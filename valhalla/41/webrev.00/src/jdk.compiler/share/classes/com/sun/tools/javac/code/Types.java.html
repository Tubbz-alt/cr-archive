<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.jvm.Target;
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
  74  * &lt;dt&gt;t&lt;/dt&gt;
  75  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  76  * &lt;dt&gt;s&lt;/dt&gt;
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
  98     final boolean injectTopInterfaceTypes;
  99     final Check chk;
 100     final Enter enter;
 101     JCDiagnostic.Factory diags;
 102     List&lt;Warner&gt; warnStack = List.nil();
 103     final Name capturedName;
 104 
 105     public final Warner noWarnings;
 106 
 107     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 108     public static Types instance(Context context) {
 109         Types instance = context.get(typesKey);
 110         if (instance == null)
 111             instance = new Types(context);
 112         return instance;
 113     }
 114 
 115     protected Types(Context context) {
 116         context.put(typesKey, this);
 117         syms = Symtab.instance(context);
 118         names = Names.instance(context);
 119         Source source = Source.instance(context);
 120         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 121         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 122         chk = Check.instance(context);
 123         enter = Enter.instance(context);
 124         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 125         messages = JavacMessages.instance(context);
 126         diags = JCDiagnostic.Factory.instance(context);
 127         noWarnings = new Warner(null);
 128         Options options = Options.instance(context);
 129         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 130         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
 131                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
 132                 Target.instance(context).hasTopInterfaces();
 133     }
 134     // &lt;/editor-fold&gt;
 135 
 136     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 137     /**
 138      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 139      * @param t a type argument, either a wildcard or a type
 140      */
 141     public Type wildUpperBound(Type t) {
 142         if (t.hasTag(WILDCARD)) {
 143             WildcardType w = (WildcardType) t;
 144             if (w.isSuperBound())
 145                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 146             else
 147                 return wildUpperBound(w.type);
 148         }
 149         else return t;
 150     }
 151 
 152     /**
 153      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 154      * @param t a type
 155      */
 156     public Type cvarUpperBound(Type t) {
 157         if (t.hasTag(TYPEVAR)) {
 158             TypeVar v = (TypeVar) t;
 159             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 160         }
 161         else return t;
 162     }
 163 
 164     /**
 165      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 166      * @param t a type argument, either a wildcard or a type
 167      */
 168     public Type wildLowerBound(Type t) {
 169         if (t.hasTag(WILDCARD)) {
 170             WildcardType w = (WildcardType) t;
 171             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 172         }
 173         else return t;
 174     }
 175 
 176     /**
 177      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 178      * @param t a type
 179      */
 180     public Type cvarLowerBound(Type t) {
 181         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 182             return cvarLowerBound(t.getLowerBound());
 183         }
 184         else return t;
 185     }
 186 
 187     /**
 188      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 189      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 190      * suitable for a method lookup.
 191      */
 192     public Type skipTypeVars(Type site, boolean capture) {
 193         while (site.hasTag(TYPEVAR)) {
 194             site = site.getUpperBound();
 195         }
 196         return capture ? capture(site) : site;
 197     }
 198     // &lt;/editor-fold&gt;
 199 
 200     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 201 
 202     /**
 203      * A projection kind. See {@link TypeProjection}
 204      */
 205     enum ProjectionKind {
 206         UPWARDS() {
 207             @Override
 208             ProjectionKind complement() {
 209                 return DOWNWARDS;
 210             }
 211         },
 212         DOWNWARDS() {
 213             @Override
 214             ProjectionKind complement() {
 215                 return UPWARDS;
 216             }
 217         };
 218 
 219         abstract ProjectionKind complement();
 220     }
 221 
 222     /**
 223      * This visitor performs upwards and downwards projections on types.
 224      *
 225      * A projection is defined as a function that takes a type T, a set of type variables V and that
 226      * produces another type S.
 227      *
 228      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 229      * and (ii) S is an upper bound of T.
 230      *
 231      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 232      * and (ii) S is a lower bound of T.
 233      *
 234      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 235      * a projection to leave its input type unchanged if it does not contain any variables in V.
 236      *
 237      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 238      * a downwards projection is not always defined.
 239      *
 240      * Examples:
 241      *
 242      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 243      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 244      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 245      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 246      */
 247     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 248 
 249         List&lt;Type&gt; vars;
 250         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 251 
 252         public TypeProjection(List&lt;Type&gt; vars) {
 253             this.vars = vars;
 254         }
 255 
 256         @Override
 257         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 258             if (t.isCompound()) {
 259                 List&lt;Type&gt; components = directSupertypes(t);
 260                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 261                 if (components == components1) return t;
 262                 else return makeIntersectionType(components1);
 263             } else {
 264                 Type outer = t.getEnclosingType();
 265                 Type outer1 = visit(outer, pkind);
 266                 List&lt;Type&gt; typarams = t.getTypeArguments();
 267                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 268                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 269                 boolean changed = false;
 270                 for (Type actual : typarams) {
 271                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 272                     if (t2.hasTag(BOT)) {
 273                         //not defined
 274                         return syms.botType;
 275                     }
 276                     typarams1.add(t2);
 277                     changed |= actual != t2;
 278                     formals = formals.tail;
 279                 }
 280                 if (outer1 == outer &amp;&amp; !changed) return t;
 281                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 282                     @Override
 283                     protected boolean needsStripping() {
 284                         return true;
 285                     }
 286                 };
 287             }
 288         }
 289 
 290         @Override
 291         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 292             Type elemtype = t.elemtype;
 293             Type elemtype1 = visit(elemtype, s);
 294             if (elemtype1 == elemtype) {
 295                 return t;
 296             } else if (elemtype1.hasTag(BOT)) {
 297                 //undefined
 298                 return syms.botType;
 299             } else {
 300                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 301                     @Override
 302                     protected boolean needsStripping() {
 303                         return true;
 304                     }
 305                 };
 306             }
 307         }
 308 
 309         @Override
 310         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 311             if (vars.contains(t)) {
 312                 if (seen.add(t)) {
 313                     try {
 314                         final Type bound;
 315                         switch (pkind) {
 316                             case UPWARDS:
 317                                 bound = t.getUpperBound();
 318                                 break;
 319                             case DOWNWARDS:
 320                                 bound = (t.getLowerBound() == null) ?
 321                                         syms.botType :
 322                                         t.getLowerBound();
 323                                 break;
 324                             default:
 325                                 Assert.error();
 326                                 return null;
 327                         }
 328                         return bound.map(this, pkind);
 329                     } finally {
 330                         seen.remove(t);
 331                     }
 332                 } else {
 333                     //cycle
 334                     return pkind == ProjectionKind.UPWARDS ?
 335                             syms.objectType : syms.botType;
 336                 }
 337             } else {
 338                 return t;
 339             }
 340         }
 341 
 342         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 343             return t.containsAny(vars) ?
 344                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 345                     t;
 346         }
 347 
 348         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 349 
 350             Type site;
 351             Type declaredBound;
 352 
 353             TypeArgumentProjection(Type site, Type declaredBound) {
 354                 this.site = site;
 355                 this.declaredBound = declaredBound;
 356             }
 357 
 358             @Override
 359             public Type visitType(Type t, ProjectionKind pkind) {
 360                 //type argument is some type containing restricted vars
 361                 if (pkind == ProjectionKind.DOWNWARDS) {
 362                     //not defined
 363                     return syms.botType;
 364                 }
 365                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 366                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 367                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 368                 BoundKind bk;
 369                 Type bound;
 370                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 371                         (declaredBound.containsAny(formals) ||
 372                          !isSubtype(declaredBound, upper))) {
 373                     bound = upper;
 374                     bk = EXTENDS;
 375                 } else if (!lower.hasTag(BOT)) {
 376                     bound = lower;
 377                     bk = SUPER;
 378                 } else {
 379                     bound = syms.objectType;
 380                     bk = UNBOUND;
 381                 }
 382                 return makeWildcard(bound, bk);
 383             }
 384 
 385             @Override
 386             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 387                 //type argument is some wildcard whose bound contains restricted vars
 388                 Type bound = syms.botType;
 389                 BoundKind bk = wt.kind;
 390                 switch (wt.kind) {
 391                     case EXTENDS:
 392                         bound = wt.type.map(TypeProjection.this, pkind);
 393                         if (bound.hasTag(BOT)) {
 394                             return syms.botType;
 395                         }
 396                         break;
 397                     case SUPER:
 398                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 399                         if (bound.hasTag(BOT)) {
 400                             bound = syms.objectType;
 401                             bk = UNBOUND;
 402                         }
 403                         break;
 404                 }
 405                 return makeWildcard(bound, bk);
 406             }
 407 
 408             private Type makeWildcard(Type bound, BoundKind bk) {
 409                 return new WildcardType(bound, bk, syms.boundClass) {
 410                     @Override
 411                     protected boolean needsStripping() {
 412                         return true;
 413                     }
 414                 };
 415             }
 416         }
 417     }
 418 
 419     /**
 420      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 421      *
 422      * @param t the type to be projected
 423      * @param vars the set of type variables to be mapped
 424      * @return the type obtained as result of the projection
 425      */
 426     public Type upward(Type t, List&lt;Type&gt; vars) {
 427         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 428     }
 429 
 430     /**
 431      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 432      * This routine is typically used to computed the input set of variables to be used during
 433      * an upwards projection (see {@link Types#upward(Type, List)}).
 434      *
 435      * @param t the type where occurrences of captured variables have to be found
 436      * @return the set of captured variables found in t
 437      */
 438     public List&lt;Type&gt; captures(Type t) {
 439         CaptureScanner cs = new CaptureScanner();
 440         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 441         cs.visit(t, captures);
 442         return List.from(captures);
 443     }
 444 
 445     /**
 446      * This visitor scans a type recursively looking for occurrences of captured type variables.
 447      */
 448     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 449 
 450         @Override
 451         public Void visitType(Type t, Set&lt;Type&gt; types) {
 452             return null;
 453         }
 454 
 455         @Override
 456         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 457             if (t.isCompound()) {
 458                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 459             } else {
 460                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 461             }
 462             return null;
 463         }
 464 
 465         @Override
 466         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 467             return visit(t.elemtype, seen);
 468         }
 469 
 470         @Override
 471         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 472             visit(t.type, seen);
 473             return null;
 474         }
 475 
 476         @Override
 477         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 478             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 479                 visit(t.getUpperBound(), seen);
 480             }
 481             return null;
 482         }
 483 
 484         @Override
 485         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 486             if (seen.add(t)) {
 487                 visit(t.getUpperBound(), seen);
 488                 visit(t.getLowerBound(), seen);
 489             }
 490             return null;
 491         }
 492     }
 493 
 494     // &lt;/editor-fold&gt;
 495 
 496     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 497     /**
 498      * Checks that all the arguments to a class are unbounded
 499      * wildcards or something else that doesn&#39;t make any restrictions
 500      * on the arguments. If a class isUnbounded, a raw super- or
 501      * subclass can be cast to it without a warning.
 502      * @param t a type
 503      * @return true iff the given type is unbounded or raw
 504      */
 505     public boolean isUnbounded(Type t) {
 506         return isUnbounded.visit(t);
 507     }
 508     // where
 509         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 510 
 511             public Boolean visitType(Type t, Void ignored) {
 512                 return true;
 513             }
 514 
 515             @Override
 516             public Boolean visitClassType(ClassType t, Void ignored) {
 517                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 518                 List&lt;Type&gt; args = t.allparams();
 519                 while (parms.nonEmpty()) {
 520                     WildcardType unb = new WildcardType(syms.objectType,
 521                                                         BoundKind.UNBOUND,
 522                                                         syms.boundClass,
 523                                                         (TypeVar)parms.head);
 524                     if (!containsType(args.head, unb))
 525                         return false;
 526                     parms = parms.tail;
 527                     args = args.tail;
 528                 }
 529                 return true;
 530             }
 531         };
 532     // &lt;/editor-fold&gt;
 533 
 534     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 535     /**
 536      * Return the least specific subtype of t that starts with symbol
 537      * sym.  If none exists, return null.  The least specific subtype
 538      * is determined as follows:
 539      *
 540      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 541      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 542      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 543      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 544      * returned.
 545      */
 546     public Type asSub(Type t, Symbol sym) {
 547         return asSub.visit(t, sym);
 548     }
 549     // where
 550         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 551 
 552             public Type visitType(Type t, Symbol sym) {
 553                 return null;
 554             }
 555 
 556             @Override
 557             public Type visitClassType(ClassType t, Symbol sym) {
 558                 if (t.tsym == sym)
 559                     return t;
 560                 Type base = asSuper(sym.type, t.tsym);
 561                 if (base == null)
 562                     return null;
 563                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 564                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 565                 try {
 566                     adapt(base, t, from, to);
 567                 } catch (AdaptFailure ex) {
 568                     return null;
 569                 }
 570                 Type res = subst(sym.type, from.toList(), to.toList());
 571                 if (!isSubtype(res, t))
 572                     return null;
 573                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 574                 for (List&lt;Type&gt; l = sym.type.allparams();
 575                      l.nonEmpty(); l = l.tail)
 576                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 577                         openVars.append(l.head);
 578                 if (openVars.nonEmpty()) {
 579                     if (t.isRaw()) {
 580                         // The subtype of a raw type is raw
 581                         res = erasure(res);
 582                     } else {
 583                         // Unbound type arguments default to ?
 584                         List&lt;Type&gt; opens = openVars.toList();
 585                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 586                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 587                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 588                                                        syms.boundClass, (TypeVar) iter.head));
 589                         }
 590                         res = subst(res, opens, qs.toList());
 591                     }
 592                 }
 593                 return res;
 594             }
 595 
 596             @Override
 597             public Type visitErrorType(ErrorType t, Symbol sym) {
 598                 return t;
 599             }
 600         };
 601     // &lt;/editor-fold&gt;
 602 
 603     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 604     /**
 605      * Is t a subtype of or convertible via boxing/unboxing
 606      * conversion to s?
 607      */
 608     public boolean isConvertible(Type t, Type s, Warner warn) {
 609         if (t.hasTag(ERROR)) {
 610             return true;
 611         }
 612 
 613         boolean tValue = t.isValue();
 614         boolean sValue = s.isValue();
 615         if (tValue != sValue) {
 616             return tValue ?
 617                     isSubtype(t.referenceProjection(), s) :
 618                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());
 619         }
 620 
 621         boolean tPrimitive = t.isPrimitive();
 622         boolean sPrimitive = s.isPrimitive();
 623         if (tPrimitive == sPrimitive) {
 624             return isSubtypeUnchecked(t, s, warn);
 625         }
 626         boolean tUndet = t.hasTag(UNDETVAR);
 627         boolean sUndet = s.hasTag(UNDETVAR);
 628 
 629         if (tUndet || sUndet) {
 630             return tUndet ?
 631                     isSubtype(t, boxedTypeOrType(s)) :
 632                     isSubtype(boxedTypeOrType(t), s);
 633         }
 634 
 635         return tPrimitive
 636             ? isSubtype(boxedClass(t).type, s)
 637             : isSubtype(unboxedType(t), s);
 638     }
 639 
 640     /**
 641      * Is t a subtype of or convertible via boxing/unboxing
 642      * conversions to s?
 643      */
 644     public boolean isConvertible(Type t, Type s) {
 645         return isConvertible(t, s, noWarnings);
 646     }
 647     // &lt;/editor-fold&gt;
 648 
 649     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 650 
 651     /**
 652      * Exception used to report a function descriptor lookup failure. The exception
 653      * wraps a diagnostic that can be used to generate more details error
 654      * messages.
 655      */
 656     public static class FunctionDescriptorLookupError extends RuntimeException {
 657         private static final long serialVersionUID = 0;
 658 
 659         transient JCDiagnostic diagnostic;
 660 
 661         FunctionDescriptorLookupError() {
 662             this.diagnostic = null;
 663         }
 664 
 665         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 666             this.diagnostic = diag;
 667             return this;
 668         }
 669 
 670         public JCDiagnostic getDiagnostic() {
 671             return diagnostic;
 672         }
 673     }
 674 
 675     /**
 676      * A cache that keeps track of function descriptors associated with given
 677      * functional interfaces.
 678      */
 679     class DescriptorCache {
 680 
 681         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 682 
 683         class FunctionDescriptor {
 684             Symbol descSym;
 685 
 686             FunctionDescriptor(Symbol descSym) {
 687                 this.descSym = descSym;
 688             }
 689 
 690             public Symbol getSymbol() {
 691                 return descSym;
 692             }
 693 
 694             public Type getType(Type site) {
 695                 site = removeWildcards(site);
 696                 if (site.isIntersection()) {
 697                     IntersectionClassType ict = (IntersectionClassType)site;
 698                     for (Type component : ict.getExplicitComponents()) {
 699                         if (!chk.checkValidGenericType(component)) {
 700                             //if the inferred functional interface type is not well-formed,
 701                             //or if it&#39;s not a subtype of the original target, issue an error
 702                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 703                         }
 704                     }
 705                 } else {
 706                     if (!chk.checkValidGenericType(site)) {
 707                         //if the inferred functional interface type is not well-formed,
 708                         //or if it&#39;s not a subtype of the original target, issue an error
 709                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 710                     }
 711                 }
 712                 return memberType(site, descSym);
 713             }
 714         }
 715 
 716         class Entry {
 717             final FunctionDescriptor cachedDescRes;
 718             final int prevMark;
 719 
 720             public Entry(FunctionDescriptor cachedDescRes,
 721                     int prevMark) {
 722                 this.cachedDescRes = cachedDescRes;
 723                 this.prevMark = prevMark;
 724             }
 725 
 726             boolean matches(int mark) {
 727                 return  this.prevMark == mark;
 728             }
 729         }
 730 
 731         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 732             Entry e = _map.get(origin);
 733             CompoundScope members = membersClosure(origin.type, false);
 734             if (e == null ||
 735                     !e.matches(members.getMark())) {
 736                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 737                 _map.put(origin, new Entry(descRes, members.getMark()));
 738                 return descRes;
 739             }
 740             else {
 741                 return e.cachedDescRes;
 742             }
 743         }
 744 
 745         /**
 746          * Compute the function descriptor associated with a given functional interface
 747          */
 748         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 749                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 750             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0) {
 751                 //t must be an interface
 752                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 753             }
 754 
 755             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 756             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 757                 Type mtype = memberType(origin.type, sym);
 758                 if (abstracts.isEmpty()) {
 759                     abstracts.append(sym);
 760                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 761                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 762                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 763                             .map(msym -&gt; memberType(origin.type, msym))
 764                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 765                         abstracts.append(sym);
 766                     }
 767                 } else {
 768                     //the target method(s) should be the only abstract members of t
 769                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 770                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 771                 }
 772             }
 773             if (abstracts.isEmpty()) {
 774                 //t must define a suitable non-generic method
 775                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 776                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 777             } else if (abstracts.size() == 1) {
 778                 return new FunctionDescriptor(abstracts.first());
 779             } else { // size &gt; 1
 780                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 781                 if (descRes == null) {
 782                     //we can get here if the functional interface is ill-formed
 783                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 784                     for (Symbol desc : abstracts) {
 785                         String key = desc.type.getThrownTypes().nonEmpty() ?
 786                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 787                         descriptors.append(diags.fragment(key, desc.name,
 788                                 desc.type.getParameterTypes(),
 789                                 desc.type.getReturnType(),
 790                                 desc.type.getThrownTypes()));
 791                     }
 792                     JCDiagnostic msg =
 793                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 794                                                                                        origin));
 795                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 796                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 797                     throw failure(incompatibleDescriptors);
 798                 }
 799                 return descRes;
 800             }
 801         }
 802 
 803         /**
 804          * Compute a synthetic type for the target descriptor given a list
 805          * of override-equivalent methods in the functional interface type.
 806          * The resulting method type is a method type that is override-equivalent
 807          * and return-type substitutable with each method in the original list.
 808          */
 809         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 810             return mergeAbstracts(methodSyms, origin.type, false)
 811                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 812                         @Override
 813                         public Type getType(Type origin) {
 814                             Type mt = memberType(origin, getSymbol());
 815                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 816                         }
 817                     }).orElse(null);
 818         }
 819 
 820         FunctionDescriptorLookupError failure(String msg, Object... args) {
 821             return failure(diags.fragment(msg, args));
 822         }
 823 
 824         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 825             return new FunctionDescriptorLookupError().setMessage(diag);
 826         }
 827     }
 828 
 829     private DescriptorCache descCache = new DescriptorCache();
 830 
 831     /**
 832      * Find the method descriptor associated to this class symbol - if the
 833      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 834      */
 835     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 836         return descCache.get(origin).getSymbol();
 837     }
 838 
 839     /**
 840      * Find the type of the method descriptor associated to this class symbol -
 841      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 842      */
 843     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 844         return descCache.get(origin.tsym).getType(origin);
 845     }
 846 
 847     /**
 848      * Is given type a functional interface?
 849      */
 850     public boolean isFunctionalInterface(TypeSymbol tsym) {
 851         try {
 852             findDescriptorSymbol(tsym);
 853             return true;
 854         } catch (FunctionDescriptorLookupError ex) {
 855             return false;
 856         }
 857     }
 858 
 859     public boolean isFunctionalInterface(Type site) {
 860         try {
 861             findDescriptorType(site);
 862             return true;
 863         } catch (FunctionDescriptorLookupError ex) {
 864             return false;
 865         }
 866     }
 867 
 868     public Type removeWildcards(Type site) {
 869         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 870             //compute non-wildcard parameterization - JLS 9.9
 871             List&lt;Type&gt; actuals = site.getTypeArguments();
 872             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 873             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 874             for (Type formal : formals) {
 875                 Type actual = actuals.head;
 876                 Type bound = formal.getUpperBound();
 877                 if (actuals.head.hasTag(WILDCARD)) {
 878                     WildcardType wt = (WildcardType)actual;
 879                     //check that bound does not contain other formals
 880                     if (bound.containsAny(formals)) {
 881                         targs.add(wt.type);
 882                     } else {
 883                         //compute new type-argument based on declared bound and wildcard bound
 884                         switch (wt.kind) {
 885                             case UNBOUND:
 886                                 targs.add(bound);
 887                                 break;
 888                             case EXTENDS:
 889                                 targs.add(glb(bound, wt.type));
 890                                 break;
 891                             case SUPER:
 892                                 targs.add(wt.type);
 893                                 break;
 894                             default:
 895                                 Assert.error(&quot;Cannot get here!&quot;);
 896                         }
 897                     }
 898                 } else {
 899                     //not a wildcard - the new type argument remains unchanged
 900                     targs.add(actual);
 901                 }
 902                 actuals = actuals.tail;
 903             }
 904             return subst(site.tsym.type, formals, targs.toList());
 905         } else {
 906             return site;
 907         }
 908     }
 909 
 910     /**
 911      * Create a symbol for a class that implements a given functional interface
 912      * and overrides its functional descriptor. This routine is used for two
 913      * main purposes: (i) checking well-formedness of a functional interface;
 914      * (ii) perform functional interface bridge calculation.
 915      */
 916     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 917         if (target == null || target == syms.unknownType) {
 918             return null;
 919         }
 920         Symbol descSym = findDescriptorSymbol(target.tsym);
 921         Type descType = findDescriptorType(target);
 922         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 923         csym.completer = Completer.NULL_COMPLETER;
 924         csym.members_field = WriteableScope.create(csym);
 925         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 926         csym.members_field.enter(instDescSym);
 927         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 928         ctype.supertype_field = syms.objectType;
 929         ctype.interfaces_field = target.isIntersection() ?
 930                 directSupertypes(target) :
 931                 List.of(target);
 932         csym.type = ctype;
 933         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 934         return csym;
 935     }
 936 
 937     /**
 938      * Find the minimal set of methods that are overridden by the functional
 939      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 940      * erased signatures.
 941      */
 942     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 943         Assert.check(isFunctionalInterface(origin));
 944         Symbol descSym = findDescriptorSymbol(origin);
 945         CompoundScope members = membersClosure(origin.type, false);
 946         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 947         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 948             if (m2 == descSym) continue;
 949             else if (descSym.overrides(m2, origin, Types.this, false)) {
 950                 for (Symbol m3 : overridden) {
 951                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 952                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 953                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 954                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 955                         continue outer;
 956                     }
 957                 }
 958                 overridden.add(m2);
 959             }
 960         }
 961         return overridden.toList();
 962     }
 963     //where
 964         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 965             public boolean accepts(Symbol t) {
 966                 return t.kind == MTH &amp;&amp;
 967                         t.name != names.init &amp;&amp;
 968                         t.name != names.clinit &amp;&amp;
 969                         (t.flags() &amp; SYNTHETIC) == 0;
 970             }
 971         };
 972         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 973             //a symbol will be completed from a classfile if (a) symbol has
 974             //an associated file object with CLASS kind and (b) the symbol has
 975             //not been entered
 976             if (origin.classfile != null &amp;&amp;
 977                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 978                     enter.getEnv(origin) == null) {
 979                 return false;
 980             }
 981             if (origin == s) {
 982                 return true;
 983             }
 984             for (Type t : interfaces(origin.type)) {
 985                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 986                     return true;
 987                 }
 988             }
 989             return false;
 990         }
 991     // &lt;/editor-fold&gt;
 992 
 993    /**
 994     * Scope filter used to skip methods that should be ignored (such as methods
 995     * overridden by j.l.Object) during function interface conversion interface check
 996     */
 997     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 998 
 999        TypeSymbol origin;
1000 
1001        DescriptorFilter(TypeSymbol origin) {
1002            this.origin = origin;
1003        }
1004 
1005        @Override
1006        public boolean accepts(Symbol sym) {
1007            return sym.kind == MTH &amp;&amp;
1008                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1009                    !overridesObjectMethod(origin, sym) &amp;&amp;
1010                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1011        }
1012     }
1013 
1014     public boolean isValue(Type t) {
1015         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1016     }
1017 
1018     public boolean isValueBased(Type t) {
1019         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1020     }
1021 
1022     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1023     /**
1024      * Is t an unchecked subtype of s?
1025      */
1026     public boolean isSubtypeUnchecked(Type t, Type s) {
1027         return isSubtypeUnchecked(t, s, noWarnings);
1028     }
1029     /**
1030      * Is t an unchecked subtype of s?
1031      */
1032     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1033         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1034         if (result) {
1035             checkUnsafeVarargsConversion(t, s, warn);
1036         }
1037         return result;
1038     }
1039     //where
1040         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1041             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1042                 if (((ArrayType)t).elemtype.isPrimitive()) {
1043                     return isSameType(elemtype(t), elemtype(s));
1044                 } else {
1045                     // if T.ref &lt;: S, then T[] &lt;: S[]
1046                     Type es = elemtype(s);
1047                     Type et = elemtype(t);
1048                     if (isValue(et)) {
1049                         et = et.referenceProjection();
1050                         if (isValue(es))
1051                             es = es.referenceProjection();  // V &lt;: V, surely
1052                     }
1053                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1054                         return false;
1055                     return true;
1056                 }
1057             } else if (isSubtype(t, s, capture)) {
1058                 return true;
1059             } else if (t.hasTag(TYPEVAR)) {
1060                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1061             } else if (!s.isRaw()) {
1062                 Type t2 = asSuper(t, s.tsym);
1063                 if (t2 != null &amp;&amp; t2.isRaw()) {
1064                     if (isReifiable(s)) {
1065                         warn.silentWarn(LintCategory.UNCHECKED);
1066                     } else {
1067                         warn.warn(LintCategory.UNCHECKED);
1068                     }
1069                     return true;
1070                 }
1071             }
1072             return false;
1073         }
1074 
1075         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1076             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1077                 return;
1078             }
1079             ArrayType from = (ArrayType)t;
1080             boolean shouldWarn = false;
1081             switch (s.getTag()) {
1082                 case ARRAY:
1083                     ArrayType to = (ArrayType)s;
1084                     shouldWarn = from.isVarargs() &amp;&amp;
1085                             !to.isVarargs() &amp;&amp;
1086                             !isReifiable(from);
1087                     break;
1088                 case CLASS:
1089                     shouldWarn = from.isVarargs();
1090                     break;
1091             }
1092             if (shouldWarn) {
1093                 warn.warn(LintCategory.VARARGS);
1094             }
1095         }
1096 
1097     /**
1098      * Is t a subtype of s?&lt;br&gt;
1099      * (not defined for Method and ForAll types)
1100      */
1101     final public boolean isSubtype(Type t, Type s) {
1102         return isSubtype(t, s, true);
1103     }
1104     final public boolean isSubtypeNoCapture(Type t, Type s) {
1105         return isSubtype(t, s, false);
1106     }
1107     public boolean isSubtype(Type t, Type s, boolean capture) {
1108         if (t.equalsIgnoreMetadata(s))
1109             return true;
1110         if (s.isPartial())
1111             return isSuperType(s, t);
1112 
1113         if (s.isCompound()) {
1114             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1115                 if (!isSubtype(t, s2, capture))
1116                     return false;
1117             }
1118             return true;
1119         }
1120 
1121         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1122         // for inference variables and intersections, we need to keep &#39;s&#39;
1123         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1124         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1125             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1126             Type lower = cvarLowerBound(wildLowerBound(s));
1127             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1128                 return isSubtype(capture ? capture(t) : t, lower, false);
1129         }
1130 
1131         return isSubtype.visit(capture ? capture(t) : t, s);
1132     }
1133     // where
1134         private TypeRelation isSubtype = new TypeRelation()
1135         {
1136             @Override
1137             public Boolean visitType(Type t, Type s) {
1138                 switch (t.getTag()) {
1139                  case BYTE:
1140                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1141                  case CHAR:
1142                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1143                  case SHORT: case INT: case LONG:
1144                  case FLOAT: case DOUBLE:
1145                      return t.getTag().isSubRangeOf(s.getTag());
1146                  case BOOLEAN: case VOID:
1147                      return t.hasTag(s.getTag());
1148                  case TYPEVAR:
1149                      return isSubtypeNoCapture(t.getUpperBound(), s);
1150                  case BOT:
1151                      return
1152                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||
1153                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1154                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1155                  case NONE:
1156                      return false;
1157                  default:
1158                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1159                  }
1160             }
1161 
1162             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1163 
1164             private boolean containsTypeRecursive(Type t, Type s) {
1165                 TypePair pair = new TypePair(t, s);
1166                 if (cache.add(pair)) {
1167                     try {
1168                         return containsType(t.getTypeArguments(),
1169                                             s.getTypeArguments());
1170                     } finally {
1171                         cache.remove(pair);
1172                     }
1173                 } else {
1174                     return containsType(t.getTypeArguments(),
1175                                         rewriteSupers(s).getTypeArguments());
1176                 }
1177             }
1178 
1179             private Type rewriteSupers(Type t) {
1180                 if (!t.isParameterized())
1181                     return t;
1182                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1183                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1184                 adaptSelf(t, from, to);
1185                 if (from.isEmpty())
1186                     return t;
1187                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1188                 boolean changed = false;
1189                 for (Type orig : to.toList()) {
1190                     Type s = rewriteSupers(orig);
1191                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1192                         s = new WildcardType(syms.objectType,
1193                                              BoundKind.UNBOUND,
1194                                              syms.boundClass,
1195                                              s.getMetadata());
1196                         changed = true;
1197                     } else if (s != orig) {
1198                         s = new WildcardType(wildUpperBound(s),
1199                                              BoundKind.EXTENDS,
1200                                              syms.boundClass,
1201                                              s.getMetadata());
1202                         changed = true;
1203                     }
1204                     rewrite.append(s);
1205                 }
1206                 if (changed)
1207                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1208                 else
1209                     return t;
1210             }
1211 
1212             @Override
1213             public Boolean visitClassType(ClassType t, Type s) {
1214                 Type sup = asSuper(t, s.tsym);
1215                 if (sup == null) return false;
1216                 // If t is an intersection, sup might not be a class type
1217                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1218                 return sup.tsym == s.tsym
1219                      // Check type variable containment
1220                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1221                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1222                                           s.getEnclosingType());
1223             }
1224 
1225             @Override
1226             public Boolean visitArrayType(ArrayType t, Type s) {
1227                 if (s.hasTag(ARRAY)) {
1228                     if (t.elemtype.isPrimitive())
1229                         return isSameType(t.elemtype, elemtype(s));
1230                     else {
1231                         // if T.ref &lt;: S, then T[] &lt;: S[]
1232                         Type es = elemtype(s);
1233                         Type et = elemtype(t);
1234                         if (isValue(et)) {
1235                             et = et.referenceProjection();
1236                             if (isValue(es))
1237                                 es = es.referenceProjection();  // V &lt;: V, surely
1238                         }
1239                         return isSubtypeNoCapture(et, es);
1240                     }
1241                 }
1242 
1243                 if (s.hasTag(CLASS)) {
1244                     Name sname = s.tsym.getQualifiedName();
1245                     return sname == names.java_lang_Object
1246                         || sname == names.java_lang_Cloneable
1247                         || sname == names.java_io_Serializable
1248                         || (injectTopInterfaceTypes &amp;&amp; sname == names.java_lang_IdentityObject);
1249                 }
1250 
1251                 return false;
1252             }
1253 
1254             @Override
1255             public Boolean visitUndetVar(UndetVar t, Type s) {
1256                 //todo: test against origin needed? or replace with substitution?
1257                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1258                     return true;
1259                 } else if (s.hasTag(BOT)) {
1260                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1261                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1262                     return false;
1263                 }
1264 
1265                 t.addBound(InferenceBound.UPPER, s, Types.this);
1266                 return true;
1267             }
1268 
1269             @Override
1270             public Boolean visitErrorType(ErrorType t, Type s) {
1271                 return true;
1272             }
1273         };
1274 
1275     /**
1276      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1277      * (not defined for Method and ForAll types)&lt;br&gt;
1278      * Allows unchecked conversions.
1279      */
1280     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1281         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1282             if (!isSubtypeUnchecked(t, l.head, warn))
1283                 return false;
1284         return true;
1285     }
1286 
1287     /**
1288      * Are corresponding elements of ts subtypes of ss?  If lists are
1289      * of different length, return false.
1290      */
1291     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1292         while (ts.tail != null &amp;&amp; ss.tail != null
1293                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1294                isSubtype(ts.head, ss.head)) {
1295             ts = ts.tail;
1296             ss = ss.tail;
1297         }
1298         return ts.tail == null &amp;&amp; ss.tail == null;
1299         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1300     }
1301 
1302     /**
1303      * Are corresponding elements of ts subtypes of ss, allowing
1304      * unchecked conversions?  If lists are of different length,
1305      * return false.
1306      **/
1307     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1308         while (ts.tail != null &amp;&amp; ss.tail != null
1309                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1310                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1311             ts = ts.tail;
1312             ss = ss.tail;
1313         }
1314         return ts.tail == null &amp;&amp; ss.tail == null;
1315         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1316     }
1317     // &lt;/editor-fold&gt;
1318 
1319     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1320     /**
1321      * Is t a supertype of s?
1322      */
1323     public boolean isSuperType(Type t, Type s) {
1324         switch (t.getTag()) {
1325         case ERROR:
1326             return true;
1327         case UNDETVAR: {
1328             UndetVar undet = (UndetVar)t;
1329             if (t == s ||
1330                 undet.qtype == s ||
1331                 s.hasTag(ERROR) ||
1332                 s.hasTag(BOT)) {
1333                 return true;
1334             }
1335             undet.addBound(InferenceBound.LOWER, s, this);
1336             return true;
1337         }
1338         default:
1339             return isSubtype(s, t);
1340         }
1341     }
1342     // &lt;/editor-fold&gt;
1343 
1344     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1345     /**
1346      * Are corresponding elements of the lists the same type?  If
1347      * lists are of different length, return false.
1348      */
1349     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1350         while (ts.tail != null &amp;&amp; ss.tail != null
1351                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1352                isSameType(ts.head, ss.head)) {
1353             ts = ts.tail;
1354             ss = ss.tail;
1355         }
1356         return ts.tail == null &amp;&amp; ss.tail == null;
1357         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1358     }
1359 
1360     /**
1361      * A polymorphic signature method (JLS 15.12.3) is a method that
1362      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1363      *  (ii) takes a single variable arity parameter;
1364      * (iii) whose declared type is Object[];
1365      *  (iv) has any return type, Object signifying a polymorphic return type; and
1366      *   (v) is native.
1367     */
1368    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1369        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1370        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1371               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1372                argtypes.length() == 1 &amp;&amp;
1373                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1374                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1375    }
1376 
1377     /**
1378      * Is t the same type as s?
1379      */
1380     public boolean isSameType(Type t, Type s) {
1381         return isSameTypeVisitor.visit(t, s);
1382     }
1383     // where
1384 
1385         /**
1386          * Type-equality relation - type variables are considered
1387          * equals if they share the same object identity.
1388          */
1389         TypeRelation isSameTypeVisitor = new TypeRelation() {
1390 
1391             public Boolean visitType(Type t, Type s) {
1392                 if (t.equalsIgnoreMetadata(s))
1393                     return true;
1394 
1395                 if (s.isPartial())
1396                     return visit(s, t);
1397 
1398                 switch (t.getTag()) {
1399                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1400                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1401                     return t.hasTag(s.getTag());
1402                 case TYPEVAR: {
1403                     if (s.hasTag(TYPEVAR)) {
1404                         //type-substitution does not preserve type-var types
1405                         //check that type var symbols and bounds are indeed the same
1406                         return t == s;
1407                     }
1408                     else {
1409                         //special case for s == ? super X, where upper(s) = u
1410                         //check that u == t, where u has been set by Type.withTypeVar
1411                         return s.isSuperBound() &amp;&amp;
1412                                 !s.isExtendsBound() &amp;&amp;
1413                                 visit(t, wildUpperBound(s));
1414                     }
1415                 }
1416                 default:
1417                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1418                 }
1419             }
1420 
1421             @Override
1422             public Boolean visitWildcardType(WildcardType t, Type s) {
1423                 if (!s.hasTag(WILDCARD)) {
1424                     return false;
1425                 } else {
1426                     WildcardType t2 = (WildcardType)s;
1427                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1428                             isSameType(t.type, t2.type);
1429                 }
1430             }
1431 
1432             @Override
1433             public Boolean visitClassType(ClassType t, Type s) {
1434                 if (t == s)
1435                     return true;
1436 
1437                 if (s.isPartial())
1438                     return visit(s, t);
1439 
1440                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1441                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1442 
1443                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1444                     if (!visit(supertype(t), supertype(s)))
1445                         return false;
1446 
1447                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1448                     for (Type ti : interfaces(t)) {
1449                         if (tMap.containsKey(ti)) {
1450                             throw new AssertionError(&quot;Malformed intersection&quot;);
1451                         }
1452                         tMap.put(ti.tsym, ti);
1453                     }
1454                     for (Type si : interfaces(s)) {
1455                         if (!tMap.containsKey(si.tsym))
1456                             return false;
1457                         Type ti = tMap.remove(si.tsym);
1458                         if (!visit(ti, si))
1459                             return false;
1460                     }
1461                     return tMap.isEmpty();
1462                 }
1463                 return t.tsym == s.tsym
1464                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1465                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1466             }
1467 
1468             @Override
1469             public Boolean visitArrayType(ArrayType t, Type s) {
1470                 if (t == s)
1471                     return true;
1472 
1473                 if (s.isPartial())
1474                     return visit(s, t);
1475 
1476                 return s.hasTag(ARRAY)
1477                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1478             }
1479 
1480             @Override
1481             public Boolean visitMethodType(MethodType t, Type s) {
1482                 // isSameType for methods does not take thrown
1483                 // exceptions into account!
1484                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1485             }
1486 
1487             @Override
1488             public Boolean visitPackageType(PackageType t, Type s) {
1489                 return t == s;
1490             }
1491 
1492             @Override
1493             public Boolean visitForAll(ForAll t, Type s) {
1494                 if (!s.hasTag(FORALL)) {
1495                     return false;
1496                 }
1497 
1498                 ForAll forAll = (ForAll)s;
1499                 return hasSameBounds(t, forAll)
1500                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1501             }
1502 
1503             @Override
1504             public Boolean visitUndetVar(UndetVar t, Type s) {
1505                 if (s.hasTag(WILDCARD)) {
1506                     // FIXME, this might be leftovers from before capture conversion
1507                     return false;
1508                 }
1509 
1510                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1511                     return true;
1512                 }
1513 
1514                 t.addBound(InferenceBound.EQ, s, Types.this);
1515 
1516                 return true;
1517             }
1518 
1519             @Override
1520             public Boolean visitErrorType(ErrorType t, Type s) {
1521                 return true;
1522             }
1523         };
1524 
1525     // &lt;/editor-fold&gt;
1526 
1527     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1528     public boolean containedBy(Type t, Type s) {
1529         switch (t.getTag()) {
1530         case UNDETVAR:
1531             if (s.hasTag(WILDCARD)) {
1532                 UndetVar undetvar = (UndetVar)t;
1533                 WildcardType wt = (WildcardType)s;
1534                 switch(wt.kind) {
1535                     case UNBOUND:
1536                         break;
1537                     case EXTENDS: {
1538                         Type bound = wildUpperBound(s);
1539                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1540                         break;
1541                     }
1542                     case SUPER: {
1543                         Type bound = wildLowerBound(s);
1544                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1545                         break;
1546                     }
1547                 }
1548                 return true;
1549             } else {
1550                 return isSameType(t, s);
1551             }
1552         case ERROR:
1553             return true;
1554         default:
1555             return containsType(s, t);
1556         }
1557     }
1558 
1559     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1560         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1561                &amp;&amp; containsType(ts.head, ss.head)) {
1562             ts = ts.tail;
1563             ss = ss.tail;
1564         }
1565         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1566     }
1567 
1568     /**
1569      * Check if t contains s.
1570      *
1571      * &lt;p&gt;T contains S if:
1572      *
1573      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1574      *
1575      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1576      * is,
1577      *
1578      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1579      *
1580      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1581      * recursion.  Thus we must somehow break that recursion.  Notice
1582      * that containsType() is only called from ClassType.isSubtype().
1583      * Since the arguments have already been checked against their
1584      * bounds, we know:
1585      *
1586      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1587      *
1588      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1589      *
1590      * @param t a type
1591      * @param s a type
1592      */
1593     public boolean containsType(Type t, Type s) {
1594         return containsType.visit(t, s);
1595     }
1596     // where
1597         private TypeRelation containsType = new TypeRelation() {
1598 
1599             public Boolean visitType(Type t, Type s) {
1600                 if (s.isPartial())
1601                     return containedBy(s, t);
1602                 else
1603                     return isSameType(t, s);
1604             }
1605 
1606 //            void debugContainsType(WildcardType t, Type s) {
1607 //                System.err.println();
1608 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1609 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1610 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1611 //                                  t.isSuperBound()
1612 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1613 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1614 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1615 //                                  t.isExtendsBound()
1616 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1617 //                System.err.println();
1618 //            }
1619 
1620             @Override
1621             public Boolean visitWildcardType(WildcardType t, Type s) {
1622                 if (s.isPartial())
1623                     return containedBy(s, t);
1624                 else {
1625 //                    debugContainsType(t, s);
1626 
1627                     // -----------------------------------  Unspecified behavior ----------------
1628 
1629                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?
1630                        It seems widening must be applied here to answer yes to compile some common code
1631                        patterns.
1632                     */
1633 
1634                     // ---------------------------------------------------------------------------
1635                     return isSameWildcard(t, s)
1636                         || isCaptureOf(s, t)
1637                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1638                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1639                 }
1640             }
1641 
1642             @Override
1643             public Boolean visitUndetVar(UndetVar t, Type s) {
1644                 if (!s.hasTag(WILDCARD)) {
1645                     return isSameType(t, s);
1646                 } else {
1647                     return false;
1648                 }
1649             }
1650 
1651             @Override
1652             public Boolean visitErrorType(ErrorType t, Type s) {
1653                 return true;
1654             }
1655         };
1656 
1657     public boolean isCaptureOf(Type s, WildcardType t) {
1658         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1659             return false;
1660         return isSameWildcard(t, ((CapturedType)s).wildcard);
1661     }
1662 
1663     public boolean isSameWildcard(WildcardType t, Type s) {
1664         if (!s.hasTag(WILDCARD))
1665             return false;
1666         WildcardType w = (WildcardType)s;
1667         return w.kind == t.kind &amp;&amp; w.type == t.type;
1668     }
1669 
1670     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1671         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1672                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1673             ts = ts.tail;
1674             ss = ss.tail;
1675         }
1676         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1677     }
1678     // &lt;/editor-fold&gt;
1679 
1680     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1681     public boolean isCastable(Type t, Type s) {
1682         return isCastable(t, s, noWarnings);
1683     }
1684 
1685     /**
1686      * Is t is castable to s?&lt;br&gt;
1687      * s is assumed to be an erased type.&lt;br&gt;
1688      * (not defined for Method and ForAll types).
1689      */
1690     public boolean isCastable(Type t, Type s, Warner warn) {
1691         if (t == s)
1692             return true;
1693         if (t.isPrimitive() != s.isPrimitive()) {
1694             t = skipTypeVars(t, false);
1695             return (isConvertible(t, s, warn)
1696                     || (s.isPrimitive() &amp;&amp;
1697                         isSubtype(boxedClass(s).type, t)));
1698         }
1699         if (warn != warnStack.head) {
1700             try {
1701                 warnStack = warnStack.prepend(warn);
1702                 checkUnsafeVarargsConversion(t, s, warn);
1703                 return isCastable.visit(t,s);
1704             } finally {
1705                 warnStack = warnStack.tail;
1706             }
1707         } else {
1708             return isCastable.visit(t,s);
1709         }
1710     }
1711     // where
1712         private TypeRelation isCastable = new TypeRelation() {
1713 
1714             public Boolean visitType(Type t, Type s) {
1715                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1716                     return true;
1717 
1718                 switch (t.getTag()) {
1719                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1720                 case DOUBLE:
1721                     return s.isNumeric();
1722                 case BOOLEAN:
1723                     return s.hasTag(BOOLEAN);
1724                 case VOID:
1725                     return false;
1726                 case BOT:
1727                     return isSubtype(t, s);
1728                 default:
1729                     throw new AssertionError();
1730                 }
1731             }
1732 
1733             @Override
1734             public Boolean visitWildcardType(WildcardType t, Type s) {
1735                 return isCastable(wildUpperBound(t), s, warnStack.head);
1736             }
1737 
1738             @Override
1739             public Boolean visitClassType(ClassType t, Type s) {
1740                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1741                     return true;
1742 
1743                 if (s.hasTag(TYPEVAR)) {
1744                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1745                         warnStack.head.warn(LintCategory.UNCHECKED);
1746                         return true;
1747                     } else {
1748                         return false;
1749                     }
1750                 }
1751 
1752                 if (t.isCompound() || s.isCompound()) {
1753                     return !t.isCompound() ?
1754                             visitCompoundType((ClassType)s, t, true) :
1755                             visitCompoundType(t, s, false);
1756                 }
1757 
1758                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
1759                     if (isValue(t)) {
1760                         // (s) Value ? == (s) Value.ref
1761                         t = t.referenceProjection();
1762                     }
1763                     if (isValue(s)) {
1764                         // (Value) t ? == (Value.ref) t
1765                         s = s.referenceProjection();
1766                     }
1767                     boolean upcast;
1768                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1769                         || isSubtype(erasure(s), erasure(t))) {
1770                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1771                             if (!isReifiable(s))
1772                                 warnStack.head.warn(LintCategory.UNCHECKED);
1773                             return true;
1774                         } else if (s.isRaw()) {
1775                             return true;
1776                         } else if (t.isRaw()) {
1777                             if (!isUnbounded(s))
1778                                 warnStack.head.warn(LintCategory.UNCHECKED);
1779                             return true;
1780                         }
1781                         // Assume |a| &lt;: |b|
1782                         final Type a = upcast ? t : s;
1783                         final Type b = upcast ? s : t;
1784                         final boolean HIGH = true;
1785                         final boolean LOW = false;
1786                         final boolean DONT_REWRITE_TYPEVARS = false;
1787                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1788                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1789                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1790                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1791                         Type lowSub = asSub(bLow, aLow.tsym);
1792                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1793                         if (highSub == null) {
1794                             final boolean REWRITE_TYPEVARS = true;
1795                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1796                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1797                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1798                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1799                             lowSub = asSub(bLow, aLow.tsym);
1800                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1801                         }
1802                         if (highSub != null) {
1803                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1804                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1805                             }
1806                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1807                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1808                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1809                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1810                                 if (upcast ? giveWarning(a, b) :
1811                                     giveWarning(b, a))
1812                                     warnStack.head.warn(LintCategory.UNCHECKED);
1813                                 return true;
1814                             }
1815                         }
1816                         if (isReifiable(s))
1817                             return isSubtypeUnchecked(a, b);
1818                         else
1819                             return isSubtypeUnchecked(a, b, warnStack.head);
1820                     }
1821 
1822                     // Sidecast
1823                     if (s.hasTag(CLASS)) {
1824                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1825                             return ((t.tsym.flags() &amp; FINAL) == 0)
1826                                 ? sideCast(t, s, warnStack.head)
1827                                 : sideCastFinal(t, s, warnStack.head);
1828                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1829                             return ((s.tsym.flags() &amp; FINAL) == 0)
1830                                 ? sideCast(t, s, warnStack.head)
1831                                 : sideCastFinal(t, s, warnStack.head);
1832                         } else {
1833                             // unrelated class types
1834                             return false;
1835                         }
1836                     }
1837                 }
1838                 return false;
1839             }
1840 
1841             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1842                 Warner warn = noWarnings;
1843                 for (Type c : directSupertypes(ct)) {
1844                     warn.clear();
1845                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1846                         return false;
1847                 }
1848                 if (warn.hasLint(LintCategory.UNCHECKED))
1849                     warnStack.head.warn(LintCategory.UNCHECKED);
1850                 return true;
1851             }
1852 
1853             @Override
1854             public Boolean visitArrayType(ArrayType t, Type s) {
1855                 switch (s.getTag()) {
1856                 case ERROR:
1857                 case BOT:
1858                     return true;
1859                 case TYPEVAR:
1860                     if (isCastable(s, t, noWarnings)) {
1861                         warnStack.head.warn(LintCategory.UNCHECKED);
1862                         return true;
1863                     } else {
1864                         return false;
1865                     }
1866                 case CLASS:
1867                     return isSubtype(t, s);
1868                 case ARRAY:
1869                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1870                         return elemtype(t).hasTag(elemtype(s).getTag());
1871                     } else {
1872                         Type et = elemtype(t);
1873                         Type es = elemtype(s);
1874                         if (!visit(et, es))
1875                             return false;
1876                         return true;
1877                     }
1878                 default:
1879                     return false;
1880                 }
1881             }
1882 
1883             @Override
1884             public Boolean visitTypeVar(TypeVar t, Type s) {
1885                 switch (s.getTag()) {
1886                 case ERROR:
1887                 case BOT:
1888                     return true;
1889                 case TYPEVAR:
1890                     if (isSubtype(t, s)) {
1891                         return true;
1892                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1893                         warnStack.head.warn(LintCategory.UNCHECKED);
1894                         return true;
1895                     } else {
1896                         return false;
1897                     }
1898                 default:
1899                     return isCastable(t.getUpperBound(), s, warnStack.head);
1900                 }
1901             }
1902 
1903             @Override
1904             public Boolean visitErrorType(ErrorType t, Type s) {
1905                 return true;
1906             }
1907         };
1908     // &lt;/editor-fold&gt;
1909 
1910     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1911     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1912         while (ts.tail != null &amp;&amp; ss.tail != null) {
1913             if (disjointType(ts.head, ss.head)) return true;
1914             ts = ts.tail;
1915             ss = ss.tail;
1916         }
1917         return false;
1918     }
1919 
1920     /**
1921      * Two types or wildcards are considered disjoint if it can be
1922      * proven that no type can be contained in both. It is
1923      * conservative in that it is allowed to say that two types are
1924      * not disjoint, even though they actually are.
1925      *
1926      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1927      * {@code X} and {@code Y} are not disjoint.
1928      */
1929     public boolean disjointType(Type t, Type s) {
1930         return disjointType.visit(t, s);
1931     }
1932     // where
1933         private TypeRelation disjointType = new TypeRelation() {
1934 
1935             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1936 
1937             @Override
1938             public Boolean visitType(Type t, Type s) {
1939                 if (s.hasTag(WILDCARD))
1940                     return visit(s, t);
1941                 else
1942                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1943             }
1944 
1945             private boolean isCastableRecursive(Type t, Type s) {
1946                 TypePair pair = new TypePair(t, s);
1947                 if (cache.add(pair)) {
1948                     try {
1949                         return Types.this.isCastable(t, s);
1950                     } finally {
1951                         cache.remove(pair);
1952                     }
1953                 } else {
1954                     return true;
1955                 }
1956             }
1957 
1958             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1959                 TypePair pair = new TypePair(t, s);
1960                 if (cache.add(pair)) {
1961                     try {
1962                         return Types.this.notSoftSubtype(t, s);
1963                     } finally {
1964                         cache.remove(pair);
1965                     }
1966                 } else {
1967                     return false;
1968                 }
1969             }
1970 
1971             @Override
1972             public Boolean visitWildcardType(WildcardType t, Type s) {
1973                 if (t.isUnbound())
1974                     return false;
1975 
1976                 if (!s.hasTag(WILDCARD)) {
1977                     if (t.isExtendsBound())
1978                         return notSoftSubtypeRecursive(s, t.type);
1979                     else
1980                         return notSoftSubtypeRecursive(t.type, s);
1981                 }
1982 
1983                 if (s.isUnbound())
1984                     return false;
1985 
1986                 if (t.isExtendsBound()) {
1987                     if (s.isExtendsBound())
1988                         return !isCastableRecursive(t.type, wildUpperBound(s));
1989                     else if (s.isSuperBound())
1990                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
1991                 } else if (t.isSuperBound()) {
1992                     if (s.isExtendsBound())
1993                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
1994                 }
1995                 return false;
1996             }
1997         };
1998     // &lt;/editor-fold&gt;
1999 
2000     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
2001     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
2002         return ts.map(cvarLowerBoundMapping);
2003     }
2004         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
2005             @Override
2006             public Type visitCapturedType(CapturedType t, Void _unused) {
2007                 return cvarLowerBound(t);
2008             }
2009         };
2010     // &lt;/editor-fold&gt;
2011 
2012     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
2013     /**
2014      * This relation answers the question: is impossible that
2015      * something of type `t&#39; can be a subtype of `s&#39;? This is
2016      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
2017      * when type variables are involved: Integer is not a subtype of T
2018      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
2019      * possibly be a subtype of T.
2020      */
2021     public boolean notSoftSubtype(Type t, Type s) {
2022         if (t == s) return false;
2023         if (t.hasTag(TYPEVAR)) {
2024             TypeVar tv = (TypeVar) t;
2025             return !isCastable(tv.getUpperBound(),
2026                                relaxBound(s),
2027                                noWarnings);
2028         }
2029         if (!s.hasTag(WILDCARD))
2030             s = cvarUpperBound(s);
2031 
2032         return !isSubtype(t, relaxBound(s));
2033     }
2034 
2035     private Type relaxBound(Type t) {
2036         return (t.hasTag(TYPEVAR)) ?
2037                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
2038                 t;
2039     }
2040     // &lt;/editor-fold&gt;
2041 
2042     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
2043     public boolean isReifiable(Type t) {
2044         return isReifiable.visit(t);
2045     }
2046     // where
2047         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
2048 
2049             public Boolean visitType(Type t, Void ignored) {
2050                 return true;
2051             }
2052 
2053             @Override
2054             public Boolean visitClassType(ClassType t, Void ignored) {
2055                 if (t.isCompound())
2056                     return false;
2057                 else {
2058                     if (!t.isParameterized())
2059                         return true;
2060 
2061                     for (Type param : t.allparams()) {
2062                         if (!param.isUnbound())
2063                             return false;
2064                     }
2065                     return true;
2066                 }
2067             }
2068 
2069             @Override
2070             public Boolean visitArrayType(ArrayType t, Void ignored) {
2071                 return visit(t.elemtype);
2072             }
2073 
2074             @Override
2075             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2076                 return false;
2077             }
2078         };
2079     // &lt;/editor-fold&gt;
2080 
2081     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2082     public boolean isArray(Type t) {
2083         while (t.hasTag(WILDCARD))
2084             t = wildUpperBound(t);
2085         return t.hasTag(ARRAY);
2086     }
2087 
2088     /**
2089      * The element type of an array.
2090      */
2091     public Type elemtype(Type t) {
2092         switch (t.getTag()) {
2093         case WILDCARD:
2094             return elemtype(wildUpperBound(t));
2095         case ARRAY:
2096             return ((ArrayType)t).elemtype;
2097         case FORALL:
2098             return elemtype(((ForAll)t).qtype);
2099         case ERROR:
2100             return t;
2101         default:
2102             return null;
2103         }
2104     }
2105 
2106     public Type elemtypeOrType(Type t) {
2107         Type elemtype = elemtype(t);
2108         return elemtype != null ?
2109             elemtype :
2110             t;
2111     }
2112 
2113     /**
2114      * Mapping to take element type of an arraytype
2115      */
2116     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2117         @Override
2118         public Type visitArrayType(ArrayType t, Void _unused) {
2119             return t.elemtype;
2120         }
2121 
2122         @Override
2123         public Type visitTypeVar(TypeVar t, Void _unused) {
2124             return visit(skipTypeVars(t, false));
2125         }
2126     };
2127 
2128     /**
2129      * The number of dimensions of an array type.
2130      */
2131     public int dimensions(Type t) {
2132         int result = 0;
2133         while (t.hasTag(ARRAY)) {
2134             result++;
2135             t = elemtype(t);
2136         }
2137         return result;
2138     }
2139 
2140     /**
2141      * Returns an ArrayType with the component type t
2142      *
2143      * @param t The component type of the ArrayType
2144      * @return the ArrayType for the given component
2145      */
2146     public ArrayType makeArrayType(Type t) {
2147         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2148             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2149         }
2150         return new ArrayType(t, syms.arrayClass);
2151     }
2152     // &lt;/editor-fold&gt;
2153 
2154     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2155 
2156     /**
2157      * Return the (most specific) base type of t that starts with the
2158      * given symbol.  If none exists, return null.
2159      *
2160      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2161      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2162      * this method could yield surprising answers when invoked on arrays. For example when
2163      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2164      *
2165      * @param t a type
2166      * @param sym a symbol
2167      * @param checkReferenceProjection if true, first compute reference projection of t
2168      */
2169     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {
2170         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether
2171            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract
2172            superclass)
2173         */
2174         if (checkReferenceProjection)
2175             t = t.isValue() ? t.referenceProjection() : t;
2176         return asSuper(t, sym);
2177     }
2178 
2179     /**
2180      * Return the (most specific) base type of t that starts with the
2181      * given symbol.  If none exists, return null.
2182      *
2183      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2184      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2185      * this method could yield surprising answers when invoked on arrays. For example when
2186      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2187      *
2188      * @param t a type
2189      * @param sym a symbol
2190      */
2191     public Type asSuper(Type t, Symbol sym) {
2192         /* Some examples:
2193          *
2194          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2195          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2196          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2197          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2198          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2199          */
2200         if (sym.type == syms.objectType) { //optimization
2201             if (!isValue(t))
2202                 return syms.objectType;
2203         }
2204         return asSuper.visit(t, sym);
2205     }
2206     // where
2207         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2208 
2209             public Type visitType(Type t, Symbol sym) {
2210                 return null;
2211             }
2212 
2213             @Override
2214             public Type visitClassType(ClassType t, Symbol sym) {
2215                 if (t.tsym == sym)
2216                     return t;
2217 
2218                 // No man may be an island, but the bell tolls for a value.
2219                 if (isValue(t))
2220                     return null;
2221 
2222                 Type st = supertype(t);
2223                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2224                     Type x = asSuper(st, sym);
2225                     if (x != null)
2226                         return x;
2227                 }
2228                 if ((sym.flags() &amp; INTERFACE) != 0) {
2229                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2230                         if (!l.head.hasTag(ERROR)) {
2231                             Type x = asSuper(l.head, sym);
2232                             if (x != null)
2233                                 return x;
2234                         }
2235                     }
2236                 }
2237                 return null;
2238             }
2239 
2240             @Override
2241             public Type visitArrayType(ArrayType t, Symbol sym) {
2242                 return isSubtype(t, sym.type) ? sym.type : null;
2243             }
2244 
2245             @Override
2246             public Type visitTypeVar(TypeVar t, Symbol sym) {
2247                 if (t.tsym == sym)
2248                     return t;
2249                 else
2250                     return asSuper(t.getUpperBound(), sym);
2251             }
2252 
2253             @Override
2254             public Type visitErrorType(ErrorType t, Symbol sym) {
2255                 return t;
2256             }
2257         };
2258 
2259     /**
2260      * Return the base type of t or any of its outer types that starts
2261      * with the given symbol.  If none exists, return null.
2262      *
2263      * @param t a type
2264      * @param sym a symbol
2265      */
2266     public Type asOuterSuper(Type t, Symbol sym) {
2267         switch (t.getTag()) {
2268         case CLASS:
2269             do {
2270                 Type s = asSuper(t, sym);
2271                 if (s != null) return s;
2272                 t = t.getEnclosingType();
2273             } while (t.hasTag(CLASS));
2274             return null;
2275         case ARRAY:
2276             return isSubtype(t, sym.type) ? sym.type : null;
2277         case TYPEVAR:
2278             return asSuper(t, sym);
2279         case ERROR:
2280             return t;
2281         default:
2282             return null;
2283         }
2284     }
2285 
2286     /**
2287      * Return the base type of t or any of its enclosing types that
2288      * starts with the given symbol.  If none exists, return null.
2289      *
2290      * @param t a type
2291      * @param sym a symbol
2292      */
2293     public Type asEnclosingSuper(Type t, Symbol sym) {
2294         switch (t.getTag()) {
2295         case CLASS:
2296             do {
2297                 Type s = asSuper(t, sym);
2298                 if (s != null) return s;
2299                 Type outer = t.getEnclosingType();
2300                 t = (outer.hasTag(CLASS)) ? outer :
2301                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2302                     Type.noType;
2303             } while (t.hasTag(CLASS));
2304             return null;
2305         case ARRAY:
2306             return isSubtype(t, sym.type) ? sym.type : null;
2307         case TYPEVAR:
2308             return asSuper(t, sym);
2309         case ERROR:
2310             return t;
2311         default:
2312             return null;
2313         }
2314     }
2315     // &lt;/editor-fold&gt;
2316 
2317     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2318     /**
2319      * The type of given symbol, seen as a member of t.
2320      *
2321      * @param t a type
2322      * @param sym a symbol
2323      */
2324     public Type memberType(Type t, Symbol sym) {
2325 
2326         if ((sym.flags() &amp; STATIC) != 0)
2327             return sym.type;
2328 
2329         /* If any inline types are involved, switch over to the reference universe,
2330            where the hierarchy is navigable. V and V.ref have identical membership
2331            with no bridging needs.
2332         */
2333         if (t.isValue())
2334             t = t.referenceProjection();
2335 
2336         if (sym.owner.isValue())
2337             sym = sym.referenceProjection();
2338 
2339         return memberType.visit(t, sym);
2340         }
2341     // where
2342         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2343 
2344             public Type visitType(Type t, Symbol sym) {
2345                 return sym.type;
2346             }
2347 
2348             @Override
2349             public Type visitWildcardType(WildcardType t, Symbol sym) {
2350                 return memberType(wildUpperBound(t), sym);
2351             }
2352 
2353             @Override
2354             public Type visitClassType(ClassType t, Symbol sym) {
2355                 Symbol owner = sym.owner;
2356                 long flags = sym.flags();
2357                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2358                     Type base = asOuterSuper(t, owner);
2359                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2360                     //its supertypes CT, I1, ... In might contain wildcards
2361                     //so we need to go through capture conversion
2362                     base = t.isCompound() ? capture(base) : base;
2363                     if (base != null) {
2364                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2365                         List&lt;Type&gt; baseParams = base.allparams();
2366                         if (ownerParams.nonEmpty()) {
2367                             if (baseParams.isEmpty()) {
2368                                 // then base is a raw type
2369                                 return erasure(sym.type);
2370                             } else {
2371                                 return subst(sym.type, ownerParams, baseParams);
2372                             }
2373                         }
2374                     }
2375                 }
2376                 return sym.type;
2377             }
2378 
2379             @Override
2380             public Type visitTypeVar(TypeVar t, Symbol sym) {
2381                 return memberType(t.getUpperBound(), sym);
2382             }
2383 
2384             @Override
2385             public Type visitErrorType(ErrorType t, Symbol sym) {
2386                 return t;
2387             }
2388         };
2389     // &lt;/editor-fold&gt;
2390 
2391     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2392     public boolean isAssignable(Type t, Type s) {
2393         return isAssignable(t, s, noWarnings);
2394     }
2395 
2396     /**
2397      * Is t assignable to s?&lt;br&gt;
2398      * Equivalent to subtype except for constant values and raw
2399      * types.&lt;br&gt;
2400      * (not defined for Method and ForAll types)
2401      */
2402     public boolean isAssignable(Type t, Type s, Warner warn) {
2403         if (t.hasTag(ERROR))
2404             return true;
2405         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2406             int value = ((Number)t.constValue()).intValue();
2407             switch (s.getTag()) {
2408             case BYTE:
2409             case CHAR:
2410             case SHORT:
2411             case INT:
2412                 if (s.getTag().checkRange(value))
2413                     return true;
2414                 break;
2415             case CLASS:
2416                 switch (unboxedType(s).getTag()) {
2417                 case BYTE:
2418                 case CHAR:
2419                 case SHORT:
2420                     return isAssignable(t, unboxedType(s), warn);
2421                 }
2422                 break;
2423             }
2424         }
2425         return isConvertible(t, s, warn);
2426     }
2427     // &lt;/editor-fold&gt;
2428 
2429     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2430     /**
2431      * The erasure of t {@code |t|} -- the type that results when all
2432      * type parameters in t are deleted.
2433      */
2434     public Type erasure(Type t) {
2435         return eraseNotNeeded(t) ? t : erasure(t, false);
2436     }
2437     //where
2438     private boolean eraseNotNeeded(Type t) {
2439         // We don&#39;t want to erase primitive types and String type as that
2440         // operation is idempotent. Also, erasing these could result in loss
2441         // of information such as constant values attached to such types.
2442         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2443     }
2444 
2445     private Type erasure(Type t, boolean recurse) {
2446         if (t.isPrimitive()) {
2447             return t; /* fast special case */
2448         } else {
2449             Type out = erasure.visit(t, recurse);
2450             return out;
2451         }
2452     }
2453     // where
2454         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2455             private Type combineMetadata(final Type s,
2456                                          final Type t) {
2457                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2458                     switch (s.getKind()) {
2459                         case OTHER:
2460                         case UNION:
2461                         case INTERSECTION:
2462                         case PACKAGE:
2463                         case EXECUTABLE:
2464                         case NONE:
2465                         case VOID:
2466                         case ERROR:
2467                             return s;
2468                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2469                     }
2470                 } else {
2471                     return s;
2472                 }
2473             }
2474 
2475             public Type visitType(Type t, Boolean recurse) {
2476                 if (t.isPrimitive())
2477                     return t; /*fast special case*/
2478                 else {
2479                     //other cases already handled
2480                     return combineMetadata(t, t);
2481                 }
2482             }
2483 
2484             @Override
2485             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2486                 Type erased = erasure(wildUpperBound(t), recurse);
2487                 return combineMetadata(erased, t);
2488             }
2489 
2490             @Override
2491             public Type visitClassType(ClassType t, Boolean recurse) {
2492                 Type erased = t.tsym.erasure(Types.this);
2493                 if (recurse) {
2494                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2495                             t.getMetadata().without(Kind.ANNOTATIONS));
2496                     return erased;
2497                 } else {
2498                     return combineMetadata(erased, t);
2499                 }
2500             }
2501 
2502             @Override
2503             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2504                 Type erased = erasure(t.getUpperBound(), recurse);
2505                 return combineMetadata(erased, t);
2506             }
2507         };
2508 
2509     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2510         return erasure.visit(ts, false);
2511     }
2512 
2513     public Type erasureRecursive(Type t) {
2514         return erasure(t, true);
2515     }
2516 
2517     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2518         return erasure.visit(ts, true);
2519     }
2520     // &lt;/editor-fold&gt;
2521 
2522     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2523     /**
2524      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2525      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2526      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2527      *
2528      * @param bounds    the types from which the intersection type is formed
2529      */
2530     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2531         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2532     }
2533 
2534     /**
2535      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2536      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2537      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2538      * supertype is implicitly assumed to be &#39;Object&#39;.
2539      *
2540      * @param bounds        the types from which the intersection type is formed
2541      * @param allInterfaces are all bounds interface types?
2542      */
2543     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2544         Assert.check(bounds.nonEmpty());
2545         Type firstExplicitBound = bounds.head;
2546         if (allInterfaces) {
2547             bounds = bounds.prepend(syms.objectType);
2548         }
2549         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;
2550         if (isValue(bounds.head))
2551             flags |= VALUE;
2552         ClassSymbol bc =
2553             new ClassSymbol(flags,
2554                             Type.moreInfo
2555                                 ? names.fromString(bounds.toString())
2556                                 : names.empty,
2557                             null,
2558                             syms.noSymbol);
2559         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2560         bc.type = intersectionType;
2561         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2562                 syms.objectType : // error condition, recover
2563                 erasure(firstExplicitBound);
2564         bc.members_field = WriteableScope.create(bc);
2565         return intersectionType;
2566     }
2567     // &lt;/editor-fold&gt;
2568 
2569     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2570     public Type supertype(Type t) {
2571         return supertype.visit(t);
2572     }
2573     // where
2574         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2575 
2576             public Type visitType(Type t, Void ignored) {
2577                 // A note on wildcards: there is no good way to
2578                 // determine a supertype for a super bounded wildcard.
2579                 return Type.noType;
2580             }
2581 
2582             @Override
2583             public Type visitClassType(ClassType t, Void ignored) {
2584                 if (t.supertype_field == null) {
2585                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2586                     // An interface has no superclass; its supertype is Object.
2587                     if (t.isInterface())
2588                         supertype = ((ClassType)t.tsym.type).supertype_field;
2589                     if (t.supertype_field == null) {
2590                         List&lt;Type&gt; actuals = classBound(t).allparams();
2591                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2592                         if (t.hasErasedSupertypes()) {
2593                             t.supertype_field = erasureRecursive(supertype);
2594                         } else if (formals.nonEmpty()) {
2595                             t.supertype_field = subst(supertype, formals, actuals);
2596                         }
2597                         else {
2598                             t.supertype_field = supertype;
2599                         }
2600                     }
2601                 }
2602                 return t.supertype_field;
2603             }
2604 
2605             /**
2606              * The supertype is always a class type. If the type
2607              * variable&#39;s bounds start with a class type, this is also
2608              * the supertype.  Otherwise, the supertype is
2609              * java.lang.Object.
2610              */
2611             @Override
2612             public Type visitTypeVar(TypeVar t, Void ignored) {
2613                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2614                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2615                     return t.getUpperBound();
2616                 } else {
2617                     return supertype(t.getUpperBound());
2618                 }
2619             }
2620 
2621             @Override
2622             public Type visitArrayType(ArrayType t, Void ignored) {
2623                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2624                     return arraySuperType();
2625                 else
2626                     return new ArrayType(supertype(t.elemtype), t.tsym);
2627             }
2628 
2629             @Override
2630             public Type visitErrorType(ErrorType t, Void ignored) {
2631                 return Type.noType;
2632             }
2633         };
2634     // &lt;/editor-fold&gt;
2635 
2636     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2637     /**
2638      * Return the interfaces implemented by this class.
2639      */
2640     public List&lt;Type&gt; interfaces(Type t) {
2641         return interfaces.visit(t);
2642     }
2643     // where
2644         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2645 
2646             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2647                 return List.nil();
2648             }
2649 
2650             @Override
2651             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2652                 if (t.interfaces_field == null) {
2653                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2654                     if (t.interfaces_field == null) {
2655                         // If t.interfaces_field is null, then t must
2656                         // be a parameterized type (not to be confused
2657                         // with a generic type declaration).
2658                         // Terminology:
2659                         //    Parameterized type: List&lt;String&gt;
2660                         //    Generic type declaration: class List&lt;E&gt; { ... }
2661                         // So t corresponds to List&lt;String&gt; and
2662                         // t.tsym.type corresponds to List&lt;E&gt;.
2663                         // The reason t must be parameterized type is
2664                         // that completion will happen as a side
2665                         // effect of calling
2666                         // ClassSymbol.getInterfaces.  Since
2667                         // t.interfaces_field is null after
2668                         // completion, we can assume that t is not the
2669                         // type of a class/interface declaration.
2670                         Assert.check(t != t.tsym.type, t);
2671                         List&lt;Type&gt; actuals = t.allparams();
2672                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2673                         if (t.hasErasedSupertypes()) {
2674                             t.interfaces_field = erasureRecursive(interfaces);
2675                         } else if (formals.nonEmpty()) {
2676                             t.interfaces_field = subst(interfaces, formals, actuals);
2677                         }
2678                         else {
2679                             t.interfaces_field = interfaces;
2680                         }
2681                     }
2682                 }
2683                 return t.interfaces_field;
2684             }
2685 
2686             @Override
2687             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2688                 if (t.getUpperBound().isCompound())
2689                     return interfaces(t.getUpperBound());
2690 
2691                 if (t.getUpperBound().isInterface())
2692                     return List.of(t.getUpperBound());
2693 
2694                 return List.nil();
2695             }
2696         };
2697 
2698     public List&lt;Type&gt; directSupertypes(Type t) {
2699         return directSupertypes.visit(t);
2700     }
2701     // where
2702         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2703 
2704             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2705                 if (!type.isIntersection()) {
2706                     final Type sup = supertype(type);
2707                     return (sup == Type.noType || sup == type || sup == null)
2708                         ? interfaces(type)
2709                         : interfaces(type).prepend(sup);
2710                 } else {
2711                     return ((IntersectionClassType)type).getExplicitComponents();
2712                 }
2713             }
2714         };
2715 
2716     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2717         for (Type i2 : interfaces(origin.type)) {
2718             if (isym == i2.tsym) return true;
2719         }
2720         return false;
2721     }
2722     // &lt;/editor-fold&gt;
2723 
2724     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2725     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2726 
2727     public boolean isDerivedRaw(Type t) {
2728         Boolean result = isDerivedRawCache.get(t);
2729         if (result == null) {
2730             result = isDerivedRawInternal(t);
2731             isDerivedRawCache.put(t, result);
2732         }
2733         return result;
2734     }
2735 
2736     public boolean isDerivedRawInternal(Type t) {
2737         if (t.isErroneous())
2738             return false;
2739         return
2740             t.isRaw() ||
2741             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2742             isDerivedRaw(interfaces(t));
2743     }
2744 
2745     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2746         List&lt;Type&gt; l = ts;
2747         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2748         return l.nonEmpty();
2749     }
2750     // &lt;/editor-fold&gt;
2751 
2752     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2753     /**
2754      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2755      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2756      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2757      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2758      * Hence, this version of setBounds may not be called during a classfile read.
2759      *
2760      * @param t         a type variable
2761      * @param bounds    the bounds, must be nonempty
2762      */
2763     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2764         setBounds(t, bounds, bounds.head.tsym.isInterface());
2765     }
2766 
2767     /**
2768      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2769      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2770      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2771      *
2772      * @param t             a type variable
2773      * @param bounds        the bounds, must be nonempty
2774      * @param allInterfaces are all bounds interface types?
2775      */
2776     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2777         t.setUpperBound( bounds.tail.isEmpty() ?
2778                 bounds.head :
2779                 makeIntersectionType(bounds, allInterfaces) );
2780         t.rank_field = -1;
2781     }
2782     // &lt;/editor-fold&gt;
2783 
2784     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2785     /**
2786      * Return list of bounds of the given type variable.
2787      */
2788     public List&lt;Type&gt; getBounds(TypeVar t) {
2789         if (t.getUpperBound().hasTag(NONE))
2790             return List.nil();
2791         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2792             return List.of(t.getUpperBound());
2793         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2794             return interfaces(t).prepend(supertype(t));
2795         else
2796             // No superclass was given in bounds.
2797             // In this case, supertype is Object, erasure is first interface.
2798             return interfaces(t);
2799     }
2800     // &lt;/editor-fold&gt;
2801 
2802     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2803     /**
2804      * If the given type is a (possibly selected) type variable,
2805      * return the bounding class of this type, otherwise return the
2806      * type itself.
2807      */
2808     public Type classBound(Type t) {
2809         return classBound.visit(t);
2810     }
2811     // where
2812         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2813 
2814             public Type visitType(Type t, Void ignored) {
2815                 return t;
2816             }
2817 
2818             @Override
2819             public Type visitClassType(ClassType t, Void ignored) {
2820                 Type outer1 = classBound(t.getEnclosingType());
2821                 if (outer1 != t.getEnclosingType())
2822                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2823                                          t.getMetadata());
2824                 else
2825                     return t;
2826             }
2827 
2828             @Override
2829             public Type visitTypeVar(TypeVar t, Void ignored) {
2830                 return classBound(supertype(t));
2831             }
2832 
2833             @Override
2834             public Type visitErrorType(ErrorType t, Void ignored) {
2835                 return t;
2836             }
2837         };
2838     // &lt;/editor-fold&gt;
2839 
2840     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2841     /**
2842      * Returns true iff the first signature is a &lt;em&gt;sub
2843      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2844      * relation.
2845      *
2846      * @jls 8.4.2 Method Signature
2847      * @see #overrideEquivalent(Type t, Type s)
2848      * @param t first signature (possibly raw).
2849      * @param s second signature (could be subjected to erasure).
2850      * @return true if t is a sub signature of s.
2851      */
2852     public boolean isSubSignature(Type t, Type s) {
2853         return isSubSignature(t, s, true);
2854     }
2855 
2856     public boolean isSubSignature(Type t, Type s, boolean strict) {
2857         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2858     }
2859 
2860     /**
2861      * Returns true iff these signatures are related by &lt;em&gt;override
2862      * equivalence&lt;/em&gt;.  This is the natural extension of
2863      * isSubSignature to an equivalence relation.
2864      *
2865      * @jls 8.4.2 Method Signature
2866      * @see #isSubSignature(Type t, Type s)
2867      * @param t a signature (possible raw, could be subjected to
2868      * erasure).
2869      * @param s a signature (possible raw, could be subjected to
2870      * erasure).
2871      * @return true if either argument is a sub signature of the other.
2872      */
2873     public boolean overrideEquivalent(Type t, Type s) {
2874         return hasSameArgs(t, s) ||
2875             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2876     }
2877 
2878     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2879         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2880             if (msym.overrides(sym, origin, Types.this, true)) {
2881                 return true;
2882             }
2883         }
2884         return false;
2885     }
2886 
2887     /**
2888      * This enum defines the strategy for implementing most specific return type check
2889      * during the most specific and functional interface checks.
2890      */
2891     public enum MostSpecificReturnCheck {
2892         /**
2893          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2894          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2895          * by type-equivalence for primitives. This is essentially an inlined version of
2896          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2897          * replaced with a strict subtyping check.
2898          */
2899         BASIC() {
2900             @Override
2901             public boolean test(Type mt1, Type mt2, Types types) {
2902                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2903                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2904                 Type t = mt1.getReturnType();
2905                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2906                 return types.isSameType(t, s) ||
2907                     !t.isPrimitive() &amp;&amp;
2908                     !s.isPrimitive() &amp;&amp;
2909                     types.isSubtype(t, s);
2910             }
2911         },
2912         /**
2913          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2914          */
2915         RTS() {
2916             @Override
2917             public boolean test(Type mt1, Type mt2, Types types) {
2918                 return types.returnTypeSubstitutable(mt1, mt2);
2919             }
2920         };
2921 
2922         public abstract boolean test(Type mt1, Type mt2, Types types);
2923     }
2924 
2925     /**
2926      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2927      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2928      * The resulting preferred method has a thrown clause that is the intersection of the merged
2929      * methods&#39; clauses.
2930      */
2931     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2932         //first check for preconditions
2933         boolean shouldErase = false;
2934         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2935         for (Symbol s : ambiguousInOrder) {
2936             if ((s.flags() &amp; ABSTRACT) == 0 ||
2937                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2938                 return Optional.empty();
2939             } else if (s.type.hasTag(FORALL)) {
2940                 shouldErase = true;
2941             }
2942         }
2943         //then merge abstracts
2944         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2945             outer: for (Symbol s : ambiguousInOrder) {
2946                 Type mt = memberType(site, s);
2947                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2948                 for (Symbol s2 : ambiguousInOrder) {
2949                     if (s != s2) {
2950                         Type mt2 = memberType(site, s2);
2951                         if (!isSubSignature(mt, mt2) ||
2952                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2953                             //ambiguity cannot be resolved
2954                             continue outer;
2955                         } else {
2956                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2957                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2958                                 thrownTypes2 = erasure(thrownTypes2);
2959                             } else if (mt.hasTag(FORALL)) {
2960                                 //subsignature implies that if most specific is generic, then all other
2961                                 //methods are too
2962                                 Assert.check(mt2.hasTag(FORALL));
2963                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2964                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2965                             }
2966                             allThrown = chk.intersect(allThrown, thrownTypes2);
2967                         }
2968                     }
2969                 }
2970                 return (allThrown == mt.getThrownTypes()) ?
2971                         Optional.of(s) :
2972                         Optional.of(new MethodSymbol(
2973                                 s.flags(),
2974                                 s.name,
2975                                 createMethodTypeWithThrown(s.type, allThrown),
2976                                 s.owner) {
2977                             @Override
2978                             public Symbol baseSymbol() {
2979                                 return s;
2980                             }
2981                         });
2982             }
2983         }
2984         return Optional.empty();
2985     }
2986 
2987     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
2988     class ImplementationCache {
2989 
2990         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
2991 
2992         class Entry {
2993             final MethodSymbol cachedImpl;
2994             final Filter&lt;Symbol&gt; implFilter;
2995             final boolean checkResult;
2996             final int prevMark;
2997 
2998             public Entry(MethodSymbol cachedImpl,
2999                     Filter&lt;Symbol&gt; scopeFilter,
3000                     boolean checkResult,
3001                     int prevMark) {
3002                 this.cachedImpl = cachedImpl;
3003                 this.implFilter = scopeFilter;
3004                 this.checkResult = checkResult;
3005                 this.prevMark = prevMark;
3006             }
3007 
3008             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
3009                 return this.implFilter == scopeFilter &amp;&amp;
3010                         this.checkResult == checkResult &amp;&amp;
3011                         this.prevMark == mark;
3012             }
3013         }
3014 
3015         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3016             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
3017             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
3018             if (cache == null) {
3019                 cache = new HashMap&lt;&gt;();
3020                 _map.put(ms, new SoftReference&lt;&gt;(cache));
3021             }
3022             Entry e = cache.get(origin);
3023             CompoundScope members = membersClosure(origin.type, true);
3024             if (e == null ||
3025                     !e.matches(implFilter, checkResult, members.getMark())) {
3026                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
3027                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
3028                 return impl;
3029             }
3030             else {
3031                 return e.cachedImpl;
3032             }
3033         }
3034 
3035         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3036             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
3037                 t = skipTypeVars(t, false);
3038                 TypeSymbol c = t.tsym;
3039                 Symbol bestSoFar = null;
3040                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
3041                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
3042                         bestSoFar = sym;
3043                         if ((sym.flags() &amp; ABSTRACT) == 0) {
3044                             //if concrete impl is found, exit immediately
3045                             break;
3046                         }
3047                     }
3048                 }
3049                 if (bestSoFar != null) {
3050                     //return either the (only) concrete implementation or the first abstract one
3051                     return (MethodSymbol)bestSoFar;
3052                 }
3053             }
3054             return null;
3055         }
3056     }
3057 
3058     private ImplementationCache implCache = new ImplementationCache();
3059 
3060     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3061         return implCache.get(ms, origin, checkResult, implFilter);
3062     }
3063     // &lt;/editor-fold&gt;
3064 
3065     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
3066     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
3067 
3068         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
3069 
3070         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
3071 
3072         class MembersScope extends CompoundScope {
3073 
3074             CompoundScope scope;
3075 
3076             public MembersScope(CompoundScope scope) {
3077                 super(scope.owner);
3078                 this.scope = scope;
3079             }
3080 
3081             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
3082                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
3083             }
3084 
3085             @Override
3086             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3087                 return scope.getSymbols(combine(sf), lookupKind);
3088             }
3089 
3090             @Override
3091             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3092                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
3093             }
3094 
3095             @Override
3096             public int getMark() {
3097                 return scope.getMark();
3098             }
3099         }
3100 
3101         CompoundScope nilScope;
3102 
3103         /** members closure visitor methods **/
3104 
3105         public CompoundScope visitType(Type t, Void _unused) {
3106             if (nilScope == null) {
3107                 nilScope = new CompoundScope(syms.noSymbol);
3108             }
3109             return nilScope;
3110         }
3111 
3112         @Override
3113         public CompoundScope visitClassType(ClassType t, Void _unused) {
3114             if (!seenTypes.add(t.tsym)) {
3115                 //this is possible when an interface is implemented in multiple
3116                 //superclasses, or when a class hierarchy is circular - in such
3117                 //cases we don&#39;t need to recurse (empty scope is returned)
3118                 return new CompoundScope(t.tsym);
3119             }
3120             try {
3121                 seenTypes.add(t.tsym);
3122                 ClassSymbol csym = (ClassSymbol)t.tsym;
3123                 CompoundScope membersClosure = _map.get(csym);
3124                 if (membersClosure == null) {
3125                     membersClosure = new CompoundScope(csym);
3126                     for (Type i : interfaces(t)) {
3127                         membersClosure.prependSubScope(visit(i, null));
3128                     }
3129                     membersClosure.prependSubScope(visit(supertype(t), null));
3130                     membersClosure.prependSubScope(csym.members());
3131                     _map.put(csym, membersClosure);
3132                 }
3133                 return membersClosure;
3134             }
3135             finally {
3136                 seenTypes.remove(t.tsym);
3137             }
3138         }
3139 
3140         @Override
3141         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3142             return visit(t.getUpperBound(), null);
3143         }
3144     }
3145 
3146     private MembersClosureCache membersCache = new MembersClosureCache();
3147 
3148     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3149         CompoundScope cs = membersCache.visit(site, null);
3150         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3151         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3152     }
3153     // &lt;/editor-fold&gt;
3154 
3155 
3156     /** Return first abstract member of class `sym&#39;.
3157      */
3158     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3159         try {
3160             return firstUnimplementedAbstractImpl(sym, sym);
3161         } catch (CompletionFailure ex) {
3162             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3163             return null;
3164         }
3165     }
3166         //where:
3167         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3168             MethodSymbol undef = null;
3169             // Do not bother to search in classes that are not abstract,
3170             // since they cannot have abstract members.
3171             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3172                 Scope s = c.members();
3173                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3174                     if (sym.kind == MTH &amp;&amp;
3175                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3176                         MethodSymbol absmeth = (MethodSymbol)sym;
3177                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3178                         if (implmeth == null || implmeth == absmeth) {
3179                             //look for default implementations
3180                             if (allowDefaultMethods) {
3181                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3182                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3183                                     implmeth = prov;
3184                                 }
3185                             }
3186                         }
3187                         if (implmeth == null || implmeth == absmeth) {
3188                             undef = absmeth;
3189                             break;
3190                         }
3191                     }
3192                 }
3193                 if (undef == null) {
3194                     Type st = supertype(c.type);
3195                     if (st.hasTag(CLASS))
3196                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3197                 }
3198                 for (List&lt;Type&gt; l = interfaces(c.type);
3199                      undef == null &amp;&amp; l.nonEmpty();
3200                      l = l.tail) {
3201                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3202                 }
3203             }
3204             return undef;
3205         }
3206 
3207     public class CandidatesCache {
3208         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3209 
3210         class Entry {
3211             Type site;
3212             MethodSymbol msym;
3213 
3214             Entry(Type site, MethodSymbol msym) {
3215                 this.site = site;
3216                 this.msym = msym;
3217             }
3218 
3219             @Override
3220             public boolean equals(Object obj) {
3221                 if (obj instanceof Entry) {
3222                     Entry e = (Entry)obj;
3223                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3224                 } else {
3225                     return false;
3226                 }
3227             }
3228 
3229             @Override
3230             public int hashCode() {
3231                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3232             }
3233         }
3234 
3235         public List&lt;MethodSymbol&gt; get(Entry e) {
3236             return cache.get(e);
3237         }
3238 
3239         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3240             cache.put(e, msymbols);
3241         }
3242     }
3243 
3244     public CandidatesCache candidatesCache = new CandidatesCache();
3245 
3246     //where
3247     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3248         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3249         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3250         if (candidates == null) {
3251             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3252             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3253             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3254                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3255                     return List.of((MethodSymbol)s);
3256                 } else if (!candidates2.contains(s)) {
3257                     candidates2 = candidates2.prepend((MethodSymbol)s);
3258                 }
3259             }
3260             candidates = prune(candidates2);
3261             candidatesCache.put(e, candidates);
3262         }
3263         return candidates;
3264     }
3265 
3266     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3267         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3268         for (MethodSymbol m1 : methods) {
3269             boolean isMin_m1 = true;
3270             for (MethodSymbol m2 : methods) {
3271                 if (m1 == m2) continue;
3272                 if (m2.owner != m1.owner &amp;&amp;
3273                         asSuper(m2.owner.type, m1.owner) != null) {
3274                     isMin_m1 = false;
3275                     break;
3276                 }
3277             }
3278             if (isMin_m1)
3279                 methodsMin.append(m1);
3280         }
3281         return methodsMin.toList();
3282     }
3283     // where
3284             private class MethodFilter implements Filter&lt;Symbol&gt; {
3285 
3286                 Symbol msym;
3287                 Type site;
3288 
3289                 MethodFilter(Symbol msym, Type site) {
3290                     this.msym = msym;
3291                     this.site = site;
3292                 }
3293 
3294                 public boolean accepts(Symbol s) {
3295                     return s.kind == MTH &amp;&amp;
3296                             s.name == msym.name &amp;&amp;
3297                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3298                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3299                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3300                 }
3301             }
3302     // &lt;/editor-fold&gt;
3303 
3304     /**
3305      * Does t have the same arguments as s?  It is assumed that both
3306      * types are (possibly polymorphic) method types.  Monomorphic
3307      * method types &quot;have the same arguments&quot;, if their argument lists
3308      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3309      * if they have the same arguments after renaming all type
3310      * variables of one to corresponding type variables in the other,
3311      * where correspondence is by position in the type parameter list.
3312      */
3313     public boolean hasSameArgs(Type t, Type s) {
3314         return hasSameArgs(t, s, true);
3315     }
3316 
3317     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3318         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3319     }
3320 
3321     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3322         return hasSameArgs.visit(t, s);
3323     }
3324     // where
3325         private class HasSameArgs extends TypeRelation {
3326 
3327             boolean strict;
3328 
3329             public HasSameArgs(boolean strict) {
3330                 this.strict = strict;
3331             }
3332 
3333             public Boolean visitType(Type t, Type s) {
3334                 throw new AssertionError();
3335             }
3336 
3337             @Override
3338             public Boolean visitMethodType(MethodType t, Type s) {
3339                 return s.hasTag(METHOD)
3340                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3341             }
3342 
3343             @Override
3344             public Boolean visitForAll(ForAll t, Type s) {
3345                 if (!s.hasTag(FORALL))
3346                     return strict ? false : visitMethodType(t.asMethodType(), s);
3347 
3348                 ForAll forAll = (ForAll)s;
3349                 return hasSameBounds(t, forAll)
3350                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3351             }
3352 
3353             @Override
3354             public Boolean visitErrorType(ErrorType t, Type s) {
3355                 return false;
3356             }
3357         }
3358 
3359     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3360         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3361 
3362     // &lt;/editor-fold&gt;
3363 
3364     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3365     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3366                             List&lt;Type&gt; from,
3367                             List&lt;Type&gt; to) {
3368         return ts.map(new Subst(from, to));
3369     }
3370 
3371     /**
3372      * Substitute all occurrences of a type in `from&#39; with the
3373      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3374      * from the right: If lists have different length, discard leading
3375      * elements of the longer list.
3376      */
3377     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3378         return t.map(new Subst(from, to));
3379     }
3380 
3381     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3382         List&lt;Type&gt; from;
3383         List&lt;Type&gt; to;
3384 
3385         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3386             int fromLength = from.length();
3387             int toLength = to.length();
3388             while (fromLength &gt; toLength) {
3389                 fromLength--;
3390                 from = from.tail;
3391             }
3392             while (fromLength &lt; toLength) {
3393                 toLength--;
3394                 to = to.tail;
3395             }
3396             this.from = from;
3397             this.to = to;
3398         }
3399 
3400         @Override
3401         public Type visitTypeVar(TypeVar t, Void ignored) {
3402             for (List&lt;Type&gt; from = this.from, to = this.to;
3403                  from.nonEmpty();
3404                  from = from.tail, to = to.tail) {
3405                 if (t.equalsIgnoreMetadata(from.head)) {
3406                     return to.head.withTypeVar(t);
3407                 }
3408             }
3409             return t;
3410         }
3411 
3412         @Override
3413         public Type visitClassType(ClassType t, Void ignored) {
3414             if (!t.isCompound()) {
3415                 return super.visitClassType(t, ignored);
3416             } else {
3417                 Type st = visit(supertype(t));
3418                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3419                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3420                     return t;
3421                 else
3422                     return makeIntersectionType(is.prepend(st));
3423             }
3424         }
3425 
3426         @Override
3427         public Type visitWildcardType(WildcardType t, Void ignored) {
3428             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3429             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3430                 t2.type = wildUpperBound(t2.type);
3431             }
3432             return t2;
3433         }
3434 
3435         @Override
3436         public Type visitForAll(ForAll t, Void ignored) {
3437             if (Type.containsAny(to, t.tvars)) {
3438                 //perform alpha-renaming of free-variables in &#39;t&#39;
3439                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3440                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3441                 t = new ForAll(freevars,
3442                                Types.this.subst(t.qtype, t.tvars, freevars));
3443             }
3444             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3445             Type qtype1 = visit(t.qtype);
3446             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3447                 return t;
3448             } else if (tvars1 == t.tvars) {
3449                 return new ForAll(tvars1, qtype1) {
3450                     @Override
3451                     public boolean needsStripping() {
3452                         return true;
3453                     }
3454                 };
3455             } else {
3456                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3457                     @Override
3458                     public boolean needsStripping() {
3459                         return true;
3460                     }
3461                 };
3462             }
3463         }
3464     }
3465 
3466     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3467                                   List&lt;Type&gt; from,
3468                                   List&lt;Type&gt; to) {
3469         if (tvars.isEmpty())
3470             return tvars;
3471         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3472         boolean changed = false;
3473         // calculate new bounds
3474         for (Type t : tvars) {
3475             TypeVar tv = (TypeVar) t;
3476             Type bound = subst(tv.getUpperBound(), from, to);
3477             if (bound != tv.getUpperBound())
3478                 changed = true;
3479             newBoundsBuf.append(bound);
3480         }
3481         if (!changed)
3482             return tvars;
3483         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3484         // create new type variables without bounds
3485         for (Type t : tvars) {
3486             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3487                                         t.getMetadata()));
3488         }
3489         // the new bounds should use the new type variables in place
3490         // of the old
3491         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3492         from = tvars;
3493         to = newTvars.toList();
3494         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3495             newBounds.head = subst(newBounds.head, from, to);
3496         }
3497         newBounds = newBoundsBuf.toList();
3498         // set the bounds of new type variables to the new bounds
3499         for (Type t : newTvars.toList()) {
3500             TypeVar tv = (TypeVar) t;
3501             tv.setUpperBound( newBounds.head );
3502             newBounds = newBounds.tail;
3503         }
3504         return newTvars.toList();
3505     }
3506 
3507     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3508         Type bound1 = subst(t.getUpperBound(), from, to);
3509         if (bound1 == t.getUpperBound())
3510             return t;
3511         else {
3512             // create new type variable without bounds
3513             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3514                                      t.getMetadata());
3515             // the new bound should use the new type variable in place
3516             // of the old
3517             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3518             return tv;
3519         }
3520     }
3521     // &lt;/editor-fold&gt;
3522 
3523     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3524     /**
3525      * Does t have the same bounds for quantified variables as s?
3526      */
3527     public boolean hasSameBounds(ForAll t, ForAll s) {
3528         List&lt;Type&gt; l1 = t.tvars;
3529         List&lt;Type&gt; l2 = s.tvars;
3530         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3531                isSameType(l1.head.getUpperBound(),
3532                           subst(l2.head.getUpperBound(),
3533                                 s.tvars,
3534                                 t.tvars))) {
3535             l1 = l1.tail;
3536             l2 = l2.tail;
3537         }
3538         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3539     }
3540     // &lt;/editor-fold&gt;
3541 
3542     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3543     /** Create new vector of type variables from list of variables
3544      *  changing all recursive bounds from old to new list.
3545      */
3546     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3547         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3548         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3549             TypeVar tv = (TypeVar) l.head;
3550             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3551         }
3552         return tvars1;
3553     }
3554         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3555             @Override
3556             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3557                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3558             }
3559         };
3560     // &lt;/editor-fold&gt;
3561 
3562     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3563         return original.accept(methodWithParameters, newParams);
3564     }
3565     // where
3566         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3567             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3568                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3569             }
3570             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3571                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3572             }
3573             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3574                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3575             }
3576         };
3577 
3578     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3579         return original.accept(methodWithThrown, newThrown);
3580     }
3581     // where
3582         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3583             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3584                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3585             }
3586             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3587                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3588             }
3589             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3590                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3591             }
3592         };
3593 
3594     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3595         return original.accept(methodWithReturn, newReturn);
3596     }
3597     // where
3598         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3599             public Type visitType(Type t, Type newReturn) {
3600                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3601             }
3602             public Type visitMethodType(MethodType t, Type newReturn) {
3603                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3604                     @Override
3605                     public Type baseType() {
3606                         return t;
3607                     }
3608                 };
3609             }
3610             public Type visitForAll(ForAll t, Type newReturn) {
3611                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3612                     @Override
3613                     public Type baseType() {
3614                         return t;
3615                     }
3616                 };
3617             }
3618         };
3619 
3620     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3621     public Type createErrorType(Type originalType) {
3622         return new ErrorType(originalType, syms.errSymbol);
3623     }
3624 
3625     public Type createErrorType(ClassSymbol c, Type originalType) {
3626         return new ErrorType(c, originalType);
3627     }
3628 
3629     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3630         return new ErrorType(name, container, originalType);
3631     }
3632     // &lt;/editor-fold&gt;
3633 
3634     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3635     /**
3636      * The rank of a class is the length of the longest path between
3637      * the class and java.lang.Object in the class inheritance
3638      * graph. Undefined for all but reference types.
3639      */
3640     public int rank(Type t) {
3641         switch(t.getTag()) {
3642         case CLASS: {
3643             ClassType cls = (ClassType)t;
3644             if (cls.rank_field &lt; 0) {
3645                 Name fullname = cls.tsym.getQualifiedName();
3646                 if (fullname == names.java_lang_Object)
3647                     cls.rank_field = 0;
3648                 else {
3649                     int r = rank(supertype(cls));
3650                     for (List&lt;Type&gt; l = interfaces(cls);
3651                          l.nonEmpty();
3652                          l = l.tail) {
3653                         if (rank(l.head) &gt; r)
3654                             r = rank(l.head);
3655                     }
3656                     cls.rank_field = r + 1;
3657                 }
3658             }
3659             return cls.rank_field;
3660         }
3661         case TYPEVAR: {
3662             TypeVar tvar = (TypeVar)t;
3663             if (tvar.rank_field &lt; 0) {
3664                 int r = rank(supertype(tvar));
3665                 for (List&lt;Type&gt; l = interfaces(tvar);
3666                      l.nonEmpty();
3667                      l = l.tail) {
3668                     if (rank(l.head) &gt; r) r = rank(l.head);
3669                 }
3670                 tvar.rank_field = r + 1;
3671             }
3672             return tvar.rank_field;
3673         }
3674         case ERROR:
3675         case NONE:
3676             return 0;
3677         default:
3678             throw new AssertionError();
3679         }
3680     }
3681     // &lt;/editor-fold&gt;
3682 
3683     /**
3684      * Helper method for generating a string representation of a given type
3685      * accordingly to a given locale
3686      */
3687     public String toString(Type t, Locale locale) {
3688         return Printer.createStandardPrinter(messages).visit(t, locale);
3689     }
3690 
3691     /**
3692      * Helper method for generating a string representation of a given type
3693      * accordingly to a given locale
3694      */
3695     public String toString(Symbol t, Locale locale) {
3696         return Printer.createStandardPrinter(messages).visit(t, locale);
3697     }
3698 
3699     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3700     /**
3701      * This toString is slightly more descriptive than the one on Type.
3702      *
3703      * @deprecated Types.toString(Type t, Locale l) provides better support
3704      * for localization
3705      */
3706     @Deprecated
3707     public String toString(Type t) {
3708         if (t.hasTag(FORALL)) {
3709             ForAll forAll = (ForAll)t;
3710             return typaramsString(forAll.tvars) + forAll.qtype;
3711         }
3712         return &quot;&quot; + t;
3713     }
3714     // where
3715         private String typaramsString(List&lt;Type&gt; tvars) {
3716             StringBuilder s = new StringBuilder();
3717             s.append(&#39;&lt;&#39;);
3718             boolean first = true;
3719             for (Type t : tvars) {
3720                 if (!first) s.append(&quot;, &quot;);
3721                 first = false;
3722                 appendTyparamString(((TypeVar)t), s);
3723             }
3724             s.append(&#39;&gt;&#39;);
3725             return s.toString();
3726         }
3727         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3728             buf.append(t);
3729             if (t.getUpperBound() == null ||
3730                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3731                 return;
3732             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3733             Type bound = t.getUpperBound();
3734             if (!bound.isCompound()) {
3735                 buf.append(bound);
3736             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3737                 buf.append(supertype(t));
3738                 for (Type intf : interfaces(t)) {
3739                     buf.append(&#39;&amp;&#39;);
3740                     buf.append(intf);
3741                 }
3742             } else {
3743                 // No superclass was given in bounds.
3744                 // In this case, supertype is Object, erasure is first interface.
3745                 boolean first = true;
3746                 for (Type intf : interfaces(t)) {
3747                     if (!first) buf.append(&#39;&amp;&#39;);
3748                     first = false;
3749                     buf.append(intf);
3750                 }
3751             }
3752         }
3753     // &lt;/editor-fold&gt;
3754 
3755     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3756     /**
3757      * A cache for closures.
3758      *
3759      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3760      * a class or interface type, ordered by ClassSymbol.precedes
3761      * (that is, subclasses come first, arbitrary but fixed
3762      * otherwise).
3763      */
3764     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3765 
3766     /**
3767      * Returns the closure of a class or interface type.
3768      */
3769     public List&lt;Type&gt; closure(Type t) {
3770         List&lt;Type&gt; cl = closureCache.get(t);
3771         if (cl == null) {
3772             Type st = supertype(t);
3773             if (!t.isCompound()) {
3774                 if (st.hasTag(CLASS)) {
3775                     cl = insert(closure(st), t);
3776                 } else if (st.hasTag(TYPEVAR)) {
3777                     cl = closure(st).prepend(t);
3778                 } else {
3779                     cl = List.of(t);
3780                 }
3781             } else {
3782                 cl = closure(supertype(t));
3783             }
3784             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3785                 cl = union(cl, closure(l.head));
3786             closureCache.put(t, cl);
3787         }
3788         return cl;
3789     }
3790 
3791     /**
3792      * Collect types into a new closure (using a @code{ClosureHolder})
3793      */
3794     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3795         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3796                 ClosureHolder::add,
3797                 ClosureHolder::merge,
3798                 ClosureHolder::closure);
3799     }
3800     //where
3801         class ClosureHolder {
3802             List&lt;Type&gt; closure;
3803             final boolean minClosure;
3804             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3805 
3806             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3807                 this.closure = List.nil();
3808                 this.minClosure = minClosure;
3809                 this.shouldSkip = shouldSkip;
3810             }
3811 
3812             void add(Type type) {
3813                 closure = insert(closure, type, shouldSkip);
3814             }
3815 
3816             ClosureHolder merge(ClosureHolder other) {
3817                 closure = union(closure, other.closure, shouldSkip);
3818                 return this;
3819             }
3820 
3821             List&lt;Type&gt; closure() {
3822                 return minClosure ? closureMin(closure) : closure;
3823             }
3824         }
3825 
3826     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3827 
3828     /**
3829      * Insert a type in a closure
3830      */
3831     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3832         if (cl.isEmpty()) {
3833             return cl.prepend(t);
3834         } else if (shouldSkip.test(t, cl.head)) {
3835             return cl;
3836         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3837             return cl.prepend(t);
3838         } else {
3839             // t comes after head, or the two are unrelated
3840             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3841         }
3842     }
3843 
3844     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3845         return insert(cl, t, basicClosureSkip);
3846     }
3847 
3848     /**
3849      * Form the union of two closures
3850      */
3851     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3852         if (cl1.isEmpty()) {
3853             return cl2;
3854         } else if (cl2.isEmpty()) {
3855             return cl1;
3856         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3857             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3858         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3859             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3860         } else {
3861             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3862         }
3863     }
3864 
3865     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3866         return union(cl1, cl2, basicClosureSkip);
3867     }
3868 
3869     /**
3870      * Intersect two closures
3871      */
3872     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3873         if (cl1 == cl2)
3874             return cl1;
3875         if (cl1.isEmpty() || cl2.isEmpty())
3876             return List.nil();
3877         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3878             return intersect(cl1.tail, cl2);
3879         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3880             return intersect(cl1, cl2.tail);
3881         if (isSameType(cl1.head, cl2.head))
3882             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3883         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3884             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3885             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3886                 Type merge = merge(cl1.head,cl2.head);
3887                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3888             }
3889             if (cl1.head.isRaw() || cl2.head.isRaw())
3890                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3891         }
3892         return intersect(cl1.tail, cl2.tail);
3893     }
3894     // where
3895         class TypePair {
3896             final Type t1;
3897             final Type t2;;
3898 
3899             TypePair(Type t1, Type t2) {
3900                 this.t1 = t1;
3901                 this.t2 = t2;
3902             }
3903             @Override
3904             public int hashCode() {
3905                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3906             }
3907             @Override
3908             public boolean equals(Object obj) {
3909                 if (!(obj instanceof TypePair))
3910                     return false;
3911                 TypePair typePair = (TypePair)obj;
3912                 return isSameType(t1, typePair.t1)
3913                     &amp;&amp; isSameType(t2, typePair.t2);
3914             }
3915         }
3916         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3917         private Type merge(Type c1, Type c2) {
3918             ClassType class1 = (ClassType) c1;
3919             List&lt;Type&gt; act1 = class1.getTypeArguments();
3920             ClassType class2 = (ClassType) c2;
3921             List&lt;Type&gt; act2 = class2.getTypeArguments();
3922             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3923             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3924 
3925             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3926                 if (containsType(act1.head, act2.head)) {
3927                     merged.append(act1.head);
3928                 } else if (containsType(act2.head, act1.head)) {
3929                     merged.append(act2.head);
3930                 } else {
3931                     TypePair pair = new TypePair(c1, c2);
3932                     Type m;
3933                     if (mergeCache.add(pair)) {
3934                         m = new WildcardType(lub(wildUpperBound(act1.head),
3935                                                  wildUpperBound(act2.head)),
3936                                              BoundKind.EXTENDS,
3937                                              syms.boundClass);
3938                         mergeCache.remove(pair);
3939                     } else {
3940                         m = new WildcardType(syms.objectType,
3941                                              BoundKind.UNBOUND,
3942                                              syms.boundClass);
3943                     }
3944                     merged.append(m.withTypeVar(typarams.head));
3945                 }
3946                 act1 = act1.tail;
3947                 act2 = act2.tail;
3948                 typarams = typarams.tail;
3949             }
3950             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3951             // There is no spec detailing how type annotations are to
3952             // be inherited.  So set it to noAnnotations for now
3953             return new ClassType(class1.getEnclosingType(), merged.toList(),
3954                                  class1.tsym);
3955         }
3956 
3957     /**
3958      * Return the minimum type of a closure, a compound type if no
3959      * unique minimum exists.
3960      */
3961     private Type compoundMin(List&lt;Type&gt; cl) {
3962         if (cl.isEmpty()) return syms.objectType;
3963         List&lt;Type&gt; compound = closureMin(cl);
3964         if (compound.isEmpty())
3965             return null;
3966         else if (compound.tail.isEmpty())
3967             return compound.head;
3968         else
3969             return makeIntersectionType(compound);
3970     }
3971 
3972     /**
3973      * Return the minimum types of a closure, suitable for computing
3974      * compoundMin or glb.
3975      */
3976     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3977         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3978         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3979         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3980         while (!cl.isEmpty()) {
3981             Type current = cl.head;
3982             boolean keep = !toSkip.contains(current);
3983             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
3984                 // skip lower-bounded variables with a subtype in cl.tail
3985                 for (Type t : cl.tail) {
3986                     if (isSubtypeNoCapture(t, current)) {
3987                         keep = false;
3988                         break;
3989                     }
3990                 }
3991             }
3992             if (keep) {
3993                 if (current.isInterface())
3994                     interfaces.append(current);
3995                 else
3996                     classes.append(current);
3997                 for (Type t : cl.tail) {
3998                     // skip supertypes of &#39;current&#39; in cl.tail
3999                     if (isSubtypeNoCapture(current, t))
4000                         toSkip.add(t);
4001                 }
4002             }
4003             cl = cl.tail;
4004         }
4005         return classes.appendList(interfaces).toList();
4006     }
4007 
4008     /**
4009      * Return the least upper bound of list of types.  if the lub does
4010      * not exist return null.
4011      */
4012     public Type lub(List&lt;Type&gt; ts) {
4013         return lub(ts.toArray(new Type[ts.length()]));
4014     }
4015 
4016     /**
4017      * Return the least upper bound (lub) of set of types.  If the lub
4018      * does not exist return the type of null (bottom).
4019      */
4020     public Type lub(Type... ts) {
4021         final int UNKNOWN_BOUND = 0;
4022         final int ARRAY_BOUND = 1;
4023         final int CLASS_BOUND = 2;
4024 
4025         int[] kinds = new int[ts.length];
4026 
4027         boolean haveValues = false;
4028         boolean haveRefs = false;
4029         for (int i = 0 ; i &lt; ts.length ; i++) {
4030             if (ts[i].isValue())
4031                 haveValues = true;
4032             else
4033                 haveRefs = true;
4034         }
4035         if (haveRefs &amp;&amp; haveValues) {
4036             System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);
4037             for (int i = 0; i &lt; ts.length; i++) {
4038                 if (ts[i].isValue())
4039                     ts[i] = ts[i].referenceProjection();
4040             }
4041         }
4042 
4043         int boundkind = UNKNOWN_BOUND;
4044         for (int i = 0 ; i &lt; ts.length ; i++) {
4045             Type t = ts[i];
4046             switch (t.getTag()) {
4047             case CLASS:
4048                 boundkind |= kinds[i] = CLASS_BOUND;
4049                 break;
4050             case ARRAY:
4051                 boundkind |= kinds[i] = ARRAY_BOUND;
4052                 break;
4053             case  TYPEVAR:
4054                 do {
4055                     t = t.getUpperBound();
4056                 } while (t.hasTag(TYPEVAR));
4057                 if (t.hasTag(ARRAY)) {
4058                     boundkind |= kinds[i] = ARRAY_BOUND;
4059                 } else {
4060                     boundkind |= kinds[i] = CLASS_BOUND;
4061                 }
4062                 break;
4063             default:
4064                 kinds[i] = UNKNOWN_BOUND;
4065                 if (t.isPrimitive())
4066                     return syms.errType;
4067             }
4068         }
4069         switch (boundkind) {
4070         case 0:
4071             return syms.botType;
4072 
4073         case ARRAY_BOUND:
4074             // calculate lub(A[], B[])
4075             Type[] elements = new Type[ts.length];
4076             for (int i = 0 ; i &lt; ts.length ; i++) {
4077                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
4078                 if (elem.isPrimitive()) {
4079                     // if a primitive type is found, then return
4080                     // arraySuperType unless all the types are the
4081                     // same
4082                     Type first = ts[0];
4083                     for (int j = 1 ; j &lt; ts.length ; j++) {
4084                         if (!isSameType(first, ts[j])) {
4085                              // lub(int[], B[]) is Cloneable &amp; Serializable
4086                             return arraySuperType();
4087                         }
4088                     }
4089                     // all the array types are the same, return one
4090                     // lub(int[], int[]) is int[]
4091                     return first;
4092                 }
4093             }
4094             // lub(A[], B[]) is lub(A, B)[]
4095             return new ArrayType(lub(elements), syms.arrayClass);
4096 
4097         case CLASS_BOUND:
4098             // calculate lub(A, B)
4099             int startIdx = 0;
4100             for (int i = 0; i &lt; ts.length ; i++) {
4101                 Type t = ts[i];
4102                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
4103                     break;
4104                 } else {
4105                     startIdx++;
4106                 }
4107             }
4108             Assert.check(startIdx &lt; ts.length);
4109             //step 1 - compute erased candidate set (EC)
4110             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
4111             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4112                 Type t = ts[i];
4113                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
4114                     cl = intersect(cl, erasedSupertypes(t));
4115             }
4116             //step 2 - compute minimal erased candidate set (MEC)
4117             List&lt;Type&gt; mec = closureMin(cl);
4118             //step 3 - for each element G in MEC, compute lci(Inv(G))
4119             List&lt;Type&gt; candidates = List.nil();
4120             for (Type erasedSupertype : mec) {
4121                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4122                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4123                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4124                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4125                 }
4126                 candidates = candidates.appendList(lci);
4127             }
4128             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4129             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4130             return compoundMin(candidates);
4131 
4132         default:
4133             // calculate lub(A, B[])
4134             List&lt;Type&gt; classes = List.of(arraySuperType());
4135             for (int i = 0 ; i &lt; ts.length ; i++) {
4136                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4137                     classes = classes.prepend(ts[i]);
4138             }
4139             // lub(A, B[]) is lub(A, arraySuperType)
4140             return lub(classes);
4141         }
4142     }
4143     // where
4144         List&lt;Type&gt; erasedSupertypes(Type t) {
4145             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4146             for (Type sup : closure(t)) {
4147                 if (sup.hasTag(TYPEVAR)) {
4148                     buf.append(sup);
4149                 } else {
4150                     buf.append(erasure(sup));
4151                 }
4152             }
4153             return buf.toList();
4154         }
4155 
4156         private Type arraySuperType = null;
4157         private Type arraySuperType() {
4158             // initialized lazily to avoid problems during compiler startup
4159             if (arraySuperType == null) {
4160                 synchronized (this) {
4161                     if (arraySuperType == null) {
4162                         // JLS 10.8: all arrays implement Cloneable and Serializable.
4163                         List&lt;Type&gt; ifaces = injectTopInterfaceTypes ?
4164                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType):
4165                                 List.of(syms.serializableType, syms.cloneableType);
4166                         arraySuperType = makeIntersectionType(ifaces, true);
4167                     }
4168                 }
4169             }
4170             return arraySuperType;
4171         }
4172     // &lt;/editor-fold&gt;
4173 
4174     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4175     public Type glb(List&lt;Type&gt; ts) {
4176         Type t1 = ts.head;
4177         for (Type t2 : ts.tail) {
4178             if (t1.isErroneous())
4179                 return t1;
4180             t1 = glb(t1, t2);
4181         }
4182         return t1;
4183     }
4184     //where
4185     public Type glb(Type t, Type s) {
4186         if (s == null)
4187             return t;
4188         else if (t.isPrimitive() || s.isPrimitive())
4189             return syms.errType;
4190         else if (isSubtypeNoCapture(t, s))
4191             return t;
4192         else if (isSubtypeNoCapture(s, t))
4193             return s;
4194 
4195         List&lt;Type&gt; closure = union(closure(t), closure(s));
4196         return glbFlattened(closure, t);
4197     }
4198     //where
4199     /**
4200      * Perform glb for a list of non-primitive, non-error, non-compound types;
4201      * redundant elements are removed.  Bounds should be ordered according to
4202      * {@link Symbol#precedes(TypeSymbol,Types)}.
4203      *
4204      * @param flatBounds List of type to glb
4205      * @param errT Original type to use if the result is an error type
4206      */
4207     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4208         List&lt;Type&gt; bounds = closureMin(flatBounds);
4209 
4210         if (bounds.isEmpty()) {             // length == 0
4211             return syms.objectType;
4212         } else if (bounds.tail.isEmpty()) { // length == 1
4213             return bounds.head;
4214         } else {                            // length &gt; 1
4215             int classCount = 0;
4216             List&lt;Type&gt; cvars = List.nil();
4217             List&lt;Type&gt; lowers = List.nil();
4218             for (Type bound : bounds) {
4219                 if (!bound.isInterface()) {
4220                     classCount++;
4221                     Type lower = cvarLowerBound(bound);
4222                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4223                         cvars = cvars.append(bound);
4224                         lowers = lowers.append(lower);
4225                     }
4226                 }
4227             }
4228             if (classCount &gt; 1) {
4229                 if (lowers.isEmpty()) {
4230                     return createErrorType(errT);
4231                 } else {
4232                     // try again with lower bounds included instead of capture variables
4233                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4234                     return glb(newBounds);
4235                 }
4236             }
4237         }
4238         return makeIntersectionType(bounds);
4239     }
4240     // &lt;/editor-fold&gt;
4241 
4242     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4243     /**
4244      * Compute a hash code on a type.
4245      */
4246     public int hashCode(Type t) {
4247         return hashCode(t, false);
4248     }
4249 
4250     public int hashCode(Type t, boolean strict) {
4251         return strict ?
4252                 hashCodeStrictVisitor.visit(t) :
4253                 hashCodeVisitor.visit(t);
4254     }
4255     // where
4256         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4257         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4258             @Override
4259             public Integer visitTypeVar(TypeVar t, Void ignored) {
4260                 return System.identityHashCode(t);
4261             }
4262         };
4263 
4264         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4265             public Integer visitType(Type t, Void ignored) {
4266                 return t.getTag().ordinal();
4267             }
4268 
4269             @Override
4270             public Integer visitClassType(ClassType t, Void ignored) {
4271                 int result = visit(t.getEnclosingType());
4272                 result *= 127;
4273                 result += t.tsym.flatName().hashCode();
4274                 for (Type s : t.getTypeArguments()) {
4275                     result *= 127;
4276                     result += visit(s);
4277                 }
4278                 return result;
4279             }
4280 
4281             @Override
4282             public Integer visitMethodType(MethodType t, Void ignored) {
4283                 int h = METHOD.ordinal();
4284                 for (List&lt;Type&gt; thisargs = t.argtypes;
4285                      thisargs.tail != null;
4286                      thisargs = thisargs.tail)
4287                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4288                 return (h &lt;&lt; 5) + visit(t.restype);
4289             }
4290 
4291             @Override
4292             public Integer visitWildcardType(WildcardType t, Void ignored) {
4293                 int result = t.kind.hashCode();
4294                 if (t.type != null) {
4295                     result *= 127;
4296                     result += visit(t.type);
4297                 }
4298                 return result;
4299             }
4300 
4301             @Override
4302             public Integer visitArrayType(ArrayType t, Void ignored) {
4303                 return visit(t.elemtype) + 12;
4304             }
4305 
4306             @Override
4307             public Integer visitTypeVar(TypeVar t, Void ignored) {
4308                 return System.identityHashCode(t);
4309             }
4310 
4311             @Override
4312             public Integer visitUndetVar(UndetVar t, Void ignored) {
4313                 return System.identityHashCode(t);
4314             }
4315 
4316             @Override
4317             public Integer visitErrorType(ErrorType t, Void ignored) {
4318                 return 0;
4319             }
4320         }
4321     // &lt;/editor-fold&gt;
4322 
4323     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4324     /**
4325      * Does t have a result that is a subtype of the result type of s,
4326      * suitable for covariant returns?  It is assumed that both types
4327      * are (possibly polymorphic) method types.  Monomorphic method
4328      * types are handled in the obvious way.  Polymorphic method types
4329      * require renaming all type variables of one to corresponding
4330      * type variables in the other, where correspondence is by
4331      * position in the type parameter list. */
4332     public boolean resultSubtype(Type t, Type s, Warner warner) {
4333         List&lt;Type&gt; tvars = t.getTypeArguments();
4334         List&lt;Type&gt; svars = s.getTypeArguments();
4335         Type tres = t.getReturnType();
4336         Type sres = subst(s.getReturnType(), svars, tvars);
4337         return covariantReturnType(tres, sres, warner);
4338     }
4339 
4340     /**
4341      * Return-Type-Substitutable.
4342      * @jls 8.4.5 Method Result
4343      */
4344     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4345         if (hasSameArgs(r1, r2))
4346             return resultSubtype(r1, r2, noWarnings);
4347         else
4348             return covariantReturnType(r1.getReturnType(),
4349                                        erasure(r2.getReturnType()),
4350                                        noWarnings);
4351     }
4352 
4353     public boolean returnTypeSubstitutable(Type r1,
4354                                            Type r2, Type r2res,
4355                                            Warner warner) {
4356         if (isSameType(r1.getReturnType(), r2res))
4357             return true;
4358         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4359             return false;
4360 
4361         if (hasSameArgs(r1, r2))
4362             return covariantReturnType(r1.getReturnType(), r2res, warner);
4363         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4364             return true;
4365         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4366             return false;
4367         warner.warn(LintCategory.UNCHECKED);
4368         return true;
4369     }
4370 
4371     /**
4372      * Is t an appropriate return type in an overrider for a
4373      * method that returns s?
4374      */
4375     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4376         return
4377             isSameType(t, s) ||
4378             !t.isPrimitive() &amp;&amp;
4379             !s.isPrimitive() &amp;&amp;
4380             isAssignable(t, s, warner);
4381     }
4382     // &lt;/editor-fold&gt;
4383 
4384     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4385     /**
4386      * Return the class that boxes the given primitive.
4387      */
4388     public ClassSymbol boxedClass(Type t) {
4389         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4390     }
4391 
4392     /**
4393      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4394      */
4395     public Type boxedTypeOrType(Type t) {
4396         return t.isPrimitive() ?
4397             boxedClass(t).type :
4398             t;
4399     }
4400 
4401     /**
4402      * Return the primitive type corresponding to a boxed type.
4403      */
4404     public Type unboxedType(Type t) {
4405         for (int i=0; i&lt;syms.boxedName.length; i++) {
4406             Name box = syms.boxedName[i];
4407             if (box != null &amp;&amp;
4408                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4409                 return syms.typeOfTag[i];
4410         }
4411         return Type.noType;
4412     }
4413 
4414     /**
4415      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4416      */
4417     public Type unboxedTypeOrType(Type t) {
4418         Type unboxedType = unboxedType(t);
4419         return unboxedType.hasTag(NONE) ? t : unboxedType;
4420     }
4421     // &lt;/editor-fold&gt;
4422 
4423     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4424     /*
4425      * JLS 5.1.10 Capture Conversion:
4426      *
4427      * Let G name a generic type declaration with n formal type
4428      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4429      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4430      * where, for 1 &lt;= i &lt;= n:
4431      *
4432      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4433      *   Si is a fresh type variable whose upper bound is
4434      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4435      *   type.
4436      *
4437      * + If Ti is a wildcard type argument of the form ? extends Bi,
4438      *   then Si is a fresh type variable whose upper bound is
4439      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4440      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4441      *   a compile-time error if for any two classes (not interfaces)
4442      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4443      *
4444      * + If Ti is a wildcard type argument of the form ? super Bi,
4445      *   then Si is a fresh type variable whose upper bound is
4446      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4447      *
4448      * + Otherwise, Si = Ti.
4449      *
4450      * Capture conversion on any type other than a parameterized type
4451      * (4.5) acts as an identity conversion (5.1.1). Capture
4452      * conversions never require a special action at run time and
4453      * therefore never throw an exception at run time.
4454      *
4455      * Capture conversion is not applied recursively.
4456      */
4457     /**
4458      * Capture conversion as specified by the JLS.
4459      */
4460 
4461     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4462         List&lt;Type&gt; buf = List.nil();
4463         for (Type t : ts) {
4464             buf = buf.prepend(capture(t));
4465         }
4466         return buf.reverse();
4467     }
4468 
4469     public Type capture(Type t) {
4470         if (!t.hasTag(CLASS)) {
4471             return t;
4472         }
4473         if (t.getEnclosingType() != Type.noType) {
4474             Type capturedEncl = capture(t.getEnclosingType());
4475             if (capturedEncl != t.getEnclosingType()) {
4476                 Type type1 = memberType(capturedEncl, t.tsym);
4477                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4478             }
4479         }
4480         ClassType cls = (ClassType)t;
4481         if (cls.isRaw() || !cls.isParameterized())
4482             return cls;
4483 
4484         ClassType G = (ClassType)cls.asElement().asType();
4485         List&lt;Type&gt; A = G.getTypeArguments();
4486         List&lt;Type&gt; T = cls.getTypeArguments();
4487         List&lt;Type&gt; S = freshTypeVariables(T);
4488 
4489         List&lt;Type&gt; currentA = A;
4490         List&lt;Type&gt; currentT = T;
4491         List&lt;Type&gt; currentS = S;
4492         boolean captured = false;
4493         while (!currentA.isEmpty() &amp;&amp;
4494                !currentT.isEmpty() &amp;&amp;
4495                !currentS.isEmpty()) {
4496             if (currentS.head != currentT.head) {
4497                 captured = true;
4498                 WildcardType Ti = (WildcardType)currentT.head;
4499                 Type Ui = currentA.head.getUpperBound();
4500                 CapturedType Si = (CapturedType)currentS.head;
4501                 if (Ui == null)
4502                     Ui = syms.objectType;
4503                 switch (Ti.kind) {
4504                 case UNBOUND:
4505                     Si.setUpperBound( subst(Ui, A, S) );
4506                     Si.lower = syms.botType;
4507                     break;
4508                 case EXTENDS:
4509                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4510                     Si.lower = syms.botType;
4511                     break;
4512                 case SUPER:
4513                     Si.setUpperBound( subst(Ui, A, S) );
4514                     Si.lower = Ti.getSuperBound();
4515                     break;
4516                 }
4517                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4518                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4519                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4520                     !Si.lower.hasTag(ERROR) &amp;&amp;
4521                     isSameType(tmpBound, tmpLower)) {
4522                     currentS.head = Si.getUpperBound();
4523                 }
4524             }
4525             currentA = currentA.tail;
4526             currentT = currentT.tail;
4527             currentS = currentS.tail;
4528         }
4529         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4530             return erasure(t); // some &quot;rare&quot; type involved
4531 
4532         if (captured)
4533             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4534                                  cls.getMetadata());
4535         else
4536             return t;
4537     }
4538     // where
4539         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4540             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4541             for (Type t : types) {
4542                 if (t.hasTag(WILDCARD)) {
4543                     Type bound = ((WildcardType)t).getExtendsBound();
4544                     if (bound == null)
4545                         bound = syms.objectType;
4546                     result.append(new CapturedType(capturedName,
4547                                                    syms.noSymbol,
4548                                                    bound,
4549                                                    syms.botType,
4550                                                    (WildcardType)t));
4551                 } else {
4552                     result.append(t);
4553                 }
4554             }
4555             return result.toList();
4556         }
4557     // &lt;/editor-fold&gt;
4558 
4559     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4560     private boolean sideCast(Type from, Type to, Warner warn) {
4561         // We are casting from type $from$ to type $to$, which are
4562         // non-final unrelated types.  This method
4563         // tries to reject a cast by transferring type parameters
4564         // from $to$ to $from$ by common superinterfaces.
4565         boolean reverse = false;
4566         Type target = to;
4567         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4568             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4569             reverse = true;
4570             to = from;
4571             from = target;
4572         }
4573         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4574         boolean giveWarning = commonSupers.isEmpty();
4575         // The arguments to the supers could be unified here to
4576         // get a more accurate analysis
4577         while (commonSupers.nonEmpty()) {
4578             Type t1 = asSuper(from, commonSupers.head.tsym);
4579             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4580             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4581                 return false;
4582             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4583             commonSupers = commonSupers.tail;
4584         }
4585         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4586             warn.warn(LintCategory.UNCHECKED);
4587         return true;
4588     }
4589 
4590     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4591         // We are casting from type $from$ to type $to$, which are
4592         // unrelated types one of which is final and the other of
4593         // which is an interface.  This method
4594         // tries to reject a cast by transferring type parameters
4595         // from the final class to the interface.
4596         boolean reverse = false;
4597         Type target = to;
4598         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4599             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4600             reverse = true;
4601             to = from;
4602             from = target;
4603         }
4604         Assert.check((from.tsym.flags() &amp; FINAL) != 0);
4605         Type t1 = asSuper(from, to.tsym);
4606         if (t1 == null) return false;
4607         Type t2 = to;
4608         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4609             return false;
4610         if (!isReifiable(target) &amp;&amp;
4611             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4612             warn.warn(LintCategory.UNCHECKED);
4613         return true;
4614     }
4615 
4616     private boolean giveWarning(Type from, Type to) {
4617         List&lt;Type&gt; bounds = to.isCompound() ?
4618                 directSupertypes(to) : List.of(to);
4619         for (Type b : bounds) {
4620             Type subFrom = asSub(from, b.tsym);
4621             if (b.isParameterized() &amp;&amp;
4622                     (!(isUnbounded(b) ||
4623                     isSubtype(from, b) ||
4624                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4625                 return true;
4626             }
4627         }
4628         return false;
4629     }
4630 
4631     private List&lt;Type&gt; superClosure(Type t, Type s) {
4632         List&lt;Type&gt; cl = List.nil();
4633         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4634             if (isSubtype(s, erasure(l.head))) {
4635                 cl = insert(cl, l.head);
4636             } else {
4637                 cl = union(cl, superClosure(l.head, s));
4638             }
4639         }
4640         return cl;
4641     }
4642 
4643     private boolean containsTypeEquivalent(Type t, Type s) {
4644         return isSameType(t, s) || // shortcut
4645             containsType(t, s) &amp;&amp; containsType(s, t);
4646     }
4647 
4648     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4649     /**
4650      * Adapt a type by computing a substitution which maps a source
4651      * type to a target type.
4652      *
4653      * @param source    the source type
4654      * @param target    the target type
4655      * @param from      the type variables of the computed substitution
4656      * @param to        the types of the computed substitution.
4657      */
4658     public void adapt(Type source,
4659                        Type target,
4660                        ListBuffer&lt;Type&gt; from,
4661                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4662         new Adapter(from, to).adapt(source, target);
4663     }
4664 
4665     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4666 
4667         ListBuffer&lt;Type&gt; from;
4668         ListBuffer&lt;Type&gt; to;
4669         Map&lt;Symbol,Type&gt; mapping;
4670 
4671         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4672             this.from = from;
4673             this.to = to;
4674             mapping = new HashMap&lt;&gt;();
4675         }
4676 
4677         public void adapt(Type source, Type target) throws AdaptFailure {
4678             visit(source, target);
4679             List&lt;Type&gt; fromList = from.toList();
4680             List&lt;Type&gt; toList = to.toList();
4681             while (!fromList.isEmpty()) {
4682                 Type val = mapping.get(fromList.head.tsym);
4683                 if (toList.head != val)
4684                     toList.head = val;
4685                 fromList = fromList.tail;
4686                 toList = toList.tail;
4687             }
4688         }
4689 
4690         @Override
4691         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4692             if (target.hasTag(CLASS))
4693                 adaptRecursive(source.allparams(), target.allparams());
4694             return null;
4695         }
4696 
4697         @Override
4698         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4699             if (target.hasTag(ARRAY))
4700                 adaptRecursive(elemtype(source), elemtype(target));
4701             return null;
4702         }
4703 
4704         @Override
4705         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4706             if (source.isExtendsBound())
4707                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4708             else if (source.isSuperBound())
4709                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4710             return null;
4711         }
4712 
4713         @Override
4714         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4715             // Check to see if there is
4716             // already a mapping for $source$, in which case
4717             // the old mapping will be merged with the new
4718             Type val = mapping.get(source.tsym);
4719             if (val != null) {
4720                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4721                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4722                         ? target : val;
4723                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4724                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4725                         ? val : target;
4726                 } else if (!isSameType(val, target)) {
4727                     throw new AdaptFailure();
4728                 }
4729             } else {
4730                 val = target;
4731                 from.append(source);
4732                 to.append(target);
4733             }
4734             mapping.put(source.tsym, val);
4735             return null;
4736         }
4737 
4738         @Override
4739         public Void visitType(Type source, Type target) {
4740             return null;
4741         }
4742 
4743         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4744 
4745         private void adaptRecursive(Type source, Type target) {
4746             TypePair pair = new TypePair(source, target);
4747             if (cache.add(pair)) {
4748                 try {
4749                     visit(source, target);
4750                 } finally {
4751                     cache.remove(pair);
4752                 }
4753             }
4754         }
4755 
4756         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4757             if (source.length() == target.length()) {
4758                 while (source.nonEmpty()) {
4759                     adaptRecursive(source.head, target.head);
4760                     source = source.tail;
4761                     target = target.tail;
4762                 }
4763             }
4764         }
4765     }
4766 
4767     public static class AdaptFailure extends RuntimeException {
4768         static final long serialVersionUID = -7490231548272701566L;
4769     }
4770 
4771     private void adaptSelf(Type t,
4772                            ListBuffer&lt;Type&gt; from,
4773                            ListBuffer&lt;Type&gt; to) {
4774         try {
4775             //if (t.tsym.type != t)
4776                 adapt(t.tsym.type, t, from, to);
4777         } catch (AdaptFailure ex) {
4778             // Adapt should never fail calculating a mapping from
4779             // t.tsym.type to t as there can be no merge problem.
4780             throw new AssertionError(ex);
4781         }
4782     }
4783     // &lt;/editor-fold&gt;
4784 
4785     /**
4786      * Rewrite all type variables (universal quantifiers) in the given
4787      * type to wildcards (existential quantifiers).  This is used to
4788      * determine if a cast is allowed.  For example, if high is true
4789      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4790      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4791      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4792      * List&lt;Integer&gt;} with a warning.
4793      * @param t a type
4794      * @param high if true return an upper bound; otherwise a lower
4795      * bound
4796      * @param rewriteTypeVars only rewrite captured wildcards if false;
4797      * otherwise rewrite all type variables
4798      * @return the type rewritten with wildcards (existential
4799      * quantifiers) only
4800      */
4801     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4802         return new Rewriter(high, rewriteTypeVars).visit(t);
4803     }
4804 
4805     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4806 
4807         boolean high;
4808         boolean rewriteTypeVars;
4809 
4810         Rewriter(boolean high, boolean rewriteTypeVars) {
4811             this.high = high;
4812             this.rewriteTypeVars = rewriteTypeVars;
4813         }
4814 
4815         @Override
4816         public Type visitClassType(ClassType t, Void s) {
4817             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4818             boolean changed = false;
4819             for (Type arg : t.allparams()) {
4820                 Type bound = visit(arg);
4821                 if (arg != bound) {
4822                     changed = true;
4823                 }
4824                 rewritten.append(bound);
4825             }
4826             if (changed)
4827                 return subst(t.tsym.type,
4828                         t.tsym.type.allparams(),
4829                         rewritten.toList());
4830             else
4831                 return t;
4832         }
4833 
4834         public Type visitType(Type t, Void s) {
4835             return t;
4836         }
4837 
4838         @Override
4839         public Type visitCapturedType(CapturedType t, Void s) {
4840             Type w_bound = t.wildcard.type;
4841             Type bound = w_bound.contains(t) ?
4842                         erasure(w_bound) :
4843                         visit(w_bound);
4844             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4845         }
4846 
4847         @Override
4848         public Type visitTypeVar(TypeVar t, Void s) {
4849             if (rewriteTypeVars) {
4850                 Type bound = t.getUpperBound().contains(t) ?
4851                         erasure(t.getUpperBound()) :
4852                         visit(t.getUpperBound());
4853                 return rewriteAsWildcardType(bound, t, EXTENDS);
4854             } else {
4855                 return t;
4856             }
4857         }
4858 
4859         @Override
4860         public Type visitWildcardType(WildcardType t, Void s) {
4861             Type bound2 = visit(t.type);
4862             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4863         }
4864 
4865         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4866             switch (bk) {
4867                case EXTENDS: return high ?
4868                        makeExtendsWildcard(B(bound), formal) :
4869                        makeExtendsWildcard(syms.objectType, formal);
4870                case SUPER: return high ?
4871                        makeSuperWildcard(syms.botType, formal) :
4872                        makeSuperWildcard(B(bound), formal);
4873                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4874                default:
4875                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4876                    return null;
4877             }
4878         }
4879 
4880         Type B(Type t) {
4881             while (t.hasTag(WILDCARD)) {
4882                 WildcardType w = (WildcardType)t;
4883                 t = high ?
4884                     w.getExtendsBound() :
4885                     w.getSuperBound();
4886                 if (t == null) {
4887                     t = high ? syms.objectType : syms.botType;
4888                 }
4889             }
4890             return t;
4891         }
4892     }
4893 
4894 
4895     /**
4896      * Create a wildcard with the given upper (extends) bound; create
4897      * an unbounded wildcard if bound is Object.
4898      *
4899      * @param bound the upper bound
4900      * @param formal the formal type parameter that will be
4901      * substituted by the wildcard
4902      */
4903     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4904         if (bound == syms.objectType) {
4905             return new WildcardType(syms.objectType,
4906                                     BoundKind.UNBOUND,
4907                                     syms.boundClass,
4908                                     formal);
4909         } else {
4910             return new WildcardType(bound,
4911                                     BoundKind.EXTENDS,
4912                                     syms.boundClass,
4913                                     formal);
4914         }
4915     }
4916 
4917     /**
4918      * Create a wildcard with the given lower (super) bound; create an
4919      * unbounded wildcard if bound is bottom (type of {@code null}).
4920      *
4921      * @param bound the lower bound
4922      * @param formal the formal type parameter that will be
4923      * substituted by the wildcard
4924      */
4925     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4926         if (bound.hasTag(BOT)) {
4927             return new WildcardType(syms.objectType,
4928                                     BoundKind.UNBOUND,
4929                                     syms.boundClass,
4930                                     formal);
4931         } else {
4932             return new WildcardType(bound,
4933                                     BoundKind.SUPER,
4934                                     syms.boundClass,
4935                                     formal);
4936         }
4937     }
4938 
4939     /**
4940      * A wrapper for a type that allows use in sets.
4941      */
4942     public static class UniqueType {
4943         public final Type type;
4944         final Types types;
4945         private boolean encodeTypeSig;
4946 
4947         public UniqueType(Type type, Types types, boolean encodeTypeSig) {
4948             this.type = type;
4949             this.types = types;
4950             this.encodeTypeSig = encodeTypeSig;
4951         }
4952 
4953         public UniqueType(Type type, Types types) {
4954             this(type, types, true);
4955         }
4956 
4957         public int hashCode() {
4958             return types.hashCode(type);
4959         }
4960 
4961         public boolean equals(Object obj) {
4962             return (obj instanceof UniqueType) &amp;&amp;
4963                 types.isSameType(type, ((UniqueType)obj).type);
4964         }
4965 
4966         public boolean encodeTypeSig() {
4967             return encodeTypeSig;
4968         }
4969 
4970         public String toString() {
4971             return type.toString();
4972         }
4973 
4974     }
4975     // &lt;/editor-fold&gt;
4976 
4977     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4978     /**
4979      * A default visitor for types.  All visitor methods except
4980      * visitType are implemented by delegating to visitType.  Concrete
4981      * subclasses must provide an implementation of visitType and can
4982      * override other methods as needed.
4983      *
4984      * @param &lt;R&gt; the return type of the operation implemented by this
4985      * visitor; use Void if no return type is needed.
4986      * @param &lt;S&gt; the type of the second argument (the first being the
4987      * type itself) of the operation implemented by this visitor; use
4988      * Void if a second argument is not needed.
4989      */
4990     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4991         final public R visit(Type t, S s)               { return t.accept(this, s); }
4992         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4993         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
4994         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
4995         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
4996         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
4997         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
4998         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
4999         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
5000         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
5001         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
5002         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
5003     }
5004 
5005     /**
5006      * A default visitor for symbols.  All visitor methods except
5007      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
5008      * subclasses must provide an implementation of visitSymbol and can
5009      * override other methods as needed.
5010      *
5011      * @param &lt;R&gt; the return type of the operation implemented by this
5012      * visitor; use Void if no return type is needed.
5013      * @param &lt;S&gt; the type of the second argument (the first being the
5014      * symbol itself) of the operation implemented by this visitor; use
5015      * Void if a second argument is not needed.
5016      */
5017     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
5018         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
5019         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
5020         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
5021         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
5022         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
5023         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
5024         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
5025     }
5026 
5027     /**
5028      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
5029      * captured wildcards, for-all types (generic methods), and
5030      * undetermined type variables (part of inference) are hidden.
5031      * Captured wildcards are hidden by treating them as type
5032      * variables and the rest are hidden by visiting their qtypes.
5033      *
5034      * @param &lt;R&gt; the return type of the operation implemented by this
5035      * visitor; use Void if no return type is needed.
5036      * @param &lt;S&gt; the type of the second argument (the first being the
5037      * type itself) of the operation implemented by this visitor; use
5038      * Void if a second argument is not needed.
5039      */
5040     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
5041         @Override
5042         public R visitCapturedType(CapturedType t, S s) {
5043             return visitTypeVar(t, s);
5044         }
5045         @Override
5046         public R visitForAll(ForAll t, S s) {
5047             return visit(t.qtype, s);
5048         }
5049         @Override
5050         public R visitUndetVar(UndetVar t, S s) {
5051             return visit(t.qtype, s);
5052         }
5053     }
5054 
5055     /**
5056      * A plain relation on types.  That is a 2-ary function on the
5057      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
5058      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
5059      */
5060     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
5061 
5062     /**
5063      * A convenience visitor for implementing operations that only
5064      * require one argument (the type itself), that is, unary
5065      * operations.
5066      *
5067      * @param &lt;R&gt; the return type of the operation implemented by this
5068      * visitor; use Void if no return type is needed.
5069      */
5070     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
5071         final public R visit(Type t) { return t.accept(this, null); }
5072     }
5073 
5074     /**
5075      * A visitor for implementing a mapping from types to types.  The
5076      * default behavior of this class is to implement the identity
5077      * mapping (mapping a type to itself).  This can be overridden in
5078      * subclasses.
5079      *
5080      * @param &lt;S&gt; the type of the second argument (the first being the
5081      * type itself) of this mapping; use Void if a second argument is
5082      * not needed.
5083      */
5084     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
5085         final public Type visit(Type t) { return t.accept(this, null); }
5086         public Type visitType(Type t, S s) { return t; }
5087     }
5088 
5089     /**
5090      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
5091      * This class implements the functional interface {@code Function}, that allows it to be used
5092      * fluently in stream-like processing.
5093      */
5094     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
5095         @Override
5096         public Type apply(Type type) { return visit(type); }
5097 
5098         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
5099             return ts.map(t -&gt; visit(t, s));
5100         }
5101 
5102         @Override
5103         public Type visitCapturedType(CapturedType t, S s) {
5104             return visitTypeVar(t, s);
5105         }
5106     }
5107     // &lt;/editor-fold&gt;
5108 
5109 
5110     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
5111 
5112     public RetentionPolicy getRetention(Attribute.Compound a) {
5113         return getRetention(a.type.tsym);
5114     }
5115 
5116     public RetentionPolicy getRetention(TypeSymbol sym) {
5117         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
5118         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
5119         if (c != null) {
5120             Attribute value = c.member(names.value);
5121             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
5122                 Name levelName = ((Attribute.Enum)value).value.name;
5123                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
5124                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
5125                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
5126                 else ;// /* fail soft */ throw new AssertionError(levelName);
5127             }
5128         }
5129         return vis;
5130     }
5131     // &lt;/editor-fold&gt;
5132 
5133     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5134 
5135     public static abstract class SignatureGenerator {
5136 
5137         public static class InvalidSignatureException extends RuntimeException {
5138             private static final long serialVersionUID = 0;
5139 
5140             private final transient Type type;
5141 
5142             InvalidSignatureException(Type type) {
5143                 this.type = type;
5144             }
5145 
5146             public Type type() {
5147                 return type;
5148             }
5149         }
5150 
5151         private final Types types;
5152 
5153         protected abstract void append(char ch);
5154         protected abstract void append(byte[] ba);
5155         protected abstract void append(Name name);
5156         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5157 
5158         protected SignatureGenerator(Types types) {
5159             this.types = types;
5160         }
5161 
5162         protected void reportIllegalSignature(Type t) {
5163             throw new InvalidSignatureException(t);
5164         }
5165 
5166         /**
5167          * Assemble signature of given type in string buffer.
5168          */
5169         public void assembleSig(Type type) {
5170             switch (type.getTag()) {
5171                 case BYTE:
5172                     append(&#39;B&#39;);
5173                     break;
5174                 case SHORT:
5175                     append(&#39;S&#39;);
5176                     break;
5177                 case CHAR:
5178                     append(&#39;C&#39;);
5179                     break;
5180                 case INT:
5181                     append(&#39;I&#39;);
5182                     break;
5183                 case LONG:
5184                     append(&#39;J&#39;);
5185                     break;
5186                 case FLOAT:
5187                     append(&#39;F&#39;);
5188                     break;
5189                 case DOUBLE:
5190                     append(&#39;D&#39;);
5191                     break;
5192                 case BOOLEAN:
5193                     append(&#39;Z&#39;);
5194                     break;
5195                 case VOID:
5196                     append(&#39;V&#39;);
5197                     break;
5198                 case CLASS:
5199                     if (type.isCompound()) {
5200                         reportIllegalSignature(type);
5201                     }
5202                     if (types.isValue(type))
5203                         append(&#39;Q&#39;);
5204                     else
5205                         append(&#39;L&#39;);
5206                     assembleClassSig(type);
5207                     append(&#39;;&#39;);
5208                     break;
5209                 case ARRAY:
5210                     ArrayType at = (ArrayType) type;
5211                     append(&#39;[&#39;);
5212                     assembleSig(at.elemtype);
5213                     break;
5214                 case METHOD:
5215                     MethodType mt = (MethodType) type;
5216                     append(&#39;(&#39;);
5217                     assembleSig(mt.argtypes);
5218                     append(&#39;)&#39;);
5219                     assembleSig(mt.restype);
5220                     if (hasTypeVar(mt.thrown)) {
5221                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5222                             append(&#39;^&#39;);
5223                             assembleSig(l.head);
5224                         }
5225                     }
5226                     break;
5227                 case WILDCARD: {
5228                     Type.WildcardType ta = (Type.WildcardType) type;
5229                     switch (ta.kind) {
5230                         case SUPER:
5231                             append(&#39;-&#39;);
5232                             assembleSig(ta.type);
5233                             break;
5234                         case EXTENDS:
5235                             append(&#39;+&#39;);
5236                             assembleSig(ta.type);
5237                             break;
5238                         case UNBOUND:
5239                             append(&#39;*&#39;);
5240                             break;
5241                         default:
5242                             throw new AssertionError(ta.kind);
5243                     }
5244                     break;
5245                 }
5246                 case TYPEVAR:
5247                     if (((TypeVar)type).isCaptured()) {
5248                         reportIllegalSignature(type);
5249                     }
5250                     append(&#39;T&#39;);
5251                     append(type.tsym.name);
5252                     append(&#39;;&#39;);
5253                     break;
5254                 case FORALL:
5255                     Type.ForAll ft = (Type.ForAll) type;
5256                     assembleParamsSig(ft.tvars);
5257                     assembleSig(ft.qtype);
5258                     break;
5259                 default:
5260                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5261             }
5262         }
5263 
5264         public boolean hasTypeVar(List&lt;Type&gt; l) {
5265             while (l.nonEmpty()) {
5266                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5267                     return true;
5268                 }
5269                 l = l.tail;
5270             }
5271             return false;
5272         }
5273 
5274         public void assembleClassSig(Type type) {
5275             ClassType ct = (ClassType) type;
5276             ClassSymbol c = (ClassSymbol) ct.tsym;
5277             classReference(c);
5278             Type outer = ct.getEnclosingType();
5279             if (outer.allparams().nonEmpty()) {
5280                 boolean rawOuter =
5281                         c.owner.kind == MTH || // either a local class
5282                         c.name == types.names.empty; // or anonymous
5283                 assembleClassSig(rawOuter
5284                         ? types.erasure(outer)
5285                         : outer);
5286                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5287                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5288                 append(rawOuter
5289                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5290                         : c.name);
5291             } else {
5292                 append(externalize(c.flatname));
5293             }
5294             if (ct.getTypeArguments().nonEmpty()) {
5295                 append(&#39;&lt;&#39;);
5296                 assembleSig(ct.getTypeArguments());
5297                 append(&#39;&gt;&#39;);
5298             }
5299         }
5300 
5301         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5302             append(&#39;&lt;&#39;);
5303             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5304                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5305                 append(tvar.tsym.name);
5306                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5307                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5308                     append(&#39;:&#39;);
5309                 }
5310                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5311                     append(&#39;:&#39;);
5312                     assembleSig(l.head);
5313                 }
5314             }
5315             append(&#39;&gt;&#39;);
5316         }
5317 
5318         public void assembleSig(List&lt;Type&gt; types) {
5319             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5320                 assembleSig(ts.head);
5321             }
5322         }
5323     }
5324 
5325     public Type constantType(LoadableConstant c) {
5326         switch (c.poolTag()) {
5327             case ClassFile.CONSTANT_Class:
5328                 return syms.classType;
5329             case ClassFile.CONSTANT_String:
5330                 return syms.stringType;
5331             case ClassFile.CONSTANT_Integer:
5332                 return syms.intType;
5333             case ClassFile.CONSTANT_Float:
5334                 return syms.floatType;
5335             case ClassFile.CONSTANT_Long:
5336                 return syms.longType;
5337             case ClassFile.CONSTANT_Double:
5338                 return syms.doubleType;
5339             case ClassFile.CONSTANT_MethodHandle:
5340                 return syms.methodHandleType;
5341             case ClassFile.CONSTANT_MethodType:
5342                 return syms.methodTypeType;
5343             case ClassFile.CONSTANT_Dynamic:
5344                 return ((DynamicVarSymbol)c).type;
5345             default:
5346                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5347         }
5348     }
5349     // &lt;/editor-fold&gt;
5350 
5351     public void newRound() {
5352         descCache._map.clear();
5353         isDerivedRawCache.clear();
5354         implCache._map.clear();
5355         membersCache._map.clear();
5356         closureCache.clear();
5357     }
5358 }
    </pre>
  </body>
</html>
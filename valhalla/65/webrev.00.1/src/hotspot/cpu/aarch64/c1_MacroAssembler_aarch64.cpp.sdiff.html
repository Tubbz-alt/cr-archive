<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;


 32 #include &quot;interpreter/interpreter.hpp&quot;
 33 #include &quot;oops/arrayOop.hpp&quot;
 34 #include &quot;oops/markWord.hpp&quot;
 35 #include &quot;runtime/basicLock.hpp&quot;
 36 #include &quot;runtime/biasedLocking.hpp&quot;
 37 #include &quot;runtime/os.hpp&quot;
 38 #include &quot;runtime/sharedRuntime.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 
 41 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 42                                   FloatRegister f0, FloatRegister f1,
 43                                   Register result)
 44 {
 45   Label done;
 46   if (is_float) {
 47     fcmps(f0, f1);
 48   } else {
 49     fcmpd(f0, f1);
 50   }
 51   if (unordered_result &lt; 0) {
</pre>
<hr />
<pre>
 67   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 68   Label done;
 69   int null_check_offset = -1;
 70 
 71   verify_oop(obj);
 72 
 73   // save object being locked into the BasicObjectLock
 74   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 75 
 76   if (UseBiasedLocking) {
 77     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 78     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 79   } else {
 80     null_check_offset = offset();
 81   }
 82 
 83   // Load object header
 84   ldr(hdr, Address(obj, hdr_offset));
 85   // and mark it as unlocked
 86   orr(hdr, hdr, markWord::unlocked_value);






 87   // save unlocked object header into the displaced header location on the stack
 88   str(hdr, Address(disp_hdr, 0));
 89   // test if object header is still the same (i.e. unlocked), and if so, store the
 90   // displaced header address in the object header - if it is not the same, get the
 91   // object header instead
 92   lea(rscratch2, Address(obj, hdr_offset));
 93   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
 94   // if the object header was the same, we&#39;re done
 95   // if the object header was not the same, it is now in the hdr register
 96   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
 97   //
 98   // 1) (hdr &amp; aligned_mask) == 0
 99   // 2) sp &lt;= hdr
100   // 3) hdr &lt;= sp + page_size
101   //
102   // these 3 tests can be done by evaluating the following expression:
103   //
104   // (hdr - sp) &amp; (aligned_mask - page_size)
105   //
106   // assuming both the stack pointer and page_size have their least
</pre>
<hr />
<pre>
314 
315   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
316     assert(obj == r0, &quot;must be&quot;);
317     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
318   }
319 
320   verify_oop(obj);
321 }
322 
323 
324 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
325   verify_oop(receiver);
326   // explicit NULL check not needed since load from [klass_offset] causes a trap
327   // check against inline cache
328   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
329 
330   cmp_klass(receiver, iCache, rscratch1);
331 }
332 
333 
<span class="line-modified">334 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes) {</span>
335   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
336   // Make sure there is enough stack space for this method&#39;s activation.
337   // Note that we do this before doing an enter().
338   generate_stack_overflow_check(bang_size_in_bytes);






339   MacroAssembler::build_frame(framesize + 2 * wordSize);
340 
341   // Insert nmethod entry barrier into frame.
342   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
343   bs-&gt;nmethod_entry_barrier(this);
344 }
345 
<span class="line-modified">346 void C1_MacroAssembler::remove_frame(int framesize) {</span>



347   MacroAssembler::remove_frame(framesize + 2 * wordSize);
348 }
349 





























350 
<span class="line-modified">351 void C1_MacroAssembler::verified_entry() {</span>
<span class="line-modified">352   // If we have to make this method not-entrant we&#39;ll overwrite its</span>
<span class="line-modified">353   // first instruction with a jump.  For this action to be legal we</span>
<span class="line-modified">354   // must ensure that this first instruction is a B, BL, NOP, BKPT,</span>
<span class="line-modified">355   // SVC, HVC, or SMC.  Make it a NOP.</span>



























































356   nop();
357 }
358 

359 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
360   // rbp, + 0: link
361   //     + 1: return address
362   //     + 2: argument with offset 0
363   //     + 3: argument with offset 1
364   //     + 4: ...
365 
366   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
367 }
368 
369 #ifndef PRODUCT
370 
371 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
372   if (!VerifyOops) return;
373   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
374 }
375 
376 void C1_MacroAssembler::verify_not_null_oop(Register r) {
377   if (!VerifyOops) return;
378   Label not_null;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-added"> 32 #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-added"> 33 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;oops/arrayOop.hpp&quot;
 36 #include &quot;oops/markWord.hpp&quot;
 37 #include &quot;runtime/basicLock.hpp&quot;
 38 #include &quot;runtime/biasedLocking.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/sharedRuntime.hpp&quot;
 41 #include &quot;runtime/stubRoutines.hpp&quot;
 42 
 43 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 44                                   FloatRegister f0, FloatRegister f1,
 45                                   Register result)
 46 {
 47   Label done;
 48   if (is_float) {
 49     fcmps(f0, f1);
 50   } else {
 51     fcmpd(f0, f1);
 52   }
 53   if (unordered_result &lt; 0) {
</pre>
<hr />
<pre>
 69   assert(hdr != obj &amp;&amp; hdr != disp_hdr &amp;&amp; obj != disp_hdr, &quot;registers must be different&quot;);
 70   Label done;
 71   int null_check_offset = -1;
 72 
 73   verify_oop(obj);
 74 
 75   // save object being locked into the BasicObjectLock
 76   str(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
 77 
 78   if (UseBiasedLocking) {
 79     assert(scratch != noreg, &quot;should have scratch register at this point&quot;);
 80     null_check_offset = biased_locking_enter(disp_hdr, obj, hdr, scratch, false, done, &amp;slow_case);
 81   } else {
 82     null_check_offset = offset();
 83   }
 84 
 85   // Load object header
 86   ldr(hdr, Address(obj, hdr_offset));
 87   // and mark it as unlocked
 88   orr(hdr, hdr, markWord::unlocked_value);
<span class="line-added"> 89 </span>
<span class="line-added"> 90   if (EnableValhalla &amp;&amp; !UseBiasedLocking) {</span>
<span class="line-added"> 91     // Mask always_locked bit such that we go to the slow path if object is a value type</span>
<span class="line-added"> 92     andr(hdr, hdr, ~markWord::biased_lock_bit_in_place);</span>
<span class="line-added"> 93   }</span>
<span class="line-added"> 94 </span>
 95   // save unlocked object header into the displaced header location on the stack
 96   str(hdr, Address(disp_hdr, 0));
 97   // test if object header is still the same (i.e. unlocked), and if so, store the
 98   // displaced header address in the object header - if it is not the same, get the
 99   // object header instead
100   lea(rscratch2, Address(obj, hdr_offset));
101   cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, /*fallthough*/NULL);
102   // if the object header was the same, we&#39;re done
103   // if the object header was not the same, it is now in the hdr register
104   // =&gt; test if it is a stack pointer into the same stack (recursive locking), i.e.:
105   //
106   // 1) (hdr &amp; aligned_mask) == 0
107   // 2) sp &lt;= hdr
108   // 3) hdr &lt;= sp + page_size
109   //
110   // these 3 tests can be done by evaluating the following expression:
111   //
112   // (hdr - sp) &amp; (aligned_mask - page_size)
113   //
114   // assuming both the stack pointer and page_size have their least
</pre>
<hr />
<pre>
322 
323   if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
324     assert(obj == r0, &quot;must be&quot;);
325     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));
326   }
327 
328   verify_oop(obj);
329 }
330 
331 
332 void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
333   verify_oop(receiver);
334   // explicit NULL check not needed since load from [klass_offset] causes a trap
335   // check against inline cache
336   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
337 
338   cmp_klass(receiver, iCache, rscratch1);
339 }
340 
341 
<span class="line-modified">342 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, bool needs_stack_repair, Label* verified_value_entry_label) {</span>
343   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
344   // Make sure there is enough stack space for this method&#39;s activation.
345   // Note that we do this before doing an enter().
346   generate_stack_overflow_check(bang_size_in_bytes);
<span class="line-added">347 </span>
<span class="line-added">348   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);</span>
<span class="line-added">349   if (verified_value_entry_label != NULL) {</span>
<span class="line-added">350     bind(*verified_value_entry_label);</span>
<span class="line-added">351   }</span>
<span class="line-added">352 </span>
353   MacroAssembler::build_frame(framesize + 2 * wordSize);
354 
355   // Insert nmethod entry barrier into frame.
356   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
357   bs-&gt;nmethod_entry_barrier(this);
358 }
359 
<span class="line-modified">360 void C1_MacroAssembler::remove_frame(int framesize, bool needs_stack_repair) {</span>
<span class="line-added">361 </span>
<span class="line-added">362   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);</span>
<span class="line-added">363 </span>
364   MacroAssembler::remove_frame(framesize + 2 * wordSize);
365 }
366 
<span class="line-added">367 void C1_MacroAssembler::verified_value_entry() {</span>
<span class="line-added">368   if (C1Breakpoint || VerifyFPU || !UseStackBanging) {</span>
<span class="line-added">369     // Verified Entry first instruction should be 5 bytes long for correct</span>
<span class="line-added">370     // patching by patch_verified_entry().</span>
<span class="line-added">371     //</span>
<span class="line-added">372     // C1Breakpoint and VerifyFPU have one byte first instruction.</span>
<span class="line-added">373     // Also first instruction will be one byte &quot;push(rbp)&quot; if stack banging</span>
<span class="line-added">374     // code is not generated (see build_frame() above).</span>
<span class="line-added">375     // For all these cases generate long instruction first.</span>
<span class="line-added">376     nop();</span>
<span class="line-added">377   }</span>
<span class="line-added">378 </span>
<span class="line-added">379   nop();</span>
<span class="line-added">380   // build frame</span>
<span class="line-added">381   // verify_FPU(0, &quot;method_entry&quot;);</span>
<span class="line-added">382 }</span>
<span class="line-added">383 </span>
<span class="line-added">384 int C1_MacroAssembler::scalarized_entry(const CompiledEntrySignature *ces, int frame_size_in_bytes, int bang_size_in_bytes, Label&amp; verified_value_entry_label, bool is_value_ro_entry) {</span>
<span class="line-added">385   // This function required to support for InlineTypePassFieldsAsArgs</span>
<span class="line-added">386   if (C1Breakpoint || VerifyFPU || !UseStackBanging) {</span>
<span class="line-added">387     // Verified Entry first instruction should be 5 bytes long for correct</span>
<span class="line-added">388     // patching by patch_verified_entry().</span>
<span class="line-added">389     //</span>
<span class="line-added">390     // C1Breakpoint and VerifyFPU have one byte first instruction.</span>
<span class="line-added">391     // Also first instruction will be one byte &quot;push(rbp)&quot; if stack banging</span>
<span class="line-added">392     // code is not generated (see build_frame() above).</span>
<span class="line-added">393     // For all these cases generate long instruction first.</span>
<span class="line-added">394     nop();</span>
<span class="line-added">395   }</span>
396 
<span class="line-modified">397   nop();</span>
<span class="line-modified">398   // verify_FPU(0, &quot;method_entry&quot;);</span>
<span class="line-modified">399 </span>
<span class="line-modified">400   assert(InlineTypePassFieldsAsArgs, &quot;sanity&quot;);</span>
<span class="line-modified">401 </span>
<span class="line-added">402   GrowableArray&lt;SigEntry&gt;* sig   = &amp;ces-&gt;sig();</span>
<span class="line-added">403   GrowableArray&lt;SigEntry&gt;* sig_cc = is_value_ro_entry ? &amp;ces-&gt;sig_cc_ro() : &amp;ces-&gt;sig_cc();</span>
<span class="line-added">404   VMRegPair* regs      = ces-&gt;regs();</span>
<span class="line-added">405   VMRegPair* regs_cc   = is_value_ro_entry ? ces-&gt;regs_cc_ro() : ces-&gt;regs_cc();</span>
<span class="line-added">406   int args_on_stack    = ces-&gt;args_on_stack();</span>
<span class="line-added">407   int args_on_stack_cc = is_value_ro_entry ? ces-&gt;args_on_stack_cc_ro() : ces-&gt;args_on_stack_cc();</span>
<span class="line-added">408 </span>
<span class="line-added">409   assert(sig-&gt;length() &lt;= sig_cc-&gt;length(), &quot;Zero-sized value class not allowed!&quot;);</span>
<span class="line-added">410   BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig_cc-&gt;length());</span>
<span class="line-added">411   int args_passed = sig-&gt;length();</span>
<span class="line-added">412   int args_passed_cc = SigEntry::fill_sig_bt(sig_cc, sig_bt);</span>
<span class="line-added">413 </span>
<span class="line-added">414   int extra_stack_offset = wordSize; // tos is return address.</span>
<span class="line-added">415 </span>
<span class="line-added">416   // Create a temp frame so we can call into runtime. It must be properly set up to accomodate GC.</span>
<span class="line-added">417   int sp_inc = (args_on_stack - args_on_stack_cc) * VMRegImpl::stack_slot_size;</span>
<span class="line-added">418   if (sp_inc &gt; 0) {</span>
<span class="line-added">419     sp_inc = align_up(sp_inc, StackAlignmentInBytes);</span>
<span class="line-added">420     sub(sp, sp, sp_inc);</span>
<span class="line-added">421   } else {</span>
<span class="line-added">422     sp_inc = 0;</span>
<span class="line-added">423   }</span>
<span class="line-added">424 </span>
<span class="line-added">425   sub(sp, sp, frame_size_in_bytes);</span>
<span class="line-added">426   if (sp_inc &gt; 0) {</span>
<span class="line-added">427     int real_frame_size = frame_size_in_bytes +</span>
<span class="line-added">428            + wordSize  // pushed rbp</span>
<span class="line-added">429            + wordSize  // returned address pushed by the stack extension code</span>
<span class="line-added">430            + sp_inc;   // stack extension</span>
<span class="line-added">431     mov(rscratch1, real_frame_size);</span>
<span class="line-added">432     str(rscratch1, Address(sp, frame_size_in_bytes - wordSize));</span>
<span class="line-added">433   }</span>
<span class="line-added">434 </span>
<span class="line-added">435   // FIXME -- call runtime only if we cannot in-line allocate all the incoming value args.</span>
<span class="line-added">436   mov(r1, (intptr_t) ces-&gt;method());</span>
<span class="line-added">437   if (is_value_ro_entry) {</span>
<span class="line-added">438     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_value_args_no_receiver_id)));</span>
<span class="line-added">439   } else {</span>
<span class="line-added">440     far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_value_args_id)));</span>
<span class="line-added">441   }</span>
<span class="line-added">442   int rt_call_offset = offset();</span>
<span class="line-added">443 </span>
<span class="line-added">444   // Remove the temp frame</span>
<span class="line-added">445   add(sp, sp, frame_size_in_bytes);</span>
<span class="line-added">446 </span>
<span class="line-added">447   int n = shuffle_value_args(true, is_value_ro_entry, extra_stack_offset, sig_bt, sig_cc,</span>
<span class="line-added">448                              args_passed_cc, args_on_stack_cc, regs_cc, // from</span>
<span class="line-added">449                              args_passed, args_on_stack, regs);         // to</span>
<span class="line-added">450   assert(sp_inc == n, &quot;must be&quot;);</span>
<span class="line-added">451 </span>
<span class="line-added">452   if (sp_inc != 0) {</span>
<span class="line-added">453     // Do the stack banging here, and skip over the stack repair code in the</span>
<span class="line-added">454     // verified_value_entry (which has a different real_frame_size).</span>
<span class="line-added">455     assert(sp_inc &gt; 0, &quot;stack should not shrink&quot;);</span>
<span class="line-added">456     generate_stack_overflow_check(bang_size_in_bytes);</span>
<span class="line-added">457     decrement(sp, frame_size_in_bytes);</span>
<span class="line-added">458   }</span>
<span class="line-added">459 </span>
<span class="line-added">460   b(verified_value_entry_label);</span>
461   return rt_call_offset;
462 }
463 
<span class="line-added">464 </span>
465 void C1_MacroAssembler::load_parameter(int offset_in_words, Register reg) {
466   // rbp, + 0: link
467   //     + 1: return address
468   //     + 2: argument with offset 0
469   //     + 3: argument with offset 1
470   //     + 4: ...
471 
472   ldr(reg, Address(rfp, (offset_in_words + 2) * BytesPerWord));
473 }
474 
475 #ifndef PRODUCT
476 
477 void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
478   if (!VerifyOops) return;
479   verify_oop_addr(Address(sp, stack_offset), &quot;oop&quot;);
480 }
481 
482 void C1_MacroAssembler::verify_not_null_oop(Register r) {
483   if (!VerifyOops) return;
484   Label not_null;
</pre>
</td>
</tr>
</table>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
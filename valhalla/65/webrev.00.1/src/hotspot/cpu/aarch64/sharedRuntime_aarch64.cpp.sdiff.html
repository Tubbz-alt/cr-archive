<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;

  29 #include &quot;code/debugInfoRec.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;nativeInst_aarch64.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #include &quot;vmreg_aarch64.inline.hpp&quot;
  45 #ifdef COMPILER1
  46 #include &quot;c1/c1_Runtime1.hpp&quot;
  47 #endif
  48 #ifdef COMPILER2
</pre>
<hr />
<pre>
 273     case T_SHORT:
 274     case T_INT:
 275       if (int_args &lt; Argument::n_int_register_parameters_j) {
 276         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 277       } else {
 278         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 279         stk_args += 2;
 280       }
 281       break;
 282     case T_VOID:
 283       // halves of T_LONG or T_DOUBLE
 284       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 285       regs[i].set_bad();
 286       break;
 287     case T_LONG:
 288       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 289       // fall through
 290     case T_OBJECT:
 291     case T_ARRAY:
 292     case T_ADDRESS:

 293       if (int_args &lt; Argument::n_int_register_parameters_j) {
 294         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 295       } else {
 296         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 297         stk_args += 2;
 298       }
 299       break;
 300     case T_FLOAT:
 301       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 302         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 303       } else {
 304         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 305         stk_args += 2;
 306       }
 307       break;
 308     case T_DOUBLE:
 309       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 310       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 311         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 312       } else {
 313         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 314         stk_args += 2;
 315       }
 316       break;
 317     default:
 318       ShouldNotReachHere();
 319       break;
 320     }
 321   }
 322 
 323   return align_up(stk_args, 2);
 324 }
 325 




















































































 326 // Patch the callers callsite with entry to compiled code if it exists.
 327 static void patch_callers_callsite(MacroAssembler *masm) {
 328   Label L;
 329   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 330   __ cbz(rscratch1, L);
 331 
 332   __ enter();
 333   __ push_CPU_state();
 334 
 335   // VM needs caller&#39;s callsite
 336   // VM needs target method
 337   // This needs to be a long call since we will relocate this adapter to
 338   // the codeBuffer and it may not reach
 339 
 340 #ifndef PRODUCT
 341   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 342 #endif
 343 
 344   __ mov(c_rarg0, rmethod);
 345   __ mov(c_rarg1, lr);
 346   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 347   __ blr(rscratch1);
 348   __ maybe_isb();
 349 
 350   __ pop_CPU_state();
 351   // restore sp
 352   __ leave();
 353   __ bind(L);
 354 }
 355 
<span class="line-modified"> 356 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-modified"> 357                             int total_args_passed,</span>
<span class="line-modified"> 358                             int comp_args_on_stack,</span>
<span class="line-modified"> 359                             const BasicType *sig_bt,</span>
<span class="line-modified"> 360                             const VMRegPair *regs,</span>
<span class="line-modified"> 361                             Label&amp; skip_fixup) {</span>
<span class="line-modified"> 362   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-modified"> 363   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-modified"> 364   // interpreter, which means the caller made a static call to get here</span>
<span class="line-modified"> 365   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-modified"> 366   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-modified"> 367   patch_callers_callsite(masm);</span>
<span class="line-modified"> 368 </span>
<span class="line-modified"> 369   __ bind(skip_fixup);</span>
<span class="line-modified"> 370 </span>
<span class="line-modified"> 371   int words_pushed = 0;</span>
<span class="line-modified"> 372 </span>
<span class="line-modified"> 373   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-modified"> 374   // Interpreter::stackElementSize is the space we need.</span>























 375 
<span class="line-modified"> 376   int extraspace = total_args_passed * Interpreter::stackElementSize;</span>

 377 
<span class="line-modified"> 378   __ mov(r13, sp);</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380   // stack is aligned, keep it that way</span>
 381   extraspace = align_up(extraspace, 2*wordSize);
 382 
<span class="line-modified"> 383   if (extraspace)</span>
<span class="line-removed"> 384     __ sub(sp, sp, extraspace);</span>
<span class="line-removed"> 385 </span>
<span class="line-removed"> 386   // Now write the args into the outgoing interpreter space</span>
<span class="line-removed"> 387   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-removed"> 388     if (sig_bt[i] == T_VOID) {</span>
<span class="line-removed"> 389       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-removed"> 390       continue;</span>
<span class="line-removed"> 391     }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393     // offset to start parameters</span>
<span class="line-removed"> 394     int st_off   = (total_args_passed - i - 1) * Interpreter::stackElementSize;</span>
<span class="line-removed"> 395     int next_off = st_off - Interpreter::stackElementSize;</span>
 396 
 397     // Say 4 args:
 398     // i   st_off
 399     // 0   32 T_LONG
 400     // 1   24 T_VOID
 401     // 2   16 T_OBJECT
 402     // 3    8 T_BOOL
 403     // -    0 return address
 404     //
 405     // However to make thing extra confusing. Because we can fit a long/double in
 406     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 407     // leaves one slot empty and only stores to a single slot. In this case the
 408     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 409 
<span class="line-modified"> 410     VMReg r_1 = regs[i].first();</span>
<span class="line-modified"> 411     VMReg r_2 = regs[i].second();</span>



 412     if (!r_1-&gt;is_valid()) {
 413       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 414       continue;</span>
 415     }

 416     if (r_1-&gt;is_stack()) {
 417       // memory to memory use rscratch1
<span class="line-modified"> 418       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size</span>
<span class="line-modified"> 419                     + extraspace</span>
<span class="line-removed"> 420                     + words_pushed * wordSize);</span>
 421       if (!r_2-&gt;is_valid()) {
 422         // sign extend??
 423         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 424         __ str(rscratch1, Address(sp, st_off));</span>
 425 
 426       } else {
<span class="line-modified"> 427 </span>
<span class="line-removed"> 428         __ ldr(rscratch1, Address(sp, ld_off));</span>
<span class="line-removed"> 429 </span>
<span class="line-removed"> 430         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 431         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 432         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 433           // ld_off == LSW, ld_off+wordSize == MSW</span>
<span class="line-removed"> 434           // st_off == MSW, next_off == LSW</span>
<span class="line-removed"> 435           __ str(rscratch1, Address(sp, next_off));</span>
<span class="line-removed"> 436 #ifdef ASSERT</span>
<span class="line-removed"> 437           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 438           __ mov(rscratch1, 0xdeadffffdeadaaaaul);</span>
<span class="line-removed"> 439           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 440 #endif /* ASSERT */</span>
<span class="line-removed"> 441         } else {</span>
<span class="line-removed"> 442           __ str(rscratch1, Address(sp, st_off));</span>
 443         }
 444       }
 445     } else if (r_1-&gt;is_Register()) {
 446       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 447       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 448         // must be only an int (or less ) so move only 32bits to slot</span>
<span class="line-removed"> 449         // why not sign extend??</span>
<span class="line-removed"> 450         __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 451       } else {</span>
<span class="line-removed"> 452         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG</span>
<span class="line-removed"> 453         // T_DOUBLE and T_LONG use two slots in the interpreter</span>
<span class="line-removed"> 454         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {</span>
<span class="line-removed"> 455           // long/double in gpr</span>
<span class="line-removed"> 456 #ifdef ASSERT</span>
<span class="line-removed"> 457           // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 458           __ mov(rscratch1, 0xdeadffffdeadaaabul);</span>
<span class="line-removed"> 459           __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 460 #endif /* ASSERT */</span>
<span class="line-removed"> 461           __ str(r, Address(sp, next_off));</span>
<span class="line-removed"> 462         } else {</span>
<span class="line-removed"> 463           __ str(r, Address(sp, st_off));</span>
<span class="line-removed"> 464         }</span>
<span class="line-removed"> 465       }</span>
 466     } else {
 467       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 468       if (!r_2-&gt;is_valid()) {
 469         // only a float use just part of the slot
<span class="line-modified"> 470         __ strs(r_1-&gt;as_FloatRegister(), Address(sp, st_off));</span>
 471       } else {
<span class="line-modified"> 472 #ifdef ASSERT</span>
<span class="line-removed"> 473         // Overwrite the unused slot with known junk</span>
<span class="line-removed"> 474         __ mov(rscratch1, 0xdeadffffdeadaaacul);</span>
<span class="line-removed"> 475         __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-removed"> 476 #endif /* ASSERT */</span>
<span class="line-removed"> 477         __ strd(r_1-&gt;as_FloatRegister(), Address(sp, next_off));</span>
 478       }
































































































































































 479     }







 480   }
 481 
 482   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 483 
 484   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 485   __ br(rscratch1);
 486 }
 487 

 488 
<span class="line-removed"> 489 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,</span>
<span class="line-removed"> 490                                     int total_args_passed,</span>
<span class="line-removed"> 491                                     int comp_args_on_stack,</span>
<span class="line-removed"> 492                                     const BasicType *sig_bt,</span>
<span class="line-removed"> 493                                     const VMRegPair *regs) {</span>
 494 
 495   // Note: r13 contains the senderSP on entry. We must preserve it since
 496   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 497   // code goes non-entrant while we get args ready.
 498 
 499   // In addition we use r13 to locate all the interpreter args because
 500   // we must align the stack to 16 bytes.
 501 
 502   // Adapters are frameless.
 503 
 504   // An i2c adapter is frameless because the *caller* frame, which is
 505   // interpreted, routinely repairs its own esp (from
 506   // interpreter_frame_last_sp), even if a callee has modified the
 507   // stack pointer.  It also recalculates and aligns sp.
 508 
 509   // A c2i adapter is frameless because the *callee* frame, which is
 510   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 511   // which is set up via the senderSP register).
 512 
 513   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 533       range_check(masm, rax, r11,
 534                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 535                   L_ok);
 536     if (StubRoutines::code1() != NULL)
 537       range_check(masm, rax, r11,
 538                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 539                   L_ok);
 540     if (StubRoutines::code2() != NULL)
 541       range_check(masm, rax, r11,
 542                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 543                   L_ok);
 544     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 545     __ block_comment(msg);
 546     __ stop(msg);
 547     __ bind(L_ok);
 548     __ block_comment(&quot;} verify_i2ce &quot;);
 549 #endif
 550   }
 551 
 552   // Cut-out for having no stack args.
<span class="line-modified"> 553   int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;</span>
 554   if (comp_args_on_stack) {
<span class="line-modified"> 555     __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-modified"> 556     __ andr(sp, rscratch1, -16);</span>

 557   }
 558 
 559   // Will jump to the compiled code just as if compiled code was doing it.
 560   // Pre-load the register-jump target early, to schedule it better.
 561   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 562 
 563 #if INCLUDE_JVMCI
 564   if (EnableJVMCI || UseAOT) {
 565     // check if this call should be routed towards a specific entry point
 566     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 567     Label no_alternative_target;
 568     __ cbz(rscratch2, no_alternative_target);
 569     __ mov(rscratch1, rscratch2);
 570     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 571     __ bind(no_alternative_target);
 572   }
 573 #endif // INCLUDE_JVMCI
 574 


 575   // Now generate the shuffle code.
 576   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 577     if (sig_bt[i] == T_VOID) {</span>
<span class="line-modified"> 578       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);</span>



 579       continue;
 580     }
 581 
 582     // Pick up 0, 1 or 2 words from SP+offset.

 583 
<span class="line-modified"> 584     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),</span>
<span class="line-removed"> 585             &quot;scrambled load targets?&quot;);</span>
<span class="line-removed"> 586     // Load in argument order going down.</span>
 587     int ld_off = (total_args_passed - i - 1)*Interpreter::stackElementSize;
 588     // Point to interpreter value (vs. tag)
 589     int next_off = ld_off - Interpreter::stackElementSize;
 590     //
 591     //
 592     //
 593     VMReg r_1 = regs[i].first();
 594     VMReg r_2 = regs[i].second();
 595     if (!r_1-&gt;is_valid()) {
 596       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 597       continue;
 598     }
 599     if (r_1-&gt;is_stack()) {
 600       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 601       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size;</span>
 602       if (!r_2-&gt;is_valid()) {
 603         // sign extend???
 604         __ ldrsw(rscratch2, Address(esp, ld_off));
 605         __ str(rscratch2, Address(sp, st_off));
 606       } else {
 607         //
 608         // We are using two optoregs. This can be either T_OBJECT,
 609         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 610         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 611         // So we must adjust where to pick up the data to match the
 612         // interpreter.
 613         //
 614         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 615         // are accessed as negative so LSW is at LOW address
 616 
 617         // ld_off is MSW so get LSW
<span class="line-modified"> 618         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 619                            next_off : ld_off;</span>
 620         __ ldr(rscratch2, Address(esp, offset));
 621         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 622         __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 623       }</span>
<span class="line-modified"> 624     } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 625       Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 626       if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 627         //</span>
<span class="line-modified"> 628         // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 629         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 630         // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 631         // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 632         // interpreter.</span>

















 633 
<span class="line-removed"> 634         const int offset = (sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?</span>
<span class="line-removed"> 635                            next_off : ld_off;</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637         // this can be a misaligned move</span>
<span class="line-removed"> 638         __ ldr(r, Address(esp, offset));</span>
<span class="line-removed"> 639       } else {</span>
<span class="line-removed"> 640         // sign extend and use a full word?</span>
<span class="line-removed"> 641         __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-removed"> 642       }</span>
<span class="line-removed"> 643     } else {</span>
<span class="line-removed"> 644       if (!r_2-&gt;is_valid()) {</span>
<span class="line-removed"> 645         __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-removed"> 646       } else {</span>
<span class="line-removed"> 647         __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-removed"> 648       }</span>
<span class="line-removed"> 649     }</span>
<span class="line-removed"> 650   }</span>
 651 
 652   // 6243940 We might end up in handle_wrong_method if
 653   // the callee is deoptimized as we race thru here. If that
 654   // happens we don&#39;t want to take a safepoint because the
 655   // caller frame will look interpreted and arguments are now
 656   // &quot;compiled&quot; so it is much better to make this transition
 657   // invisible to the stack walking code. Unfortunately if
 658   // we try and find the callee by normal means a safepoint
 659   // is possible. So we stash the desired callee in the thread
 660   // and the vm will find there should this case occur.
 661 
 662   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
<span class="line-removed"> 663 </span>
 664   __ br(rscratch1);
 665 }
 666 
<span class="line-modified"> 667 // ---------------------------------------------------------------</span>
<span class="line-removed"> 668 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-removed"> 669                                                             int total_args_passed,</span>
<span class="line-removed"> 670                                                             int comp_args_on_stack,</span>
<span class="line-removed"> 671                                                             const BasicType *sig_bt,</span>
<span class="line-removed"> 672                                                             const VMRegPair *regs,</span>
<span class="line-removed"> 673                                                             AdapterFingerPrint* fingerprint) {</span>
<span class="line-removed"> 674   address i2c_entry = __ pc();</span>
<span class="line-removed"> 675 </span>
<span class="line-removed"> 676   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);</span>
<span class="line-removed"> 677 </span>
<span class="line-removed"> 678   address c2i_unverified_entry = __ pc();</span>
<span class="line-removed"> 679   Label skip_fixup;</span>
 680 
 681   Label ok;
 682 
 683   Register holder = rscratch2;
 684   Register receiver = j_rarg0;
 685   Register tmp = r10;  // A call-clobbered register not used for arg passing
 686 
 687   // -------------------------------------------------------------------------
 688   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 689   // to the interpreter.  The args start out packed in the compiled layout.  They
 690   // need to be unpacked into the interpreter layout.  This will almost always
 691   // require some stack space.  We grow the current (compiled) stack, then repack
 692   // the args.  We  finally end in a jump to the generic interpreter entry point.
 693   // On exit from the interpreter, the interpreter will restore our SP (lest the
 694   // compiled code, which relys solely on SP and not FP, get sick).
 695 
 696   {
 697     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 698     __ load_klass(rscratch1, receiver);
 699     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 700     __ cmp(rscratch1, tmp);
 701     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 702     __ br(Assembler::EQ, ok);
 703     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 704 
 705     __ bind(ok);
 706     // Method might have been compiled since the call site was patched to
 707     // interpreted; if that is the case treat it as a miss so we can get
 708     // the call site corrected.
 709     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 710     __ cbz(rscratch1, skip_fixup);
 711     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 712     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 713   }


































 714 

 715   address c2i_entry = __ pc();
 716 
 717   // Class initialization barrier for static methods
 718   address c2i_no_clinit_check_entry = NULL;

 719   if (VM_Version::supports_fast_class_init_checks()) {
 720     Label L_skip_barrier;
<span class="line-modified"> 721 </span>
<span class="line-modified"> 722     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 723       __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 724       __ andsw(zr, rscratch1, JVM_ACC_STATIC);</span>
 725       __ br(Assembler::EQ, L_skip_barrier); // non-static
 726     }
 727 
<span class="line-modified"> 728     __ load_method_holder(rscratch2, rmethod);</span>
<span class="line-modified"> 729     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-modified"> 730     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>



 731 
 732     __ bind(L_skip_barrier);
 733     c2i_no_clinit_check_entry = __ pc();
 734   }
 735 
 736   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 737   bs-&gt;c2i_entry_barrier(masm);
 738 
 739   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 740 














 741   __ flush();
<span class="line-modified"> 742   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>







 743 }
 744 
 745 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 746                                          VMRegPair *regs,
 747                                          VMRegPair *regs2,
 748                                          int total_args_passed) {
 749   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
 750 
 751 // We return the amount of VMRegImpl stack slots we need to reserve for all
 752 // the arguments NOT counting out_preserve_stack_slots.
 753 
 754     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
 755       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
 756     };
 757     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
 758       c_farg0, c_farg1, c_farg2, c_farg3,
 759       c_farg4, c_farg5, c_farg6, c_farg7
 760     };
 761 
 762     uint int_args = 0;
</pre>
<hr />
<pre>
 765 
 766     for (int i = 0; i &lt; total_args_passed; i++) {
 767       switch (sig_bt[i]) {
 768       case T_BOOLEAN:
 769       case T_CHAR:
 770       case T_BYTE:
 771       case T_SHORT:
 772       case T_INT:
 773         if (int_args &lt; Argument::n_int_register_parameters_c) {
 774           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 775         } else {
 776           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 777           stk_args += 2;
 778         }
 779         break;
 780       case T_LONG:
 781         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 782         // fall through
 783       case T_OBJECT:
 784       case T_ARRAY:

 785       case T_ADDRESS:
 786       case T_METADATA:
 787         if (int_args &lt; Argument::n_int_register_parameters_c) {
 788           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 789         } else {
 790           regs[i].set2(VMRegImpl::stack2reg(stk_args));
 791           stk_args += 2;
 792         }
 793         break;
 794       case T_FLOAT:
 795         if (fp_args &lt; Argument::n_float_register_parameters_c) {
 796           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 797         } else {
 798           regs[i].set1(VMRegImpl::stack2reg(stk_args));
 799           stk_args += 2;
 800         }
 801         break;
 802       case T_DOUBLE:
 803         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 804         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1618       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1619     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1620       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1621     }
1622 #endif /* ASSERT */
1623     switch (in_sig_bt[i]) {
1624       case T_ARRAY:
1625         if (is_critical_native) {
1626           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1627           c_arg++;
1628 #ifdef ASSERT
1629           if (out_regs[c_arg].first()-&gt;is_Register()) {
1630             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1631           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1632             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1633           }
1634 #endif
1635           int_args++;
1636           break;
1637         }

1638       case T_OBJECT:
1639         assert(!is_critical_native, &quot;no oop arguments&quot;);
1640         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1641                     ((i == 0) &amp;&amp; (!is_static)),
1642                     &amp;receiver_offset);
1643         int_args++;
1644         break;
1645       case T_VOID:
1646         break;
1647 
1648       case T_FLOAT:
1649         float_move(masm, in_regs[i], out_regs[c_arg]);
1650         float_args++;
1651         break;
1652 
1653       case T_DOUBLE:
1654         assert( i + 1 &lt; total_in_args &amp;&amp;
1655                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1656                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1657         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
1799   }
1800 
1801   // Now set thread in native
1802   __ mov(rscratch1, _thread_in_native);
1803   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
1804   __ stlrw(rscratch1, rscratch2);
1805 
1806   {
1807     int return_type = 0;
1808     switch (ret_type) {
1809     case T_VOID: break;
1810       return_type = 0; break;
1811     case T_CHAR:
1812     case T_BYTE:
1813     case T_SHORT:
1814     case T_INT:
1815     case T_BOOLEAN:
1816     case T_LONG:
1817       return_type = 1; break;
1818     case T_ARRAY:

1819     case T_OBJECT:
1820       return_type = 1; break;
1821     case T_FLOAT:
1822       return_type = 2; break;
1823     case T_DOUBLE:
1824       return_type = 3; break;
1825     default:
1826       ShouldNotReachHere();
1827     }
1828     rt_call(masm, native_func,
1829             int_args + 2, // AArch64 passes up to 8 args in int registers
1830             float_args,   // and up to 8 float args
1831             return_type);
1832   }
1833 
1834   __ bind(native_return);
1835 
1836   intptr_t return_pc = (intptr_t) __ pc();
1837   oop_maps-&gt;add_gc_map(return_pc - start, map);
1838 
1839   // Unpack native results.
1840   switch (ret_type) {
1841   case T_BOOLEAN: __ c2bool(r0);                     break;
1842   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
1843   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
1844   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
1845   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
1846   case T_DOUBLE :
1847   case T_FLOAT  :
1848     // Result is in v0 we&#39;ll save as needed
1849     break;
1850   case T_ARRAY:                 // Really a handle

1851   case T_OBJECT:                // Really a handle
1852       break; // can&#39;t de-handlize until after safepoint check
1853   case T_VOID: break;
1854   case T_LONG: break;
1855   default       : ShouldNotReachHere();
1856   }
1857 
1858   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
1859   // This additional state is necessary because reading and testing the synchronization
1860   // state is not atomic w.r.t. GC, as this scenario demonstrates:
1861   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
1862   //     VM thread changes sync state to synchronizing and suspends threads for GC.
1863   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
1864   //     didn&#39;t see any synchronization is progress, and escapes.
1865   __ mov(rscratch1, _thread_in_native_trans);
1866 
1867   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
1868 
1869   // Force this write out before the read below
1870   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3056 #ifdef ASSERT
3057   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3058   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3059 #endif
3060   // Clear the exception oop so GC no longer processes it as a root.
3061   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3062 
3063   // r0: exception oop
3064   // r8:  exception handler
3065   // r4: exception pc
3066   // Jump to handler
3067 
3068   __ br(r8);
3069 
3070   // Make sure all code is generated
3071   masm-&gt;flush();
3072 
3073   // Set exception blob
3074   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3075 }









































































































3076 #endif // COMPILER2
</pre>
</td>
<td>
<hr />
<pre>
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
<span class="line-added">  29 #include &quot;classfile/symbolTable.hpp&quot;</span>
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;logging/log.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;nativeInst_aarch64.hpp&quot;
  39 #include &quot;oops/compiledICHolder.hpp&quot;
  40 #include &quot;oops/klass.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/vframeArray.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 #include &quot;vmreg_aarch64.inline.hpp&quot;
  46 #ifdef COMPILER1
  47 #include &quot;c1/c1_Runtime1.hpp&quot;
  48 #endif
  49 #ifdef COMPILER2
</pre>
<hr />
<pre>
 274     case T_SHORT:
 275     case T_INT:
 276       if (int_args &lt; Argument::n_int_register_parameters_j) {
 277         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 278       } else {
 279         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 280         stk_args += 2;
 281       }
 282       break;
 283     case T_VOID:
 284       // halves of T_LONG or T_DOUBLE
 285       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 286       regs[i].set_bad();
 287       break;
 288     case T_LONG:
 289       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 290       // fall through
 291     case T_OBJECT:
 292     case T_ARRAY:
 293     case T_ADDRESS:
<span class="line-added"> 294     case T_VALUETYPE:</span>
 295       if (int_args &lt; Argument::n_int_register_parameters_j) {
 296         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 297       } else {
 298         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 299         stk_args += 2;
 300       }
 301       break;
 302     case T_FLOAT:
 303       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 304         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 305       } else {
 306         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 307         stk_args += 2;
 308       }
 309       break;
 310     case T_DOUBLE:
 311       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 312       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 313         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 314       } else {
 315         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 316         stk_args += 2;
 317       }
 318       break;
 319     default:
 320       ShouldNotReachHere();
 321       break;
 322     }
 323   }
 324 
 325   return align_up(stk_args, 2);
 326 }
 327 
<span class="line-added"> 328 </span>
<span class="line-added"> 329 // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;</span>
<span class="line-added"> 330 const uint SharedRuntime::java_return_convention_max_int = 6;</span>
<span class="line-added"> 331 const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;</span>
<span class="line-added"> 332 </span>
<span class="line-added"> 333 int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335   // Create the mapping between argument positions and</span>
<span class="line-added"> 336   // registers.</span>
<span class="line-added"> 337   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision</span>
<span class="line-added"> 338 </span>
<span class="line-added"> 339   static const Register INT_ArgReg[java_return_convention_max_int] = {</span>
<span class="line-added"> 340      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2</span>
<span class="line-added"> 341   };</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {</span>
<span class="line-added"> 344     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7</span>
<span class="line-added"> 345   };</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347   uint int_args = 0;</span>
<span class="line-added"> 348   uint fp_args = 0;</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350   for (int i = 0; i &lt; total_args_passed; i++) {</span>
<span class="line-added"> 351     switch (sig_bt[i]) {</span>
<span class="line-added"> 352     case T_BOOLEAN:</span>
<span class="line-added"> 353     case T_CHAR:</span>
<span class="line-added"> 354     case T_BYTE:</span>
<span class="line-added"> 355     case T_SHORT:</span>
<span class="line-added"> 356     case T_INT:</span>
<span class="line-added"> 357       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 358         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 359         int_args ++;</span>
<span class="line-added"> 360       } else {</span>
<span class="line-added"> 361         // Should we have gurantee here?</span>
<span class="line-added"> 362         return -1;</span>
<span class="line-added"> 363       }</span>
<span class="line-added"> 364       break;</span>
<span class="line-added"> 365     case T_VOID:</span>
<span class="line-added"> 366       // halves of T_LONG or T_DOUBLE</span>
<span class="line-added"> 367       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);</span>
<span class="line-added"> 368       regs[i].set_bad();</span>
<span class="line-added"> 369       break;</span>
<span class="line-added"> 370     case T_LONG:</span>
<span class="line-added"> 371       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 372       // fall through</span>
<span class="line-added"> 373     case T_OBJECT:</span>
<span class="line-added"> 374     case T_ARRAY:</span>
<span class="line-added"> 375     case T_ADDRESS:</span>
<span class="line-added"> 376       // Should T_METADATA be added to java_calling_convention as well ?</span>
<span class="line-added"> 377     case T_METADATA:</span>
<span class="line-added"> 378     case T_VALUETYPE:</span>
<span class="line-added"> 379       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {</span>
<span class="line-added"> 380         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());</span>
<span class="line-added"> 381         int_args ++;</span>
<span class="line-added"> 382       } else {</span>
<span class="line-added"> 383         return -1;</span>
<span class="line-added"> 384       }</span>
<span class="line-added"> 385       break;</span>
<span class="line-added"> 386     case T_FLOAT:</span>
<span class="line-added"> 387       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {</span>
<span class="line-added"> 388         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 389         fp_args ++;</span>
<span class="line-added"> 390       } else {</span>
<span class="line-added"> 391         return -1;</span>
<span class="line-added"> 392       }</span>
<span class="line-added"> 393       break;</span>
<span class="line-added"> 394     case T_DOUBLE:</span>
<span class="line-added"> 395       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);</span>
<span class="line-added"> 396       if (fp_args &lt; Argument::n_float_register_parameters_j) {</span>
<span class="line-added"> 397         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());</span>
<span class="line-added"> 398         fp_args ++;</span>
<span class="line-added"> 399       } else {</span>
<span class="line-added"> 400         return -1;</span>
<span class="line-added"> 401       }</span>
<span class="line-added"> 402       break;</span>
<span class="line-added"> 403     default:</span>
<span class="line-added"> 404       ShouldNotReachHere();</span>
<span class="line-added"> 405       break;</span>
<span class="line-added"> 406     }</span>
<span class="line-added"> 407   }</span>
<span class="line-added"> 408 </span>
<span class="line-added"> 409   return int_args + fp_args;</span>
<span class="line-added"> 410 }</span>
<span class="line-added"> 411 </span>
 412 // Patch the callers callsite with entry to compiled code if it exists.
 413 static void patch_callers_callsite(MacroAssembler *masm) {
 414   Label L;
 415   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 416   __ cbz(rscratch1, L);
 417 
 418   __ enter();
 419   __ push_CPU_state();
 420 
 421   // VM needs caller&#39;s callsite
 422   // VM needs target method
 423   // This needs to be a long call since we will relocate this adapter to
 424   // the codeBuffer and it may not reach
 425 
 426 #ifndef PRODUCT
 427   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 428 #endif
 429 
 430   __ mov(c_rarg0, rmethod);
 431   __ mov(c_rarg1, lr);
 432   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
<span class="line-modified"> 442 // For each value type argument, sig includes the list of fields of</span>
<span class="line-modified"> 443 // the value type. This utility function computes the number of</span>
<span class="line-modified"> 444 // arguments for the call if value types are passed by reference (the</span>
<span class="line-modified"> 445 // calling convention the interpreter expects).</span>
<span class="line-modified"> 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {</span>
<span class="line-modified"> 447   int total_args_passed = 0;</span>
<span class="line-modified"> 448   if (InlineTypePassFieldsAsArgs) {</span>
<span class="line-modified"> 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {</span>
<span class="line-modified"> 450        BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-modified"> 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {</span>
<span class="line-modified"> 452          // Ignore reserved entry</span>
<span class="line-modified"> 453        } else if (bt == T_VALUETYPE) {</span>
<span class="line-modified"> 454          // In sig_extended, a value type argument starts with:</span>
<span class="line-modified"> 455          // T_VALUETYPE, followed by the types of the fields of the</span>
<span class="line-modified"> 456          // value type and T_VOID to mark the end of the value</span>
<span class="line-modified"> 457          // type. Value types are flattened so, for instance, in the</span>
<span class="line-modified"> 458          // case of a value type with an int field and a value type</span>
<span class="line-modified"> 459          // field that itself has 2 fields, an int and a long:</span>
<span class="line-modified"> 460          // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second</span>
<span class="line-added"> 461          // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID</span>
<span class="line-added"> 462          // (outer T_VALUETYPE)</span>
<span class="line-added"> 463          total_args_passed++;</span>
<span class="line-added"> 464          int vt = 1;</span>
<span class="line-added"> 465          do {</span>
<span class="line-added"> 466            i++;</span>
<span class="line-added"> 467            BasicType bt = sig_extended-&gt;at(i)._bt;</span>
<span class="line-added"> 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;</span>
<span class="line-added"> 469            if (bt == T_VALUETYPE) {</span>
<span class="line-added"> 470              vt++;</span>
<span class="line-added"> 471            } else if (bt == T_VOID &amp;&amp;</span>
<span class="line-added"> 472                       prev_bt != T_LONG &amp;&amp;</span>
<span class="line-added"> 473                       prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 474              vt--;</span>
<span class="line-added"> 475            }</span>
<span class="line-added"> 476          } while (vt != 0);</span>
<span class="line-added"> 477        } else {</span>
<span class="line-added"> 478          total_args_passed++;</span>
<span class="line-added"> 479        }</span>
<span class="line-added"> 480      }</span>
<span class="line-added"> 481   } else {</span>
<span class="line-added"> 482     total_args_passed = sig_extended-&gt;length();</span>
<span class="line-added"> 483   }</span>
 484 
<span class="line-modified"> 485   return total_args_passed;</span>
<span class="line-added"> 486 }</span>
 487 
<span class="line-modified"> 488 </span>


 489 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 490 
<span class="line-modified"> 491     assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);</span>












 492 
 493     // Say 4 args:
 494     // i   st_off
 495     // 0   32 T_LONG
 496     // 1   24 T_VOID
 497     // 2   16 T_OBJECT
 498     // 3    8 T_BOOL
 499     // -    0 return address
 500     //
 501     // However to make thing extra confusing. Because we can fit a long/double in
 502     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 503     // leaves one slot empty and only stores to a single slot. In this case the
 504     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 505 
<span class="line-modified"> 506     // int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-modified"> 507 </span>
<span class="line-added"> 508     VMReg r_1 = reg_pair.first();</span>
<span class="line-added"> 509     VMReg r_2 = reg_pair.second();</span>
<span class="line-added"> 510 </span>
 511     if (!r_1-&gt;is_valid()) {
 512       assert(!r_2-&gt;is_valid(), &quot;&quot;);
<span class="line-modified"> 513       return;</span>
 514     }
<span class="line-added"> 515 </span>
 516     if (r_1-&gt;is_stack()) {
 517       // memory to memory use rscratch1
<span class="line-modified"> 518       // words_pushed is always 0 so we don&#39;t use it.</span>
<span class="line-modified"> 519       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);</span>

 520       if (!r_2-&gt;is_valid()) {
 521         // sign extend??
 522         __ ldrw(rscratch1, Address(sp, ld_off));
<span class="line-modified"> 523         __ str(rscratch1, to);</span>
 524 
 525       } else {
<span class="line-modified"> 526         __ ldr(rscratch1, Address(sp, ld_off));</span>















 527         __ str(rscratch1, to);
 528       }
 529     } else if (r_1-&gt;is_Register()) {
 530       Register r = r_1-&gt;as_Register();
<span class="line-modified"> 531       __ str(r, to);</span>


















 532     } else {
 533       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 534       if (!r_2-&gt;is_valid()) {
 535         // only a float use just part of the slot
<span class="line-modified"> 536         __ strs(r_1-&gt;as_FloatRegister(), to);</span>
 537       } else {
<span class="line-modified"> 538         __ strd(r_1-&gt;as_FloatRegister(), to);</span>





 539       }
<span class="line-added"> 540    }</span>
<span class="line-added"> 541 }</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543 static void gen_c2i_adapter(MacroAssembler *masm,</span>
<span class="line-added"> 544                             const GrowableArray&lt;SigEntry&gt;* sig_extended,</span>
<span class="line-added"> 545                             const VMRegPair *regs,</span>
<span class="line-added"> 546                             Label&amp; skip_fixup,</span>
<span class="line-added"> 547                             address start,</span>
<span class="line-added"> 548                             OopMapSet* oop_maps,</span>
<span class="line-added"> 549                             int&amp; frame_complete,</span>
<span class="line-added"> 550                             int&amp; frame_size_in_words,</span>
<span class="line-added"> 551                             bool alloc_value_receiver) {</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553   // Before we get into the guts of the C2I adapter, see if we should be here</span>
<span class="line-added"> 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the</span>
<span class="line-added"> 555   // interpreter, which means the caller made a static call to get here</span>
<span class="line-added"> 556   // (vcalls always get a compiled target if there is one).  Check for a</span>
<span class="line-added"> 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.</span>
<span class="line-added"> 558   patch_callers_callsite(masm);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   __ bind(skip_fixup);</span>
<span class="line-added"> 561 </span>
<span class="line-added"> 562   bool has_value_argument = false;</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564   if (InlineTypePassFieldsAsArgs) {</span>
<span class="line-added"> 565       // Is there an inline type argument?</span>
<span class="line-added"> 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {</span>
<span class="line-added"> 567        has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);</span>
<span class="line-added"> 568      }</span>
<span class="line-added"> 569      if (has_value_argument) {</span>
<span class="line-added"> 570       // There is at least a value type argument: we&#39;re coming from</span>
<span class="line-added"> 571       // compiled code so we have no buffers to back the value</span>
<span class="line-added"> 572       // types. Allocate the buffers here with a runtime call.</span>
<span class="line-added"> 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);</span>
<span class="line-added"> 574 </span>
<span class="line-added"> 575       frame_complete = __ offset();</span>
<span class="line-added"> 576       address the_pc = __ pc();</span>
<span class="line-added"> 577 </span>
<span class="line-added"> 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);</span>
<span class="line-added"> 579 </span>
<span class="line-added"> 580       __ mov(c_rarg0, rthread);</span>
<span class="line-added"> 581       __ mov(c_rarg1, r1);</span>
<span class="line-added"> 582       __ mov(c_rarg2, (int64_t)alloc_value_receiver);</span>
<span class="line-added"> 583 </span>
<span class="line-added"> 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));</span>
<span class="line-added"> 585       __ blr(rscratch1);</span>
<span class="line-added"> 586 </span>
<span class="line-added"> 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);</span>
<span class="line-added"> 588       __ reset_last_Java_frame(false);</span>
<span class="line-added"> 589 </span>
<span class="line-added"> 590       RegisterSaver::restore_live_registers(masm);</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592       Label no_exception;</span>
<span class="line-added"> 593       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 594       __ cbz(r0, no_exception);</span>
<span class="line-added"> 595 </span>
<span class="line-added"> 596       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));</span>
<span class="line-added"> 597       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));</span>
<span class="line-added"> 598       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600       __ bind(no_exception);</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602       // We get an array of objects from the runtime call</span>
<span class="line-added"> 603       __ get_vm_result(r10, rthread);</span>
<span class="line-added"> 604       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?</span>
<span class="line-added"> 605     }</span>
<span class="line-added"> 606   }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608   int words_pushed = 0;</span>
<span class="line-added"> 609 </span>
<span class="line-added"> 610   // Since all args are passed on the stack, total_args_passed *</span>
<span class="line-added"> 611   // Interpreter::stackElementSize is the space we need.</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613   int total_args_passed = compute_total_args_passed_int(sig_extended);</span>
<span class="line-added"> 614   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;</span>
<span class="line-added"> 615 </span>
<span class="line-added"> 616   // stack is aligned, keep it that way</span>
<span class="line-added"> 617   extraspace = align_up(extraspace, 2 * wordSize);</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619   __ mov(r13, sp);</span>
<span class="line-added"> 620 </span>
<span class="line-added"> 621   if (extraspace)</span>
<span class="line-added"> 622     __ sub(sp, sp, extraspace);</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624   // Now write the args into the outgoing interpreter space</span>
<span class="line-added"> 625 </span>
<span class="line-added"> 626   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;</span>
<span class="line-added"> 627   bool has_oop_field = false;</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {</span>
<span class="line-added"> 630     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 631     // offset to start parameters</span>
<span class="line-added"> 632     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634     if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {</span>
<span class="line-added"> 635 </span>
<span class="line-added"> 636             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 637                continue; // Ignore reserved entry</span>
<span class="line-added"> 638             }</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640             if (bt == T_VOID) {</span>
<span class="line-added"> 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
<span class="line-added"> 642                next_arg_int ++;</span>
<span class="line-added"> 643                continue;</span>
<span class="line-added"> 644              }</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646              int next_off = st_off - Interpreter::stackElementSize;</span>
<span class="line-added"> 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;</span>
<span class="line-added"> 648 </span>
<span class="line-added"> 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));</span>
<span class="line-added"> 650              next_arg_int ++;</span>
<span class="line-added"> 651    } else {</span>
<span class="line-added"> 652        ignored++;</span>
<span class="line-added"> 653       // get the buffer from the just allocated pool of buffers</span>
<span class="line-added"> 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);</span>
<span class="line-added"> 655       __ load_heap_oop(rscratch1, Address(r10, index));</span>
<span class="line-added"> 656       next_vt_arg++;</span>
<span class="line-added"> 657       next_arg_int++;</span>
<span class="line-added"> 658       int vt = 1;</span>
<span class="line-added"> 659       // write fields we get from compiled code in registers/stack</span>
<span class="line-added"> 660       // slots to the buffer: we know we are done with that value type</span>
<span class="line-added"> 661       // argument when we hit the T_VOID that acts as an end of value</span>
<span class="line-added"> 662       // type delimiter for this value type. Value types are flattened</span>
<span class="line-added"> 663       // so we might encounter embedded value types. Each entry in</span>
<span class="line-added"> 664       // sig_extended contains a field offset in the buffer.</span>
<span class="line-added"> 665       do {</span>
<span class="line-added"> 666         next_arg_comp++;</span>
<span class="line-added"> 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;</span>
<span class="line-added"> 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;</span>
<span class="line-added"> 669         if (bt == T_VALUETYPE) {</span>
<span class="line-added"> 670           vt++;</span>
<span class="line-added"> 671           ignored++;</span>
<span class="line-added"> 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {</span>
<span class="line-added"> 673           vt--;</span>
<span class="line-added"> 674           ignored++;</span>
<span class="line-added"> 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {</span>
<span class="line-added"> 676           // Ignore reserved entry</span>
<span class="line-added"> 677         } else {</span>
<span class="line-added"> 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;</span>
<span class="line-added"> 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added"> 680 </span>
<span class="line-added"> 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added"> 682           has_oop_field = has_oop_field || is_oop;</span>
<span class="line-added"> 683 </span>
<span class="line-added"> 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));</span>
<span class="line-added"> 685         }</span>
<span class="line-added"> 686       } while (vt != 0);</span>
<span class="line-added"> 687       // pass the buffer to the interpreter</span>
<span class="line-added"> 688       __ str(rscratch1, Address(sp, st_off));</span>
<span class="line-added"> 689    }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691   }</span>
<span class="line-added"> 692 </span>
<span class="line-added"> 693 // If a value type was allocated and initialized, apply post barrier to all oop fields</span>
<span class="line-added"> 694   if (has_value_argument &amp;&amp; has_oop_field) {</span>
<span class="line-added"> 695     __ push(r13); // save senderSP</span>
<span class="line-added"> 696     __ push(r1); // save callee</span>
<span class="line-added"> 697     // Allocate argument register save area</span>
<span class="line-added"> 698     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 699       __ sub(sp, sp, frame::arg_reg_save_area_bytes);</span>
 700     }
<span class="line-added"> 701     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);</span>
<span class="line-added"> 702     // De-allocate argument register save area</span>
<span class="line-added"> 703     if (frame::arg_reg_save_area_bytes != 0) {</span>
<span class="line-added"> 704       __ add(sp, sp, frame::arg_reg_save_area_bytes);</span>
<span class="line-added"> 705     }</span>
<span class="line-added"> 706     __ pop(r1); // restore callee</span>
<span class="line-added"> 707     __ pop(r13); // restore sender SP</span>
 708   }
 709 
 710   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 711 
 712   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 713   __ br(rscratch1);
 714 }
 715 
<span class="line-added"> 716 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {</span>
 717 





 718 
 719   // Note: r13 contains the senderSP on entry. We must preserve it since
 720   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 721   // code goes non-entrant while we get args ready.
 722 
 723   // In addition we use r13 to locate all the interpreter args because
 724   // we must align the stack to 16 bytes.
 725 
 726   // Adapters are frameless.
 727 
 728   // An i2c adapter is frameless because the *caller* frame, which is
 729   // interpreted, routinely repairs its own esp (from
 730   // interpreter_frame_last_sp), even if a callee has modified the
 731   // stack pointer.  It also recalculates and aligns sp.
 732 
 733   // A c2i adapter is frameless because the *callee* frame, which is
 734   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 735   // which is set up via the senderSP register).
 736 
 737   // In other words, if *either* the caller or callee is interpreted, we can
</pre>
<hr />
<pre>
 757       range_check(masm, rax, r11,
 758                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 759                   L_ok);
 760     if (StubRoutines::code1() != NULL)
 761       range_check(masm, rax, r11,
 762                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 763                   L_ok);
 764     if (StubRoutines::code2() != NULL)
 765       range_check(masm, rax, r11,
 766                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 767                   L_ok);
 768     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 769     __ block_comment(msg);
 770     __ stop(msg);
 771     __ bind(L_ok);
 772     __ block_comment(&quot;} verify_i2ce &quot;);
 773 #endif
 774   }
 775 
 776   // Cut-out for having no stack args.
<span class="line-modified"> 777   int comp_words_on_stack = 0;</span>
 778   if (comp_args_on_stack) {
<span class="line-modified"> 779      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;</span>
<span class="line-modified"> 780      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);</span>
<span class="line-added"> 781      __ andr(sp, rscratch1, -16);</span>
 782   }
 783 
 784   // Will jump to the compiled code just as if compiled code was doing it.
 785   // Pre-load the register-jump target early, to schedule it better.
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
<span class="line-added"> 800   int total_args_passed = sig-&gt;length();</span>
<span class="line-added"> 801 </span>
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
<span class="line-modified"> 804     BasicType bt = sig-&gt;at(i)._bt;</span>
<span class="line-modified"> 805 </span>
<span class="line-added"> 806     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);</span>
<span class="line-added"> 807     if (bt == T_VOID) {</span>
<span class="line-added"> 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);</span>
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
<span class="line-added"> 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);</span>
 814 
<span class="line-modified"> 815     // Load in argument order going down.</span>


 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
 827     }
 828     if (r_1-&gt;is_stack()) {
 829       // Convert stack slot to an SP offset (+ wordSize to account for return address )
<span class="line-modified"> 830       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;</span>
 831       if (!r_2-&gt;is_valid()) {
 832         // sign extend???
 833         __ ldrsw(rscratch2, Address(esp, ld_off));
 834         __ str(rscratch2, Address(sp, st_off));
 835       } else {
 836         //
 837         // We are using two optoregs. This can be either T_OBJECT,
 838         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 839         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 840         // So we must adjust where to pick up the data to match the
 841         // interpreter.
 842         //
 843         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 844         // are accessed as negative so LSW is at LOW address
 845 
 846         // ld_off is MSW so get LSW
<span class="line-modified"> 847         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>

 848         __ ldr(rscratch2, Address(esp, offset));
 849         // st_off is LSW (i.e. reg.first())
<span class="line-modified"> 850          __ str(rscratch2, Address(sp, st_off));</span>
<span class="line-modified"> 851        }</span>
<span class="line-modified"> 852      } else if (r_1-&gt;is_Register()) {  // Register argument</span>
<span class="line-modified"> 853        Register r = r_1-&gt;as_Register();</span>
<span class="line-modified"> 854        if (r_2-&gt;is_valid()) {</span>
<span class="line-modified"> 855          //</span>
<span class="line-modified"> 856          // We are using two VMRegs. This can be either T_OBJECT,</span>
<span class="line-modified"> 857          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates</span>
<span class="line-modified"> 858          // two slots but only uses one for thr T_LONG or T_DOUBLE case</span>
<span class="line-modified"> 859          // So we must adjust where to pick up the data to match the</span>
<span class="line-modified"> 860          // interpreter.</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864          // this can be a misaligned move</span>
<span class="line-added"> 865          __ ldr(r, Address(esp, offset));</span>
<span class="line-added"> 866        } else {</span>
<span class="line-added"> 867          // sign extend and use a full word?</span>
<span class="line-added"> 868          __ ldrw(r, Address(esp, ld_off));</span>
<span class="line-added"> 869        }</span>
<span class="line-added"> 870      } else {</span>
<span class="line-added"> 871        if (!r_2-&gt;is_valid()) {</span>
<span class="line-added"> 872          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));</span>
<span class="line-added"> 873        } else {</span>
<span class="line-added"> 874          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));</span>
<span class="line-added"> 875        }</span>
<span class="line-added"> 876      }</span>
<span class="line-added"> 877    }</span>
 878 

















 879 
 880   // 6243940 We might end up in handle_wrong_method if
 881   // the callee is deoptimized as we race thru here. If that
 882   // happens we don&#39;t want to take a safepoint because the
 883   // caller frame will look interpreted and arguments are now
 884   // &quot;compiled&quot; so it is much better to make this transition
 885   // invisible to the stack walking code. Unfortunately if
 886   // we try and find the callee by normal means a safepoint
 887   // is possible. So we stash the desired callee in the thread
 888   // and the vm will find there should this case occur.
 889 
 890   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));

 891   __ br(rscratch1);
 892 }
 893 
<span class="line-modified"> 894 static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {</span>












 895 
 896   Label ok;
 897 
 898   Register holder = rscratch2;
 899   Register receiver = j_rarg0;
 900   Register tmp = r10;  // A call-clobbered register not used for arg passing
 901 
 902   // -------------------------------------------------------------------------
 903   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 904   // to the interpreter.  The args start out packed in the compiled layout.  They
 905   // need to be unpacked into the interpreter layout.  This will almost always
 906   // require some stack space.  We grow the current (compiled) stack, then repack
 907   // the args.  We  finally end in a jump to the generic interpreter entry point.
 908   // On exit from the interpreter, the interpreter will restore our SP (lest the
 909   // compiled code, which relys solely on SP and not FP, get sick).
 910 
 911   {
 912     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 913     __ load_klass(rscratch1, receiver);
 914     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 915     __ cmp(rscratch1, tmp);
 916     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 917     __ br(Assembler::EQ, ok);
 918     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 919 
 920     __ bind(ok);
 921     // Method might have been compiled since the call site was patched to
 922     // interpreted; if that is the case treat it as a miss so we can get
 923     // the call site corrected.
 924     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 925     __ cbz(rscratch1, skip_fixup);
 926     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 927     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 928   }
<span class="line-added"> 929 }</span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932 // ---------------------------------------------------------------</span>
<span class="line-added"> 933 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-added"> 934                                                             int comp_args_on_stack,</span>
<span class="line-added"> 935                                                             const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="line-added"> 936                                                             const VMRegPair* regs,</span>
<span class="line-added"> 937                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added"> 938                                                             const VMRegPair* regs_cc,</span>
<span class="line-added"> 939                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="line-added"> 940                                                             const VMRegPair* regs_cc_ro,</span>
<span class="line-added"> 941                                                             AdapterFingerPrint* fingerprint,</span>
<span class="line-added"> 942                                                             AdapterBlob*&amp; new_adapter) {</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944   address i2c_entry = __ pc();</span>
<span class="line-added"> 945   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);</span>
<span class="line-added"> 946 </span>
<span class="line-added"> 947   address c2i_unverified_entry = __ pc();</span>
<span class="line-added"> 948   Label skip_fixup;</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950   gen_inline_cache_check(masm, skip_fixup);</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952   OopMapSet* oop_maps = new OopMapSet();</span>
<span class="line-added"> 953   int frame_complete = CodeOffsets::frame_never_safe;</span>
<span class="line-added"> 954   int frame_size_in_words = 0;</span>
<span class="line-added"> 955 </span>
<span class="line-added"> 956   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)</span>
<span class="line-added"> 957   address c2i_value_ro_entry = __ pc();</span>
<span class="line-added"> 958   if (regs_cc != regs_cc_ro) {</span>
<span class="line-added"> 959     Label unused;</span>
<span class="line-added"> 960     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added"> 961     skip_fixup = unused;</span>
<span class="line-added"> 962   }</span>
 963 
<span class="line-added"> 964   // Scalarized c2i adapter</span>
 965   address c2i_entry = __ pc();
 966 
 967   // Class initialization barrier for static methods
 968   address c2i_no_clinit_check_entry = NULL;
<span class="line-added"> 969 </span>
 970   if (VM_Version::supports_fast_class_init_checks()) {
 971     Label L_skip_barrier;
<span class="line-modified"> 972     { // Bypass the barrier for non-static methods</span>
<span class="line-modified"> 973         Register flags  = rscratch1;</span>
<span class="line-modified"> 974       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));</span>
<span class="line-modified"> 975       __ tst(flags, JVM_ACC_STATIC);</span>
 976       __ br(Assembler::NE, L_skip_barrier); // non-static
 977     }
 978 
<span class="line-modified"> 979     Register klass = rscratch1;</span>
<span class="line-modified"> 980     __ load_method_holder(klass, rmethod);</span>
<span class="line-modified"> 981     // We pass rthread to this function on x86</span>
<span class="line-added"> 982     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
 985 
 986     __ bind(L_skip_barrier);
 987     c2i_no_clinit_check_entry = __ pc();
 988   }
 989 
 990   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 991   bs-&gt;c2i_entry_barrier(masm);
 992 
 993   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 994 
<span class="line-added"> 995   address c2i_unverified_value_entry = c2i_unverified_entry;</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997  // Non-scalarized c2i adapter</span>
<span class="line-added"> 998   address c2i_value_entry = c2i_entry;</span>
<span class="line-added"> 999   if (regs != regs_cc) {</span>
<span class="line-added">1000     Label value_entry_skip_fixup;</span>
<span class="line-added">1001     c2i_unverified_value_entry = __ pc();</span>
<span class="line-added">1002     gen_inline_cache_check(masm, value_entry_skip_fixup);</span>
<span class="line-added">1003 </span>
<span class="line-added">1004     c2i_value_entry = __ pc();</span>
<span class="line-added">1005     Label unused;</span>
<span class="line-added">1006     gen_c2i_adapter(masm, sig, regs, value_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);</span>
<span class="line-added">1007   }</span>
<span class="line-added">1008 </span>
1009   __ flush();
<span class="line-modified">1010 </span>
<span class="line-added">1011   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that</span>
<span class="line-added">1012   // the GC knows about the location of oop argument locations passed to the c2i adapter.</span>
<span class="line-added">1013 </span>
<span class="line-added">1014   bool caller_must_gc_arguments = (regs != regs_cc);</span>
<span class="line-added">1015   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);</span>
<span class="line-added">1016 </span>
<span class="line-added">1017   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
1018 }
1019 
1020 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1021                                          VMRegPair *regs,
1022                                          VMRegPair *regs2,
1023                                          int total_args_passed) {
1024   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1025 
1026 // We return the amount of VMRegImpl stack slots we need to reserve for all
1027 // the arguments NOT counting out_preserve_stack_slots.
1028 
1029     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1030       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1031     };
1032     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1033       c_farg0, c_farg1, c_farg2, c_farg3,
1034       c_farg4, c_farg5, c_farg6, c_farg7
1035     };
1036 
1037     uint int_args = 0;
</pre>
<hr />
<pre>
1040 
1041     for (int i = 0; i &lt; total_args_passed; i++) {
1042       switch (sig_bt[i]) {
1043       case T_BOOLEAN:
1044       case T_CHAR:
1045       case T_BYTE:
1046       case T_SHORT:
1047       case T_INT:
1048         if (int_args &lt; Argument::n_int_register_parameters_c) {
1049           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1050         } else {
1051           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1052           stk_args += 2;
1053         }
1054         break;
1055       case T_LONG:
1056         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1057         // fall through
1058       case T_OBJECT:
1059       case T_ARRAY:
<span class="line-added">1060       case T_VALUETYPE:</span>
1061       case T_ADDRESS:
1062       case T_METADATA:
1063         if (int_args &lt; Argument::n_int_register_parameters_c) {
1064           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1065         } else {
1066           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1067           stk_args += 2;
1068         }
1069         break;
1070       case T_FLOAT:
1071         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1072           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1073         } else {
1074           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1075           stk_args += 2;
1076         }
1077         break;
1078       case T_DOUBLE:
1079         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1080         if (fp_args &lt; Argument::n_float_register_parameters_c) {
</pre>
<hr />
<pre>
1894       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1895     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1896       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1897     }
1898 #endif /* ASSERT */
1899     switch (in_sig_bt[i]) {
1900       case T_ARRAY:
1901         if (is_critical_native) {
1902           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1903           c_arg++;
1904 #ifdef ASSERT
1905           if (out_regs[c_arg].first()-&gt;is_Register()) {
1906             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1907           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1908             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1909           }
1910 #endif
1911           int_args++;
1912           break;
1913         }
<span class="line-added">1914       case T_VALUETYPE:</span>
1915       case T_OBJECT:
1916         assert(!is_critical_native, &quot;no oop arguments&quot;);
1917         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1918                     ((i == 0) &amp;&amp; (!is_static)),
1919                     &amp;receiver_offset);
1920         int_args++;
1921         break;
1922       case T_VOID:
1923         break;
1924 
1925       case T_FLOAT:
1926         float_move(masm, in_regs[i], out_regs[c_arg]);
1927         float_args++;
1928         break;
1929 
1930       case T_DOUBLE:
1931         assert( i + 1 &lt; total_in_args &amp;&amp;
1932                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1933                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1934         double_move(masm, in_regs[i], out_regs[c_arg]);
</pre>
<hr />
<pre>
2076   }
2077 
2078   // Now set thread in native
2079   __ mov(rscratch1, _thread_in_native);
2080   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2081   __ stlrw(rscratch1, rscratch2);
2082 
2083   {
2084     int return_type = 0;
2085     switch (ret_type) {
2086     case T_VOID: break;
2087       return_type = 0; break;
2088     case T_CHAR:
2089     case T_BYTE:
2090     case T_SHORT:
2091     case T_INT:
2092     case T_BOOLEAN:
2093     case T_LONG:
2094       return_type = 1; break;
2095     case T_ARRAY:
<span class="line-added">2096     case T_VALUETYPE:</span>
2097     case T_OBJECT:
2098       return_type = 1; break;
2099     case T_FLOAT:
2100       return_type = 2; break;
2101     case T_DOUBLE:
2102       return_type = 3; break;
2103     default:
2104       ShouldNotReachHere();
2105     }
2106     rt_call(masm, native_func,
2107             int_args + 2, // AArch64 passes up to 8 args in int registers
2108             float_args,   // and up to 8 float args
2109             return_type);
2110   }
2111 
2112   __ bind(native_return);
2113 
2114   intptr_t return_pc = (intptr_t) __ pc();
2115   oop_maps-&gt;add_gc_map(return_pc - start, map);
2116 
2117   // Unpack native results.
2118   switch (ret_type) {
2119   case T_BOOLEAN: __ c2bool(r0);                     break;
2120   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2121   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2122   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2123   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2124   case T_DOUBLE :
2125   case T_FLOAT  :
2126     // Result is in v0 we&#39;ll save as needed
2127     break;
2128   case T_ARRAY:                 // Really a handle
<span class="line-added">2129   case T_VALUETYPE:</span>
2130   case T_OBJECT:                // Really a handle
2131       break; // can&#39;t de-handlize until after safepoint check
2132   case T_VOID: break;
2133   case T_LONG: break;
2134   default       : ShouldNotReachHere();
2135   }
2136 
2137   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2138   // This additional state is necessary because reading and testing the synchronization
2139   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2140   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2141   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2142   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2143   //     didn&#39;t see any synchronization is progress, and escapes.
2144   __ mov(rscratch1, _thread_in_native_trans);
2145 
2146   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2147 
2148   // Force this write out before the read below
2149   __ dmb(Assembler::ISH);
</pre>
<hr />
<pre>
3335 #ifdef ASSERT
3336   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3337   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3338 #endif
3339   // Clear the exception oop so GC no longer processes it as a root.
3340   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3341 
3342   // r0: exception oop
3343   // r8:  exception handler
3344   // r4: exception pc
3345   // Jump to handler
3346 
3347   __ br(r8);
3348 
3349   // Make sure all code is generated
3350   masm-&gt;flush();
3351 
3352   // Set exception blob
3353   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3354 }
<span class="line-added">3355 </span>
<span class="line-added">3356 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {</span>
<span class="line-added">3357   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);</span>
<span class="line-added">3358   CodeBuffer buffer(buf);</span>
<span class="line-added">3359   short buffer_locs[20];</span>
<span class="line-added">3360   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,</span>
<span class="line-added">3361                                          sizeof(buffer_locs)/sizeof(relocInfo));</span>
<span class="line-added">3362 </span>
<span class="line-added">3363   MacroAssembler _masm(&amp;buffer);</span>
<span class="line-added">3364   MacroAssembler* masm = &amp;_masm;</span>
<span class="line-added">3365 </span>
<span class="line-added">3366   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="line-added">3367   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="line-added">3368 </span>
<span class="line-added">3369   int pack_fields_off = __ offset();</span>
<span class="line-added">3370 </span>
<span class="line-added">3371   int j = 1;</span>
<span class="line-added">3372   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3373     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3374     if (bt == T_VALUETYPE) {</span>
<span class="line-added">3375       continue;</span>
<span class="line-added">3376     }</span>
<span class="line-added">3377     if (bt == T_VOID) {</span>
<span class="line-added">3378       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3379           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3380         j++;</span>
<span class="line-added">3381       }</span>
<span class="line-added">3382       continue;</span>
<span class="line-added">3383     }</span>
<span class="line-added">3384     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3385     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3386     VMReg r_1 = pair.first();</span>
<span class="line-added">3387     VMReg r_2 = pair.second();</span>
<span class="line-added">3388     Address to(r0, off);</span>
<span class="line-added">3389     if (bt == T_FLOAT) {</span>
<span class="line-added">3390       __ strs(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3391     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3392       __ strd(r_1-&gt;as_FloatRegister(), to);</span>
<span class="line-added">3393     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3394       Register val = r_1-&gt;as_Register();</span>
<span class="line-added">3395       assert_different_registers(r0, val);</span>
<span class="line-added">3396       // We don&#39;t need barriers because the destination is a newly allocated object.</span>
<span class="line-added">3397       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.</span>
<span class="line-added">3398       if (UseCompressedOops) {</span>
<span class="line-added">3399         __ encode_heap_oop(val);</span>
<span class="line-added">3400         __ str(val, to);</span>
<span class="line-added">3401       } else {</span>
<span class="line-added">3402         __ str(val, to);</span>
<span class="line-added">3403       }</span>
<span class="line-added">3404     } else {</span>
<span class="line-added">3405       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3406       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3407       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3408       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);</span>
<span class="line-added">3409     }</span>
<span class="line-added">3410     j++;</span>
<span class="line-added">3411   }</span>
<span class="line-added">3412   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3413 </span>
<span class="line-added">3414   __ ret(lr);</span>
<span class="line-added">3415 </span>
<span class="line-added">3416   int unpack_fields_off = __ offset();</span>
<span class="line-added">3417 </span>
<span class="line-added">3418   j = 1;</span>
<span class="line-added">3419   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3420     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3421     if (bt == T_VALUETYPE) {</span>
<span class="line-added">3422       continue;</span>
<span class="line-added">3423     }</span>
<span class="line-added">3424     if (bt == T_VOID) {</span>
<span class="line-added">3425       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3426           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3427         j++;</span>
<span class="line-added">3428       }</span>
<span class="line-added">3429       continue;</span>
<span class="line-added">3430     }</span>
<span class="line-added">3431     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3432     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3433     VMReg r_1 = pair.first();</span>
<span class="line-added">3434     VMReg r_2 = pair.second();</span>
<span class="line-added">3435     Address from(r0, off);</span>
<span class="line-added">3436     if (bt == T_FLOAT) {</span>
<span class="line-added">3437       __ ldrs(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3438     } else if (bt == T_DOUBLE) {</span>
<span class="line-added">3439       __ ldrd(r_1-&gt;as_FloatRegister(), from);</span>
<span class="line-added">3440     } else if (bt == T_OBJECT || bt == T_ARRAY) {</span>
<span class="line-added">3441        assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3442        __ load_heap_oop(r_1-&gt;as_Register(), from);</span>
<span class="line-added">3443     } else {</span>
<span class="line-added">3444       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);</span>
<span class="line-added">3445       assert_different_registers(r0, r_1-&gt;as_Register());</span>
<span class="line-added">3446 </span>
<span class="line-added">3447       size_t size_in_bytes = type2aelembytes(bt);</span>
<span class="line-added">3448       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);</span>
<span class="line-added">3449     }</span>
<span class="line-added">3450     j++;</span>
<span class="line-added">3451   }</span>
<span class="line-added">3452   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3453 </span>
<span class="line-added">3454   __ ret(lr);</span>
<span class="line-added">3455 </span>
<span class="line-added">3456   __ flush();</span>
<span class="line-added">3457 </span>
<span class="line-added">3458   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);</span>
<span class="line-added">3459 }</span>
3460 #endif // COMPILER2
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
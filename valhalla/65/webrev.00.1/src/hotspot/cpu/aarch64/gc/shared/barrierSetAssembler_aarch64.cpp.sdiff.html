<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 61     } else {
 62       assert(in_native, &quot;why else?&quot;);
 63       __ ldr(dst, src);
 64     }
 65     break;
 66   }
 67   case T_BOOLEAN: __ load_unsigned_byte (dst, src); break;
 68   case T_BYTE:    __ load_signed_byte   (dst, src); break;
 69   case T_CHAR:    __ load_unsigned_short(dst, src); break;
 70   case T_SHORT:   __ load_signed_short  (dst, src); break;
 71   case T_INT:     __ ldrw               (dst, src); break;
 72   case T_LONG:    __ ldr                (dst, src); break;
 73   case T_ADDRESS: __ ldr                (dst, src); break;
 74   case T_FLOAT:   __ ldrs               (v0, src);  break;
 75   case T_DOUBLE:  __ ldrd               (v0, src);  break;
 76   default: Unimplemented();
 77   }
 78 }
 79 
 80 void BarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
<span class="line-modified"> 81                                    Address dst, Register val, Register tmp1, Register tmp2) {</span>
 82   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 83   bool in_native = (decorators &amp; IN_NATIVE) != 0;


 84   switch (type) {
 85   case T_OBJECT:
 86   case T_ARRAY: {
<span class="line-modified"> 87     val = val == noreg ? zr : val;</span>
<span class="line-modified"> 88     if (in_heap) {</span>
<span class="line-modified"> 89       if (UseCompressedOops) {</span>
<span class="line-modified"> 90         assert(!dst.uses(val), &quot;not enough registers&quot;);</span>
<span class="line-modified"> 91         if (val != zr) {</span>
<span class="line-modified"> 92           __ encode_heap_oop(val);</span>

 93         }
<span class="line-modified"> 94         __ strw(val, dst);</span>
<span class="line-modified"> 95       } else {</span>









 96         __ str(val, dst);
 97       }
 98     } else {
 99       assert(in_native, &quot;why else?&quot;);

100       __ str(val, dst);
101     }
102     break;
103   }
104   case T_BOOLEAN:
105     __ andw(val, val, 0x1);  // boolean is true if LSB is 1
106     __ strb(val, dst);
107     break;
108   case T_BYTE:    __ strb(val, dst); break;
109   case T_CHAR:    __ strh(val, dst); break;
110   case T_SHORT:   __ strh(val, dst); break;
111   case T_INT:     __ strw(val, dst); break;
112   case T_LONG:    __ str (val, dst); break;
113   case T_ADDRESS: __ str (val, dst); break;
114   case T_FLOAT:   __ strs(v0,  dst); break;
115   case T_DOUBLE:  __ strd(v0,  dst); break;
116   default: Unimplemented();
117   }
118 }
119 
</pre>
</td>
<td>
<hr />
<pre>
 61     } else {
 62       assert(in_native, &quot;why else?&quot;);
 63       __ ldr(dst, src);
 64     }
 65     break;
 66   }
 67   case T_BOOLEAN: __ load_unsigned_byte (dst, src); break;
 68   case T_BYTE:    __ load_signed_byte   (dst, src); break;
 69   case T_CHAR:    __ load_unsigned_short(dst, src); break;
 70   case T_SHORT:   __ load_signed_short  (dst, src); break;
 71   case T_INT:     __ ldrw               (dst, src); break;
 72   case T_LONG:    __ ldr                (dst, src); break;
 73   case T_ADDRESS: __ ldr                (dst, src); break;
 74   case T_FLOAT:   __ ldrs               (v0, src);  break;
 75   case T_DOUBLE:  __ ldrd               (v0, src);  break;
 76   default: Unimplemented();
 77   }
 78 }
 79 
 80 void BarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
<span class="line-modified"> 81                                    Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {</span>
 82   bool in_heap = (decorators &amp; IN_HEAP) != 0;
 83   bool in_native = (decorators &amp; IN_NATIVE) != 0;
<span class="line-added"> 84   bool is_not_null = (decorators &amp; IS_NOT_NULL) != 0;</span>
<span class="line-added"> 85 </span>
 86   switch (type) {
 87   case T_OBJECT:
 88   case T_ARRAY: {
<span class="line-modified"> 89    if (in_heap) {</span>
<span class="line-modified"> 90       if (val == noreg) {</span>
<span class="line-modified"> 91         assert(!is_not_null, &quot;inconsistent access&quot;);</span>
<span class="line-modified"> 92         if (UseCompressedOops) {</span>
<span class="line-modified"> 93           __ strw(zr, dst);</span>
<span class="line-modified"> 94         } else {</span>
<span class="line-added"> 95           __ str(zr, dst);</span>
 96         }
<span class="line-modified"> 97       } else {</span>
<span class="line-modified"> 98         if (UseCompressedOops) {</span>
<span class="line-added"> 99           assert(!dst.uses(val), &quot;not enough registers&quot;);</span>
<span class="line-added">100           if (is_not_null) {</span>
<span class="line-added">101             __ encode_heap_oop_not_null(val);</span>
<span class="line-added">102           } else {</span>
<span class="line-added">103             __ encode_heap_oop(val);</span>
<span class="line-added">104           }</span>
<span class="line-added">105           __ strw(val, dst);</span>
<span class="line-added">106         } else {</span>
<span class="line-added">107           __ str(val, dst);</span>
108         }
109       }
110     } else {
111       assert(in_native, &quot;why else?&quot;);
<span class="line-added">112       assert(val != noreg, &quot;not supported&quot;);</span>
113       __ str(val, dst);
114     }
115     break;
116   }
117   case T_BOOLEAN:
118     __ andw(val, val, 0x1);  // boolean is true if LSB is 1
119     __ strb(val, dst);
120     break;
121   case T_BYTE:    __ strb(val, dst); break;
122   case T_CHAR:    __ strh(val, dst); break;
123   case T_SHORT:   __ strh(val, dst); break;
124   case T_INT:     __ strw(val, dst); break;
125   case T_LONG:    __ str (val, dst); break;
126   case T_ADDRESS: __ str (val, dst); break;
127   case T_FLOAT:   __ strs(v0,  dst); break;
128   case T_DOUBLE:  __ strd(v0,  dst); break;
129   default: Unimplemented();
130   }
131 }
132 
</pre>
</td>
</tr>
</table>
<center><a href="../../c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="barrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
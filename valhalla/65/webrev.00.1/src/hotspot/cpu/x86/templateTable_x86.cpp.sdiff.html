<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aarch64/stubGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/bytecodeAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;

  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  45 
  46 // Global Register Names
  47 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  48 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  49 
  50 // Platform-dependent initialization
  51 void TemplateTable::pd_initialize() {
  52   // No x86 specific initialization
  53 }
  54 
  55 // Address Computation: local variables
</pre>
<hr />
<pre>
 137   case TemplateTable::less_equal   : return Assembler::greater;
 138   case TemplateTable::greater      : return Assembler::lessEqual;
 139   case TemplateTable::greater_equal: return Assembler::less;
 140   }
 141   ShouldNotReachHere();
 142   return Assembler::zero;
 143 }
 144 
 145 
 146 
 147 // Miscelaneous helper routines
 148 // Store an oop (or NULL) at the address described by obj.
 149 // If val == noreg this means store a NULL
 150 
 151 
 152 static void do_oop_store(InterpreterMacroAssembler* _masm,
 153                          Address dst,
 154                          Register val,
 155                          DecoratorSet decorators = 0) {
 156   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
<span class="line-modified"> 157   __ store_heap_oop(dst, val, rdx, rbx, decorators);</span>
 158 }
 159 
 160 static void do_oop_load(InterpreterMacroAssembler* _masm,
 161                         Address src,
 162                         Register dst,
 163                         DecoratorSet decorators = 0) {
 164   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 165 }
 166 
 167 Address TemplateTable::at_bcp(int offset) {
 168   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 169   return Address(rbcp, offset);
 170 }
 171 
 172 
 173 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 174                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 175                                    int byte_no) {
 176   if (!RewriteBytecodes)  return;
 177   Label L_patch_done;
 178 
 179   switch (bc) {

 180   case Bytecodes::_fast_aputfield:
 181   case Bytecodes::_fast_bputfield:
 182   case Bytecodes::_fast_zputfield:
 183   case Bytecodes::_fast_cputfield:
 184   case Bytecodes::_fast_dputfield:
 185   case Bytecodes::_fast_fputfield:
 186   case Bytecodes::_fast_iputfield:
 187   case Bytecodes::_fast_lputfield:
 188   case Bytecodes::_fast_sputfield:
 189     {
 190       // We skip bytecode quickening for putfield instructions when
 191       // the put_code written to the constant pool cache is zero.
 192       // This is required so that every execution of this instruction
 193       // calls out to InterpreterRuntime::resolve_get_put to do
 194       // additional, required work.
 195       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 196       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 197       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 198       __ movl(bc_reg, bc);
 199       __ cmpl(temp_reg, (int) 0);
</pre>
<hr />
<pre>
 352   __ sarl(rax, 16);
 353 }
 354 
 355 void TemplateTable::ldc(bool wide) {
 356   transition(vtos, vtos);
 357   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 358   Label call_ldc, notFloat, notClass, notInt, Done;
 359 
 360   if (wide) {
 361     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 362   } else {
 363     __ load_unsigned_byte(rbx, at_bcp(1));
 364   }
 365 
 366   __ get_cpool_and_tags(rcx, rax);
 367   const int base_offset = ConstantPool::header_size() * wordSize;
 368   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 369 
 370   // get type
 371   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));

 372 
 373   // unresolved class - get the resolved class
 374   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 375   __ jccb(Assembler::equal, call_ldc);
 376 
 377   // unresolved class in error state - call into runtime to throw the error
 378   // from the first resolution attempt
 379   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 380   __ jccb(Assembler::equal, call_ldc);
 381 
 382   // resolved class - need to call vm to get java mirror of the class
 383   __ cmpl(rdx, JVM_CONSTANT_Class);
 384   __ jcc(Assembler::notEqual, notClass);
 385 
 386   __ bind(call_ldc);
 387 
 388   __ movl(rarg, wide);
 389   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 390 
 391   __ push(atos);
</pre>
<hr />
<pre>
 802                     Address(rdx, rax,
 803                             Address::times_4,
 804                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 805                     noreg, noreg);
 806 }
 807 
 808 void TemplateTable::daload() {
 809   transition(itos, dtos);
 810   // rax: index
 811   // rdx: array
 812   index_check(rdx, rax); // kills rbx
 813   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,
 814                     Address(rdx, rax,
 815                             Address::times_8,
 816                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
 817                     noreg, noreg);
 818 }
 819 
 820 void TemplateTable::aaload() {
 821   transition(itos, atos);
<span class="line-modified"> 822   // rax: index</span>
<span class="line-modified"> 823   // rdx: array</span>
<span class="line-modified"> 824   index_check(rdx, rax); // kills rbx</span>
<span class="line-modified"> 825   do_oop_load(_masm,</span>
<span class="line-modified"> 826               Address(rdx, rax,</span>
<span class="line-modified"> 827                       UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-modified"> 828                       arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-modified"> 829               rax,</span>
<span class="line-modified"> 830               IS_ARRAY);</span>


















 831 }
 832 
 833 void TemplateTable::baload() {
 834   transition(itos, itos);
 835   // rax: index
 836   // rdx: array
 837   index_check(rdx, rax); // kills rbx
 838   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,
 839                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),
 840                     noreg, noreg);
 841 }
 842 
 843 void TemplateTable::caload() {
 844   transition(itos, itos);
 845   // rax: index
 846   // rdx: array
 847   index_check(rdx, rax); // kills rbx
 848   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 849                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 850                     noreg, noreg);
</pre>
<hr />
<pre>
1096   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,
1097                      Address(rdx, rbx, Address::times_4,
1098                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1099                      noreg /* ftos */, noreg, noreg);
1100 }
1101 
1102 void TemplateTable::dastore() {
1103   transition(dtos, vtos);
1104   __ pop_i(rbx);
1105   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1106   // rbx:  index
1107   // rdx:  array
1108   index_check(rdx, rbx); // prefer index in rbx
1109   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,
1110                      Address(rdx, rbx, Address::times_8,
1111                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
1112                      noreg /* dtos */, noreg, noreg);
1113 }
1114 
1115 void TemplateTable::aastore() {
<span class="line-modified">1116   Label is_null, ok_is_subtype, done;</span>
1117   transition(vtos, vtos);
1118   // stack: ..., array, index, value
1119   __ movptr(rax, at_tos());    // value
1120   __ movl(rcx, at_tos_p1()); // index
1121   __ movptr(rdx, at_tos_p2()); // array
1122 
1123   Address element_address(rdx, rcx,
1124                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1125                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1126 
1127   index_check_without_pop(rdx, rcx);     // kills rbx




1128   __ testptr(rax, rax);
1129   __ jcc(Assembler::zero, is_null);
1130 







1131   // Move subklass into rbx
1132   __ load_klass(rbx, rax);
<span class="line-modified">1133   // Move superklass into rax</span>
<span class="line-modified">1134   __ load_klass(rax, rdx);</span>
<span class="line-removed">1135   __ movptr(rax, Address(rax,</span>
1136                          ObjArrayKlass::element_klass_offset()));
1137 
1138   // Generate subtype check.  Blows rcx, rdi
1139   // Superklass in rax.  Subklass in rbx.
<span class="line-modified">1140   __ gen_subtype_check(rbx, ok_is_subtype);</span>

1141 
1142   // Come here on failure
1143   // object is at TOS
1144   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1145 
1146   // Come here on success
1147   __ bind(ok_is_subtype);
1148 
1149   // Get the value we will store
1150   __ movptr(rax, at_tos());
1151   __ movl(rcx, at_tos_p1()); // index
1152   // Now store using the appropriate barrier
1153   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1154   __ jmp(done);
1155 
1156   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1157   __ bind(is_null);
<span class="line-modified">1158   __ profile_null_seen(rbx);</span>

1159 









1160   // Store a NULL
1161   do_oop_store(_masm, element_address, noreg, IS_ARRAY);







1162 



























1163   // Pop stack arguments
1164   __ bind(done);
1165   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1166 }
1167 
1168 void TemplateTable::bastore() {
1169   transition(itos, vtos);
1170   __ pop_i(rbx);
1171   // rax: value
1172   // rbx: index
1173   // rdx: array
1174   index_check(rdx, rbx); // prefer index in rbx
1175   // Need to check whether array is boolean or byte
1176   // since both types share the bastore bytecode.
1177   __ load_klass(rcx, rdx);
1178   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1179   int diffbit = Klass::layout_helper_boolean_diffbit();
1180   __ testl(rcx, diffbit);
1181   Label L_skip;
1182   __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
2388   __ jcc(j_not(cc), not_taken);
2389   branch(false, false);
2390   __ bind(not_taken);
2391   __ profile_not_taken_branch(rax);
2392 }
2393 
2394 void TemplateTable::if_nullcmp(Condition cc) {
2395   transition(atos, vtos);
2396   // assume branch is more often taken than not (loops use backward branches)
2397   Label not_taken;
2398   __ testptr(rax, rax);
2399   __ jcc(j_not(cc), not_taken);
2400   branch(false, false);
2401   __ bind(not_taken);
2402   __ profile_not_taken_branch(rax);
2403 }
2404 
2405 void TemplateTable::if_acmp(Condition cc) {
2406   transition(atos, vtos);
2407   // assume branch is more often taken than not (loops use backward branches)
<span class="line-modified">2408   Label not_taken;</span>
2409   __ pop_ptr(rdx);




































2410   __ cmpoop(rdx, rax);
2411   __ jcc(j_not(cc), not_taken);

2412   branch(false, false);
2413   __ bind(not_taken);
2414   __ profile_not_taken_branch(rax);
2415 }
2416 









2417 void TemplateTable::ret() {
2418   transition(vtos, vtos);
2419   locals_index(rbx);
2420   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2421   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2422   __ profile_ret(rbx, rcx);
2423   __ get_method(rax);
2424   __ movptr(rbcp, Address(rax, Method::const_offset()));
2425   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2426                       ConstMethod::codes_offset()));
2427   __ dispatch_next(vtos, 0, true);
2428 }
2429 
2430 void TemplateTable::wide_ret() {
2431   transition(vtos, vtos);
2432   locals_index_wide(rbx);
2433   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2434   __ profile_ret(rbx, rcx);
2435   __ get_method(rax);
2436   __ movptr(rbcp, Address(rax, Method::const_offset()));
</pre>
<hr />
<pre>
2662     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2663 #else
2664     const Register thread = rdi;
2665     __ get_thread(thread);
2666     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2667 #endif
2668     __ jcc(Assembler::zero, no_safepoint);
2669     __ push(state);
2670     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2671                                     InterpreterRuntime::at_safepoint));
2672     __ pop(state);
2673     __ bind(no_safepoint);
2674   }
2675 
2676   // Narrow result if state is itos but result type is smaller.
2677   // Need to narrow in the return bytecode rather than in generate_return_entry
2678   // since compiled code callers expect the result to already be narrowed.
2679   if (state == itos) {
2680     __ narrow(rax);
2681   }
<span class="line-modified">2682   __ remove_activation(state, rbcp);</span>

2683 
2684   __ jmp(rbcp);
2685 }
2686 
2687 // ----------------------------------------------------------------------------
2688 // Volatile variables demand their effects be made known to all CPU&#39;s
2689 // in order.  Store buffers on most chips allow reads &amp; writes to
2690 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2691 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2692 // the interpreter does not reorder volatile references, the hardware
2693 // also must not reorder them).
2694 //
2695 // According to the new Java Memory Model (JMM):
2696 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2697 //     writes act as aquire &amp; release, so:
2698 // (2) A read cannot let unrelated NON-volatile memory refs that
2699 //     happen after the read float up to before the read.  It&#39;s OK for
2700 //     non-volatile memory refs that happen before the volatile read to
2701 //     float down below it.
2702 // (3) Similar a volatile write cannot let unrelated NON-volatile
</pre>
<hr />
<pre>
2860     __ get_cache_and_index_at_bcp(cache, index, 1);
2861     __ bind(L1);
2862   }
2863 }
2864 
2865 void TemplateTable::pop_and_check_object(Register r) {
2866   __ pop_ptr(r);
2867   __ null_check(r);  // for field access must check obj.
2868   __ verify_oop(r);
2869 }
2870 
2871 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2872   transition(vtos, vtos);
2873 
2874   const Register cache = rcx;
2875   const Register index = rdx;
2876   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
2877   const Register off   = rbx;
2878   const Register flags = rax;
2879   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them

2880 
2881   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2882   jvmti_post_field_access(cache, index, is_static, false);
2883   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2884 
<span class="line-removed">2885   if (!is_static) pop_and_check_object(obj);</span>
<span class="line-removed">2886 </span>
2887   const Address field(obj, off, Address::times_1, 0*wordSize);
2888 
<span class="line-modified">2889   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;</span>








2890 
2891   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
2892   // Make sure we don&#39;t need to mask edx after the above shift
2893   assert(btos == 0, &quot;change code, btos != 0&quot;);
2894 
2895   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
2896 
2897   __ jcc(Assembler::notZero, notByte);
2898   // btos

2899   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
2900   __ push(btos);
2901   // Rewrite bytecode to be faster
2902   if (!is_static &amp;&amp; rc == may_rewrite) {
2903     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
2904   }
2905   __ jmp(Done);
2906 
2907   __ bind(notByte);

2908   __ cmpl(flags, ztos);
2909   __ jcc(Assembler::notEqual, notBool);
<span class="line-modified">2910 </span>
2911   // ztos (same code as btos)
2912   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
2913   __ push(ztos);
2914   // Rewrite bytecode to be faster
2915   if (!is_static &amp;&amp; rc == may_rewrite) {
2916     // use btos rewriting, no truncating to t/f bit is needed for getfield.
2917     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
2918   }
2919   __ jmp(Done);
2920 
2921   __ bind(notBool);
2922   __ cmpl(flags, atos);
2923   __ jcc(Assembler::notEqual, notObj);
2924   // atos
<span class="line-modified">2925   do_oop_load(_masm, field, rax);</span>
<span class="line-modified">2926   __ push(atos);</span>
<span class="line-modified">2927   if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-modified">2928     patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>













































































2929   }
<span class="line-removed">2930   __ jmp(Done);</span>
2931 
2932   __ bind(notObj);



2933   __ cmpl(flags, itos);
2934   __ jcc(Assembler::notEqual, notInt);
2935   // itos
2936   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
2937   __ push(itos);
2938   // Rewrite bytecode to be faster
2939   if (!is_static &amp;&amp; rc == may_rewrite) {
2940     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
2941   }
2942   __ jmp(Done);
2943 
2944   __ bind(notInt);
2945   __ cmpl(flags, ctos);
2946   __ jcc(Assembler::notEqual, notChar);
2947   // ctos
2948   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
2949   __ push(ctos);
2950   // Rewrite bytecode to be faster
2951   if (!is_static &amp;&amp; rc == may_rewrite) {
2952     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
</pre>
<hr />
<pre>
3012 #endif
3013 
3014   __ bind(Done);
3015   // [jk] not needed currently
3016   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3017   //                                              Assembler::LoadStore));
3018 }
3019 
3020 void TemplateTable::getfield(int byte_no) {
3021   getfield_or_static(byte_no, false);
3022 }
3023 
3024 void TemplateTable::nofast_getfield(int byte_no) {
3025   getfield_or_static(byte_no, false, may_not_rewrite);
3026 }
3027 
3028 void TemplateTable::getstatic(int byte_no) {
3029   getfield_or_static(byte_no, true);
3030 }
3031 















3032 
3033 // The registers cache and index expected to be set before call.
3034 // The function may destroy various registers, just not the cache and index registers.
3035 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3036 
3037   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3038   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3039   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3040   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3041 
3042   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3043 
3044   if (JvmtiExport::can_post_field_modification()) {
3045     // Check to see if a field modification watch has been set before
3046     // we take the time to call into the VM.
3047     Label L1;
3048     assert_different_registers(cache, index, rax);
3049     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3050     __ testl(rax, rax);
3051     __ jcc(Assembler::zero, L1);
</pre>
<hr />
<pre>
3107     // c_rarg1: object pointer set up above (NULL if static)
3108     // c_rarg2: cache entry pointer
3109     // c_rarg3: jvalue object on the stack
3110     __ call_VM(noreg,
3111                CAST_FROM_FN_PTR(address,
3112                                 InterpreterRuntime::post_field_modification),
3113                RBX, robj, RCX);
3114     __ get_cache_and_index_at_bcp(cache, index, 1);
3115     __ bind(L1);
3116   }
3117 }
3118 
3119 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3120   transition(vtos, vtos);
3121 
3122   const Register cache = rcx;
3123   const Register index = rdx;
3124   const Register obj   = rcx;
3125   const Register off   = rbx;
3126   const Register flags = rax;

3127 
3128   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3129   jvmti_post_field_mod(cache, index, is_static);
3130   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3131 
3132   // [jk] not needed currently
3133   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3134   //                                              Assembler::StoreStore));
3135 
3136   Label notVolatile, Done;
3137   __ movl(rdx, flags);
3138   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3139   __ andl(rdx, 0x1);
3140 
3141   // Check for volatile store
3142   __ testl(rdx, rdx);

3143   __ jcc(Assembler::zero, notVolatile);
3144 
<span class="line-modified">3145   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
3146   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3147                                                Assembler::StoreStore));
3148   __ jmp(Done);
3149   __ bind(notVolatile);
3150 
<span class="line-modified">3151   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);</span>
3152 
3153   __ bind(Done);
3154 }
3155 
3156 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
<span class="line-modified">3157                                               Register obj, Register off, Register flags) {</span>
3158 
3159   // field addresses
3160   const Address field(obj, off, Address::times_1, 0*wordSize);
3161   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3162 
3163   Label notByte, notBool, notInt, notShort, notChar,
<span class="line-modified">3164         notLong, notFloat, notObj;</span>
3165   Label Done;
3166 
3167   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3168 
3169   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3170 
3171   assert(btos == 0, &quot;change code, btos != 0&quot;);
3172   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3173   __ jcc(Assembler::notZero, notByte);
3174 
3175   // btos
3176   {
3177     __ pop(btos);
3178     if (!is_static) pop_and_check_object(obj);
3179     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3180     if (!is_static &amp;&amp; rc == may_rewrite) {
3181       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3182     }
3183     __ jmp(Done);
3184   }
</pre>
<hr />
<pre>
3187   __ cmpl(flags, ztos);
3188   __ jcc(Assembler::notEqual, notBool);
3189 
3190   // ztos
3191   {
3192     __ pop(ztos);
3193     if (!is_static) pop_and_check_object(obj);
3194     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3195     if (!is_static &amp;&amp; rc == may_rewrite) {
3196       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3197     }
3198     __ jmp(Done);
3199   }
3200 
3201   __ bind(notBool);
3202   __ cmpl(flags, atos);
3203   __ jcc(Assembler::notEqual, notObj);
3204 
3205   // atos
3206   {
<span class="line-modified">3207     __ pop(atos);</span>
<span class="line-modified">3208     if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3209     // Store into the field</span>
<span class="line-modified">3210     do_oop_store(_masm, field, rax);</span>
<span class="line-modified">3211     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-modified">3212       patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>














































3213     }
<span class="line-removed">3214     __ jmp(Done);</span>
3215   }
3216 
3217   __ bind(notObj);
3218   __ cmpl(flags, itos);
3219   __ jcc(Assembler::notEqual, notInt);
3220 
3221   // itos
3222   {
3223     __ pop(itos);
3224     if (!is_static) pop_and_check_object(obj);
3225     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3226     if (!is_static &amp;&amp; rc == may_rewrite) {
3227       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3228     }
3229     __ jmp(Done);
3230   }
3231 
3232   __ bind(notInt);
3233   __ cmpl(flags, ctos);
3234   __ jcc(Assembler::notEqual, notChar);
</pre>
<hr />
<pre>
3333 }
3334 
3335 void TemplateTable::jvmti_post_fast_field_mod() {
3336 
3337   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3338 
3339   if (JvmtiExport::can_post_field_modification()) {
3340     // Check to see if a field modification watch has been set before
3341     // we take the time to call into the VM.
3342     Label L2;
3343     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3344     __ testl(scratch, scratch);
3345     __ jcc(Assembler::zero, L2);
3346     __ pop_ptr(rbx);                  // copy the object pointer from tos
3347     __ verify_oop(rbx);
3348     __ push_ptr(rbx);                 // put the object pointer back on tos
3349     // Save tos values before call_VM() clobbers them. Since we have
3350     // to do it for every data type, we use the saved values as the
3351     // jvalue object.
3352     switch (bytecode()) {          // load values into the jvalue object

3353     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3354     case Bytecodes::_fast_bputfield: // fall through
3355     case Bytecodes::_fast_zputfield: // fall through
3356     case Bytecodes::_fast_sputfield: // fall through
3357     case Bytecodes::_fast_cputfield: // fall through
3358     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3359     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3360     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3361     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3362 
3363     default:
3364       ShouldNotReachHere();
3365     }
3366     __ mov(scratch, rsp);             // points to jvalue on the stack
3367     // access constant pool cache entry
3368     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3369     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3370     __ verify_oop(rbx);
3371     // rbx: object pointer copied above
3372     // c_rarg2: cache entry pointer
3373     // c_rarg3: jvalue object on the stack
3374     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3375     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3376 
3377     switch (bytecode()) {             // restore tos values

3378     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3379     case Bytecodes::_fast_bputfield: // fall through
3380     case Bytecodes::_fast_zputfield: // fall through
3381     case Bytecodes::_fast_sputfield: // fall through
3382     case Bytecodes::_fast_cputfield: // fall through
3383     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3384     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3385     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3386     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3387     default: break;
3388     }
3389     __ bind(L2);
3390   }
3391 }
3392 
3393 void TemplateTable::fast_storefield(TosState state) {
3394   transition(state, vtos);
3395 
3396   ByteSize base = ConstantPoolCache::base_offset();
3397 
3398   jvmti_post_fast_field_mod();
3399 
3400   // access constant pool cache
3401   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3402 
3403   // test for volatile with rdx but rdx is tos register for lputfield.
3404   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3405                        in_bytes(base +
3406                                 ConstantPoolCacheEntry::flags_offset())));
3407 
3408   // replace index with field offset from cache entry
3409   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3410                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3411 
3412   // [jk] not needed currently
3413   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3414   //                                              Assembler::StoreStore));
3415 
3416   Label notVolatile, Done;




3417   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3418   __ andl(rdx, 0x1);
3419 
3420   // Get object from stack
3421   pop_and_check_object(rcx);
3422 
3423   // field address
3424   const Address field(rcx, rbx, Address::times_1);
3425 
3426   // Check for volatile store
3427   __ testl(rdx, rdx);
3428   __ jcc(Assembler::zero, notVolatile);
3429 
<span class="line-modified">3430   fast_storefield_helper(field, rax);</span>



3431   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3432                                                Assembler::StoreStore));
3433   __ jmp(Done);
3434   __ bind(notVolatile);
3435 
<span class="line-modified">3436   fast_storefield_helper(field, rax);</span>



3437 
3438   __ bind(Done);
3439 }
3440 
<span class="line-modified">3441 void TemplateTable::fast_storefield_helper(Address field, Register rax) {</span>
3442 
3443   // access field
3444   switch (bytecode()) {

















3445   case Bytecodes::_fast_aputfield:
<span class="line-modified">3446     do_oop_store(_masm, field, rax);</span>


3447     break;
3448   case Bytecodes::_fast_lputfield:
3449 #ifdef _LP64
3450     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3451 #else
3452   __ stop(&quot;should not be rewritten&quot;);
3453 #endif
3454     break;
3455   case Bytecodes::_fast_iputfield:
3456     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3457     break;
3458   case Bytecodes::_fast_zputfield:
3459     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3460     break;
3461   case Bytecodes::_fast_bputfield:
3462     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3463     break;
3464   case Bytecodes::_fast_sputfield:
3465     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3466     break;
</pre>
<hr />
<pre>
3496     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3497     LP64_ONLY(__ mov(c_rarg1, rax));
3498     // c_rarg1: object pointer copied above
3499     // c_rarg2: cache entry pointer
3500     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3501     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3502     __ pop_ptr(rax); // restore object pointer
3503     __ bind(L1);
3504   }
3505 
3506   // access constant pool cache
3507   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3508   // replace index with field offset from cache entry
3509   // [jk] not needed currently
3510   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3511   //                      in_bytes(ConstantPoolCache::base_offset() +
3512   //                               ConstantPoolCacheEntry::flags_offset())));
3513   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3514   // __ andl(rdx, 0x1);
3515   //
<span class="line-modified">3516   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,</span>
3517                          in_bytes(ConstantPoolCache::base_offset() +
3518                                   ConstantPoolCacheEntry::f2_offset())));
3519 
3520   // rax: object
3521   __ verify_oop(rax);
3522   __ null_check(rax);
<span class="line-modified">3523   Address field(rax, rbx, Address::times_1);</span>
3524 
3525   // access field
3526   switch (bytecode()) {






































3527   case Bytecodes::_fast_agetfield:
3528     do_oop_load(_masm, field, rax);
3529     __ verify_oop(rax);
3530     break;
3531   case Bytecodes::_fast_lgetfield:
3532 #ifdef _LP64
3533     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3534 #else
3535   __ stop(&quot;should not be rewritten&quot;);
3536 #endif
3537     break;
3538   case Bytecodes::_fast_igetfield:
3539     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3540     break;
3541   case Bytecodes::_fast_bgetfield:
3542     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3543     break;
3544   case Bytecodes::_fast_sgetfield:
3545     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3546     break;
</pre>
<hr />
<pre>
3978 
3979   // Note:  rax_callsite is already pushed by prepare_invoke
3980 
3981   // %%% should make a type profile for any invokedynamic that takes a ref argument
3982   // profile this call
3983   __ profile_call(rbcp);
3984   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
3985 
3986   __ verify_oop(rax_callsite);
3987 
3988   __ jump_from_interpreted(rbx_method, rdx);
3989 }
3990 
3991 //-----------------------------------------------------------------------------
3992 // Allocation
3993 
3994 void TemplateTable::_new() {
3995   transition(vtos, atos);
3996   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
3997   Label slow_case;
<span class="line-modified">3998   Label slow_case_no_pop;</span>
<span class="line-removed">3999   Label done;</span>
<span class="line-removed">4000   Label initialize_header;</span>
4001   Label initialize_object;  // including clearing the fields
4002 
4003   __ get_cpool_and_tags(rcx, rax);
4004 
4005   // Make sure the class we&#39;re about to instantiate has been resolved.
4006   // This is done before loading InstanceKlass to be consistent with the order
4007   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4008   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4009   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
<span class="line-modified">4010   __ jcc(Assembler::notEqual, slow_case_no_pop);</span>
4011 
4012   // get InstanceKlass
4013   __ load_resolved_klass_at_index(rcx, rcx, rdx);
<span class="line-modified">4014   __ push(rcx);  // save the contexts of klass for initializing the header</span>






4015 
4016   // make sure klass is initialized &amp; doesn&#39;t have finalizer
<span class="line-removed">4017   // make sure klass is fully initialized</span>
4018   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4019   __ jcc(Assembler::notEqual, slow_case);
4020 
<span class="line-modified">4021   // get instance_size in InstanceKlass (scaled to a count of bytes)</span>
<span class="line-modified">4022   __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));</span>
<span class="line-removed">4023   // test to see if it has a finalizer or is malformed in some way</span>
<span class="line-removed">4024   __ testl(rdx, Klass::_lh_instance_slow_path_bit);</span>
<span class="line-removed">4025   __ jcc(Assembler::notZero, slow_case);</span>
<span class="line-removed">4026 </span>
<span class="line-removed">4027   // Allocate the instance:</span>
<span class="line-removed">4028   //  If TLAB is enabled:</span>
<span class="line-removed">4029   //    Try to allocate in the TLAB.</span>
<span class="line-removed">4030   //    If fails, go to the slow path.</span>
<span class="line-removed">4031   //  Else If inline contiguous allocations are enabled:</span>
<span class="line-removed">4032   //    Try to allocate in eden.</span>
<span class="line-removed">4033   //    If fails due to heap end, go to slow path.</span>
<span class="line-removed">4034   //</span>
<span class="line-removed">4035   //  If TLAB is enabled OR inline contiguous is enabled:</span>
<span class="line-removed">4036   //    Initialize the allocation.</span>
<span class="line-removed">4037   //    Exit.</span>
<span class="line-removed">4038   //</span>
<span class="line-removed">4039   //  Go to slow path.</span>
4040 
<span class="line-modified">4041   const bool allow_shared_alloc =</span>
<span class="line-modified">4042     Universe::heap()-&gt;supports_inline_contig_alloc();</span>
4043 
<span class="line-modified">4044   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);</span>
<span class="line-modified">4045 #ifndef _LP64</span>
<span class="line-removed">4046   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-removed">4047     __ get_thread(thread);</span>
<span class="line-removed">4048   }</span>
<span class="line-removed">4049 #endif // _LP64</span>
4050 
<span class="line-modified">4051   if (UseTLAB) {</span>
<span class="line-modified">4052     __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);</span>
<span class="line-modified">4053     if (ZeroTLAB) {</span>
<span class="line-modified">4054       // the fields have been already cleared</span>
<span class="line-removed">4055       __ jmp(initialize_header);</span>
<span class="line-removed">4056     } else {</span>
<span class="line-removed">4057       // initialize both the header and fields</span>
<span class="line-removed">4058       __ jmp(initialize_object);</span>
<span class="line-removed">4059     }</span>
<span class="line-removed">4060   } else {</span>
<span class="line-removed">4061     // Allocation in the shared Eden, if allowed.</span>
<span class="line-removed">4062     //</span>
<span class="line-removed">4063     // rdx: instance size in bytes</span>
<span class="line-removed">4064     __ eden_allocate(thread, rax, rdx, 0, rbx, slow_case);</span>
<span class="line-removed">4065   }</span>
4066 
<span class="line-modified">4067   // If UseTLAB or allow_shared_alloc are true, the object is created above and</span>
<span class="line-modified">4068   // there is an initialize need. Otherwise, skip and go to the slow path.</span>
<span class="line-modified">4069   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-removed">4070     // The object is initialized before the header.  If the object size is</span>
<span class="line-removed">4071     // zero, go directly to the header initialization.</span>
<span class="line-removed">4072     __ bind(initialize_object);</span>
<span class="line-removed">4073     __ decrement(rdx, sizeof(oopDesc));</span>
<span class="line-removed">4074     __ jcc(Assembler::zero, initialize_header);</span>
<span class="line-removed">4075 </span>
<span class="line-removed">4076     // Initialize topmost object field, divide rdx by 8, check if odd and</span>
<span class="line-removed">4077     // test if zero.</span>
<span class="line-removed">4078     __ xorl(rcx, rcx);    // use zero reg to clear memory (shorter code)</span>
<span class="line-removed">4079     __ shrl(rdx, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd</span>
<span class="line-removed">4080 </span>
<span class="line-removed">4081     // rdx must have been multiple of 8</span>
<span class="line-removed">4082 #ifdef ASSERT</span>
<span class="line-removed">4083     // make sure rdx was multiple of 8</span>
<span class="line-removed">4084     Label L;</span>
<span class="line-removed">4085     // Ignore partial flag stall after shrl() since it is debug VM</span>
<span class="line-removed">4086     __ jcc(Assembler::carryClear, L);</span>
<span class="line-removed">4087     __ stop(&quot;object size is not multiple of 2 - adjust this code&quot;);</span>
<span class="line-removed">4088     __ bind(L);</span>
<span class="line-removed">4089     // rdx must be &gt; 0, no extra check needed here</span>
<span class="line-removed">4090 #endif</span>
4091 
<span class="line-modified">4092     // initialize remaining object fields: rdx was a multiple of 8</span>
<span class="line-modified">4093     { Label loop;</span>
<span class="line-removed">4094     __ bind(loop);</span>
<span class="line-removed">4095     __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);</span>
<span class="line-removed">4096     NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));</span>
<span class="line-removed">4097     __ decrement(rdx);</span>
<span class="line-removed">4098     __ jcc(Assembler::notZero, loop);</span>
<span class="line-removed">4099     }</span>
4100 
<span class="line-modified">4101     // initialize object header only.</span>
<span class="line-modified">4102     __ bind(initialize_header);</span>
<span class="line-modified">4103     if (UseBiasedLocking) {</span>
<span class="line-removed">4104       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="line-removed">4105       __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));</span>
<span class="line-removed">4106       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);</span>
<span class="line-removed">4107     } else {</span>
<span class="line-removed">4108       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),</span>
<span class="line-removed">4109                 (intptr_t)markWord::prototype().value()); // header</span>
<span class="line-removed">4110       __ pop(rcx);   // get saved klass back in the register.</span>
<span class="line-removed">4111     }</span>
<span class="line-removed">4112 #ifdef _LP64</span>
<span class="line-removed">4113     __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)</span>
<span class="line-removed">4114     __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops</span>
<span class="line-removed">4115 #endif</span>
<span class="line-removed">4116     __ store_klass(rax, rcx);  // klass</span>
4117 
<span class="line-modified">4118     {</span>
<span class="line-modified">4119       SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);</span>
<span class="line-removed">4120       // Trigger dtrace event for fastpath</span>
<span class="line-removed">4121       __ push(atos);</span>
<span class="line-removed">4122       __ call_VM_leaf(</span>
<span class="line-removed">4123            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);</span>
<span class="line-removed">4124       __ pop(atos);</span>
<span class="line-removed">4125     }</span>
4126 
<span class="line-modified">4127     __ jmp(done);</span>
<span class="line-modified">4128   }</span>























4129 
<span class="line-modified">4130   // slow case</span>
<span class="line-removed">4131   __ bind(slow_case);</span>
<span class="line-removed">4132   __ pop(rcx);   // restore stack pointer to what it was when we came in.</span>
<span class="line-removed">4133   __ bind(slow_case_no_pop);</span>
4134 
4135   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4136   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4137 
<span class="line-modified">4138   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4139   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4140   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>

4141    __ verify_oop(rax);
4142 
<span class="line-modified">4143   // continue</span>
4144   __ bind(done);
4145 }
4146 
4147 void TemplateTable::newarray() {
4148   transition(itos, atos);
4149   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4150   __ load_unsigned_byte(rarg1, at_bcp(1));
4151   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4152           rarg1, rax);
4153 }
4154 
4155 void TemplateTable::anewarray() {
4156   transition(itos, atos);
4157 
4158   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4159   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4160 
4161   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4162   __ get_constant_pool(rarg1);
4163   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4164           rarg1, rarg2, rax);
4165 }
4166 
4167 void TemplateTable::arraylength() {
4168   transition(atos, itos);
4169   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4170   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4171 }
4172 
4173 void TemplateTable::checkcast() {
4174   transition(atos, atos);
4175   Label done, is_null, ok_is_subtype, quicked, resolved;
4176   __ testptr(rax, rax); // object is in rax
4177   __ jcc(Assembler::zero, is_null);
4178 
4179   // Get cpool &amp; tags index
4180   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4181   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4182   // See if bytecode has already been quicked
<span class="line-modified">4183   __ cmpb(Address(rdx, rbx,</span>
<span class="line-modified">4184                   Address::times_1,</span>
<span class="line-modified">4185                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="line-modified">4186           JVM_CONSTANT_Class);</span>

4187   __ jcc(Assembler::equal, quicked);
4188   __ push(atos); // save receiver for result, and for GC
4189   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4190 
4191   // vm_result_2 has metadata result
4192 #ifndef _LP64
4193   // borrow rdi from locals
4194   __ get_thread(rdi);
4195   __ get_vm_result_2(rax, rdi);
4196   __ restore_locals();
4197 #else
4198   __ get_vm_result_2(rax, r15_thread);
4199 #endif
4200 
4201   __ pop_ptr(rdx); // restore receiver
4202   __ jmpb(resolved);
4203 
4204   // Get superklass in rax and subklass in rbx
4205   __ bind(quicked);
4206   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4207   __ load_resolved_klass_at_index(rax, rcx, rbx);
4208 
4209   __ bind(resolved);
4210   __ load_klass(rbx, rdx);
4211 
4212   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4213   // Superklass in rax.  Subklass in rbx.
4214   __ gen_subtype_check(rbx, ok_is_subtype);
4215 
4216   // Come here on failure
4217   __ push_ptr(rdx);
4218   // object is at TOS
4219   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4220 
4221   // Come here on success
4222   __ bind(ok_is_subtype);
4223   __ mov(rax, rdx); // Restore object in rdx



4224 
4225   // Collect counts on whether this check-cast sees NULLs a lot or not.
4226   if (ProfileInterpreter) {
<span class="line-modified">4227     __ jmp(done);</span>
<span class="line-modified">4228     __ bind(is_null);</span>
<span class="line-modified">4229     __ profile_null_seen(rcx);</span>
<span class="line-modified">4230   } else {</span>











4231     __ bind(is_null);   // same as &#39;done&#39;
4232   }
4233   __ bind(done);
4234 }
4235 
4236 void TemplateTable::instanceof() {
4237   transition(atos, itos);
4238   Label done, is_null, ok_is_subtype, quicked, resolved;
4239   __ testptr(rax, rax);
4240   __ jcc(Assembler::zero, is_null);
4241 
4242   // Get cpool &amp; tags index
4243   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4244   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4245   // See if bytecode has already been quicked
<span class="line-modified">4246   __ cmpb(Address(rdx, rbx,</span>
<span class="line-modified">4247                   Address::times_1,</span>
<span class="line-modified">4248                   Array&lt;u1&gt;::base_offset_in_bytes()),</span>
<span class="line-modified">4249           JVM_CONSTANT_Class);</span>

4250   __ jcc(Assembler::equal, quicked);
4251 
4252   __ push(atos); // save receiver for result, and for GC
4253   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4254   // vm_result_2 has metadata result
4255 
4256 #ifndef _LP64
4257   // borrow rdi from locals
4258   __ get_thread(rdi);
4259   __ get_vm_result_2(rax, rdi);
4260   __ restore_locals();
4261 #else
4262   __ get_vm_result_2(rax, r15_thread);
4263 #endif
4264 
4265   __ pop_ptr(rdx); // restore receiver
4266   __ verify_oop(rdx);
4267   __ load_klass(rdx, rdx);
4268   __ jmpb(resolved);
4269 
</pre>
<hr />
<pre>
4281   // Come here on failure
4282   __ xorl(rax, rax);
4283   __ jmpb(done);
4284   // Come here on success
4285   __ bind(ok_is_subtype);
4286   __ movl(rax, 1);
4287 
4288   // Collect counts on whether this test sees NULLs a lot or not.
4289   if (ProfileInterpreter) {
4290     __ jmp(done);
4291     __ bind(is_null);
4292     __ profile_null_seen(rcx);
4293   } else {
4294     __ bind(is_null);   // same as &#39;done&#39;
4295   }
4296   __ bind(done);
4297   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4298   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4299 }
4300 
<span class="line-removed">4301 </span>
4302 //----------------------------------------------------------------------------------------------------
4303 // Breakpoints
4304 void TemplateTable::_breakpoint() {
4305   // Note: We get here even if we are single stepping..
4306   // jbug insists on setting breakpoints at every bytecode
4307   // even if we are in single step mode.
4308 
4309   transition(vtos, vtos);
4310 
4311   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4312 
4313   // get the unpatched byte code
4314   __ get_method(rarg);
4315   __ call_VM(noreg,
4316              CAST_FROM_FN_PTR(address,
4317                               InterpreterRuntime::get_original_bytecode_at),
4318              rarg, rbcp);
4319   __ mov(rbx, rax);  // why?
4320 
4321   // post the breakpoint event
</pre>
<hr />
<pre>
4345 //
4346 // Stack layout:
4347 //
4348 // [expressions  ] &lt;--- rsp               = expression stack top
4349 // ..
4350 // [expressions  ]
4351 // [monitor entry] &lt;--- monitor block top = expression stack bot
4352 // ..
4353 // [monitor entry]
4354 // [frame data   ] &lt;--- monitor block bot
4355 // ...
4356 // [saved rbp    ] &lt;--- rbp
4357 void TemplateTable::monitorenter() {
4358   transition(atos, vtos);
4359 
4360   // check for NULL object
4361   __ null_check(rax);
4362 
4363   __ resolve(IS_NOT_NULL, rax);
4364 











4365   const Address monitor_block_top(
4366         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4367   const Address monitor_block_bot(
4368         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4369   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4370 
4371   Label allocated;
4372 
4373   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4374   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4375   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4376 
4377   // initialize entry pointer
4378   __ xorl(rmon, rmon); // points to free slot or NULL
4379 
4380   // find a free slot in the monitor block (result in rmon)
4381   {
4382     Label entry, loop, exit;
4383     __ movptr(rtop, monitor_block_top); // points to current entry,
4384                                         // starting with top-most entry
</pre>
<hr />
<pre>
4444   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4445   __ lock_object(rmon);
4446 
4447   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4448   __ save_bcp();  // in case of exception
4449   __ generate_stack_overflow_check(0);
4450 
4451   // The bcp has already been incremented. Just need to dispatch to
4452   // next instruction.
4453   __ dispatch_next(vtos);
4454 }
4455 
4456 void TemplateTable::monitorexit() {
4457   transition(atos, vtos);
4458 
4459   // check for NULL object
4460   __ null_check(rax);
4461 
4462   __ resolve(IS_NOT_NULL, rax);
4463 











4464   const Address monitor_block_top(
4465         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4466   const Address monitor_block_bot(
4467         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4468   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4469 
4470   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4471   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4472 
4473   Label found;
4474 
4475   // find matching slot
4476   {
4477     Label entry, loop;
4478     __ movptr(rtop, monitor_block_top); // points to current entry,
4479                                         // starting with top-most entry
4480     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4481                                         // of monitor block
4482     __ jmpb(entry);
4483 
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  36 #include &quot;oops/valueKlass.hpp&quot;</span>
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 
  45 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  46 
  47 // Global Register Names
  48 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  49 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  50 
  51 // Platform-dependent initialization
  52 void TemplateTable::pd_initialize() {
  53   // No x86 specific initialization
  54 }
  55 
  56 // Address Computation: local variables
</pre>
<hr />
<pre>
 138   case TemplateTable::less_equal   : return Assembler::greater;
 139   case TemplateTable::greater      : return Assembler::lessEqual;
 140   case TemplateTable::greater_equal: return Assembler::less;
 141   }
 142   ShouldNotReachHere();
 143   return Assembler::zero;
 144 }
 145 
 146 
 147 
 148 // Miscelaneous helper routines
 149 // Store an oop (or NULL) at the address described by obj.
 150 // If val == noreg this means store a NULL
 151 
 152 
 153 static void do_oop_store(InterpreterMacroAssembler* _masm,
 154                          Address dst,
 155                          Register val,
 156                          DecoratorSet decorators = 0) {
 157   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
<span class="line-modified"> 158   __ store_heap_oop(dst, val, rdx, rbx, noreg, decorators);</span>
 159 }
 160 
 161 static void do_oop_load(InterpreterMacroAssembler* _masm,
 162                         Address src,
 163                         Register dst,
 164                         DecoratorSet decorators = 0) {
 165   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 166 }
 167 
 168 Address TemplateTable::at_bcp(int offset) {
 169   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 170   return Address(rbcp, offset);
 171 }
 172 
 173 
 174 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 175                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 176                                    int byte_no) {
 177   if (!RewriteBytecodes)  return;
 178   Label L_patch_done;
 179 
 180   switch (bc) {
<span class="line-added"> 181   case Bytecodes::_fast_qputfield:</span>
 182   case Bytecodes::_fast_aputfield:
 183   case Bytecodes::_fast_bputfield:
 184   case Bytecodes::_fast_zputfield:
 185   case Bytecodes::_fast_cputfield:
 186   case Bytecodes::_fast_dputfield:
 187   case Bytecodes::_fast_fputfield:
 188   case Bytecodes::_fast_iputfield:
 189   case Bytecodes::_fast_lputfield:
 190   case Bytecodes::_fast_sputfield:
 191     {
 192       // We skip bytecode quickening for putfield instructions when
 193       // the put_code written to the constant pool cache is zero.
 194       // This is required so that every execution of this instruction
 195       // calls out to InterpreterRuntime::resolve_get_put to do
 196       // additional, required work.
 197       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 198       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 199       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 200       __ movl(bc_reg, bc);
 201       __ cmpl(temp_reg, (int) 0);
</pre>
<hr />
<pre>
 354   __ sarl(rax, 16);
 355 }
 356 
 357 void TemplateTable::ldc(bool wide) {
 358   transition(vtos, vtos);
 359   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 360   Label call_ldc, notFloat, notClass, notInt, Done;
 361 
 362   if (wide) {
 363     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 364   } else {
 365     __ load_unsigned_byte(rbx, at_bcp(1));
 366   }
 367 
 368   __ get_cpool_and_tags(rcx, rax);
 369   const int base_offset = ConstantPool::header_size() * wordSize;
 370   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 371 
 372   // get type
 373   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
<span class="line-added"> 374   __ andl(rdx, ~JVM_CONSTANT_QDescBit);</span>
 375 
 376   // unresolved class - get the resolved class
 377   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 378   __ jccb(Assembler::equal, call_ldc);
 379 
 380   // unresolved class in error state - call into runtime to throw the error
 381   // from the first resolution attempt
 382   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 383   __ jccb(Assembler::equal, call_ldc);
 384 
 385   // resolved class - need to call vm to get java mirror of the class
 386   __ cmpl(rdx, JVM_CONSTANT_Class);
 387   __ jcc(Assembler::notEqual, notClass);
 388 
 389   __ bind(call_ldc);
 390 
 391   __ movl(rarg, wide);
 392   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 393 
 394   __ push(atos);
</pre>
<hr />
<pre>
 805                     Address(rdx, rax,
 806                             Address::times_4,
 807                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 808                     noreg, noreg);
 809 }
 810 
 811 void TemplateTable::daload() {
 812   transition(itos, dtos);
 813   // rax: index
 814   // rdx: array
 815   index_check(rdx, rax); // kills rbx
 816   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,
 817                     Address(rdx, rax,
 818                             Address::times_8,
 819                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
 820                     noreg, noreg);
 821 }
 822 
 823 void TemplateTable::aaload() {
 824   transition(itos, atos);
<span class="line-modified"> 825   Register array = rdx;</span>
<span class="line-modified"> 826   Register index = rax;</span>
<span class="line-modified"> 827 </span>
<span class="line-modified"> 828   index_check(array, index); // kills rbx</span>
<span class="line-modified"> 829   __ profile_array(rbx, array, rcx);</span>
<span class="line-modified"> 830   if (ValueArrayFlatten) {</span>
<span class="line-modified"> 831     Label is_flat_array, done;</span>
<span class="line-modified"> 832     __ test_flattened_array_oop(array, rbx, is_flat_array);</span>
<span class="line-modified"> 833     do_oop_load(_masm,</span>
<span class="line-added"> 834                 Address(array, index,</span>
<span class="line-added"> 835                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-added"> 836                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-added"> 837                 rax,</span>
<span class="line-added"> 838                 IS_ARRAY);</span>
<span class="line-added"> 839     __ jmp(done);</span>
<span class="line-added"> 840     __ bind(is_flat_array);</span>
<span class="line-added"> 841     __ read_flattened_element(array, index, rbx, rcx, rax);</span>
<span class="line-added"> 842     __ bind(done);</span>
<span class="line-added"> 843   } else {</span>
<span class="line-added"> 844     do_oop_load(_masm,</span>
<span class="line-added"> 845                 Address(array, index,</span>
<span class="line-added"> 846                         UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-added"> 847                         arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-added"> 848                 rax,</span>
<span class="line-added"> 849                 IS_ARRAY);</span>
<span class="line-added"> 850   }</span>
<span class="line-added"> 851   __ profile_element(rbx, rax, rcx);</span>
 852 }
 853 
 854 void TemplateTable::baload() {
 855   transition(itos, itos);
 856   // rax: index
 857   // rdx: array
 858   index_check(rdx, rax); // kills rbx
 859   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,
 860                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),
 861                     noreg, noreg);
 862 }
 863 
 864 void TemplateTable::caload() {
 865   transition(itos, itos);
 866   // rax: index
 867   // rdx: array
 868   index_check(rdx, rax); // kills rbx
 869   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 870                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 871                     noreg, noreg);
</pre>
<hr />
<pre>
1117   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,
1118                      Address(rdx, rbx, Address::times_4,
1119                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1120                      noreg /* ftos */, noreg, noreg);
1121 }
1122 
1123 void TemplateTable::dastore() {
1124   transition(dtos, vtos);
1125   __ pop_i(rbx);
1126   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1127   // rbx:  index
1128   // rdx:  array
1129   index_check(rdx, rbx); // prefer index in rbx
1130   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,
1131                      Address(rdx, rbx, Address::times_8,
1132                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),
1133                      noreg /* dtos */, noreg, noreg);
1134 }
1135 
1136 void TemplateTable::aastore() {
<span class="line-modified">1137   Label is_null, is_flat_array, ok_is_subtype, done;</span>
1138   transition(vtos, vtos);
1139   // stack: ..., array, index, value
1140   __ movptr(rax, at_tos());    // value
1141   __ movl(rcx, at_tos_p1()); // index
1142   __ movptr(rdx, at_tos_p2()); // array
1143 
1144   Address element_address(rdx, rcx,
1145                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1146                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1147 
1148   index_check_without_pop(rdx, rcx);     // kills rbx
<span class="line-added">1149 </span>
<span class="line-added">1150   __ profile_array(rdi, rdx, rbx);</span>
<span class="line-added">1151   __ profile_element(rdi, rax, rbx);</span>
<span class="line-added">1152 </span>
1153   __ testptr(rax, rax);
1154   __ jcc(Assembler::zero, is_null);
1155 
<span class="line-added">1156   // Move array class to rdi</span>
<span class="line-added">1157   __ load_klass(rdi, rdx);</span>
<span class="line-added">1158   if (ValueArrayFlatten) {</span>
<span class="line-added">1159     __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));</span>
<span class="line-added">1160     __ test_flattened_array_layout(rbx, is_flat_array);</span>
<span class="line-added">1161   }</span>
<span class="line-added">1162 </span>
1163   // Move subklass into rbx
1164   __ load_klass(rbx, rax);
<span class="line-modified">1165   // Move array element superklass into rax</span>
<span class="line-modified">1166   __ movptr(rax, Address(rdi,</span>

1167                          ObjArrayKlass::element_klass_offset()));
1168 
1169   // Generate subtype check.  Blows rcx, rdi
1170   // Superklass in rax.  Subklass in rbx.
<span class="line-modified">1171   // is &quot;rbx &lt;: rax&quot; ? (value subclass &lt;: array element superclass)</span>
<span class="line-added">1172   __ gen_subtype_check(rbx, ok_is_subtype, false);</span>
1173 
1174   // Come here on failure
1175   // object is at TOS
1176   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1177 
1178   // Come here on success
1179   __ bind(ok_is_subtype);
1180 
1181   // Get the value we will store
1182   __ movptr(rax, at_tos());
1183   __ movl(rcx, at_tos_p1()); // index
1184   // Now store using the appropriate barrier
1185   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1186   __ jmp(done);
1187 
1188   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1189   __ bind(is_null);
<span class="line-modified">1190   if (EnableValhalla) {</span>
<span class="line-added">1191     Label is_null_into_value_array_npe, store_null;</span>
1192 
<span class="line-added">1193     // No way to store null in null-free array</span>
<span class="line-added">1194     __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);</span>
<span class="line-added">1195     __ jmp(store_null);</span>
<span class="line-added">1196 </span>
<span class="line-added">1197     __ bind(is_null_into_value_array_npe);</span>
<span class="line-added">1198     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
<span class="line-added">1199 </span>
<span class="line-added">1200     __ bind(store_null);</span>
<span class="line-added">1201   }</span>
1202   // Store a NULL
1203   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
<span class="line-added">1204   __ jmp(done);</span>
<span class="line-added">1205 </span>
<span class="line-added">1206   if (EnableValhalla) {</span>
<span class="line-added">1207     Label is_type_ok;</span>
<span class="line-added">1208     __ bind(is_flat_array); // Store non-null value to flat</span>
<span class="line-added">1209 </span>
<span class="line-added">1210     // Simplistic type check...</span>
1211 
<span class="line-added">1212     // Profile the not-null value&#39;s klass.</span>
<span class="line-added">1213     __ load_klass(rbx, rax);</span>
<span class="line-added">1214     // Move element klass into rax</span>
<span class="line-added">1215     __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));</span>
<span class="line-added">1216     // flat value array needs exact type match</span>
<span class="line-added">1217     // is &quot;rax == rbx&quot; (value subclass == array element superclass)</span>
<span class="line-added">1218     __ cmpptr(rax, rbx);</span>
<span class="line-added">1219     __ jccb(Assembler::equal, is_type_ok);</span>
<span class="line-added">1220 </span>
<span class="line-added">1221     __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));</span>
<span class="line-added">1222 </span>
<span class="line-added">1223     __ bind(is_type_ok);</span>
<span class="line-added">1224     // rbx: value&#39;s klass</span>
<span class="line-added">1225     // rdx: array</span>
<span class="line-added">1226     // rdi: array klass</span>
<span class="line-added">1227     __ test_klass_is_empty_value(rbx, rax, done);</span>
<span class="line-added">1228 </span>
<span class="line-added">1229     // calc dst for copy</span>
<span class="line-added">1230     __ movl(rax, at_tos_p1()); // index</span>
<span class="line-added">1231     __ data_for_value_array_index(rdx, rdi, rax, rax);</span>
<span class="line-added">1232 </span>
<span class="line-added">1233     // ...and src for copy</span>
<span class="line-added">1234     __ movptr(rcx, at_tos());  // value</span>
<span class="line-added">1235     __ data_for_oop(rcx, rcx, rbx);</span>
<span class="line-added">1236 </span>
<span class="line-added">1237     __ access_value_copy(IN_HEAP, rcx, rax, rbx);</span>
<span class="line-added">1238   }</span>
1239   // Pop stack arguments
1240   __ bind(done);
1241   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1242 }
1243 
1244 void TemplateTable::bastore() {
1245   transition(itos, vtos);
1246   __ pop_i(rbx);
1247   // rax: value
1248   // rbx: index
1249   // rdx: array
1250   index_check(rdx, rbx); // prefer index in rbx
1251   // Need to check whether array is boolean or byte
1252   // since both types share the bastore bytecode.
1253   __ load_klass(rcx, rdx);
1254   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1255   int diffbit = Klass::layout_helper_boolean_diffbit();
1256   __ testl(rcx, diffbit);
1257   Label L_skip;
1258   __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
2464   __ jcc(j_not(cc), not_taken);
2465   branch(false, false);
2466   __ bind(not_taken);
2467   __ profile_not_taken_branch(rax);
2468 }
2469 
2470 void TemplateTable::if_nullcmp(Condition cc) {
2471   transition(atos, vtos);
2472   // assume branch is more often taken than not (loops use backward branches)
2473   Label not_taken;
2474   __ testptr(rax, rax);
2475   __ jcc(j_not(cc), not_taken);
2476   branch(false, false);
2477   __ bind(not_taken);
2478   __ profile_not_taken_branch(rax);
2479 }
2480 
2481 void TemplateTable::if_acmp(Condition cc) {
2482   transition(atos, vtos);
2483   // assume branch is more often taken than not (loops use backward branches)
<span class="line-modified">2484   Label taken, not_taken;</span>
2485   __ pop_ptr(rdx);
<span class="line-added">2486 </span>
<span class="line-added">2487   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">2488   if (EnableValhalla) {</span>
<span class="line-added">2489     __ cmpoop(rdx, rax);</span>
<span class="line-added">2490     __ jcc(Assembler::equal, (cc == equal) ? taken : not_taken);</span>
<span class="line-added">2491 </span>
<span class="line-added">2492     // might be substitutable, test if either rax or rdx is null</span>
<span class="line-added">2493     __ movptr(rbx, rdx);</span>
<span class="line-added">2494     __ andptr(rbx, rax);</span>
<span class="line-added">2495     __ testptr(rbx, rbx);</span>
<span class="line-added">2496     __ jcc(Assembler::zero, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2497 </span>
<span class="line-added">2498     // and both are values ?</span>
<span class="line-added">2499     __ movptr(rbx, Address(rdx, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">2500     __ andptr(rbx, is_value_mask);</span>
<span class="line-added">2501     __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">2502     __ andptr(rbx, is_value_mask);</span>
<span class="line-added">2503     __ andptr(rbx, rcx);</span>
<span class="line-added">2504     __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">2505     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2506 </span>
<span class="line-added">2507     // same value klass ?</span>
<span class="line-added">2508     __ load_metadata(rbx, rdx);</span>
<span class="line-added">2509     __ load_metadata(rcx, rax);</span>
<span class="line-added">2510     __ cmpptr(rbx, rcx);</span>
<span class="line-added">2511     __ jcc(Assembler::notEqual, (cc == equal) ? not_taken : taken);</span>
<span class="line-added">2512 </span>
<span class="line-added">2513     // Know both are the same type, let&#39;s test for substitutability...</span>
<span class="line-added">2514     if (cc == equal) {</span>
<span class="line-added">2515       invoke_is_substitutable(rax, rdx, taken, not_taken);</span>
<span class="line-added">2516     } else {</span>
<span class="line-added">2517       invoke_is_substitutable(rax, rdx, not_taken, taken);</span>
<span class="line-added">2518     }</span>
<span class="line-added">2519     __ stop(&quot;Not reachable&quot;);</span>
<span class="line-added">2520   }</span>
<span class="line-added">2521 </span>
2522   __ cmpoop(rdx, rax);
2523   __ jcc(j_not(cc), not_taken);
<span class="line-added">2524   __ bind(taken);</span>
2525   branch(false, false);
2526   __ bind(not_taken);
2527   __ profile_not_taken_branch(rax);
2528 }
2529 
<span class="line-added">2530 void TemplateTable::invoke_is_substitutable(Register aobj, Register bobj,</span>
<span class="line-added">2531                                             Label&amp; is_subst, Label&amp; not_subst) {</span>
<span class="line-added">2532   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::is_substitutable), aobj, bobj);</span>
<span class="line-added">2533   // Restored...rax answer, jmp to outcome...</span>
<span class="line-added">2534   __ testl(rax, rax);</span>
<span class="line-added">2535   __ jcc(Assembler::zero, not_subst);</span>
<span class="line-added">2536   __ jmp(is_subst);</span>
<span class="line-added">2537 }</span>
<span class="line-added">2538 </span>
2539 void TemplateTable::ret() {
2540   transition(vtos, vtos);
2541   locals_index(rbx);
2542   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2543   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2544   __ profile_ret(rbx, rcx);
2545   __ get_method(rax);
2546   __ movptr(rbcp, Address(rax, Method::const_offset()));
2547   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2548                       ConstMethod::codes_offset()));
2549   __ dispatch_next(vtos, 0, true);
2550 }
2551 
2552 void TemplateTable::wide_ret() {
2553   transition(vtos, vtos);
2554   locals_index_wide(rbx);
2555   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2556   __ profile_ret(rbx, rcx);
2557   __ get_method(rax);
2558   __ movptr(rbcp, Address(rax, Method::const_offset()));
</pre>
<hr />
<pre>
2784     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2785 #else
2786     const Register thread = rdi;
2787     __ get_thread(thread);
2788     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2789 #endif
2790     __ jcc(Assembler::zero, no_safepoint);
2791     __ push(state);
2792     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2793                                     InterpreterRuntime::at_safepoint));
2794     __ pop(state);
2795     __ bind(no_safepoint);
2796   }
2797 
2798   // Narrow result if state is itos but result type is smaller.
2799   // Need to narrow in the return bytecode rather than in generate_return_entry
2800   // since compiled code callers expect the result to already be narrowed.
2801   if (state == itos) {
2802     __ narrow(rax);
2803   }
<span class="line-modified">2804 </span>
<span class="line-added">2805   __ remove_activation(state, rbcp, true, true, true);</span>
2806 
2807   __ jmp(rbcp);
2808 }
2809 
2810 // ----------------------------------------------------------------------------
2811 // Volatile variables demand their effects be made known to all CPU&#39;s
2812 // in order.  Store buffers on most chips allow reads &amp; writes to
2813 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2814 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2815 // the interpreter does not reorder volatile references, the hardware
2816 // also must not reorder them).
2817 //
2818 // According to the new Java Memory Model (JMM):
2819 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2820 //     writes act as aquire &amp; release, so:
2821 // (2) A read cannot let unrelated NON-volatile memory refs that
2822 //     happen after the read float up to before the read.  It&#39;s OK for
2823 //     non-volatile memory refs that happen before the volatile read to
2824 //     float down below it.
2825 // (3) Similar a volatile write cannot let unrelated NON-volatile
</pre>
<hr />
<pre>
2983     __ get_cache_and_index_at_bcp(cache, index, 1);
2984     __ bind(L1);
2985   }
2986 }
2987 
2988 void TemplateTable::pop_and_check_object(Register r) {
2989   __ pop_ptr(r);
2990   __ null_check(r);  // for field access must check obj.
2991   __ verify_oop(r);
2992 }
2993 
2994 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2995   transition(vtos, vtos);
2996 
2997   const Register cache = rcx;
2998   const Register index = rdx;
2999   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3000   const Register off   = rbx;
3001   const Register flags = rax;
3002   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
<span class="line-added">3003   const Register flags2 = rdx;</span>
3004 
3005   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3006   jvmti_post_field_access(cache, index, is_static, false);
3007   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3008 


3009   const Address field(obj, off, Address::times_1, 0*wordSize);
3010 
<span class="line-modified">3011   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj, notValueType;</span>
<span class="line-added">3012 </span>
<span class="line-added">3013   if (!is_static) {</span>
<span class="line-added">3014     __ movptr(rcx, Address(cache, index, Address::times_ptr,</span>
<span class="line-added">3015                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3016                                     ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3017   }</span>
<span class="line-added">3018 </span>
<span class="line-added">3019   __ movl(flags2, flags);</span>
3020 
3021   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3022   // Make sure we don&#39;t need to mask edx after the above shift
3023   assert(btos == 0, &quot;change code, btos != 0&quot;);
3024 
3025   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3026 
3027   __ jcc(Assembler::notZero, notByte);
3028   // btos
<span class="line-added">3029   if (!is_static) pop_and_check_object(obj);</span>
3030   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3031   __ push(btos);
3032   // Rewrite bytecode to be faster
3033   if (!is_static &amp;&amp; rc == may_rewrite) {
3034     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3035   }
3036   __ jmp(Done);
3037 
3038   __ bind(notByte);
<span class="line-added">3039 </span>
3040   __ cmpl(flags, ztos);
3041   __ jcc(Assembler::notEqual, notBool);
<span class="line-modified">3042    if (!is_static) pop_and_check_object(obj);</span>
3043   // ztos (same code as btos)
3044   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
3045   __ push(ztos);
3046   // Rewrite bytecode to be faster
3047   if (!is_static &amp;&amp; rc == may_rewrite) {
3048     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3049     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3050   }
3051   __ jmp(Done);
3052 
3053   __ bind(notBool);
3054   __ cmpl(flags, atos);
3055   __ jcc(Assembler::notEqual, notObj);
3056   // atos
<span class="line-modified">3057   if (!EnableValhalla) {</span>
<span class="line-modified">3058     if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3059     do_oop_load(_masm, field, rax);</span>
<span class="line-modified">3060     __ push(atos);</span>
<span class="line-added">3061     if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-added">3062       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="line-added">3063     }</span>
<span class="line-added">3064     __ jmp(Done);</span>
<span class="line-added">3065   } else {</span>
<span class="line-added">3066     if (is_static) {</span>
<span class="line-added">3067       __ load_heap_oop(rax, field);</span>
<span class="line-added">3068       Label isFlattenable, uninitialized;</span>
<span class="line-added">3069       // Issue below if the static field has not been initialized yet</span>
<span class="line-added">3070       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3071         // Not flattenable case</span>
<span class="line-added">3072         __ push(atos);</span>
<span class="line-added">3073         __ jmp(Done);</span>
<span class="line-added">3074       // Flattenable case, must not return null even if uninitialized</span>
<span class="line-added">3075       __ bind(isFlattenable);</span>
<span class="line-added">3076         __ testptr(rax, rax);</span>
<span class="line-added">3077         __ jcc(Assembler::zero, uninitialized);</span>
<span class="line-added">3078           __ push(atos);</span>
<span class="line-added">3079           __ jmp(Done);</span>
<span class="line-added">3080         __ bind(uninitialized);</span>
<span class="line-added">3081           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3082 #ifdef _LP64</span>
<span class="line-added">3083           Label slow_case, finish;</span>
<span class="line-added">3084           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">3085           __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">3086         __ get_default_value_oop(rcx, off, rax);</span>
<span class="line-added">3087         __ jmp(finish);</span>
<span class="line-added">3088         __ bind(slow_case);</span>
<span class="line-added">3089 #endif // LP64</span>
<span class="line-added">3090           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),</span>
<span class="line-added">3091                  obj, flags2);</span>
<span class="line-added">3092 #ifdef _LP64</span>
<span class="line-added">3093           __ bind(finish);</span>
<span class="line-added">3094 #endif // _LP64</span>
<span class="line-added">3095           __ verify_oop(rax);</span>
<span class="line-added">3096           __ push(atos);</span>
<span class="line-added">3097           __ jmp(Done);</span>
<span class="line-added">3098     } else {</span>
<span class="line-added">3099       Label isFlattened, nonnull, isFlattenable, rewriteFlattenable;</span>
<span class="line-added">3100       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3101         // Non-flattenable field case, also covers the object case</span>
<span class="line-added">3102         pop_and_check_object(obj);</span>
<span class="line-added">3103         __ load_heap_oop(rax, field);</span>
<span class="line-added">3104         __ push(atos);</span>
<span class="line-added">3105         if (rc == may_rewrite) {</span>
<span class="line-added">3106           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);</span>
<span class="line-added">3107         }</span>
<span class="line-added">3108         __ jmp(Done);</span>
<span class="line-added">3109       __ bind(isFlattenable);</span>
<span class="line-added">3110         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="line-added">3111           // Non-flattened field case</span>
<span class="line-added">3112           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere</span>
<span class="line-added">3113           pop_and_check_object(obj);</span>
<span class="line-added">3114           __ push(rax);</span>
<span class="line-added">3115           __ load_heap_oop(rax, field);</span>
<span class="line-added">3116           __ pop(rcx);</span>
<span class="line-added">3117           __ testptr(rax, rax);</span>
<span class="line-added">3118           __ jcc(Assembler::notZero, nonnull);</span>
<span class="line-added">3119             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3120             __ get_value_field_klass(rcx, flags2, rbx);</span>
<span class="line-added">3121             __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="line-added">3122           __ bind(nonnull);</span>
<span class="line-added">3123           __ verify_oop(rax);</span>
<span class="line-added">3124           __ push(atos);</span>
<span class="line-added">3125           __ jmp(rewriteFlattenable);</span>
<span class="line-added">3126         __ bind(isFlattened);</span>
<span class="line-added">3127           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3128           pop_and_check_object(rax);</span>
<span class="line-added">3129           __ read_flattened_field(rcx, flags2, rbx, rax);</span>
<span class="line-added">3130           __ verify_oop(rax);</span>
<span class="line-added">3131           __ push(atos);</span>
<span class="line-added">3132       __ bind(rewriteFlattenable);</span>
<span class="line-added">3133       if (rc == may_rewrite) {</span>
<span class="line-added">3134         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);</span>
<span class="line-added">3135       }</span>
<span class="line-added">3136       __ jmp(Done);</span>
<span class="line-added">3137     }</span>
3138   }

3139 
3140   __ bind(notObj);
<span class="line-added">3141 </span>
<span class="line-added">3142   if (!is_static) pop_and_check_object(obj);</span>
<span class="line-added">3143 </span>
3144   __ cmpl(flags, itos);
3145   __ jcc(Assembler::notEqual, notInt);
3146   // itos
3147   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3148   __ push(itos);
3149   // Rewrite bytecode to be faster
3150   if (!is_static &amp;&amp; rc == may_rewrite) {
3151     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3152   }
3153   __ jmp(Done);
3154 
3155   __ bind(notInt);
3156   __ cmpl(flags, ctos);
3157   __ jcc(Assembler::notEqual, notChar);
3158   // ctos
3159   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3160   __ push(ctos);
3161   // Rewrite bytecode to be faster
3162   if (!is_static &amp;&amp; rc == may_rewrite) {
3163     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
</pre>
<hr />
<pre>
3223 #endif
3224 
3225   __ bind(Done);
3226   // [jk] not needed currently
3227   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3228   //                                              Assembler::LoadStore));
3229 }
3230 
3231 void TemplateTable::getfield(int byte_no) {
3232   getfield_or_static(byte_no, false);
3233 }
3234 
3235 void TemplateTable::nofast_getfield(int byte_no) {
3236   getfield_or_static(byte_no, false, may_not_rewrite);
3237 }
3238 
3239 void TemplateTable::getstatic(int byte_no) {
3240   getfield_or_static(byte_no, true);
3241 }
3242 
<span class="line-added">3243 void TemplateTable::withfield() {</span>
<span class="line-added">3244   transition(vtos, atos);</span>
<span class="line-added">3245 </span>
<span class="line-added">3246   Register cache = LP64_ONLY(c_rarg1) NOT_LP64(rcx);</span>
<span class="line-added">3247   Register index = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>
<span class="line-added">3248 </span>
<span class="line-added">3249   resolve_cache_and_index(f2_byte, cache, index, sizeof(u2));</span>
<span class="line-added">3250 </span>
<span class="line-added">3251   call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache);</span>
<span class="line-added">3252   // new value type is returned in rbx</span>
<span class="line-added">3253   // stack adjustement is returned in rax</span>
<span class="line-added">3254   __ verify_oop(rbx);</span>
<span class="line-added">3255   __ addptr(rsp, rax);</span>
<span class="line-added">3256   __ movptr(rax, rbx);</span>
<span class="line-added">3257 }</span>
3258 
3259 // The registers cache and index expected to be set before call.
3260 // The function may destroy various registers, just not the cache and index registers.
3261 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3262 
3263   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3264   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3265   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3266   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3267 
3268   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3269 
3270   if (JvmtiExport::can_post_field_modification()) {
3271     // Check to see if a field modification watch has been set before
3272     // we take the time to call into the VM.
3273     Label L1;
3274     assert_different_registers(cache, index, rax);
3275     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3276     __ testl(rax, rax);
3277     __ jcc(Assembler::zero, L1);
</pre>
<hr />
<pre>
3333     // c_rarg1: object pointer set up above (NULL if static)
3334     // c_rarg2: cache entry pointer
3335     // c_rarg3: jvalue object on the stack
3336     __ call_VM(noreg,
3337                CAST_FROM_FN_PTR(address,
3338                                 InterpreterRuntime::post_field_modification),
3339                RBX, robj, RCX);
3340     __ get_cache_and_index_at_bcp(cache, index, 1);
3341     __ bind(L1);
3342   }
3343 }
3344 
3345 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3346   transition(vtos, vtos);
3347 
3348   const Register cache = rcx;
3349   const Register index = rdx;
3350   const Register obj   = rcx;
3351   const Register off   = rbx;
3352   const Register flags = rax;
<span class="line-added">3353   const Register flags2 = rdx;</span>
3354 
3355   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3356   jvmti_post_field_mod(cache, index, is_static);
3357   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3358 
3359   // [jk] not needed currently
3360   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3361   //                                              Assembler::StoreStore));
3362 
3363   Label notVolatile, Done;
3364   __ movl(rdx, flags);
3365   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3366   __ andl(rdx, 0x1);
3367 
3368   // Check for volatile store
3369   __ testl(rdx, rdx);
<span class="line-added">3370   __ movl(flags2, flags);</span>
3371   __ jcc(Assembler::zero, notVolatile);
3372 
<span class="line-modified">3373   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
3374   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3375                                                Assembler::StoreStore));
3376   __ jmp(Done);
3377   __ bind(notVolatile);
3378 
<span class="line-modified">3379   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);</span>
3380 
3381   __ bind(Done);
3382 }
3383 
3384 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
<span class="line-modified">3385                                               Register obj, Register off, Register flags, Register flags2) {</span>
3386 
3387   // field addresses
3388   const Address field(obj, off, Address::times_1, 0*wordSize);
3389   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3390 
3391   Label notByte, notBool, notInt, notShort, notChar,
<span class="line-modified">3392         notLong, notFloat, notObj, notValueType;</span>
3393   Label Done;
3394 
3395   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3396 
3397   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3398 
3399   assert(btos == 0, &quot;change code, btos != 0&quot;);
3400   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3401   __ jcc(Assembler::notZero, notByte);
3402 
3403   // btos
3404   {
3405     __ pop(btos);
3406     if (!is_static) pop_and_check_object(obj);
3407     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3408     if (!is_static &amp;&amp; rc == may_rewrite) {
3409       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3410     }
3411     __ jmp(Done);
3412   }
</pre>
<hr />
<pre>
3415   __ cmpl(flags, ztos);
3416   __ jcc(Assembler::notEqual, notBool);
3417 
3418   // ztos
3419   {
3420     __ pop(ztos);
3421     if (!is_static) pop_and_check_object(obj);
3422     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3423     if (!is_static &amp;&amp; rc == may_rewrite) {
3424       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3425     }
3426     __ jmp(Done);
3427   }
3428 
3429   __ bind(notBool);
3430   __ cmpl(flags, atos);
3431   __ jcc(Assembler::notEqual, notObj);
3432 
3433   // atos
3434   {
<span class="line-modified">3435     if (!EnableValhalla) {</span>
<span class="line-modified">3436       __ pop(atos);</span>
<span class="line-modified">3437       if (!is_static) pop_and_check_object(obj);</span>
<span class="line-modified">3438       // Store into the field</span>
<span class="line-modified">3439       do_oop_store(_masm, field, rax);</span>
<span class="line-modified">3440       if (!is_static &amp;&amp; rc == may_rewrite) {</span>
<span class="line-added">3441         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3442       }</span>
<span class="line-added">3443       __ jmp(Done);</span>
<span class="line-added">3444     } else {</span>
<span class="line-added">3445       __ pop(atos);</span>
<span class="line-added">3446       if (is_static) {</span>
<span class="line-added">3447         Label notFlattenable, notBuffered;</span>
<span class="line-added">3448         __ test_field_is_not_flattenable(flags2, rscratch1, notFlattenable);</span>
<span class="line-added">3449         __ null_check(rax);</span>
<span class="line-added">3450         __ bind(notFlattenable);</span>
<span class="line-added">3451         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3452         __ jmp(Done);</span>
<span class="line-added">3453       } else {</span>
<span class="line-added">3454         Label isFlattenable, isFlattened, notBuffered, notBuffered2, rewriteNotFlattenable, rewriteFlattenable;</span>
<span class="line-added">3455         __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-added">3456         // Not flattenable case, covers not flattenable values and objects</span>
<span class="line-added">3457         pop_and_check_object(obj);</span>
<span class="line-added">3458         // Store into the field</span>
<span class="line-added">3459         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3460         __ bind(rewriteNotFlattenable);</span>
<span class="line-added">3461         if (rc == may_rewrite) {</span>
<span class="line-added">3462           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3463         }</span>
<span class="line-added">3464         __ jmp(Done);</span>
<span class="line-added">3465         // Implementation of the flattenable semantic</span>
<span class="line-added">3466         __ bind(isFlattenable);</span>
<span class="line-added">3467         __ null_check(rax);</span>
<span class="line-added">3468         __ test_field_is_flattened(flags2, rscratch1, isFlattened);</span>
<span class="line-added">3469         // Not flattened case</span>
<span class="line-added">3470         pop_and_check_object(obj);</span>
<span class="line-added">3471         // Store into the field</span>
<span class="line-added">3472         do_oop_store(_masm, field, rax);</span>
<span class="line-added">3473         __ jmp(rewriteFlattenable);</span>
<span class="line-added">3474         __ bind(isFlattened);</span>
<span class="line-added">3475         pop_and_check_object(obj);</span>
<span class="line-added">3476         assert_different_registers(rax, rdx, obj, off);</span>
<span class="line-added">3477         __ load_klass(rdx, rax);</span>
<span class="line-added">3478         __ data_for_oop(rax, rax, rdx);</span>
<span class="line-added">3479         __ addptr(obj, off);</span>
<span class="line-added">3480         __ access_value_copy(IN_HEAP, rax, obj, rdx);</span>
<span class="line-added">3481         __ bind(rewriteFlattenable);</span>
<span class="line-added">3482         if (rc == may_rewrite) {</span>
<span class="line-added">3483           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);</span>
<span class="line-added">3484         }</span>
<span class="line-added">3485         __ jmp(Done);</span>
<span class="line-added">3486       }</span>
3487     }

3488   }
3489 
3490   __ bind(notObj);
3491   __ cmpl(flags, itos);
3492   __ jcc(Assembler::notEqual, notInt);
3493 
3494   // itos
3495   {
3496     __ pop(itos);
3497     if (!is_static) pop_and_check_object(obj);
3498     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3499     if (!is_static &amp;&amp; rc == may_rewrite) {
3500       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3501     }
3502     __ jmp(Done);
3503   }
3504 
3505   __ bind(notInt);
3506   __ cmpl(flags, ctos);
3507   __ jcc(Assembler::notEqual, notChar);
</pre>
<hr />
<pre>
3606 }
3607 
3608 void TemplateTable::jvmti_post_fast_field_mod() {
3609 
3610   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3611 
3612   if (JvmtiExport::can_post_field_modification()) {
3613     // Check to see if a field modification watch has been set before
3614     // we take the time to call into the VM.
3615     Label L2;
3616     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3617     __ testl(scratch, scratch);
3618     __ jcc(Assembler::zero, L2);
3619     __ pop_ptr(rbx);                  // copy the object pointer from tos
3620     __ verify_oop(rbx);
3621     __ push_ptr(rbx);                 // put the object pointer back on tos
3622     // Save tos values before call_VM() clobbers them. Since we have
3623     // to do it for every data type, we use the saved values as the
3624     // jvalue object.
3625     switch (bytecode()) {          // load values into the jvalue object
<span class="line-added">3626     case Bytecodes::_fast_qputfield: //fall through</span>
3627     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3628     case Bytecodes::_fast_bputfield: // fall through
3629     case Bytecodes::_fast_zputfield: // fall through
3630     case Bytecodes::_fast_sputfield: // fall through
3631     case Bytecodes::_fast_cputfield: // fall through
3632     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3633     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3634     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3635     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3636 
3637     default:
3638       ShouldNotReachHere();
3639     }
3640     __ mov(scratch, rsp);             // points to jvalue on the stack
3641     // access constant pool cache entry
3642     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3643     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3644     __ verify_oop(rbx);
3645     // rbx: object pointer copied above
3646     // c_rarg2: cache entry pointer
3647     // c_rarg3: jvalue object on the stack
3648     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3649     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3650 
3651     switch (bytecode()) {             // restore tos values
<span class="line-added">3652     case Bytecodes::_fast_qputfield: // fall through</span>
3653     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3654     case Bytecodes::_fast_bputfield: // fall through
3655     case Bytecodes::_fast_zputfield: // fall through
3656     case Bytecodes::_fast_sputfield: // fall through
3657     case Bytecodes::_fast_cputfield: // fall through
3658     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3659     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3660     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3661     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3662     default: break;
3663     }
3664     __ bind(L2);
3665   }
3666 }
3667 
3668 void TemplateTable::fast_storefield(TosState state) {
3669   transition(state, vtos);
3670 
3671   ByteSize base = ConstantPoolCache::base_offset();
3672 
3673   jvmti_post_fast_field_mod();
3674 
3675   // access constant pool cache
3676   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3677 
3678   // test for volatile with rdx but rdx is tos register for lputfield.
3679   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3680                        in_bytes(base +
3681                                 ConstantPoolCacheEntry::flags_offset())));
3682 
3683   // replace index with field offset from cache entry
3684   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3685                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3686 
3687   // [jk] not needed currently
3688   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3689   //                                              Assembler::StoreStore));
3690 
3691   Label notVolatile, Done;
<span class="line-added">3692   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3693     __ movl(rscratch2, rdx);  // saving flags for isFlattened test</span>
<span class="line-added">3694   }</span>
<span class="line-added">3695 </span>
3696   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3697   __ andl(rdx, 0x1);
3698 
3699   // Get object from stack
3700   pop_and_check_object(rcx);
3701 
3702   // field address
3703   const Address field(rcx, rbx, Address::times_1);
3704 
3705   // Check for volatile store
3706   __ testl(rdx, rdx);
3707   __ jcc(Assembler::zero, notVolatile);
3708 
<span class="line-modified">3709   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3710     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="line-added">3711   }</span>
<span class="line-added">3712   fast_storefield_helper(field, rax, rdx);</span>
3713   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3714                                                Assembler::StoreStore));
3715   __ jmp(Done);
3716   __ bind(notVolatile);
3717 
<span class="line-modified">3718   if (bytecode() == Bytecodes::_fast_qputfield) {</span>
<span class="line-added">3719     __ movl(rdx, rscratch2);  // restoring flags for isFlattened test</span>
<span class="line-added">3720   }</span>
<span class="line-added">3721   fast_storefield_helper(field, rax, rdx);</span>
3722 
3723   __ bind(Done);
3724 }
3725 
<span class="line-modified">3726 void TemplateTable::fast_storefield_helper(Address field, Register rax, Register flags) {</span>
3727 
3728   // access field
3729   switch (bytecode()) {
<span class="line-added">3730   case Bytecodes::_fast_qputfield:</span>
<span class="line-added">3731     {</span>
<span class="line-added">3732       Label isFlattened, done;</span>
<span class="line-added">3733       __ null_check(rax);</span>
<span class="line-added">3734       __ test_field_is_flattened(flags, rscratch1, isFlattened);</span>
<span class="line-added">3735       // No Flattened case</span>
<span class="line-added">3736       do_oop_store(_masm, field, rax);</span>
<span class="line-added">3737       __ jmp(done);</span>
<span class="line-added">3738       __ bind(isFlattened);</span>
<span class="line-added">3739       // Flattened case</span>
<span class="line-added">3740       __ load_klass(rdx, rax);</span>
<span class="line-added">3741       __ data_for_oop(rax, rax, rdx);</span>
<span class="line-added">3742       __ lea(rcx, field);</span>
<span class="line-added">3743       __ access_value_copy(IN_HEAP, rax, rcx, rdx);</span>
<span class="line-added">3744       __ bind(done);</span>
<span class="line-added">3745     }</span>
<span class="line-added">3746     break;</span>
3747   case Bytecodes::_fast_aputfield:
<span class="line-modified">3748     {</span>
<span class="line-added">3749       do_oop_store(_masm, field, rax);</span>
<span class="line-added">3750     }</span>
3751     break;
3752   case Bytecodes::_fast_lputfield:
3753 #ifdef _LP64
3754     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3755 #else
3756   __ stop(&quot;should not be rewritten&quot;);
3757 #endif
3758     break;
3759   case Bytecodes::_fast_iputfield:
3760     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3761     break;
3762   case Bytecodes::_fast_zputfield:
3763     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3764     break;
3765   case Bytecodes::_fast_bputfield:
3766     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3767     break;
3768   case Bytecodes::_fast_sputfield:
3769     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3770     break;
</pre>
<hr />
<pre>
3800     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3801     LP64_ONLY(__ mov(c_rarg1, rax));
3802     // c_rarg1: object pointer copied above
3803     // c_rarg2: cache entry pointer
3804     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3805     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3806     __ pop_ptr(rax); // restore object pointer
3807     __ bind(L1);
3808   }
3809 
3810   // access constant pool cache
3811   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3812   // replace index with field offset from cache entry
3813   // [jk] not needed currently
3814   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3815   //                      in_bytes(ConstantPoolCache::base_offset() +
3816   //                               ConstantPoolCacheEntry::flags_offset())));
3817   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3818   // __ andl(rdx, 0x1);
3819   //
<span class="line-modified">3820   __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,</span>
3821                          in_bytes(ConstantPoolCache::base_offset() +
3822                                   ConstantPoolCacheEntry::f2_offset())));
3823 
3824   // rax: object
3825   __ verify_oop(rax);
3826   __ null_check(rax);
<span class="line-modified">3827   Address field(rax, rdx, Address::times_1);</span>
3828 
3829   // access field
3830   switch (bytecode()) {
<span class="line-added">3831   case Bytecodes::_fast_qgetfield:</span>
<span class="line-added">3832     {</span>
<span class="line-added">3833       Label isFlattened, nonnull, Done;</span>
<span class="line-added">3834       __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3835                                    in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3836                                             ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3837       __ test_field_is_flattened(rscratch1, rscratch2, isFlattened);</span>
<span class="line-added">3838         // Non-flattened field case</span>
<span class="line-added">3839         __ load_heap_oop(rax, field);</span>
<span class="line-added">3840         __ testptr(rax, rax);</span>
<span class="line-added">3841         __ jcc(Assembler::notZero, nonnull);</span>
<span class="line-added">3842           __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3843                              in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3844                                       ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3845           __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3846           __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3847                                        in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3848                                                 ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3849           __ get_value_field_klass(rcx, rdx, rbx);</span>
<span class="line-added">3850           __ get_default_value_oop(rbx, rcx, rax);</span>
<span class="line-added">3851         __ bind(nonnull);</span>
<span class="line-added">3852         __ verify_oop(rax);</span>
<span class="line-added">3853         __ jmp(Done);</span>
<span class="line-added">3854       __ bind(isFlattened);</span>
<span class="line-added">3855         __ push(rdx); // save offset</span>
<span class="line-added">3856         __ movl(rdx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3857                            in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3858                                     ConstantPoolCacheEntry::flags_offset())));</span>
<span class="line-added">3859         __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);</span>
<span class="line-added">3860         __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,</span>
<span class="line-added">3861                                      in_bytes(ConstantPoolCache::base_offset() +</span>
<span class="line-added">3862                                               ConstantPoolCacheEntry::f1_offset())));</span>
<span class="line-added">3863         __ pop(rbx); // restore offset</span>
<span class="line-added">3864         __ read_flattened_field(rcx, rdx, rbx, rax);</span>
<span class="line-added">3865       __ bind(Done);</span>
<span class="line-added">3866       __ verify_oop(rax);</span>
<span class="line-added">3867     }</span>
<span class="line-added">3868     break;</span>
3869   case Bytecodes::_fast_agetfield:
3870     do_oop_load(_masm, field, rax);
3871     __ verify_oop(rax);
3872     break;
3873   case Bytecodes::_fast_lgetfield:
3874 #ifdef _LP64
3875     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3876 #else
3877   __ stop(&quot;should not be rewritten&quot;);
3878 #endif
3879     break;
3880   case Bytecodes::_fast_igetfield:
3881     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3882     break;
3883   case Bytecodes::_fast_bgetfield:
3884     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3885     break;
3886   case Bytecodes::_fast_sgetfield:
3887     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3888     break;
</pre>
<hr />
<pre>
4320 
4321   // Note:  rax_callsite is already pushed by prepare_invoke
4322 
4323   // %%% should make a type profile for any invokedynamic that takes a ref argument
4324   // profile this call
4325   __ profile_call(rbcp);
4326   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
4327 
4328   __ verify_oop(rax_callsite);
4329 
4330   __ jump_from_interpreted(rbx_method, rdx);
4331 }
4332 
4333 //-----------------------------------------------------------------------------
4334 // Allocation
4335 
4336 void TemplateTable::_new() {
4337   transition(vtos, atos);
4338   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4339   Label slow_case;
<span class="line-modified">4340   Label done;</span>


4341   Label is_not_value;
4342 
4343   __ get_cpool_and_tags(rcx, rax);
4344 
4345   // Make sure the class we&#39;re about to instantiate has been resolved.
4346   // This is done before loading InstanceKlass to be consistent with the order
4347   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4348   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4349   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
<span class="line-modified">4350   __ jcc(Assembler::notEqual, slow_case);</span>
4351 
4352   // get InstanceKlass
4353   __ load_resolved_klass_at_index(rcx, rcx, rdx);
<span class="line-modified">4354 </span>
<span class="line-added">4355   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);</span>
<span class="line-added">4356   __ jcc(Assembler::notEqual, is_not_value);</span>
<span class="line-added">4357 </span>
<span class="line-added">4358   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_InstantiationError));</span>
<span class="line-added">4359 </span>
<span class="line-added">4360   __ bind(is_not_value);</span>
4361 
4362   // make sure klass is initialized &amp; doesn&#39;t have finalizer

4363   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4364   __ jcc(Assembler::notEqual, slow_case);
4365 
<span class="line-modified">4366   __ allocate_instance(rcx, rax, rdx, rbx, true, slow_case);</span>
<span class="line-modified">4367   __ jmp(done);</span>

















4368 
<span class="line-modified">4369   // slow case</span>
<span class="line-modified">4370   __ bind(slow_case);</span>
4371 
<span class="line-modified">4372   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);</span>
<span class="line-modified">4373   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);</span>




4374 
<span class="line-modified">4375   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4376   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4377   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);</span>
<span class="line-modified">4378    __ verify_oop(rax);</span>











4379 
<span class="line-modified">4380   // continue</span>
<span class="line-modified">4381   __ bind(done);</span>
<span class="line-modified">4382 }</span>





















4383 
<span class="line-modified">4384 void TemplateTable::defaultvalue() {</span>
<span class="line-modified">4385   transition(vtos, atos);</span>






4386 
<span class="line-modified">4387   Label slow_case;</span>
<span class="line-modified">4388   Label done;</span>
<span class="line-modified">4389   Label is_value;</span>













4390 
<span class="line-modified">4391   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);</span>
<span class="line-modified">4392   __ get_cpool_and_tags(rcx, rax);</span>






4393 
<span class="line-modified">4394   // Make sure the class we&#39;re about to instantiate has been resolved.</span>
<span class="line-modified">4395   // This is done before loading InstanceKlass to be consistent with the order</span>
<span class="line-added">4396   // how Constant Pool is updated (see ConstantPool::klass_at_put)</span>
<span class="line-added">4397   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();</span>
<span class="line-added">4398   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);</span>
<span class="line-added">4399   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">4400 </span>
<span class="line-added">4401   // get InstanceKlass</span>
<span class="line-added">4402   __ load_resolved_klass_at_index(rcx, rcx, rdx);</span>
<span class="line-added">4403 </span>
<span class="line-added">4404   __ cmpb(Address(rcx, InstanceKlass::kind_offset()), InstanceKlass::_kind_inline_type);</span>
<span class="line-added">4405   __ jcc(Assembler::equal, is_value);</span>
<span class="line-added">4406 </span>
<span class="line-added">4407   // in the future, defaultvalue will just return null instead of throwing an exception</span>
<span class="line-added">4408   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeError));</span>
<span class="line-added">4409 </span>
<span class="line-added">4410   __ bind(is_value);</span>
<span class="line-added">4411 </span>
<span class="line-added">4412   // make sure klass is fully initialized</span>
<span class="line-added">4413   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">4414   __ jcc(Assembler::notEqual, slow_case);</span>
<span class="line-added">4415 </span>
<span class="line-added">4416   // have a resolved ValueKlass in rcx, return the default value oop from it</span>
<span class="line-added">4417   __ get_default_value_oop(rcx, rdx, rax);</span>
<span class="line-added">4418   __ jmp(done);</span>
4419 
<span class="line-modified">4420   __ bind(slow_case);</span>



4421 
4422   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4423   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4424 
<span class="line-modified">4425   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);</span>
<span class="line-modified">4426   __ get_constant_pool(rarg1);</span>
<span class="line-modified">4427 </span>
<span class="line-added">4428   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::defaultvalue),</span>
4429       rarg1, rarg2);
4430 
<span class="line-modified">4431   __ bind(done);</span>
4432   __ verify_oop(rax);
4433 }
4434 
4435 void TemplateTable::newarray() {
4436   transition(itos, atos);
4437   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4438   __ load_unsigned_byte(rarg1, at_bcp(1));
4439   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4440           rarg1, rax);
4441 }
4442 
4443 void TemplateTable::anewarray() {
4444   transition(itos, atos);
4445 
4446   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4447   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4448 
4449   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4450   __ get_constant_pool(rarg1);
4451   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4452           rarg1, rarg2, rax);
4453 }
4454 
4455 void TemplateTable::arraylength() {
4456   transition(atos, itos);
4457   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4458   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4459 }
4460 
4461 void TemplateTable::checkcast() {
4462   transition(atos, atos);
4463   Label done, is_null, ok_is_subtype, quicked, resolved;
4464   __ testptr(rax, rax); // object is in rax
4465   __ jcc(Assembler::zero, is_null);
4466 
4467   // Get cpool &amp; tags index
4468   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4469   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4470   // See if bytecode has already been quicked
<span class="line-modified">4471   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="line-modified">4472       Address::times_1,</span>
<span class="line-modified">4473       Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-modified">4474   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4475   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
4476   __ jcc(Assembler::equal, quicked);
4477   __ push(atos); // save receiver for result, and for GC
4478   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4479 
4480   // vm_result_2 has metadata result
4481 #ifndef _LP64
4482   // borrow rdi from locals
4483   __ get_thread(rdi);
4484   __ get_vm_result_2(rax, rdi);
4485   __ restore_locals();
4486 #else
4487   __ get_vm_result_2(rax, r15_thread);
4488 #endif
4489 
4490   __ pop_ptr(rdx); // restore receiver
4491   __ jmpb(resolved);
4492 
4493   // Get superklass in rax and subklass in rbx
4494   __ bind(quicked);
4495   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4496   __ load_resolved_klass_at_index(rax, rcx, rbx);
4497 
4498   __ bind(resolved);
4499   __ load_klass(rbx, rdx);
4500 
4501   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4502   // Superklass in rax.  Subklass in rbx.
4503   __ gen_subtype_check(rbx, ok_is_subtype);
4504 
4505   // Come here on failure
4506   __ push_ptr(rdx);
4507   // object is at TOS
4508   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4509 
4510   // Come here on success
4511   __ bind(ok_is_subtype);
4512   __ mov(rax, rdx); // Restore object in rdx
<span class="line-added">4513   __ jmp(done);</span>
<span class="line-added">4514 </span>
<span class="line-added">4515   __ bind(is_null);</span>
4516 
4517   // Collect counts on whether this check-cast sees NULLs a lot or not.
4518   if (ProfileInterpreter) {
<span class="line-modified">4519     __ profile_null_seen(rcx);</span>
<span class="line-modified">4520   }</span>
<span class="line-modified">4521 </span>
<span class="line-modified">4522   if (EnableValhalla) {</span>
<span class="line-added">4523     // Get cpool &amp; tags index</span>
<span class="line-added">4524     __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array</span>
<span class="line-added">4525     __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index</span>
<span class="line-added">4526     // See if CP entry is a Q-descriptor</span>
<span class="line-added">4527     __ movzbl(rcx, Address(rdx, rbx,</span>
<span class="line-added">4528         Address::times_1,</span>
<span class="line-added">4529         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-added">4530     __ andl (rcx, JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4531     __ cmpl(rcx, JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4532     __ jcc(Assembler::notEqual, done);</span>
<span class="line-added">4533     __ jump(ExternalAddress(Interpreter::_throw_NullPointerException_entry));</span>
4534   }
4535 
4536   __ bind(done);
4537 }
4538 
4539 void TemplateTable::instanceof() {
4540   transition(atos, itos);
4541   Label done, is_null, ok_is_subtype, quicked, resolved;
4542   __ testptr(rax, rax);
4543   __ jcc(Assembler::zero, is_null);
4544 
4545   // Get cpool &amp; tags index
4546   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4547   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4548   // See if bytecode has already been quicked
<span class="line-modified">4549   __ movzbl(rdx, Address(rdx, rbx,</span>
<span class="line-modified">4550         Address::times_1,</span>
<span class="line-modified">4551         Array&lt;u1&gt;::base_offset_in_bytes()));</span>
<span class="line-modified">4552   __ andl (rdx, ~JVM_CONSTANT_QDescBit);</span>
<span class="line-added">4553   __ cmpl(rdx, JVM_CONSTANT_Class);</span>
4554   __ jcc(Assembler::equal, quicked);
4555 
4556   __ push(atos); // save receiver for result, and for GC
4557   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4558   // vm_result_2 has metadata result
4559 
4560 #ifndef _LP64
4561   // borrow rdi from locals
4562   __ get_thread(rdi);
4563   __ get_vm_result_2(rax, rdi);
4564   __ restore_locals();
4565 #else
4566   __ get_vm_result_2(rax, r15_thread);
4567 #endif
4568 
4569   __ pop_ptr(rdx); // restore receiver
4570   __ verify_oop(rdx);
4571   __ load_klass(rdx, rdx);
4572   __ jmpb(resolved);
4573 
</pre>
<hr />
<pre>
4585   // Come here on failure
4586   __ xorl(rax, rax);
4587   __ jmpb(done);
4588   // Come here on success
4589   __ bind(ok_is_subtype);
4590   __ movl(rax, 1);
4591 
4592   // Collect counts on whether this test sees NULLs a lot or not.
4593   if (ProfileInterpreter) {
4594     __ jmp(done);
4595     __ bind(is_null);
4596     __ profile_null_seen(rcx);
4597   } else {
4598     __ bind(is_null);   // same as &#39;done&#39;
4599   }
4600   __ bind(done);
4601   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4602   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4603 }
4604 

4605 //----------------------------------------------------------------------------------------------------
4606 // Breakpoints
4607 void TemplateTable::_breakpoint() {
4608   // Note: We get here even if we are single stepping..
4609   // jbug insists on setting breakpoints at every bytecode
4610   // even if we are in single step mode.
4611 
4612   transition(vtos, vtos);
4613 
4614   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4615 
4616   // get the unpatched byte code
4617   __ get_method(rarg);
4618   __ call_VM(noreg,
4619              CAST_FROM_FN_PTR(address,
4620                               InterpreterRuntime::get_original_bytecode_at),
4621              rarg, rbcp);
4622   __ mov(rbx, rax);  // why?
4623 
4624   // post the breakpoint event
</pre>
<hr />
<pre>
4648 //
4649 // Stack layout:
4650 //
4651 // [expressions  ] &lt;--- rsp               = expression stack top
4652 // ..
4653 // [expressions  ]
4654 // [monitor entry] &lt;--- monitor block top = expression stack bot
4655 // ..
4656 // [monitor entry]
4657 // [frame data   ] &lt;--- monitor block bot
4658 // ...
4659 // [saved rbp    ] &lt;--- rbp
4660 void TemplateTable::monitorenter() {
4661   transition(atos, vtos);
4662 
4663   // check for NULL object
4664   __ null_check(rax);
4665 
4666   __ resolve(IS_NOT_NULL, rax);
4667 
<span class="line-added">4668   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">4669   Label has_identity;</span>
<span class="line-added">4670   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">4671   __ andptr(rbx, is_value_mask);</span>
<span class="line-added">4672   __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">4673   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="line-added">4674   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="line-added">4675                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="line-added">4676   __ should_not_reach_here();</span>
<span class="line-added">4677   __ bind(has_identity);</span>
<span class="line-added">4678 </span>
4679   const Address monitor_block_top(
4680         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4681   const Address monitor_block_bot(
4682         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4683   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4684 
4685   Label allocated;
4686 
4687   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4688   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4689   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4690 
4691   // initialize entry pointer
4692   __ xorl(rmon, rmon); // points to free slot or NULL
4693 
4694   // find a free slot in the monitor block (result in rmon)
4695   {
4696     Label entry, loop, exit;
4697     __ movptr(rtop, monitor_block_top); // points to current entry,
4698                                         // starting with top-most entry
</pre>
<hr />
<pre>
4758   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4759   __ lock_object(rmon);
4760 
4761   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4762   __ save_bcp();  // in case of exception
4763   __ generate_stack_overflow_check(0);
4764 
4765   // The bcp has already been incremented. Just need to dispatch to
4766   // next instruction.
4767   __ dispatch_next(vtos);
4768 }
4769 
4770 void TemplateTable::monitorexit() {
4771   transition(atos, vtos);
4772 
4773   // check for NULL object
4774   __ null_check(rax);
4775 
4776   __ resolve(IS_NOT_NULL, rax);
4777 
<span class="line-added">4778   const int is_value_mask = markWord::always_locked_pattern;</span>
<span class="line-added">4779   Label has_identity;</span>
<span class="line-added">4780   __ movptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">4781   __ andptr(rbx, is_value_mask);</span>
<span class="line-added">4782   __ cmpl(rbx, is_value_mask);</span>
<span class="line-added">4783   __ jcc(Assembler::notEqual, has_identity);</span>
<span class="line-added">4784   __ call_VM(noreg, CAST_FROM_FN_PTR(address,</span>
<span class="line-added">4785                      InterpreterRuntime::throw_illegal_monitor_state_exception));</span>
<span class="line-added">4786   __ should_not_reach_here();</span>
<span class="line-added">4787   __ bind(has_identity);</span>
<span class="line-added">4788 </span>
4789   const Address monitor_block_top(
4790         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4791   const Address monitor_block_bot(
4792         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4793   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4794 
4795   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4796   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4797 
4798   Label found;
4799 
4800   // find matching slot
4801   {
4802     Label entry, loop;
4803     __ movptr(rtop, monitor_block_top); // points to current entry,
4804                                         // starting with top-most entry
4805     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4806                                         // of monitor block
4807     __ jmpb(entry);
4808 
</pre>
</td>
</tr>
</table>
<center><a href="../aarch64/stubGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/bytecodeAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
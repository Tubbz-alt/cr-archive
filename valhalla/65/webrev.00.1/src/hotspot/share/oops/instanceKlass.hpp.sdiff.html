<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;

  29 #include &quot;memory/referenceType.hpp&quot;
  30 #include &quot;oops/annotations.hpp&quot;
  31 #include &quot;oops/constMethod.hpp&quot;
  32 #include &quot;oops/fieldInfo.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/klassVtable.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;utilities/accessFlags.hpp&quot;
  38 #include &quot;utilities/align.hpp&quot;
  39 #include &quot;utilities/macros.hpp&quot;
  40 #if INCLUDE_JFR
  41 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  42 #endif
  43 
  44 class RecordComponent;
  45 
  46 // An InstanceKlass is the VM level representation of a Java class.
  47 // It contains all information needed for at class at execution runtime.
  48 
  49 //  InstanceKlass embedded field layout (after declared fields):
  50 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  51 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  52 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  53 //      indicating where oops are located in instances of this klass.
  54 //    [EMBEDDED implementor of the interface] only exist for interface
  55 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  56 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true

  57 
  58 
  59 // forward declaration for class -- see below for definition
  60 #if INCLUDE_JVMTI
  61 class BreakpointInfo;
  62 #endif
  63 class ClassFileParser;
  64 class ClassFileStream;
  65 class KlassDepChange;
  66 class DependencyContext;
  67 class fieldDescriptor;
  68 class jniIdMapBase;
  69 class JNIid;
  70 class JvmtiCachedClassFieldMap;
  71 class nmethodBucket;
  72 class OopMapCache;

  73 class InterpreterOopMap;
  74 class PackageEntry;
  75 class ModuleEntry;
  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
</pre>
<hr />
<pre>
 115     return another_offset == end_offset();
 116   }
 117 
 118   // sizeof(OopMapBlock) in words.
 119   static const int size_in_words() {
 120     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 121       LogBytesPerWord;
 122   }
 123 
 124   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 125     return a-&gt;offset() - b-&gt;offset();
 126   }
 127 
 128  private:
 129   int  _offset;
 130   uint _count;
 131 };
 132 
 133 struct JvmtiCachedClassFileData;
 134 























 135 class InstanceKlass: public Klass {
 136   friend class VMStructs;
 137   friend class JVMCIVMStructs;
 138   friend class ClassFileParser;
 139   friend class CompileReplay;

 140 
 141  public:
 142   static const KlassID ID = InstanceKlassID;
 143 
 144  protected:
 145   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 146 
 147  public:
 148   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 149 
 150   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 151   // of the class loading &amp; initialization procedure, and the use of the states.
 152   enum ClassState {
 153     allocated,                          // allocated (but not yet linked)
 154     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 155     linked,                             // successfully linked/verified (but not initialized yet)
 156     being_initialized,                  // currently running class initializer
<span class="line-modified"> 157     fully_initialized,                  // initialized (successfull final state)</span>
 158     initialization_error                // error happened during initialization
 159   };
 160 
 161  private:
 162   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 163 
 164  protected:
 165   // If you add a new field that points to any metaspace object, you
 166   // must add this field to InstanceKlass::metaspace_pointers_do().
 167 
 168   // Annotations for this class
 169   Annotations*    _annotations;
 170   // Package this class is defined in
 171   PackageEntry*   _package_entry;
 172   // Array classes holding elements of this class.
 173   Klass* volatile _array_klasses;
 174   // Constant pool for this class.
 175   ConstantPool* _constants;
 176   // The InnerClasses attribute and EnclosingMethod attribute. The
 177   // _inner_classes is an array of shorts. If the class has InnerClasses
</pre>
<hr />
<pre>
 181   // attribute. If the EnclosingMethod attribute exists, it occupies the
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // Resolved nest-host klass: either true nest-host or self if we are not
 195   // nested, or an error occurred resolving or validating the nominated
 196   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 197   // relationships.
 198   // By always being set it makes nest-member access checks simpler.
 199   InstanceKlass* _nest_host;
 200 


 201   // The contents of the Record attribute.
 202   Array&lt;RecordComponent*&gt;* _record_components;
 203 
 204   // the source debug extension for this klass, NULL if not specified.
 205   // Specified as UTF-8 string without terminating zero byte in the classfile,
 206   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 207   const char*     _source_debug_extension;
 208 
 209   // Number of heapOopSize words used by non-static fields in this klass
 210   // (including inherited fields but after header_size()).
 211   int             _nonstatic_field_size;
 212   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 213 
 214   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 215   int             _itable_len;           // length of Java itable (in words)
 216 
 217   // The NestHost attribute. The class info index for the class
 218   // that is the nest-host of this class. This data has not been validated.
 219   u2              _nest_host_index;
 220   u2              _this_class_index;              // constant pool entry
 221 
 222   u2              _static_oop_field_count;// number of static oop fields in this klass
 223   u2              _java_fields_count;    // The number of declared Java fields
 224 
 225   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 226 
 227   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 228   // _misc_flags.
 229   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 230 
 231   // Class states are defined as ClassState (see above).
 232   // Place the _init_state here to utilize the unused 2-byte after
 233   // _idnum_allocated_count.
 234   u1              _init_state;                    // state of class
 235 
<span class="line-modified"> 236   // This can be used to quickly discriminate among the four kinds of</span>
 237   // InstanceKlass. This should be an enum (?)
 238   static const unsigned _kind_other        = 0; // concrete InstanceKlass
 239   static const unsigned _kind_reference    = 1; // InstanceRefKlass
 240   static const unsigned _kind_class_loader = 2; // InstanceClassLoaderKlass
 241   static const unsigned _kind_mirror       = 3; // InstanceMirrorKlass

 242 
 243   u1              _reference_type;                // reference type
 244   u1              _kind;                          // kind of InstanceKlass
 245 
 246   enum {
 247     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.
 248     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops
 249     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification
 250     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field
 251     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation
 252     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods
 253     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods
 254     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined
 255     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 256                                                          // code source was found to be matching the value recorded by AOT.
 257     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class
 258     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader
 259     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader
 260     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader
 261     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class
 262     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition
<span class="line-modified"> 263     _misc_has_contended_annotations           = 1 &lt;&lt; 15  // has @Contended annotation</span>







 264   };
 265   u2 shared_loader_type_bits() const {
 266     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 267   }
<span class="line-modified"> 268   u2              _misc_flags;           // There is more space in access_flags for more flags.</span>
 269 
 270   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 271   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 272   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 273   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 274   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 275   uint64_t        volatile _dep_context_last_cleaned;
 276   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 277 #if INCLUDE_JVMTI
 278   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 279   // Linked instanceKlasses of previous versions
 280   InstanceKlass* _previous_versions;
 281   // JVMTI fields can be moved to their own structure - see 6315920
 282   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 283   JvmtiCachedClassFileData* _cached_class_file;
 284 #endif
 285 
 286 #if INCLUDE_JVMTI
 287   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 288 #endif
</pre>
<hr />
<pre>
 300   // Int array containing the original order of method in the class file (for JVMTI).
 301   Array&lt;int&gt;*     _method_ordering;
 302   // Int array containing the vtable_indices for default_methods
 303   // offset matches _default_methods offset
 304   Array&lt;int&gt;*     _default_vtable_indices;
 305 
 306   // Instance and static variable information, starts with 6-tuples of shorts
 307   // [access, name index, sig index, initval index, low_offset, high_offset]
 308   // for all fields, followed by the generic signature data at the end of
 309   // the array. Only fields with generic signature attributes have the generic
 310   // signature data set in the array. The fields array looks like following:
 311   //
 312   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 313   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 314   //      ...
 315   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 316   //     [generic signature index]
 317   //     [generic signature index]
 318   //     ...
 319   Array&lt;u2&gt;*      _fields;



 320 
 321   // embedded Java vtable follows here
 322   // embedded Java itables follows here
 323   // embedded static fields follows here
 324   // embedded nonstatic oop-map blocks follows here
 325   // embedded implementor of this interface follows here
 326   //   The embedded implementor only exists if the current klass is an
 327   //   iterface. The possible values of the implementor fall into following
 328   //   three cases:
 329   //     NULL: no implementor.
 330   //     A Klass* that&#39;s not itself: one implementor.
 331   //     Itself: more than one implementors.
 332   // embedded unsafe_anonymous_host klass follows here
 333   //   The embedded host klass only exists in an unsafe anonymous class for
 334   //   dynamic language support (JSR 292 enabled). The host class grants
 335   //   its access privileges to this class also. The host class is either
 336   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 337   //   or an anonymous class loaded through normal classloading does not
 338   //   have this embedded field.
 339   //
</pre>
<hr />
<pre>
 358     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 359   }
 360 
 361   void clear_shared_class_loader_type() {
 362     _misc_flags &amp;= ~shared_loader_type_bits();
 363   }
 364 
 365   void set_shared_class_loader_type(s2 loader_type);
 366 
 367   bool has_nonstatic_fields() const        {
 368     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 369   }
 370   void set_has_nonstatic_fields(bool b)    {
 371     if (b) {
 372       _misc_flags |= _misc_has_nonstatic_fields;
 373     } else {
 374       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 375     }
 376   }
 377 

































































 378   // field sizes
 379   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 380   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 381 
 382   int static_field_size() const            { return _static_field_size; }
 383   void set_static_field_size(int size)     { _static_field_size = size; }
 384 
 385   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 386   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 387 
 388   // Java itable
 389   int  itable_length() const               { return _itable_len; }
 390   void set_itable_length(int len)          { _itable_len = len; }
 391 
 392   // array klasses
 393   Klass* array_klasses() const             { return _array_klasses; }
 394   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 395   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 396   inline void release_set_array_klasses(Klass* k); // store with release semantics
 397 
</pre>
<hr />
<pre>
 420   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 421   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 422     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 423     _local_interfaces = a; }
 424 
 425   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 426   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 427     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 428     _transitive_interfaces = a;
 429   }
 430 
 431  private:
 432   friend class fieldDescriptor;
 433   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 434 
 435  public:
 436   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 437   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 438   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 439   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }


 440 
 441   // Number of Java declared fields
 442   int java_fields_count() const           { return (int)_java_fields_count; }
 443 
 444   Array&lt;u2&gt;* fields() const            { return _fields; }
 445   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 446     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 447     _fields = f;
 448     _java_fields_count = java_fields_count;
 449   }
 450 
 451   // inner classes
 452   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 453   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 454 
 455   // nest members
 456   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 457   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 458 
 459   // nest-host index
</pre>
<hr />
<pre>
 540   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 541   ClassState  init_state()                 { return (ClassState)_init_state; }
 542   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 543 
 544   // defineClass specified verification
 545   bool should_verify_class() const         {
 546     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 547   }
 548   void set_should_verify_class(bool value) {
 549     if (value) {
 550       _misc_flags |= _misc_should_verify_class;
 551     } else {
 552       _misc_flags &amp;= ~_misc_should_verify_class;
 553     }
 554   }
 555 
 556   // marking
 557   bool is_marked_dependent() const         { return _is_marked_dependent; }
 558   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 559 




 560   // initialization (virtuals from Klass)
 561   bool should_be_initialized() const;  // means that initialize should be called
 562   void initialize(TRAPS);
 563   void link_class(TRAPS);
 564   bool link_class_or_fail(TRAPS); // returns false on failure
 565   void rewrite_class(TRAPS);
 566   void link_methods(TRAPS);
 567   Method* class_initializer() const;
 568 
 569   // set the class to initialized if no static initializer is present
 570   void eager_initialize(Thread *thread);
 571 
 572   // reference type
 573   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 574   void set_reference_type(ReferenceType t) {
 575     assert(t == (u1)t, &quot;overflow&quot;);
 576     _reference_type = (u1)t;
 577   }
 578 
 579   // this class cp index
</pre>
<hr />
<pre>
 739     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 740   }
 741   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 742   void set_nonstatic_oop_map_size(int words) {
 743     _nonstatic_oop_map_size = words;
 744   }
 745 
 746   bool has_contended_annotations() const {
 747     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 748   }
 749   void set_has_contended_annotations(bool value)  {
 750     if (value) {
 751       _misc_flags |= _misc_has_contended_annotations;
 752     } else {
 753       _misc_flags &amp;= ~_misc_has_contended_annotations;
 754     }
 755   }
 756 
 757 #if INCLUDE_JVMTI
 758   // Redefinition locking.  Class can only be redefined by one thread at a time.

 759   bool is_being_redefined() const          {
<span class="line-modified"> 760     return ((_misc_flags &amp; _misc_is_being_redefined) != 0);</span>
 761   }
 762   void set_is_being_redefined(bool value)  {
 763     if (value) {
 764       _misc_flags |= _misc_is_being_redefined;
 765     } else {
 766       _misc_flags &amp;= ~_misc_is_being_redefined;
 767     }
 768   }
 769 
 770   // RedefineClasses() support for previous versions:
 771   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 772   void purge_previous_version_list();
 773 
 774   InstanceKlass* previous_versions() const { return _previous_versions; }
 775 #else
 776   InstanceKlass* previous_versions() const { return NULL; }
 777 #endif
 778 
 779   InstanceKlass* get_klass_version(int version) {
 780     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
</pre>
<hr />
<pre>
 825   void set_has_resolved_methods() {
 826     _misc_flags |= _misc_has_resolved_methods;
 827   }
 828 private:
 829 
 830   void set_kind(unsigned kind) {
 831     _kind = (u1)kind;
 832   }
 833 
 834   bool is_kind(unsigned desired) const {
 835     return _kind == (u1)desired;
 836   }
 837 
 838 public:
 839 
 840   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 841   bool is_other_instance_klass() const        { return is_kind(_kind_other); }
 842   bool is_reference_instance_klass() const    { return is_kind(_kind_reference); }
 843   bool is_mirror_instance_klass() const       { return is_kind(_kind_mirror); }
 844   bool is_class_loader_instance_klass() const { return is_kind(_kind_class_loader); }

 845 
 846 #if INCLUDE_JVMTI
 847 
 848   void init_previous_versions() {
 849     _previous_versions = NULL;
 850   }
 851 
 852  private:
 853   static bool  _has_previous_versions;
 854  public:
 855   static void purge_previous_versions(InstanceKlass* ik) {
 856     if (ik-&gt;has_been_redefined()) {
 857       ik-&gt;purge_previous_version_list();
 858     }
 859   }
 860 
 861   static bool has_previous_versions_and_reset();
 862   static bool has_previous_versions() { return _has_previous_versions; }
 863 
 864   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
 993 
 994   // On-stack replacement support
 995   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
 996   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
 997   void add_osr_nmethod(nmethod* n);
 998   bool remove_osr_nmethod(nmethod* n);
 999   int mark_osr_nmethods(const Method* m);
1000   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1001 
1002 #if INCLUDE_JVMTI
1003   // Breakpoint support (see methods on Method* for details)
1004   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1005   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1006 #endif
1007 
1008   // support for stub routines
1009   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1010   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1011   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1012 



1013   // subclass/subinterface checks
1014   bool implements_interface(Klass* k) const;
1015   bool is_same_or_direct_interface(Klass* k) const;
1016 
1017 #ifdef ASSERT
1018   // check whether this class or one of its superclasses was redefined
1019   bool has_redefined_this_or_super() const;
1020 #endif
1021 
1022   // Access to the implementor of an interface.
1023   Klass* implementor() const;
1024   void set_implementor(Klass* k);
1025   int  nof_implementors() const;
1026   void add_implementor(Klass* k);  // k is a new class that implements this interface
1027   void init_implementor();           // initialize
1028 
1029   // link this class into the implementors list of every interface it implements
1030   void process_interfaces(Thread *thread);
1031 
1032   // virtual operations from Klass
1033   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1034                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1035   bool can_be_primary_super_slow() const;
1036   int oop_size(oop obj)  const             { return size_helper(); }
1037   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1038   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1039   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1040 
1041   // Iterators
1042   void do_local_static_fields(FieldClosure* cl);
1043   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1044   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1045 
1046   void methods_do(void f(Method* method));
<span class="line-modified">1047   void array_klasses_do(void f(Klass* k));</span>
<span class="line-removed">1048   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);</span>
1049 
1050   static InstanceKlass* cast(Klass* k) {
1051     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1052   }
1053 
1054   static const InstanceKlass* cast(const Klass* k) {
1055     assert(k != NULL, &quot;k should not be null&quot;);
1056     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1057     return static_cast&lt;const InstanceKlass*&gt;(k);
1058   }
1059 
1060   virtual InstanceKlass* java_super() const {
1061     return (super() == NULL) ? NULL : cast(super());
1062   }
1063 
1064   // Sizing (in words)
1065   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1066 
1067   static int size(int vtable_length, int itable_length,
1068                   int nonstatic_oop_map_size,
<span class="line-modified">1069                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {</span>

1070     return align_metadata_size(header_size() +
1071            vtable_length +
1072            itable_length +
1073            nonstatic_oop_map_size +
1074            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1075            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
<span class="line-modified">1076            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));</span>


1077   }
1078   int size() const                    { return size(vtable_length(),
1079                                                itable_length(),
1080                                                nonstatic_oop_map_size(),
1081                                                is_interface(),
1082                                                is_unsafe_anonymous(),
<span class="line-modified">1083                                                has_stored_fingerprint());</span>


1084   }
1085 
1086   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1087   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1088 
1089   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1090 
1091   oop static_field_base_raw() { return java_mirror(); }
1092 


1093   OopMapBlock* start_of_nonstatic_oop_maps() const {
1094     return (OopMapBlock*)(start_of_itable() + itable_length());
1095   }
1096 
1097   Klass** end_of_nonstatic_oop_maps() const {
1098     return (Klass**)(start_of_nonstatic_oop_maps() +
1099                      nonstatic_oop_map_count());
1100   }
1101 
1102   Klass* volatile* adr_implementor() const {
1103     if (is_interface()) {
1104       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1105     } else {
1106       return NULL;
1107     }
1108   };
1109 
1110   InstanceKlass** adr_unsafe_anonymous_host() const {
1111     if (is_unsafe_anonymous()) {
1112       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
</pre>
<hr />
<pre>
1121   }
1122 
1123   address adr_fingerprint() const {
1124     if (has_stored_fingerprint()) {
1125       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1126       if (adr_host != NULL) {
1127         return (address)(adr_host + 1);
1128       }
1129 
1130       Klass* volatile* adr_impl = adr_implementor();
1131       if (adr_impl != NULL) {
1132         return (address)(adr_impl + 1);
1133       }
1134 
1135       return (address)end_of_nonstatic_oop_maps();
1136     } else {
1137       return NULL;
1138     }
1139   }
1140 













































1141   // Use this to return the size of an instance in heap words:
<span class="line-modified">1142   int size_helper() const {</span>
1143     return layout_helper_to_size_helper(layout_helper());
1144   }
1145 
1146   // This bit is initialized in classFileParser.cpp.
1147   // It is false under any of the following conditions:
1148   //  - the class is abstract (including any interface)
1149   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1150   //  - the class size is larger than FastAllocateSizeLimit
1151   //  - the class is java/lang/Class, which cannot be allocated directly
1152   bool can_be_fastpath_allocated() const {
1153     return !layout_helper_needs_slow_path(layout_helper());
1154   }
1155 
1156   // Java itable
1157   klassItable itable() const;        // return klassItable wrapper
1158   Method* method_at_itable(Klass* holder, int index, TRAPS);
1159 
1160 #if INCLUDE_JVMTI
1161   void adjust_default_methods(bool* trace_name_printed);
1162 #endif // INCLUDE_JVMTI
</pre>
<hr />
<pre>
1259   inline jmethodID* methods_jmethod_ids_acquire() const;
1260   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1261 
1262   // Lock during initialization
1263 public:
1264   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1265   // Must be one per class and it has to be a VM internal object so java code
1266   // cannot lock it (like the mirror).
1267   // It has to be an object not a Mutex because it&#39;s held through java calls.
1268   oop init_lock() const;
1269 private:
1270   void fence_and_clear_init_lock();
1271 
1272   bool link_class_impl                           (TRAPS);
1273   bool verify_code                               (TRAPS);
1274   void initialize_impl                           (TRAPS);
1275   void initialize_super_interfaces               (TRAPS);
1276   void eager_initialize_impl                     ();
1277   /* jni_id_for_impl for jfieldID only */
1278   JNIid* jni_id_for_impl                         (int offset);
<span class="line-modified">1279 </span>
1280   // Returns the array class for the n&#39;th dimension
<span class="line-modified">1281   Klass* array_klass_impl(bool or_null, int n, TRAPS);</span>
1282 
1283   // Returns the array class with this class as element type
<span class="line-modified">1284   Klass* array_klass_impl(bool or_null, TRAPS);</span>


1285 
1286   // find a local method (returns NULL if not found)
1287   Method* find_method_impl(const Symbol* name,
1288                            const Symbol* signature,
1289                            OverpassLookupMode overpass_mode,
1290                            StaticLookupMode static_mode,
1291                            PrivateLookupMode private_mode) const;
1292 
1293   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1294                                   const Symbol* name,
1295                                   const Symbol* signature,
1296                                   OverpassLookupMode overpass_mode,
1297                                   StaticLookupMode static_mode,
1298                                   PrivateLookupMode private_mode);
1299 
1300   // Free CHeap allocated fields.
1301   void release_C_heap_structures_internal();
1302 
1303 #if INCLUDE_JVMTI
1304   // RedefineClasses support
1305   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1306   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1307 #endif
1308 public:
1309   // CDS support - remove and restore oops from metadata. Oops are not shared.
1310   virtual void remove_unshareable_info();
1311   virtual void remove_java_mirror();
<span class="line-modified">1312   void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1313 
1314   // jvm support
1315   jint compute_modifier_flags(TRAPS) const;
1316 
1317 public:
1318   // JVMTI support
1319   jint jvmti_class_status() const;
1320 
1321   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1322 
1323  public:
1324   // Printing
1325 #ifndef PRODUCT
1326   void print_on(outputStream* st) const;
1327 #endif
1328   void print_value_on(outputStream* st) const;
1329 
1330   void oop_print_value_on(oop obj, outputStream* st);
1331 
1332 #ifndef PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;
<span class="line-added">  29 #include &quot;code/vmreg.hpp&quot;</span>
  30 #include &quot;memory/referenceType.hpp&quot;
  31 #include &quot;oops/annotations.hpp&quot;
  32 #include &quot;oops/constMethod.hpp&quot;
  33 #include &quot;oops/fieldInfo.hpp&quot;
  34 #include &quot;oops/instanceOop.hpp&quot;
  35 #include &quot;oops/klassVtable.hpp&quot;
  36 #include &quot;runtime/handles.hpp&quot;
  37 #include &quot;runtime/os.hpp&quot;
  38 #include &quot;utilities/accessFlags.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
  40 #include &quot;utilities/macros.hpp&quot;
  41 #if INCLUDE_JFR
  42 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  43 #endif
  44 
  45 class RecordComponent;
  46 
  47 // An InstanceKlass is the VM level representation of a Java class.
  48 // It contains all information needed for at class at execution runtime.
  49 
  50 //  InstanceKlass embedded field layout (after declared fields):
  51 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  52 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  53 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  54 //      indicating where oops are located in instances of this klass.
  55 //    [EMBEDDED implementor of the interface] only exist for interface
  56 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  57 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
<span class="line-added">  58 //    [EMBEDDED ValueKlassFixedBlock] only if is a ValueKlass instance</span>
  59 
  60 
  61 // forward declaration for class -- see below for definition
  62 #if INCLUDE_JVMTI
  63 class BreakpointInfo;
  64 #endif
  65 class ClassFileParser;
  66 class ClassFileStream;
  67 class KlassDepChange;
  68 class DependencyContext;
  69 class fieldDescriptor;
  70 class jniIdMapBase;
  71 class JNIid;
  72 class JvmtiCachedClassFieldMap;
  73 class nmethodBucket;
  74 class OopMapCache;
<span class="line-added">  75 class BufferedValueTypeBlob;</span>
  76 class InterpreterOopMap;
  77 class PackageEntry;
  78 class ModuleEntry;
  79 
  80 // This is used in iterators below.
  81 class FieldClosure: public StackObj {
  82 public:
  83   virtual void do_field(fieldDescriptor* fd) = 0;
  84 };
  85 
  86 #ifndef PRODUCT
  87 // Print fields.
  88 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  89 class FieldPrinter: public FieldClosure {
  90    oop _obj;
  91    outputStream* _st;
  92  public:
  93    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  94    void do_field(fieldDescriptor* fd);
  95 };
</pre>
<hr />
<pre>
 118     return another_offset == end_offset();
 119   }
 120 
 121   // sizeof(OopMapBlock) in words.
 122   static const int size_in_words() {
 123     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 124       LogBytesPerWord;
 125   }
 126 
 127   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 128     return a-&gt;offset() - b-&gt;offset();
 129   }
 130 
 131  private:
 132   int  _offset;
 133   uint _count;
 134 };
 135 
 136 struct JvmtiCachedClassFileData;
 137 
<span class="line-added"> 138 class SigEntry;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140 class ValueKlassFixedBlock {</span>
<span class="line-added"> 141   Array&lt;SigEntry&gt;** _extended_sig;</span>
<span class="line-added"> 142   Array&lt;VMRegPair&gt;** _return_regs;</span>
<span class="line-added"> 143   address* _pack_handler;</span>
<span class="line-added"> 144   address* _pack_handler_jobject;</span>
<span class="line-added"> 145   address* _unpack_handler;</span>
<span class="line-added"> 146   int* _default_value_offset;</span>
<span class="line-added"> 147   Klass** _value_array_klass;</span>
<span class="line-added"> 148   int _alignment;</span>
<span class="line-added"> 149   int _first_field_offset;</span>
<span class="line-added"> 150   int _exact_size_in_bytes;</span>
<span class="line-added"> 151 </span>
<span class="line-added"> 152   friend class ValueKlass;</span>
<span class="line-added"> 153 };</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155 class InlineTypes {</span>
<span class="line-added"> 156 public:</span>
<span class="line-added"> 157   u2 _class_info_index;</span>
<span class="line-added"> 158   Symbol* _class_name;</span>
<span class="line-added"> 159 };</span>
<span class="line-added"> 160 </span>
 161 class InstanceKlass: public Klass {
 162   friend class VMStructs;
 163   friend class JVMCIVMStructs;
 164   friend class ClassFileParser;
 165   friend class CompileReplay;
<span class="line-added"> 166   friend class TemplateTable;</span>
 167 
 168  public:
 169   static const KlassID ID = InstanceKlassID;
 170 
 171  protected:
 172   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 173 
 174  public:
 175   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 176 
 177   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 178   // of the class loading &amp; initialization procedure, and the use of the states.
 179   enum ClassState {
 180     allocated,                          // allocated (but not yet linked)
 181     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 182     linked,                             // successfully linked/verified (but not initialized yet)
 183     being_initialized,                  // currently running class initializer
<span class="line-modified"> 184     fully_initialized,                  // initialized (successful final state)</span>
 185     initialization_error                // error happened during initialization
 186   };
 187 
 188  private:
 189   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 190 
 191  protected:
 192   // If you add a new field that points to any metaspace object, you
 193   // must add this field to InstanceKlass::metaspace_pointers_do().
 194 
 195   // Annotations for this class
 196   Annotations*    _annotations;
 197   // Package this class is defined in
 198   PackageEntry*   _package_entry;
 199   // Array classes holding elements of this class.
 200   Klass* volatile _array_klasses;
 201   // Constant pool for this class.
 202   ConstantPool* _constants;
 203   // The InnerClasses attribute and EnclosingMethod attribute. The
 204   // _inner_classes is an array of shorts. If the class has InnerClasses
</pre>
<hr />
<pre>
 208   // attribute. If the EnclosingMethod attribute exists, it occupies the
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
 221   // Resolved nest-host klass: either true nest-host or self if we are not
 222   // nested, or an error occurred resolving or validating the nominated
 223   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 224   // relationships.
 225   // By always being set it makes nest-member access checks simpler.
 226   InstanceKlass* _nest_host;
 227 
<span class="line-added"> 228   Array&lt;InlineTypes&gt;* _inline_types;</span>
<span class="line-added"> 229 </span>
 230   // The contents of the Record attribute.
 231   Array&lt;RecordComponent*&gt;* _record_components;
 232 
 233   // the source debug extension for this klass, NULL if not specified.
 234   // Specified as UTF-8 string without terminating zero byte in the classfile,
 235   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 236   const char*     _source_debug_extension;
 237 
 238   // Number of heapOopSize words used by non-static fields in this klass
 239   // (including inherited fields but after header_size()).
 240   int             _nonstatic_field_size;
 241   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 242 
 243   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 244   int             _itable_len;           // length of Java itable (in words)
 245 
 246   // The NestHost attribute. The class info index for the class
 247   // that is the nest-host of this class. This data has not been validated.
 248   u2              _nest_host_index;
 249   u2              _this_class_index;              // constant pool entry
 250 
 251   u2              _static_oop_field_count;// number of static oop fields in this klass
 252   u2              _java_fields_count;    // The number of declared Java fields
 253 
 254   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 255 
 256   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 257   // _misc_flags.
 258   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 259 
 260   // Class states are defined as ClassState (see above).
 261   // Place the _init_state here to utilize the unused 2-byte after
 262   // _idnum_allocated_count.
 263   u1              _init_state;                    // state of class
 264 
<span class="line-modified"> 265   // This can be used to quickly discriminate among the five kinds of</span>
 266   // InstanceKlass. This should be an enum (?)
 267   static const unsigned _kind_other        = 0; // concrete InstanceKlass
 268   static const unsigned _kind_reference    = 1; // InstanceRefKlass
 269   static const unsigned _kind_class_loader = 2; // InstanceClassLoaderKlass
 270   static const unsigned _kind_mirror       = 3; // InstanceMirrorKlass
<span class="line-added"> 271   static const unsigned _kind_inline_type  = 4; // InlineKlass</span>
 272 
 273   u1              _reference_type;                // reference type
 274   u1              _kind;                          // kind of InstanceKlass
 275 
 276   enum {
 277     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.
 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops
 279     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification
 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field
 281     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation
 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods
 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods
 284     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined
 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 286                                                          // code source was found to be matching the value recorded by AOT.
 287     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class
 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader
 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader
 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader
 291     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class
 292     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition
<span class="line-modified"> 293     _misc_has_contended_annotations           = 1 &lt;&lt; 15,  // has @Contended annotation</span>
<span class="line-added"> 294     _misc_has_inline_fields                   = 1 &lt;&lt; 16, // has inline fields and related embedded section is not empty</span>
<span class="line-added"> 295     _misc_is_empty_inline_type                = 1 &lt;&lt; 17, // empty inline type</span>
<span class="line-added"> 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 18, // loaded/stored in one instruction</span>
<span class="line-added"> 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 19, // implements jl.NonTearable</span>
<span class="line-added"> 298     _misc_invalid_inline_super                = 1 &lt;&lt; 20, // invalid super type for an inline type</span>
<span class="line-added"> 299     _misc_invalid_identity_super              = 1 &lt;&lt; 21, // invalid super type for an identity type</span>
<span class="line-added"> 300     _misc_has_injected_identityObject         = 1 &lt;&lt; 22  // IdentityObject has been injected by the JVM</span>
 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
<span class="line-modified"> 305   u4              _misc_flags;           // There is more space in access_flags for more flags.</span>
 306 
 307   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 308   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 309   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 310   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 311   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 312   uint64_t        volatile _dep_context_last_cleaned;
 313   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 314 #if INCLUDE_JVMTI
 315   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 316   // Linked instanceKlasses of previous versions
 317   InstanceKlass* _previous_versions;
 318   // JVMTI fields can be moved to their own structure - see 6315920
 319   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 320   JvmtiCachedClassFileData* _cached_class_file;
 321 #endif
 322 
 323 #if INCLUDE_JVMTI
 324   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 325 #endif
</pre>
<hr />
<pre>
 337   // Int array containing the original order of method in the class file (for JVMTI).
 338   Array&lt;int&gt;*     _method_ordering;
 339   // Int array containing the vtable_indices for default_methods
 340   // offset matches _default_methods offset
 341   Array&lt;int&gt;*     _default_vtable_indices;
 342 
 343   // Instance and static variable information, starts with 6-tuples of shorts
 344   // [access, name index, sig index, initval index, low_offset, high_offset]
 345   // for all fields, followed by the generic signature data at the end of
 346   // the array. Only fields with generic signature attributes have the generic
 347   // signature data set in the array. The fields array looks like following:
 348   //
 349   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 350   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 351   //      ...
 352   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 353   //     [generic signature index]
 354   //     [generic signature index]
 355   //     ...
 356   Array&lt;u2&gt;*      _fields;
<span class="line-added"> 357   const Klass**   _value_field_klasses; // For &quot;inline class&quot; fields, NULL if none present</span>
<span class="line-added"> 358 </span>
<span class="line-added"> 359   const ValueKlassFixedBlock* _adr_valueklass_fixed_block;</span>
 360 
 361   // embedded Java vtable follows here
 362   // embedded Java itables follows here
 363   // embedded static fields follows here
 364   // embedded nonstatic oop-map blocks follows here
 365   // embedded implementor of this interface follows here
 366   //   The embedded implementor only exists if the current klass is an
 367   //   iterface. The possible values of the implementor fall into following
 368   //   three cases:
 369   //     NULL: no implementor.
 370   //     A Klass* that&#39;s not itself: one implementor.
 371   //     Itself: more than one implementors.
 372   // embedded unsafe_anonymous_host klass follows here
 373   //   The embedded host klass only exists in an unsafe anonymous class for
 374   //   dynamic language support (JSR 292 enabled). The host class grants
 375   //   its access privileges to this class also. The host class is either
 376   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 377   //   or an anonymous class loaded through normal classloading does not
 378   //   have this embedded field.
 379   //
</pre>
<hr />
<pre>
 398     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 399   }
 400 
 401   void clear_shared_class_loader_type() {
 402     _misc_flags &amp;= ~shared_loader_type_bits();
 403   }
 404 
 405   void set_shared_class_loader_type(s2 loader_type);
 406 
 407   bool has_nonstatic_fields() const        {
 408     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 409   }
 410   void set_has_nonstatic_fields(bool b)    {
 411     if (b) {
 412       _misc_flags |= _misc_has_nonstatic_fields;
 413     } else {
 414       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 415     }
 416   }
 417 
<span class="line-added"> 418   bool has_inline_fields() const          {</span>
<span class="line-added"> 419     return (_misc_flags &amp; _misc_has_inline_fields) != 0;</span>
<span class="line-added"> 420   }</span>
<span class="line-added"> 421   void set_has_inline_fields()  {</span>
<span class="line-added"> 422     _misc_flags |= _misc_has_inline_fields;</span>
<span class="line-added"> 423   }</span>
<span class="line-added"> 424 </span>
<span class="line-added"> 425   bool is_empty_inline_type() const {</span>
<span class="line-added"> 426     return (_misc_flags &amp; _misc_is_empty_inline_type) != 0;</span>
<span class="line-added"> 427   }</span>
<span class="line-added"> 428   void set_is_empty_inline_type() {</span>
<span class="line-added"> 429     _misc_flags |= _misc_is_empty_inline_type;</span>
<span class="line-added"> 430   }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432   // Note:  The naturally_atomic property only applies to</span>
<span class="line-added"> 433   // inline classes; it is never true on identity classes.</span>
<span class="line-added"> 434   // The bit is placed on instanceKlass for convenience.</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436   // Query if h/w provides atomic load/store for instances.</span>
<span class="line-added"> 437   bool is_naturally_atomic() const {</span>
<span class="line-added"> 438     return (_misc_flags &amp; _misc_is_naturally_atomic) != 0;</span>
<span class="line-added"> 439   }</span>
<span class="line-added"> 440   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 441   void set_is_naturally_atomic() {</span>
<span class="line-added"> 442     _misc_flags |= _misc_is_naturally_atomic;</span>
<span class="line-added"> 443   }</span>
<span class="line-added"> 444 </span>
<span class="line-added"> 445   // Query if this class implements jl.NonTearable or was</span>
<span class="line-added"> 446   // mentioned in the JVM option AlwaysAtomicValueTypes.</span>
<span class="line-added"> 447   // This bit can occur anywhere, but is only significant</span>
<span class="line-added"> 448   // for inline classes *and* their super types.</span>
<span class="line-added"> 449   // It inherits from supers along with NonTearable.</span>
<span class="line-added"> 450   bool is_declared_atomic() const {</span>
<span class="line-added"> 451     return (_misc_flags &amp; _misc_is_declared_atomic) != 0;</span>
<span class="line-added"> 452   }</span>
<span class="line-added"> 453   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 454   void set_is_declared_atomic() {</span>
<span class="line-added"> 455     _misc_flags |= _misc_is_declared_atomic;</span>
<span class="line-added"> 456   }</span>
<span class="line-added"> 457 </span>
<span class="line-added"> 458   // Query if class is an invalid super class for an inline type.</span>
<span class="line-added"> 459   bool invalid_inline_super() const {</span>
<span class="line-added"> 460     return (_misc_flags &amp; _misc_invalid_inline_super) != 0;</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 463   void set_invalid_inline_super() {</span>
<span class="line-added"> 464     _misc_flags |= _misc_invalid_inline_super;</span>
<span class="line-added"> 465   }</span>
<span class="line-added"> 466   // Query if class is an invalid super class for an identity type.</span>
<span class="line-added"> 467   bool invalid_identity_super() const {</span>
<span class="line-added"> 468     return (_misc_flags &amp; _misc_invalid_identity_super) != 0;</span>
<span class="line-added"> 469   }</span>
<span class="line-added"> 470   // Initialized in the class file parser, not changed later.</span>
<span class="line-added"> 471   void set_invalid_identity_super() {</span>
<span class="line-added"> 472     _misc_flags |= _misc_invalid_identity_super;</span>
<span class="line-added"> 473   }</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475   bool has_injected_identityObject() const {</span>
<span class="line-added"> 476     return (_misc_flags &amp; _misc_has_injected_identityObject);</span>
<span class="line-added"> 477   }</span>
<span class="line-added"> 478 </span>
<span class="line-added"> 479   void set_has_injected_identityObject() {</span>
<span class="line-added"> 480     _misc_flags |= _misc_has_injected_identityObject;</span>
<span class="line-added"> 481   }</span>
<span class="line-added"> 482 </span>
 483   // field sizes
 484   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 485   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 486 
 487   int static_field_size() const            { return _static_field_size; }
 488   void set_static_field_size(int size)     { _static_field_size = size; }
 489 
 490   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 491   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 492 
 493   // Java itable
 494   int  itable_length() const               { return _itable_len; }
 495   void set_itable_length(int len)          { _itable_len = len; }
 496 
 497   // array klasses
 498   Klass* array_klasses() const             { return _array_klasses; }
 499   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 500   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 501   inline void release_set_array_klasses(Klass* k); // store with release semantics
 502 
</pre>
<hr />
<pre>
 525   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 526   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 527     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 528     _local_interfaces = a; }
 529 
 530   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 531   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 532     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 533     _transitive_interfaces = a;
 534   }
 535 
 536  private:
 537   friend class fieldDescriptor;
 538   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 539 
 540  public:
 541   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 542   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 543   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 544   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
<span class="line-added"> 545   bool    field_is_flattened(int index) const { return field(index)-&gt;is_flattened(); }</span>
<span class="line-added"> 546   bool    field_is_flattenable(int index) const { return field(index)-&gt;is_flattenable(); }</span>
 547 
 548   // Number of Java declared fields
 549   int java_fields_count() const           { return (int)_java_fields_count; }
 550 
 551   Array&lt;u2&gt;* fields() const            { return _fields; }
 552   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 553     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 554     _fields = f;
 555     _java_fields_count = java_fields_count;
 556   }
 557 
 558   // inner classes
 559   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 560   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 561 
 562   // nest members
 563   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 564   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 565 
 566   // nest-host index
</pre>
<hr />
<pre>
 647   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 648   ClassState  init_state()                 { return (ClassState)_init_state; }
 649   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 650 
 651   // defineClass specified verification
 652   bool should_verify_class() const         {
 653     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 654   }
 655   void set_should_verify_class(bool value) {
 656     if (value) {
 657       _misc_flags |= _misc_should_verify_class;
 658     } else {
 659       _misc_flags &amp;= ~_misc_should_verify_class;
 660     }
 661   }
 662 
 663   // marking
 664   bool is_marked_dependent() const         { return _is_marked_dependent; }
 665   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 666 
<span class="line-added"> 667   static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }</span>
<span class="line-added"> 668   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }</span>
<span class="line-added"> 669   static u4 misc_flags_is_empty_inline_type() { return _misc_is_empty_inline_type; }</span>
<span class="line-added"> 670 </span>
 671   // initialization (virtuals from Klass)
 672   bool should_be_initialized() const;  // means that initialize should be called
 673   void initialize(TRAPS);
 674   void link_class(TRAPS);
 675   bool link_class_or_fail(TRAPS); // returns false on failure
 676   void rewrite_class(TRAPS);
 677   void link_methods(TRAPS);
 678   Method* class_initializer() const;
 679 
 680   // set the class to initialized if no static initializer is present
 681   void eager_initialize(Thread *thread);
 682 
 683   // reference type
 684   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 685   void set_reference_type(ReferenceType t) {
 686     assert(t == (u1)t, &quot;overflow&quot;);
 687     _reference_type = (u1)t;
 688   }
 689 
 690   // this class cp index
</pre>
<hr />
<pre>
 850     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 851   }
 852   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 853   void set_nonstatic_oop_map_size(int words) {
 854     _nonstatic_oop_map_size = words;
 855   }
 856 
 857   bool has_contended_annotations() const {
 858     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 859   }
 860   void set_has_contended_annotations(bool value)  {
 861     if (value) {
 862       _misc_flags |= _misc_has_contended_annotations;
 863     } else {
 864       _misc_flags &amp;= ~_misc_has_contended_annotations;
 865     }
 866   }
 867 
 868 #if INCLUDE_JVMTI
 869   // Redefinition locking.  Class can only be redefined by one thread at a time.
<span class="line-added"> 870 </span>
 871   bool is_being_redefined() const          {
<span class="line-modified"> 872     return (_misc_flags &amp; _misc_is_being_redefined);</span>
 873   }
 874   void set_is_being_redefined(bool value)  {
 875     if (value) {
 876       _misc_flags |= _misc_is_being_redefined;
 877     } else {
 878       _misc_flags &amp;= ~_misc_is_being_redefined;
 879     }
 880   }
 881 
 882   // RedefineClasses() support for previous versions:
 883   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 884   void purge_previous_version_list();
 885 
 886   InstanceKlass* previous_versions() const { return _previous_versions; }
 887 #else
 888   InstanceKlass* previous_versions() const { return NULL; }
 889 #endif
 890 
 891   InstanceKlass* get_klass_version(int version) {
 892     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
</pre>
<hr />
<pre>
 937   void set_has_resolved_methods() {
 938     _misc_flags |= _misc_has_resolved_methods;
 939   }
 940 private:
 941 
 942   void set_kind(unsigned kind) {
 943     _kind = (u1)kind;
 944   }
 945 
 946   bool is_kind(unsigned desired) const {
 947     return _kind == (u1)desired;
 948   }
 949 
 950 public:
 951 
 952   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 953   bool is_other_instance_klass() const        { return is_kind(_kind_other); }
 954   bool is_reference_instance_klass() const    { return is_kind(_kind_reference); }
 955   bool is_mirror_instance_klass() const       { return is_kind(_kind_mirror); }
 956   bool is_class_loader_instance_klass() const { return is_kind(_kind_class_loader); }
<span class="line-added"> 957   bool is_inline_type_klass()           const { return is_kind(_kind_inline_type); }</span>
 958 
 959 #if INCLUDE_JVMTI
 960 
 961   void init_previous_versions() {
 962     _previous_versions = NULL;
 963   }
 964 
 965  private:
 966   static bool  _has_previous_versions;
 967  public:
 968   static void purge_previous_versions(InstanceKlass* ik) {
 969     if (ik-&gt;has_been_redefined()) {
 970       ik-&gt;purge_previous_version_list();
 971     }
 972   }
 973 
 974   static bool has_previous_versions_and_reset();
 975   static bool has_previous_versions() { return _has_previous_versions; }
 976 
 977   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1106 
1107   // On-stack replacement support
1108   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1109   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1110   void add_osr_nmethod(nmethod* n);
1111   bool remove_osr_nmethod(nmethod* n);
1112   int mark_osr_nmethods(const Method* m);
1113   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1114 
1115 #if INCLUDE_JVMTI
1116   // Breakpoint support (see methods on Method* for details)
1117   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1118   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1119 #endif
1120 
1121   // support for stub routines
1122   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1123   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1124   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1125 
<span class="line-added">1126   static ByteSize value_field_klasses_offset() { return in_ByteSize(offset_of(InstanceKlass, _value_field_klasses)); }</span>
<span class="line-added">1127   static ByteSize adr_valueklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_valueklass_fixed_block)); }</span>
<span class="line-added">1128 </span>
1129   // subclass/subinterface checks
1130   bool implements_interface(Klass* k) const;
1131   bool is_same_or_direct_interface(Klass* k) const;
1132 
1133 #ifdef ASSERT
1134   // check whether this class or one of its superclasses was redefined
1135   bool has_redefined_this_or_super() const;
1136 #endif
1137 
1138   // Access to the implementor of an interface.
1139   Klass* implementor() const;
1140   void set_implementor(Klass* k);
1141   int  nof_implementors() const;
1142   void add_implementor(Klass* k);  // k is a new class that implements this interface
1143   void init_implementor();           // initialize
1144 
1145   // link this class into the implementors list of every interface it implements
1146   void process_interfaces(Thread *thread);
1147 
1148   // virtual operations from Klass
1149   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1150                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1151   bool can_be_primary_super_slow() const;
1152   int oop_size(oop obj)  const             { return size_helper(); }
1153   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1154   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1155   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1156 
1157   // Iterators
1158   void do_local_static_fields(FieldClosure* cl);
1159   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1160   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1161 
1162   void methods_do(void f(Method* method));
<span class="line-modified">1163   virtual void array_klasses_do(void f(Klass* k));</span>

1164 
1165   static InstanceKlass* cast(Klass* k) {
1166     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1167   }
1168 
1169   static const InstanceKlass* cast(const Klass* k) {
1170     assert(k != NULL, &quot;k should not be null&quot;);
1171     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1172     return static_cast&lt;const InstanceKlass*&gt;(k);
1173   }
1174 
1175   virtual InstanceKlass* java_super() const {
1176     return (super() == NULL) ? NULL : cast(super());
1177   }
1178 
1179   // Sizing (in words)
1180   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1181 
1182   static int size(int vtable_length, int itable_length,
1183                   int nonstatic_oop_map_size,
<span class="line-modified">1184                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint,</span>
<span class="line-added">1185                   int java_fields, bool is_inline_type) {</span>
1186     return align_metadata_size(header_size() +
1187            vtable_length +
1188            itable_length +
1189            nonstatic_oop_map_size +
1190            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1191            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
<span class="line-modified">1192            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0) +</span>
<span class="line-added">1193            (java_fields * (int)sizeof(Klass*)/wordSize) +</span>
<span class="line-added">1194            (is_inline_type ? (int)sizeof(ValueKlassFixedBlock) : 0));</span>
1195   }
1196   int size() const                    { return size(vtable_length(),
1197                                                itable_length(),
1198                                                nonstatic_oop_map_size(),
1199                                                is_interface(),
1200                                                is_unsafe_anonymous(),
<span class="line-modified">1201                                                has_stored_fingerprint(),</span>
<span class="line-added">1202                                                has_inline_fields() ? java_fields_count() : 0,</span>
<span class="line-added">1203                                                is_value());</span>
1204   }
1205 
1206   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1207   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1208 
1209   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1210 
1211   oop static_field_base_raw() { return java_mirror(); }
1212 
<span class="line-added">1213   bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;</span>
<span class="line-added">1214 </span>
1215   OopMapBlock* start_of_nonstatic_oop_maps() const {
1216     return (OopMapBlock*)(start_of_itable() + itable_length());
1217   }
1218 
1219   Klass** end_of_nonstatic_oop_maps() const {
1220     return (Klass**)(start_of_nonstatic_oop_maps() +
1221                      nonstatic_oop_map_count());
1222   }
1223 
1224   Klass* volatile* adr_implementor() const {
1225     if (is_interface()) {
1226       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1227     } else {
1228       return NULL;
1229     }
1230   };
1231 
1232   InstanceKlass** adr_unsafe_anonymous_host() const {
1233     if (is_unsafe_anonymous()) {
1234       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
</pre>
<hr />
<pre>
1243   }
1244 
1245   address adr_fingerprint() const {
1246     if (has_stored_fingerprint()) {
1247       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1248       if (adr_host != NULL) {
1249         return (address)(adr_host + 1);
1250       }
1251 
1252       Klass* volatile* adr_impl = adr_implementor();
1253       if (adr_impl != NULL) {
1254         return (address)(adr_impl + 1);
1255       }
1256 
1257       return (address)end_of_nonstatic_oop_maps();
1258     } else {
1259       return NULL;
1260     }
1261   }
1262 
<span class="line-added">1263   address adr_value_fields_klasses() const {</span>
<span class="line-added">1264     if (has_inline_fields()) {</span>
<span class="line-added">1265       address adr_fing = adr_fingerprint();</span>
<span class="line-added">1266       if (adr_fing != NULL) {</span>
<span class="line-added">1267         return adr_fingerprint() + sizeof(u8);</span>
<span class="line-added">1268       }</span>
<span class="line-added">1269 </span>
<span class="line-added">1270       InstanceKlass** adr_host = adr_unsafe_anonymous_host();</span>
<span class="line-added">1271       if (adr_host != NULL) {</span>
<span class="line-added">1272         return (address)(adr_host + 1);</span>
<span class="line-added">1273       }</span>
<span class="line-added">1274 </span>
<span class="line-added">1275       Klass* volatile* adr_impl = adr_implementor();</span>
<span class="line-added">1276       if (adr_impl != NULL) {</span>
<span class="line-added">1277         return (address)(adr_impl + 1);</span>
<span class="line-added">1278       }</span>
<span class="line-added">1279 </span>
<span class="line-added">1280       return (address)end_of_nonstatic_oop_maps();</span>
<span class="line-added">1281     } else {</span>
<span class="line-added">1282       return NULL;</span>
<span class="line-added">1283     }</span>
<span class="line-added">1284   }</span>
<span class="line-added">1285 </span>
<span class="line-added">1286   Klass* get_value_field_klass(int idx) const {</span>
<span class="line-added">1287     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1288     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>
<span class="line-added">1289     assert(k != NULL, &quot;Should always be set before being read&quot;);</span>
<span class="line-added">1290     assert(k-&gt;is_value(), &quot;Must be a inline type&quot;);</span>
<span class="line-added">1291     return k;</span>
<span class="line-added">1292   }</span>
<span class="line-added">1293 </span>
<span class="line-added">1294   Klass* get_value_field_klass_or_null(int idx) const {</span>
<span class="line-added">1295     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1296     Klass* k = ((Klass**)adr_value_fields_klasses())[idx];</span>
<span class="line-added">1297     assert(k == NULL || k-&gt;is_value(), &quot;Must be a inline type&quot;);</span>
<span class="line-added">1298     return k;</span>
<span class="line-added">1299   }</span>
<span class="line-added">1300 </span>
<span class="line-added">1301   void set_value_field_klass(int idx, Klass* k) {</span>
<span class="line-added">1302     assert(has_inline_fields(), &quot;Sanity checking&quot;);</span>
<span class="line-added">1303     assert(k != NULL, &quot;Should not be set to NULL&quot;);</span>
<span class="line-added">1304     assert(((Klass**)adr_value_fields_klasses())[idx] == NULL, &quot;Should not be set twice&quot;);</span>
<span class="line-added">1305     ((Klass**)adr_value_fields_klasses())[idx] = k;</span>
<span class="line-added">1306   }</span>
<span class="line-added">1307 </span>
1308   // Use this to return the size of an instance in heap words:
<span class="line-modified">1309   virtual int size_helper() const {</span>
1310     return layout_helper_to_size_helper(layout_helper());
1311   }
1312 
1313   // This bit is initialized in classFileParser.cpp.
1314   // It is false under any of the following conditions:
1315   //  - the class is abstract (including any interface)
1316   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1317   //  - the class size is larger than FastAllocateSizeLimit
1318   //  - the class is java/lang/Class, which cannot be allocated directly
1319   bool can_be_fastpath_allocated() const {
1320     return !layout_helper_needs_slow_path(layout_helper());
1321   }
1322 
1323   // Java itable
1324   klassItable itable() const;        // return klassItable wrapper
1325   Method* method_at_itable(Klass* holder, int index, TRAPS);
1326 
1327 #if INCLUDE_JVMTI
1328   void adjust_default_methods(bool* trace_name_printed);
1329 #endif // INCLUDE_JVMTI
</pre>
<hr />
<pre>
1426   inline jmethodID* methods_jmethod_ids_acquire() const;
1427   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1428 
1429   // Lock during initialization
1430 public:
1431   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1432   // Must be one per class and it has to be a VM internal object so java code
1433   // cannot lock it (like the mirror).
1434   // It has to be an object not a Mutex because it&#39;s held through java calls.
1435   oop init_lock() const;
1436 private:
1437   void fence_and_clear_init_lock();
1438 
1439   bool link_class_impl                           (TRAPS);
1440   bool verify_code                               (TRAPS);
1441   void initialize_impl                           (TRAPS);
1442   void initialize_super_interfaces               (TRAPS);
1443   void eager_initialize_impl                     ();
1444   /* jni_id_for_impl for jfieldID only */
1445   JNIid* jni_id_for_impl                         (int offset);
<span class="line-modified">1446 protected:</span>
1447   // Returns the array class for the n&#39;th dimension
<span class="line-modified">1448   virtual Klass* array_klass_impl(bool or_null, int n, TRAPS);</span>
1449 
1450   // Returns the array class with this class as element type
<span class="line-modified">1451   virtual Klass* array_klass_impl(bool or_null, TRAPS);</span>
<span class="line-added">1452 </span>
<span class="line-added">1453 private:</span>
1454 
1455   // find a local method (returns NULL if not found)
1456   Method* find_method_impl(const Symbol* name,
1457                            const Symbol* signature,
1458                            OverpassLookupMode overpass_mode,
1459                            StaticLookupMode static_mode,
1460                            PrivateLookupMode private_mode) const;
1461 
1462   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1463                                   const Symbol* name,
1464                                   const Symbol* signature,
1465                                   OverpassLookupMode overpass_mode,
1466                                   StaticLookupMode static_mode,
1467                                   PrivateLookupMode private_mode);
1468 
1469   // Free CHeap allocated fields.
1470   void release_C_heap_structures_internal();
1471 
1472 #if INCLUDE_JVMTI
1473   // RedefineClasses support
1474   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1475   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1476 #endif
1477 public:
1478   // CDS support - remove and restore oops from metadata. Oops are not shared.
1479   virtual void remove_unshareable_info();
1480   virtual void remove_java_mirror();
<span class="line-modified">1481   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1482 
1483   // jvm support
1484   jint compute_modifier_flags(TRAPS) const;
1485 
1486 public:
1487   // JVMTI support
1488   jint jvmti_class_status() const;
1489 
1490   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1491 
1492  public:
1493   // Printing
1494 #ifndef PRODUCT
1495   void print_on(outputStream* st) const;
1496 #endif
1497   void print_value_on(outputStream* st) const;
1498 
1499   void oop_print_value_on(oop obj, outputStream* st);
1500 
1501 #ifndef PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
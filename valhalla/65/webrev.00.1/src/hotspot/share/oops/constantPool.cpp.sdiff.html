<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;

  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vframe.inline.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 
  62 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  63   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  64   int size = ConstantPool::size(length);
  65   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  66 }
  67 
  68 void ConstantPool::copy_fields(const ConstantPool* orig) {
  69   // Preserve dynamic constant information from the original pool
  70   if (orig-&gt;has_dynamic_constant()) {
  71     set_has_dynamic_constant();
  72   }
</pre>
<hr />
<pre>
 210   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 211   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 212   set_resolved_klasses(rk);
 213 }
 214 
 215 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 216   int len = length();
 217   int num_klasses = 0;
 218   for (int i = 1; i &lt;len; i++) {
 219     switch (tag_at(i).value()) {
 220     case JVM_CONSTANT_ClassIndex:
 221       {
 222         const int class_index = klass_index_at(i);
 223         unresolved_klass_at_put(i, class_index, num_klasses++);
 224       }
 225       break;
 226 #ifndef PRODUCT
 227     case JVM_CONSTANT_Class:
 228     case JVM_CONSTANT_UnresolvedClass:
 229     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 230       // All of these should have been reverted back to ClassIndex before calling</span>
 231       // this function.
 232       ShouldNotReachHere();
 233 #endif
 234     }
 235   }
 236   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 237 }
 238 
 239 // Unsafe anonymous class support:
 240 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 241   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 242   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 243   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 244   *int_at_addr(class_index) =
 245     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 246 
 247   symbol_at_put(name_index, name);
 248   name-&gt;increment_refcount();
 249   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 250   Atomic::release_store(adr, k);
 251 
 252   // The interpreter assumes when the tag is stored, the klass is resolved
 253   // and the Klass* non-NULL, so we need hardware store ordering here.

 254   if (k != NULL) {
<span class="line-modified"> 255     release_tag_at_put(class_index, JVM_CONSTANT_Class);</span>
 256   } else {
<span class="line-modified"> 257     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);</span>
 258   }
 259 }
 260 
 261 // Unsafe anonymous class support:
 262 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 263   assert(k != NULL, &quot;must be valid klass&quot;);
 264   CPKlassSlot kslot = klass_slot_at(class_index);
 265   int resolved_klass_index = kslot.resolved_klass_index();
 266   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 267   Atomic::release_store(adr, k);
 268 
 269   // The interpreter assumes when the tag is stored, the klass is resolved
 270   // and the Klass* non-NULL, so we need hardware store ordering here.

 271   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 272 }
 273 
 274 #if INCLUDE_CDS_JAVA_HEAP
 275 // Archive the resolved references
 276 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 277   if (_cache == NULL) {
 278     return; // nothing to do
 279   }
 280 
 281   InstanceKlass *ik = pool_holder();
 282   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 283         ik-&gt;is_shared_app_class())) {
 284     // Archiving resolved references for classes from non-builtin loaders
 285     // is not yet supported.
 286     set_resolved_references(NULL);
 287     return;
 288   }
 289 
 290   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 451       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 452       if (s != NULL) {
 453         source_file = s-&gt;as_C_string();
 454       }
 455     }
 456   }
 457   if (k != this_cp-&gt;pool_holder()) {
 458     // only print something if the classes are different
 459     if (source_file != NULL) {
 460       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 461                  this_cp-&gt;pool_holder()-&gt;external_name(),
 462                  k-&gt;external_name(), source_file, line_number);
 463     } else {
 464       log_debug(class, resolve)(&quot;%s %s&quot;,
 465                  this_cp-&gt;pool_holder()-&gt;external_name(),
 466                  k-&gt;external_name());
 467     }
 468   }
 469 }
 470 






 471 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 472                                    bool save_resolution_error, TRAPS) {
 473   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 474   JavaThread* javaThread = (JavaThread*)THREAD;
 475 
 476   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 477   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 478   // the entry and tag is not updated atomicly.
 479   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 480   int resolved_klass_index = kslot.resolved_klass_index();
 481   int name_index = kslot.name_index();
 482   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 483 
 484   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 485   if (klass != NULL) {
 486     return klass;
 487   }
 488 
 489   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 490   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 491     // The original attempt to resolve this constant pool entry failed so find the
 492     // class of the original error and throw another error of the same class
 493     // (JVMS 5.4.3).
 494     // If there is a detail message, pass that detail message to the error.
 495     // The JVMS does not strictly require us to duplicate the same detail message,
 496     // or any internal exception fields such as cause or stacktrace.  But since the
 497     // detail message is often a class name or other literal string, we will repeat it
 498     // if we can find it in the symbol table.
 499     throw_resolution_error(this_cp, which, CHECK_NULL);
 500     ShouldNotReachHere();
 501   }
 502 
 503   Handle mirror_handle;
 504   Symbol* name = this_cp-&gt;symbol_at(name_index);





 505   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 506   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 507 
 508   Klass* k;
 509   {
 510     // Turn off the single stepping while doing class resolution
 511     JvmtiHideSingleStepping jhss(javaThread);
 512     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 513   } //  JvmtiHideSingleStepping jhss(javaThread);



 514 
 515   if (!HAS_PENDING_EXCEPTION) {
 516     // preserve the resolved klass from unloading
 517     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 518     // Do access check for klasses
 519     verify_constant_pool_resolve(this_cp, k, THREAD);
 520   }
 521 
















 522   // Failed to resolve class. We must record the errors so that subsequent attempts
 523   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 524   if (HAS_PENDING_EXCEPTION) {
 525     if (save_resolution_error) {
 526       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 527       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 528       // some other thread has beaten us and has resolved the class.
 529       // To preserve old behavior, we return the resolved class.
 530       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 531       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 532       return klass;
 533     } else {
 534       return NULL;  // return the pending exception
 535     }
 536   }
 537 
 538   // logging for class+resolve.
 539   if (log_is_enabled(Debug, class, resolve)){
 540     trace_class_resolution(this_cp, k);
 541   }
 542   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 543   Atomic::release_store(adr, k);
 544   // The interpreter assumes when the tag is stored, the klass is resolved
 545   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 546   // hardware store ordering here.
<span class="line-modified"> 547   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);</span>




 548   return k;
 549 }
 550 
 551 
 552 // Does not update ConstantPool* - to avoid any exception throwing. Used
 553 // by compiler and exception handling.  Also used to avoid classloads for
 554 // instanceof operations. Returns NULL if the class has not been loaded or
 555 // if the verification of constant pool failed
 556 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 557   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 558   int resolved_klass_index = kslot.resolved_klass_index();
 559   int name_index = kslot.name_index();
 560   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 561 
 562   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 563   if (k != NULL) {
 564     return k;
 565   } else {
 566     Thread *thread = Thread::current();
 567     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1851       case JVM_CONSTANT_Long: {
1852         u8 val = Bytes::get_Java_u8(bytes);
1853         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1854         ent_size = 8;
1855         idx++; // Long takes two cpool slots
1856         break;
1857       }
1858       case JVM_CONSTANT_Double: {
1859         u8 val = Bytes::get_Java_u8(bytes);
1860         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1861         ent_size = 8;
1862         idx++; // Double takes two cpool slots
1863         break;
1864       }
1865       case JVM_CONSTANT_Class: {
1866         idx1 = Bytes::get_Java_u2(bytes);
1867         printf(&quot;class        #%03d&quot;, idx1);
1868         ent_size = 2;
1869         break;
1870       }






1871       case JVM_CONSTANT_String: {
1872         idx1 = Bytes::get_Java_u2(bytes);
1873         printf(&quot;String       #%03d&quot;, idx1);
1874         ent_size = 2;
1875         break;
1876       }
1877       case JVM_CONSTANT_Fieldref: {
1878         idx1 = Bytes::get_Java_u2(bytes);
1879         idx2 = Bytes::get_Java_u2(bytes+2);
1880         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1881         ent_size = 4;
1882         break;
1883       }
1884       case JVM_CONSTANT_Methodref: {
1885         idx1 = Bytes::get_Java_u2(bytes);
1886         idx2 = Bytes::get_Java_u2(bytes+2);
1887         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1888         ent_size = 4;
1889         break;
1890       }
</pre>
<hr />
<pre>
1893         idx2 = Bytes::get_Java_u2(bytes+2);
1894         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1895         ent_size = 4;
1896         break;
1897       }
1898       case JVM_CONSTANT_NameAndType: {
1899         idx1 = Bytes::get_Java_u2(bytes);
1900         idx2 = Bytes::get_Java_u2(bytes+2);
1901         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1902         ent_size = 4;
1903         break;
1904       }
1905       case JVM_CONSTANT_ClassIndex: {
1906         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1907         break;
1908       }
1909       case JVM_CONSTANT_UnresolvedClass: {
1910         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1911         break;
1912       }




1913       case JVM_CONSTANT_UnresolvedClassInError: {
1914         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1915         break;
1916       }
1917       case JVM_CONSTANT_StringIndex: {
1918         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1919         break;
1920       }
1921     }
1922     printf(&quot;;\n&quot;);
1923     bytes += ent_size;
1924     size  += ent_size;
1925   }
1926   printf(&quot;Cpool size: %d\n&quot;, size);
1927   fflush(0);
1928   return;
1929 } /* end print_cpool_bytes */
1930 
1931 
1932 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2064       case JVM_CONSTANT_Float: {
2065         jfloat val = float_at(idx);
2066         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2067         break;
2068       }
2069       case JVM_CONSTANT_Long: {
2070         jlong val = long_at(idx);
2071         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2072         idx++;             // Long takes two cpool slots
2073         break;
2074       }
2075       case JVM_CONSTANT_Double: {
2076         jdouble val = double_at(idx);
2077         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2078         idx++;             // Double takes two cpool slots
2079         break;
2080       }
2081       case JVM_CONSTANT_Class:
2082       case JVM_CONSTANT_UnresolvedClass:
2083       case JVM_CONSTANT_UnresolvedClassInError: {

2084         *bytes = JVM_CONSTANT_Class;
2085         Symbol* sym = klass_name_at(idx);
2086         idx1 = tbl-&gt;symbol_to_value(sym);
2087         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2088         Bytes::put_Java_u2((address) (bytes+1), idx1);
2089         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2090         break;
2091       }
2092       case JVM_CONSTANT_String: {
2093         *bytes = JVM_CONSTANT_String;
2094         Symbol* sym = unresolved_string_at(idx);
2095         idx1 = tbl-&gt;symbol_to_value(sym);
2096         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2097         Bytes::put_Java_u2((address) (bytes+1), idx1);
2098         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2099         break;
2100       }
2101       case JVM_CONSTANT_Fieldref:
2102       case JVM_CONSTANT_Methodref:
2103       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  53 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/signature.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/vframe.inline.hpp&quot;
  61 #include &quot;utilities/copy.hpp&quot;
  62 
  63 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  64   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  65   int size = ConstantPool::size(length);
  66   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  67 }
  68 
  69 void ConstantPool::copy_fields(const ConstantPool* orig) {
  70   // Preserve dynamic constant information from the original pool
  71   if (orig-&gt;has_dynamic_constant()) {
  72     set_has_dynamic_constant();
  73   }
</pre>
<hr />
<pre>
 211   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 212   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 213   set_resolved_klasses(rk);
 214 }
 215 
 216 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 217   int len = length();
 218   int num_klasses = 0;
 219   for (int i = 1; i &lt;len; i++) {
 220     switch (tag_at(i).value()) {
 221     case JVM_CONSTANT_ClassIndex:
 222       {
 223         const int class_index = klass_index_at(i);
 224         unresolved_klass_at_put(i, class_index, num_klasses++);
 225       }
 226       break;
 227 #ifndef PRODUCT
 228     case JVM_CONSTANT_Class:
 229     case JVM_CONSTANT_UnresolvedClass:
 230     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 231       // All of these should have been reverted back to Unresolved before calling</span>
 232       // this function.
 233       ShouldNotReachHere();
 234 #endif
 235     }
 236   }
 237   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 238 }
 239 
 240 // Unsafe anonymous class support:
 241 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 242   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 243   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 244   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 245   *int_at_addr(class_index) =
 246     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 247 
 248   symbol_at_put(name_index, name);
 249   name-&gt;increment_refcount();
 250   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 251   Atomic::release_store(adr, k);
 252 
 253   // The interpreter assumes when the tag is stored, the klass is resolved
 254   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 255   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;</span>
 256   if (k != NULL) {
<span class="line-modified"> 257     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);</span>
 258   } else {
<span class="line-modified"> 259     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);</span>
 260   }
 261 }
 262 
 263 // Unsafe anonymous class support:
 264 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 265   assert(k != NULL, &quot;must be valid klass&quot;);
 266   CPKlassSlot kslot = klass_slot_at(class_index);
 267   int resolved_klass_index = kslot.resolved_klass_index();
 268   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 269   Atomic::release_store(adr, k);
 270 
 271   // The interpreter assumes when the tag is stored, the klass is resolved
 272   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 273   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);</span>
 274   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 275 }
 276 
 277 #if INCLUDE_CDS_JAVA_HEAP
 278 // Archive the resolved references
 279 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 280   if (_cache == NULL) {
 281     return; // nothing to do
 282   }
 283 
 284   InstanceKlass *ik = pool_holder();
 285   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 286         ik-&gt;is_shared_app_class())) {
 287     // Archiving resolved references for classes from non-builtin loaders
 288     // is not yet supported.
 289     set_resolved_references(NULL);
 290     return;
 291   }
 292 
 293   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 454       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 455       if (s != NULL) {
 456         source_file = s-&gt;as_C_string();
 457       }
 458     }
 459   }
 460   if (k != this_cp-&gt;pool_holder()) {
 461     // only print something if the classes are different
 462     if (source_file != NULL) {
 463       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 464                  this_cp-&gt;pool_holder()-&gt;external_name(),
 465                  k-&gt;external_name(), source_file, line_number);
 466     } else {
 467       log_debug(class, resolve)(&quot;%s %s&quot;,
 468                  this_cp-&gt;pool_holder()-&gt;external_name(),
 469                  k-&gt;external_name());
 470     }
 471   }
 472 }
 473 
<span class="line-added"> 474 void check_is_inline_type(Klass* k, TRAPS) {</span>
<span class="line-added"> 475   if (!k-&gt;is_value()) {</span>
<span class="line-added"> 476     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added"> 477   }</span>
<span class="line-added"> 478 }</span>
<span class="line-added"> 479 </span>
 480 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 481                                    bool save_resolution_error, TRAPS) {
 482   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 483   JavaThread* javaThread = (JavaThread*)THREAD;
 484 
 485   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 486   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 487   // the entry and tag is not updated atomicly.
 488   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 489   int resolved_klass_index = kslot.resolved_klass_index();
 490   int name_index = kslot.name_index();
 491   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 492 
 493   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 494   if (klass != NULL) {
 495     return klass;
 496   }
 497 
 498   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 499   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 500     // The original attempt to resolve this constant pool entry failed so find the
 501     // class of the original error and throw another error of the same class
 502     // (JVMS 5.4.3).
 503     // If there is a detail message, pass that detail message to the error.
 504     // The JVMS does not strictly require us to duplicate the same detail message,
 505     // or any internal exception fields such as cause or stacktrace.  But since the
 506     // detail message is often a class name or other literal string, we will repeat it
 507     // if we can find it in the symbol table.
 508     throw_resolution_error(this_cp, which, CHECK_NULL);
 509     ShouldNotReachHere();
 510   }
 511 
 512   Handle mirror_handle;
 513   Symbol* name = this_cp-&gt;symbol_at(name_index);
<span class="line-added"> 514   bool inline_type_signature = false;</span>
<span class="line-added"> 515   if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 516     name = name-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 517     inline_type_signature = true;</span>
<span class="line-added"> 518   }</span>
 519   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 520   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 521 
 522   Klass* k;
 523   {
 524     // Turn off the single stepping while doing class resolution
 525     JvmtiHideSingleStepping jhss(javaThread);
 526     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 527   } //  JvmtiHideSingleStepping jhss(javaThread);
<span class="line-added"> 528   if (inline_type_signature) {</span>
<span class="line-added"> 529     name-&gt;decrement_refcount();</span>
<span class="line-added"> 530   }</span>
 531 
 532   if (!HAS_PENDING_EXCEPTION) {
 533     // preserve the resolved klass from unloading
 534     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 535     // Do access check for klasses
 536     verify_constant_pool_resolve(this_cp, k, THREAD);
 537   }
 538 
<span class="line-added"> 539   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {</span>
<span class="line-added"> 540     check_is_inline_type(k, THREAD);</span>
<span class="line-added"> 541   }</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543   if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 544     Klass* bottom_klass = NULL;</span>
<span class="line-added"> 545     if (k-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 546       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();</span>
<span class="line-added"> 547       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 548       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);</span>
<span class="line-added"> 549     } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 550       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 551       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 552     }</span>
<span class="line-added"> 553   }</span>
<span class="line-added"> 554 </span>
 555   // Failed to resolve class. We must record the errors so that subsequent attempts
 556   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 557   if (HAS_PENDING_EXCEPTION) {
 558     if (save_resolution_error) {
 559       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 560       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 561       // some other thread has beaten us and has resolved the class.
 562       // To preserve old behavior, we return the resolved class.
 563       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 564       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 565       return klass;
 566     } else {
 567       return NULL;  // return the pending exception
 568     }
 569   }
 570 
 571   // logging for class+resolve.
 572   if (log_is_enabled(Debug, class, resolve)){
 573     trace_class_resolution(this_cp, k);
 574   }
 575   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 576   Atomic::release_store(adr, k);
 577   // The interpreter assumes when the tag is stored, the klass is resolved
 578   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 579   // hardware store ordering here.
<span class="line-modified"> 580   jbyte tag = JVM_CONSTANT_Class;</span>
<span class="line-added"> 581   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {</span>
<span class="line-added"> 582     tag |= JVM_CONSTANT_QDescBit;</span>
<span class="line-added"> 583   }</span>
<span class="line-added"> 584   this_cp-&gt;release_tag_at_put(which, tag);</span>
 585   return k;
 586 }
 587 
 588 
 589 // Does not update ConstantPool* - to avoid any exception throwing. Used
 590 // by compiler and exception handling.  Also used to avoid classloads for
 591 // instanceof operations. Returns NULL if the class has not been loaded or
 592 // if the verification of constant pool failed
 593 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 594   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 595   int resolved_klass_index = kslot.resolved_klass_index();
 596   int name_index = kslot.name_index();
 597   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 598 
 599   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 600   if (k != NULL) {
 601     return k;
 602   } else {
 603     Thread *thread = Thread::current();
 604     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1888       case JVM_CONSTANT_Long: {
1889         u8 val = Bytes::get_Java_u8(bytes);
1890         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1891         ent_size = 8;
1892         idx++; // Long takes two cpool slots
1893         break;
1894       }
1895       case JVM_CONSTANT_Double: {
1896         u8 val = Bytes::get_Java_u8(bytes);
1897         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1898         ent_size = 8;
1899         idx++; // Double takes two cpool slots
1900         break;
1901       }
1902       case JVM_CONSTANT_Class: {
1903         idx1 = Bytes::get_Java_u2(bytes);
1904         printf(&quot;class        #%03d&quot;, idx1);
1905         ent_size = 2;
1906         break;
1907       }
<span class="line-added">1908       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1909         idx1 = Bytes::get_Java_u2(bytes);</span>
<span class="line-added">1910         printf(&quot;qclass        #%03d&quot;, idx1);</span>
<span class="line-added">1911         ent_size = 2;</span>
<span class="line-added">1912         break;</span>
<span class="line-added">1913       }</span>
1914       case JVM_CONSTANT_String: {
1915         idx1 = Bytes::get_Java_u2(bytes);
1916         printf(&quot;String       #%03d&quot;, idx1);
1917         ent_size = 2;
1918         break;
1919       }
1920       case JVM_CONSTANT_Fieldref: {
1921         idx1 = Bytes::get_Java_u2(bytes);
1922         idx2 = Bytes::get_Java_u2(bytes+2);
1923         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1924         ent_size = 4;
1925         break;
1926       }
1927       case JVM_CONSTANT_Methodref: {
1928         idx1 = Bytes::get_Java_u2(bytes);
1929         idx2 = Bytes::get_Java_u2(bytes+2);
1930         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1931         ent_size = 4;
1932         break;
1933       }
</pre>
<hr />
<pre>
1936         idx2 = Bytes::get_Java_u2(bytes+2);
1937         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1938         ent_size = 4;
1939         break;
1940       }
1941       case JVM_CONSTANT_NameAndType: {
1942         idx1 = Bytes::get_Java_u2(bytes);
1943         idx2 = Bytes::get_Java_u2(bytes+2);
1944         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1945         ent_size = 4;
1946         break;
1947       }
1948       case JVM_CONSTANT_ClassIndex: {
1949         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1950         break;
1951       }
1952       case JVM_CONSTANT_UnresolvedClass: {
1953         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1954         break;
1955       }
<span class="line-added">1956       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1957         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);</span>
<span class="line-added">1958         break;</span>
<span class="line-added">1959       }</span>
1960       case JVM_CONSTANT_UnresolvedClassInError: {
1961         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1962         break;
1963       }
1964       case JVM_CONSTANT_StringIndex: {
1965         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1966         break;
1967       }
1968     }
1969     printf(&quot;;\n&quot;);
1970     bytes += ent_size;
1971     size  += ent_size;
1972   }
1973   printf(&quot;Cpool size: %d\n&quot;, size);
1974   fflush(0);
1975   return;
1976 } /* end print_cpool_bytes */
1977 
1978 
1979 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2111       case JVM_CONSTANT_Float: {
2112         jfloat val = float_at(idx);
2113         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2114         break;
2115       }
2116       case JVM_CONSTANT_Long: {
2117         jlong val = long_at(idx);
2118         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2119         idx++;             // Long takes two cpool slots
2120         break;
2121       }
2122       case JVM_CONSTANT_Double: {
2123         jdouble val = double_at(idx);
2124         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2125         idx++;             // Double takes two cpool slots
2126         break;
2127       }
2128       case JVM_CONSTANT_Class:
2129       case JVM_CONSTANT_UnresolvedClass:
2130       case JVM_CONSTANT_UnresolvedClassInError: {
<span class="line-added">2131         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);</span>
2132         *bytes = JVM_CONSTANT_Class;
2133         Symbol* sym = klass_name_at(idx);
2134         idx1 = tbl-&gt;symbol_to_value(sym);
2135         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2136         Bytes::put_Java_u2((address) (bytes+1), idx1);
2137         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2138         break;
2139       }
2140       case JVM_CONSTANT_String: {
2141         *bytes = JVM_CONSTANT_String;
2142         Symbol* sym = unresolved_string_at(idx);
2143         idx1 = tbl-&gt;symbol_to_value(sym);
2144         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2145         Bytes::put_Java_u2((address) (bytes+1), idx1);
2146         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2147         break;
2148       }
2149       case JVM_CONSTANT_Fieldref:
2150       case JVM_CONSTANT_Methodref:
2151       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
</tr>
</table>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
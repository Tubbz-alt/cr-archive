<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<a name="1" id="anc1"></a>
  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vframe.inline.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 
  62 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  63   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  64   int size = ConstantPool::size(length);
  65   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  66 }
  67 
  68 void ConstantPool::copy_fields(const ConstantPool* orig) {
  69   // Preserve dynamic constant information from the original pool
  70   if (orig-&gt;has_dynamic_constant()) {
  71     set_has_dynamic_constant();
  72   }
  73 
  74   // Copy class version
  75   set_major_version(orig-&gt;major_version());
  76   set_minor_version(orig-&gt;minor_version());
  77 
  78   set_source_file_name_index(orig-&gt;source_file_name_index());
  79   set_generic_signature_index(orig-&gt;generic_signature_index());
  80 }
  81 
  82 #ifdef ASSERT
  83 
  84 // MetaspaceObj allocation invariant is calloc equivalent memory
  85 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  86 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  87   assert(tags != NULL, &quot;invariant&quot;);
  88   const int length = tags-&gt;length();
  89   for (int index = 0; index &lt; length; ++index) {
  90     if (JVM_CONSTANT_Invalid != tags-&gt;at(index)) {
  91       return false;
  92     }
  93   }
  94   return true;
  95 }
  96 
  97 #endif
  98 
  99 ConstantPool::ConstantPool(Array&lt;u1&gt;* tags) :
 100   _tags(tags),
 101   _length(tags-&gt;length()) {
 102 
 103     assert(_tags != NULL, &quot;invariant&quot;);
 104     assert(tags-&gt;length() == _length, &quot;invariant&quot;);
 105     assert(tag_array_is_zero_initialized(tags), &quot;invariant&quot;);
 106     assert(0 == flags(), &quot;invariant&quot;);
 107     assert(0 == version(), &quot;invariant&quot;);
 108     assert(NULL == _pool_holder, &quot;invariant&quot;);
 109 }
 110 
 111 void ConstantPool::deallocate_contents(ClassLoaderData* loader_data) {
 112   if (cache() != NULL) {
 113     MetadataFactory::free_metadata(loader_data, cache());
 114     set_cache(NULL);
 115   }
 116 
 117   MetadataFactory::free_array&lt;Klass*&gt;(loader_data, resolved_klasses());
 118   set_resolved_klasses(NULL);
 119 
 120   MetadataFactory::free_array&lt;jushort&gt;(loader_data, operands());
 121   set_operands(NULL);
 122 
 123   release_C_heap_structures();
 124 
 125   // free tag array
 126   MetadataFactory::free_array&lt;u1&gt;(loader_data, tags());
 127   set_tags(NULL);
 128 }
 129 
 130 void ConstantPool::release_C_heap_structures() {
 131   // walk constant pool and decrement symbol reference counts
 132   unreference_symbols();
 133 }
 134 
 135 void ConstantPool::metaspace_pointers_do(MetaspaceClosure* it) {
 136   log_trace(cds)(&quot;Iter(ConstantPool): %p&quot;, this);
 137 
 138   it-&gt;push(&amp;_tags, MetaspaceClosure::_writable);
 139   it-&gt;push(&amp;_cache);
 140   it-&gt;push(&amp;_pool_holder);
 141   it-&gt;push(&amp;_operands);
 142   it-&gt;push(&amp;_resolved_klasses, MetaspaceClosure::_writable);
 143 
 144   for (int i = 0; i &lt; length(); i++) {
 145     // The only MSO&#39;s embedded in the CP entries are Symbols:
 146     //   JVM_CONSTANT_String (normal and pseudo)
 147     //   JVM_CONSTANT_Utf8
 148     constantTag ctag = tag_at(i);
 149     if (ctag.is_string() || ctag.is_utf8()) {
 150       it-&gt;push(symbol_at_addr(i));
 151     }
 152   }
 153 }
 154 
 155 objArrayOop ConstantPool::resolved_references() const {
 156   return (objArrayOop)_cache-&gt;resolved_references();
 157 }
 158 
 159 // Called from outside constant pool resolution where a resolved_reference array
 160 // may not be present.
 161 objArrayOop ConstantPool::resolved_references_or_null() const {
 162   if (_cache == NULL) {
 163     return NULL;
 164   } else {
 165     return (objArrayOop)_cache-&gt;resolved_references();
 166   }
 167 }
 168 
 169 // Create resolved_references array and mapping array for original cp indexes
 170 // The ldc bytecode was rewritten to have the resolved reference array index so need a way
 171 // to map it back for resolving and some unlikely miscellaneous uses.
 172 // The objects created by invokedynamic are appended to this list.
 173 void ConstantPool::initialize_resolved_references(ClassLoaderData* loader_data,
 174                                                   const intStack&amp; reference_map,
 175                                                   int constant_pool_map_length,
 176                                                   TRAPS) {
 177   // Initialized the resolved object cache.
 178   int map_length = reference_map.length();
 179   if (map_length &gt; 0) {
 180     // Only need mapping back to constant pool entries.  The map isn&#39;t used for
 181     // invokedynamic resolved_reference entries.  For invokedynamic entries,
 182     // the constant pool cache index has the mapping back to both the constant
 183     // pool and to the resolved reference index.
 184     if (constant_pool_map_length &gt; 0) {
 185       Array&lt;u2&gt;* om = MetadataFactory::new_array&lt;u2&gt;(loader_data, constant_pool_map_length, CHECK);
 186 
 187       for (int i = 0; i &lt; constant_pool_map_length; i++) {
 188         int x = reference_map.at(i);
 189         assert(x == (int)(jushort) x, &quot;klass index is too big&quot;);
 190         om-&gt;at_put(i, (jushort)x);
 191       }
 192       set_reference_map(om);
 193     }
 194 
 195     // Create Java array for holding resolved strings, methodHandles,
 196     // methodTypes, invokedynamic and invokehandle appendix objects, etc.
 197     objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 198     Handle refs_handle (THREAD, (oop)stom);  // must handleize.
 199     set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 200   }
 201 }
 202 
 203 void ConstantPool::allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS) {
 204   // A ConstantPool can&#39;t possibly have 0xffff valid class entries,
 205   // because entry #0 must be CONSTANT_Invalid, and each class entry must refer to a UTF8
 206   // entry for the class&#39;s name. So at most we will have 0xfffe class entries.
 207   // This allows us to use 0xffff (ConstantPool::_temp_resolved_klass_index) to indicate
 208   // UnresolvedKlass entries that are temporarily created during class redefinition.
 209   assert(num_klasses &lt; CPKlassSlot::_temp_resolved_klass_index, &quot;sanity&quot;);
 210   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 211   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 212   set_resolved_klasses(rk);
 213 }
 214 
 215 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 216   int len = length();
 217   int num_klasses = 0;
 218   for (int i = 1; i &lt;len; i++) {
 219     switch (tag_at(i).value()) {
 220     case JVM_CONSTANT_ClassIndex:
 221       {
 222         const int class_index = klass_index_at(i);
 223         unresolved_klass_at_put(i, class_index, num_klasses++);
 224       }
 225       break;
 226 #ifndef PRODUCT
 227     case JVM_CONSTANT_Class:
 228     case JVM_CONSTANT_UnresolvedClass:
 229     case JVM_CONSTANT_UnresolvedClassInError:
<a name="2" id="anc2"></a><span class="line-modified"> 230       // All of these should have been reverted back to ClassIndex before calling</span>
 231       // this function.
 232       ShouldNotReachHere();
 233 #endif
 234     }
 235   }
 236   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 237 }
 238 
 239 // Unsafe anonymous class support:
 240 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 241   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 242   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 243   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 244   *int_at_addr(class_index) =
 245     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 246 
 247   symbol_at_put(name_index, name);
 248   name-&gt;increment_refcount();
 249   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 250   Atomic::release_store(adr, k);
 251 
 252   // The interpreter assumes when the tag is stored, the klass is resolved
 253   // and the Klass* non-NULL, so we need hardware store ordering here.
<a name="3" id="anc3"></a>
 254   if (k != NULL) {
<a name="4" id="anc4"></a><span class="line-modified"> 255     release_tag_at_put(class_index, JVM_CONSTANT_Class);</span>
 256   } else {
<a name="5" id="anc5"></a><span class="line-modified"> 257     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);</span>
 258   }
 259 }
 260 
 261 // Unsafe anonymous class support:
 262 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 263   assert(k != NULL, &quot;must be valid klass&quot;);
 264   CPKlassSlot kslot = klass_slot_at(class_index);
 265   int resolved_klass_index = kslot.resolved_klass_index();
 266   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 267   Atomic::release_store(adr, k);
 268 
 269   // The interpreter assumes when the tag is stored, the klass is resolved
 270   // and the Klass* non-NULL, so we need hardware store ordering here.
<a name="6" id="anc6"></a>
 271   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 272 }
 273 
 274 #if INCLUDE_CDS_JAVA_HEAP
 275 // Archive the resolved references
 276 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 277   if (_cache == NULL) {
 278     return; // nothing to do
 279   }
 280 
 281   InstanceKlass *ik = pool_holder();
 282   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 283         ik-&gt;is_shared_app_class())) {
 284     // Archiving resolved references for classes from non-builtin loaders
 285     // is not yet supported.
 286     set_resolved_references(NULL);
 287     return;
 288   }
 289 
 290   objArrayOop rr = resolved_references();
 291   Array&lt;u2&gt;* ref_map = reference_map();
 292   if (rr != NULL) {
 293     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 294     int rr_len = rr-&gt;length();
 295     for (int i = 0; i &lt; rr_len; i++) {
 296       oop p = rr-&gt;obj_at(i);
 297       rr-&gt;obj_at_put(i, NULL);
 298       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 299         int index = object_to_cp_index(i);
 300         if (tag_at(index).is_string()) {
 301           oop op = StringTable::create_archived_string(p, THREAD);
 302           // If the String object is not archived (possibly too large),
 303           // NULL is returned. Also set it in the array, so we won&#39;t
 304           // have a &#39;bad&#39; reference in the archived resolved_reference
 305           // array.
 306           rr-&gt;obj_at_put(i, op);
 307         }
 308       }
 309     }
 310 
 311     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 312     // If the resolved references array is not archived (too large),
 313     // the &#39;archived&#39; object is NULL. No need to explicitly check
 314     // the return value of archive_heap_object here. At runtime, the
 315     // resolved references will be created using the normal process
 316     // when there is no archived value.
 317     _cache-&gt;set_archived_references(archived);
 318     set_resolved_references(NULL);
 319   }
 320 }
 321 
 322 void ConstantPool::resolve_class_constants(TRAPS) {
 323   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
 324   // The _cache may be NULL if the _pool_holder klass fails verification
 325   // at dump time due to missing dependencies.
 326   if (cache() == NULL || reference_map() == NULL) {
 327     return; // nothing to do
 328   }
 329 
 330   constantPoolHandle cp(THREAD, this);
 331   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 332     if (tag_at(index).is_string() &amp;&amp; !cp-&gt;is_pseudo_string_at(index)) {
 333       int cache_index = cp-&gt;cp_to_object_index(index);
 334       string_at_impl(cp, index, cache_index, CHECK);
 335     }
 336   }
 337 }
 338 #endif
 339 
 340 // CDS support. Create a new resolved_references array.
 341 void ConstantPool::restore_unshareable_info(TRAPS) {
 342   assert(is_constantPool(), &quot;ensure C++ vtable is restored&quot;);
 343   assert(on_stack(), &quot;should always be set for shared constant pools&quot;);
 344   assert(is_shared(), &quot;should always be set for shared constant pools&quot;);
 345   assert(_cache != NULL, &quot;constant pool _cache should not be NULL&quot;);
 346 
 347   // Only create the new resolved references array if it hasn&#39;t been attempted before
 348   if (resolved_references() != NULL) return;
 349 
 350   // restore the C++ vtable from the shared archive
 351   restore_vtable();
 352 
 353   if (SystemDictionary::Object_klass_loaded()) {
 354     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
 355 #if INCLUDE_CDS_JAVA_HEAP
 356     if (HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 357         _cache-&gt;archived_references() != NULL) {
 358       oop archived = _cache-&gt;archived_references();
 359       // Create handle for the archived resolved reference array object
 360       Handle refs_handle(THREAD, archived);
 361       set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 362     } else
 363 #endif
 364     {
 365       // No mapped archived resolved reference array
 366       // Recreate the object array and add to ClassLoaderData.
 367       int map_length = resolved_reference_length();
 368       if (map_length &gt; 0) {
 369         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 370         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 371         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 372       }
 373     }
 374   }
 375 }
 376 
 377 void ConstantPool::remove_unshareable_info() {
 378   // Resolved references are not in the shared archive.
 379   // Save the length for restoration.  It is not necessarily the same length
 380   // as reference_map.length() if invokedynamic is saved. It is needed when
 381   // re-creating the resolved reference array if archived heap data cannot be map
 382   // at runtime.
 383   set_resolved_reference_length(
 384     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 385 
 386   // If archiving heap objects is not allowed, clear the resolved references.
 387   // Otherwise, it is cleared after the resolved references array is cached
 388   // (see archive_resolved_references()).
 389   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 390   // as java objects are not archived in the top layer.
 391   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 392     set_resolved_references(NULL);
 393   }
 394 
 395   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 396   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 397   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 398   // we always set _on_stack to true to avoid having to change _flags during runtime.
 399   _flags |= (_on_stack | _is_shared);
 400   int num_klasses = 0;
 401   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 402     if (!DynamicDumpSharedSpaces) {
 403       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 404     } else {
 405       if (tag_at(index).is_unresolved_klass_in_error() ||
 406           tag_at(index).is_method_handle_in_error()    ||
 407           tag_at(index).is_method_type_in_error()      ||
 408           tag_at(index).is_dynamic_constant_in_error()) {
 409         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 410       }
 411     }
 412     if (tag_at(index).is_klass()) {
 413       // This class was resolved as a side effect of executing Java code
 414       // during dump time. We need to restore it back to an UnresolvedClass,
 415       // so that the proper class loading and initialization can happen
 416       // at runtime.
 417       CPKlassSlot kslot = klass_slot_at(index);
 418       int resolved_klass_index = kslot.resolved_klass_index();
 419       int name_index = kslot.name_index();
 420       assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 421       resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 422       tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 423       assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 424     }
 425   }
 426   if (cache() != NULL) {
 427     cache()-&gt;remove_unshareable_info();
 428   }
 429 }
 430 
 431 int ConstantPool::cp_to_object_index(int cp_index) {
 432   // this is harder don&#39;t do this so much.
 433   int i = reference_map()-&gt;find(cp_index);
 434   // We might not find the index for jsr292 call.
 435   return (i &lt; 0) ? _no_index_sentinel : i;
 436 }
 437 
 438 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 439   resolved_references()-&gt;obj_at_put(obj_index, str);
 440 }
 441 
 442 void ConstantPool::trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k) {
 443   ResourceMark rm;
 444   int line_number = -1;
 445   const char * source_file = NULL;
 446   if (JavaThread::current()-&gt;has_last_Java_frame()) {
 447     // try to identify the method which called this function.
 448     vframeStream vfst(JavaThread::current());
 449     if (!vfst.at_end()) {
 450       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 451       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 452       if (s != NULL) {
 453         source_file = s-&gt;as_C_string();
 454       }
 455     }
 456   }
 457   if (k != this_cp-&gt;pool_holder()) {
 458     // only print something if the classes are different
 459     if (source_file != NULL) {
 460       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 461                  this_cp-&gt;pool_holder()-&gt;external_name(),
 462                  k-&gt;external_name(), source_file, line_number);
 463     } else {
 464       log_debug(class, resolve)(&quot;%s %s&quot;,
 465                  this_cp-&gt;pool_holder()-&gt;external_name(),
 466                  k-&gt;external_name());
 467     }
 468   }
 469 }
 470 
<a name="7" id="anc7"></a>





 471 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 472                                    bool save_resolution_error, TRAPS) {
 473   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 474   JavaThread* javaThread = (JavaThread*)THREAD;
 475 
 476   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 477   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 478   // the entry and tag is not updated atomicly.
 479   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 480   int resolved_klass_index = kslot.resolved_klass_index();
 481   int name_index = kslot.name_index();
 482   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 483 
 484   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 485   if (klass != NULL) {
 486     return klass;
 487   }
 488 
 489   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 490   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 491     // The original attempt to resolve this constant pool entry failed so find the
 492     // class of the original error and throw another error of the same class
 493     // (JVMS 5.4.3).
 494     // If there is a detail message, pass that detail message to the error.
 495     // The JVMS does not strictly require us to duplicate the same detail message,
 496     // or any internal exception fields such as cause or stacktrace.  But since the
 497     // detail message is often a class name or other literal string, we will repeat it
 498     // if we can find it in the symbol table.
 499     throw_resolution_error(this_cp, which, CHECK_NULL);
 500     ShouldNotReachHere();
 501   }
 502 
 503   Handle mirror_handle;
 504   Symbol* name = this_cp-&gt;symbol_at(name_index);
<a name="8" id="anc8"></a>




 505   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 506   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 507 
 508   Klass* k;
 509   {
 510     // Turn off the single stepping while doing class resolution
 511     JvmtiHideSingleStepping jhss(javaThread);
 512     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 513   } //  JvmtiHideSingleStepping jhss(javaThread);
<a name="9" id="anc9"></a>


 514 
 515   if (!HAS_PENDING_EXCEPTION) {
 516     // preserve the resolved klass from unloading
 517     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 518     // Do access check for klasses
 519     verify_constant_pool_resolve(this_cp, k, THREAD);
 520   }
 521 
<a name="10" id="anc10"></a>















 522   // Failed to resolve class. We must record the errors so that subsequent attempts
 523   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 524   if (HAS_PENDING_EXCEPTION) {
 525     if (save_resolution_error) {
 526       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 527       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 528       // some other thread has beaten us and has resolved the class.
 529       // To preserve old behavior, we return the resolved class.
 530       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 531       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 532       return klass;
 533     } else {
 534       return NULL;  // return the pending exception
 535     }
 536   }
 537 
 538   // logging for class+resolve.
 539   if (log_is_enabled(Debug, class, resolve)){
 540     trace_class_resolution(this_cp, k);
 541   }
 542   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 543   Atomic::release_store(adr, k);
 544   // The interpreter assumes when the tag is stored, the klass is resolved
 545   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 546   // hardware store ordering here.
<a name="11" id="anc11"></a><span class="line-modified"> 547   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);</span>




 548   return k;
 549 }
 550 
 551 
 552 // Does not update ConstantPool* - to avoid any exception throwing. Used
 553 // by compiler and exception handling.  Also used to avoid classloads for
 554 // instanceof operations. Returns NULL if the class has not been loaded or
 555 // if the verification of constant pool failed
 556 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 557   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 558   int resolved_klass_index = kslot.resolved_klass_index();
 559   int name_index = kslot.name_index();
 560   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 561 
 562   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 563   if (k != NULL) {
 564     return k;
 565   } else {
 566     Thread *thread = Thread::current();
 567     Symbol* name = this_cp-&gt;symbol_at(name_index);
 568     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 569     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 570     Handle h_prot (thread, protection_domain);
 571     Handle h_loader (thread, loader);
 572     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 573 
 574     // Avoid constant pool verification at a safepoint, which takes the Module_lock.
 575     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
 576       // Make sure that resolving is legal
 577       EXCEPTION_MARK;
 578       // return NULL if verification fails
 579       verify_constant_pool_resolve(this_cp, k, THREAD);
 580       if (HAS_PENDING_EXCEPTION) {
 581         CLEAR_PENDING_EXCEPTION;
 582         return NULL;
 583       }
 584       return k;
 585     } else {
 586       return k;
 587     }
 588   }
 589 }
 590 
 591 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 592                                                    int which) {
 593   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 594   int cache_index = decode_cpcache_index(which, true);
 595   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
 596     // FIXME: should be an assert
 597     log_debug(class, resolve)(&quot;bad operand %d in:&quot;, which); cpool-&gt;print();
 598     return NULL;
 599   }
 600   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 601   return e-&gt;method_if_resolved(cpool);
 602 }
 603 
 604 
 605 bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 606   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 607   int cache_index = decode_cpcache_index(which, true);
 608   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 609   return e-&gt;has_appendix();
 610 }
 611 
 612 oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 613   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 614   int cache_index = decode_cpcache_index(which, true);
 615   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 616   return e-&gt;appendix_if_resolved(cpool);
 617 }
 618 
 619 
 620 bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 621   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 622   int cache_index = decode_cpcache_index(which, true);
 623   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 624   return e-&gt;has_local_signature();
 625 }
 626 
 627 Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {
 628   int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 629   return symbol_at(name_index);
 630 }
 631 
 632 
 633 Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {
 634   int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 635   return symbol_at(signature_index);
 636 }
 637 
 638 int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {
 639   int i = which;
 640   if (!uncached &amp;&amp; cache() != NULL) {
 641     if (ConstantPool::is_invokedynamic_index(which)) {
 642       // Invokedynamic index is index into the constant pool cache
 643       int pool_index = invokedynamic_bootstrap_ref_index_at(which);
 644       pool_index = bootstrap_name_and_type_ref_index_at(pool_index);
 645       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 646       return pool_index;
 647     }
 648     // change byte-ordering and go via cache
 649     i = remap_instruction_operand_from_cache(which);
 650   } else {
 651     if (tag_at(which).has_bootstrap()) {
 652       int pool_index = bootstrap_name_and_type_ref_index_at(which);
 653       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 654       return pool_index;
 655     }
 656   }
 657   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 658   assert(!tag_at(i).has_bootstrap(), &quot;Must be handled above&quot;);
 659   jint ref_index = *int_at_addr(i);
 660   return extract_high_short_from_int(ref_index);
 661 }
 662 
 663 constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {
 664   int pool_index = which;
 665   if (!uncached &amp;&amp; cache() != NULL) {
 666     if (ConstantPool::is_invokedynamic_index(which)) {
 667       // Invokedynamic index is index into resolved_references
 668       pool_index = invokedynamic_bootstrap_ref_index_at(which);
 669     } else {
 670       // change byte-ordering and go via cache
 671       pool_index = remap_instruction_operand_from_cache(which);
 672     }
 673   }
 674   return tag_at(pool_index);
 675 }
 676 
 677 int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {
 678   guarantee(!ConstantPool::is_invokedynamic_index(which),
 679             &quot;an invokedynamic instruction does not have a klass&quot;);
 680   int i = which;
 681   if (!uncached &amp;&amp; cache() != NULL) {
 682     // change byte-ordering and go via cache
 683     i = remap_instruction_operand_from_cache(which);
 684   }
 685   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 686   jint ref_index = *int_at_addr(i);
 687   return extract_low_short_from_int(ref_index);
 688 }
 689 
 690 
 691 
 692 int ConstantPool::remap_instruction_operand_from_cache(int operand) {
 693   int cpc_index = operand;
 694   DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
 695   assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
 696   int member_index = cache()-&gt;entry_at(cpc_index)-&gt;constant_pool_index();
 697   return member_index;
 698 }
 699 
 700 
 701 void ConstantPool::verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* k, TRAPS) {
 702   if (!(k-&gt;is_instance_klass() || k-&gt;is_objArray_klass())) {
 703     return;  // short cut, typeArray klass is always accessible
 704   }
 705   Klass* holder = this_cp-&gt;pool_holder();
 706   LinkResolver::check_klass_accessibility(holder, k, CHECK);
 707 }
 708 
 709 
 710 int ConstantPool::name_ref_index_at(int which_nt) {
 711   jint ref_index = name_and_type_at(which_nt);
 712   return extract_low_short_from_int(ref_index);
 713 }
 714 
 715 
 716 int ConstantPool::signature_ref_index_at(int which_nt) {
 717   jint ref_index = name_and_type_at(which_nt);
 718   return extract_high_short_from_int(ref_index);
 719 }
 720 
 721 
 722 Klass* ConstantPool::klass_ref_at(int which, TRAPS) {
 723   return klass_at(klass_ref_index_at(which), THREAD);
 724 }
 725 
 726 Symbol* ConstantPool::klass_name_at(int which) const {
 727   return symbol_at(klass_slot_at(which).name_index());
 728 }
 729 
 730 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 731   jint ref_index = klass_ref_index_at(which);
 732   return klass_at_noresolve(ref_index);
 733 }
 734 
 735 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 736   jint ref_index = uncached_klass_ref_index_at(which);
 737   return klass_at_noresolve(ref_index);
 738 }
 739 
 740 char* ConstantPool::string_at_noresolve(int which) {
 741   return unresolved_string_at(which)-&gt;as_C_string();
 742 }
 743 
 744 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
 745   return Signature::basic_type(symbol_at(which));
 746 }
 747 
 748 
 749 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 750   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 751     if (this_cp-&gt;tag_at(index).is_string()) {
 752       this_cp-&gt;string_at(index, CHECK);
 753     }
 754   }
 755 }
 756 
 757 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 758   // Dig out the detailed message to reuse if possible
 759   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 760   if (message != NULL) {
 761     return message;
 762   }
 763 
 764   // Return specific message for the tag
 765   switch (tag.value()) {
 766   case JVM_CONSTANT_UnresolvedClass:
 767     // return the class name in the error message
 768     message = this_cp-&gt;klass_name_at(which);
 769     break;
 770   case JVM_CONSTANT_MethodHandle:
 771     // return the method handle name in the error message
 772     message = this_cp-&gt;method_handle_name_ref_at(which);
 773     break;
 774   case JVM_CONSTANT_MethodType:
 775     // return the method type signature in the error message
 776     message = this_cp-&gt;method_type_signature_at(which);
 777     break;
 778   case JVM_CONSTANT_Dynamic:
 779     // return the name of the condy in the error message
 780     message = this_cp-&gt;uncached_name_ref_at(which);
 781     break;
 782   default:
 783     ShouldNotReachHere();
 784   }
 785 
 786   return message;
 787 }
 788 
 789 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 790   Symbol* message = NULL;
 791   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 792   assert(error != NULL, &quot;checking&quot;);
 793   CLEAR_PENDING_EXCEPTION;
 794   if (message != NULL) {
 795     ResourceMark rm;
 796     THROW_MSG(error, message-&gt;as_C_string());
 797   } else {
 798     THROW(error);
 799   }
 800 }
 801 
 802 // If resolution for Class, Dynamic constant, MethodHandle or MethodType fails, save the
 803 // exception in the resolution error table, so that the same exception is thrown again.
 804 void ConstantPool::save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which,
 805                                             constantTag tag, TRAPS) {
 806   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 807 
 808   int error_tag = tag.error_value();
 809 
 810   if (!PENDING_EXCEPTION-&gt;
 811     is_a(SystemDictionary::LinkageError_klass())) {
 812     // Just throw the exception and don&#39;t prevent these classes from
 813     // being loaded due to virtual machine errors like StackOverflow
 814     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 815     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 816   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 817     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 818     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 819     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 820     // If another thread resolved the reference, this is a race condition. This
 821     // thread may have had a security manager or something temporary.
 822     // This doesn&#39;t deterministically get an error.   So why do we save this?
 823     // We save this because jvmti can add classes to the bootclass path after
 824     // this error, so it needs to get the same error if the error is first.
 825     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),
 826                                     (jbyte)tag.value(),
 827                                     (jbyte)error_tag);
 828     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 829       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 830       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 831       // Forget the exception and use the resolved class.
 832       CLEAR_PENDING_EXCEPTION;
 833     }
 834   } else {
 835     // some other thread put this in error state
 836     throw_resolution_error(this_cp, which, CHECK);
 837   }
 838 }
 839 
 840 constantTag ConstantPool::constant_tag_at(int which) {
 841   constantTag tag = tag_at(which);
 842   if (tag.is_dynamic_constant() ||
 843       tag.is_dynamic_constant_in_error()) {
 844     BasicType bt = basic_type_for_constant_at(which);
 845     // dynamic constant could return an array, treat as object
 846     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 847   }
 848   return tag;
 849 }
 850 
 851 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 852   constantTag tag = tag_at(which);
 853   if (tag.is_dynamic_constant() ||
 854       tag.is_dynamic_constant_in_error()) {
 855     // have to look at the signature for this one
 856     Symbol* constant_type = uncached_signature_ref_at(which);
 857     return Signature::basic_type(constant_type);
 858   }
 859   return tag.basic_type();
 860 }
 861 
 862 // Called to resolve constants in the constant pool and return an oop.
 863 // Some constant pool entries cache their resolved oop. This is also
 864 // called to create oops from constants to use in arguments for invokedynamic
 865 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 866                                            int index, int cache_index,
 867                                            bool* status_return, TRAPS) {
 868   oop result_oop = NULL;
 869   Handle throw_exception;
 870 
 871   if (cache_index == _possible_index_sentinel) {
 872     // It is possible that this constant is one which is cached in the objects.
 873     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 874     // FIXME: If bootstrap specifiers stress this code, consider putting in
 875     // a reverse index.  Binary search over a short array should do it.
 876     assert(index &gt; 0, &quot;valid index&quot;);
 877     cache_index = this_cp-&gt;cp_to_object_index(index);
 878   }
 879   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 880   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 881 
 882   if (cache_index &gt;= 0) {
 883     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 884     if (result_oop != NULL) {
 885       if (result_oop == Universe::the_null_sentinel()) {
 886         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 887         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 888         result_oop = NULL;
 889       }
 890       if (status_return != NULL)  (*status_return) = true;
 891       return result_oop;
 892       // That was easy...
 893     }
 894     index = this_cp-&gt;object_to_cp_index(cache_index);
 895   }
 896 
 897   jvalue prim_value;  // temp used only in a few cases below
 898 
 899   constantTag tag = this_cp-&gt;tag_at(index);
 900 
 901   if (status_return != NULL) {
 902     // don&#39;t trigger resolution if the constant might need it
 903     switch (tag.value()) {
 904     case JVM_CONSTANT_Class:
 905     {
 906       CPKlassSlot kslot = this_cp-&gt;klass_slot_at(index);
 907       int resolved_klass_index = kslot.resolved_klass_index();
 908       if (this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index) == NULL) {
 909         (*status_return) = false;
 910         return NULL;
 911       }
 912       // the klass is waiting in the CP; go get it
 913       break;
 914     }
 915     case JVM_CONSTANT_String:
 916     case JVM_CONSTANT_Integer:
 917     case JVM_CONSTANT_Float:
 918     case JVM_CONSTANT_Long:
 919     case JVM_CONSTANT_Double:
 920       // these guys trigger OOM at worst
 921       break;
 922     default:
 923       (*status_return) = false;
 924       return NULL;
 925     }
 926     // from now on there is either success or an OOME
 927     (*status_return) = true;
 928   }
 929 
 930   switch (tag.value()) {
 931 
 932   case JVM_CONSTANT_UnresolvedClass:
 933   case JVM_CONSTANT_UnresolvedClassInError:
 934   case JVM_CONSTANT_Class:
 935     {
 936       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 937       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 938       // ldc wants the java mirror.
 939       result_oop = resolved-&gt;java_mirror();
 940       break;
 941     }
 942 
 943   case JVM_CONSTANT_Dynamic:
 944     {
 945       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 946       BootstrapInfo bootstrap_specifier(this_cp, index);
 947 
 948       // The initial step in resolving an unresolved symbolic reference to a
 949       // dynamically-computed constant is to resolve the symbolic reference to a
 950       // method handle which will be the bootstrap method for the dynamically-computed
 951       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 952       // method fails, then a MethodHandleInError is stored at the corresponding
 953       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 954       // set a DynamicConstantInError here since any subsequent use of this
 955       // bootstrap method will encounter the resolution of MethodHandleInError.
 956       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 957       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 958       // for the bootstrap_specifier created above.
 959       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
 960       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);
 961       if (HAS_PENDING_EXCEPTION) {
 962         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 963         // will check for a LinkageError and store a DynamicConstantInError.
 964         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 965       }
 966       result_oop = bootstrap_specifier.resolved_value()();
 967       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 968       if (!is_reference_type(type)) {
 969         // Make sure the primitive value is properly boxed.
 970         // This is a JDK responsibility.
 971         const char* fail = NULL;
 972         if (result_oop == NULL) {
 973           fail = &quot;null result instead of box&quot;;
 974         } else if (!is_java_primitive(type)) {
 975           // FIXME: support value types via unboxing
 976           fail = &quot;can only handle references and primitives&quot;;
 977         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 978           fail = &quot;primitive is not properly boxed&quot;;
 979         }
 980         if (fail != NULL) {
 981           // Since this exception is not a LinkageError, throw exception
 982           // but do not save a DynamicInError resolution result.
 983           // See section 5.4.3 of the VM spec.
 984           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 985         }
 986       }
 987 
 988       LogTarget(Debug, methodhandles, condy) lt_condy;
 989       if (lt_condy.is_enabled()) {
 990         LogStream ls(lt_condy);
 991         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);
 992       }
 993       break;
 994     }
 995 
 996   case JVM_CONSTANT_String:
 997     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
 998     if (this_cp-&gt;is_pseudo_string_at(index)) {
 999       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1000       break;
1001     }
1002     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1003     break;
1004 
1005   case JVM_CONSTANT_DynamicInError:
1006   case JVM_CONSTANT_MethodHandleInError:
1007   case JVM_CONSTANT_MethodTypeInError:
1008     {
1009       throw_resolution_error(this_cp, index, CHECK_NULL);
1010       break;
1011     }
1012 
1013   case JVM_CONSTANT_MethodHandle:
1014     {
1015       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
1016       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1017       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1018       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1019       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1020       { ResourceMark rm(THREAD);
1021         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1022                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1023                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1024       }
1025 
1026       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1027 
1028       // Check constant pool method consistency
1029       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1030           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1031         ResourceMark rm(THREAD);
1032         stringStream ss;
1033         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;
1034                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());
1035         signature-&gt;print_as_signature_external_return_type(&amp;ss);
1036         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());
1037         signature-&gt;print_as_signature_external_parameters(&amp;ss);
1038         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,
1039                  index,
1040                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,
1041                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);
1042         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1043       }
1044 
1045       Klass* klass = this_cp-&gt;pool_holder();
1046       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1047                                                                    callee, name, signature,
1048                                                                    THREAD);
1049       result_oop = value();
1050       if (HAS_PENDING_EXCEPTION) {
1051         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1052       }
1053       break;
1054     }
1055 
1056   case JVM_CONSTANT_MethodType:
1057     {
1058       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1059       { ResourceMark rm(THREAD);
1060         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1061                               index, this_cp-&gt;method_type_index_at(index),
1062                               signature-&gt;as_C_string());
1063       }
1064       Klass* klass = this_cp-&gt;pool_holder();
1065       Handle value = SystemDictionary::find_method_handle_type(signature, klass, THREAD);
1066       result_oop = value();
1067       if (HAS_PENDING_EXCEPTION) {
1068         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1069       }
1070       break;
1071     }
1072 
1073   case JVM_CONSTANT_Integer:
1074     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1075     prim_value.i = this_cp-&gt;int_at(index);
1076     result_oop = java_lang_boxing_object::create(T_INT, &amp;prim_value, CHECK_NULL);
1077     break;
1078 
1079   case JVM_CONSTANT_Float:
1080     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1081     prim_value.f = this_cp-&gt;float_at(index);
1082     result_oop = java_lang_boxing_object::create(T_FLOAT, &amp;prim_value, CHECK_NULL);
1083     break;
1084 
1085   case JVM_CONSTANT_Long:
1086     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1087     prim_value.j = this_cp-&gt;long_at(index);
1088     result_oop = java_lang_boxing_object::create(T_LONG, &amp;prim_value, CHECK_NULL);
1089     break;
1090 
1091   case JVM_CONSTANT_Double:
1092     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1093     prim_value.d = this_cp-&gt;double_at(index);
1094     result_oop = java_lang_boxing_object::create(T_DOUBLE, &amp;prim_value, CHECK_NULL);
1095     break;
1096 
1097   default:
1098     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1099                               this_cp(), index, cache_index, tag.value()));
1100     assert(false, &quot;unexpected constant tag&quot;);
1101     break;
1102   }
1103 
1104   if (cache_index &gt;= 0) {
1105     // Benign race condition:  resolved_references may already be filled in.
1106     // The important thing here is that all threads pick up the same result.
1107     // It doesn&#39;t matter which racing thread wins, as long as only one
1108     // result is used by all threads, and all future queries.
1109     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1110     oop old_result = this_cp-&gt;resolved_references()
1111       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1112     if (old_result == NULL) {
1113       return result_oop;  // was installed
1114     } else {
1115       // Return the winning thread&#39;s result.  This can be different than
1116       // the result here for MethodHandles.
1117       if (old_result == Universe::the_null_sentinel())
1118         old_result = NULL;
1119       return old_result;
1120     }
1121   } else {
1122     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);
1123     return result_oop;
1124   }
1125 }
1126 
1127 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1128   Symbol* sym = unresolved_string_at(which);
1129   oop str = StringTable::intern(sym, CHECK_(NULL));
1130   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1131   return str;
1132 }
1133 
1134 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1135                                                     int start_arg, int end_arg,
1136                                                     objArrayHandle info, int pos,
1137                                                     bool must_resolve, Handle if_not_available,
1138                                                     TRAPS) {
1139   int argc;
1140   int limit = pos + end_arg - start_arg;
1141   // checks: index in range [0..this_cp-&gt;length),
1142   // tag at index, start..end in range [0..argc],
1143   // info array non-null, pos..limit in [0..info.length]
1144   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1145       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1146         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1147       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1148       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1149       (0 &gt; pos       || pos &gt; limit)         ||
1150       (info.is_null() || limit &gt; info-&gt;length())) {
1151     // An index or something else went wrong; throw an error.
1152     // Since this is an internal API, we don&#39;t expect this,
1153     // so we don&#39;t bother to craft a nice message.
1154     THROW_MSG(vmSymbols::java_lang_LinkageError(), &quot;bad BSM argument access&quot;);
1155   }
1156   // now we can loop safely
1157   int info_i = pos;
1158   for (int i = start_arg; i &lt; end_arg; i++) {
1159     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1160     oop arg_oop;
1161     if (must_resolve) {
1162       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1163     } else {
1164       bool found_it = false;
1165       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1166       if (!found_it)  arg_oop = if_not_available();
1167     }
1168     info-&gt;obj_at_put(info_i++, arg_oop);
1169   }
1170 }
1171 
1172 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1173   // If the string has already been interned, this entry will be non-null
1174   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
1175   assert(str != Universe::the_null_sentinel(), &quot;&quot;);
1176   if (str != NULL) return str;
1177   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1178   str = StringTable::intern(sym, CHECK_(NULL));
1179   this_cp-&gt;string_at_put(which, obj_index, str);
1180   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1181   return str;
1182 }
1183 
1184 
1185 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1186   // Names are interned, so we can compare Symbol*s directly
1187   Symbol* cp_name = klass_name_at(which);
1188   return (cp_name == k-&gt;name());
1189 }
1190 
1191 
1192 // Iterate over symbols and decrement ones which are Symbol*s
1193 // This is done during GC.
1194 // Only decrement the UTF8 symbols. Strings point to
1195 // these symbols but didn&#39;t increment the reference count.
1196 void ConstantPool::unreference_symbols() {
1197   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
1198     constantTag tag = tag_at(index);
1199     if (tag.is_symbol()) {
1200       symbol_at(index)-&gt;decrement_refcount();
1201     }
1202   }
1203 }
1204 
1205 
1206 // Compare this constant pool&#39;s entry at index1 to the constant pool
1207 // cp2&#39;s entry at index2.
1208 bool ConstantPool::compare_entry_to(int index1, const constantPoolHandle&amp; cp2,
1209        int index2, TRAPS) {
1210 
1211   // The error tags are equivalent to non-error tags when comparing
1212   jbyte t1 = tag_at(index1).non_error_value();
1213   jbyte t2 = cp2-&gt;tag_at(index2).non_error_value();
1214 
1215   if (t1 != t2) {
1216     // Not the same entry type so there is nothing else to check. Note
1217     // that this style of checking will consider resolved/unresolved
1218     // class pairs as different.
1219     // From the ConstantPool* API point of view, this is correct
1220     // behavior. See VM_RedefineClasses::merge_constant_pools() to see how this
1221     // plays out in the context of ConstantPool* merging.
1222     return false;
1223   }
1224 
1225   switch (t1) {
1226   case JVM_CONSTANT_Class:
1227   {
1228     Klass* k1 = klass_at(index1, CHECK_false);
1229     Klass* k2 = cp2-&gt;klass_at(index2, CHECK_false);
1230     if (k1 == k2) {
1231       return true;
1232     }
1233   } break;
1234 
1235   case JVM_CONSTANT_ClassIndex:
1236   {
1237     int recur1 = klass_index_at(index1);
1238     int recur2 = cp2-&gt;klass_index_at(index2);
1239     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1240     if (match) {
1241       return true;
1242     }
1243   } break;
1244 
1245   case JVM_CONSTANT_Double:
1246   {
1247     jdouble d1 = double_at(index1);
1248     jdouble d2 = cp2-&gt;double_at(index2);
1249     if (d1 == d2) {
1250       return true;
1251     }
1252   } break;
1253 
1254   case JVM_CONSTANT_Fieldref:
1255   case JVM_CONSTANT_InterfaceMethodref:
1256   case JVM_CONSTANT_Methodref:
1257   {
1258     int recur1 = uncached_klass_ref_index_at(index1);
1259     int recur2 = cp2-&gt;uncached_klass_ref_index_at(index2);
1260     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1261     if (match) {
1262       recur1 = uncached_name_and_type_ref_index_at(index1);
1263       recur2 = cp2-&gt;uncached_name_and_type_ref_index_at(index2);
1264       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1265       if (match) {
1266         return true;
1267       }
1268     }
1269   } break;
1270 
1271   case JVM_CONSTANT_Float:
1272   {
1273     jfloat f1 = float_at(index1);
1274     jfloat f2 = cp2-&gt;float_at(index2);
1275     if (f1 == f2) {
1276       return true;
1277     }
1278   } break;
1279 
1280   case JVM_CONSTANT_Integer:
1281   {
1282     jint i1 = int_at(index1);
1283     jint i2 = cp2-&gt;int_at(index2);
1284     if (i1 == i2) {
1285       return true;
1286     }
1287   } break;
1288 
1289   case JVM_CONSTANT_Long:
1290   {
1291     jlong l1 = long_at(index1);
1292     jlong l2 = cp2-&gt;long_at(index2);
1293     if (l1 == l2) {
1294       return true;
1295     }
1296   } break;
1297 
1298   case JVM_CONSTANT_NameAndType:
1299   {
1300     int recur1 = name_ref_index_at(index1);
1301     int recur2 = cp2-&gt;name_ref_index_at(index2);
1302     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1303     if (match) {
1304       recur1 = signature_ref_index_at(index1);
1305       recur2 = cp2-&gt;signature_ref_index_at(index2);
1306       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1307       if (match) {
1308         return true;
1309       }
1310     }
1311   } break;
1312 
1313   case JVM_CONSTANT_StringIndex:
1314   {
1315     int recur1 = string_index_at(index1);
1316     int recur2 = cp2-&gt;string_index_at(index2);
1317     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1318     if (match) {
1319       return true;
1320     }
1321   } break;
1322 
1323   case JVM_CONSTANT_UnresolvedClass:
1324   {
1325     Symbol* k1 = klass_name_at(index1);
1326     Symbol* k2 = cp2-&gt;klass_name_at(index2);
1327     if (k1 == k2) {
1328       return true;
1329     }
1330   } break;
1331 
1332   case JVM_CONSTANT_MethodType:
1333   {
1334     int k1 = method_type_index_at(index1);
1335     int k2 = cp2-&gt;method_type_index_at(index2);
1336     bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1337     if (match) {
1338       return true;
1339     }
1340   } break;
1341 
1342   case JVM_CONSTANT_MethodHandle:
1343   {
1344     int k1 = method_handle_ref_kind_at(index1);
1345     int k2 = cp2-&gt;method_handle_ref_kind_at(index2);
1346     if (k1 == k2) {
1347       int i1 = method_handle_index_at(index1);
1348       int i2 = cp2-&gt;method_handle_index_at(index2);
1349       bool match = compare_entry_to(i1, cp2, i2, CHECK_false);
1350       if (match) {
1351         return true;
1352       }
1353     }
1354   } break;
1355 
1356   case JVM_CONSTANT_Dynamic:
1357   {
1358     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1359     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1360     int i1 = bootstrap_methods_attribute_index(index1);
1361     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1362     // separate statements and variables because CHECK_false is used
1363     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1364     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1365     return (match_entry &amp;&amp; match_operand);
1366   } break;
1367 
1368   case JVM_CONSTANT_InvokeDynamic:
1369   {
1370     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1371     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1372     int i1 = bootstrap_methods_attribute_index(index1);
1373     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1374     // separate statements and variables because CHECK_false is used
1375     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1376     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1377     return (match_entry &amp;&amp; match_operand);
1378   } break;
1379 
1380   case JVM_CONSTANT_String:
1381   {
1382     Symbol* s1 = unresolved_string_at(index1);
1383     Symbol* s2 = cp2-&gt;unresolved_string_at(index2);
1384     if (s1 == s2) {
1385       return true;
1386     }
1387   } break;
1388 
1389   case JVM_CONSTANT_Utf8:
1390   {
1391     Symbol* s1 = symbol_at(index1);
1392     Symbol* s2 = cp2-&gt;symbol_at(index2);
1393     if (s1 == s2) {
1394       return true;
1395     }
1396   } break;
1397 
1398   // Invalid is used as the tag for the second constant pool entry
1399   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1400   // not be seen by itself.
1401   case JVM_CONSTANT_Invalid: // fall through
1402 
1403   default:
1404     ShouldNotReachHere();
1405     break;
1406   }
1407 
1408   return false;
1409 } // end compare_entry_to()
1410 
1411 
1412 // Resize the operands array with delta_len and delta_size.
1413 // Used in RedefineClasses for CP merge.
1414 void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {
1415   int old_len  = operand_array_length(operands());
1416   int new_len  = old_len + delta_len;
1417   int min_len  = (delta_len &gt; 0) ? old_len : new_len;
1418 
1419   int old_size = operands()-&gt;length();
1420   int new_size = old_size + delta_size;
1421   int min_size = (delta_size &gt; 0) ? old_size : new_size;
1422 
1423   ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1424   Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, new_size, CHECK);
1425 
1426   // Set index in the resized array for existing elements only
1427   for (int idx = 0; idx &lt; min_len; idx++) {
1428     int offset = operand_offset_at(idx);                       // offset in original array
1429     operand_offset_at_put(new_ops, idx, offset + 2*delta_len); // offset in resized array
1430   }
1431   // Copy the bootstrap specifiers only
1432   Copy::conjoint_memory_atomic(operands()-&gt;adr_at(2*old_len),
1433                                new_ops-&gt;adr_at(2*new_len),
1434                                (min_size - 2*min_len) * sizeof(u2));
1435   // Explicitly deallocate old operands array.
1436   // Note, it is not needed for 7u backport.
1437   if ( operands() != NULL) { // the safety check
1438     MetadataFactory::free_array&lt;u2&gt;(loader_data, operands());
1439   }
1440   set_operands(new_ops);
1441 } // end resize_operands()
1442 
1443 
1444 // Extend the operands array with the length and size of the ext_cp operands.
1445 // Used in RedefineClasses for CP merge.
1446 void ConstantPool::extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS) {
1447   int delta_len = operand_array_length(ext_cp-&gt;operands());
1448   if (delta_len == 0) {
1449     return; // nothing to do
1450   }
1451   int delta_size = ext_cp-&gt;operands()-&gt;length();
1452 
1453   assert(delta_len  &gt; 0 &amp;&amp; delta_size &gt; 0, &quot;extended operands array must be bigger&quot;);
1454 
1455   if (operand_array_length(operands()) == 0) {
1456     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1457     Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, delta_size, CHECK);
1458     // The first element index defines the offset of second part
1459     operand_offset_at_put(new_ops, 0, 2*delta_len); // offset in new array
1460     set_operands(new_ops);
1461   } else {
1462     resize_operands(delta_len, delta_size, CHECK);
1463   }
1464 
1465 } // end extend_operands()
1466 
1467 
1468 // Shrink the operands array to a smaller array with new_len length.
1469 // Used in RedefineClasses for CP merge.
1470 void ConstantPool::shrink_operands(int new_len, TRAPS) {
1471   int old_len = operand_array_length(operands());
1472   if (new_len == old_len) {
1473     return; // nothing to do
1474   }
1475   assert(new_len &lt; old_len, &quot;shrunken operands array must be smaller&quot;);
1476 
1477   int free_base  = operand_next_offset_at(new_len - 1);
1478   int delta_len  = new_len - old_len;
1479   int delta_size = 2*delta_len + free_base - operands()-&gt;length();
1480 
1481   resize_operands(delta_len, delta_size, CHECK);
1482 
1483 } // end shrink_operands()
1484 
1485 
1486 void ConstantPool::copy_operands(const constantPoolHandle&amp; from_cp,
1487                                  const constantPoolHandle&amp; to_cp,
1488                                  TRAPS) {
1489 
1490   int from_oplen = operand_array_length(from_cp-&gt;operands());
1491   int old_oplen  = operand_array_length(to_cp-&gt;operands());
1492   if (from_oplen != 0) {
1493     ClassLoaderData* loader_data = to_cp-&gt;pool_holder()-&gt;class_loader_data();
1494     // append my operands to the target&#39;s operands array
1495     if (old_oplen == 0) {
1496       // Can&#39;t just reuse from_cp&#39;s operand list because of deallocation issues
1497       int len = from_cp-&gt;operands()-&gt;length();
1498       Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, len, CHECK);
1499       Copy::conjoint_memory_atomic(
1500           from_cp-&gt;operands()-&gt;adr_at(0), new_ops-&gt;adr_at(0), len * sizeof(u2));
1501       to_cp-&gt;set_operands(new_ops);
1502     } else {
1503       int old_len  = to_cp-&gt;operands()-&gt;length();
1504       int from_len = from_cp-&gt;operands()-&gt;length();
1505       int old_off  = old_oplen * sizeof(u2);
1506       int from_off = from_oplen * sizeof(u2);
1507       // Use the metaspace for the destination constant pool
1508       Array&lt;u2&gt;* new_operands = MetadataFactory::new_array&lt;u2&gt;(loader_data, old_len + from_len, CHECK);
1509       int fillp = 0, len = 0;
1510       // first part of dest
1511       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(0),
1512                                    new_operands-&gt;adr_at(fillp),
1513                                    (len = old_off) * sizeof(u2));
1514       fillp += len;
1515       // first part of src
1516       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(0),
1517                                    new_operands-&gt;adr_at(fillp),
1518                                    (len = from_off) * sizeof(u2));
1519       fillp += len;
1520       // second part of dest
1521       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(old_off),
1522                                    new_operands-&gt;adr_at(fillp),
1523                                    (len = old_len - old_off) * sizeof(u2));
1524       fillp += len;
1525       // second part of src
1526       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(from_off),
1527                                    new_operands-&gt;adr_at(fillp),
1528                                    (len = from_len - from_off) * sizeof(u2));
1529       fillp += len;
1530       assert(fillp == new_operands-&gt;length(), &quot;&quot;);
1531 
1532       // Adjust indexes in the first part of the copied operands array.
1533       for (int j = 0; j &lt; from_oplen; j++) {
1534         int offset = operand_offset_at(new_operands, old_oplen + j);
1535         assert(offset == operand_offset_at(from_cp-&gt;operands(), j), &quot;correct copy&quot;);
1536         offset += old_len;  // every new tuple is preceded by old_len extra u2&#39;s
1537         operand_offset_at_put(new_operands, old_oplen + j, offset);
1538       }
1539 
1540       // replace target operands array with combined array
1541       to_cp-&gt;set_operands(new_operands);
1542     }
1543   }
1544 } // end copy_operands()
1545 
1546 
1547 // Copy this constant pool&#39;s entries at start_i to end_i (inclusive)
1548 // to the constant pool to_cp&#39;s entries starting at to_i. A total of
1549 // (end_i - start_i) + 1 entries are copied.
1550 void ConstantPool::copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i,
1551        const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
1552 
1553 
1554   int dest_i = to_i;  // leave original alone for debug purposes
1555 
1556   for (int src_i = start_i; src_i &lt;= end_i; /* see loop bottom */ ) {
1557     copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);
1558 
1559     switch (from_cp-&gt;tag_at(src_i).value()) {
1560     case JVM_CONSTANT_Double:
1561     case JVM_CONSTANT_Long:
1562       // double and long take two constant pool entries
1563       src_i += 2;
1564       dest_i += 2;
1565       break;
1566 
1567     default:
1568       // all others take one constant pool entry
1569       src_i++;
1570       dest_i++;
1571       break;
1572     }
1573   }
1574   copy_operands(from_cp, to_cp, CHECK);
1575 
1576 } // end copy_cp_to_impl()
1577 
1578 
1579 // Copy this constant pool&#39;s entry at from_i to the constant pool
1580 // to_cp&#39;s entry at to_i.
1581 void ConstantPool::copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i,
1582                                         const constantPoolHandle&amp; to_cp, int to_i,
1583                                         TRAPS) {
1584 
1585   int tag = from_cp-&gt;tag_at(from_i).value();
1586   switch (tag) {
1587   case JVM_CONSTANT_ClassIndex:
1588   {
1589     jint ki = from_cp-&gt;klass_index_at(from_i);
1590     to_cp-&gt;klass_index_at_put(to_i, ki);
1591   } break;
1592 
1593   case JVM_CONSTANT_Double:
1594   {
1595     jdouble d = from_cp-&gt;double_at(from_i);
1596     to_cp-&gt;double_at_put(to_i, d);
1597     // double takes two constant pool entries so init second entry&#39;s tag
1598     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1599   } break;
1600 
1601   case JVM_CONSTANT_Fieldref:
1602   {
1603     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1604     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1605     to_cp-&gt;field_at_put(to_i, class_index, name_and_type_index);
1606   } break;
1607 
1608   case JVM_CONSTANT_Float:
1609   {
1610     jfloat f = from_cp-&gt;float_at(from_i);
1611     to_cp-&gt;float_at_put(to_i, f);
1612   } break;
1613 
1614   case JVM_CONSTANT_Integer:
1615   {
1616     jint i = from_cp-&gt;int_at(from_i);
1617     to_cp-&gt;int_at_put(to_i, i);
1618   } break;
1619 
1620   case JVM_CONSTANT_InterfaceMethodref:
1621   {
1622     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1623     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1624     to_cp-&gt;interface_method_at_put(to_i, class_index, name_and_type_index);
1625   } break;
1626 
1627   case JVM_CONSTANT_Long:
1628   {
1629     jlong l = from_cp-&gt;long_at(from_i);
1630     to_cp-&gt;long_at_put(to_i, l);
1631     // long takes two constant pool entries so init second entry&#39;s tag
1632     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1633   } break;
1634 
1635   case JVM_CONSTANT_Methodref:
1636   {
1637     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1638     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1639     to_cp-&gt;method_at_put(to_i, class_index, name_and_type_index);
1640   } break;
1641 
1642   case JVM_CONSTANT_NameAndType:
1643   {
1644     int name_ref_index = from_cp-&gt;name_ref_index_at(from_i);
1645     int signature_ref_index = from_cp-&gt;signature_ref_index_at(from_i);
1646     to_cp-&gt;name_and_type_at_put(to_i, name_ref_index, signature_ref_index);
1647   } break;
1648 
1649   case JVM_CONSTANT_StringIndex:
1650   {
1651     jint si = from_cp-&gt;string_index_at(from_i);
1652     to_cp-&gt;string_index_at_put(to_i, si);
1653   } break;
1654 
1655   case JVM_CONSTANT_Class:
1656   case JVM_CONSTANT_UnresolvedClass:
1657   case JVM_CONSTANT_UnresolvedClassInError:
1658   {
1659     // Revert to JVM_CONSTANT_ClassIndex
1660     int name_index = from_cp-&gt;klass_slot_at(from_i).name_index();
1661     assert(from_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
1662     to_cp-&gt;klass_index_at_put(to_i, name_index);
1663   } break;
1664 
1665   case JVM_CONSTANT_String:
1666   {
1667     Symbol* s = from_cp-&gt;unresolved_string_at(from_i);
1668     to_cp-&gt;unresolved_string_at_put(to_i, s);
1669   } break;
1670 
1671   case JVM_CONSTANT_Utf8:
1672   {
1673     Symbol* s = from_cp-&gt;symbol_at(from_i);
1674     // Need to increase refcount, the old one will be thrown away and deferenced
1675     s-&gt;increment_refcount();
1676     to_cp-&gt;symbol_at_put(to_i, s);
1677   } break;
1678 
1679   case JVM_CONSTANT_MethodType:
1680   case JVM_CONSTANT_MethodTypeInError:
1681   {
1682     jint k = from_cp-&gt;method_type_index_at(from_i);
1683     to_cp-&gt;method_type_index_at_put(to_i, k);
1684   } break;
1685 
1686   case JVM_CONSTANT_MethodHandle:
1687   case JVM_CONSTANT_MethodHandleInError:
1688   {
1689     int k1 = from_cp-&gt;method_handle_ref_kind_at(from_i);
1690     int k2 = from_cp-&gt;method_handle_index_at(from_i);
1691     to_cp-&gt;method_handle_index_at_put(to_i, k1, k2);
1692   } break;
1693 
1694   case JVM_CONSTANT_Dynamic:
1695   case JVM_CONSTANT_DynamicInError:
1696   {
1697     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1698     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1699     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1700     to_cp-&gt;dynamic_constant_at_put(to_i, k1, k2);
1701   } break;
1702 
1703   case JVM_CONSTANT_InvokeDynamic:
1704   {
1705     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1706     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1707     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1708     to_cp-&gt;invoke_dynamic_at_put(to_i, k1, k2);
1709   } break;
1710 
1711   // Invalid is used as the tag for the second constant pool entry
1712   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1713   // not be seen by itself.
1714   case JVM_CONSTANT_Invalid: // fall through
1715 
1716   default:
1717   {
1718     ShouldNotReachHere();
1719   } break;
1720   }
1721 } // end copy_entry_to()
1722 
1723 // Search constant pool search_cp for an entry that matches this
1724 // constant pool&#39;s entry at pattern_i. Returns the index of a
1725 // matching entry or zero (0) if there is no matching entry.
1726 int ConstantPool::find_matching_entry(int pattern_i,
1727       const constantPoolHandle&amp; search_cp, TRAPS) {
1728 
1729   // index zero (0) is not used
1730   for (int i = 1; i &lt; search_cp-&gt;length(); i++) {
1731     bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);
1732     if (found) {
1733       return i;
1734     }
1735   }
1736 
1737   return 0;  // entry not found; return unused index zero (0)
1738 } // end find_matching_entry()
1739 
1740 
1741 // Compare this constant pool&#39;s bootstrap specifier at idx1 to the constant pool
1742 // cp2&#39;s bootstrap specifier at idx2.
1743 bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle&amp; cp2, int idx2, TRAPS) {
1744   int k1 = operand_bootstrap_method_ref_index_at(idx1);
1745   int k2 = cp2-&gt;operand_bootstrap_method_ref_index_at(idx2);
1746   bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1747 
1748   if (!match) {
1749     return false;
1750   }
1751   int argc = operand_argument_count_at(idx1);
1752   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1753     for (int j = 0; j &lt; argc; j++) {
1754       k1 = operand_argument_index_at(idx1, j);
1755       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1756       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1757       if (!match) {
1758         return false;
1759       }
1760     }
1761     return true;           // got through loop; all elements equal
1762   }
1763   return false;
1764 } // end compare_operand_to()
1765 
1766 // Search constant pool search_cp for a bootstrap specifier that matches
1767 // this constant pool&#39;s bootstrap specifier data at pattern_i index.
1768 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.
1769 int ConstantPool::find_matching_operand(int pattern_i,
1770                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1771   for (int i = 0; i &lt; search_len; i++) {
1772     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1773     if (found) {
1774       return i;
1775     }
1776   }
1777   return -1;  // bootstrap specifier data not found; return unused index (-1)
1778 } // end find_matching_operand()
1779 
1780 
1781 #ifndef PRODUCT
1782 
1783 const char* ConstantPool::printable_name_at(int which) {
1784 
1785   constantTag tag = tag_at(which);
1786 
1787   if (tag.is_string()) {
1788     return string_at_noresolve(which);
1789   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1790     return klass_name_at(which)-&gt;as_C_string();
1791   } else if (tag.is_symbol()) {
1792     return symbol_at(which)-&gt;as_C_string();
1793   }
1794   return &quot;&quot;;
1795 }
1796 
1797 #endif // PRODUCT
1798 
1799 
1800 // JVMTI GetConstantPool support
1801 
1802 // For debugging of constant pool
1803 const bool debug_cpool = false;
1804 
1805 #define DBG(code) do { if (debug_cpool) { (code); } } while(0)
1806 
1807 static void print_cpool_bytes(jint cnt, u1 *bytes) {
1808   const char* WARN_MSG = &quot;Must not be such entry!&quot;;
1809   jint size = 0;
1810   u2   idx1, idx2;
1811 
1812   for (jint idx = 1; idx &lt; cnt; idx++) {
1813     jint ent_size = 0;
1814     u1   tag  = *bytes++;
1815     size++;                       // count tag
1816 
1817     printf(&quot;const #%03d, tag: %02d &quot;, idx, tag);
1818     switch(tag) {
1819       case JVM_CONSTANT_Invalid: {
1820         printf(&quot;Invalid&quot;);
1821         break;
1822       }
1823       case JVM_CONSTANT_Unicode: {
1824         printf(&quot;Unicode      %s&quot;, WARN_MSG);
1825         break;
1826       }
1827       case JVM_CONSTANT_Utf8: {
1828         u2 len = Bytes::get_Java_u2(bytes);
1829         char str[128];
1830         if (len &gt; 127) {
1831            len = 127;
1832         }
1833         strncpy(str, (char *) (bytes+2), len);
1834         str[len] = &#39;\0&#39;;
1835         printf(&quot;Utf8          \&quot;%s\&quot;&quot;, str);
1836         ent_size = 2 + len;
1837         break;
1838       }
1839       case JVM_CONSTANT_Integer: {
1840         u4 val = Bytes::get_Java_u4(bytes);
1841         printf(&quot;int          %d&quot;, *(int *) &amp;val);
1842         ent_size = 4;
1843         break;
1844       }
1845       case JVM_CONSTANT_Float: {
1846         u4 val = Bytes::get_Java_u4(bytes);
1847         printf(&quot;float        %5.3ff&quot;, *(float *) &amp;val);
1848         ent_size = 4;
1849         break;
1850       }
1851       case JVM_CONSTANT_Long: {
1852         u8 val = Bytes::get_Java_u8(bytes);
1853         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1854         ent_size = 8;
1855         idx++; // Long takes two cpool slots
1856         break;
1857       }
1858       case JVM_CONSTANT_Double: {
1859         u8 val = Bytes::get_Java_u8(bytes);
1860         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1861         ent_size = 8;
1862         idx++; // Double takes two cpool slots
1863         break;
1864       }
1865       case JVM_CONSTANT_Class: {
1866         idx1 = Bytes::get_Java_u2(bytes);
1867         printf(&quot;class        #%03d&quot;, idx1);
1868         ent_size = 2;
1869         break;
1870       }
<a name="12" id="anc12"></a>





1871       case JVM_CONSTANT_String: {
1872         idx1 = Bytes::get_Java_u2(bytes);
1873         printf(&quot;String       #%03d&quot;, idx1);
1874         ent_size = 2;
1875         break;
1876       }
1877       case JVM_CONSTANT_Fieldref: {
1878         idx1 = Bytes::get_Java_u2(bytes);
1879         idx2 = Bytes::get_Java_u2(bytes+2);
1880         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1881         ent_size = 4;
1882         break;
1883       }
1884       case JVM_CONSTANT_Methodref: {
1885         idx1 = Bytes::get_Java_u2(bytes);
1886         idx2 = Bytes::get_Java_u2(bytes+2);
1887         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1888         ent_size = 4;
1889         break;
1890       }
1891       case JVM_CONSTANT_InterfaceMethodref: {
1892         idx1 = Bytes::get_Java_u2(bytes);
1893         idx2 = Bytes::get_Java_u2(bytes+2);
1894         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1895         ent_size = 4;
1896         break;
1897       }
1898       case JVM_CONSTANT_NameAndType: {
1899         idx1 = Bytes::get_Java_u2(bytes);
1900         idx2 = Bytes::get_Java_u2(bytes+2);
1901         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1902         ent_size = 4;
1903         break;
1904       }
1905       case JVM_CONSTANT_ClassIndex: {
1906         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1907         break;
1908       }
1909       case JVM_CONSTANT_UnresolvedClass: {
1910         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1911         break;
1912       }
<a name="13" id="anc13"></a>



1913       case JVM_CONSTANT_UnresolvedClassInError: {
1914         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1915         break;
1916       }
1917       case JVM_CONSTANT_StringIndex: {
1918         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1919         break;
1920       }
1921     }
1922     printf(&quot;;\n&quot;);
1923     bytes += ent_size;
1924     size  += ent_size;
1925   }
1926   printf(&quot;Cpool size: %d\n&quot;, size);
1927   fflush(0);
1928   return;
1929 } /* end print_cpool_bytes */
1930 
1931 
1932 // Returns size of constant pool entry.
1933 jint ConstantPool::cpool_entry_size(jint idx) {
1934   switch(tag_at(idx).value()) {
1935     case JVM_CONSTANT_Invalid:
1936     case JVM_CONSTANT_Unicode:
1937       return 1;
1938 
1939     case JVM_CONSTANT_Utf8:
1940       return 3 + symbol_at(idx)-&gt;utf8_length();
1941 
1942     case JVM_CONSTANT_Class:
1943     case JVM_CONSTANT_String:
1944     case JVM_CONSTANT_ClassIndex:
1945     case JVM_CONSTANT_UnresolvedClass:
1946     case JVM_CONSTANT_UnresolvedClassInError:
1947     case JVM_CONSTANT_StringIndex:
1948     case JVM_CONSTANT_MethodType:
1949     case JVM_CONSTANT_MethodTypeInError:
1950       return 3;
1951 
1952     case JVM_CONSTANT_MethodHandle:
1953     case JVM_CONSTANT_MethodHandleInError:
1954       return 4; //tag, ref_kind, ref_index
1955 
1956     case JVM_CONSTANT_Integer:
1957     case JVM_CONSTANT_Float:
1958     case JVM_CONSTANT_Fieldref:
1959     case JVM_CONSTANT_Methodref:
1960     case JVM_CONSTANT_InterfaceMethodref:
1961     case JVM_CONSTANT_NameAndType:
1962       return 5;
1963 
1964     case JVM_CONSTANT_Dynamic:
1965     case JVM_CONSTANT_DynamicInError:
1966     case JVM_CONSTANT_InvokeDynamic:
1967       // u1 tag, u2 bsm, u2 nt
1968       return 5;
1969 
1970     case JVM_CONSTANT_Long:
1971     case JVM_CONSTANT_Double:
1972       return 9;
1973   }
1974   assert(false, &quot;cpool_entry_size: Invalid constant pool entry tag&quot;);
1975   return 1;
1976 } /* end cpool_entry_size */
1977 
1978 
1979 // SymbolHashMap is used to find a constant pool index from a string.
1980 // This function fills in SymbolHashMaps, one for utf8s and one for
1981 // class names, returns size of the cpool raw bytes.
1982 jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,
1983                                           SymbolHashMap *classmap) {
1984   jint size = 0;
1985 
1986   for (u2 idx = 1; idx &lt; length(); idx++) {
1987     u2 tag = tag_at(idx).value();
1988     size += cpool_entry_size(idx);
1989 
1990     switch(tag) {
1991       case JVM_CONSTANT_Utf8: {
1992         Symbol* sym = symbol_at(idx);
1993         symmap-&gt;add_entry(sym, idx);
1994         DBG(printf(&quot;adding symbol entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
1995         break;
1996       }
1997       case JVM_CONSTANT_Class:
1998       case JVM_CONSTANT_UnresolvedClass:
1999       case JVM_CONSTANT_UnresolvedClassInError: {
2000         Symbol* sym = klass_name_at(idx);
2001         classmap-&gt;add_entry(sym, idx);
2002         DBG(printf(&quot;adding class entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2003         break;
2004       }
2005       case JVM_CONSTANT_Long:
2006       case JVM_CONSTANT_Double: {
2007         idx++; // Both Long and Double take two cpool slots
2008         break;
2009       }
2010     }
2011   }
2012   return size;
2013 } /* end hash_utf8_entries_to */
2014 
2015 
2016 // Copy cpool bytes.
2017 // Returns:
2018 //    0, in case of OutOfMemoryError
2019 //   -1, in case of internal error
2020 //  &gt; 0, count of the raw cpool bytes that have been copied
2021 int ConstantPool::copy_cpool_bytes(int cpool_size,
2022                                           SymbolHashMap* tbl,
2023                                           unsigned char *bytes) {
2024   u2   idx1, idx2;
2025   jint size  = 0;
2026   jint cnt   = length();
2027   unsigned char *start_bytes = bytes;
2028 
2029   for (jint idx = 1; idx &lt; cnt; idx++) {
2030     u1   tag      = tag_at(idx).value();
2031     jint ent_size = cpool_entry_size(idx);
2032 
2033     assert(size + ent_size &lt;= cpool_size, &quot;Size mismatch&quot;);
2034 
2035     *bytes = tag;
2036     DBG(printf(&quot;#%03hd tag=%03hd, &quot;, (short)idx, (short)tag));
2037     switch(tag) {
2038       case JVM_CONSTANT_Invalid: {
2039         DBG(printf(&quot;JVM_CONSTANT_Invalid&quot;));
2040         break;
2041       }
2042       case JVM_CONSTANT_Unicode: {
2043         assert(false, &quot;Wrong constant pool tag: JVM_CONSTANT_Unicode&quot;);
2044         DBG(printf(&quot;JVM_CONSTANT_Unicode&quot;));
2045         break;
2046       }
2047       case JVM_CONSTANT_Utf8: {
2048         Symbol* sym = symbol_at(idx);
2049         char*     str = sym-&gt;as_utf8();
2050         // Warning! It&#39;s crashing on x86 with len = sym-&gt;utf8_length()
2051         int       len = (int) strlen(str);
2052         Bytes::put_Java_u2((address) (bytes+1), (u2) len);
2053         for (int i = 0; i &lt; len; i++) {
2054             bytes[3+i] = (u1) str[i];
2055         }
2056         DBG(printf(&quot;JVM_CONSTANT_Utf8: %s &quot;, str));
2057         break;
2058       }
2059       case JVM_CONSTANT_Integer: {
2060         jint val = int_at(idx);
2061         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2062         break;
2063       }
2064       case JVM_CONSTANT_Float: {
2065         jfloat val = float_at(idx);
2066         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2067         break;
2068       }
2069       case JVM_CONSTANT_Long: {
2070         jlong val = long_at(idx);
2071         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2072         idx++;             // Long takes two cpool slots
2073         break;
2074       }
2075       case JVM_CONSTANT_Double: {
2076         jdouble val = double_at(idx);
2077         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2078         idx++;             // Double takes two cpool slots
2079         break;
2080       }
2081       case JVM_CONSTANT_Class:
2082       case JVM_CONSTANT_UnresolvedClass:
2083       case JVM_CONSTANT_UnresolvedClassInError: {
<a name="14" id="anc14"></a>
2084         *bytes = JVM_CONSTANT_Class;
2085         Symbol* sym = klass_name_at(idx);
2086         idx1 = tbl-&gt;symbol_to_value(sym);
2087         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2088         Bytes::put_Java_u2((address) (bytes+1), idx1);
2089         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2090         break;
2091       }
2092       case JVM_CONSTANT_String: {
2093         *bytes = JVM_CONSTANT_String;
2094         Symbol* sym = unresolved_string_at(idx);
2095         idx1 = tbl-&gt;symbol_to_value(sym);
2096         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2097         Bytes::put_Java_u2((address) (bytes+1), idx1);
2098         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2099         break;
2100       }
2101       case JVM_CONSTANT_Fieldref:
2102       case JVM_CONSTANT_Methodref:
2103       case JVM_CONSTANT_InterfaceMethodref: {
2104         idx1 = uncached_klass_ref_index_at(idx);
2105         idx2 = uncached_name_and_type_ref_index_at(idx);
2106         Bytes::put_Java_u2((address) (bytes+1), idx1);
2107         Bytes::put_Java_u2((address) (bytes+3), idx2);
2108         DBG(printf(&quot;JVM_CONSTANT_Methodref: %hd %hd&quot;, idx1, idx2));
2109         break;
2110       }
2111       case JVM_CONSTANT_NameAndType: {
2112         idx1 = name_ref_index_at(idx);
2113         idx2 = signature_ref_index_at(idx);
2114         Bytes::put_Java_u2((address) (bytes+1), idx1);
2115         Bytes::put_Java_u2((address) (bytes+3), idx2);
2116         DBG(printf(&quot;JVM_CONSTANT_NameAndType: %hd %hd&quot;, idx1, idx2));
2117         break;
2118       }
2119       case JVM_CONSTANT_ClassIndex: {
2120         *bytes = JVM_CONSTANT_Class;
2121         idx1 = klass_index_at(idx);
2122         Bytes::put_Java_u2((address) (bytes+1), idx1);
2123         DBG(printf(&quot;JVM_CONSTANT_ClassIndex: %hd&quot;, idx1));
2124         break;
2125       }
2126       case JVM_CONSTANT_StringIndex: {
2127         *bytes = JVM_CONSTANT_String;
2128         idx1 = string_index_at(idx);
2129         Bytes::put_Java_u2((address) (bytes+1), idx1);
2130         DBG(printf(&quot;JVM_CONSTANT_StringIndex: %hd&quot;, idx1));
2131         break;
2132       }
2133       case JVM_CONSTANT_MethodHandle:
2134       case JVM_CONSTANT_MethodHandleInError: {
2135         *bytes = JVM_CONSTANT_MethodHandle;
2136         int kind = method_handle_ref_kind_at(idx);
2137         idx1 = method_handle_index_at(idx);
2138         *(bytes+1) = (unsigned char) kind;
2139         Bytes::put_Java_u2((address) (bytes+2), idx1);
2140         DBG(printf(&quot;JVM_CONSTANT_MethodHandle: %d %hd&quot;, kind, idx1));
2141         break;
2142       }
2143       case JVM_CONSTANT_MethodType:
2144       case JVM_CONSTANT_MethodTypeInError: {
2145         *bytes = JVM_CONSTANT_MethodType;
2146         idx1 = method_type_index_at(idx);
2147         Bytes::put_Java_u2((address) (bytes+1), idx1);
2148         DBG(printf(&quot;JVM_CONSTANT_MethodType: %hd&quot;, idx1));
2149         break;
2150       }
2151       case JVM_CONSTANT_Dynamic:
2152       case JVM_CONSTANT_DynamicInError: {
2153         *bytes = tag;
2154         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2155         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2156         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2157         Bytes::put_Java_u2((address) (bytes+1), idx1);
2158         Bytes::put_Java_u2((address) (bytes+3), idx2);
2159         DBG(printf(&quot;JVM_CONSTANT_Dynamic: %hd %hd&quot;, idx1, idx2));
2160         break;
2161       }
2162       case JVM_CONSTANT_InvokeDynamic: {
2163         *bytes = tag;
2164         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2165         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2166         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2167         Bytes::put_Java_u2((address) (bytes+1), idx1);
2168         Bytes::put_Java_u2((address) (bytes+3), idx2);
2169         DBG(printf(&quot;JVM_CONSTANT_InvokeDynamic: %hd %hd&quot;, idx1, idx2));
2170         break;
2171       }
2172     }
2173     DBG(printf(&quot;\n&quot;));
2174     bytes += ent_size;
2175     size  += ent_size;
2176   }
2177   assert(size == cpool_size, &quot;Size mismatch&quot;);
2178 
2179   // Keep temorarily for debugging until it&#39;s stable.
2180   DBG(print_cpool_bytes(cnt, start_bytes));
2181   return (int)(bytes - start_bytes);
2182 } /* end copy_cpool_bytes */
2183 
2184 #undef DBG
2185 
2186 
2187 void ConstantPool::set_on_stack(const bool value) {
2188   if (value) {
2189     // Only record if it&#39;s not already set.
2190     if (!on_stack()) {
2191       assert(!is_shared(), &quot;should always be set for shared constant pools&quot;);
2192       _flags |= _on_stack;
2193       MetadataOnStackMark::record(this);
2194     }
2195   } else {
2196     // Clearing is done single-threadedly.
2197     if (!is_shared()) {
2198       _flags &amp;= ~_on_stack;
2199     }
2200   }
2201 }
2202 
2203 // JSR 292 support for patching constant pool oops after the class is linked and
2204 // the oop array for resolved references are created.
2205 // We can&#39;t do this during classfile parsing, which is how the other indexes are
2206 // patched.  The other patches are applied early for some error checking
2207 // so only defer the pseudo_strings.
2208 void ConstantPool::patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches) {
2209   for (int index = 1; index &lt; cp_patches-&gt;length(); index++) { // Index 0 is unused
2210     Handle patch = cp_patches-&gt;at(index);
2211     if (patch.not_null()) {
2212       assert (tag_at(index).is_string(), &quot;should only be string left&quot;);
2213       // Patching a string means pre-resolving it.
2214       // The spelling in the constant pool is ignored.
2215       // The constant reference may be any object whatever.
2216       // If it is not a real interned string, the constant is referred
2217       // to as a &quot;pseudo-string&quot;, and must be presented to the CP
2218       // explicitly, because it may require scavenging.
2219       int obj_index = cp_to_object_index(index);
2220       pseudo_string_at_put(index, obj_index, patch());
2221      DEBUG_ONLY(cp_patches-&gt;at_put(index, Handle());)
2222     }
2223   }
2224 #ifdef ASSERT
2225   // Ensure that all the patches have been used.
2226   for (int index = 0; index &lt; cp_patches-&gt;length(); index++) {
2227     assert(cp_patches-&gt;at(index).is_null(),
2228            &quot;Unused constant pool patch at %d in class file %s&quot;,
2229            index,
2230            pool_holder()-&gt;external_name());
2231   }
2232 #endif // ASSERT
2233 }
2234 
2235 // Printing
2236 
2237 void ConstantPool::print_on(outputStream* st) const {
2238   assert(is_constantPool(), &quot;must be constantPool&quot;);
2239   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2240   if (flags() != 0) {
2241     st-&gt;print(&quot; - flags: 0x%x&quot;, flags());
2242     if (has_preresolution()) st-&gt;print(&quot; has_preresolution&quot;);
2243     if (on_stack()) st-&gt;print(&quot; on_stack&quot;);
2244     st-&gt;cr();
2245   }
2246   if (pool_holder() != NULL) {
2247     st-&gt;print_cr(&quot; - holder: &quot; INTPTR_FORMAT, p2i(pool_holder()));
2248   }
2249   st-&gt;print_cr(&quot; - cache: &quot; INTPTR_FORMAT, p2i(cache()));
2250   st-&gt;print_cr(&quot; - resolved_references: &quot; INTPTR_FORMAT, p2i(resolved_references()));
2251   st-&gt;print_cr(&quot; - reference_map: &quot; INTPTR_FORMAT, p2i(reference_map()));
2252   st-&gt;print_cr(&quot; - resolved_klasses: &quot; INTPTR_FORMAT, p2i(resolved_klasses()));
2253 
2254   for (int index = 1; index &lt; length(); index++) {      // Index 0 is unused
2255     ((ConstantPool*)this)-&gt;print_entry_on(index, st);
2256     switch (tag_at(index).value()) {
2257       case JVM_CONSTANT_Long :
2258       case JVM_CONSTANT_Double :
2259         index++;   // Skip entry following eigth-byte constant
2260     }
2261 
2262   }
2263   st-&gt;cr();
2264 }
2265 
2266 // Print one constant pool entry
2267 void ConstantPool::print_entry_on(const int index, outputStream* st) {
2268   EXCEPTION_MARK;
2269   st-&gt;print(&quot; - %3d : &quot;, index);
2270   tag_at(index).print_on(st);
2271   st-&gt;print(&quot; : &quot;);
2272   switch (tag_at(index).value()) {
2273     case JVM_CONSTANT_Class :
2274       { Klass* k = klass_at(index, CATCH);
2275         guarantee(k != NULL, &quot;need klass&quot;);
2276         k-&gt;print_value_on(st);
2277         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(k));
2278       }
2279       break;
2280     case JVM_CONSTANT_Fieldref :
2281     case JVM_CONSTANT_Methodref :
2282     case JVM_CONSTANT_InterfaceMethodref :
2283       st-&gt;print(&quot;klass_index=%d&quot;, uncached_klass_ref_index_at(index));
2284       st-&gt;print(&quot; name_and_type_index=%d&quot;, uncached_name_and_type_ref_index_at(index));
2285       break;
2286     case JVM_CONSTANT_String :
2287       if (is_pseudo_string_at(index)) {
2288         oop anObj = pseudo_string_at(index);
2289         anObj-&gt;print_value_on(st);
2290         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(anObj));
2291       } else {
2292         unresolved_string_at(index)-&gt;print_value_on(st);
2293       }
2294       break;
2295     case JVM_CONSTANT_Integer :
2296       st-&gt;print(&quot;%d&quot;, int_at(index));
2297       break;
2298     case JVM_CONSTANT_Float :
2299       st-&gt;print(&quot;%f&quot;, float_at(index));
2300       break;
2301     case JVM_CONSTANT_Long :
2302       st-&gt;print_jlong(long_at(index));
2303       break;
2304     case JVM_CONSTANT_Double :
2305       st-&gt;print(&quot;%lf&quot;, double_at(index));
2306       break;
2307     case JVM_CONSTANT_NameAndType :
2308       st-&gt;print(&quot;name_index=%d&quot;, name_ref_index_at(index));
2309       st-&gt;print(&quot; signature_index=%d&quot;, signature_ref_index_at(index));
2310       break;
2311     case JVM_CONSTANT_Utf8 :
2312       symbol_at(index)-&gt;print_value_on(st);
2313       break;
2314     case JVM_CONSTANT_ClassIndex: {
2315         int name_index = *int_at_addr(index);
2316         st-&gt;print(&quot;klass_index=%d &quot;, name_index);
2317         symbol_at(name_index)-&gt;print_value_on(st);
2318       }
2319       break;
2320     case JVM_CONSTANT_UnresolvedClass :               // fall-through
2321     case JVM_CONSTANT_UnresolvedClassInError: {
2322         CPKlassSlot kslot = klass_slot_at(index);
2323         int resolved_klass_index = kslot.resolved_klass_index();
2324         int name_index = kslot.name_index();
2325         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
2326 
2327         Klass* klass = resolved_klasses()-&gt;at(resolved_klass_index);
2328         if (klass != NULL) {
2329           klass-&gt;print_value_on(st);
2330         } else {
2331           symbol_at(name_index)-&gt;print_value_on(st);
2332         }
2333       }
2334       break;
2335     case JVM_CONSTANT_MethodHandle :
2336     case JVM_CONSTANT_MethodHandleInError :
2337       st-&gt;print(&quot;ref_kind=%d&quot;, method_handle_ref_kind_at(index));
2338       st-&gt;print(&quot; ref_index=%d&quot;, method_handle_index_at(index));
2339       break;
2340     case JVM_CONSTANT_MethodType :
2341     case JVM_CONSTANT_MethodTypeInError :
2342       st-&gt;print(&quot;signature_index=%d&quot;, method_type_index_at(index));
2343       break;
2344     case JVM_CONSTANT_Dynamic :
2345     case JVM_CONSTANT_DynamicInError :
2346       {
2347         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2348         st-&gt;print(&quot; type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2349         int argc = bootstrap_argument_count_at(index);
2350         if (argc &gt; 0) {
2351           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2352             int arg = bootstrap_argument_index_at(index, arg_i);
2353             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2354           }
2355           st-&gt;print(&quot;}&quot;);
2356         }
2357       }
2358       break;
2359     case JVM_CONSTANT_InvokeDynamic :
2360       {
2361         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2362         st-&gt;print(&quot; name_and_type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2363         int argc = bootstrap_argument_count_at(index);
2364         if (argc &gt; 0) {
2365           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2366             int arg = bootstrap_argument_index_at(index, arg_i);
2367             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2368           }
2369           st-&gt;print(&quot;}&quot;);
2370         }
2371       }
2372       break;
2373     default:
2374       ShouldNotReachHere();
2375       break;
2376   }
2377   st-&gt;cr();
2378 }
2379 
2380 void ConstantPool::print_value_on(outputStream* st) const {
2381   assert(is_constantPool(), &quot;must be constantPool&quot;);
2382   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2383   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2384   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2385   print_address_on(st);
2386   if (pool_holder() != NULL) {
2387     st-&gt;print(&quot; for &quot;);
2388     pool_holder()-&gt;print_value_on(st);
2389     bool extra = (pool_holder()-&gt;constants() != this);
2390     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2391   }
2392   if (cache() != NULL) {
2393     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2394   }
2395 }
2396 
2397 // Verification
2398 
2399 void ConstantPool::verify_on(outputStream* st) {
2400   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2401   for (int i = 0; i&lt; length();  i++) {
2402     constantTag tag = tag_at(i);
2403     if (tag.is_klass() || tag.is_unresolved_klass()) {
2404       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2405     } else if (tag.is_symbol()) {
2406       CPSlot entry = slot_at(i);
2407       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2408     } else if (tag.is_string()) {
2409       CPSlot entry = slot_at(i);
2410       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2411     }
2412   }
2413   if (pool_holder() != NULL) {
2414     // Note: pool_holder() can be NULL in temporary constant pools
2415     // used during constant pool merging
2416     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
2417   }
2418 }
2419 
2420 
2421 SymbolHashMap::~SymbolHashMap() {
2422   SymbolHashMapEntry* next;
2423   for (int i = 0; i &lt; _table_size; i++) {
2424     for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {
2425       next = cur-&gt;next();
2426       delete(cur);
2427     }
2428   }
2429   FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);
2430 }
2431 
2432 void SymbolHashMap::add_entry(Symbol* sym, u2 value) {
2433   char *str = sym-&gt;as_utf8();
2434   unsigned int hash = compute_hash(str, sym-&gt;utf8_length());
2435   unsigned int index = hash % table_size();
2436 
2437   // check if already in map
2438   // we prefer the first entry since it is more likely to be what was used in
2439   // the class file
2440   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2441     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2442     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2443         return;  // already there
2444     }
2445   }
2446 
2447   SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);
2448   entry-&gt;set_next(bucket(index));
2449   _buckets[index].set_entry(entry);
2450   assert(entry-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2451 }
2452 
2453 SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {
2454   assert(sym != NULL, &quot;SymbolHashMap::find_entry - symbol is NULL&quot;);
2455   char *str = sym-&gt;as_utf8();
2456   int   len = sym-&gt;utf8_length();
2457   unsigned int hash = SymbolHashMap::compute_hash(str, len);
2458   unsigned int index = hash % table_size();
2459   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2460     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2461     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2462       return en;
2463     }
2464   }
2465   return NULL;
2466 }
2467 
2468 void SymbolHashMap::initialize_table(int table_size) {
2469   _table_size = table_size;
2470   _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);
2471   for (int index = 0; index &lt; table_size; index++) {
2472     _buckets[index].clear();
2473   }
2474 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
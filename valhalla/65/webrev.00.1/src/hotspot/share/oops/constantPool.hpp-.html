<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_CONSTANTPOOL_HPP
  26 #define SHARE_OOPS_CONSTANTPOOL_HPP
  27 
  28 #include &quot;memory/allocation.hpp&quot;
  29 #include &quot;oops/arrayOop.hpp&quot;
  30 #include &quot;oops/cpCache.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oopHandle.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;oops/typeArrayOop.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/bytes.hpp&quot;
  38 #include &quot;utilities/constantTag.hpp&quot;
  39 
  40 // A ConstantPool is an array containing class constants as described in the
  41 // class file.
  42 //
  43 // Most of the constant pool entries are written during class parsing, which
  44 // is safe.  For klass types, the constant pool entry is
  45 // modified when the entry is resolved.  If a klass constant pool
  46 // entry is read without a lock, only the resolved state guarantees that
  47 // the entry in the constant pool is a klass object and not a Symbol*.
  48 
  49 class SymbolHashMap;
  50 
  51 class CPSlot {
  52  friend class ConstantPool;
  53   intptr_t _ptr;
  54   enum TagBits  {_pseudo_bit = 1};
  55  public:
  56 
  57   CPSlot(intptr_t ptr): _ptr(ptr) {}
  58   CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}
  59 
  60   intptr_t value()   { return _ptr; }
  61   bool is_pseudo_string() { return (_ptr &amp; _pseudo_bit) != 0; }
  62 
  63   Symbol* get_symbol() {
  64     return (Symbol*)(_ptr &amp; ~_pseudo_bit);
  65   }
  66 };
  67 
  68 // This represents a JVM_CONSTANT_Class, JVM_CONSTANT_UnresolvedClass, or
  69 // JVM_CONSTANT_UnresolvedClassInError slot in the constant pool.
  70 class CPKlassSlot {
  71   // cp-&gt;symbol_at(_name_index) gives the name of the class.
  72   int _name_index;
  73 
  74   // cp-&gt;_resolved_klasses-&gt;at(_resolved_klass_index) gives the Klass* for the class.
  75   int _resolved_klass_index;
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
 113   u2              _major_version;        // major version number of class file
 114   u2              _minor_version;        // minor version number of class file
 115 
 116   // Constant pool index to the utf8 entry of the Generic signature,
 117   // or 0 if none.
 118   u2              _generic_signature_index;
 119   // Constant pool index to the utf8 entry for the name of source file
 120   // containing this klass, 0 if not specified.
 121   u2              _source_file_name_index;
 122 
 123   enum {
 124     _has_preresolution    = 1,       // Flags
 125     _on_stack             = 2,
 126     _is_shared            = 4,
 127     _has_dynamic_constant = 8
 128   };
 129 
 130   u2              _flags;  // old fashioned bit twiddling
 131 
 132   int             _length; // number of elements in the array
 133 
 134   union {
 135     // set for CDS to restore resolved references
 136     int                _resolved_reference_length;
 137     // keeps version number for redefined classes (used in backtrace)
 138     int                _version;
 139   } _saved;
 140 
 141   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 142   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 143   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 144 
 145   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 146 
 147   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 148 
 149   u2 flags() const                             { return _flags; }
 150   void set_flags(u2 f)                         { _flags = f; }
 151 
 152  private:
 153   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 154 
 155   CPSlot slot_at(int which) const;
 156 
 157   void slot_at_put(int which, CPSlot s) const {
 158     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 159     assert(s.value() != 0, &quot;Caught something&quot;);
 160     *(intptr_t*)&amp;base()[which] = s.value();
 161   }
 162   intptr_t* obj_at_addr(int which) const {
 163     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 164     return (intptr_t*) &amp;base()[which];
 165   }
 166 
 167   jint* int_at_addr(int which) const {
 168     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 169     return (jint*) &amp;base()[which];
 170   }
 171 
 172   jlong* long_at_addr(int which) const {
 173     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 174     return (jlong*) &amp;base()[which];
 175   }
 176 
 177   jfloat* float_at_addr(int which) const {
 178     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 179     return (jfloat*) &amp;base()[which];
 180   }
 181 
 182   jdouble* double_at_addr(int which) const {
 183     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 184     return (jdouble*) &amp;base()[which];
 185   }
 186 
 187   ConstantPool(Array&lt;u1&gt;* tags);
 188   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 189  public:
 190   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 191 
 192   bool is_constantPool() const volatile     { return true; }
 193 
 194   Array&lt;u1&gt;* tags() const                   { return _tags; }
 195   Array&lt;u2&gt;* operands() const               { return _operands; }
 196 
 197   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 198   void set_has_preresolution() {
 199     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 200     _flags |= _has_preresolution;
 201   }
 202 
 203   // minor and major version numbers of class file
 204   u2 major_version() const                 { return _major_version; }
 205   void set_major_version(u2 major_version) { _major_version = major_version; }
 206   u2 minor_version() const                 { return _minor_version; }
 207   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 208 
 209   // generics support
 210   Symbol* generic_signature() const {
 211     return (_generic_signature_index == 0) ?
 212       (Symbol*)NULL : symbol_at(_generic_signature_index);
 213   }
 214   u2 generic_signature_index() const                   { return _generic_signature_index; }
 215   void set_generic_signature_index(u2 sig_index)       { _generic_signature_index = sig_index; }
 216 
 217   // source file name
 218   Symbol* source_file_name() const {
 219     return (_source_file_name_index == 0) ?
 220       (Symbol*)NULL : symbol_at(_source_file_name_index);
 221   }
 222   u2 source_file_name_index() const                    { return _source_file_name_index; }
 223   void set_source_file_name_index(u2 sourcefile_index) { _source_file_name_index = sourcefile_index; }
 224 
 225   void copy_fields(const ConstantPool* orig);
 226 
 227   // Redefine classes support.  If a method refering to this constant pool
 228   // is on the executing stack, or as a handle in vm code, this constant pool
 229   // can&#39;t be removed from the set of previous versions saved in the instance
 230   // class.
 231   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 232   void set_on_stack(const bool value);
 233 
 234   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 235   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 236 
 237   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 238   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 239 
 240   // Klass holding pool
 241   InstanceKlass* pool_holder() const      { return _pool_holder; }
 242   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 243   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 244 
 245   // Interpreter runtime support
 246   ConstantPoolCache* cache() const        { return _cache; }
 247   void set_cache(ConstantPoolCache* cache){ _cache = cache; }
 248 
 249   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 250   virtual MetaspaceObj::Type type() const { return ConstantPoolType; }
 251 
 252   // Create object cache in the constant pool
 253   void initialize_resolved_references(ClassLoaderData* loader_data,
 254                                       const intStack&amp; reference_map,
 255                                       int constant_pool_map_length,
 256                                       TRAPS);
 257 
 258   // resolved strings, methodHandles and callsite objects from the constant pool
 259   objArrayOop resolved_references()  const;
 260   objArrayOop resolved_references_or_null()  const;
 261   // mapping resolved object array indexes to cp indexes and back.
 262   int object_to_cp_index(int index)         { return reference_map()-&gt;at(index); }
 263   int cp_to_object_index(int index);
 264 
 265   void set_resolved_klasses(Array&lt;Klass*&gt;* rk)  { _resolved_klasses = rk; }
 266   Array&lt;Klass*&gt;* resolved_klasses() const       { return _resolved_klasses; }
 267   void allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS);
 268   void initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS);
 269 
 270   // Invokedynamic indexes.
 271   // They must look completely different from normal indexes.
 272   // The main reason is that byte swapping is sometimes done on normal indexes.
 273   // Finally, it is helpful for debugging to tell the two apart.
 274   static bool is_invokedynamic_index(int i) { return (i &lt; 0); }
 275   static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  &quot;&quot;); return ~i; }
 276   static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), &quot;&quot;); return ~i; }
 277 
 278 
 279   // The invokedynamic points at a CP cache entry.  This entry points back
 280   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
 281   // in the resolved_references array (which provides the appendix argument).
 282   int invokedynamic_cp_cache_index(int indy_index) const {
 283     assert(is_invokedynamic_index(indy_index), &quot;should be a invokedynamic index&quot;);
 284     int cache_index = decode_invokedynamic_index(indy_index);
 285     return cache_index;
 286   }
 287   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {
 288     // decode index that invokedynamic points to.
 289     int cp_cache_index = invokedynamic_cp_cache_index(indy_index);
 290     return cache()-&gt;entry_at(cp_cache_index);
 291   }
 292   // Given the per-instruction index of an indy instruction, report the
 293   // main constant pool entry for its bootstrap specifier.
 294   // From there, uncached_name/signature_ref_at will get the name/type.
 295   int invokedynamic_bootstrap_ref_index_at(int indy_index) const {
 296     return invokedynamic_cp_cache_entry_at(indy_index)-&gt;constant_pool_index();
 297   }
 298 
 299   // Assembly code support
 300   static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }
 301   static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }
 302   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
 303   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 304 
 305   // Storing constants
 306 
 307   // For temporary use while constructing constant pool
 308   void klass_index_at_put(int which, int name_index) {
 309     tag_at_put(which, JVM_CONSTANT_ClassIndex);
 310     *int_at_addr(which) = name_index;
 311   }
 312 
 313   // Unsafe anonymous class support:
 314   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
 315   void klass_at_put(int class_index, Klass* k);
 316 
 317   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
 318     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 319 
 320     assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 321     assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 322     *int_at_addr(which) =
 323       build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 324   }
 325 
 326   void method_handle_index_at_put(int which, int ref_kind, int ref_index) {
 327     tag_at_put(which, JVM_CONSTANT_MethodHandle);
 328     *int_at_addr(which) = ((jint) ref_index&lt;&lt;16) | ref_kind;
 329   }
 330 
 331   void method_type_index_at_put(int which, int ref_index) {
 332     tag_at_put(which, JVM_CONSTANT_MethodType);
 333     *int_at_addr(which) = ref_index;
 334   }
 335 
 336   void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 337     tag_at_put(which, JVM_CONSTANT_Dynamic);
 338     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 339   }
 340 
 341   void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 342     tag_at_put(which, JVM_CONSTANT_InvokeDynamic);
 343     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 344   }
 345 
 346   void unresolved_string_at_put(int which, Symbol* s) {
 347     release_tag_at_put(which, JVM_CONSTANT_String);
 348     slot_at_put(which, CPSlot(s));
 349   }
 350 
 351   void int_at_put(int which, jint i) {
 352     tag_at_put(which, JVM_CONSTANT_Integer);
 353     *int_at_addr(which) = i;
 354   }
 355 
 356   void long_at_put(int which, jlong l) {
 357     tag_at_put(which, JVM_CONSTANT_Long);
 358     // *long_at_addr(which) = l;
 359     Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &amp;l));
 360   }
 361 
 362   void float_at_put(int which, jfloat f) {
 363     tag_at_put(which, JVM_CONSTANT_Float);
 364     *float_at_addr(which) = f;
 365   }
 366 
 367   void double_at_put(int which, jdouble d) {
 368     tag_at_put(which, JVM_CONSTANT_Double);
 369     // *double_at_addr(which) = d;
 370     // u8 temp = *(u8*) &amp;d;
 371     Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &amp;d));
 372   }
 373 
 374   Symbol** symbol_at_addr(int which) const {
 375     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 376     return (Symbol**) &amp;base()[which];
 377   }
 378 
 379   void symbol_at_put(int which, Symbol* s) {
 380     assert(s-&gt;refcount() != 0, &quot;should have nonzero refcount&quot;);
 381     tag_at_put(which, JVM_CONSTANT_Utf8);
 382     *symbol_at_addr(which) = s;
 383   }
 384 
 385   void string_at_put(int which, int obj_index, oop str);
 386 
 387   // For temporary use while constructing constant pool
 388   void string_index_at_put(int which, int string_index) {
 389     tag_at_put(which, JVM_CONSTANT_StringIndex);
 390     *int_at_addr(which) = string_index;
 391   }
 392 
 393   void field_at_put(int which, int class_index, int name_and_type_index) {
 394     tag_at_put(which, JVM_CONSTANT_Fieldref);
 395     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 396   }
 397 
 398   void method_at_put(int which, int class_index, int name_and_type_index) {
 399     tag_at_put(which, JVM_CONSTANT_Methodref);
 400     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 401   }
 402 
 403   void interface_method_at_put(int which, int class_index, int name_and_type_index) {
 404     tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);
 405     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;  // Not so nice
 406   }
 407 
 408   void name_and_type_at_put(int which, int name_index, int signature_index) {
 409     tag_at_put(which, JVM_CONSTANT_NameAndType);
 410     *int_at_addr(which) = ((jint) signature_index&lt;&lt;16) | name_index;  // Not so nice
 411   }
 412 
 413   // Tag query
 414 
 415   constantTag tag_at(int which) const { return (constantTag)tags()-&gt;at_acquire(which); }
 416 
 417   // Fetching constants
 418 
 419   Klass* klass_at(int which, TRAPS) {
 420     constantPoolHandle h_this(THREAD, this);
 421     return klass_at_impl(h_this, which, true, THREAD);
 422   }
 423 
 424   // Version of klass_at that doesn&#39;t save the resolution error, called during deopt
 425   Klass* klass_at_ignore_error(int which, TRAPS) {
 426     constantPoolHandle h_this(THREAD, this);
 427     return klass_at_impl(h_this, which, false, THREAD);
 428   }
 429 
 430   CPKlassSlot klass_slot_at(int which) const {
 431     assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),
 432            &quot;Corrupted constant pool&quot;);
 433     int value = *int_at_addr(which);
 434     int name_index = extract_high_short_from_int(value);
 435     int resolved_klass_index = extract_low_short_from_int(value);
 436     return CPKlassSlot(name_index, resolved_klass_index);
 437   }
 438 
 439   Symbol* klass_name_at(int which) const;  // Returns the name, w/o resolving.
 440   int klass_name_index_at(int which) const {
 441     return klass_slot_at(which).name_index();
 442   }
 443 
 444   Klass* resolved_klass_at(int which) const;  // Used by Compiler
 445 
 446   // RedefineClasses() API support:
 447   Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }
 448   void temp_unresolved_klass_at_put(int which, int name_index) {
 449     // Used only during constant pool merging for class redefinition. The resolved klass index
 450     // will be initialized later by a call to initialize_unresolved_klasses().
 451     unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);
 452   }
 453 
 454   jint int_at(int which) {
 455     assert(tag_at(which).is_int(), &quot;Corrupted constant pool&quot;);
 456     return *int_at_addr(which);
 457   }
 458 
 459   jlong long_at(int which) {
 460     assert(tag_at(which).is_long(), &quot;Corrupted constant pool&quot;);
 461     // return *long_at_addr(which);
 462     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 463     return *((jlong*)&amp;tmp);
 464   }
 465 
 466   jfloat float_at(int which) {
 467     assert(tag_at(which).is_float(), &quot;Corrupted constant pool&quot;);
 468     return *float_at_addr(which);
 469   }
 470 
 471   jdouble double_at(int which) {
 472     assert(tag_at(which).is_double(), &quot;Corrupted constant pool&quot;);
 473     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 474     return *((jdouble*)&amp;tmp);
 475   }
 476 
 477   Symbol* symbol_at(int which) const {
 478     assert(tag_at(which).is_utf8(), &quot;Corrupted constant pool&quot;);
 479     return *symbol_at_addr(which);
 480   }
 481 
 482   oop string_at(int which, int obj_index, TRAPS) {
 483     constantPoolHandle h_this(THREAD, this);
 484     return string_at_impl(h_this, which, obj_index, THREAD);
 485   }
 486   oop string_at(int which, TRAPS) {
 487     int obj_index = cp_to_object_index(which);
 488     return string_at(which, obj_index, THREAD);
 489   }
 490 
 491   // Version that can be used before string oop array is created.
 492   oop uncached_string_at(int which, TRAPS);
 493 
 494   // A &quot;pseudo-string&quot; is an non-string oop that has found its way into
 495   // a String entry.
 496   // This can happen if the user patches a live
 497   // object into a CONSTANT_String entry of an unsafe anonymous class.
 498   // Method oops internally created for method handles may also
 499   // use pseudo-strings to link themselves to related metaobjects.
 500 
 501   bool is_pseudo_string_at(int which);
 502 
 503   oop pseudo_string_at(int which, int obj_index);
 504 
 505   oop pseudo_string_at(int which);
 506 
 507   void pseudo_string_at_put(int which, int obj_index, oop x) {
 508     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 509     Symbol* sym = unresolved_string_at(which);
 510     slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));
 511     string_at_put(which, obj_index, x);    // this works just fine
 512   }
 513 
 514   // only called when we are sure a string entry is already resolved (via an
 515   // earlier string_at call.
 516   oop resolved_string_at(int which) {
 517     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 518     // Must do an acquire here in case another thread resolved the klass
 519     // behind our back, lest we later load stale values thru the oop.
 520     // we might want a volatile_obj_at in ObjArrayKlass.
 521     int obj_index = cp_to_object_index(which);
 522     return resolved_references()-&gt;obj_at(obj_index);
 523   }
 524 
 525   Symbol* unresolved_string_at(int which) {
 526     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 527     Symbol* sym = slot_at(which).get_symbol();
 528     return sym;
 529   }
 530 
 531   // Returns an UTF8 for a CONSTANT_String entry at a given index.
 532   // UTF8 char* representation was chosen to avoid conversion of
 533   // java_lang_Strings at resolved entries into Symbol*s
 534   // or vice versa.
 535   char* string_at_noresolve(int which);
 536 
 537   jint name_and_type_at(int which) {
 538     assert(tag_at(which).is_name_and_type(), &quot;Corrupted constant pool&quot;);
 539     return *int_at_addr(which);
 540   }
 541 
 542   int method_handle_ref_kind_at(int which) {
 543     assert(tag_at(which).is_method_handle() ||
 544            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 545     return extract_low_short_from_int(*int_at_addr(which));  // mask out unwanted ref_index bits
 546   }
 547   int method_handle_index_at(int which) {
 548     assert(tag_at(which).is_method_handle() ||
 549            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 550     return extract_high_short_from_int(*int_at_addr(which));  // shift out unwanted ref_kind bits
 551   }
 552   int method_type_index_at(int which) {
 553     assert(tag_at(which).is_method_type() ||
 554            tag_at(which).is_method_type_in_error(), &quot;Corrupted constant pool&quot;);
 555     return *int_at_addr(which);
 556   }
 557 
 558   // Derived queries:
 559   Symbol* method_handle_name_ref_at(int which) {
 560     int member = method_handle_index_at(which);
 561     return impl_name_ref_at(member, true);
 562   }
 563   Symbol* method_handle_signature_ref_at(int which) {
 564     int member = method_handle_index_at(which);
 565     return impl_signature_ref_at(member, true);
 566   }
 567   int method_handle_klass_index_at(int which) {
 568     int member = method_handle_index_at(which);
 569     return impl_klass_ref_index_at(member, true);
 570   }
 571   Symbol* method_type_signature_at(int which) {
 572     int sym = method_type_index_at(which);
 573     return symbol_at(sym);
 574   }
 575 
 576   int bootstrap_name_and_type_ref_index_at(int which) {
 577     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 578     return extract_high_short_from_int(*int_at_addr(which));
 579   }
 580   int bootstrap_methods_attribute_index(int which) {
 581     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 582     return extract_low_short_from_int(*int_at_addr(which));
 583   }
 584   int bootstrap_operand_base(int which) {
 585     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 586     return operand_offset_at(operands(), bsms_attribute_index);
 587   }
 588   // The first part of the operands array consists of an index into the second part.
 589   // Extract a 32-bit index value from the first part.
 590   static int operand_offset_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 591     int n = (bsms_attribute_index * 2);
 592     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 593     // The first 32-bit index points to the beginning of the second part
 594     // of the operands array.  Make sure this index is in the first part.
 595     DEBUG_ONLY(int second_part = build_int_from_shorts(operands-&gt;at(0),
 596                                                        operands-&gt;at(1)));
 597     assert(second_part == 0 || n+2 &lt;= second_part, &quot;oob (2)&quot;);
 598     int offset = build_int_from_shorts(operands-&gt;at(n+0),
 599                                        operands-&gt;at(n+1));
 600     // The offset itself must point into the second part of the array.
 601     assert(offset == 0 || offset &gt;= second_part &amp;&amp; offset &lt;= operands-&gt;length(), &quot;oob (3)&quot;);
 602     return offset;
 603   }
 604   static void operand_offset_at_put(Array&lt;u2&gt;* operands, int bsms_attribute_index, int offset) {
 605     int n = bsms_attribute_index * 2;
 606     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 607     operands-&gt;at_put(n+0, extract_low_short_from_int(offset));
 608     operands-&gt;at_put(n+1, extract_high_short_from_int(offset));
 609   }
 610   static int operand_array_length(Array&lt;u2&gt;* operands) {
 611     if (operands == NULL || operands-&gt;length() == 0)  return 0;
 612     int second_part = operand_offset_at(operands, 0);
 613     return (second_part / 2);
 614   }
 615 
 616 #ifdef ASSERT
 617   // operand tuples fit together exactly, end to end
 618   static int operand_limit_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 619     int nextidx = bsms_attribute_index + 1;
 620     if (nextidx == operand_array_length(operands))
 621       return operands-&gt;length();
 622     else
 623       return operand_offset_at(operands, nextidx);
 624   }
 625   int bootstrap_operand_limit(int which) {
 626     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 627     return operand_limit_at(operands(), bsms_attribute_index);
 628   }
 629 #endif //ASSERT
 630 
 631   // Layout of InvokeDynamic and Dynamic bootstrap method specifier
 632   // data in second part of operands array.  This encodes one record in
 633   // the BootstrapMethods attribute.  The whole specifier also includes
 634   // the name and type information from the main constant pool entry.
 635   enum {
 636          _indy_bsm_offset  = 0,  // CONSTANT_MethodHandle bsm
 637          _indy_argc_offset = 1,  // u2 argc
 638          _indy_argv_offset = 2   // u2 argv[argc]
 639   };
 640 
 641   // These functions are used in RedefineClasses for CP merge
 642 
 643   int operand_offset_at(int bsms_attribute_index) {
 644     assert(0 &lt;= bsms_attribute_index &amp;&amp;
 645            bsms_attribute_index &lt; operand_array_length(operands()),
 646            &quot;Corrupted CP operands&quot;);
 647     return operand_offset_at(operands(), bsms_attribute_index);
 648   }
 649   int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {
 650     int offset = operand_offset_at(bsms_attribute_index);
 651     return operands()-&gt;at(offset + _indy_bsm_offset);
 652   }
 653   int operand_argument_count_at(int bsms_attribute_index) {
 654     int offset = operand_offset_at(bsms_attribute_index);
 655     int argc = operands()-&gt;at(offset + _indy_argc_offset);
 656     return argc;
 657   }
 658   int operand_argument_index_at(int bsms_attribute_index, int j) {
 659     int offset = operand_offset_at(bsms_attribute_index);
 660     return operands()-&gt;at(offset + _indy_argv_offset + j);
 661   }
 662   int operand_next_offset_at(int bsms_attribute_index) {
 663     int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset
 664                    + operand_argument_count_at(bsms_attribute_index);
 665     return offset;
 666   }
 667   // Compare a bootstrap specifier data in the operands arrays
 668   bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle&amp; cp2,
 669                           int bsms_attribute_index2, TRAPS);
 670   // Find a bootstrap specifier data in the operands array
 671   int find_matching_operand(int bsms_attribute_index, const constantPoolHandle&amp; search_cp,
 672                             int operands_cur_len, TRAPS);
 673   // Resize the operands array with delta_len and delta_size
 674   void resize_operands(int delta_len, int delta_size, TRAPS);
 675   // Extend the operands array with the length and size of the ext_cp operands
 676   void extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS);
 677   // Shrink the operands array to a smaller array with new_len length
 678   void shrink_operands(int new_len, TRAPS);
 679 
 680   int bootstrap_method_ref_index_at(int which) {
 681     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 682     int op_base = bootstrap_operand_base(which);
 683     return operands()-&gt;at(op_base + _indy_bsm_offset);
 684   }
 685   int bootstrap_argument_count_at(int which) {
 686     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 687     int op_base = bootstrap_operand_base(which);
 688     int argc = operands()-&gt;at(op_base + _indy_argc_offset);
 689     DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;
 690                int next_offset = bootstrap_operand_limit(which));
 691     assert(end_offset == next_offset, &quot;matched ending&quot;);
 692     return argc;
 693   }
 694   int bootstrap_argument_index_at(int which, int j) {
 695     int op_base = bootstrap_operand_base(which);
 696     DEBUG_ONLY(int argc = operands()-&gt;at(op_base + _indy_argc_offset));
 697     assert((uint)j &lt; (uint)argc, &quot;oob&quot;);
 698     return operands()-&gt;at(op_base + _indy_argv_offset + j);
 699   }
 700 
 701   // The following methods (name/signature/klass_ref_at, klass_ref_at_noresolve,
 702   // name_and_type_ref_index_at) all expect to be passed indices obtained
 703   // directly from the bytecode.
 704   // If the indices are meant to refer to fields or methods, they are
 705   // actually rewritten constant pool cache indices.
 706   // The routine remap_instruction_operand_from_cache manages the adjustment
 707   // of these values back to constant pool indices.
 708 
 709   // There are also &quot;uncached&quot; versions which do not adjust the operand index; see below.
 710 
 711   // FIXME: Consider renaming these with a prefix &quot;cached_&quot; to make the distinction clear.
 712   // In a few cases (the verifier) there are uses before a cpcache has been built,
 713   // which are handled by a dynamic check in remap_instruction_operand_from_cache.
 714   // FIXME: Remove the dynamic check, and adjust all callers to specify the correct mode.
 715 
 716   // Lookup for entries consisting of (klass_index, name_and_type index)
 717   Klass* klass_ref_at(int which, TRAPS);
 718   Symbol* klass_ref_at_noresolve(int which);
 719   Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }
 720   Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }
 721 
 722   int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }
 723   int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }
 724 
 725   int remap_instruction_operand_from_cache(int operand);  // operand must be biased by CPCACHE_INDEX_TAG
 726 
 727   constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }
 728 
 729   // Lookup for entries consisting of (name_index, signature_index)
 730   int name_ref_index_at(int which_nt);            // ==  low-order jshort of name_and_type_at(which_nt)
 731   int signature_ref_index_at(int which_nt);       // == high-order jshort of name_and_type_at(which_nt)
 732 
 733   BasicType basic_type_for_signature_at(int which) const;
 734 
 735   // Resolve string constants (to prevent allocation during compilation)
 736   void resolve_string_constants(TRAPS) {
 737     constantPoolHandle h_this(THREAD, this);
 738     resolve_string_constants_impl(h_this, CHECK);
 739   }
 740 
 741   // CDS support
 742   void archive_resolved_references(Thread *THREAD) NOT_CDS_JAVA_HEAP_RETURN;
 743   void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 744   void remove_unshareable_info();
 745   void restore_unshareable_info(TRAPS);
 746   // The ConstantPool vtable is restored by this call when the ConstantPool is
 747   // in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for
 748   // all the gory details.  SA, dtrace and pstack helpers distinguish metadata
 749   // by their vtable.
 750   void restore_vtable() { guarantee(is_constantPool(), &quot;vtable restored by this call&quot;); }
 751 
 752  private:
 753   enum { _no_index_sentinel = -1, _possible_index_sentinel = -2 };
 754  public:
 755 
 756   // Get the tag for a constant, which may involve a constant dynamic
 757   constantTag constant_tag_at(int which);
 758   // Get the basic type for a constant, which may involve a constant dynamic
 759   BasicType basic_type_for_constant_at(int which);
 760 
 761   // Resolve late bound constants.
 762   oop resolve_constant_at(int index, TRAPS) {
 763     constantPoolHandle h_this(THREAD, this);
 764     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 765   }
 766 
 767   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 768     constantPoolHandle h_this(THREAD, this);
 769     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 770   }
 771 
 772   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 773     constantPoolHandle h_this(THREAD, this);
 774     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 775   }
 776 
 777   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 778     constantPoolHandle h_this(THREAD, this);
 779     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 780   }
 781 
 782   void copy_bootstrap_arguments_at(int index,
 783                                    int start_arg, int end_arg,
 784                                    objArrayHandle info, int pos,
 785                                    bool must_resolve, Handle if_not_available, TRAPS) {
 786     constantPoolHandle h_this(THREAD, this);
 787     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 788                                      info, pos, must_resolve, if_not_available, THREAD);
 789   }
 790 
 791   // Klass name matches name at offset
 792   bool klass_name_at_matches(const InstanceKlass* k, int which);
 793 
 794   // Sizing
 795   int length() const                   { return _length; }
 796   void set_length(int length)          { _length = length; }
 797 
 798   // Tells whether index is within bounds.
 799   bool is_within_bounds(int index) const {
 800     return 0 &lt;= index &amp;&amp; index &lt; length();
 801   }
 802 
 803   // Sizing (in words)
 804   static int header_size()             {
 805     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 806   }
 807   static int size(int length)          { return align_metadata_size(header_size() + length); }
 808   int size() const                     { return size(length()); }
 809 
 810   // ConstantPools should be stored in the read-only region of CDS archive.
 811   static bool is_read_only_by_default() { return true; }
 812 
 813   friend class ClassFileParser;
 814   friend class SystemDictionary;
 815 
 816   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 817   template &lt;class T&gt; friend class CppVtableTesterA;
 818   template &lt;class T&gt; friend class CppVtableTesterB;
 819   template &lt;class T&gt; friend class CppVtableCloner;
 820 
 821   // Used by compiler to prevent classloading.
 822   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 823   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 824   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 825   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 826   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 827 
 828   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
 829   // future by other Java code. These take constant pool indices rather than
 830   // constant pool cache indices as do the peer methods above.
 831   Symbol* uncached_klass_ref_at_noresolve(int which);
 832   Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }
 833   Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }
 834   int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }
 835   int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }
 836 
 837   // Sharing
 838   int pre_resolve_shared_klasses(TRAPS);
 839 
 840   // Debugging
 841   const char* printable_name_at(int which) PRODUCT_RETURN0;
 842 
 843 #ifdef ASSERT
 844   enum { CPCACHE_INDEX_TAG = 0x10000 };  // helps keep CP cache indices distinct from CP indices
 845 #else
 846   enum { CPCACHE_INDEX_TAG = 0 };        // in product mode, this zero value is a no-op
 847 #endif //ASSERT
 848 
 849   static int decode_cpcache_index(int raw_index, bool invokedynamic_ok = false) {
 850     if (invokedynamic_ok &amp;&amp; is_invokedynamic_index(raw_index))
 851       return decode_invokedynamic_index(raw_index);
 852     else
 853       return raw_index - CPCACHE_INDEX_TAG;
 854   }
 855 
 856  private:
 857 
 858   void set_resolved_references(OopHandle s) { _cache-&gt;set_resolved_references(s); }
 859   Array&lt;u2&gt;* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache-&gt;reference_map(); }
 860   void set_reference_map(Array&lt;u2&gt;* o)    { _cache-&gt;set_reference_map(o); }
 861 
 862   // patch JSR 292 resolved references after the class is linked.
 863   void patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches);
 864 
 865   Symbol* impl_name_ref_at(int which, bool uncached);
 866   Symbol* impl_signature_ref_at(int which, bool uncached);
 867 
 868   int       impl_klass_ref_index_at(int which, bool uncached);
 869   int       impl_name_and_type_ref_index_at(int which, bool uncached);
 870   constantTag impl_tag_ref_at(int which, bool uncached);
 871 
 872   // Used while constructing constant pool (only by ClassFileParser)
 873   jint klass_index_at(int which) {
 874     assert(tag_at(which).is_klass_index(), &quot;Corrupted constant pool&quot;);
 875     return *int_at_addr(which);
 876   }
 877 
 878   jint string_index_at(int which) {
 879     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 880     return *int_at_addr(which);
 881   }
 882 
 883   // Performs the LinkResolver checks
 884   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 885 
 886   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 887   // handle GC while executing the method
 888   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 889                               bool save_resolution_error, TRAPS);
 890   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 891 
 892   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 893 
 894   // Resolve string constants (to prevent allocation during compilation)
 895   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 896 
 897   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 898                                       bool* status_return, TRAPS);
 899   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 900                                                int start_arg, int end_arg,
 901                                                objArrayHandle info, int pos,
 902                                                bool must_resolve, Handle if_not_available, TRAPS);
 903 
 904   // Exception handling
 905   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 906   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 907 
 908  public:
 909   // Exception handling
 910   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 911 
 912   // Merging ConstantPool* support:
 913   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 914   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 915     constantPoolHandle h_this(THREAD, this);
 916     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 917   }
 918   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 919   static void copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 920   static void copy_operands(const constantPoolHandle&amp; from_cp, const constantPoolHandle&amp; to_cp, TRAPS);
 921   int  find_matching_entry(int pattern_i, const constantPoolHandle&amp; search_cp, TRAPS);
 922   int  version() const                    { return _saved._version; }
 923   void set_version(int version)           { _saved._version = version; }
 924   void increment_and_save_version(int version) {
 925     _saved._version = version &gt;= 0 ? (version + 1) : version;  // keep overflow
 926   }
 927 
 928   void set_resolved_reference_length(int length) { _saved._resolved_reference_length = length; }
 929   int  resolved_reference_length() const  { return _saved._resolved_reference_length; }
 930 
 931   // Decrease ref counts of symbols that are in the constant pool
 932   // when the holder class is unloaded
 933   void unreference_symbols();
 934 
 935   // Deallocate constant pool for RedefineClasses
 936   void deallocate_contents(ClassLoaderData* loader_data);
 937   void release_C_heap_structures();
 938 
 939   // JVMTI accesss - GetConstantPool, RetransformClasses, ...
 940   friend class JvmtiConstantPoolReconstituter;
 941 
 942  private:
 943   jint cpool_entry_size(jint idx);
 944   jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);
 945 
 946   // Copy cpool bytes into byte array.
 947   // Returns:
 948   //  int &gt; 0, count of the raw cpool bytes that have been copied
 949   //        0, OutOfMemory error
 950   //       -1, Internal error
 951   int  copy_cpool_bytes(int cpool_size,
 952                         SymbolHashMap* tbl,
 953                         unsigned char *bytes);
 954 
 955  public:
 956   // Verify
 957   void verify_on(outputStream* st);
 958 
 959   // Printing
 960   void print_on(outputStream* st) const;
 961   void print_value_on(outputStream* st) const;
 962   void print_entry_on(int index, outputStream* st);
 963 
 964   const char* internal_name() const { return &quot;{constant pool}&quot;; }
 965 };
 966 
 967 class SymbolHashMapEntry : public CHeapObj&lt;mtSymbol&gt; {
 968  private:
 969   unsigned int        _hash;   // 32-bit hash for item
 970   SymbolHashMapEntry* _next;   // Next element in the linked list for this bucket
 971   Symbol*             _symbol; // 1-st part of the mapping: symbol =&gt; value
 972   u2                  _value;  // 2-nd part of the mapping: symbol =&gt; value
 973 
 974  public:
 975   unsigned   int hash() const             { return _hash;   }
 976   void       set_hash(unsigned int hash)  { _hash = hash;   }
 977 
 978   SymbolHashMapEntry* next() const        { return _next;   }
 979   void set_next(SymbolHashMapEntry* next) { _next = next;   }
 980 
 981   Symbol*    symbol() const               { return _symbol; }
 982   void       set_symbol(Symbol* sym)      { _symbol = sym;  }
 983 
 984   u2         value() const                {  return _value; }
 985   void       set_value(u2 value)          { _value = value; }
 986 
 987   SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)
 988     : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}
 989 
 990 }; // End SymbolHashMapEntry class
 991 
 992 
 993 class SymbolHashMapBucket : public CHeapObj&lt;mtSymbol&gt; {
 994 
 995 private:
 996   SymbolHashMapEntry*    _entry;
 997 
 998 public:
 999   SymbolHashMapEntry* entry() const         {  return _entry; }
1000   void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }
1001   void clear()                              { _entry = NULL;  }
1002 
1003 }; // End SymbolHashMapBucket class
1004 
1005 
1006 class SymbolHashMap: public CHeapObj&lt;mtSymbol&gt; {
1007 
1008  private:
1009   // Default number of entries in the table
1010   enum SymbolHashMap_Constants {
1011     _Def_HashMap_Size = 256
1012   };
1013 
1014   int                   _table_size;
1015   SymbolHashMapBucket*  _buckets;
1016 
1017   void initialize_table(int table_size);
1018 
1019  public:
1020 
1021   int table_size() const        { return _table_size; }
1022 
1023   SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }
1024   SymbolHashMap(int table_size) { initialize_table(table_size); }
1025 
1026   // hash P(31) from Kernighan &amp; Ritchie
1027   static unsigned int compute_hash(const char* str, int len) {
1028     unsigned int hash = 0;
1029     while (len-- &gt; 0) {
1030       hash = 31*hash + (unsigned) *str;
1031       str++;
1032     }
1033     return hash;
1034   }
1035 
1036   SymbolHashMapEntry* bucket(int i) {
1037     return _buckets[i].entry();
1038   }
1039 
1040   void add_entry(Symbol* sym, u2 value);
1041   SymbolHashMapEntry* find_entry(Symbol* sym);
1042 
1043   u2 symbol_to_value(Symbol* sym) {
1044     SymbolHashMapEntry *entry = find_entry(sym);
1045     return (entry == NULL) ? 0 : entry-&gt;value();
1046   }
1047 
1048   ~SymbolHashMap();
1049 }; // End SymbolHashMap class
1050 
1051 #endif // SHARE_OOPS_CONSTANTPOOL_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/cfgnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/moduleEntry.hpp&quot;
 27 #include &quot;classfile/packageEntry.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;memory/metadataFactory.hpp&quot;
 34 #include &quot;memory/metaspaceClosure.hpp&quot;

 35 #include &quot;memory/resourceArea.hpp&quot;
 36 #include &quot;memory/universe.hpp&quot;
 37 #include &quot;oops/arrayKlass.inline.hpp&quot;
 38 #include &quot;oops/instanceKlass.hpp&quot;
 39 #include &quot;oops/klass.inline.hpp&quot;
 40 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 41 #include &quot;oops/objArrayOop.inline.hpp&quot;
 42 #include &quot;oops/oop.inline.hpp&quot;
 43 #include &quot;oops/symbol.hpp&quot;
 44 #include &quot;runtime/handles.inline.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
 46 #include &quot;utilities/macros.hpp&quot;
 47 
 48 ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {
 49   assert(ObjArrayKlass::header_size() &lt;= InstanceKlass::header_size(),
 50       &quot;array klasses must be same size as InstanceKlass&quot;);
 51 
 52   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 53 
 54   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 55 }
 56 
<span class="line-modified"> 57 Klass* ObjArrayKlass::allocate_objArray_klass(ClassLoaderData* loader_data,</span>
<span class="line-removed"> 58                                                 int n, Klass* element_klass, TRAPS) {</span>
<span class="line-removed"> 59 </span>
 60   // Eagerly allocate the direct array supertype.
 61   Klass* super_klass = NULL;
 62   if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
 63     Klass* element_super = element_klass-&gt;super();
 64     if (element_super != NULL) {
 65       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 66       super_klass = element_super-&gt;array_klass_or_null();
 67       bool supers_exist = super_klass != NULL;
 68       // Also, see if the element has secondary supertypes.
 69       // We need an array type for each.
 70       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 71       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 72         Klass* elem_super = element_supers-&gt;at(i);
 73         if (elem_super-&gt;array_klass_or_null() == NULL) {
 74           supers_exist = false;
 75           break;
 76         }
 77       }
 78       if (!supers_exist) {
 79         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 80         Klass* ek = NULL;
 81         {
 82           MutexUnlocker mu(MultiArray_lock);
 83           super_klass = element_super-&gt;array_klass(CHECK_NULL);
 84           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 85             Klass* elem_super = element_supers-&gt;at(i);
 86             elem_super-&gt;array_klass(CHECK_NULL);
 87           }
 88           // Now retry from the beginning
 89           ek = element_klass-&gt;array_klass(n, CHECK_NULL);
 90         }  // re-lock
 91         return ek;
 92       }
 93     } else {
 94       // The element type is already Object.  Object[] has direct super of Object.
 95       super_klass = SystemDictionary::Object_klass();
 96     }
 97   }
 98 
 99   // Create type name for klass.
<span class="line-modified">100   Symbol* name = NULL;</span>
<span class="line-removed">101   {</span>
<span class="line-removed">102     ResourceMark rm(THREAD);</span>
<span class="line-removed">103     char *name_str = element_klass-&gt;name()-&gt;as_C_string();</span>
<span class="line-removed">104     int len = element_klass-&gt;name()-&gt;utf8_length();</span>
<span class="line-removed">105     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);</span>
<span class="line-removed">106     int idx = 0;</span>
<span class="line-removed">107     new_str[idx++] = JVM_SIGNATURE_ARRAY;</span>
<span class="line-removed">108     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type</span>
<span class="line-removed">109       new_str[idx++] = JVM_SIGNATURE_CLASS;</span>
<span class="line-removed">110     }</span>
<span class="line-removed">111     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));</span>
<span class="line-removed">112     idx += len;</span>
<span class="line-removed">113     if (element_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed">114       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;</span>
<span class="line-removed">115     }</span>
<span class="line-removed">116     new_str[idx++] = &#39;\0&#39;;</span>
<span class="line-removed">117     name = SymbolTable::new_symbol(new_str);</span>
<span class="line-removed">118   }</span>
119 
120   // Initialize instance variables

121   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
122 
123   ModuleEntry* module = oak-&gt;module();
124   assert(module != NULL, &quot;No module entry for array&quot;);
125 
126   // Call complete_create_array_klass after all instance variables has been initialized.
127   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
128 
129   // Add all classes to our internal class loader list here,
130   // including classes in the bootstrap (NULL) class loader.
131   // Do this step after creating the mirror so that if the
132   // mirror creation fails, loaded_classes_do() doesn&#39;t find
133   // an array class without a mirror.
134   loader_data-&gt;add_class(oak);
135 
136   return oak;
137 }
138 
139 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
140   set_dimension(n);
141   set_element_klass(element_klass);
142 
143   Klass* bk;
144   if (element_klass-&gt;is_objArray_klass()) {
145     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();


146   } else {
147     bk = element_klass;
148   }
149   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
150   set_bottom_klass(bk);
151   set_class_loader_data(bk-&gt;class_loader_data());
152 
<span class="line-modified">153   set_layout_helper(array_layout_helper(T_OBJECT));</span>




154   assert(is_array_klass(), &quot;sanity&quot;);
155   assert(is_objArray_klass(), &quot;sanity&quot;);
156 }
157 
158 int ObjArrayKlass::oop_size(oop obj) const {
159   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
160   return objArrayOop(obj)-&gt;object_size();
161 }
162 
163 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
164   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
165   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">166   return (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,</span>

167                                                        /* do_zero */ true, THREAD);














168 }
169 
<span class="line-removed">170 static int multi_alloc_counter = 0;</span>
<span class="line-removed">171 </span>
172 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
173   int length = *sizes;








174   // Call to lower_dimension uses this pointer, so most be called before a
175   // possible GC
176   Klass* ld_klass = lower_dimension();
177   // If length &lt; 0 allocate will throw an exception.
178   objArrayOop array = allocate(length, CHECK_NULL);
179   objArrayHandle h_array (THREAD, array);
<span class="line-modified">180   if (rank &gt; 1) {</span>
<span class="line-modified">181     if (length != 0) {</span>
<span class="line-modified">182       for (int index = 0; index &lt; length; index++) {</span>
<span class="line-modified">183         ArrayKlass* ak = ArrayKlass::cast(ld_klass);</span>
<span class="line-modified">184         oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);</span>
<span class="line-modified">185         h_array-&gt;obj_at_put(index, sub_array);</span>
<span class="line-modified">186       }</span>
<span class="line-modified">187     } else {</span>
<span class="line-modified">188       // Since this array dimension has zero length, nothing will be</span>
<span class="line-modified">189       // allocated, however the lower dimension values must be checked</span>
<span class="line-modified">190       // for illegal values.</span>
<span class="line-modified">191       for (int i = 0; i &lt; rank - 1; ++i) {</span>
<span class="line-modified">192         sizes += 1;</span>
<span class="line-modified">193         if (*sizes &lt; 0) {</span>
<span class="line-removed">194           THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));</span>
<span class="line-removed">195         }</span>
196       }
197     }
198   }
199   return h_array();
200 }
201 
202 // Either oop or narrowOop depending on UseCompressedOops.
203 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
204                             arrayOop d, size_t dst_offset, int length, TRAPS) {
205   if (s == d) {
206     // since source and destination are equal we do not need conversion checks.
207     assert(length &gt; 0, &quot;sanity check&quot;);
208     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
209   } else {
210     // We have to make sure all elements conform to the destination array
211     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
212     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();



213     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
<span class="line-modified">214       // elements are guaranteed to be subtypes, so no check necessary</span>
<span class="line-modified">215       ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);</span>



216     } else {
<span class="line-modified">217       // slow case: need individual subtype checks</span>
<span class="line-modified">218       // note: don&#39;t use obj_at_put below because it includes a redundant store check</span>
<span class="line-modified">219       if (!ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length)) {</span>
<span class="line-modified">220         ResourceMark rm(THREAD);</span>
<span class="line-removed">221         stringStream ss;</span>
<span class="line-removed">222         if (!bound-&gt;is_subtype_of(stype)) {</span>
<span class="line-removed">223           ss.print(&quot;arraycopy: type mismatch: can not copy %s[] into %s[]&quot;,</span>
<span class="line-removed">224                    stype-&gt;external_name(), bound-&gt;external_name());</span>
<span class="line-removed">225         } else {</span>
<span class="line-removed">226           // oop_arraycopy should return the index in the source array that</span>
<span class="line-removed">227           // contains the problematic oop.</span>
<span class="line-removed">228           ss.print(&quot;arraycopy: element type mismatch: can not cast one of the elements&quot;</span>
<span class="line-removed">229                    &quot; of %s[] to the type of the destination array, %s&quot;,</span>
<span class="line-removed">230                    stype-&gt;external_name(), bound-&gt;external_name());</span>
<span class="line-removed">231         }</span>
<span class="line-removed">232         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
233       }
234     }
235   }
236 }
237 
238 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
239                                int dst_pos, int length, TRAPS) {
240   assert(s-&gt;is_objArray(), &quot;must be obj array&quot;);
241 







242   if (!d-&gt;is_objArray()) {
243     ResourceMark rm(THREAD);
244     stringStream ss;
245     if (d-&gt;is_typeArray()) {
246       ss.print(&quot;arraycopy: type mismatch: can not copy object array[] into %s[]&quot;,
247                type2name_tab[ArrayKlass::cast(d-&gt;klass())-&gt;element_type()]);
248     } else {
249       ss.print(&quot;arraycopy: destination type %s is not an array&quot;, d-&gt;klass()-&gt;external_name());
250     }
251     THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
252   }
253 
254   // Check is all offsets and lengths are non negative
255   if (src_pos &lt; 0 || dst_pos &lt; 0 || length &lt; 0) {
256     // Pass specific exception reason.
257     ResourceMark rm(THREAD);
258     stringStream ss;
259     if (src_pos &lt; 0) {
260       ss.print(&quot;arraycopy: source index %d out of bounds for object array[%d]&quot;,
261                src_pos, s-&gt;length());
</pre>
<hr />
<pre>
294     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(src_pos);
295     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(dst_pos);
296     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(s, src_offset, NULL) ==
297            objArrayOop(s)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(src_pos), &quot;sanity&quot;);
298     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(d, dst_offset, NULL) ==
299            objArrayOop(d)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(dst_pos), &quot;sanity&quot;);
300     do_copy(s, src_offset, d, dst_offset, length, CHECK);
301   } else {
302     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(src_pos);
303     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(dst_pos);
304     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(s, src_offset, NULL) ==
305            objArrayOop(s)-&gt;obj_at_addr_raw&lt;oop&gt;(src_pos), &quot;sanity&quot;);
306     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(d, dst_offset, NULL) ==
307            objArrayOop(d)-&gt;obj_at_addr_raw&lt;oop&gt;(dst_pos), &quot;sanity&quot;);
308     do_copy(s, src_offset, d, dst_offset, length, CHECK);
309   }
310 }
311 
312 
313 Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {
<span class="line-removed">314 </span>
315   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
316   int dim = dimension();
317   if (dim == n) return this;
318 
319   // lock-free read needs acquire semantics
320   if (higher_dimension_acquire() == NULL) {
321     if (or_null) return NULL;
322 
323     ResourceMark rm;
<span class="line-removed">324     JavaThread *jt = (JavaThread *)THREAD;</span>
325     {
326       // Ensure atomic creation of higher dimensions
327       MutexLocker mu(THREAD, MultiArray_lock);
328 
329       // Check if another thread beat us
330       if (higher_dimension() == NULL) {
331 
332         // Create multi-dim klass object and link them together
<span class="line-modified">333         Klass* k =</span>
<span class="line-removed">334           ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);</span>
335         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
336         ak-&gt;set_lower_dimension(this);
337         // use &#39;release&#39; to pair with lock-free load
338         release_set_higher_dimension(ak);
339         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
340       }
341     }
342   }
343 
344   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
345   if (or_null) {
346     return ak-&gt;array_klass_or_null(n);
347   }
348   THREAD-&gt;check_possible_safepoint();
349   return ak-&gt;array_klass(n, THREAD);
350 }
351 
352 Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
353   return array_klass_impl(or_null, dimension() +  1, THREAD);
354 }
</pre>
<hr />
<pre>
356 bool ObjArrayKlass::can_be_primary_super_slow() const {
357   if (!bottom_klass()-&gt;can_be_primary_super())
358     // array of interfaces
359     return false;
360   else
361     return Klass::can_be_primary_super_slow();
362 }
363 
364 GrowableArray&lt;Klass*&gt;* ObjArrayKlass::compute_secondary_supers(int num_extra_slots,
365                                                                Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
366   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
367   // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
368   const Array&lt;Klass*&gt;* elem_supers = element_klass()-&gt;secondary_supers();
369   int num_elem_supers = elem_supers == NULL ? 0 : elem_supers-&gt;length();
370   int num_secondaries = num_extra_slots + 2 + num_elem_supers;
371   if (num_secondaries == 2) {
372     // Must share this for correct bootstrapping!
373     set_secondary_supers(Universe::the_array_interfaces_array());
374     return NULL;
375   } else {
<span class="line-modified">376     GrowableArray&lt;Klass*&gt;* secondaries = new GrowableArray&lt;Klass*&gt;(num_elem_supers+2);</span>
377     secondaries-&gt;push(SystemDictionary::Cloneable_klass());
378     secondaries-&gt;push(SystemDictionary::Serializable_klass());

379     for (int i = 0; i &lt; num_elem_supers; i++) {
380       Klass* elem_super = elem_supers-&gt;at(i);
381       Klass* array_super = elem_super-&gt;array_klass_or_null();
382       assert(array_super != NULL, &quot;must already have been created&quot;);
383       secondaries-&gt;push(array_super);
384     }
385     return secondaries;
386   }
387 }
388 
389 void ObjArrayKlass::initialize(TRAPS) {
390   bottom_klass()-&gt;initialize(THREAD);  // dispatches to either InstanceKlass or TypeArrayKlass
391 }
392 
393 void ObjArrayKlass::metaspace_pointers_do(MetaspaceClosure* it) {
394   ArrayKlass::metaspace_pointers_do(it);
395   it-&gt;push(&amp;_element_klass);
396   it-&gt;push(&amp;_bottom_klass);
397 }
398 
</pre>
<hr />
<pre>
410   return (element_flags &amp; (JVM_ACC_PUBLIC | JVM_ACC_PRIVATE | JVM_ACC_PROTECTED))
411                         | (JVM_ACC_ABSTRACT | JVM_ACC_FINAL);
412 }
413 
414 ModuleEntry* ObjArrayKlass::module() const {
415   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
416   // The array is defined in the module of its bottom class
417   return bottom_klass()-&gt;module();
418 }
419 
420 PackageEntry* ObjArrayKlass::package() const {
421   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
422   return bottom_klass()-&gt;package();
423 }
424 
425 // Printing
426 
427 void ObjArrayKlass::print_on(outputStream* st) const {
428 #ifndef PRODUCT
429   Klass::print_on(st);
<span class="line-modified">430   st-&gt;print(&quot; - instance klass: &quot;);</span>
431   element_klass()-&gt;print_value_on(st);
432   st-&gt;cr();
433 #endif //PRODUCT
434 }
435 
436 void ObjArrayKlass::print_value_on(outputStream* st) const {
437   assert(is_klass(), &quot;must be klass&quot;);
438 
439   element_klass()-&gt;print_value_on(st);
440   st-&gt;print(&quot;[]&quot;);
441 }
442 
443 #ifndef PRODUCT
444 
445 void ObjArrayKlass::oop_print_on(oop obj, outputStream* st) {
446   ArrayKlass::oop_print_on(obj, st);
447   assert(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
448   objArrayOop oa = objArrayOop(obj);
449   int print_len = MIN2((intx) oa-&gt;length(), MaxElementPrintSize);
450   for(int index = 0; index &lt; print_len; index++) {
</pre>
<hr />
<pre>
472   st-&gt;print(&quot;[%d] &quot;, len);
473   if (obj != NULL) {
474     obj-&gt;print_address_on(st);
475   } else {
476     st-&gt;print_cr(&quot;NULL&quot;);
477   }
478 }
479 
480 const char* ObjArrayKlass::internal_name() const {
481   return external_name();
482 }
483 
484 
485 // Verification
486 
487 void ObjArrayKlass::verify_on(outputStream* st) {
488   ArrayKlass::verify_on(st);
489   guarantee(element_klass()-&gt;is_klass(), &quot;should be klass&quot;);
490   guarantee(bottom_klass()-&gt;is_klass(), &quot;should be klass&quot;);
491   Klass* bk = bottom_klass();
<span class="line-modified">492   guarantee(bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass(),  &quot;invalid bottom klass&quot;);</span>

493 }
494 
495 void ObjArrayKlass::oop_verify_on(oop obj, outputStream* st) {
496   ArrayKlass::oop_verify_on(obj, st);
497   guarantee(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
498   objArrayOop oa = objArrayOop(obj);
499   for(int index = 0; index &lt; oa-&gt;length(); index++) {
500     guarantee(oopDesc::is_oop_or_null(oa-&gt;obj_at(index)), &quot;should be oop&quot;);
501   }
502 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/moduleEntry.hpp&quot;
 27 #include &quot;classfile/packageEntry.hpp&quot;
 28 #include &quot;classfile/symbolTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
 32 #include &quot;memory/iterator.inline.hpp&quot;
 33 #include &quot;memory/metadataFactory.hpp&quot;
 34 #include &quot;memory/metaspaceClosure.hpp&quot;
<span class="line-added"> 35 #include &quot;memory/oopFactory.hpp&quot;</span>
 36 #include &quot;memory/resourceArea.hpp&quot;
 37 #include &quot;memory/universe.hpp&quot;
 38 #include &quot;oops/arrayKlass.inline.hpp&quot;
 39 #include &quot;oops/instanceKlass.hpp&quot;
 40 #include &quot;oops/klass.inline.hpp&quot;
 41 #include &quot;oops/objArrayKlass.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;oops/symbol.hpp&quot;
 45 #include &quot;runtime/handles.inline.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;utilities/macros.hpp&quot;
 48 
 49 ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS) {
 50   assert(ObjArrayKlass::header_size() &lt;= InstanceKlass::header_size(),
 51       &quot;array klasses must be same size as InstanceKlass&quot;);
 52 
 53   int size = ArrayKlass::static_size(ObjArrayKlass::header_size());
 54 
 55   return new (loader_data, size, THREAD) ObjArrayKlass(n, k, name);
 56 }
 57 
<span class="line-modified"> 58 Klass* ObjArrayKlass::allocate_objArray_klass(int n, Klass* element_klass, TRAPS) {</span>


 59   // Eagerly allocate the direct array supertype.
 60   Klass* super_klass = NULL;
 61   if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
 62     Klass* element_super = element_klass-&gt;super();
 63     if (element_super != NULL) {
 64       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 65       super_klass = element_super-&gt;array_klass_or_null();
 66       bool supers_exist = super_klass != NULL;
 67       // Also, see if the element has secondary supertypes.
 68       // We need an array type for each.
 69       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 70       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 71         Klass* elem_super = element_supers-&gt;at(i);
 72         if (elem_super-&gt;array_klass_or_null() == NULL) {
 73           supers_exist = false;
 74           break;
 75         }
 76       }
 77       if (!supers_exist) {
 78         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 79         Klass* ek = NULL;
 80         {
 81           MutexUnlocker mu(MultiArray_lock);
 82           super_klass = element_super-&gt;array_klass(CHECK_NULL);
 83           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 84             Klass* elem_super = element_supers-&gt;at(i);
 85             elem_super-&gt;array_klass(CHECK_NULL);
 86           }
 87           // Now retry from the beginning
 88           ek = element_klass-&gt;array_klass(n, CHECK_NULL);
 89         }  // re-lock
 90         return ek;
 91       }
 92     } else {
 93       // The element type is already Object.  Object[] has direct super of Object.
 94       super_klass = SystemDictionary::Object_klass();
 95     }
 96   }
 97 
 98   // Create type name for klass.
<span class="line-modified"> 99   Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);</span>


















100 
101   // Initialize instance variables
<span class="line-added">102   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();</span>
103   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
104 
105   ModuleEntry* module = oak-&gt;module();
106   assert(module != NULL, &quot;No module entry for array&quot;);
107 
108   // Call complete_create_array_klass after all instance variables has been initialized.
109   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
110 
111   // Add all classes to our internal class loader list here,
112   // including classes in the bootstrap (NULL) class loader.
113   // Do this step after creating the mirror so that if the
114   // mirror creation fails, loaded_classes_do() doesn&#39;t find
115   // an array class without a mirror.
116   loader_data-&gt;add_class(oak);
117 
118   return oak;
119 }
120 
121 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
122   set_dimension(n);
123   set_element_klass(element_klass);
124 
125   Klass* bk;
126   if (element_klass-&gt;is_objArray_klass()) {
127     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
<span class="line-added">128   } else if (element_klass-&gt;is_valueArray_klass()) {</span>
<span class="line-added">129     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();</span>
130   } else {
131     bk = element_klass;
132   }
133   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
134   set_bottom_klass(bk);
135   set_class_loader_data(bk-&gt;class_loader_data());
136 
<span class="line-modified">137   jint lh = array_layout_helper(T_OBJECT);</span>
<span class="line-added">138   if (element_klass-&gt;is_value()) {</span>
<span class="line-added">139     lh = layout_helper_set_null_free(lh);</span>
<span class="line-added">140   }</span>
<span class="line-added">141   set_layout_helper(lh);</span>
142   assert(is_array_klass(), &quot;sanity&quot;);
143   assert(is_objArray_klass(), &quot;sanity&quot;);
144 }
145 
146 int ObjArrayKlass::oop_size(oop obj) const {
147   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
148   return objArrayOop(obj)-&gt;object_size();
149 }
150 
151 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
152   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
153   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">154   bool populate_null_free = is_null_free_array_klass();</span>
<span class="line-added">155   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,</span>
156                                                        /* do_zero */ true, THREAD);
<span class="line-added">157   if (populate_null_free) {</span>
<span class="line-added">158     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);</span>
<span class="line-added">159     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);</span>
<span class="line-added">160     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);</span>
<span class="line-added">161     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);</span>
<span class="line-added">162     element_klass()-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">163     // Populate default values...</span>
<span class="line-added">164     objArrayHandle array_h(THREAD, array);</span>
<span class="line-added">165     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();</span>
<span class="line-added">166     for (int i = 0; i &lt; length; i++) {</span>
<span class="line-added">167       array_h-&gt;obj_at_put(i, value);</span>
<span class="line-added">168     }</span>
<span class="line-added">169   }</span>
<span class="line-added">170   return array;</span>
171 }
172 


173 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
174   int length = *sizes;
<span class="line-added">175   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements</span>
<span class="line-added">176     if (element_klass()-&gt;is_value()) {</span>
<span class="line-added">177       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);</span>
<span class="line-added">178     } else {</span>
<span class="line-added">179       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);</span>
<span class="line-added">180     }</span>
<span class="line-added">181   }</span>
<span class="line-added">182   guarantee(rank &gt; 1, &quot;Rank below 1&quot;);</span>
183   // Call to lower_dimension uses this pointer, so most be called before a
184   // possible GC
185   Klass* ld_klass = lower_dimension();
186   // If length &lt; 0 allocate will throw an exception.
187   objArrayOop array = allocate(length, CHECK_NULL);
188   objArrayHandle h_array (THREAD, array);
<span class="line-modified">189   if (length != 0) {</span>
<span class="line-modified">190     for (int index = 0; index &lt; length; index++) {</span>
<span class="line-modified">191       ArrayKlass* ak = ArrayKlass::cast(ld_klass);</span>
<span class="line-modified">192       oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);</span>
<span class="line-modified">193       h_array-&gt;obj_at_put(index, sub_array);</span>
<span class="line-modified">194     }</span>
<span class="line-modified">195   } else {</span>
<span class="line-modified">196     // Since this array dimension has zero length, nothing will be</span>
<span class="line-modified">197     // allocated, however the lower dimension values must be checked</span>
<span class="line-modified">198     // for illegal values.</span>
<span class="line-modified">199     for (int i = 0; i &lt; rank - 1; ++i) {</span>
<span class="line-modified">200       sizes += 1;</span>
<span class="line-modified">201       if (*sizes &lt; 0) {</span>
<span class="line-modified">202         THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));</span>


203       }
204     }
205   }
206   return h_array();
207 }
208 
209 // Either oop or narrowOop depending on UseCompressedOops.
210 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
211                             arrayOop d, size_t dst_offset, int length, TRAPS) {
212   if (s == d) {
213     // since source and destination are equal we do not need conversion checks.
214     assert(length &gt; 0, &quot;sanity check&quot;);
215     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
216   } else {
217     // We have to make sure all elements conform to the destination array
218     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
219     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
<span class="line-added">220     // Perform null check if dst is null-free but src has no such guarantee</span>
<span class="line-added">221     bool null_check = ((!s-&gt;klass()-&gt;is_null_free_array_klass()) &amp;&amp;</span>
<span class="line-added">222         d-&gt;klass()-&gt;is_null_free_array_klass());</span>
223     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
<span class="line-modified">224       if (null_check) {</span>
<span class="line-modified">225         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);</span>
<span class="line-added">226       } else {</span>
<span class="line-added">227         ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);</span>
<span class="line-added">228       }</span>
229     } else {
<span class="line-modified">230       if (null_check) {</span>
<span class="line-modified">231         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);</span>
<span class="line-modified">232       } else {</span>
<span class="line-modified">233         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_CHECKCAST&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);</span>












234       }
235     }
236   }
237 }
238 
239 void ObjArrayKlass::copy_array(arrayOop s, int src_pos, arrayOop d,
240                                int dst_pos, int length, TRAPS) {
241   assert(s-&gt;is_objArray(), &quot;must be obj array&quot;);
242 
<span class="line-added">243   if (EnableValhalla) {</span>
<span class="line-added">244     if (d-&gt;is_valueArray()) {</span>
<span class="line-added">245       ValueArrayKlass::cast(d-&gt;klass())-&gt;copy_array(s, src_pos, d, dst_pos, length, THREAD);</span>
<span class="line-added">246       return;</span>
<span class="line-added">247     }</span>
<span class="line-added">248   }</span>
<span class="line-added">249 </span>
250   if (!d-&gt;is_objArray()) {
251     ResourceMark rm(THREAD);
252     stringStream ss;
253     if (d-&gt;is_typeArray()) {
254       ss.print(&quot;arraycopy: type mismatch: can not copy object array[] into %s[]&quot;,
255                type2name_tab[ArrayKlass::cast(d-&gt;klass())-&gt;element_type()]);
256     } else {
257       ss.print(&quot;arraycopy: destination type %s is not an array&quot;, d-&gt;klass()-&gt;external_name());
258     }
259     THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
260   }
261 
262   // Check is all offsets and lengths are non negative
263   if (src_pos &lt; 0 || dst_pos &lt; 0 || length &lt; 0) {
264     // Pass specific exception reason.
265     ResourceMark rm(THREAD);
266     stringStream ss;
267     if (src_pos &lt; 0) {
268       ss.print(&quot;arraycopy: source index %d out of bounds for object array[%d]&quot;,
269                src_pos, s-&gt;length());
</pre>
<hr />
<pre>
302     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(src_pos);
303     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;narrowOop&gt;(dst_pos);
304     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(s, src_offset, NULL) ==
305            objArrayOop(s)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(src_pos), &quot;sanity&quot;);
306     assert(arrayOopDesc::obj_offset_to_raw&lt;narrowOop&gt;(d, dst_offset, NULL) ==
307            objArrayOop(d)-&gt;obj_at_addr_raw&lt;narrowOop&gt;(dst_pos), &quot;sanity&quot;);
308     do_copy(s, src_offset, d, dst_offset, length, CHECK);
309   } else {
310     size_t src_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(src_pos);
311     size_t dst_offset = (size_t) objArrayOopDesc::obj_at_offset&lt;oop&gt;(dst_pos);
312     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(s, src_offset, NULL) ==
313            objArrayOop(s)-&gt;obj_at_addr_raw&lt;oop&gt;(src_pos), &quot;sanity&quot;);
314     assert(arrayOopDesc::obj_offset_to_raw&lt;oop&gt;(d, dst_offset, NULL) ==
315            objArrayOop(d)-&gt;obj_at_addr_raw&lt;oop&gt;(dst_pos), &quot;sanity&quot;);
316     do_copy(s, src_offset, d, dst_offset, length, CHECK);
317   }
318 }
319 
320 
321 Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {

322   assert(dimension() &lt;= n, &quot;check order of chain&quot;);
323   int dim = dimension();
324   if (dim == n) return this;
325 
326   // lock-free read needs acquire semantics
327   if (higher_dimension_acquire() == NULL) {
328     if (or_null) return NULL;
329 
330     ResourceMark rm;

331     {
332       // Ensure atomic creation of higher dimensions
333       MutexLocker mu(THREAD, MultiArray_lock);
334 
335       // Check if another thread beat us
336       if (higher_dimension() == NULL) {
337 
338         // Create multi-dim klass object and link them together
<span class="line-modified">339         Klass* k = ObjArrayKlass::allocate_objArray_klass(dim + 1, this, CHECK_NULL);</span>

340         ObjArrayKlass* ak = ObjArrayKlass::cast(k);
341         ak-&gt;set_lower_dimension(this);
342         // use &#39;release&#39; to pair with lock-free load
343         release_set_higher_dimension(ak);
344         assert(ak-&gt;is_objArray_klass(), &quot;incorrect initialization of ObjArrayKlass&quot;);
345       }
346     }
347   }
348 
349   ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
350   if (or_null) {
351     return ak-&gt;array_klass_or_null(n);
352   }
353   THREAD-&gt;check_possible_safepoint();
354   return ak-&gt;array_klass(n, THREAD);
355 }
356 
357 Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
358   return array_klass_impl(or_null, dimension() +  1, THREAD);
359 }
</pre>
<hr />
<pre>
361 bool ObjArrayKlass::can_be_primary_super_slow() const {
362   if (!bottom_klass()-&gt;can_be_primary_super())
363     // array of interfaces
364     return false;
365   else
366     return Klass::can_be_primary_super_slow();
367 }
368 
369 GrowableArray&lt;Klass*&gt;* ObjArrayKlass::compute_secondary_supers(int num_extra_slots,
370                                                                Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
371   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
372   // interfaces = { cloneable_klass, serializable_klass, elemSuper[], ... };
373   const Array&lt;Klass*&gt;* elem_supers = element_klass()-&gt;secondary_supers();
374   int num_elem_supers = elem_supers == NULL ? 0 : elem_supers-&gt;length();
375   int num_secondaries = num_extra_slots + 2 + num_elem_supers;
376   if (num_secondaries == 2) {
377     // Must share this for correct bootstrapping!
378     set_secondary_supers(Universe::the_array_interfaces_array());
379     return NULL;
380   } else {
<span class="line-modified">381     GrowableArray&lt;Klass*&gt;* secondaries = new GrowableArray&lt;Klass*&gt;(num_elem_supers+3);</span>
382     secondaries-&gt;push(SystemDictionary::Cloneable_klass());
383     secondaries-&gt;push(SystemDictionary::Serializable_klass());
<span class="line-added">384     secondaries-&gt;push(SystemDictionary::IdentityObject_klass());</span>
385     for (int i = 0; i &lt; num_elem_supers; i++) {
386       Klass* elem_super = elem_supers-&gt;at(i);
387       Klass* array_super = elem_super-&gt;array_klass_or_null();
388       assert(array_super != NULL, &quot;must already have been created&quot;);
389       secondaries-&gt;push(array_super);
390     }
391     return secondaries;
392   }
393 }
394 
395 void ObjArrayKlass::initialize(TRAPS) {
396   bottom_klass()-&gt;initialize(THREAD);  // dispatches to either InstanceKlass or TypeArrayKlass
397 }
398 
399 void ObjArrayKlass::metaspace_pointers_do(MetaspaceClosure* it) {
400   ArrayKlass::metaspace_pointers_do(it);
401   it-&gt;push(&amp;_element_klass);
402   it-&gt;push(&amp;_bottom_klass);
403 }
404 
</pre>
<hr />
<pre>
416   return (element_flags &amp; (JVM_ACC_PUBLIC | JVM_ACC_PRIVATE | JVM_ACC_PROTECTED))
417                         | (JVM_ACC_ABSTRACT | JVM_ACC_FINAL);
418 }
419 
420 ModuleEntry* ObjArrayKlass::module() const {
421   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
422   // The array is defined in the module of its bottom class
423   return bottom_klass()-&gt;module();
424 }
425 
426 PackageEntry* ObjArrayKlass::package() const {
427   assert(bottom_klass() != NULL, &quot;ObjArrayKlass returned unexpected NULL bottom_klass&quot;);
428   return bottom_klass()-&gt;package();
429 }
430 
431 // Printing
432 
433 void ObjArrayKlass::print_on(outputStream* st) const {
434 #ifndef PRODUCT
435   Klass::print_on(st);
<span class="line-modified">436   st-&gt;print(&quot; - element klass: &quot;);</span>
437   element_klass()-&gt;print_value_on(st);
438   st-&gt;cr();
439 #endif //PRODUCT
440 }
441 
442 void ObjArrayKlass::print_value_on(outputStream* st) const {
443   assert(is_klass(), &quot;must be klass&quot;);
444 
445   element_klass()-&gt;print_value_on(st);
446   st-&gt;print(&quot;[]&quot;);
447 }
448 
449 #ifndef PRODUCT
450 
451 void ObjArrayKlass::oop_print_on(oop obj, outputStream* st) {
452   ArrayKlass::oop_print_on(obj, st);
453   assert(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
454   objArrayOop oa = objArrayOop(obj);
455   int print_len = MIN2((intx) oa-&gt;length(), MaxElementPrintSize);
456   for(int index = 0; index &lt; print_len; index++) {
</pre>
<hr />
<pre>
478   st-&gt;print(&quot;[%d] &quot;, len);
479   if (obj != NULL) {
480     obj-&gt;print_address_on(st);
481   } else {
482     st-&gt;print_cr(&quot;NULL&quot;);
483   }
484 }
485 
486 const char* ObjArrayKlass::internal_name() const {
487   return external_name();
488 }
489 
490 
491 // Verification
492 
493 void ObjArrayKlass::verify_on(outputStream* st) {
494   ArrayKlass::verify_on(st);
495   guarantee(element_klass()-&gt;is_klass(), &quot;should be klass&quot;);
496   guarantee(bottom_klass()-&gt;is_klass(), &quot;should be klass&quot;);
497   Klass* bk = bottom_klass();
<span class="line-modified">498   guarantee(bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass() || bk-&gt;is_valueArray_klass(),</span>
<span class="line-added">499             &quot;invalid bottom klass&quot;);</span>
500 }
501 
502 void ObjArrayKlass::oop_verify_on(oop obj, outputStream* st) {
503   ArrayKlass::oop_verify_on(obj, st);
504   guarantee(obj-&gt;is_objArray(), &quot;must be objArray&quot;);
505   objArrayOop oa = objArrayOop(obj);
506   for(int index = 0; index &lt; oa-&gt;length(); index++) {
507     guarantee(oopDesc::is_oop_or_null(oa-&gt;obj_at(index)), &quot;should be oop&quot;);
508   }
509 }
</pre>
</td>
</tr>
</table>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/cfgnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
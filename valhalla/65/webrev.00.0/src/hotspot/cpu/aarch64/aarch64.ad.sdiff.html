<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1618 
 1619 #ifndef PRODUCT
 1620 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1621   Compile* C = ra_-&gt;C;
 1622 
 1623   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1624 
 1625   if (C-&gt;output()-&gt;need_stack_bang(framesize))
 1626     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1627 
 1628   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1629     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1630     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1631     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1632   } else {
 1633     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1634     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1635     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1636     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1637   }














 1638 }
 1639 #endif
 1640 
 1641 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1642   Compile* C = ra_-&gt;C;
 1643   C2_MacroAssembler _masm(&amp;cbuf);
 1644 
 1645   __ verified_entry(C, 0);
 1646   __ bind(*_verified_entry);

































 1647 
 1648   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
 1649 
 1650   if (C-&gt;has_mach_constant_base_node()) {
 1651     // NOTE: We set the table base offset here because users might be
 1652     // emitted before MachConstantBaseNode.
 1653     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1654     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1655   }
 1656 }
 1657 
 1658 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1659 {
 1660   return MachNode::size(ra_); // too many variables; just compute it
 1661                               // the hard way
 1662 }
 1663 
 1664 int MachPrologNode::reloc() const
 1665 {
 1666   return 0;
</pre>
<hr />
<pre>
16644   %}
16645   ins_pipe(vdop_fp128);
16646 %}
16647 
16648 instruct vsub2D(vecX dst, vecX src1, vecX src2)
16649 %{
16650   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16651   match(Set dst (SubVD src1 src2));
16652   ins_cost(INSN_COST);
16653   format %{ &quot;fsub  $dst,$src1,$src2\t# vector (2D)&quot; %}
16654   ins_encode %{
16655     __ fsub(as_FloatRegister($dst$$reg), __ T2D,
16656             as_FloatRegister($src1$$reg),
16657             as_FloatRegister($src2$$reg));
16658   %}
16659   ins_pipe(vdop_fp128);
16660 %}
16661 
16662 // --------------------------------- MUL --------------------------------------
16663 





























16664 instruct vmul4S(vecD dst, vecD src1, vecD src2)
16665 %{
16666   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16667             n-&gt;as_Vector()-&gt;length() == 4);
16668   match(Set dst (MulVS src1 src2));
16669   ins_cost(INSN_COST);
16670   format %{ &quot;mulv  $dst,$src1,$src2\t# vector (4H)&quot; %}
16671   ins_encode %{
16672     __ mulv(as_FloatRegister($dst$$reg), __ T4H,
16673             as_FloatRegister($src1$$reg),
16674             as_FloatRegister($src2$$reg));
16675   %}
16676   ins_pipe(vmul64);
16677 %}
16678 
16679 instruct vmul8S(vecX dst, vecX src1, vecX src2)
16680 %{
16681   predicate(n-&gt;as_Vector()-&gt;length() == 8);
16682   match(Set dst (MulVS src1 src2));
16683   ins_cost(INSN_COST);
</pre>
</td>
<td>
<hr />
<pre>
 1618 
 1619 #ifndef PRODUCT
 1620 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1621   Compile* C = ra_-&gt;C;
 1622 
 1623   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1624 
 1625   if (C-&gt;output()-&gt;need_stack_bang(framesize))
 1626     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1627 
 1628   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1629     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1630     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1631     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1632   } else {
 1633     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1634     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1635     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1636     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1637   }
<span class="line-added"> 1638   if (C-&gt;stub_function() == NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {</span>
<span class="line-added"> 1639     st-&gt;print(&quot;\n\t&quot;);</span>
<span class="line-added"> 1640     st-&gt;print(&quot;ldr  rscratch1, [guard]\n\t&quot;);</span>
<span class="line-added"> 1641     st-&gt;print(&quot;dmb ishld\n\t&quot;);</span>
<span class="line-added"> 1642     st-&gt;print(&quot;ldr  rscratch2, [rthread, #thread_disarmed_offset]\n\t&quot;);</span>
<span class="line-added"> 1643     st-&gt;print(&quot;cmp  rscratch1, rscratch2\n\t&quot;);</span>
<span class="line-added"> 1644     st-&gt;print(&quot;b.eq skip&quot;);</span>
<span class="line-added"> 1645     st-&gt;print(&quot;\n\t&quot;);</span>
<span class="line-added"> 1646     st-&gt;print(&quot;blr #nmethod_entry_barrier_stub\n\t&quot;);</span>
<span class="line-added"> 1647     st-&gt;print(&quot;b skip\n\t&quot;);</span>
<span class="line-added"> 1648     st-&gt;print(&quot;guard: int\n\t&quot;);</span>
<span class="line-added"> 1649     st-&gt;print(&quot;\n\t&quot;);</span>
<span class="line-added"> 1650     st-&gt;print(&quot;skip:\n\t&quot;);</span>
<span class="line-added"> 1651   }</span>
 1652 }
 1653 #endif
 1654 
 1655 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1656   Compile* C = ra_-&gt;C;
 1657   C2_MacroAssembler _masm(&amp;cbuf);
 1658 
 1659   __ verified_entry(C, 0);
 1660   __ bind(*_verified_entry);
<span class="line-added"> 1661   // n.b. frame size includes space for return pc and rfp</span>
<span class="line-added"> 1662   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-added"> 1663   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);</span>
<span class="line-added"> 1664 </span>
<span class="line-added"> 1665   // insert a nop at the start of the prolog so we can patch in a</span>
<span class="line-added"> 1666   // branch if we need to invalidate the method later</span>
<span class="line-added"> 1667   __ nop();</span>
<span class="line-added"> 1668 </span>
<span class="line-added"> 1669   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added"> 1670     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added"> 1671 </span>
<span class="line-added"> 1672     Label L_skip_barrier;</span>
<span class="line-added"> 1673 </span>
<span class="line-added"> 1674     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added"> 1675     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);</span>
<span class="line-added"> 1676     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));</span>
<span class="line-added"> 1677     __ bind(L_skip_barrier);</span>
<span class="line-added"> 1678   }</span>
<span class="line-added"> 1679 </span>
<span class="line-added"> 1680   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-added"> 1681   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="line-added"> 1682     __ generate_stack_overflow_check(bangsize);</span>
<span class="line-added"> 1683 </span>
<span class="line-added"> 1684   __ build_frame(framesize);</span>
<span class="line-added"> 1685 </span>
<span class="line-added"> 1686   if (C-&gt;stub_function() == NULL) {</span>
<span class="line-added"> 1687     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added"> 1688     bs-&gt;nmethod_entry_barrier(&amp;_masm);</span>
<span class="line-added"> 1689   }</span>
<span class="line-added"> 1690 </span>
<span class="line-added"> 1691   if (VerifyStackAtCalls) {</span>
<span class="line-added"> 1692     Unimplemented();</span>
<span class="line-added"> 1693   }</span>
 1694 
 1695   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
 1696 
 1697   if (C-&gt;has_mach_constant_base_node()) {
 1698     // NOTE: We set the table base offset here because users might be
 1699     // emitted before MachConstantBaseNode.
 1700     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1701     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1702   }
 1703 }
 1704 
 1705 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1706 {
 1707   return MachNode::size(ra_); // too many variables; just compute it
 1708                               // the hard way
 1709 }
 1710 
 1711 int MachPrologNode::reloc() const
 1712 {
 1713   return 0;
</pre>
<hr />
<pre>
16691   %}
16692   ins_pipe(vdop_fp128);
16693 %}
16694 
16695 instruct vsub2D(vecX dst, vecX src1, vecX src2)
16696 %{
16697   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16698   match(Set dst (SubVD src1 src2));
16699   ins_cost(INSN_COST);
16700   format %{ &quot;fsub  $dst,$src1,$src2\t# vector (2D)&quot; %}
16701   ins_encode %{
16702     __ fsub(as_FloatRegister($dst$$reg), __ T2D,
16703             as_FloatRegister($src1$$reg),
16704             as_FloatRegister($src2$$reg));
16705   %}
16706   ins_pipe(vdop_fp128);
16707 %}
16708 
16709 // --------------------------------- MUL --------------------------------------
16710 
<span class="line-added">16711 instruct vmul8B(vecD dst, vecD src1, vecD src2)</span>
<span class="line-added">16712 %{</span>
<span class="line-added">16713   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||</span>
<span class="line-added">16714             n-&gt;as_Vector()-&gt;length() == 8);</span>
<span class="line-added">16715   match(Set dst (MulVB src1 src2));</span>
<span class="line-added">16716   ins_cost(INSN_COST);</span>
<span class="line-added">16717   format %{ &quot;mulv  $dst,$src1,$src2\t# vector (8B)&quot; %}</span>
<span class="line-added">16718   ins_encode %{</span>
<span class="line-added">16719     __ mulv(as_FloatRegister($dst$$reg), __ T8B,</span>
<span class="line-added">16720             as_FloatRegister($src1$$reg),</span>
<span class="line-added">16721             as_FloatRegister($src2$$reg));</span>
<span class="line-added">16722   %}</span>
<span class="line-added">16723   ins_pipe(vmul64);</span>
<span class="line-added">16724 %}</span>
<span class="line-added">16725 </span>
<span class="line-added">16726 instruct vmul16B(vecX dst, vecX src1, vecX src2)</span>
<span class="line-added">16727 %{</span>
<span class="line-added">16728   predicate(n-&gt;as_Vector()-&gt;length() == 16);</span>
<span class="line-added">16729   match(Set dst (MulVB src1 src2));</span>
<span class="line-added">16730   ins_cost(INSN_COST);</span>
<span class="line-added">16731   format %{ &quot;mulv  $dst,$src1,$src2\t# vector (16B)&quot; %}</span>
<span class="line-added">16732   ins_encode %{</span>
<span class="line-added">16733     __ mulv(as_FloatRegister($dst$$reg), __ T16B,</span>
<span class="line-added">16734             as_FloatRegister($src1$$reg),</span>
<span class="line-added">16735             as_FloatRegister($src2$$reg));</span>
<span class="line-added">16736   %}</span>
<span class="line-added">16737   ins_pipe(vmul128);</span>
<span class="line-added">16738 %}</span>
<span class="line-added">16739 </span>
16740 instruct vmul4S(vecD dst, vecD src1, vecD src2)
16741 %{
16742   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
16743             n-&gt;as_Vector()-&gt;length() == 4);
16744   match(Set dst (MulVS src1 src2));
16745   ins_cost(INSN_COST);
16746   format %{ &quot;mulv  $dst,$src1,$src2\t# vector (4H)&quot; %}
16747   ins_encode %{
16748     __ mulv(as_FloatRegister($dst$$reg), __ T4H,
16749             as_FloatRegister($src1$$reg),
16750             as_FloatRegister($src2$$reg));
16751   %}
16752   ins_pipe(vmul64);
16753 %}
16754 
16755 instruct vmul8S(vecX dst, vecX src1, vecX src2)
16756 %{
16757   predicate(n-&gt;as_Vector()-&gt;length() == 8);
16758   match(Set dst (MulVS src1 src2));
16759   ins_cost(INSN_COST);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../make/test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
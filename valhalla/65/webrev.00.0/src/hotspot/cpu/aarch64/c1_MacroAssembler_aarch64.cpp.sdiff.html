<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_MacroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;

 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;gc/shared/barrierSet.hpp&quot;
 32 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
 34 #include &quot;oops/arrayOop.hpp&quot;
 35 #include &quot;oops/markWord.hpp&quot;
 36 #include &quot;runtime/basicLock.hpp&quot;
 37 #include &quot;runtime/biasedLocking.hpp&quot;
 38 #include &quot;runtime/os.hpp&quot;
 39 #include &quot;runtime/sharedRuntime.hpp&quot;
 40 #include &quot;runtime/stubRoutines.hpp&quot;
 41 
 42 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 43                                   FloatRegister f0, FloatRegister f1,
 44                                   Register result)
 45 {
 46   Label done;
 47   if (is_float) {
 48     fcmps(f0, f1);
 49   } else {
</pre>
<hr />
<pre>
333   // explicit NULL check not needed since load from [klass_offset] causes a trap
334   // check against inline cache
335   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
336 
337   cmp_klass(receiver, iCache, rscratch1);
338 }
339 
340 
341 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, bool needs_stack_repair, Label* verified_value_entry_label) {
342   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
343   // Make sure there is enough stack space for this method&#39;s activation.
344   // Note that we do this before doing an enter().
345   generate_stack_overflow_check(bang_size_in_bytes);
346 
347   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);
348   if (verified_value_entry_label != NULL) {
349     bind(*verified_value_entry_label);
350   }
351 
352   MacroAssembler::build_frame(framesize + 2 * wordSize);




353 }
354 
355 void C1_MacroAssembler::remove_frame(int framesize, bool needs_stack_repair) {
356 
357   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);
358 
359   MacroAssembler::remove_frame(framesize + 2 * wordSize);
360 }
361 
362 void C1_MacroAssembler::verified_value_entry() {
363   if (C1Breakpoint || VerifyFPU || !UseStackBanging) {
364     // Verified Entry first instruction should be 5 bytes long for correct
365     // patching by patch_verified_entry().
366     //
367     // C1Breakpoint and VerifyFPU have one byte first instruction.
368     // Also first instruction will be one byte &quot;push(rbp)&quot; if stack banging
369     // code is not generated (see build_frame() above).
370     // For all these cases generate long instruction first.
371     nop();
372   }
</pre>
</td>
<td>
<hr />
<pre>
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 28 #include &quot;c1/c1_Runtime1.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
 31 #include &quot;gc/shared/collectedHeap.hpp&quot;
 32 #include &quot;gc/shared/barrierSet.hpp&quot;
 33 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;oops/arrayOop.hpp&quot;
 36 #include &quot;oops/markWord.hpp&quot;
 37 #include &quot;runtime/basicLock.hpp&quot;
 38 #include &quot;runtime/biasedLocking.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/sharedRuntime.hpp&quot;
 41 #include &quot;runtime/stubRoutines.hpp&quot;
 42 
 43 void C1_MacroAssembler::float_cmp(bool is_float, int unordered_result,
 44                                   FloatRegister f0, FloatRegister f1,
 45                                   Register result)
 46 {
 47   Label done;
 48   if (is_float) {
 49     fcmps(f0, f1);
 50   } else {
</pre>
<hr />
<pre>
334   // explicit NULL check not needed since load from [klass_offset] causes a trap
335   // check against inline cache
336   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), &quot;must add explicit null check&quot;);
337 
338   cmp_klass(receiver, iCache, rscratch1);
339 }
340 
341 
342 void C1_MacroAssembler::build_frame(int framesize, int bang_size_in_bytes, bool needs_stack_repair, Label* verified_value_entry_label) {
343   assert(bang_size_in_bytes &gt;= framesize, &quot;stack bang size incorrect&quot;);
344   // Make sure there is enough stack space for this method&#39;s activation.
345   // Note that we do this before doing an enter().
346   generate_stack_overflow_check(bang_size_in_bytes);
347 
348   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);
349   if (verified_value_entry_label != NULL) {
350     bind(*verified_value_entry_label);
351   }
352 
353   MacroAssembler::build_frame(framesize + 2 * wordSize);
<span class="line-added">354 </span>
<span class="line-added">355   // Insert nmethod entry barrier into frame.</span>
<span class="line-added">356   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">357   bs-&gt;nmethod_entry_barrier(this);</span>
358 }
359 
360 void C1_MacroAssembler::remove_frame(int framesize, bool needs_stack_repair) {
361 
362   guarantee(needs_stack_repair == false, &quot;Stack repair should not be true&quot;);
363 
364   MacroAssembler::remove_frame(framesize + 2 * wordSize);
365 }
366 
367 void C1_MacroAssembler::verified_value_entry() {
368   if (C1Breakpoint || VerifyFPU || !UseStackBanging) {
369     // Verified Entry first instruction should be 5 bytes long for correct
370     // patching by patch_verified_entry().
371     //
372     // C1Breakpoint and VerifyFPU have one byte first instruction.
373     // Also first instruction will be one byte &quot;push(rbp)&quot; if stack banging
374     // code is not generated (see build_frame() above).
375     // For all these cases generate long instruction first.
376     nop();
377   }
</pre>
</td>
</tr>
</table>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shared/barrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
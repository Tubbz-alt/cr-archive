<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/templateTable_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
4153 
4154       __ eor(rscratch2, tmpU, tmpL);
4155       __ cbz(rscratch2, DONE);
4156 
4157     // Find the first different characters in the longwords and
4158     // compute their difference.
4159     __ bind(CALCULATE_DIFFERENCE);
4160       __ rev(rscratch2, rscratch2);
4161       __ clz(rscratch2, rscratch2);
4162       __ andr(rscratch2, rscratch2, -16);
4163       __ lsrv(tmp1, tmp1, rscratch2);
4164       __ uxthw(tmp1, tmp1);
4165       __ lsrv(rscratch1, rscratch1, rscratch2);
4166       __ uxthw(rscratch1, rscratch1);
4167       __ subw(result, tmp1, rscratch1);
4168     __ bind(DONE);
4169       __ ret(lr);
4170     return entry;
4171   }
4172 












































4173   // r0  = result
4174   // r1  = str1
4175   // r2  = cnt1
4176   // r3  = str2
4177   // r4  = cnt2
4178   // r10 = tmp1
4179   // r11 = tmp2
4180   address generate_compare_long_string_same_encoding(bool isLL) {
4181     __ align(CodeEntryAlignment);
4182     StubCodeMark mark(this, &quot;StubRoutines&quot;, isLL
4183         ? &quot;compare_long_string_same_encoding LL&quot;
4184         : &quot;compare_long_string_same_encoding UU&quot;);
4185     address entry = __ pc();
4186     Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
4187         tmp1 = r10, tmp2 = r11;
4188     Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,
4189         LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,
4190         DIFF_LAST_POSITION, DIFF_LAST_POSITION2;
4191     // exit from large loop when less than 64 bytes left to read or we&#39;re about
4192     // to prefetch memory behind array border
</pre>
<hr />
<pre>
5927                                                 throw_NullPointerException_at_call));
5928 
5929     // arraycopy stubs used by compilers
5930     generate_arraycopy_stubs();
5931 
5932     // has negatives stub for large arrays.
5933     StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);
5934 
5935     // array equals stub for large arrays.
5936     if (!UseSimpleArrayEquals) {
5937       StubRoutines::aarch64::_large_array_equals = generate_large_array_equals();
5938     }
5939 
5940     generate_compare_long_strings();
5941 
5942     generate_string_indexof_stubs();
5943 
5944     // byte_array_inflate stub for large arrays.
5945     StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();
5946 




5947 #ifdef COMPILER2
5948     if (UseMultiplyToLenIntrinsic) {
5949       StubRoutines::_multiplyToLen = generate_multiplyToLen();
5950     }
5951 
5952     if (UseSquareToLenIntrinsic) {
5953       StubRoutines::_squareToLen = generate_squareToLen();
5954     }
5955 
5956     if (UseMulAddIntrinsic) {
5957       StubRoutines::_mulAdd = generate_mulAdd();
5958     }
5959 
5960     if (UseMontgomeryMultiplyIntrinsic) {
5961       StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;montgomeryMultiply&quot;);
5962       MontgomeryMultiplyGenerator g(_masm, /*squaring*/false);
5963       StubRoutines::_montgomeryMultiply = g.generate_multiply();
5964     }
5965 
5966     if (UseMontgomerySquareIntrinsic) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
4153 
4154       __ eor(rscratch2, tmpU, tmpL);
4155       __ cbz(rscratch2, DONE);
4156 
4157     // Find the first different characters in the longwords and
4158     // compute their difference.
4159     __ bind(CALCULATE_DIFFERENCE);
4160       __ rev(rscratch2, rscratch2);
4161       __ clz(rscratch2, rscratch2);
4162       __ andr(rscratch2, rscratch2, -16);
4163       __ lsrv(tmp1, tmp1, rscratch2);
4164       __ uxthw(tmp1, tmp1);
4165       __ lsrv(rscratch1, rscratch1, rscratch2);
4166       __ uxthw(rscratch1, rscratch1);
4167       __ subw(result, tmp1, rscratch1);
4168     __ bind(DONE);
4169       __ ret(lr);
4170     return entry;
4171   }
4172 
<span class="line-added">4173     address generate_method_entry_barrier() {</span>
<span class="line-added">4174     __ align(CodeEntryAlignment);</span>
<span class="line-added">4175     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;nmethod_entry_barrier&quot;);</span>
<span class="line-added">4176 </span>
<span class="line-added">4177     Label deoptimize_label;</span>
<span class="line-added">4178 </span>
<span class="line-added">4179     address start = __ pc();</span>
<span class="line-added">4180 </span>
<span class="line-added">4181     __ set_last_Java_frame(sp, rfp, lr, rscratch1);</span>
<span class="line-added">4182 </span>
<span class="line-added">4183     __ enter();</span>
<span class="line-added">4184     __ add(rscratch2, sp, wordSize);  // rscratch2 points to the saved lr</span>
<span class="line-added">4185 </span>
<span class="line-added">4186     __ sub(sp, sp, 4 * wordSize);  // four words for the returned {sp, fp, lr, pc}</span>
<span class="line-added">4187 </span>
<span class="line-added">4188     __ push_call_clobbered_registers();</span>
<span class="line-added">4189 </span>
<span class="line-added">4190     __ mov(c_rarg0, rscratch2);</span>
<span class="line-added">4191     __ call_VM_leaf</span>
<span class="line-added">4192          (CAST_FROM_FN_PTR</span>
<span class="line-added">4193           (address, BarrierSetNMethod::nmethod_stub_entry_barrier), 1);</span>
<span class="line-added">4194 </span>
<span class="line-added">4195     __ reset_last_Java_frame(true);</span>
<span class="line-added">4196 </span>
<span class="line-added">4197     __ mov(rscratch1, r0);</span>
<span class="line-added">4198 </span>
<span class="line-added">4199     __ pop_call_clobbered_registers();</span>
<span class="line-added">4200 </span>
<span class="line-added">4201     __ cbnz(rscratch1, deoptimize_label);</span>
<span class="line-added">4202 </span>
<span class="line-added">4203     __ leave();</span>
<span class="line-added">4204     __ ret(lr);</span>
<span class="line-added">4205 </span>
<span class="line-added">4206     __ BIND(deoptimize_label);</span>
<span class="line-added">4207 </span>
<span class="line-added">4208     __ ldp(/* new sp */ rscratch1, rfp, Address(sp, 0 * wordSize));</span>
<span class="line-added">4209     __ ldp(lr, /* new pc*/ rscratch2, Address(sp, 2 * wordSize));</span>
<span class="line-added">4210 </span>
<span class="line-added">4211     __ mov(sp, rscratch1);</span>
<span class="line-added">4212     __ br(rscratch2);</span>
<span class="line-added">4213 </span>
<span class="line-added">4214     return start;</span>
<span class="line-added">4215   }</span>
<span class="line-added">4216 </span>
4217   // r0  = result
4218   // r1  = str1
4219   // r2  = cnt1
4220   // r3  = str2
4221   // r4  = cnt2
4222   // r10 = tmp1
4223   // r11 = tmp2
4224   address generate_compare_long_string_same_encoding(bool isLL) {
4225     __ align(CodeEntryAlignment);
4226     StubCodeMark mark(this, &quot;StubRoutines&quot;, isLL
4227         ? &quot;compare_long_string_same_encoding LL&quot;
4228         : &quot;compare_long_string_same_encoding UU&quot;);
4229     address entry = __ pc();
4230     Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,
4231         tmp1 = r10, tmp2 = r11;
4232     Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,
4233         LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,
4234         DIFF_LAST_POSITION, DIFF_LAST_POSITION2;
4235     // exit from large loop when less than 64 bytes left to read or we&#39;re about
4236     // to prefetch memory behind array border
</pre>
<hr />
<pre>
5971                                                 throw_NullPointerException_at_call));
5972 
5973     // arraycopy stubs used by compilers
5974     generate_arraycopy_stubs();
5975 
5976     // has negatives stub for large arrays.
5977     StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);
5978 
5979     // array equals stub for large arrays.
5980     if (!UseSimpleArrayEquals) {
5981       StubRoutines::aarch64::_large_array_equals = generate_large_array_equals();
5982     }
5983 
5984     generate_compare_long_strings();
5985 
5986     generate_string_indexof_stubs();
5987 
5988     // byte_array_inflate stub for large arrays.
5989     StubRoutines::aarch64::_large_byte_array_inflate = generate_large_byte_array_inflate();
5990 
<span class="line-added">5991     BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()-&gt;barrier_set_nmethod();</span>
<span class="line-added">5992     if (bs_nm != NULL) {</span>
<span class="line-added">5993       StubRoutines::aarch64::_method_entry_barrier = generate_method_entry_barrier();</span>
<span class="line-added">5994     }</span>
5995 #ifdef COMPILER2
5996     if (UseMultiplyToLenIntrinsic) {
5997       StubRoutines::_multiplyToLen = generate_multiplyToLen();
5998     }
5999 
6000     if (UseSquareToLenIntrinsic) {
6001       StubRoutines::_squareToLen = generate_squareToLen();
6002     }
6003 
6004     if (UseMulAddIntrinsic) {
6005       StubRoutines::_mulAdd = generate_mulAdd();
6006     }
6007 
6008     if (UseMontgomeryMultiplyIntrinsic) {
6009       StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;montgomeryMultiply&quot;);
6010       MontgomeryMultiplyGenerator g(_masm, /*squaring*/false);
6011       StubRoutines::_montgomeryMultiply = g.generate_multiply();
6012     }
6013 
6014     if (UseMontgomerySquareIntrinsic) {
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../x86/templateTable_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
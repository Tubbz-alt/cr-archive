<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/shared/barrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3722     adr = Address(rscratch2);
3723     break;
3724   }
3725   ldr(rscratch1, adr);
3726   add(rscratch1, rscratch1, src);
3727   str(rscratch1, adr);
3728 }
3729 
3730 void MacroAssembler::cmpptr(Register src1, Address src2) {
3731   unsigned long offset;
3732   adrp(rscratch1, src2, offset);
3733   ldr(rscratch1, Address(rscratch1, offset));
3734   cmp(src1, rscratch1);
3735 }
3736 
3737 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3738   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3739   bs-&gt;obj_equals(this, obj1, obj2);
3740 }
3741 





3742 void MacroAssembler::load_method_holder(Register holder, Register method) {
3743   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3744   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3745   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3746 }
3747 
3748 void MacroAssembler::load_metadata(Register dst, Register src) {
3749   if (UseCompressedClassPointers) {
3750     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3751   } else {
3752     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3753   }
3754 }
3755 
3756 void MacroAssembler::load_klass(Register dst, Register src) {
3757   load_metadata(dst, src);
3758   if (UseCompressedClassPointers) {
3759     andr(dst, dst, oopDesc::compressed_klass_mask());
3760     decode_klass_not_null(dst);
3761   } else {
3762     ubfm(dst, dst, 0, 63 - oopDesc::storage_props_nof_bits);
3763   }
3764 }
3765 
3766 // ((OopHandle)result).resolve();
3767 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3768   // OopHandle::resolve is an indirection.
3769   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3770 }
3771 
















3772 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3773   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3774   ldr(dst, Address(rmethod, Method::const_offset()));
3775   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3776   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3777   ldr(dst, Address(dst, mirror_offset));
3778   resolve_oop_handle(dst, tmp);
3779 }
3780 
3781 void MacroAssembler::load_storage_props(Register dst, Register src) {
3782   load_metadata(dst, src);
3783   if (UseCompressedClassPointers) {
3784     asrw(dst, dst, oopDesc::narrow_storage_props_shift);
3785   } else {
3786     asr(dst, dst, oopDesc::wide_storage_props_shift);
3787   }
3788 }
3789 
3790 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3791   if (UseCompressedClassPointers) {
</pre>
<hr />
<pre>
4156 }
4157 
4158 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4159                                     Register thread_tmp, Register tmp3, DecoratorSet decorators) {
4160   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);
4161 }
4162 
4163 // Used for storing NULLs.
4164 void MacroAssembler::store_heap_oop_null(Address dst) {
4165   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4166 }
4167 
4168 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4169   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4170   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4171   RelocationHolder rspec = metadata_Relocation::spec(index);
4172   return Address((address)obj, rspec);
4173 }
4174 
4175 // Move an oop into a register.  immediate is true if we want
<span class="line-modified">4176 // immediate instrcutions, i.e. we are not going to patch this</span>
<span class="line-modified">4177 // instruction while the code is being executed by another thread.  In</span>
<span class="line-modified">4178 // that case we can use move immediates rather than the constant pool.</span>
4179 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4180   int oop_index;
4181   if (obj == NULL) {
4182     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4183   } else {
4184 #ifdef ASSERT
4185     {
4186       ThreadInVMfromUnknown tiv;
4187       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4188     }
4189 #endif
4190     oop_index = oop_recorder()-&gt;find_index(obj);
4191   }
4192   RelocationHolder rspec = oop_Relocation::spec(oop_index);
<span class="line-modified">4193   if (! immediate) {</span>




4194     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4195     ldr_constant(dst, Address(dummy, rspec));
4196   } else
4197     mov(dst, Address((address)obj, rspec));

4198 }
4199 
4200 // Move a metadata address into a register.
4201 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4202   int oop_index;
4203   if (obj == NULL) {
4204     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4205   } else {
4206     oop_index = oop_recorder()-&gt;find_index(obj);
4207   }
4208   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4209   mov(dst, Address((address)obj, rspec));
4210 }
4211 
4212 Address MacroAssembler::constant_oop_address(jobject obj) {
4213 #ifdef ASSERT
4214   {
4215     ThreadInVMfromUnknown tiv;
4216     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4217     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
</pre>
</td>
<td>
<hr />
<pre>
3722     adr = Address(rscratch2);
3723     break;
3724   }
3725   ldr(rscratch1, adr);
3726   add(rscratch1, rscratch1, src);
3727   str(rscratch1, adr);
3728 }
3729 
3730 void MacroAssembler::cmpptr(Register src1, Address src2) {
3731   unsigned long offset;
3732   adrp(rscratch1, src2, offset);
3733   ldr(rscratch1, Address(rscratch1, offset));
3734   cmp(src1, rscratch1);
3735 }
3736 
3737 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3738   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3739   bs-&gt;obj_equals(this, obj1, obj2);
3740 }
3741 
<span class="line-added">3742 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {</span>
<span class="line-added">3743   load_method_holder(rresult, rmethod);</span>
<span class="line-added">3744   ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));</span>
<span class="line-added">3745 }</span>
<span class="line-added">3746 </span>
3747 void MacroAssembler::load_method_holder(Register holder, Register method) {
3748   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3749   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3750   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3751 }
3752 
3753 void MacroAssembler::load_metadata(Register dst, Register src) {
3754   if (UseCompressedClassPointers) {
3755     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3756   } else {
3757     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3758   }
3759 }
3760 
3761 void MacroAssembler::load_klass(Register dst, Register src) {
3762   load_metadata(dst, src);
3763   if (UseCompressedClassPointers) {
3764     andr(dst, dst, oopDesc::compressed_klass_mask());
3765     decode_klass_not_null(dst);
3766   } else {
3767     ubfm(dst, dst, 0, 63 - oopDesc::storage_props_nof_bits);
3768   }
3769 }
3770 
3771 // ((OopHandle)result).resolve();
3772 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3773   // OopHandle::resolve is an indirection.
3774   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3775 }
3776 
<span class="line-added">3777 // ((WeakHandle)result).resolve();</span>
<span class="line-added">3778 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {</span>
<span class="line-added">3779   assert_different_registers(rresult, rtmp);</span>
<span class="line-added">3780   Label resolved;</span>
<span class="line-added">3781 </span>
<span class="line-added">3782   // A null weak handle resolves to null.</span>
<span class="line-added">3783   cbz(rresult, resolved);</span>
<span class="line-added">3784 </span>
<span class="line-added">3785   // Only 64 bit platforms support GCs that require a tmp register</span>
<span class="line-added">3786   // Only IN_HEAP loads require a thread_tmp register</span>
<span class="line-added">3787   // WeakHandle::resolve is an indirection like jweak.</span>
<span class="line-added">3788   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,</span>
<span class="line-added">3789                  rresult, Address(rresult), rtmp, /*tmp_thread*/noreg);</span>
<span class="line-added">3790   bind(resolved);</span>
<span class="line-added">3791 }</span>
<span class="line-added">3792 </span>
3793 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3794   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3795   ldr(dst, Address(rmethod, Method::const_offset()));
3796   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3797   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3798   ldr(dst, Address(dst, mirror_offset));
3799   resolve_oop_handle(dst, tmp);
3800 }
3801 
3802 void MacroAssembler::load_storage_props(Register dst, Register src) {
3803   load_metadata(dst, src);
3804   if (UseCompressedClassPointers) {
3805     asrw(dst, dst, oopDesc::narrow_storage_props_shift);
3806   } else {
3807     asr(dst, dst, oopDesc::wide_storage_props_shift);
3808   }
3809 }
3810 
3811 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3812   if (UseCompressedClassPointers) {
</pre>
<hr />
<pre>
4177 }
4178 
4179 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
4180                                     Register thread_tmp, Register tmp3, DecoratorSet decorators) {
4181   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);
4182 }
4183 
4184 // Used for storing NULLs.
4185 void MacroAssembler::store_heap_oop_null(Address dst) {
4186   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);
4187 }
4188 
4189 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4190   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4191   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4192   RelocationHolder rspec = metadata_Relocation::spec(index);
4193   return Address((address)obj, rspec);
4194 }
4195 
4196 // Move an oop into a register.  immediate is true if we want
<span class="line-modified">4197 // immediate instructions and nmethod entry barriers are not enabled.</span>
<span class="line-modified">4198 // i.e. we are not going to patch this instruction while the code is being</span>
<span class="line-modified">4199 // executed by another thread.</span>
4200 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4201   int oop_index;
4202   if (obj == NULL) {
4203     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4204   } else {
4205 #ifdef ASSERT
4206     {
4207       ThreadInVMfromUnknown tiv;
4208       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4209     }
4210 #endif
4211     oop_index = oop_recorder()-&gt;find_index(obj);
4212   }
4213   RelocationHolder rspec = oop_Relocation::spec(oop_index);
<span class="line-modified">4214 </span>
<span class="line-added">4215   // nmethod entry barrier necessitate using the constant pool. They have to be</span>
<span class="line-added">4216   // ordered with respected to oop accesses.</span>
<span class="line-added">4217   // Using immediate literals would necessitate ISBs.</span>
<span class="line-added">4218   if (BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL || !immediate) {</span>
4219     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4220     ldr_constant(dst, Address(dummy, rspec));
4221   } else
4222     mov(dst, Address((address)obj, rspec));
<span class="line-added">4223 </span>
4224 }
4225 
4226 // Move a metadata address into a register.
4227 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4228   int oop_index;
4229   if (obj == NULL) {
4230     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4231   } else {
4232     oop_index = oop_recorder()-&gt;find_index(obj);
4233   }
4234   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4235   mov(dst, Address((address)obj, rspec));
4236 }
4237 
4238 Address MacroAssembler::constant_oop_address(jobject obj) {
4239 #ifdef ASSERT
4240   {
4241     ThreadInVMfromUnknown tiv;
4242     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4243     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="gc/shared/barrierSetAssembler_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
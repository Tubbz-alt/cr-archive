<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 










 113   enum {
 114     _has_preresolution    = 1,       // Flags
 115     _on_stack             = 2,
 116     _is_shared            = 4,
 117     _has_dynamic_constant = 8
 118   };
 119 
<span class="line-modified"> 120   int                  _flags;  // old fashioned bit twiddling</span>
<span class="line-modified"> 121   int                  _length; // number of elements in the array</span>

 122 
 123   union {
 124     // set for CDS to restore resolved references
 125     int                _resolved_reference_length;
 126     // keeps version number for redefined classes (used in backtrace)
 127     int                _version;
 128   } _saved;
 129 
 130   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 131   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 132   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 133 
 134   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 135 
 136   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 137 
<span class="line-modified"> 138   int flags() const                            { return _flags; }</span>
<span class="line-modified"> 139   void set_flags(int f)                        { _flags = f; }</span>
 140 
 141  private:
 142   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 143 
 144   CPSlot slot_at(int which) const;
 145 
 146   void slot_at_put(int which, CPSlot s) const {
 147     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 148     assert(s.value() != 0, &quot;Caught something&quot;);
 149     *(intptr_t*)&amp;base()[which] = s.value();
 150   }
 151   intptr_t* obj_at_addr(int which) const {
 152     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 153     return (intptr_t*) &amp;base()[which];
 154   }
 155 
 156   jint* int_at_addr(int which) const {
 157     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 158     return (jint*) &amp;base()[which];
 159   }
</pre>
<hr />
<pre>
 172     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 173     return (jdouble*) &amp;base()[which];
 174   }
 175 
 176   ConstantPool(Array&lt;u1&gt;* tags);
 177   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 178  public:
 179   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 180 
 181   bool is_constantPool() const volatile     { return true; }
 182 
 183   Array&lt;u1&gt;* tags() const                   { return _tags; }
 184   Array&lt;u2&gt;* operands() const               { return _operands; }
 185 
 186   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 187   void set_has_preresolution() {
 188     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 189     _flags |= _has_preresolution;
 190   }
 191 
























 192   // Redefine classes support.  If a method refering to this constant pool
 193   // is on the executing stack, or as a handle in vm code, this constant pool
 194   // can&#39;t be removed from the set of previous versions saved in the instance
 195   // class.
 196   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 197   void set_on_stack(const bool value);
 198 
 199   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 200   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 201 
 202   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 203   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 204 
 205   // Klass holding pool
 206   InstanceKlass* pool_holder() const      { return _pool_holder; }
 207   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 208   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 209 
 210   // Interpreter runtime support
 211   ConstantPoolCache* cache() const        { return _cache; }
</pre>
</td>
<td>
<hr />
<pre>
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
<span class="line-added"> 113   u2              _major_version;        // major version number of class file</span>
<span class="line-added"> 114   u2              _minor_version;        // minor version number of class file</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116   // Constant pool index to the utf8 entry of the Generic signature,</span>
<span class="line-added"> 117   // or 0 if none.</span>
<span class="line-added"> 118   u2              _generic_signature_index;</span>
<span class="line-added"> 119   // Constant pool index to the utf8 entry for the name of source file</span>
<span class="line-added"> 120   // containing this klass, 0 if not specified.</span>
<span class="line-added"> 121   u2              _source_file_name_index;</span>
<span class="line-added"> 122 </span>
 123   enum {
 124     _has_preresolution    = 1,       // Flags
 125     _on_stack             = 2,
 126     _is_shared            = 4,
 127     _has_dynamic_constant = 8
 128   };
 129 
<span class="line-modified"> 130   u2              _flags;  // old fashioned bit twiddling</span>
<span class="line-modified"> 131 </span>
<span class="line-added"> 132   int             _length; // number of elements in the array</span>
 133 
 134   union {
 135     // set for CDS to restore resolved references
 136     int                _resolved_reference_length;
 137     // keeps version number for redefined classes (used in backtrace)
 138     int                _version;
 139   } _saved;
 140 
 141   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 142   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 143   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 144 
 145   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 146 
 147   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 148 
<span class="line-modified"> 149   u2 flags() const                             { return _flags; }</span>
<span class="line-modified"> 150   void set_flags(u2 f)                         { _flags = f; }</span>
 151 
 152  private:
 153   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 154 
 155   CPSlot slot_at(int which) const;
 156 
 157   void slot_at_put(int which, CPSlot s) const {
 158     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 159     assert(s.value() != 0, &quot;Caught something&quot;);
 160     *(intptr_t*)&amp;base()[which] = s.value();
 161   }
 162   intptr_t* obj_at_addr(int which) const {
 163     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 164     return (intptr_t*) &amp;base()[which];
 165   }
 166 
 167   jint* int_at_addr(int which) const {
 168     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 169     return (jint*) &amp;base()[which];
 170   }
</pre>
<hr />
<pre>
 183     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 184     return (jdouble*) &amp;base()[which];
 185   }
 186 
 187   ConstantPool(Array&lt;u1&gt;* tags);
 188   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 189  public:
 190   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 191 
 192   bool is_constantPool() const volatile     { return true; }
 193 
 194   Array&lt;u1&gt;* tags() const                   { return _tags; }
 195   Array&lt;u2&gt;* operands() const               { return _operands; }
 196 
 197   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 198   void set_has_preresolution() {
 199     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 200     _flags |= _has_preresolution;
 201   }
 202 
<span class="line-added"> 203   // minor and major version numbers of class file</span>
<span class="line-added"> 204   u2 major_version() const                 { return _major_version; }</span>
<span class="line-added"> 205   void set_major_version(u2 major_version) { _major_version = major_version; }</span>
<span class="line-added"> 206   u2 minor_version() const                 { return _minor_version; }</span>
<span class="line-added"> 207   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }</span>
<span class="line-added"> 208 </span>
<span class="line-added"> 209   // generics support</span>
<span class="line-added"> 210   Symbol* generic_signature() const {</span>
<span class="line-added"> 211     return (_generic_signature_index == 0) ?</span>
<span class="line-added"> 212       (Symbol*)NULL : symbol_at(_generic_signature_index);</span>
<span class="line-added"> 213   }</span>
<span class="line-added"> 214   u2 generic_signature_index() const                   { return _generic_signature_index; }</span>
<span class="line-added"> 215   void set_generic_signature_index(u2 sig_index)       { _generic_signature_index = sig_index; }</span>
<span class="line-added"> 216 </span>
<span class="line-added"> 217   // source file name</span>
<span class="line-added"> 218   Symbol* source_file_name() const {</span>
<span class="line-added"> 219     return (_source_file_name_index == 0) ?</span>
<span class="line-added"> 220       (Symbol*)NULL : symbol_at(_source_file_name_index);</span>
<span class="line-added"> 221   }</span>
<span class="line-added"> 222   u2 source_file_name_index() const                    { return _source_file_name_index; }</span>
<span class="line-added"> 223   void set_source_file_name_index(u2 sourcefile_index) { _source_file_name_index = sourcefile_index; }</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225   void copy_fields(const ConstantPool* orig);</span>
<span class="line-added"> 226 </span>
 227   // Redefine classes support.  If a method refering to this constant pool
 228   // is on the executing stack, or as a handle in vm code, this constant pool
 229   // can&#39;t be removed from the set of previous versions saved in the instance
 230   // class.
 231   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 232   void set_on_stack(const bool value);
 233 
 234   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 235   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 236 
 237   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 238   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 239 
 240   // Klass holding pool
 241   InstanceKlass* pool_holder() const      { return _pool_holder; }
 242   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 243   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 244 
 245   // Interpreter runtime support
 246   ConstantPoolCache* cache() const        { return _cache; }
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
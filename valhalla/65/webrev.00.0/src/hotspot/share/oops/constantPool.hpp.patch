diff a/src/hotspot/share/oops/constantPool.hpp b/src/hotspot/share/oops/constantPool.hpp
--- a/src/hotspot/share/oops/constantPool.hpp
+++ b/src/hotspot/share/oops/constantPool.hpp
@@ -108,19 +108,30 @@
 
   // Consider using an array of compressed klass pointers to
   // save space on 64-bit platforms.
   Array<Klass*>*       _resolved_klasses;
 
+  u2              _major_version;        // major version number of class file
+  u2              _minor_version;        // minor version number of class file
+
+  // Constant pool index to the utf8 entry of the Generic signature,
+  // or 0 if none.
+  u2              _generic_signature_index;
+  // Constant pool index to the utf8 entry for the name of source file
+  // containing this klass, 0 if not specified.
+  u2              _source_file_name_index;
+
   enum {
     _has_preresolution    = 1,       // Flags
     _on_stack             = 2,
     _is_shared            = 4,
     _has_dynamic_constant = 8
   };
 
-  int                  _flags;  // old fashioned bit twiddling
-  int                  _length; // number of elements in the array
+  u2              _flags;  // old fashioned bit twiddling
+
+  int             _length; // number of elements in the array
 
   union {
     // set for CDS to restore resolved references
     int                _resolved_reference_length;
     // keeps version number for redefined classes (used in backtrace)
@@ -133,12 +144,12 @@
 
   u1* tag_addr_at(int which) const             { return tags()->adr_at(which); }
 
   void set_operands(Array<u2>* operands)       { _operands = operands; }
 
-  int flags() const                            { return _flags; }
-  void set_flags(int f)                        { _flags = f; }
+  u2 flags() const                             { return _flags; }
+  void set_flags(u2 f)                         { _flags = f; }
 
  private:
   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 
   CPSlot slot_at(int which) const;
@@ -187,10 +198,34 @@
   void set_has_preresolution() {
     assert(!is_shared(), "should never be called on shared ConstantPools");
     _flags |= _has_preresolution;
   }
 
+  // minor and major version numbers of class file
+  u2 major_version() const                 { return _major_version; }
+  void set_major_version(u2 major_version) { _major_version = major_version; }
+  u2 minor_version() const                 { return _minor_version; }
+  void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
+
+  // generics support
+  Symbol* generic_signature() const {
+    return (_generic_signature_index == 0) ?
+      (Symbol*)NULL : symbol_at(_generic_signature_index);
+  }
+  u2 generic_signature_index() const                   { return _generic_signature_index; }
+  void set_generic_signature_index(u2 sig_index)       { _generic_signature_index = sig_index; }
+
+  // source file name
+  Symbol* source_file_name() const {
+    return (_source_file_name_index == 0) ?
+      (Symbol*)NULL : symbol_at(_source_file_name_index);
+  }
+  u2 source_file_name_index() const                    { return _source_file_name_index; }
+  void set_source_file_name_index(u2 sourcefile_index) { _source_file_name_index = sourcefile_index; }
+
+  void copy_fields(const ConstantPool* orig);
+
   // Redefine classes support.  If a method refering to this constant pool
   // is on the executing stack, or as a handle in vm code, this constant pool
   // can't be removed from the set of previous versions saved in the instance
   // class.
   bool on_stack() const                      { return (_flags &_on_stack) != 0; }

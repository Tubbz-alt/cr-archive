<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 201   // Constant pool for this class.
 202   ConstantPool* _constants;
 203   // The InnerClasses attribute and EnclosingMethod attribute. The
 204   // _inner_classes is an array of shorts. If the class has InnerClasses
 205   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 206   // [inner_class_info_index, outer_class_info_index,
 207   // inner_name_index, inner_class_access_flags] for the InnerClasses
 208   // attribute. If the EnclosingMethod attribute exists, it occupies the
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 
<span class="line-removed"> 221   // The NestHost attribute. The class info index for the class</span>
<span class="line-removed"> 222   // that is the nest-host of this class. This data has not been validated.</span>
<span class="line-removed"> 223   jushort _nest_host_index;</span>
<span class="line-removed"> 224 </span>
 225   // Resolved nest-host klass: either true nest-host or self if we are not
 226   // nested, or an error occurred resolving or validating the nominated
 227   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 228   // relationships.
 229   // By always being set it makes nest-member access checks simpler.
 230   InstanceKlass* _nest_host;
 231 
 232   Array&lt;InlineTypes&gt;* _inline_types;
 233 
 234   // The contents of the Record attribute.
 235   Array&lt;RecordComponent*&gt;* _record_components;
 236 
 237   // the source debug extension for this klass, NULL if not specified.
 238   // Specified as UTF-8 string without terminating zero byte in the classfile,
 239   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 240   const char*     _source_debug_extension;
<span class="line-removed"> 241   // Array name derived from this class which needs unreferencing</span>
<span class="line-removed"> 242   // if this class is unloaded.</span>
<span class="line-removed"> 243   Symbol*         _array_name;</span>
 244 
 245   // Number of heapOopSize words used by non-static fields in this klass
 246   // (including inherited fields but after header_size()).
 247   int             _nonstatic_field_size;
 248   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
<span class="line-modified"> 249   // Constant pool index to the utf8 entry of the Generic signature,</span>
<span class="line-modified"> 250   // or 0 if none.</span>
<span class="line-modified"> 251   u2              _generic_signature_index;</span>
<span class="line-modified"> 252   // Constant pool index to the utf8 entry for the name of source file</span>
<span class="line-modified"> 253   // containing this klass, 0 if not specified.</span>
<span class="line-modified"> 254   u2              _source_file_name_index;</span>



 255   u2              _static_oop_field_count;// number of static oop fields in this klass
 256   u2              _java_fields_count;    // The number of declared Java fields
<span class="line-modified"> 257   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks</span>
<span class="line-modified"> 258 </span>
 259   int             _itable_len;           // length of Java itable (in words)
 260   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 261   // _misc_flags.
 262   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 263 
<span class="line-modified"> 264   // The low three bits of _misc_flags contains the kind field.</span>
<span class="line-modified"> 265   // This can be used to quickly discriminate among the five kinds of</span>
<span class="line-modified"> 266   // InstanceKlass.</span>

 267 
<span class="line-modified"> 268   static const unsigned _misc_kind_field_size = 3;</span>
<span class="line-modified"> 269   static const unsigned _misc_kind_field_pos  = 0;</span>
<span class="line-modified"> 270   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;</span>




 271 
<span class="line-modified"> 272   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass</span>
<span class="line-modified"> 273   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass</span>
<span class="line-removed"> 274   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass</span>
<span class="line-removed"> 275   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass</span>
<span class="line-removed"> 276   static const unsigned _misc_kind_inline_type  = 4; // InlineKlass</span>
 277 
<span class="line-modified"> 278   // Start after _misc_kind field.</span>
<span class="line-modified"> 279   enum {</span>
<span class="line-modified"> 280     _misc_rewritten                           = 1 &lt;&lt; 3,  // methods rewritten.</span>
<span class="line-modified"> 281     _misc_has_nonstatic_fields                = 1 &lt;&lt; 4,  // for sizing with UseCompressedOops</span>
<span class="line-modified"> 282     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification</span>
<span class="line-modified"> 283     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field</span>
<span class="line-modified"> 284     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation</span>
<span class="line-modified"> 285     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods</span>
<span class="line-modified"> 286     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods</span>
<span class="line-removed"> 287     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined</span>
 288     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 289                                                          // code source was found to be matching the value recorded by AOT.
<span class="line-modified"> 290     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class</span>
<span class="line-modified"> 291     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader</span>
<span class="line-modified"> 292     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader</span>
<span class="line-modified"> 293     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader</span>
<span class="line-modified"> 294     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class</span>
<span class="line-modified"> 295     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition</span>
<span class="line-modified"> 296     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation</span>
<span class="line-modified"> 297     _misc_has_inline_fields                   = 1 &lt;&lt; 19, // has inline fields and related embedded section is not empty</span>
<span class="line-modified"> 298     _misc_is_empty_inline_type                = 1 &lt;&lt; 20, // empty inline type</span>
<span class="line-modified"> 299     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction</span>
<span class="line-modified"> 300     _misc_is_declared_atomic                  = 1 &lt;&lt; 22, // implements jl.NonTearable</span>
<span class="line-modified"> 301     _misc_invalid_inline_super                = 1 &lt;&lt; 23, // invalid super type for an inline type</span>
<span class="line-modified"> 302     _misc_invalid_identity_super              = 1 &lt;&lt; 24, // invalid super type for an identity type</span>
<span class="line-modified"> 303     _misc_has_injected_identityObject         = 1 &lt;&lt; 25  // IdentityObject has been injected by the JVM</span>
 304   };
 305   u2 shared_loader_type_bits() const {
 306     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 307   }
<span class="line-modified"> 308   u4              _misc_flags;</span>
<span class="line-modified"> 309   u2              _minor_version;        // minor version number of class file</span>
<span class="line-removed"> 310   u2              _major_version;        // major version number of class file</span>
 311   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 312   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 313   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 314   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 315   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 316   uint64_t        volatile _dep_context_last_cleaned;
 317   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 318 #if INCLUDE_JVMTI
 319   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 320   // Linked instanceKlasses of previous versions
 321   InstanceKlass* _previous_versions;
 322   // JVMTI fields can be moved to their own structure - see 6315920
 323   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 324   JvmtiCachedClassFileData* _cached_class_file;
 325 #endif
 326 
<span class="line-removed"> 327   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329   // Class states are defined as ClassState (see above).</span>
<span class="line-removed"> 330   // Place the _init_state here to utilize the unused 2-byte after</span>
<span class="line-removed"> 331   // _idnum_allocated_count.</span>
<span class="line-removed"> 332   u1              _init_state;                    // state of class</span>
<span class="line-removed"> 333   u1              _reference_type;                // reference type</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335   u2              _this_class_index;              // constant pool entry</span>
 336 #if INCLUDE_JVMTI
 337   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 338 #endif
 339 
 340   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 341 
 342   // Method array.
 343   Array&lt;Method*&gt;* _methods;
 344   // Default Method Array, concrete methods inherited from interfaces
 345   Array&lt;Method*&gt;* _default_methods;
 346   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 347   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 348   // Interfaces (InstanceKlass*s) this class implements transitively.
 349   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 350   // Int array containing the original order of method in the class file (for JVMTI).
 351   Array&lt;int&gt;*     _method_ordering;
 352   // Int array containing the vtable_indices for default_methods
 353   // offset matches _default_methods offset
 354   Array&lt;int&gt;*     _default_vtable_indices;
 355 
</pre>
<hr />
<pre>
 660   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 661   ClassState  init_state()                 { return (ClassState)_init_state; }
 662   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 663 
 664   // defineClass specified verification
 665   bool should_verify_class() const         {
 666     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 667   }
 668   void set_should_verify_class(bool value) {
 669     if (value) {
 670       _misc_flags |= _misc_should_verify_class;
 671     } else {
 672       _misc_flags &amp;= ~_misc_should_verify_class;
 673     }
 674   }
 675 
 676   // marking
 677   bool is_marked_dependent() const         { return _is_marked_dependent; }
 678   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 679 

 680   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 681   static u4 misc_flags_is_empty_inline_type() { return _misc_is_empty_inline_type; }
 682 
 683   // initialization (virtuals from Klass)
 684   bool should_be_initialized() const;  // means that initialize should be called
 685   void initialize(TRAPS);
 686   void link_class(TRAPS);
 687   bool link_class_or_fail(TRAPS); // returns false on failure
 688   void rewrite_class(TRAPS);
 689   void link_methods(TRAPS);
 690   Method* class_initializer() const;
 691 
 692   // set the class to initialized if no static initializer is present
 693   void eager_initialize(Thread *thread);
 694 
 695   // reference type
 696   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 697   void set_reference_type(ReferenceType t) {
 698     assert(t == (u1)t, &quot;overflow&quot;);
 699     _reference_type = (u1)t;
</pre>
<hr />
<pre>
 823   void set_is_unsafe_anonymous(bool value)        {
 824     if (value) {
 825       _misc_flags |= _misc_is_unsafe_anonymous;
 826     } else {
 827       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 828     }
 829   }
 830 
 831   bool is_contended() const                {
 832     return (_misc_flags &amp; _misc_is_contended) != 0;
 833   }
 834   void set_is_contended(bool value)        {
 835     if (value) {
 836       _misc_flags |= _misc_is_contended;
 837     } else {
 838       _misc_flags &amp;= ~_misc_is_contended;
 839     }
 840   }
 841 
 842   // source file name
<span class="line-modified"> 843   Symbol* source_file_name() const               {</span>
<span class="line-modified"> 844     return (_source_file_name_index == 0) ?</span>
<span class="line-modified"> 845       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);</span>
<span class="line-removed"> 846   }</span>
<span class="line-removed"> 847   u2 source_file_name_index() const              {</span>
<span class="line-removed"> 848     return _source_file_name_index;</span>
<span class="line-removed"> 849   }</span>
<span class="line-removed"> 850   void set_source_file_name_index(u2 sourcefile_index) {</span>
<span class="line-removed"> 851     _source_file_name_index = sourcefile_index;</span>
<span class="line-removed"> 852   }</span>
 853 
 854   // minor and major version numbers of class file
<span class="line-modified"> 855   u2 minor_version() const                 { return _minor_version; }</span>
<span class="line-modified"> 856   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }</span>
<span class="line-modified"> 857   u2 major_version() const                 { return _major_version; }</span>
<span class="line-modified"> 858   void set_major_version(u2 major_version) { _major_version = major_version; }</span>
 859 
 860   // source debug extension
 861   const char* source_debug_extension() const { return _source_debug_extension; }
 862   void set_source_debug_extension(const char* array, int length);
 863 
<span class="line-removed"> 864   // symbol unloading support (refcount already added)</span>
<span class="line-removed"> 865   Symbol* array_name()                     { return _array_name; }</span>
<span class="line-removed"> 866   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }</span>
<span class="line-removed"> 867 </span>
 868   // nonstatic oop-map blocks
 869   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 870     return oop_map_count * OopMapBlock::size_in_words();
 871   }
 872   unsigned int nonstatic_oop_map_count() const {
 873     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 874   }
 875   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 876   void set_nonstatic_oop_map_size(int words) {
 877     _nonstatic_oop_map_size = words;
 878   }
 879 
 880   bool has_contended_annotations() const {
 881     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 882   }
 883   void set_has_contended_annotations(bool value)  {
 884     if (value) {
 885       _misc_flags |= _misc_has_contended_annotations;
 886     } else {
 887       _misc_flags &amp;= ~_misc_has_contended_annotations;
</pre>
<hr />
<pre>
 946   void store_fingerprint(uint64_t fingerprint);
 947 
 948   bool is_scratch_class() const {
 949     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 950   }
 951 
 952   void set_is_scratch_class() {
 953     _misc_flags |= _misc_is_scratch_class;
 954   }
 955 
 956   bool has_resolved_methods() const {
 957     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 958   }
 959 
 960   void set_has_resolved_methods() {
 961     _misc_flags |= _misc_has_resolved_methods;
 962   }
 963 private:
 964 
 965   void set_kind(unsigned kind) {
<span class="line-modified"> 966     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);</span>
<span class="line-removed"> 967     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;</span>
<span class="line-removed"> 968     unsigned flags = _misc_flags &amp; ~fmask;</span>
<span class="line-removed"> 969     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));</span>
 970   }
 971 
 972   bool is_kind(unsigned desired) const {
<span class="line-modified"> 973     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;</span>
<span class="line-removed"> 974     return kind == desired;</span>
 975   }
 976 
 977 public:
 978 
 979   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
<span class="line-modified"> 980   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }</span>
<span class="line-modified"> 981   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }</span>
<span class="line-modified"> 982   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }</span>
<span class="line-modified"> 983   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }</span>
<span class="line-modified"> 984   bool is_inline_type_klass()           const { return is_kind(_misc_kind_inline_type); }</span>
 985 
 986 #if INCLUDE_JVMTI
 987 
 988   void init_previous_versions() {
 989     _previous_versions = NULL;
 990   }
 991 
 992  private:
 993   static bool  _has_previous_versions;
 994  public:
 995   static void purge_previous_versions(InstanceKlass* ik) {
 996     if (ik-&gt;has_been_redefined()) {
 997       ik-&gt;purge_previous_version_list();
 998     }
 999   }
1000 
1001   static bool has_previous_versions_and_reset();
1002   static bool has_previous_versions() { return _has_previous_versions; }
1003 
1004   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1038       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
1039     }
1040   }
1041 
1042   bool declares_nonstatic_concrete_methods() const {
1043     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
1044   }
1045   void set_declares_nonstatic_concrete_methods(bool b) {
1046     if (b) {
1047       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
1048     } else {
1049       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
1050     }
1051   }
1052 
1053   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
1054   inline u2 next_method_idnum();
1055   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
1056 
1057   // generics support
<span class="line-modified">1058   Symbol* generic_signature() const                   {</span>
<span class="line-modified">1059     return (_generic_signature_index == 0) ?</span>
<span class="line-modified">1060       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);</span>
<span class="line-removed">1061   }</span>
<span class="line-removed">1062   u2 generic_signature_index() const                  {</span>
<span class="line-removed">1063     return _generic_signature_index;</span>
<span class="line-removed">1064   }</span>
<span class="line-removed">1065   void set_generic_signature_index(u2 sig_index)      {</span>
<span class="line-removed">1066     _generic_signature_index = sig_index;</span>
<span class="line-removed">1067   }</span>
1068 
1069   u2 enclosing_method_data(int offset) const;
1070   u2 enclosing_method_class_index() const {
1071     return enclosing_method_data(enclosing_method_class_index_offset);
1072   }
1073   u2 enclosing_method_method_index() {
1074     return enclosing_method_data(enclosing_method_method_index_offset);
1075   }
1076   void set_enclosing_method_indices(u2 class_index,
1077                                     u2 method_index);
1078 
1079   // jmethodID support
1080   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
1081   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
1082                      jmethodID new_id, jmethodID* new_jmeths,
1083                      jmethodID* to_dealloc_id_p,
1084                      jmethodID** to_dealloc_jmeths_p);
1085   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
1086                 size_t *length_p, jmethodID* id_p);
1087   void ensure_space_for_methodids(int start_offset = 0);
</pre>
<hr />
<pre>
1370  public:
1371   // Explicit metaspace deallocation of fields
1372   // For RedefineClasses and class file parsing errors, we need to deallocate
1373   // instanceKlasses and the metadata they point to.
1374   void deallocate_contents(ClassLoaderData* loader_data);
1375   static void deallocate_methods(ClassLoaderData* loader_data,
1376                                  Array&lt;Method*&gt;* methods);
1377   void static deallocate_interfaces(ClassLoaderData* loader_data,
1378                                     const Klass* super_klass,
1379                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1380                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1381   void static deallocate_record_components(ClassLoaderData* loader_data,
1382                                            Array&lt;RecordComponent*&gt;* record_component);
1383 
1384   // The constant pool is on stack if any of the methods are executing or
1385   // referenced by handles.
1386   bool on_stack() const { return _constants-&gt;on_stack(); }
1387 
1388   // callbacks for actions during class unloading
1389   static void unload_class(InstanceKlass* ik);
<span class="line-modified">1390   static void release_C_heap_structures(InstanceKlass* ik);</span>

1391 
1392   // Naming
1393   const char* signature_name() const;
1394 
1395   // Oop fields (and metadata) iterators
1396   //
1397   // The InstanceKlass iterators also visits the Object&#39;s klass.
1398 
1399   // Forward iteration
1400  public:
1401   // Iterate over all oop fields in the oop maps.
1402   template &lt;typename T, class OopClosureType&gt;
1403   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1404 
1405   // Iterate over all oop fields and metadata.
1406   template &lt;typename T, class OopClosureType&gt;
1407   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1408 
1409   // Iterate over all oop fields in one oop map.
1410   template &lt;typename T, class OopClosureType&gt;
</pre>
<hr />
<pre>
1483   // Returns the array class with this class as element type
1484   virtual Klass* array_klass_impl(bool or_null, TRAPS);
1485 
1486 private:
1487 
1488   // find a local method (returns NULL if not found)
1489   Method* find_method_impl(const Symbol* name,
1490                            const Symbol* signature,
1491                            OverpassLookupMode overpass_mode,
1492                            StaticLookupMode static_mode,
1493                            PrivateLookupMode private_mode) const;
1494 
1495   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1496                                   const Symbol* name,
1497                                   const Symbol* signature,
1498                                   OverpassLookupMode overpass_mode,
1499                                   StaticLookupMode static_mode,
1500                                   PrivateLookupMode private_mode);
1501 
1502   // Free CHeap allocated fields.
<span class="line-modified">1503   void release_C_heap_structures();</span>
1504 
1505 #if INCLUDE_JVMTI
1506   // RedefineClasses support
1507   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1508   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1509 #endif
1510 public:
1511   // CDS support - remove and restore oops from metadata. Oops are not shared.
1512   virtual void remove_unshareable_info();
1513   virtual void remove_java_mirror();
1514   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);
1515 
1516   // jvm support
1517   jint compute_modifier_flags(TRAPS) const;
1518 
1519 public:
1520   // JVMTI support
1521   jint jvmti_class_status() const;
1522 
1523   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
</pre>
</td>
<td>
<hr />
<pre>
 201   // Constant pool for this class.
 202   ConstantPool* _constants;
 203   // The InnerClasses attribute and EnclosingMethod attribute. The
 204   // _inner_classes is an array of shorts. If the class has InnerClasses
 205   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 206   // [inner_class_info_index, outer_class_info_index,
 207   // inner_name_index, inner_class_access_flags] for the InnerClasses
 208   // attribute. If the EnclosingMethod attribute exists, it occupies the
 209   // last two shorts [class_index, method_index] of the array. If only
 210   // the InnerClasses attribute exists, the _inner_classes array length is
 211   // number_of_inner_classes * 4. If the class has both InnerClasses
 212   // and EnclosingMethod attributes the _inner_classes array length is
 213   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 214   Array&lt;jushort&gt;* _inner_classes;
 215 
 216   // The NestMembers attribute. An array of shorts, where each is a
 217   // class info index for the class that is a nest member. This data
 218   // has not been validated.
 219   Array&lt;jushort&gt;* _nest_members;
 220 




 221   // Resolved nest-host klass: either true nest-host or self if we are not
 222   // nested, or an error occurred resolving or validating the nominated
 223   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 224   // relationships.
 225   // By always being set it makes nest-member access checks simpler.
 226   InstanceKlass* _nest_host;
 227 
 228   Array&lt;InlineTypes&gt;* _inline_types;
 229 
 230   // The contents of the Record attribute.
 231   Array&lt;RecordComponent*&gt;* _record_components;
 232 
 233   // the source debug extension for this klass, NULL if not specified.
 234   // Specified as UTF-8 string without terminating zero byte in the classfile,
 235   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 236   const char*     _source_debug_extension;



 237 
 238   // Number of heapOopSize words used by non-static fields in this klass
 239   // (including inherited fields but after header_size()).
 240   int             _nonstatic_field_size;
 241   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
<span class="line-modified"> 242 </span>
<span class="line-modified"> 243   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks</span>
<span class="line-modified"> 244   int             _itable_len;           // length of Java itable (in words)</span>
<span class="line-modified"> 245 </span>
<span class="line-modified"> 246   // The NestHost attribute. The class info index for the class</span>
<span class="line-modified"> 247   // that is the nest-host of this class. This data has not been validated.</span>
<span class="line-added"> 248   u2              _nest_host_index;</span>
<span class="line-added"> 249   u2              _this_class_index;              // constant pool entry</span>
<span class="line-added"> 250 </span>
 251   u2              _static_oop_field_count;// number of static oop fields in this klass
 252   u2              _java_fields_count;    // The number of declared Java fields
<span class="line-modified"> 253 </span>
<span class="line-modified"> 254   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change</span>
 255 
 256   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 257   // _misc_flags.
 258   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 259 
<span class="line-modified"> 260   // Class states are defined as ClassState (see above).</span>
<span class="line-modified"> 261   // Place the _init_state here to utilize the unused 2-byte after</span>
<span class="line-modified"> 262   // _idnum_allocated_count.</span>
<span class="line-added"> 263   u1              _init_state;                    // state of class</span>
 264 
<span class="line-modified"> 265   // This can be used to quickly discriminate among the five kinds of</span>
<span class="line-modified"> 266   // InstanceKlass. This should be an enum (?)</span>
<span class="line-modified"> 267   static const unsigned _kind_other        = 0; // concrete InstanceKlass</span>
<span class="line-added"> 268   static const unsigned _kind_reference    = 1; // InstanceRefKlass</span>
<span class="line-added"> 269   static const unsigned _kind_class_loader = 2; // InstanceClassLoaderKlass</span>
<span class="line-added"> 270   static const unsigned _kind_mirror       = 3; // InstanceMirrorKlass</span>
<span class="line-added"> 271   static const unsigned _kind_inline_type  = 4; // InlineKlass</span>
 272 
<span class="line-modified"> 273   u1              _reference_type;                // reference type</span>
<span class="line-modified"> 274   u1              _kind;                          // kind of InstanceKlass</span>



 275 
<span class="line-modified"> 276   enum {</span>
<span class="line-modified"> 277     _misc_rewritten                           = 1 &lt;&lt; 0,  // methods rewritten.</span>
<span class="line-modified"> 278     _misc_has_nonstatic_fields                = 1 &lt;&lt; 1,  // for sizing with UseCompressedOops</span>
<span class="line-modified"> 279     _misc_should_verify_class                 = 1 &lt;&lt; 2,  // allow caching of preverification</span>
<span class="line-modified"> 280     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 3,  // has embedded _unsafe_anonymous_host field</span>
<span class="line-modified"> 281     _misc_is_contended                        = 1 &lt;&lt; 4,  // marked with contended annotation</span>
<span class="line-modified"> 282     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 5,  // class/superclass/implemented interfaces has non-static, concrete methods</span>
<span class="line-modified"> 283     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 6,  // directly declares non-static, concrete methods</span>
<span class="line-modified"> 284     _misc_has_been_redefined                  = 1 &lt;&lt; 7,  // class has been redefined</span>

 285     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 8,  // when this class was loaded, the fingerprint computed from its
 286                                                          // code source was found to be matching the value recorded by AOT.
<span class="line-modified"> 287     _misc_is_scratch_class                    = 1 &lt;&lt; 9,  // class is the redefined scratch class</span>
<span class="line-modified"> 288     _misc_is_shared_boot_class                = 1 &lt;&lt; 10, // defining class loader is boot class loader</span>
<span class="line-modified"> 289     _misc_is_shared_platform_class            = 1 &lt;&lt; 11, // defining class loader is platform class loader</span>
<span class="line-modified"> 290     _misc_is_shared_app_class                 = 1 &lt;&lt; 12, // defining class loader is app class loader</span>
<span class="line-modified"> 291     _misc_has_resolved_methods                = 1 &lt;&lt; 13, // resolved methods table entries added for this class</span>
<span class="line-modified"> 292     _misc_is_being_redefined                  = 1 &lt;&lt; 14, // used for locking redefinition</span>
<span class="line-modified"> 293     _misc_has_contended_annotations           = 1 &lt;&lt; 15,  // has @Contended annotation</span>
<span class="line-modified"> 294     _misc_has_inline_fields                   = 1 &lt;&lt; 16, // has inline fields and related embedded section is not empty</span>
<span class="line-modified"> 295     _misc_is_empty_inline_type                = 1 &lt;&lt; 17, // empty inline type</span>
<span class="line-modified"> 296     _misc_is_naturally_atomic                 = 1 &lt;&lt; 18, // loaded/stored in one instruction</span>
<span class="line-modified"> 297     _misc_is_declared_atomic                  = 1 &lt;&lt; 19, // implements jl.NonTearable</span>
<span class="line-modified"> 298     _misc_invalid_inline_super                = 1 &lt;&lt; 20, // invalid super type for an inline type</span>
<span class="line-modified"> 299     _misc_invalid_identity_super              = 1 &lt;&lt; 21, // invalid super type for an identity type</span>
<span class="line-modified"> 300     _misc_has_injected_identityObject         = 1 &lt;&lt; 22  // IdentityObject has been injected by the JVM</span>
 301   };
 302   u2 shared_loader_type_bits() const {
 303     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 304   }
<span class="line-modified"> 305   u4              _misc_flags;           // There is more space in access_flags for more flags.</span>
<span class="line-modified"> 306 </span>

 307   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 308   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 309   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 310   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 311   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 312   uint64_t        volatile _dep_context_last_cleaned;
 313   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 314 #if INCLUDE_JVMTI
 315   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 316   // Linked instanceKlasses of previous versions
 317   InstanceKlass* _previous_versions;
 318   // JVMTI fields can be moved to their own structure - see 6315920
 319   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 320   JvmtiCachedClassFileData* _cached_class_file;
 321 #endif
 322 









 323 #if INCLUDE_JVMTI
 324   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 325 #endif
 326 
 327   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 328 
 329   // Method array.
 330   Array&lt;Method*&gt;* _methods;
 331   // Default Method Array, concrete methods inherited from interfaces
 332   Array&lt;Method*&gt;* _default_methods;
 333   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 334   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 335   // Interfaces (InstanceKlass*s) this class implements transitively.
 336   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 337   // Int array containing the original order of method in the class file (for JVMTI).
 338   Array&lt;int&gt;*     _method_ordering;
 339   // Int array containing the vtable_indices for default_methods
 340   // offset matches _default_methods offset
 341   Array&lt;int&gt;*     _default_vtable_indices;
 342 
</pre>
<hr />
<pre>
 647   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 648   ClassState  init_state()                 { return (ClassState)_init_state; }
 649   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 650 
 651   // defineClass specified verification
 652   bool should_verify_class() const         {
 653     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 654   }
 655   void set_should_verify_class(bool value) {
 656     if (value) {
 657       _misc_flags |= _misc_should_verify_class;
 658     } else {
 659       _misc_flags &amp;= ~_misc_should_verify_class;
 660     }
 661   }
 662 
 663   // marking
 664   bool is_marked_dependent() const         { return _is_marked_dependent; }
 665   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 666 
<span class="line-added"> 667   static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }</span>
 668   static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }
 669   static u4 misc_flags_is_empty_inline_type() { return _misc_is_empty_inline_type; }
 670 
 671   // initialization (virtuals from Klass)
 672   bool should_be_initialized() const;  // means that initialize should be called
 673   void initialize(TRAPS);
 674   void link_class(TRAPS);
 675   bool link_class_or_fail(TRAPS); // returns false on failure
 676   void rewrite_class(TRAPS);
 677   void link_methods(TRAPS);
 678   Method* class_initializer() const;
 679 
 680   // set the class to initialized if no static initializer is present
 681   void eager_initialize(Thread *thread);
 682 
 683   // reference type
 684   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 685   void set_reference_type(ReferenceType t) {
 686     assert(t == (u1)t, &quot;overflow&quot;);
 687     _reference_type = (u1)t;
</pre>
<hr />
<pre>
 811   void set_is_unsafe_anonymous(bool value)        {
 812     if (value) {
 813       _misc_flags |= _misc_is_unsafe_anonymous;
 814     } else {
 815       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 816     }
 817   }
 818 
 819   bool is_contended() const                {
 820     return (_misc_flags &amp; _misc_is_contended) != 0;
 821   }
 822   void set_is_contended(bool value)        {
 823     if (value) {
 824       _misc_flags |= _misc_is_contended;
 825     } else {
 826       _misc_flags &amp;= ~_misc_is_contended;
 827     }
 828   }
 829 
 830   // source file name
<span class="line-modified"> 831   Symbol* source_file_name() const               { return _constants-&gt;source_file_name(); }</span>
<span class="line-modified"> 832   u2 source_file_name_index() const              { return _constants-&gt;source_file_name_index(); }</span>
<span class="line-modified"> 833   void set_source_file_name_index(u2 sourcefile_index) { _constants-&gt;set_source_file_name_index(sourcefile_index); }</span>







 834 
 835   // minor and major version numbers of class file
<span class="line-modified"> 836   u2 minor_version() const                 { return _constants-&gt;minor_version(); }</span>
<span class="line-modified"> 837   void set_minor_version(u2 minor_version) { _constants-&gt;set_minor_version(minor_version); }</span>
<span class="line-modified"> 838   u2 major_version() const                 { return _constants-&gt;major_version(); }</span>
<span class="line-modified"> 839   void set_major_version(u2 major_version) { _constants-&gt;set_major_version(major_version); }</span>
 840 
 841   // source debug extension
 842   const char* source_debug_extension() const { return _source_debug_extension; }
 843   void set_source_debug_extension(const char* array, int length);
 844 




 845   // nonstatic oop-map blocks
 846   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 847     return oop_map_count * OopMapBlock::size_in_words();
 848   }
 849   unsigned int nonstatic_oop_map_count() const {
 850     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 851   }
 852   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 853   void set_nonstatic_oop_map_size(int words) {
 854     _nonstatic_oop_map_size = words;
 855   }
 856 
 857   bool has_contended_annotations() const {
 858     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 859   }
 860   void set_has_contended_annotations(bool value)  {
 861     if (value) {
 862       _misc_flags |= _misc_has_contended_annotations;
 863     } else {
 864       _misc_flags &amp;= ~_misc_has_contended_annotations;
</pre>
<hr />
<pre>
 923   void store_fingerprint(uint64_t fingerprint);
 924 
 925   bool is_scratch_class() const {
 926     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 927   }
 928 
 929   void set_is_scratch_class() {
 930     _misc_flags |= _misc_is_scratch_class;
 931   }
 932 
 933   bool has_resolved_methods() const {
 934     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 935   }
 936 
 937   void set_has_resolved_methods() {
 938     _misc_flags |= _misc_has_resolved_methods;
 939   }
 940 private:
 941 
 942   void set_kind(unsigned kind) {
<span class="line-modified"> 943     _kind = (u1)kind;</span>



 944   }
 945 
 946   bool is_kind(unsigned desired) const {
<span class="line-modified"> 947     return _kind == (u1)desired;</span>

 948   }
 949 
 950 public:
 951 
 952   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
<span class="line-modified"> 953   bool is_other_instance_klass() const        { return is_kind(_kind_other); }</span>
<span class="line-modified"> 954   bool is_reference_instance_klass() const    { return is_kind(_kind_reference); }</span>
<span class="line-modified"> 955   bool is_mirror_instance_klass() const       { return is_kind(_kind_mirror); }</span>
<span class="line-modified"> 956   bool is_class_loader_instance_klass() const { return is_kind(_kind_class_loader); }</span>
<span class="line-modified"> 957   bool is_inline_type_klass()           const { return is_kind(_kind_inline_type); }</span>
 958 
 959 #if INCLUDE_JVMTI
 960 
 961   void init_previous_versions() {
 962     _previous_versions = NULL;
 963   }
 964 
 965  private:
 966   static bool  _has_previous_versions;
 967  public:
 968   static void purge_previous_versions(InstanceKlass* ik) {
 969     if (ik-&gt;has_been_redefined()) {
 970       ik-&gt;purge_previous_version_list();
 971     }
 972   }
 973 
 974   static bool has_previous_versions_and_reset();
 975   static bool has_previous_versions() { return _has_previous_versions; }
 976 
 977   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
</pre>
<hr />
<pre>
1011       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
1012     }
1013   }
1014 
1015   bool declares_nonstatic_concrete_methods() const {
1016     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
1017   }
1018   void set_declares_nonstatic_concrete_methods(bool b) {
1019     if (b) {
1020       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
1021     } else {
1022       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
1023     }
1024   }
1025 
1026   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
1027   inline u2 next_method_idnum();
1028   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
1029 
1030   // generics support
<span class="line-modified">1031   Symbol* generic_signature() const                   { return _constants-&gt;generic_signature(); }</span>
<span class="line-modified">1032   u2 generic_signature_index() const                  { return _constants-&gt;generic_signature_index(); }</span>
<span class="line-modified">1033   void set_generic_signature_index(u2 sig_index)      { _constants-&gt;set_generic_signature_index(sig_index); }</span>







1034 
1035   u2 enclosing_method_data(int offset) const;
1036   u2 enclosing_method_class_index() const {
1037     return enclosing_method_data(enclosing_method_class_index_offset);
1038   }
1039   u2 enclosing_method_method_index() {
1040     return enclosing_method_data(enclosing_method_method_index_offset);
1041   }
1042   void set_enclosing_method_indices(u2 class_index,
1043                                     u2 method_index);
1044 
1045   // jmethodID support
1046   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
1047   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
1048                      jmethodID new_id, jmethodID* new_jmeths,
1049                      jmethodID* to_dealloc_id_p,
1050                      jmethodID** to_dealloc_jmeths_p);
1051   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
1052                 size_t *length_p, jmethodID* id_p);
1053   void ensure_space_for_methodids(int start_offset = 0);
</pre>
<hr />
<pre>
1336  public:
1337   // Explicit metaspace deallocation of fields
1338   // For RedefineClasses and class file parsing errors, we need to deallocate
1339   // instanceKlasses and the metadata they point to.
1340   void deallocate_contents(ClassLoaderData* loader_data);
1341   static void deallocate_methods(ClassLoaderData* loader_data,
1342                                  Array&lt;Method*&gt;* methods);
1343   void static deallocate_interfaces(ClassLoaderData* loader_data,
1344                                     const Klass* super_klass,
1345                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1346                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1347   void static deallocate_record_components(ClassLoaderData* loader_data,
1348                                            Array&lt;RecordComponent*&gt;* record_component);
1349 
1350   // The constant pool is on stack if any of the methods are executing or
1351   // referenced by handles.
1352   bool on_stack() const { return _constants-&gt;on_stack(); }
1353 
1354   // callbacks for actions during class unloading
1355   static void unload_class(InstanceKlass* ik);
<span class="line-modified">1356 </span>
<span class="line-added">1357   virtual void release_C_heap_structures();</span>
1358 
1359   // Naming
1360   const char* signature_name() const;
1361 
1362   // Oop fields (and metadata) iterators
1363   //
1364   // The InstanceKlass iterators also visits the Object&#39;s klass.
1365 
1366   // Forward iteration
1367  public:
1368   // Iterate over all oop fields in the oop maps.
1369   template &lt;typename T, class OopClosureType&gt;
1370   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1371 
1372   // Iterate over all oop fields and metadata.
1373   template &lt;typename T, class OopClosureType&gt;
1374   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1375 
1376   // Iterate over all oop fields in one oop map.
1377   template &lt;typename T, class OopClosureType&gt;
</pre>
<hr />
<pre>
1450   // Returns the array class with this class as element type
1451   virtual Klass* array_klass_impl(bool or_null, TRAPS);
1452 
1453 private:
1454 
1455   // find a local method (returns NULL if not found)
1456   Method* find_method_impl(const Symbol* name,
1457                            const Symbol* signature,
1458                            OverpassLookupMode overpass_mode,
1459                            StaticLookupMode static_mode,
1460                            PrivateLookupMode private_mode) const;
1461 
1462   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1463                                   const Symbol* name,
1464                                   const Symbol* signature,
1465                                   OverpassLookupMode overpass_mode,
1466                                   StaticLookupMode static_mode,
1467                                   PrivateLookupMode private_mode);
1468 
1469   // Free CHeap allocated fields.
<span class="line-modified">1470   void release_C_heap_structures_internal();</span>
1471 
1472 #if INCLUDE_JVMTI
1473   // RedefineClasses support
1474   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1475   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1476 #endif
1477 public:
1478   // CDS support - remove and restore oops from metadata. Oops are not shared.
1479   virtual void remove_unshareable_info();
1480   virtual void remove_java_mirror();
1481   virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);
1482 
1483   // jvm support
1484   jint compute_modifier_flags(TRAPS) const;
1485 
1486 public:
1487   // JVMTI support
1488   jint jvmti_class_status() const;
1489 
1490   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
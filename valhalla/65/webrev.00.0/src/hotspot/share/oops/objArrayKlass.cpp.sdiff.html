<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
102   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
103   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
104 
105   ModuleEntry* module = oak-&gt;module();
106   assert(module != NULL, &quot;No module entry for array&quot;);
107 
108   // Call complete_create_array_klass after all instance variables has been initialized.
109   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
110 
111   // Add all classes to our internal class loader list here,
112   // including classes in the bootstrap (NULL) class loader.
113   // Do this step after creating the mirror so that if the
114   // mirror creation fails, loaded_classes_do() doesn&#39;t find
115   // an array class without a mirror.
116   loader_data-&gt;add_class(oak);
117 
118   return oak;
119 }
120 
121 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
<span class="line-modified">122   this-&gt;set_dimension(n);</span>
<span class="line-modified">123   this-&gt;set_element_klass(element_klass);</span>
<span class="line-removed">124   // decrement refcount because object arrays are not explicitly freed.  The</span>
<span class="line-removed">125   // InstanceKlass array_name() keeps the name counted while the klass is</span>
<span class="line-removed">126   // loaded.</span>
<span class="line-removed">127   name-&gt;decrement_refcount();</span>
128 
129   Klass* bk;
130   if (element_klass-&gt;is_objArray_klass()) {
131     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
132   } else if (element_klass-&gt;is_valueArray_klass()) {
133     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
134   } else {
135     bk = element_klass;
136   }
<span class="line-modified">137   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass()</span>
<span class="line-modified">138       || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);</span>
<span class="line-modified">139   this-&gt;set_bottom_klass(bk);</span>
<span class="line-removed">140   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());</span>
141 
142   jint lh = array_layout_helper(T_OBJECT);
143   if (element_klass-&gt;is_value()) {
144     lh = layout_helper_set_null_free(lh);
145   }
<span class="line-modified">146   this-&gt;set_layout_helper(lh);</span>
<span class="line-modified">147   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);</span>
<span class="line-modified">148   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);</span>
149 }
150 
151 int ObjArrayKlass::oop_size(oop obj) const {
152   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
153   return objArrayOop(obj)-&gt;object_size();
154 }
155 
156 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
157   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
158   int size = objArrayOopDesc::object_size(length);
159   bool populate_null_free = is_null_free_array_klass();
160   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
161                                                        /* do_zero */ true, THREAD);
162   if (populate_null_free) {
163     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
164     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
165     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
166     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
167     element_klass()-&gt;initialize(CHECK_NULL);
168     // Populate default values...
</pre>
</td>
<td>
<hr />
<pre>
102   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
103   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);
104 
105   ModuleEntry* module = oak-&gt;module();
106   assert(module != NULL, &quot;No module entry for array&quot;);
107 
108   // Call complete_create_array_klass after all instance variables has been initialized.
109   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);
110 
111   // Add all classes to our internal class loader list here,
112   // including classes in the bootstrap (NULL) class loader.
113   // Do this step after creating the mirror so that if the
114   // mirror creation fails, loaded_classes_do() doesn&#39;t find
115   // an array class without a mirror.
116   loader_data-&gt;add_class(oak);
117 
118   return oak;
119 }
120 
121 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
<span class="line-modified">122   set_dimension(n);</span>
<span class="line-modified">123   set_element_klass(element_klass);</span>




124 
125   Klass* bk;
126   if (element_klass-&gt;is_objArray_klass()) {
127     bk = ObjArrayKlass::cast(element_klass)-&gt;bottom_klass();
128   } else if (element_klass-&gt;is_valueArray_klass()) {
129     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
130   } else {
131     bk = element_klass;
132   }
<span class="line-modified">133   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass() || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);</span>
<span class="line-modified">134   set_bottom_klass(bk);</span>
<span class="line-modified">135   set_class_loader_data(bk-&gt;class_loader_data());</span>

136 
137   jint lh = array_layout_helper(T_OBJECT);
138   if (element_klass-&gt;is_value()) {
139     lh = layout_helper_set_null_free(lh);
140   }
<span class="line-modified">141   set_layout_helper(lh);</span>
<span class="line-modified">142   assert(is_array_klass(), &quot;sanity&quot;);</span>
<span class="line-modified">143   assert(is_objArray_klass(), &quot;sanity&quot;);</span>
144 }
145 
146 int ObjArrayKlass::oop_size(oop obj) const {
147   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
148   return objArrayOop(obj)-&gt;object_size();
149 }
150 
151 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
152   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
153   int size = objArrayOopDesc::object_size(length);
154   bool populate_null_free = is_null_free_array_klass();
155   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
156                                                        /* do_zero */ true, THREAD);
157   if (populate_null_free) {
158     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
159     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
160     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
161     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
162     element_klass()-&gt;initialize(CHECK_NULL);
163     // Populate default values...
</pre>
</td>
</tr>
</table>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
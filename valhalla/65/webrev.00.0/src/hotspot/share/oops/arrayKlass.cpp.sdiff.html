<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/arrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../jvmci/vmStructs_jvmci.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/arrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83   // any overpass methods present.
 84   return super()-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass, private_mode);
 85 }
 86 
 87 ArrayKlass::ArrayKlass(Symbol* name, KlassID id) :
 88   Klass(id),
 89   _dimension(1),
 90   _higher_dimension(NULL),
 91   _lower_dimension(NULL) {
 92     // Arrays don&#39;t add any new methods, so their vtable is the same size as
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
102 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {

103   Symbol* name = NULL;
104   bool is_qtype = element_klass-&gt;is_value();
<span class="line-modified">105   if (!element_klass-&gt;is_instance_klass() || is_qtype ||</span>
<span class="line-modified">106       (name = InstanceKlass::cast(element_klass)-&gt;array_name()) == NULL) {</span>
<span class="line-modified">107 </span>
<span class="line-modified">108     ResourceMark rm(THREAD);</span>
<span class="line-modified">109     char *name_str = element_klass-&gt;name()-&gt;as_C_string();</span>
<span class="line-modified">110     int len = element_klass-&gt;name()-&gt;utf8_length();</span>
<span class="line-modified">111     char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);</span>
<span class="line-modified">112     int idx = 0;</span>
<span class="line-modified">113     new_str[idx++] = JVM_SIGNATURE_ARRAY;</span>
<span class="line-modified">114     if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type</span>
<span class="line-removed">115       if (is_qtype) {</span>
<span class="line-removed">116         new_str[idx++] = JVM_SIGNATURE_VALUETYPE;</span>
<span class="line-removed">117       } else {</span>
<span class="line-removed">118         new_str[idx++] = JVM_SIGNATURE_CLASS;</span>
<span class="line-removed">119       }</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121     memcpy(&amp;new_str[idx], name_str, len * sizeof(char));</span>
<span class="line-removed">122     idx += len;</span>
<span class="line-removed">123     if (element_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed">124       new_str[idx++] = JVM_SIGNATURE_ENDCLASS;</span>
<span class="line-removed">125     }</span>
<span class="line-removed">126     new_str[idx++] = &#39;\0&#39;;</span>
<span class="line-removed">127     name = SymbolTable::new_symbol(new_str);</span>
<span class="line-removed">128     if (element_klass-&gt;is_instance_klass()) {</span>
<span class="line-removed">129       InstanceKlass* ik = InstanceKlass::cast(element_klass);</span>
<span class="line-removed">130       ik-&gt;set_array_name(name);</span>
131     }
132   }
<span class="line-modified">133 </span>
<span class="line-modified">134   return name;</span>





135 }
136 
137 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
138 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
139 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
140   k-&gt;initialize_supers(super_klass, NULL, CHECK);
141   k-&gt;vtable().initialize_vtable(false, CHECK);
142 
143   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
144   // These classes will be put on a fixup list and their module fields will be patched once
145   // java.base is defined.
146   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
147          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
148   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
149   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);
150 }
151 
152 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
153                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
154   // interfaces = { cloneable_klass, serializable_klass };
</pre>
</td>
<td>
<hr />
<pre>
 83   // any overpass methods present.
 84   return super()-&gt;uncached_lookup_method(name, signature, Klass::skip_overpass, private_mode);
 85 }
 86 
 87 ArrayKlass::ArrayKlass(Symbol* name, KlassID id) :
 88   Klass(id),
 89   _dimension(1),
 90   _higher_dimension(NULL),
 91   _lower_dimension(NULL) {
 92     // Arrays don&#39;t add any new methods, so their vtable is the same size as
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
102 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {
<span class="line-added">103   ResourceMark rm(THREAD);</span>
104   Symbol* name = NULL;
105   bool is_qtype = element_klass-&gt;is_value();
<span class="line-modified">106   char *name_str = element_klass-&gt;name()-&gt;as_C_string();</span>
<span class="line-modified">107   int len = element_klass-&gt;name()-&gt;utf8_length();</span>
<span class="line-modified">108   char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);</span>
<span class="line-modified">109   int idx = 0;</span>
<span class="line-modified">110   new_str[idx++] = JVM_SIGNATURE_ARRAY;</span>
<span class="line-modified">111   if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type</span>
<span class="line-modified">112     if (is_qtype) {</span>
<span class="line-modified">113       new_str[idx++] = JVM_SIGNATURE_VALUETYPE;</span>
<span class="line-modified">114     } else {</span>
<span class="line-modified">115       new_str[idx++] = JVM_SIGNATURE_CLASS;</span>
















116     }
117   }
<span class="line-modified">118   memcpy(&amp;new_str[idx], name_str, len * sizeof(char));</span>
<span class="line-modified">119   idx += len;</span>
<span class="line-added">120   if (element_klass-&gt;is_instance_klass()) {</span>
<span class="line-added">121     new_str[idx++] = JVM_SIGNATURE_ENDCLASS;</span>
<span class="line-added">122   }</span>
<span class="line-added">123   new_str[idx++] = &#39;\0&#39;;</span>
<span class="line-added">124   return SymbolTable::new_symbol(new_str);</span>
125 }
126 
127 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
128 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
129 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
130   k-&gt;initialize_supers(super_klass, NULL, CHECK);
131   k-&gt;vtable().initialize_vtable(false, CHECK);
132 
133   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
134   // These classes will be put on a fixup list and their module fields will be patched once
135   // java.base is defined.
136   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
137          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
138   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
139   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);
140 }
141 
142 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
143                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
144   // interfaces = { cloneable_klass, serializable_klass };
</pre>
</td>
</tr>
</table>
<center><a href="../jvmci/vmStructs_jvmci.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 430   const Symbol* const class_name = parser.class_name();
 431   assert(class_name != NULL, &quot;invariant&quot;);
 432   ClassLoaderData* loader_data = parser.loader_data();
 433   assert(loader_data != NULL, &quot;invariant&quot;);
 434 
 435   InstanceKlass* ik;
 436 
 437   // Allocation
 438   if (REF_NONE == parser.reference_type()) {
 439     if (class_name == vmSymbols::java_lang_Class()) {
 440       // mirror
 441       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 442     } else if (is_class_loader(class_name, parser)) {
 443       // class loader
 444       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
 445     } else if (parser.is_inline_type()) {
 446       // inline type
 447       ik = new (loader_data, size, THREAD) ValueKlass(parser);
 448     } else {
 449       // normal
<span class="line-modified"> 450       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);</span>
 451     }
 452   } else {
 453     // reference
 454     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 455   }
 456 
 457   // Check for pending exception before adding to the loader data and incrementing
 458   // class count.  Can get OOM here.
 459   if (HAS_PENDING_EXCEPTION) {
 460     return NULL;
 461   }
 462 
 463 #ifdef ASSERT
 464   assert(ik-&gt;size() == size, &quot;&quot;);
 465   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);
 466   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);
 467   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);
 468   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);
 469 #endif //ASSERT
 470   return ik;
</pre>
<hr />
<pre>
 501     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 502     for (int i = 0; i &lt; m-&gt;length(); i++) {
 503       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 504     }
 505   } else {
 506     _method_ordering = Universe::the_empty_int_array();
 507   }
 508 }
 509 
 510 // create a new array of vtable_indices for default methods
 511 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 512   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 513   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 514   set_default_vtable_indices(vtable_indices);
 515   return vtable_indices;
 516 }
 517 
 518 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 519   Klass(id),
 520   _nest_members(NULL),
<span class="line-removed"> 521   _nest_host_index(0),</span>
 522   _nest_host(NULL),
 523   _record_components(NULL),
 524   _static_field_size(parser.static_field_size()),
 525   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 526   _itable_len(parser.itable_size()),
<span class="line-modified"> 527   _init_thread(NULL),</span>
 528   _init_state(allocated),
 529   _reference_type(parser.reference_type()),

 530   _value_field_klasses(NULL),
 531   _adr_valueklass_fixed_block(NULL)
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
 540     if (parser.has_flattenable_fields()) {
 541       set_has_inline_fields();
 542     }
 543     _java_fields_count = parser.java_fields_count();
 544 
 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 548 
 549   if (Arguments::is_dumping_archive()) {
</pre>
<hr />
<pre>
 616 // InstanceKlass points to.
 617 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 618 
 619   // Orphan the mirror first, CMS thinks it&#39;s still live.
 620   if (java_mirror() != NULL) {
 621     java_lang_Class::set_klass(java_mirror(), NULL);
 622   }
 623 
 624   // Also remove mirror from handles
 625   loader_data-&gt;remove_handle(_java_mirror);
 626 
 627   // Need to take this class off the class loader data list.
 628   loader_data-&gt;remove_class(this);
 629 
 630   // The array_klass for this class is created later, after error handling.
 631   // For class redefinition, we keep the original class so this scratch class
 632   // doesn&#39;t have an array class.  Either way, assert that there is nothing
 633   // to deallocate.
 634   assert(array_klasses() == NULL, &quot;array classes shouldn&#39;t be created for this class yet&quot;);
 635 
<span class="line-modified"> 636   // Release C heap allocated data that this might point to, which includes</span>
 637   // reference counting symbol names.
<span class="line-modified"> 638   release_C_heap_structures();</span>
 639 
 640   deallocate_methods(loader_data, methods());
 641   set_methods(NULL);
 642 
 643   deallocate_record_components(loader_data, record_components());
 644   set_record_components(NULL);
 645 
 646   if (method_ordering() != NULL &amp;&amp;
 647       method_ordering() != Universe::the_empty_int_array() &amp;&amp;
 648       !method_ordering()-&gt;is_shared()) {
 649     MetadataFactory::free_array&lt;int&gt;(loader_data, method_ordering());
 650   }
 651   set_method_ordering(NULL);
 652 
 653   // default methods can be empty
 654   if (default_methods() != NULL &amp;&amp;
 655       default_methods() != Universe::the_empty_method_array() &amp;&amp;
 656       !default_methods()-&gt;is_shared()) {
 657     MetadataFactory::free_array&lt;Method*&gt;(loader_data, default_methods());
 658   }
</pre>
<hr />
<pre>
2505   if (adr != NULL) {
2506     Bytes::put_native_u8(adr, (u8)fingerprint); // adr may not be 64-bit aligned
2507 
2508     ResourceMark rm;
2509     log_trace(class, fingerprint)(&quot;stored as &quot; PTR64_FORMAT &quot; for class %s&quot;, fingerprint, external_name());
2510   }
2511 }
2512 
2513 void InstanceKlass::metaspace_pointers_do(MetaspaceClosure* it) {
2514   Klass::metaspace_pointers_do(it);
2515 
2516   if (log_is_enabled(Trace, cds)) {
2517     ResourceMark rm;
2518     log_trace(cds)(&quot;Iter(InstanceKlass): %p (%s)&quot;, this, external_name());
2519   }
2520 
2521   it-&gt;push(&amp;_annotations);
2522   it-&gt;push((Klass**)&amp;_array_klasses);
2523   it-&gt;push(&amp;_constants);
2524   it-&gt;push(&amp;_inner_classes);
<span class="line-removed">2525   it-&gt;push(&amp;_array_name);</span>
2526 #if INCLUDE_JVMTI
2527   it-&gt;push(&amp;_previous_versions);
2528 #endif
2529   it-&gt;push(&amp;_methods);
2530   it-&gt;push(&amp;_default_methods);
2531   it-&gt;push(&amp;_local_interfaces);
2532   it-&gt;push(&amp;_transitive_interfaces);
2533   it-&gt;push(&amp;_method_ordering);
2534   it-&gt;push(&amp;_default_vtable_indices);
2535   it-&gt;push(&amp;_fields);
2536 
2537   if (itable_length() &gt; 0) {
2538     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2539     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2540     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2541                          / itableOffsetEntry::size();
2542 
2543     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2544       if (ioe-&gt;interface_klass() != NULL) {
2545         it-&gt;push(ioe-&gt;interface_klass_addr());
</pre>
<hr />
<pre>
2704   if (log_is_enabled(Info, class, unload)) {
2705     ResourceMark rm;
2706     log_info(class, unload)(&quot;unloading class %s &quot; INTPTR_FORMAT, ik-&gt;external_name(), p2i(ik));
2707   }
2708 
2709   Events::log_class_unloading(Thread::current(), ik);
2710 
2711 #if INCLUDE_JFR
2712   assert(ik != NULL, &quot;invariant&quot;);
2713   EventClassUnload event;
2714   event.set_unloadedClass(ik);
2715   event.set_definingClassLoader(ik-&gt;class_loader_data());
2716   event.commit();
2717 #endif
2718 }
2719 
2720 static void method_release_C_heap_structures(Method* m) {
2721   m-&gt;release_C_heap_structures();
2722 }
2723 
<span class="line-modified">2724 void InstanceKlass::release_C_heap_structures(InstanceKlass* ik) {</span>

2725   // Clean up C heap
<span class="line-modified">2726   ik-&gt;release_C_heap_structures();</span>
<span class="line-modified">2727   ik-&gt;constants()-&gt;release_C_heap_structures();</span>
2728 
2729   // Deallocate and call destructors for MDO mutexes
<span class="line-modified">2730   ik-&gt;methods_do(method_release_C_heap_structures);</span>
<span class="line-removed">2731 </span>
2732 }
2733 
<span class="line-modified">2734 void InstanceKlass::release_C_heap_structures() {</span>


2735   // Can&#39;t release the constant pool here because the constant pool can be
2736   // deallocated separately from the InstanceKlass for default methods and
2737   // redefine classes.
2738 
2739   // Deallocate oop map cache
2740   if (_oop_map_cache != NULL) {
2741     delete _oop_map_cache;
2742     _oop_map_cache = NULL;
2743   }
2744 
2745   // Deallocate JNI identifiers for jfieldIDs
2746   JNIid::deallocate(jni_ids());
2747   set_jni_ids(NULL);
2748 
2749   jmethodID* jmeths = methods_jmethod_ids_acquire();
2750   if (jmeths != (jmethodID*)NULL) {
2751     release_set_methods_jmethod_ids(NULL);
2752     FreeHeap(jmeths);
2753   }
2754 
2755   assert(_dep_context == NULL,
2756          &quot;dependencies should already be cleaned&quot;);
2757 
2758 #if INCLUDE_JVMTI
2759   // Deallocate breakpoint records
2760   if (breakpoints() != 0x0) {
2761     methods_do(clear_all_breakpoints);
2762     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2763   }
2764 
2765   // deallocate the cached class file
2766   if (_cached_class_file != NULL) {
2767     os::free(_cached_class_file);
2768     _cached_class_file = NULL;
2769   }
2770 #endif
2771 
<span class="line-removed">2772   // Decrement symbol reference counts associated with the unloaded class.</span>
<span class="line-removed">2773   if (_name != NULL) _name-&gt;decrement_refcount();</span>
<span class="line-removed">2774 </span>
<span class="line-removed">2775   // unreference array name derived from this class name (arrays of an unloaded</span>
<span class="line-removed">2776   // class can&#39;t be referenced anymore).</span>
<span class="line-removed">2777   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();</span>
<span class="line-removed">2778   if (_inline_types != NULL) {</span>
<span class="line-removed">2779     for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {</span>
<span class="line-removed">2780       Symbol* s = _inline_types-&gt;at(i)._class_name;</span>
<span class="line-removed">2781       if (s != NULL) {</span>
<span class="line-removed">2782         s-&gt;decrement_refcount();</span>
<span class="line-removed">2783       }</span>
<span class="line-removed">2784     }</span>
<span class="line-removed">2785   }</span>
2786   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2787 }
2788 
2789 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2790   if (array == NULL) {
2791     _source_debug_extension = NULL;
2792   } else {
2793     // Adding one to the attribute length in order to store a null terminator
2794     // character could cause an overflow because the attribute length is
2795     // already coded with an u4 in the classfile, but in practice, it&#39;s
2796     // unlikely to happen.
2797     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2798     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2799     for (int i = 0; i &lt; length; i++) {
2800       sde[i] = array[i];
2801     }
2802     sde[length] = &#39;\0&#39;;
2803     _source_debug_extension = sde;
2804   }
2805 }
</pre>
</td>
<td>
<hr />
<pre>
 430   const Symbol* const class_name = parser.class_name();
 431   assert(class_name != NULL, &quot;invariant&quot;);
 432   ClassLoaderData* loader_data = parser.loader_data();
 433   assert(loader_data != NULL, &quot;invariant&quot;);
 434 
 435   InstanceKlass* ik;
 436 
 437   // Allocation
 438   if (REF_NONE == parser.reference_type()) {
 439     if (class_name == vmSymbols::java_lang_Class()) {
 440       // mirror
 441       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 442     } else if (is_class_loader(class_name, parser)) {
 443       // class loader
 444       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
 445     } else if (parser.is_inline_type()) {
 446       // inline type
 447       ik = new (loader_data, size, THREAD) ValueKlass(parser);
 448     } else {
 449       // normal
<span class="line-modified"> 450       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);</span>
 451     }
 452   } else {
 453     // reference
 454     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 455   }
 456 
 457   // Check for pending exception before adding to the loader data and incrementing
 458   // class count.  Can get OOM here.
 459   if (HAS_PENDING_EXCEPTION) {
 460     return NULL;
 461   }
 462 
 463 #ifdef ASSERT
 464   assert(ik-&gt;size() == size, &quot;&quot;);
 465   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);
 466   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);
 467   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);
 468   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);
 469 #endif //ASSERT
 470   return ik;
</pre>
<hr />
<pre>
 501     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 502     for (int i = 0; i &lt; m-&gt;length(); i++) {
 503       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 504     }
 505   } else {
 506     _method_ordering = Universe::the_empty_int_array();
 507   }
 508 }
 509 
 510 // create a new array of vtable_indices for default methods
 511 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 512   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 513   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 514   set_default_vtable_indices(vtable_indices);
 515   return vtable_indices;
 516 }
 517 
 518 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 519   Klass(id),
 520   _nest_members(NULL),

 521   _nest_host(NULL),
 522   _record_components(NULL),
 523   _static_field_size(parser.static_field_size()),
 524   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 525   _itable_len(parser.itable_size()),
<span class="line-modified"> 526   _nest_host_index(0),</span>
 527   _init_state(allocated),
 528   _reference_type(parser.reference_type()),
<span class="line-added"> 529   _init_thread(NULL),</span>
 530   _value_field_klasses(NULL),
 531   _adr_valueklass_fixed_block(NULL)
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
 540     if (parser.has_flattenable_fields()) {
 541       set_has_inline_fields();
 542     }
 543     _java_fields_count = parser.java_fields_count();
 544 
 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 548 
 549   if (Arguments::is_dumping_archive()) {
</pre>
<hr />
<pre>
 616 // InstanceKlass points to.
 617 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 618 
 619   // Orphan the mirror first, CMS thinks it&#39;s still live.
 620   if (java_mirror() != NULL) {
 621     java_lang_Class::set_klass(java_mirror(), NULL);
 622   }
 623 
 624   // Also remove mirror from handles
 625   loader_data-&gt;remove_handle(_java_mirror);
 626 
 627   // Need to take this class off the class loader data list.
 628   loader_data-&gt;remove_class(this);
 629 
 630   // The array_klass for this class is created later, after error handling.
 631   // For class redefinition, we keep the original class so this scratch class
 632   // doesn&#39;t have an array class.  Either way, assert that there is nothing
 633   // to deallocate.
 634   assert(array_klasses() == NULL, &quot;array classes shouldn&#39;t be created for this class yet&quot;);
 635 
<span class="line-modified"> 636   // Release C heap allocated data that this points to, which includes</span>
 637   // reference counting symbol names.
<span class="line-modified"> 638   release_C_heap_structures_internal();</span>
 639 
 640   deallocate_methods(loader_data, methods());
 641   set_methods(NULL);
 642 
 643   deallocate_record_components(loader_data, record_components());
 644   set_record_components(NULL);
 645 
 646   if (method_ordering() != NULL &amp;&amp;
 647       method_ordering() != Universe::the_empty_int_array() &amp;&amp;
 648       !method_ordering()-&gt;is_shared()) {
 649     MetadataFactory::free_array&lt;int&gt;(loader_data, method_ordering());
 650   }
 651   set_method_ordering(NULL);
 652 
 653   // default methods can be empty
 654   if (default_methods() != NULL &amp;&amp;
 655       default_methods() != Universe::the_empty_method_array() &amp;&amp;
 656       !default_methods()-&gt;is_shared()) {
 657     MetadataFactory::free_array&lt;Method*&gt;(loader_data, default_methods());
 658   }
</pre>
<hr />
<pre>
2505   if (adr != NULL) {
2506     Bytes::put_native_u8(adr, (u8)fingerprint); // adr may not be 64-bit aligned
2507 
2508     ResourceMark rm;
2509     log_trace(class, fingerprint)(&quot;stored as &quot; PTR64_FORMAT &quot; for class %s&quot;, fingerprint, external_name());
2510   }
2511 }
2512 
2513 void InstanceKlass::metaspace_pointers_do(MetaspaceClosure* it) {
2514   Klass::metaspace_pointers_do(it);
2515 
2516   if (log_is_enabled(Trace, cds)) {
2517     ResourceMark rm;
2518     log_trace(cds)(&quot;Iter(InstanceKlass): %p (%s)&quot;, this, external_name());
2519   }
2520 
2521   it-&gt;push(&amp;_annotations);
2522   it-&gt;push((Klass**)&amp;_array_klasses);
2523   it-&gt;push(&amp;_constants);
2524   it-&gt;push(&amp;_inner_classes);

2525 #if INCLUDE_JVMTI
2526   it-&gt;push(&amp;_previous_versions);
2527 #endif
2528   it-&gt;push(&amp;_methods);
2529   it-&gt;push(&amp;_default_methods);
2530   it-&gt;push(&amp;_local_interfaces);
2531   it-&gt;push(&amp;_transitive_interfaces);
2532   it-&gt;push(&amp;_method_ordering);
2533   it-&gt;push(&amp;_default_vtable_indices);
2534   it-&gt;push(&amp;_fields);
2535 
2536   if (itable_length() &gt; 0) {
2537     itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();
2538     int method_table_offset_in_words = ioe-&gt;offset()/wordSize;
2539     int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())
2540                          / itableOffsetEntry::size();
2541 
2542     for (int i = 0; i &lt; nof_interfaces; i ++, ioe ++) {
2543       if (ioe-&gt;interface_klass() != NULL) {
2544         it-&gt;push(ioe-&gt;interface_klass_addr());
</pre>
<hr />
<pre>
2703   if (log_is_enabled(Info, class, unload)) {
2704     ResourceMark rm;
2705     log_info(class, unload)(&quot;unloading class %s &quot; INTPTR_FORMAT, ik-&gt;external_name(), p2i(ik));
2706   }
2707 
2708   Events::log_class_unloading(Thread::current(), ik);
2709 
2710 #if INCLUDE_JFR
2711   assert(ik != NULL, &quot;invariant&quot;);
2712   EventClassUnload event;
2713   event.set_unloadedClass(ik);
2714   event.set_definingClassLoader(ik-&gt;class_loader_data());
2715   event.commit();
2716 #endif
2717 }
2718 
2719 static void method_release_C_heap_structures(Method* m) {
2720   m-&gt;release_C_heap_structures();
2721 }
2722 
<span class="line-modified">2723 void InstanceKlass::release_C_heap_structures() {</span>
<span class="line-added">2724 </span>
2725   // Clean up C heap
<span class="line-modified">2726   release_C_heap_structures_internal();</span>
<span class="line-modified">2727   constants()-&gt;release_C_heap_structures();</span>
2728 
2729   // Deallocate and call destructors for MDO mutexes
<span class="line-modified">2730   methods_do(method_release_C_heap_structures);</span>

2731 }
2732 
<span class="line-modified">2733 void InstanceKlass::release_C_heap_structures_internal() {</span>
<span class="line-added">2734   Klass::release_C_heap_structures();</span>
<span class="line-added">2735 </span>
2736   // Can&#39;t release the constant pool here because the constant pool can be
2737   // deallocated separately from the InstanceKlass for default methods and
2738   // redefine classes.
2739 
2740   // Deallocate oop map cache
2741   if (_oop_map_cache != NULL) {
2742     delete _oop_map_cache;
2743     _oop_map_cache = NULL;
2744   }
2745 
2746   // Deallocate JNI identifiers for jfieldIDs
2747   JNIid::deallocate(jni_ids());
2748   set_jni_ids(NULL);
2749 
2750   jmethodID* jmeths = methods_jmethod_ids_acquire();
2751   if (jmeths != (jmethodID*)NULL) {
2752     release_set_methods_jmethod_ids(NULL);
2753     FreeHeap(jmeths);
2754   }
2755 
2756   assert(_dep_context == NULL,
2757          &quot;dependencies should already be cleaned&quot;);
2758 
2759 #if INCLUDE_JVMTI
2760   // Deallocate breakpoint records
2761   if (breakpoints() != 0x0) {
2762     methods_do(clear_all_breakpoints);
2763     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2764   }
2765 
2766   // deallocate the cached class file
2767   if (_cached_class_file != NULL) {
2768     os::free(_cached_class_file);
2769     _cached_class_file = NULL;
2770   }
2771 #endif
2772 














2773   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2774 }
2775 
2776 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2777   if (array == NULL) {
2778     _source_debug_extension = NULL;
2779   } else {
2780     // Adding one to the attribute length in order to store a null terminator
2781     // character could cause an overflow because the attribute length is
2782     // already coded with an u4 in the classfile, but in practice, it&#39;s
2783     // unlikely to happen.
2784     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2785     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2786     for (int i = 0; i &lt; length; i++) {
2787       sde[i] = array[i];
2788     }
2789     sde[length] = &#39;\0&#39;;
2790     _source_debug_extension = sde;
2791   }
2792 }
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
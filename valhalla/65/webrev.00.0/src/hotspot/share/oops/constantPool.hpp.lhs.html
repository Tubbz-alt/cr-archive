<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/constantPool.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_CONSTANTPOOL_HPP
  26 #define SHARE_OOPS_CONSTANTPOOL_HPP
  27 
  28 #include &quot;memory/allocation.hpp&quot;
  29 #include &quot;oops/arrayOop.hpp&quot;
  30 #include &quot;oops/cpCache.hpp&quot;
  31 #include &quot;oops/objArrayOop.hpp&quot;
  32 #include &quot;oops/oopHandle.hpp&quot;
  33 #include &quot;oops/symbol.hpp&quot;
  34 #include &quot;oops/typeArrayOop.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;utilities/align.hpp&quot;
  37 #include &quot;utilities/bytes.hpp&quot;
  38 #include &quot;utilities/constantTag.hpp&quot;
  39 
  40 // A ConstantPool is an array containing class constants as described in the
  41 // class file.
  42 //
  43 // Most of the constant pool entries are written during class parsing, which
  44 // is safe.  For klass types, the constant pool entry is
  45 // modified when the entry is resolved.  If a klass constant pool
  46 // entry is read without a lock, only the resolved state guarantees that
  47 // the entry in the constant pool is a klass object and not a Symbol*.
  48 
  49 class SymbolHashMap;
  50 
  51 class CPSlot {
  52  friend class ConstantPool;
  53   intptr_t _ptr;
  54   enum TagBits  {_pseudo_bit = 1};
  55  public:
  56 
  57   CPSlot(intptr_t ptr): _ptr(ptr) {}
  58   CPSlot(Symbol* ptr, int tag_bits = 0): _ptr((intptr_t)ptr | tag_bits) {}
  59 
  60   intptr_t value()   { return _ptr; }
  61   bool is_pseudo_string() { return (_ptr &amp; _pseudo_bit) != 0; }
  62 
  63   Symbol* get_symbol() {
  64     return (Symbol*)(_ptr &amp; ~_pseudo_bit);
  65   }
  66 };
  67 
  68 // This represents a JVM_CONSTANT_Class, JVM_CONSTANT_UnresolvedClass, or
  69 // JVM_CONSTANT_UnresolvedClassInError slot in the constant pool.
  70 class CPKlassSlot {
  71   // cp-&gt;symbol_at(_name_index) gives the name of the class.
  72   int _name_index;
  73 
  74   // cp-&gt;_resolved_klasses-&gt;at(_resolved_klass_index) gives the Klass* for the class.
  75   int _resolved_klass_index;
  76 public:
  77   enum {
  78     // This is used during constant pool merging where the resolved klass index is
  79     // not yet known, and will be computed at a later stage (during a call to
  80     // initialize_unresolved_klasses()).
  81     _temp_resolved_klass_index = 0xffff
  82   };
  83   CPKlassSlot(int n, int rk) {
  84     _name_index = n;
  85     _resolved_klass_index = rk;
  86   }
  87   int name_index() const {
  88     return _name_index;
  89   }
  90   int resolved_klass_index() const {
  91     assert(_resolved_klass_index != _temp_resolved_klass_index, &quot;constant pool merging was incomplete&quot;);
  92     return _resolved_klass_index;
  93   }
  94 };
  95 
  96 class ConstantPool : public Metadata {
  97   friend class VMStructs;
  98   friend class JVMCIVMStructs;
  99   friend class BytecodeInterpreter;  // Directly extracts a klass in the pool for fast instanceof/checkcast
 100   friend class Universe;             // For null constructor
 101  private:
 102   // If you add a new field that points to any metaspace object, you
 103   // must add this field to ConstantPool::metaspace_pointers_do().
 104   Array&lt;u1&gt;*           _tags;        // the tag array describing the constant pool&#39;s contents
 105   ConstantPoolCache*   _cache;       // the cache holding interpreter runtime information
 106   InstanceKlass*       _pool_holder; // the corresponding class
 107   Array&lt;u2&gt;*           _operands;    // for variable-sized (InvokeDynamic) nodes, usually empty
 108 
 109   // Consider using an array of compressed klass pointers to
 110   // save space on 64-bit platforms.
 111   Array&lt;Klass*&gt;*       _resolved_klasses;
 112 
<a name="1" id="anc1"></a>









 113   enum {
 114     _has_preresolution    = 1,       // Flags
 115     _on_stack             = 2,
 116     _is_shared            = 4,
 117     _has_dynamic_constant = 8
 118   };
 119 
<a name="2" id="anc2"></a><span class="line-modified"> 120   int                  _flags;  // old fashioned bit twiddling</span>
<span class="line-modified"> 121   int                  _length; // number of elements in the array</span>

 122 
 123   union {
 124     // set for CDS to restore resolved references
 125     int                _resolved_reference_length;
 126     // keeps version number for redefined classes (used in backtrace)
 127     int                _version;
 128   } _saved;
 129 
 130   void set_tags(Array&lt;u1&gt;* tags)               { _tags = tags; }
 131   void tag_at_put(int which, jbyte t)          { tags()-&gt;at_put(which, t); }
 132   void release_tag_at_put(int which, jbyte t)  { tags()-&gt;release_at_put(which, t); }
 133 
 134   u1* tag_addr_at(int which) const             { return tags()-&gt;adr_at(which); }
 135 
 136   void set_operands(Array&lt;u2&gt;* operands)       { _operands = operands; }
 137 
<a name="3" id="anc3"></a><span class="line-modified"> 138   int flags() const                            { return _flags; }</span>
<span class="line-modified"> 139   void set_flags(int f)                        { _flags = f; }</span>
 140 
 141  private:
 142   intptr_t* base() const { return (intptr_t*) (((char*) this) + sizeof(ConstantPool)); }
 143 
 144   CPSlot slot_at(int which) const;
 145 
 146   void slot_at_put(int which, CPSlot s) const {
 147     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 148     assert(s.value() != 0, &quot;Caught something&quot;);
 149     *(intptr_t*)&amp;base()[which] = s.value();
 150   }
 151   intptr_t* obj_at_addr(int which) const {
 152     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 153     return (intptr_t*) &amp;base()[which];
 154   }
 155 
 156   jint* int_at_addr(int which) const {
 157     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 158     return (jint*) &amp;base()[which];
 159   }
 160 
 161   jlong* long_at_addr(int which) const {
 162     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 163     return (jlong*) &amp;base()[which];
 164   }
 165 
 166   jfloat* float_at_addr(int which) const {
 167     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 168     return (jfloat*) &amp;base()[which];
 169   }
 170 
 171   jdouble* double_at_addr(int which) const {
 172     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 173     return (jdouble*) &amp;base()[which];
 174   }
 175 
 176   ConstantPool(Array&lt;u1&gt;* tags);
 177   ConstantPool() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 178  public:
 179   static ConstantPool* allocate(ClassLoaderData* loader_data, int length, TRAPS);
 180 
 181   bool is_constantPool() const volatile     { return true; }
 182 
 183   Array&lt;u1&gt;* tags() const                   { return _tags; }
 184   Array&lt;u2&gt;* operands() const               { return _operands; }
 185 
 186   bool has_preresolution() const            { return (_flags &amp; _has_preresolution) != 0; }
 187   void set_has_preresolution() {
 188     assert(!is_shared(), &quot;should never be called on shared ConstantPools&quot;);
 189     _flags |= _has_preresolution;
 190   }
 191 
<a name="4" id="anc4"></a>























 192   // Redefine classes support.  If a method refering to this constant pool
 193   // is on the executing stack, or as a handle in vm code, this constant pool
 194   // can&#39;t be removed from the set of previous versions saved in the instance
 195   // class.
 196   bool on_stack() const                      { return (_flags &amp;_on_stack) != 0; }
 197   void set_on_stack(const bool value);
 198 
 199   // Faster than MetaspaceObj::is_shared() - used by set_on_stack()
 200   bool is_shared() const                     { return (_flags &amp; _is_shared) != 0; }
 201 
 202   bool has_dynamic_constant() const       { return (_flags &amp; _has_dynamic_constant) != 0; }
 203   void set_has_dynamic_constant()         { _flags |= _has_dynamic_constant; }
 204 
 205   // Klass holding pool
 206   InstanceKlass* pool_holder() const      { return _pool_holder; }
 207   void set_pool_holder(InstanceKlass* k)  { _pool_holder = k; }
 208   InstanceKlass** pool_holder_addr()      { return &amp;_pool_holder; }
 209 
 210   // Interpreter runtime support
 211   ConstantPoolCache* cache() const        { return _cache; }
 212   void set_cache(ConstantPoolCache* cache){ _cache = cache; }
 213 
 214   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 215   virtual MetaspaceObj::Type type() const { return ConstantPoolType; }
 216 
 217   // Create object cache in the constant pool
 218   void initialize_resolved_references(ClassLoaderData* loader_data,
 219                                       const intStack&amp; reference_map,
 220                                       int constant_pool_map_length,
 221                                       TRAPS);
 222 
 223   // resolved strings, methodHandles and callsite objects from the constant pool
 224   objArrayOop resolved_references()  const;
 225   objArrayOop resolved_references_or_null()  const;
 226   // mapping resolved object array indexes to cp indexes and back.
 227   int object_to_cp_index(int index)         { return reference_map()-&gt;at(index); }
 228   int cp_to_object_index(int index);
 229 
 230   void set_resolved_klasses(Array&lt;Klass*&gt;* rk)  { _resolved_klasses = rk; }
 231   Array&lt;Klass*&gt;* resolved_klasses() const       { return _resolved_klasses; }
 232   void allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS);
 233   void initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS);
 234 
 235   // Invokedynamic indexes.
 236   // They must look completely different from normal indexes.
 237   // The main reason is that byte swapping is sometimes done on normal indexes.
 238   // Finally, it is helpful for debugging to tell the two apart.
 239   static bool is_invokedynamic_index(int i) { return (i &lt; 0); }
 240   static int  decode_invokedynamic_index(int i) { assert(is_invokedynamic_index(i),  &quot;&quot;); return ~i; }
 241   static int  encode_invokedynamic_index(int i) { assert(!is_invokedynamic_index(i), &quot;&quot;); return ~i; }
 242 
 243 
 244   // The invokedynamic points at a CP cache entry.  This entry points back
 245   // at the original CP entry (CONSTANT_InvokeDynamic) and also (via f2) at an entry
 246   // in the resolved_references array (which provides the appendix argument).
 247   int invokedynamic_cp_cache_index(int indy_index) const {
 248     assert(is_invokedynamic_index(indy_index), &quot;should be a invokedynamic index&quot;);
 249     int cache_index = decode_invokedynamic_index(indy_index);
 250     return cache_index;
 251   }
 252   ConstantPoolCacheEntry* invokedynamic_cp_cache_entry_at(int indy_index) const {
 253     // decode index that invokedynamic points to.
 254     int cp_cache_index = invokedynamic_cp_cache_index(indy_index);
 255     return cache()-&gt;entry_at(cp_cache_index);
 256   }
 257   // Given the per-instruction index of an indy instruction, report the
 258   // main constant pool entry for its bootstrap specifier.
 259   // From there, uncached_name/signature_ref_at will get the name/type.
 260   int invokedynamic_bootstrap_ref_index_at(int indy_index) const {
 261     return invokedynamic_cp_cache_entry_at(indy_index)-&gt;constant_pool_index();
 262   }
 263 
 264   // Assembly code support
 265   static int tags_offset_in_bytes()         { return offset_of(ConstantPool, _tags); }
 266   static int cache_offset_in_bytes()        { return offset_of(ConstantPool, _cache); }
 267   static int pool_holder_offset_in_bytes()  { return offset_of(ConstantPool, _pool_holder); }
 268   static int resolved_klasses_offset_in_bytes()    { return offset_of(ConstantPool, _resolved_klasses); }
 269 
 270   // Storing constants
 271 
 272   // For temporary use while constructing constant pool. Used during a retransform/class redefinition as well.
 273   void klass_index_at_put(int which, int name_index) {
 274     tag_at_put(which, JVM_CONSTANT_ClassIndex);
 275     *int_at_addr(which) = name_index;
 276   }
 277 
 278   // Unsafe anonymous class support:
 279   void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);
 280   void klass_at_put(int class_index, Klass* k);
 281 
 282   void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {
 283       release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);
 284 
 285       assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 286       assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 287       *int_at_addr(which) =
 288         build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 289     }
 290 
 291   void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {
 292     release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);
 293 
 294     assert((name_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 295     assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 296     *int_at_addr(which) =
 297       build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 298   }
 299 
 300   void method_handle_index_at_put(int which, int ref_kind, int ref_index) {
 301     tag_at_put(which, JVM_CONSTANT_MethodHandle);
 302     *int_at_addr(which) = ((jint) ref_index&lt;&lt;16) | ref_kind;
 303   }
 304 
 305   void method_type_index_at_put(int which, int ref_index) {
 306     tag_at_put(which, JVM_CONSTANT_MethodType);
 307     *int_at_addr(which) = ref_index;
 308   }
 309 
 310   void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 311     tag_at_put(which, JVM_CONSTANT_Dynamic);
 312     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 313   }
 314 
 315   void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {
 316     tag_at_put(which, JVM_CONSTANT_InvokeDynamic);
 317     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | bsms_attribute_index;
 318   }
 319 
 320   void unresolved_string_at_put(int which, Symbol* s) {
 321     release_tag_at_put(which, JVM_CONSTANT_String);
 322     slot_at_put(which, CPSlot(s));
 323   }
 324 
 325   void int_at_put(int which, jint i) {
 326     tag_at_put(which, JVM_CONSTANT_Integer);
 327     *int_at_addr(which) = i;
 328   }
 329 
 330   void long_at_put(int which, jlong l) {
 331     tag_at_put(which, JVM_CONSTANT_Long);
 332     // *long_at_addr(which) = l;
 333     Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &amp;l));
 334   }
 335 
 336   void float_at_put(int which, jfloat f) {
 337     tag_at_put(which, JVM_CONSTANT_Float);
 338     *float_at_addr(which) = f;
 339   }
 340 
 341   void double_at_put(int which, jdouble d) {
 342     tag_at_put(which, JVM_CONSTANT_Double);
 343     // *double_at_addr(which) = d;
 344     // u8 temp = *(u8*) &amp;d;
 345     Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &amp;d));
 346   }
 347 
 348   Symbol** symbol_at_addr(int which) const {
 349     assert(is_within_bounds(which), &quot;index out of bounds&quot;);
 350     return (Symbol**) &amp;base()[which];
 351   }
 352 
 353   void symbol_at_put(int which, Symbol* s) {
 354     assert(s-&gt;refcount() != 0, &quot;should have nonzero refcount&quot;);
 355     tag_at_put(which, JVM_CONSTANT_Utf8);
 356     *symbol_at_addr(which) = s;
 357   }
 358 
 359   void string_at_put(int which, int obj_index, oop str);
 360 
 361   // For temporary use while constructing constant pool
 362   void string_index_at_put(int which, int string_index) {
 363     tag_at_put(which, JVM_CONSTANT_StringIndex);
 364     *int_at_addr(which) = string_index;
 365   }
 366 
 367   void field_at_put(int which, int class_index, int name_and_type_index) {
 368     tag_at_put(which, JVM_CONSTANT_Fieldref);
 369     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 370   }
 371 
 372   void method_at_put(int which, int class_index, int name_and_type_index) {
 373     tag_at_put(which, JVM_CONSTANT_Methodref);
 374     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;
 375   }
 376 
 377   void interface_method_at_put(int which, int class_index, int name_and_type_index) {
 378     tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);
 379     *int_at_addr(which) = ((jint) name_and_type_index&lt;&lt;16) | class_index;  // Not so nice
 380   }
 381 
 382   void name_and_type_at_put(int which, int name_index, int signature_index) {
 383     tag_at_put(which, JVM_CONSTANT_NameAndType);
 384     *int_at_addr(which) = ((jint) signature_index&lt;&lt;16) | name_index;  // Not so nice
 385   }
 386 
 387   // Tag query
 388 
 389   constantTag tag_at(int which) const { return (constantTag)tags()-&gt;at_acquire(which); }
 390 
 391   // Fetching constants
 392 
 393   Klass* klass_at(int which, TRAPS) {
 394     constantPoolHandle h_this(THREAD, this);
 395     return klass_at_impl(h_this, which, true, THREAD);
 396   }
 397 
 398   // Version of klass_at that doesn&#39;t save the resolution error, called during deopt
 399   Klass* klass_at_ignore_error(int which, TRAPS) {
 400     constantPoolHandle h_this(THREAD, this);
 401     return klass_at_impl(h_this, which, false, THREAD);
 402   }
 403 
 404   CPKlassSlot klass_slot_at(int which) const {
 405     assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),
 406            &quot;Corrupted constant pool&quot;);
 407     int value = *int_at_addr(which);
 408     int name_index = extract_high_short_from_int(value);
 409     int resolved_klass_index = extract_low_short_from_int(value);
 410     return CPKlassSlot(name_index, resolved_klass_index);
 411   }
 412 
 413   Symbol* klass_name_at(int which) const;  // Returns the name, w/o resolving.
 414   int klass_name_index_at(int which) const {
 415     return klass_slot_at(which).name_index();
 416   }
 417 
 418   Klass* resolved_klass_at(int which) const;  // Used by Compiler
 419 
 420   // RedefineClasses() API support:
 421   Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }
 422   void temp_unresolved_klass_at_put(int which, int name_index) {
 423     // Used only during constant pool merging for class redefinition. The resolved klass index
 424     // will be initialized later by a call to initialize_unresolved_klasses().
 425     unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);
 426   }
 427 
 428   jint int_at(int which) {
 429     assert(tag_at(which).is_int(), &quot;Corrupted constant pool&quot;);
 430     return *int_at_addr(which);
 431   }
 432 
 433   jlong long_at(int which) {
 434     assert(tag_at(which).is_long(), &quot;Corrupted constant pool&quot;);
 435     // return *long_at_addr(which);
 436     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 437     return *((jlong*)&amp;tmp);
 438   }
 439 
 440   jfloat float_at(int which) {
 441     assert(tag_at(which).is_float(), &quot;Corrupted constant pool&quot;);
 442     return *float_at_addr(which);
 443   }
 444 
 445   jdouble double_at(int which) {
 446     assert(tag_at(which).is_double(), &quot;Corrupted constant pool&quot;);
 447     u8 tmp = Bytes::get_native_u8((address)&amp;base()[which]);
 448     return *((jdouble*)&amp;tmp);
 449   }
 450 
 451   Symbol* symbol_at(int which) const {
 452     assert(tag_at(which).is_utf8(), &quot;Corrupted constant pool&quot;);
 453     return *symbol_at_addr(which);
 454   }
 455 
 456   oop string_at(int which, int obj_index, TRAPS) {
 457     constantPoolHandle h_this(THREAD, this);
 458     return string_at_impl(h_this, which, obj_index, THREAD);
 459   }
 460   oop string_at(int which, TRAPS) {
 461     int obj_index = cp_to_object_index(which);
 462     return string_at(which, obj_index, THREAD);
 463   }
 464 
 465   // Version that can be used before string oop array is created.
 466   oop uncached_string_at(int which, TRAPS);
 467 
 468   // A &quot;pseudo-string&quot; is an non-string oop that has found its way into
 469   // a String entry.
 470   // This can happen if the user patches a live
 471   // object into a CONSTANT_String entry of an unsafe anonymous class.
 472   // Method oops internally created for method handles may also
 473   // use pseudo-strings to link themselves to related metaobjects.
 474 
 475   bool is_pseudo_string_at(int which);
 476 
 477   oop pseudo_string_at(int which, int obj_index);
 478 
 479   oop pseudo_string_at(int which);
 480 
 481   void pseudo_string_at_put(int which, int obj_index, oop x) {
 482     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 483     Symbol* sym = unresolved_string_at(which);
 484     slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));
 485     string_at_put(which, obj_index, x);    // this works just fine
 486   }
 487 
 488   // only called when we are sure a string entry is already resolved (via an
 489   // earlier string_at call.
 490   oop resolved_string_at(int which) {
 491     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 492     // Must do an acquire here in case another thread resolved the klass
 493     // behind our back, lest we later load stale values thru the oop.
 494     // we might want a volatile_obj_at in ObjArrayKlass.
 495     int obj_index = cp_to_object_index(which);
 496     return resolved_references()-&gt;obj_at(obj_index);
 497   }
 498 
 499   Symbol* unresolved_string_at(int which) {
 500     assert(tag_at(which).is_string(), &quot;Corrupted constant pool&quot;);
 501     Symbol* sym = slot_at(which).get_symbol();
 502     return sym;
 503   }
 504 
 505   // Returns an UTF8 for a CONSTANT_String entry at a given index.
 506   // UTF8 char* representation was chosen to avoid conversion of
 507   // java_lang_Strings at resolved entries into Symbol*s
 508   // or vice versa.
 509   char* string_at_noresolve(int which);
 510 
 511   jint name_and_type_at(int which) {
 512     assert(tag_at(which).is_name_and_type(), &quot;Corrupted constant pool&quot;);
 513     return *int_at_addr(which);
 514   }
 515 
 516   int method_handle_ref_kind_at(int which) {
 517     assert(tag_at(which).is_method_handle() ||
 518            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 519     return extract_low_short_from_int(*int_at_addr(which));  // mask out unwanted ref_index bits
 520   }
 521   int method_handle_index_at(int which) {
 522     assert(tag_at(which).is_method_handle() ||
 523            tag_at(which).is_method_handle_in_error(), &quot;Corrupted constant pool&quot;);
 524     return extract_high_short_from_int(*int_at_addr(which));  // shift out unwanted ref_kind bits
 525   }
 526   int method_type_index_at(int which) {
 527     assert(tag_at(which).is_method_type() ||
 528            tag_at(which).is_method_type_in_error(), &quot;Corrupted constant pool&quot;);
 529     return *int_at_addr(which);
 530   }
 531 
 532   // Derived queries:
 533   Symbol* method_handle_name_ref_at(int which) {
 534     int member = method_handle_index_at(which);
 535     return impl_name_ref_at(member, true);
 536   }
 537   Symbol* method_handle_signature_ref_at(int which) {
 538     int member = method_handle_index_at(which);
 539     return impl_signature_ref_at(member, true);
 540   }
 541   int method_handle_klass_index_at(int which) {
 542     int member = method_handle_index_at(which);
 543     return impl_klass_ref_index_at(member, true);
 544   }
 545   Symbol* method_type_signature_at(int which) {
 546     int sym = method_type_index_at(which);
 547     return symbol_at(sym);
 548   }
 549 
 550   int bootstrap_name_and_type_ref_index_at(int which) {
 551     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 552     return extract_high_short_from_int(*int_at_addr(which));
 553   }
 554   int bootstrap_methods_attribute_index(int which) {
 555     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 556     return extract_low_short_from_int(*int_at_addr(which));
 557   }
 558   int bootstrap_operand_base(int which) {
 559     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 560     return operand_offset_at(operands(), bsms_attribute_index);
 561   }
 562   // The first part of the operands array consists of an index into the second part.
 563   // Extract a 32-bit index value from the first part.
 564   static int operand_offset_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 565     int n = (bsms_attribute_index * 2);
 566     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 567     // The first 32-bit index points to the beginning of the second part
 568     // of the operands array.  Make sure this index is in the first part.
 569     DEBUG_ONLY(int second_part = build_int_from_shorts(operands-&gt;at(0),
 570                                                        operands-&gt;at(1)));
 571     assert(second_part == 0 || n+2 &lt;= second_part, &quot;oob (2)&quot;);
 572     int offset = build_int_from_shorts(operands-&gt;at(n+0),
 573                                        operands-&gt;at(n+1));
 574     // The offset itself must point into the second part of the array.
 575     assert(offset == 0 || offset &gt;= second_part &amp;&amp; offset &lt;= operands-&gt;length(), &quot;oob (3)&quot;);
 576     return offset;
 577   }
 578   static void operand_offset_at_put(Array&lt;u2&gt;* operands, int bsms_attribute_index, int offset) {
 579     int n = bsms_attribute_index * 2;
 580     assert(n &gt;= 0 &amp;&amp; n+2 &lt;= operands-&gt;length(), &quot;oob&quot;);
 581     operands-&gt;at_put(n+0, extract_low_short_from_int(offset));
 582     operands-&gt;at_put(n+1, extract_high_short_from_int(offset));
 583   }
 584   static int operand_array_length(Array&lt;u2&gt;* operands) {
 585     if (operands == NULL || operands-&gt;length() == 0)  return 0;
 586     int second_part = operand_offset_at(operands, 0);
 587     return (second_part / 2);
 588   }
 589 
 590 #ifdef ASSERT
 591   // operand tuples fit together exactly, end to end
 592   static int operand_limit_at(Array&lt;u2&gt;* operands, int bsms_attribute_index) {
 593     int nextidx = bsms_attribute_index + 1;
 594     if (nextidx == operand_array_length(operands))
 595       return operands-&gt;length();
 596     else
 597       return operand_offset_at(operands, nextidx);
 598   }
 599   int bootstrap_operand_limit(int which) {
 600     int bsms_attribute_index = bootstrap_methods_attribute_index(which);
 601     return operand_limit_at(operands(), bsms_attribute_index);
 602   }
 603 #endif //ASSERT
 604 
 605   // Layout of InvokeDynamic and Dynamic bootstrap method specifier
 606   // data in second part of operands array.  This encodes one record in
 607   // the BootstrapMethods attribute.  The whole specifier also includes
 608   // the name and type information from the main constant pool entry.
 609   enum {
 610          _indy_bsm_offset  = 0,  // CONSTANT_MethodHandle bsm
 611          _indy_argc_offset = 1,  // u2 argc
 612          _indy_argv_offset = 2   // u2 argv[argc]
 613   };
 614 
 615   // These functions are used in RedefineClasses for CP merge
 616 
 617   int operand_offset_at(int bsms_attribute_index) {
 618     assert(0 &lt;= bsms_attribute_index &amp;&amp;
 619            bsms_attribute_index &lt; operand_array_length(operands()),
 620            &quot;Corrupted CP operands&quot;);
 621     return operand_offset_at(operands(), bsms_attribute_index);
 622   }
 623   int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {
 624     int offset = operand_offset_at(bsms_attribute_index);
 625     return operands()-&gt;at(offset + _indy_bsm_offset);
 626   }
 627   int operand_argument_count_at(int bsms_attribute_index) {
 628     int offset = operand_offset_at(bsms_attribute_index);
 629     int argc = operands()-&gt;at(offset + _indy_argc_offset);
 630     return argc;
 631   }
 632   int operand_argument_index_at(int bsms_attribute_index, int j) {
 633     int offset = operand_offset_at(bsms_attribute_index);
 634     return operands()-&gt;at(offset + _indy_argv_offset + j);
 635   }
 636   int operand_next_offset_at(int bsms_attribute_index) {
 637     int offset = operand_offset_at(bsms_attribute_index) + _indy_argv_offset
 638                    + operand_argument_count_at(bsms_attribute_index);
 639     return offset;
 640   }
 641   // Compare a bootstrap specifier data in the operands arrays
 642   bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle&amp; cp2,
 643                           int bsms_attribute_index2, TRAPS);
 644   // Find a bootstrap specifier data in the operands array
 645   int find_matching_operand(int bsms_attribute_index, const constantPoolHandle&amp; search_cp,
 646                             int operands_cur_len, TRAPS);
 647   // Resize the operands array with delta_len and delta_size
 648   void resize_operands(int delta_len, int delta_size, TRAPS);
 649   // Extend the operands array with the length and size of the ext_cp operands
 650   void extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS);
 651   // Shrink the operands array to a smaller array with new_len length
 652   void shrink_operands(int new_len, TRAPS);
 653 
 654   int bootstrap_method_ref_index_at(int which) {
 655     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 656     int op_base = bootstrap_operand_base(which);
 657     return operands()-&gt;at(op_base + _indy_bsm_offset);
 658   }
 659   int bootstrap_argument_count_at(int which) {
 660     assert(tag_at(which).has_bootstrap(), &quot;Corrupted constant pool&quot;);
 661     int op_base = bootstrap_operand_base(which);
 662     int argc = operands()-&gt;at(op_base + _indy_argc_offset);
 663     DEBUG_ONLY(int end_offset = op_base + _indy_argv_offset + argc;
 664                int next_offset = bootstrap_operand_limit(which));
 665     assert(end_offset == next_offset, &quot;matched ending&quot;);
 666     return argc;
 667   }
 668   int bootstrap_argument_index_at(int which, int j) {
 669     int op_base = bootstrap_operand_base(which);
 670     DEBUG_ONLY(int argc = operands()-&gt;at(op_base + _indy_argc_offset));
 671     assert((uint)j &lt; (uint)argc, &quot;oob&quot;);
 672     return operands()-&gt;at(op_base + _indy_argv_offset + j);
 673   }
 674 
 675   // The following methods (name/signature/klass_ref_at, klass_ref_at_noresolve,
 676   // name_and_type_ref_index_at) all expect to be passed indices obtained
 677   // directly from the bytecode.
 678   // If the indices are meant to refer to fields or methods, they are
 679   // actually rewritten constant pool cache indices.
 680   // The routine remap_instruction_operand_from_cache manages the adjustment
 681   // of these values back to constant pool indices.
 682 
 683   // There are also &quot;uncached&quot; versions which do not adjust the operand index; see below.
 684 
 685   // FIXME: Consider renaming these with a prefix &quot;cached_&quot; to make the distinction clear.
 686   // In a few cases (the verifier) there are uses before a cpcache has been built,
 687   // which are handled by a dynamic check in remap_instruction_operand_from_cache.
 688   // FIXME: Remove the dynamic check, and adjust all callers to specify the correct mode.
 689 
 690   // Lookup for entries consisting of (klass_index, name_and_type index)
 691   Klass* klass_ref_at(int which, TRAPS);
 692   Symbol* klass_ref_at_noresolve(int which);
 693   Symbol* name_ref_at(int which)                { return impl_name_ref_at(which, false); }
 694   Symbol* signature_ref_at(int which)           { return impl_signature_ref_at(which, false); }
 695 
 696   int klass_ref_index_at(int which)               { return impl_klass_ref_index_at(which, false); }
 697   int name_and_type_ref_index_at(int which)       { return impl_name_and_type_ref_index_at(which, false); }
 698 
 699   int remap_instruction_operand_from_cache(int operand);  // operand must be biased by CPCACHE_INDEX_TAG
 700 
 701   constantTag tag_ref_at(int cp_cache_index)      { return impl_tag_ref_at(cp_cache_index, false); }
 702 
 703   // Lookup for entries consisting of (name_index, signature_index)
 704   int name_ref_index_at(int which_nt);            // ==  low-order jshort of name_and_type_at(which_nt)
 705   int signature_ref_index_at(int which_nt);       // == high-order jshort of name_and_type_at(which_nt)
 706 
 707   BasicType basic_type_for_signature_at(int which) const;
 708 
 709   // Resolve string constants (to prevent allocation during compilation)
 710   void resolve_string_constants(TRAPS) {
 711     constantPoolHandle h_this(THREAD, this);
 712     resolve_string_constants_impl(h_this, CHECK);
 713   }
 714 
 715   // CDS support
 716   void archive_resolved_references(Thread *THREAD) NOT_CDS_JAVA_HEAP_RETURN;
 717   void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 718   void remove_unshareable_info();
 719   void restore_unshareable_info(TRAPS);
 720   // The ConstantPool vtable is restored by this call when the ConstantPool is
 721   // in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for
 722   // all the gory details.  SA, dtrace and pstack helpers distinguish metadata
 723   // by their vtable.
 724   void restore_vtable() { guarantee(is_constantPool(), &quot;vtable restored by this call&quot;); }
 725 
 726  private:
 727   enum { _no_index_sentinel = -1, _possible_index_sentinel = -2 };
 728  public:
 729 
 730   // Get the tag for a constant, which may involve a constant dynamic
 731   constantTag constant_tag_at(int which);
 732   // Get the basic type for a constant, which may involve a constant dynamic
 733   BasicType basic_type_for_constant_at(int which);
 734 
 735   // Resolve late bound constants.
 736   oop resolve_constant_at(int index, TRAPS) {
 737     constantPoolHandle h_this(THREAD, this);
 738     return resolve_constant_at_impl(h_this, index, _no_index_sentinel, NULL, THREAD);
 739   }
 740 
 741   oop resolve_cached_constant_at(int cache_index, TRAPS) {
 742     constantPoolHandle h_this(THREAD, this);
 743     return resolve_constant_at_impl(h_this, _no_index_sentinel, cache_index, NULL, THREAD);
 744   }
 745 
 746   oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {
 747     constantPoolHandle h_this(THREAD, this);
 748     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, NULL, THREAD);
 749   }
 750 
 751   oop find_cached_constant_at(int pool_index, bool&amp; found_it, TRAPS) {
 752     constantPoolHandle h_this(THREAD, this);
 753     return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &amp;found_it, THREAD);
 754   }
 755 
 756   void copy_bootstrap_arguments_at(int index,
 757                                    int start_arg, int end_arg,
 758                                    objArrayHandle info, int pos,
 759                                    bool must_resolve, Handle if_not_available, TRAPS) {
 760     constantPoolHandle h_this(THREAD, this);
 761     copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,
 762                                      info, pos, must_resolve, if_not_available, THREAD);
 763   }
 764 
 765   // Klass name matches name at offset
 766   bool klass_name_at_matches(const InstanceKlass* k, int which);
 767 
 768   // Sizing
 769   int length() const                   { return _length; }
 770   void set_length(int length)          { _length = length; }
 771 
 772   // Tells whether index is within bounds.
 773   bool is_within_bounds(int index) const {
 774     return 0 &lt;= index &amp;&amp; index &lt; length();
 775   }
 776 
 777   // Sizing (in words)
 778   static int header_size()             {
 779     return align_up((int)sizeof(ConstantPool), wordSize) / wordSize;
 780   }
 781   static int size(int length)          { return align_metadata_size(header_size() + length); }
 782   int size() const                     { return size(length()); }
 783 
 784   // ConstantPools should be stored in the read-only region of CDS archive.
 785   static bool is_read_only_by_default() { return true; }
 786 
 787   friend class ClassFileParser;
 788   friend class SystemDictionary;
 789 
 790   // Used by CDS. These classes need to access the private ConstantPool() constructor.
 791   template &lt;class T&gt; friend class CppVtableTesterA;
 792   template &lt;class T&gt; friend class CppVtableTesterB;
 793   template &lt;class T&gt; friend class CppVtableCloner;
 794 
 795   // Used by compiler to prevent classloading.
 796   static Method*          method_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 797   static bool       has_appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 798   static oop            appendix_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 799   static bool has_local_signature_at_if_loaded     (const constantPoolHandle&amp; this_cp, int which);
 800   static Klass*            klass_at_if_loaded      (const constantPoolHandle&amp; this_cp, int which);
 801 
 802   // Routines currently used for annotations (only called by jvm.cpp) but which might be used in the
 803   // future by other Java code. These take constant pool indices rather than
 804   // constant pool cache indices as do the peer methods above.
 805   Symbol* uncached_klass_ref_at_noresolve(int which);
 806   Symbol* uncached_name_ref_at(int which)                 { return impl_name_ref_at(which, true); }
 807   Symbol* uncached_signature_ref_at(int which)            { return impl_signature_ref_at(which, true); }
 808   int       uncached_klass_ref_index_at(int which)          { return impl_klass_ref_index_at(which, true); }
 809   int       uncached_name_and_type_ref_index_at(int which)  { return impl_name_and_type_ref_index_at(which, true); }
 810 
 811   // Sharing
 812   int pre_resolve_shared_klasses(TRAPS);
 813 
 814   // Debugging
 815   const char* printable_name_at(int which) PRODUCT_RETURN0;
 816 
 817 #ifdef ASSERT
 818   enum { CPCACHE_INDEX_TAG = 0x10000 };  // helps keep CP cache indices distinct from CP indices
 819 #else
 820   enum { CPCACHE_INDEX_TAG = 0 };        // in product mode, this zero value is a no-op
 821 #endif //ASSERT
 822 
 823   static int decode_cpcache_index(int raw_index, bool invokedynamic_ok = false) {
 824     if (invokedynamic_ok &amp;&amp; is_invokedynamic_index(raw_index))
 825       return decode_invokedynamic_index(raw_index);
 826     else
 827       return raw_index - CPCACHE_INDEX_TAG;
 828   }
 829 
 830  private:
 831 
 832   void set_resolved_references(OopHandle s) { _cache-&gt;set_resolved_references(s); }
 833   Array&lt;u2&gt;* reference_map() const        {  return (_cache == NULL) ? NULL :  _cache-&gt;reference_map(); }
 834   void set_reference_map(Array&lt;u2&gt;* o)    { _cache-&gt;set_reference_map(o); }
 835 
 836   // patch JSR 292 resolved references after the class is linked.
 837   void patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches);
 838 
 839   Symbol* impl_name_ref_at(int which, bool uncached);
 840   Symbol* impl_signature_ref_at(int which, bool uncached);
 841 
 842   int       impl_klass_ref_index_at(int which, bool uncached);
 843   int       impl_name_and_type_ref_index_at(int which, bool uncached);
 844   constantTag impl_tag_ref_at(int which, bool uncached);
 845 
 846   // Used while constructing constant pool (only by ClassFileParser)
 847   jint klass_index_at(int which) {
 848     assert(tag_at(which).is_klass_index(), &quot;Corrupted constant pool&quot;);
 849     return *int_at_addr(which);
 850   }
 851 
 852   jint string_index_at(int which) {
 853     assert(tag_at(which).is_string_index(), &quot;Corrupted constant pool&quot;);
 854     return *int_at_addr(which);
 855   }
 856 
 857   // Performs the LinkResolver checks
 858   static void verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* klass, TRAPS);
 859 
 860   // Implementation of methods that needs an exposed &#39;this&#39; pointer, in order to
 861   // handle GC while executing the method
 862   static Klass* klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 863                               bool save_resolution_error, TRAPS);
 864   static oop string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS);
 865 
 866   static void trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k);
 867 
 868   // Resolve string constants (to prevent allocation during compilation)
 869   static void resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS);
 870 
 871   static oop resolve_constant_at_impl(const constantPoolHandle&amp; this_cp, int index, int cache_index,
 872                                       bool* status_return, TRAPS);
 873   static void copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
 874                                                int start_arg, int end_arg,
 875                                                objArrayHandle info, int pos,
 876                                                bool must_resolve, Handle if_not_available, TRAPS);
 877 
 878   // Exception handling
 879   static Symbol* exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception);
 880   static void save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which, constantTag tag, TRAPS);
 881 
 882  public:
 883   // Exception handling
 884   static void throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS);
 885 
 886   // Merging ConstantPool* support:
 887   bool compare_entry_to(int index1, const constantPoolHandle&amp; cp2, int index2, TRAPS);
 888   void copy_cp_to(int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
 889     constantPoolHandle h_this(THREAD, this);
 890     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
 891   }
 892   static void copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 893   static void copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i, const constantPoolHandle&amp; to_cp, int to_i, TRAPS);
 894   static void copy_operands(const constantPoolHandle&amp; from_cp, const constantPoolHandle&amp; to_cp, TRAPS);
 895   int  find_matching_entry(int pattern_i, const constantPoolHandle&amp; search_cp, TRAPS);
 896   int  version() const                    { return _saved._version; }
 897   void set_version(int version)           { _saved._version = version; }
 898   void increment_and_save_version(int version) {
 899     _saved._version = version &gt;= 0 ? (version + 1) : version;  // keep overflow
 900   }
 901 
 902   void set_resolved_reference_length(int length) { _saved._resolved_reference_length = length; }
 903   int  resolved_reference_length() const  { return _saved._resolved_reference_length; }
 904 
 905   // Decrease ref counts of symbols that are in the constant pool
 906   // when the holder class is unloaded
 907   void unreference_symbols();
 908 
 909   // Deallocate constant pool for RedefineClasses
 910   void deallocate_contents(ClassLoaderData* loader_data);
 911   void release_C_heap_structures();
 912 
 913   // JVMTI accesss - GetConstantPool, RetransformClasses, ...
 914   friend class JvmtiConstantPoolReconstituter;
 915 
 916  private:
 917   jint cpool_entry_size(jint idx);
 918   jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);
 919 
 920   // Copy cpool bytes into byte array.
 921   // Returns:
 922   //  int &gt; 0, count of the raw cpool bytes that have been copied
 923   //        0, OutOfMemory error
 924   //       -1, Internal error
 925   int  copy_cpool_bytes(int cpool_size,
 926                         SymbolHashMap* tbl,
 927                         unsigned char *bytes);
 928 
 929  public:
 930   // Verify
 931   void verify_on(outputStream* st);
 932 
 933   // Printing
 934   void print_on(outputStream* st) const;
 935   void print_value_on(outputStream* st) const;
 936   void print_entry_on(int index, outputStream* st);
 937 
 938   const char* internal_name() const { return &quot;{constant pool}&quot;; }
 939 };
 940 
 941 class SymbolHashMapEntry : public CHeapObj&lt;mtSymbol&gt; {
 942  private:
 943   unsigned int        _hash;   // 32-bit hash for item
 944   SymbolHashMapEntry* _next;   // Next element in the linked list for this bucket
 945   Symbol*             _symbol; // 1-st part of the mapping: symbol =&gt; value
 946   u2                  _value;  // 2-nd part of the mapping: symbol =&gt; value
 947 
 948  public:
 949   unsigned   int hash() const             { return _hash;   }
 950   void       set_hash(unsigned int hash)  { _hash = hash;   }
 951 
 952   SymbolHashMapEntry* next() const        { return _next;   }
 953   void set_next(SymbolHashMapEntry* next) { _next = next;   }
 954 
 955   Symbol*    symbol() const               { return _symbol; }
 956   void       set_symbol(Symbol* sym)      { _symbol = sym;  }
 957 
 958   u2         value() const                {  return _value; }
 959   void       set_value(u2 value)          { _value = value; }
 960 
 961   SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)
 962     : _hash(hash), _next(NULL), _symbol(symbol), _value(value) {}
 963 
 964 }; // End SymbolHashMapEntry class
 965 
 966 
 967 class SymbolHashMapBucket : public CHeapObj&lt;mtSymbol&gt; {
 968 
 969 private:
 970   SymbolHashMapEntry*    _entry;
 971 
 972 public:
 973   SymbolHashMapEntry* entry() const         {  return _entry; }
 974   void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }
 975   void clear()                              { _entry = NULL;  }
 976 
 977 }; // End SymbolHashMapBucket class
 978 
 979 
 980 class SymbolHashMap: public CHeapObj&lt;mtSymbol&gt; {
 981 
 982  private:
 983   // Default number of entries in the table
 984   enum SymbolHashMap_Constants {
 985     _Def_HashMap_Size = 256
 986   };
 987 
 988   int                   _table_size;
 989   SymbolHashMapBucket*  _buckets;
 990 
 991   void initialize_table(int table_size);
 992 
 993  public:
 994 
 995   int table_size() const        { return _table_size; }
 996 
 997   SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }
 998   SymbolHashMap(int table_size) { initialize_table(table_size); }
 999 
1000   // hash P(31) from Kernighan &amp; Ritchie
1001   static unsigned int compute_hash(const char* str, int len) {
1002     unsigned int hash = 0;
1003     while (len-- &gt; 0) {
1004       hash = 31*hash + (unsigned) *str;
1005       str++;
1006     }
1007     return hash;
1008   }
1009 
1010   SymbolHashMapEntry* bucket(int i) {
1011     return _buckets[i].entry();
1012   }
1013 
1014   void add_entry(Symbol* sym, u2 value);
1015   SymbolHashMapEntry* find_entry(Symbol* sym);
1016 
1017   u2 symbol_to_value(Symbol* sym) {
1018     SymbolHashMapEntry *entry = find_entry(sym);
1019     return (entry == NULL) ? 0 : entry-&gt;value();
1020   }
1021 
1022   ~SymbolHashMap();
1023 }; // End SymbolHashMap class
1024 
1025 #endif // SHARE_OOPS_CONSTANTPOOL_HPP
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
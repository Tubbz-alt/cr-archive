<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;oops/valueArrayKlass.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/signature.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/vframe.inline.hpp&quot;
  61 #include &quot;utilities/copy.hpp&quot;
  62 
  63 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  64   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  65   int size = ConstantPool::size(length);
  66   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  67 }
  68 
<a name="1" id="anc1"></a>













  69 #ifdef ASSERT
  70 
  71 // MetaspaceObj allocation invariant is calloc equivalent memory
  72 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  73 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  74   assert(tags != NULL, &quot;invariant&quot;);
  75   const int length = tags-&gt;length();
  76   for (int index = 0; index &lt; length; ++index) {
  77     if (JVM_CONSTANT_Invalid != tags-&gt;at(index)) {
  78       return false;
  79     }
  80   }
  81   return true;
  82 }
  83 
  84 #endif
  85 
  86 ConstantPool::ConstantPool(Array&lt;u1&gt;* tags) :
  87   _tags(tags),
  88   _length(tags-&gt;length()) {
  89 
  90     assert(_tags != NULL, &quot;invariant&quot;);
  91     assert(tags-&gt;length() == _length, &quot;invariant&quot;);
  92     assert(tag_array_is_zero_initialized(tags), &quot;invariant&quot;);
  93     assert(0 == flags(), &quot;invariant&quot;);
  94     assert(0 == version(), &quot;invariant&quot;);
  95     assert(NULL == _pool_holder, &quot;invariant&quot;);
  96 }
  97 
  98 void ConstantPool::deallocate_contents(ClassLoaderData* loader_data) {
  99   if (cache() != NULL) {
 100     MetadataFactory::free_metadata(loader_data, cache());
 101     set_cache(NULL);
 102   }
 103 
 104   MetadataFactory::free_array&lt;Klass*&gt;(loader_data, resolved_klasses());
 105   set_resolved_klasses(NULL);
 106 
 107   MetadataFactory::free_array&lt;jushort&gt;(loader_data, operands());
 108   set_operands(NULL);
 109 
 110   release_C_heap_structures();
 111 
 112   // free tag array
 113   MetadataFactory::free_array&lt;u1&gt;(loader_data, tags());
 114   set_tags(NULL);
 115 }
 116 
 117 void ConstantPool::release_C_heap_structures() {
 118   // walk constant pool and decrement symbol reference counts
 119   unreference_symbols();
 120 }
 121 
 122 void ConstantPool::metaspace_pointers_do(MetaspaceClosure* it) {
 123   log_trace(cds)(&quot;Iter(ConstantPool): %p&quot;, this);
 124 
 125   it-&gt;push(&amp;_tags, MetaspaceClosure::_writable);
 126   it-&gt;push(&amp;_cache);
 127   it-&gt;push(&amp;_pool_holder);
 128   it-&gt;push(&amp;_operands);
 129   it-&gt;push(&amp;_resolved_klasses, MetaspaceClosure::_writable);
 130 
 131   for (int i = 0; i &lt; length(); i++) {
 132     // The only MSO&#39;s embedded in the CP entries are Symbols:
 133     //   JVM_CONSTANT_String (normal and pseudo)
 134     //   JVM_CONSTANT_Utf8
 135     constantTag ctag = tag_at(i);
 136     if (ctag.is_string() || ctag.is_utf8()) {
 137       it-&gt;push(symbol_at_addr(i));
 138     }
 139   }
 140 }
 141 
 142 objArrayOop ConstantPool::resolved_references() const {
 143   return (objArrayOop)_cache-&gt;resolved_references();
 144 }
 145 
 146 // Called from outside constant pool resolution where a resolved_reference array
 147 // may not be present.
 148 objArrayOop ConstantPool::resolved_references_or_null() const {
 149   if (_cache == NULL) {
 150     return NULL;
 151   } else {
 152     return (objArrayOop)_cache-&gt;resolved_references();
 153   }
 154 }
 155 
 156 // Create resolved_references array and mapping array for original cp indexes
 157 // The ldc bytecode was rewritten to have the resolved reference array index so need a way
 158 // to map it back for resolving and some unlikely miscellaneous uses.
 159 // The objects created by invokedynamic are appended to this list.
 160 void ConstantPool::initialize_resolved_references(ClassLoaderData* loader_data,
 161                                                   const intStack&amp; reference_map,
 162                                                   int constant_pool_map_length,
 163                                                   TRAPS) {
 164   // Initialized the resolved object cache.
 165   int map_length = reference_map.length();
 166   if (map_length &gt; 0) {
 167     // Only need mapping back to constant pool entries.  The map isn&#39;t used for
 168     // invokedynamic resolved_reference entries.  For invokedynamic entries,
 169     // the constant pool cache index has the mapping back to both the constant
 170     // pool and to the resolved reference index.
 171     if (constant_pool_map_length &gt; 0) {
 172       Array&lt;u2&gt;* om = MetadataFactory::new_array&lt;u2&gt;(loader_data, constant_pool_map_length, CHECK);
 173 
 174       for (int i = 0; i &lt; constant_pool_map_length; i++) {
 175         int x = reference_map.at(i);
 176         assert(x == (int)(jushort) x, &quot;klass index is too big&quot;);
 177         om-&gt;at_put(i, (jushort)x);
 178       }
 179       set_reference_map(om);
 180     }
 181 
 182     // Create Java array for holding resolved strings, methodHandles,
 183     // methodTypes, invokedynamic and invokehandle appendix objects, etc.
 184     objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 185     Handle refs_handle (THREAD, (oop)stom);  // must handleize.
 186     set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 187   }
 188 }
 189 
 190 void ConstantPool::allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS) {
 191   // A ConstantPool can&#39;t possibly have 0xffff valid class entries,
 192   // because entry #0 must be CONSTANT_Invalid, and each class entry must refer to a UTF8
 193   // entry for the class&#39;s name. So at most we will have 0xfffe class entries.
 194   // This allows us to use 0xffff (ConstantPool::_temp_resolved_klass_index) to indicate
 195   // UnresolvedKlass entries that are temporarily created during class redefinition.
 196   assert(num_klasses &lt; CPKlassSlot::_temp_resolved_klass_index, &quot;sanity&quot;);
 197   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 198   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 199   set_resolved_klasses(rk);
 200 }
 201 
 202 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 203   int len = length();
 204   int num_klasses = 0;
 205   for (int i = 1; i &lt;len; i++) {
 206     switch (tag_at(i).value()) {
 207     case JVM_CONSTANT_ClassIndex:
 208       {
 209         const int class_index = klass_index_at(i);
 210         unresolved_klass_at_put(i, class_index, num_klasses++);
 211       }
 212       break;
 213 #ifndef PRODUCT
 214     case JVM_CONSTANT_Class:
 215     case JVM_CONSTANT_UnresolvedClass:
 216     case JVM_CONSTANT_UnresolvedClassInError:
 217       // All of these should have been reverted back to Unresolved before calling
 218       // this function.
 219       ShouldNotReachHere();
 220 #endif
 221     }
 222   }
 223   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 224 }
 225 
 226 // Unsafe anonymous class support:
 227 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 228   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 229   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 230   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 231   *int_at_addr(class_index) =
 232     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 233 
 234   symbol_at_put(name_index, name);
 235   name-&gt;increment_refcount();
 236   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 237   Atomic::release_store(adr, k);
 238 
 239   // The interpreter assumes when the tag is stored, the klass is resolved
 240   // and the Klass* non-NULL, so we need hardware store ordering here.
 241   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;
 242   if (k != NULL) {
 243     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);
 244   } else {
 245     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);
 246   }
 247 }
 248 
 249 // Unsafe anonymous class support:
 250 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 251   assert(k != NULL, &quot;must be valid klass&quot;);
 252   CPKlassSlot kslot = klass_slot_at(class_index);
 253   int resolved_klass_index = kslot.resolved_klass_index();
 254   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 255   Atomic::release_store(adr, k);
 256 
 257   // The interpreter assumes when the tag is stored, the klass is resolved
 258   // and the Klass* non-NULL, so we need hardware store ordering here.
 259   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);
 260   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 261 }
 262 
 263 #if INCLUDE_CDS_JAVA_HEAP
 264 // Archive the resolved references
 265 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 266   if (_cache == NULL) {
 267     return; // nothing to do
 268   }
 269 
 270   InstanceKlass *ik = pool_holder();
 271   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 272         ik-&gt;is_shared_app_class())) {
 273     // Archiving resolved references for classes from non-builtin loaders
 274     // is not yet supported.
 275     set_resolved_references(NULL);
 276     return;
 277   }
 278 
 279   objArrayOop rr = resolved_references();
 280   Array&lt;u2&gt;* ref_map = reference_map();
 281   if (rr != NULL) {
 282     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 283     int rr_len = rr-&gt;length();
 284     for (int i = 0; i &lt; rr_len; i++) {
 285       oop p = rr-&gt;obj_at(i);
 286       rr-&gt;obj_at_put(i, NULL);
 287       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 288         int index = object_to_cp_index(i);
 289         if (tag_at(index).is_string()) {
 290           oop op = StringTable::create_archived_string(p, THREAD);
 291           // If the String object is not archived (possibly too large),
 292           // NULL is returned. Also set it in the array, so we won&#39;t
 293           // have a &#39;bad&#39; reference in the archived resolved_reference
 294           // array.
 295           rr-&gt;obj_at_put(i, op);
 296         }
 297       }
 298     }
 299 
 300     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 301     // If the resolved references array is not archived (too large),
 302     // the &#39;archived&#39; object is NULL. No need to explicitly check
 303     // the return value of archive_heap_object here. At runtime, the
 304     // resolved references will be created using the normal process
 305     // when there is no archived value.
 306     _cache-&gt;set_archived_references(archived);
 307     set_resolved_references(NULL);
 308   }
 309 }
 310 
 311 void ConstantPool::resolve_class_constants(TRAPS) {
 312   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
 313   // The _cache may be NULL if the _pool_holder klass fails verification
 314   // at dump time due to missing dependencies.
 315   if (cache() == NULL || reference_map() == NULL) {
 316     return; // nothing to do
 317   }
 318 
 319   constantPoolHandle cp(THREAD, this);
 320   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 321     if (tag_at(index).is_string() &amp;&amp; !cp-&gt;is_pseudo_string_at(index)) {
 322       int cache_index = cp-&gt;cp_to_object_index(index);
 323       string_at_impl(cp, index, cache_index, CHECK);
 324     }
 325   }
 326 }
 327 #endif
 328 
 329 // CDS support. Create a new resolved_references array.
 330 void ConstantPool::restore_unshareable_info(TRAPS) {
 331   assert(is_constantPool(), &quot;ensure C++ vtable is restored&quot;);
 332   assert(on_stack(), &quot;should always be set for shared constant pools&quot;);
 333   assert(is_shared(), &quot;should always be set for shared constant pools&quot;);
 334   assert(_cache != NULL, &quot;constant pool _cache should not be NULL&quot;);
 335 
 336   // Only create the new resolved references array if it hasn&#39;t been attempted before
 337   if (resolved_references() != NULL) return;
 338 
 339   // restore the C++ vtable from the shared archive
 340   restore_vtable();
 341 
 342   if (SystemDictionary::Object_klass_loaded()) {
 343     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
 344 #if INCLUDE_CDS_JAVA_HEAP
 345     if (HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 346         _cache-&gt;archived_references() != NULL) {
 347       oop archived = _cache-&gt;archived_references();
 348       // Create handle for the archived resolved reference array object
 349       Handle refs_handle(THREAD, archived);
 350       set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 351     } else
 352 #endif
 353     {
 354       // No mapped archived resolved reference array
 355       // Recreate the object array and add to ClassLoaderData.
 356       int map_length = resolved_reference_length();
 357       if (map_length &gt; 0) {
 358         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 359         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 360         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 361       }
 362     }
 363   }
 364 }
 365 
 366 void ConstantPool::remove_unshareable_info() {
 367   // Resolved references are not in the shared archive.
 368   // Save the length for restoration.  It is not necessarily the same length
 369   // as reference_map.length() if invokedynamic is saved. It is needed when
 370   // re-creating the resolved reference array if archived heap data cannot be map
 371   // at runtime.
 372   set_resolved_reference_length(
 373     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 374 
 375   // If archiving heap objects is not allowed, clear the resolved references.
 376   // Otherwise, it is cleared after the resolved references array is cached
 377   // (see archive_resolved_references()).
 378   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 379   // as java objects are not archived in the top layer.
 380   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 381     set_resolved_references(NULL);
 382   }
 383 
 384   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 385   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 386   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 387   // we always set _on_stack to true to avoid having to change _flags during runtime.
 388   _flags |= (_on_stack | _is_shared);
 389   int num_klasses = 0;
 390   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 391     if (!DynamicDumpSharedSpaces) {
 392       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 393     } else {
 394       if (tag_at(index).is_unresolved_klass_in_error() ||
 395           tag_at(index).is_method_handle_in_error()    ||
 396           tag_at(index).is_method_type_in_error()      ||
 397           tag_at(index).is_dynamic_constant_in_error()) {
 398         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 399       }
 400     }
 401     if (tag_at(index).is_klass()) {
 402       // This class was resolved as a side effect of executing Java code
 403       // during dump time. We need to restore it back to an UnresolvedClass,
 404       // so that the proper class loading and initialization can happen
 405       // at runtime.
 406       CPKlassSlot kslot = klass_slot_at(index);
 407       int resolved_klass_index = kslot.resolved_klass_index();
 408       int name_index = kslot.name_index();
 409       assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 410       resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 411       tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 412       assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 413     }
 414   }
 415   if (cache() != NULL) {
 416     cache()-&gt;remove_unshareable_info();
 417   }
 418 }
 419 
 420 int ConstantPool::cp_to_object_index(int cp_index) {
 421   // this is harder don&#39;t do this so much.
 422   int i = reference_map()-&gt;find(cp_index);
 423   // We might not find the index for jsr292 call.
 424   return (i &lt; 0) ? _no_index_sentinel : i;
 425 }
 426 
 427 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 428   resolved_references()-&gt;obj_at_put(obj_index, str);
 429 }
 430 
 431 void ConstantPool::trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k) {
 432   ResourceMark rm;
 433   int line_number = -1;
 434   const char * source_file = NULL;
 435   if (JavaThread::current()-&gt;has_last_Java_frame()) {
 436     // try to identify the method which called this function.
 437     vframeStream vfst(JavaThread::current());
 438     if (!vfst.at_end()) {
 439       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 440       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 441       if (s != NULL) {
 442         source_file = s-&gt;as_C_string();
 443       }
 444     }
 445   }
 446   if (k != this_cp-&gt;pool_holder()) {
 447     // only print something if the classes are different
 448     if (source_file != NULL) {
 449       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 450                  this_cp-&gt;pool_holder()-&gt;external_name(),
 451                  k-&gt;external_name(), source_file, line_number);
 452     } else {
 453       log_debug(class, resolve)(&quot;%s %s&quot;,
 454                  this_cp-&gt;pool_holder()-&gt;external_name(),
 455                  k-&gt;external_name());
 456     }
 457   }
 458 }
 459 
 460 void check_is_inline_type(Klass* k, TRAPS) {
 461   if (!k-&gt;is_value()) {
 462     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
 463   }
 464 }
 465 
 466 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 467                                    bool save_resolution_error, TRAPS) {
 468   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 469   JavaThread* javaThread = (JavaThread*)THREAD;
 470 
 471   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 472   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 473   // the entry and tag is not updated atomicly.
 474   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 475   int resolved_klass_index = kslot.resolved_klass_index();
 476   int name_index = kslot.name_index();
 477   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 478 
 479   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 480   if (klass != NULL) {
 481     return klass;
 482   }
 483 
 484   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 485   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 486     // The original attempt to resolve this constant pool entry failed so find the
 487     // class of the original error and throw another error of the same class
 488     // (JVMS 5.4.3).
 489     // If there is a detail message, pass that detail message to the error.
 490     // The JVMS does not strictly require us to duplicate the same detail message,
 491     // or any internal exception fields such as cause or stacktrace.  But since the
 492     // detail message is often a class name or other literal string, we will repeat it
 493     // if we can find it in the symbol table.
 494     throw_resolution_error(this_cp, which, CHECK_NULL);
 495     ShouldNotReachHere();
 496   }
 497 
 498   Handle mirror_handle;
 499   Symbol* name = this_cp-&gt;symbol_at(name_index);
 500   bool inline_type_signature = false;
 501   if (name-&gt;is_Q_signature()) {
 502     name = name-&gt;fundamental_name(THREAD);
 503     inline_type_signature = true;
 504   }
 505   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 506   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 507 
 508   Klass* k;
 509   {
 510     // Turn off the single stepping while doing class resolution
 511     JvmtiHideSingleStepping jhss(javaThread);
 512     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 513   } //  JvmtiHideSingleStepping jhss(javaThread);
 514   if (inline_type_signature) {
 515     name-&gt;decrement_refcount();
 516   }
 517 
 518   if (!HAS_PENDING_EXCEPTION) {
 519     // preserve the resolved klass from unloading
 520     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 521     // Do access check for klasses
 522     verify_constant_pool_resolve(this_cp, k, THREAD);
 523   }
 524 
 525   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {
 526     check_is_inline_type(k, THREAD);
 527   }
 528 
 529   if (!HAS_PENDING_EXCEPTION) {
 530     Klass* bottom_klass = NULL;
 531     if (k-&gt;is_objArray_klass()) {
 532       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();
 533       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 534       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);
 535     } else if (k-&gt;is_valueArray_klass()) {
 536       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();
 537       assert(bottom_klass != NULL, &quot;Should be set&quot;);
 538     }
 539   }
 540 
 541   // Failed to resolve class. We must record the errors so that subsequent attempts
 542   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 543   if (HAS_PENDING_EXCEPTION) {
 544     if (save_resolution_error) {
 545       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 546       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 547       // some other thread has beaten us and has resolved the class.
 548       // To preserve old behavior, we return the resolved class.
 549       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 550       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 551       return klass;
 552     } else {
 553       return NULL;  // return the pending exception
 554     }
 555   }
 556 
 557   // logging for class+resolve.
 558   if (log_is_enabled(Debug, class, resolve)){
 559     trace_class_resolution(this_cp, k);
 560   }
 561   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 562   Atomic::release_store(adr, k);
 563   // The interpreter assumes when the tag is stored, the klass is resolved
 564   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 565   // hardware store ordering here.
 566   jbyte tag = JVM_CONSTANT_Class;
 567   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {
 568     tag |= JVM_CONSTANT_QDescBit;
 569   }
 570   this_cp-&gt;release_tag_at_put(which, tag);
 571   return k;
 572 }
 573 
 574 
 575 // Does not update ConstantPool* - to avoid any exception throwing. Used
 576 // by compiler and exception handling.  Also used to avoid classloads for
 577 // instanceof operations. Returns NULL if the class has not been loaded or
 578 // if the verification of constant pool failed
 579 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 580   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 581   int resolved_klass_index = kslot.resolved_klass_index();
 582   int name_index = kslot.name_index();
 583   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 584 
 585   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 586   if (k != NULL) {
 587     return k;
 588   } else {
 589     Thread *thread = Thread::current();
 590     Symbol* name = this_cp-&gt;symbol_at(name_index);
 591     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 592     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 593     Handle h_prot (thread, protection_domain);
 594     Handle h_loader (thread, loader);
 595     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 596 
 597     // Avoid constant pool verification at a safepoint, which takes the Module_lock.
 598     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
 599       // Make sure that resolving is legal
 600       EXCEPTION_MARK;
 601       // return NULL if verification fails
 602       verify_constant_pool_resolve(this_cp, k, THREAD);
 603       if (HAS_PENDING_EXCEPTION) {
 604         CLEAR_PENDING_EXCEPTION;
 605         return NULL;
 606       }
 607       return k;
 608     } else {
 609       return k;
 610     }
 611   }
 612 }
 613 
 614 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 615                                                    int which) {
 616   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 617   int cache_index = decode_cpcache_index(which, true);
 618   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
 619     // FIXME: should be an assert
 620     log_debug(class, resolve)(&quot;bad operand %d in:&quot;, which); cpool-&gt;print();
 621     return NULL;
 622   }
 623   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 624   return e-&gt;method_if_resolved(cpool);
 625 }
 626 
 627 
 628 bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 629   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 630   int cache_index = decode_cpcache_index(which, true);
 631   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 632   return e-&gt;has_appendix();
 633 }
 634 
 635 oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 636   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 637   int cache_index = decode_cpcache_index(which, true);
 638   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 639   return e-&gt;appendix_if_resolved(cpool);
 640 }
 641 
 642 
 643 bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 644   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 645   int cache_index = decode_cpcache_index(which, true);
 646   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 647   return e-&gt;has_local_signature();
 648 }
 649 
 650 Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {
 651   int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 652   return symbol_at(name_index);
 653 }
 654 
 655 
 656 Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {
 657   int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 658   return symbol_at(signature_index);
 659 }
 660 
 661 int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {
 662   int i = which;
 663   if (!uncached &amp;&amp; cache() != NULL) {
 664     if (ConstantPool::is_invokedynamic_index(which)) {
 665       // Invokedynamic index is index into the constant pool cache
 666       int pool_index = invokedynamic_bootstrap_ref_index_at(which);
 667       pool_index = bootstrap_name_and_type_ref_index_at(pool_index);
 668       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 669       return pool_index;
 670     }
 671     // change byte-ordering and go via cache
 672     i = remap_instruction_operand_from_cache(which);
 673   } else {
 674     if (tag_at(which).has_bootstrap()) {
 675       int pool_index = bootstrap_name_and_type_ref_index_at(which);
 676       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 677       return pool_index;
 678     }
 679   }
 680   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 681   assert(!tag_at(i).has_bootstrap(), &quot;Must be handled above&quot;);
 682   jint ref_index = *int_at_addr(i);
 683   return extract_high_short_from_int(ref_index);
 684 }
 685 
 686 constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {
 687   int pool_index = which;
 688   if (!uncached &amp;&amp; cache() != NULL) {
 689     if (ConstantPool::is_invokedynamic_index(which)) {
 690       // Invokedynamic index is index into resolved_references
 691       pool_index = invokedynamic_bootstrap_ref_index_at(which);
 692     } else {
 693       // change byte-ordering and go via cache
 694       pool_index = remap_instruction_operand_from_cache(which);
 695     }
 696   }
 697   return tag_at(pool_index);
 698 }
 699 
 700 int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {
 701   guarantee(!ConstantPool::is_invokedynamic_index(which),
 702             &quot;an invokedynamic instruction does not have a klass&quot;);
 703   int i = which;
 704   if (!uncached &amp;&amp; cache() != NULL) {
 705     // change byte-ordering and go via cache
 706     i = remap_instruction_operand_from_cache(which);
 707   }
 708   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 709   jint ref_index = *int_at_addr(i);
 710   return extract_low_short_from_int(ref_index);
 711 }
 712 
 713 
 714 
 715 int ConstantPool::remap_instruction_operand_from_cache(int operand) {
 716   int cpc_index = operand;
 717   DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
 718   assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
 719   int member_index = cache()-&gt;entry_at(cpc_index)-&gt;constant_pool_index();
 720   return member_index;
 721 }
 722 
 723 
 724 void ConstantPool::verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* k, TRAPS) {
 725   if (!(k-&gt;is_instance_klass() || k-&gt;is_objArray_klass())) {
 726     return;  // short cut, typeArray klass is always accessible
 727   }
 728   Klass* holder = this_cp-&gt;pool_holder();
 729   LinkResolver::check_klass_accessibility(holder, k, CHECK);
 730 }
 731 
 732 
 733 int ConstantPool::name_ref_index_at(int which_nt) {
 734   jint ref_index = name_and_type_at(which_nt);
 735   return extract_low_short_from_int(ref_index);
 736 }
 737 
 738 
 739 int ConstantPool::signature_ref_index_at(int which_nt) {
 740   jint ref_index = name_and_type_at(which_nt);
 741   return extract_high_short_from_int(ref_index);
 742 }
 743 
 744 
 745 Klass* ConstantPool::klass_ref_at(int which, TRAPS) {
 746   return klass_at(klass_ref_index_at(which), THREAD);
 747 }
 748 
 749 Symbol* ConstantPool::klass_name_at(int which) const {
 750   return symbol_at(klass_slot_at(which).name_index());
 751 }
 752 
 753 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 754   jint ref_index = klass_ref_index_at(which);
 755   return klass_at_noresolve(ref_index);
 756 }
 757 
 758 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 759   jint ref_index = uncached_klass_ref_index_at(which);
 760   return klass_at_noresolve(ref_index);
 761 }
 762 
 763 char* ConstantPool::string_at_noresolve(int which) {
 764   return unresolved_string_at(which)-&gt;as_C_string();
 765 }
 766 
 767 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
 768   return Signature::basic_type(symbol_at(which));
 769 }
 770 
 771 
 772 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 773   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 774     if (this_cp-&gt;tag_at(index).is_string()) {
 775       this_cp-&gt;string_at(index, CHECK);
 776     }
 777   }
 778 }
 779 
 780 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 781   // Dig out the detailed message to reuse if possible
 782   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 783   if (message != NULL) {
 784     return message;
 785   }
 786 
 787   // Return specific message for the tag
 788   switch (tag.value()) {
 789   case JVM_CONSTANT_UnresolvedClass:
 790     // return the class name in the error message
 791     message = this_cp-&gt;klass_name_at(which);
 792     break;
 793   case JVM_CONSTANT_MethodHandle:
 794     // return the method handle name in the error message
 795     message = this_cp-&gt;method_handle_name_ref_at(which);
 796     break;
 797   case JVM_CONSTANT_MethodType:
 798     // return the method type signature in the error message
 799     message = this_cp-&gt;method_type_signature_at(which);
 800     break;
 801   case JVM_CONSTANT_Dynamic:
 802     // return the name of the condy in the error message
 803     message = this_cp-&gt;uncached_name_ref_at(which);
 804     break;
 805   default:
 806     ShouldNotReachHere();
 807   }
 808 
 809   return message;
 810 }
 811 
 812 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 813   Symbol* message = NULL;
 814   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 815   assert(error != NULL, &quot;checking&quot;);
 816   CLEAR_PENDING_EXCEPTION;
 817   if (message != NULL) {
 818     ResourceMark rm;
 819     THROW_MSG(error, message-&gt;as_C_string());
 820   } else {
 821     THROW(error);
 822   }
 823 }
 824 
 825 // If resolution for Class, Dynamic constant, MethodHandle or MethodType fails, save the
 826 // exception in the resolution error table, so that the same exception is thrown again.
 827 void ConstantPool::save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which,
 828                                             constantTag tag, TRAPS) {
 829   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 830 
 831   int error_tag = tag.error_value();
 832 
 833   if (!PENDING_EXCEPTION-&gt;
 834     is_a(SystemDictionary::LinkageError_klass())) {
 835     // Just throw the exception and don&#39;t prevent these classes from
 836     // being loaded due to virtual machine errors like StackOverflow
 837     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 838     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 839   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 840     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 841     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 842     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 843     // If another thread resolved the reference, this is a race condition. This
 844     // thread may have had a security manager or something temporary.
 845     // This doesn&#39;t deterministically get an error.   So why do we save this?
 846     // We save this because jvmti can add classes to the bootclass path after
 847     // this error, so it needs to get the same error if the error is first.
 848     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),
 849                                     (jbyte)tag.value(),
 850                                     (jbyte)error_tag);
 851     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 852       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 853       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 854       // Forget the exception and use the resolved class.
 855       CLEAR_PENDING_EXCEPTION;
 856     }
 857   } else {
 858     // some other thread put this in error state
 859     throw_resolution_error(this_cp, which, CHECK);
 860   }
 861 }
 862 
 863 constantTag ConstantPool::constant_tag_at(int which) {
 864   constantTag tag = tag_at(which);
 865   if (tag.is_dynamic_constant() ||
 866       tag.is_dynamic_constant_in_error()) {
 867     BasicType bt = basic_type_for_constant_at(which);
 868     // dynamic constant could return an array, treat as object
 869     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 870   }
 871   return tag;
 872 }
 873 
 874 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 875   constantTag tag = tag_at(which);
 876   if (tag.is_dynamic_constant() ||
 877       tag.is_dynamic_constant_in_error()) {
 878     // have to look at the signature for this one
 879     Symbol* constant_type = uncached_signature_ref_at(which);
 880     return Signature::basic_type(constant_type);
 881   }
 882   return tag.basic_type();
 883 }
 884 
 885 // Called to resolve constants in the constant pool and return an oop.
 886 // Some constant pool entries cache their resolved oop. This is also
 887 // called to create oops from constants to use in arguments for invokedynamic
 888 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 889                                            int index, int cache_index,
 890                                            bool* status_return, TRAPS) {
 891   oop result_oop = NULL;
 892   Handle throw_exception;
 893 
 894   if (cache_index == _possible_index_sentinel) {
 895     // It is possible that this constant is one which is cached in the objects.
 896     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 897     // FIXME: If bootstrap specifiers stress this code, consider putting in
 898     // a reverse index.  Binary search over a short array should do it.
 899     assert(index &gt; 0, &quot;valid index&quot;);
 900     cache_index = this_cp-&gt;cp_to_object_index(index);
 901   }
 902   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 903   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 904 
 905   if (cache_index &gt;= 0) {
 906     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 907     if (result_oop != NULL) {
 908       if (result_oop == Universe::the_null_sentinel()) {
 909         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 910         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 911         result_oop = NULL;
 912       }
 913       if (status_return != NULL)  (*status_return) = true;
 914       return result_oop;
 915       // That was easy...
 916     }
 917     index = this_cp-&gt;object_to_cp_index(cache_index);
 918   }
 919 
 920   jvalue prim_value;  // temp used only in a few cases below
 921 
 922   constantTag tag = this_cp-&gt;tag_at(index);
 923 
 924   if (status_return != NULL) {
 925     // don&#39;t trigger resolution if the constant might need it
 926     switch (tag.value()) {
 927     case JVM_CONSTANT_Class:
 928     {
 929       CPKlassSlot kslot = this_cp-&gt;klass_slot_at(index);
 930       int resolved_klass_index = kslot.resolved_klass_index();
 931       if (this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index) == NULL) {
 932         (*status_return) = false;
 933         return NULL;
 934       }
 935       // the klass is waiting in the CP; go get it
 936       break;
 937     }
 938     case JVM_CONSTANT_String:
 939     case JVM_CONSTANT_Integer:
 940     case JVM_CONSTANT_Float:
 941     case JVM_CONSTANT_Long:
 942     case JVM_CONSTANT_Double:
 943       // these guys trigger OOM at worst
 944       break;
 945     default:
 946       (*status_return) = false;
 947       return NULL;
 948     }
 949     // from now on there is either success or an OOME
 950     (*status_return) = true;
 951   }
 952 
 953   switch (tag.value()) {
 954 
 955   case JVM_CONSTANT_UnresolvedClass:
 956   case JVM_CONSTANT_UnresolvedClassInError:
 957   case JVM_CONSTANT_Class:
 958     {
 959       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 960       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 961       // ldc wants the java mirror.
 962       result_oop = resolved-&gt;java_mirror();
 963       break;
 964     }
 965 
 966   case JVM_CONSTANT_Dynamic:
 967     {
 968       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 969       BootstrapInfo bootstrap_specifier(this_cp, index);
 970 
 971       // The initial step in resolving an unresolved symbolic reference to a
 972       // dynamically-computed constant is to resolve the symbolic reference to a
 973       // method handle which will be the bootstrap method for the dynamically-computed
 974       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 975       // method fails, then a MethodHandleInError is stored at the corresponding
 976       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 977       // set a DynamicConstantInError here since any subsequent use of this
 978       // bootstrap method will encounter the resolution of MethodHandleInError.
 979       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 980       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 981       // for the bootstrap_specifier created above.
 982       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
 983       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);
 984       if (HAS_PENDING_EXCEPTION) {
 985         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 986         // will check for a LinkageError and store a DynamicConstantInError.
 987         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 988       }
 989       result_oop = bootstrap_specifier.resolved_value()();
 990       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 991       if (!is_reference_type(type)) {
 992         // Make sure the primitive value is properly boxed.
 993         // This is a JDK responsibility.
 994         const char* fail = NULL;
 995         if (result_oop == NULL) {
 996           fail = &quot;null result instead of box&quot;;
 997         } else if (!is_java_primitive(type)) {
 998           // FIXME: support value types via unboxing
 999           fail = &quot;can only handle references and primitives&quot;;
1000         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
1001           fail = &quot;primitive is not properly boxed&quot;;
1002         }
1003         if (fail != NULL) {
1004           // Since this exception is not a LinkageError, throw exception
1005           // but do not save a DynamicInError resolution result.
1006           // See section 5.4.3 of the VM spec.
1007           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
1008         }
1009       }
1010 
1011       LogTarget(Debug, methodhandles, condy) lt_condy;
1012       if (lt_condy.is_enabled()) {
1013         LogStream ls(lt_condy);
1014         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);
1015       }
1016       break;
1017     }
1018 
1019   case JVM_CONSTANT_String:
1020     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1021     if (this_cp-&gt;is_pseudo_string_at(index)) {
1022       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1023       break;
1024     }
1025     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1026     break;
1027 
1028   case JVM_CONSTANT_DynamicInError:
1029   case JVM_CONSTANT_MethodHandleInError:
1030   case JVM_CONSTANT_MethodTypeInError:
1031     {
1032       throw_resolution_error(this_cp, index, CHECK_NULL);
1033       break;
1034     }
1035 
1036   case JVM_CONSTANT_MethodHandle:
1037     {
1038       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
1039       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1040       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1041       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1042       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1043       { ResourceMark rm(THREAD);
1044         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1045                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1046                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1047       }
1048 
1049       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1050 
1051       // Check constant pool method consistency
1052       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1053           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1054         ResourceMark rm(THREAD);
1055         stringStream ss;
1056         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;
1057                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());
1058         signature-&gt;print_as_signature_external_return_type(&amp;ss);
1059         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());
1060         signature-&gt;print_as_signature_external_parameters(&amp;ss);
1061         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,
1062                  index,
1063                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,
1064                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);
1065         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1066       }
1067 
1068       Klass* klass = this_cp-&gt;pool_holder();
1069       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1070                                                                    callee, name, signature,
1071                                                                    THREAD);
1072       result_oop = value();
1073       if (HAS_PENDING_EXCEPTION) {
1074         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1075       }
1076       break;
1077     }
1078 
1079   case JVM_CONSTANT_MethodType:
1080     {
1081       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1082       { ResourceMark rm(THREAD);
1083         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1084                               index, this_cp-&gt;method_type_index_at(index),
1085                               signature-&gt;as_C_string());
1086       }
1087       Klass* klass = this_cp-&gt;pool_holder();
1088       Handle value = SystemDictionary::find_method_handle_type(signature, klass, THREAD);
1089       result_oop = value();
1090       if (HAS_PENDING_EXCEPTION) {
1091         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1092       }
1093       break;
1094     }
1095 
1096   case JVM_CONSTANT_Integer:
1097     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1098     prim_value.i = this_cp-&gt;int_at(index);
1099     result_oop = java_lang_boxing_object::create(T_INT, &amp;prim_value, CHECK_NULL);
1100     break;
1101 
1102   case JVM_CONSTANT_Float:
1103     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1104     prim_value.f = this_cp-&gt;float_at(index);
1105     result_oop = java_lang_boxing_object::create(T_FLOAT, &amp;prim_value, CHECK_NULL);
1106     break;
1107 
1108   case JVM_CONSTANT_Long:
1109     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1110     prim_value.j = this_cp-&gt;long_at(index);
1111     result_oop = java_lang_boxing_object::create(T_LONG, &amp;prim_value, CHECK_NULL);
1112     break;
1113 
1114   case JVM_CONSTANT_Double:
1115     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1116     prim_value.d = this_cp-&gt;double_at(index);
1117     result_oop = java_lang_boxing_object::create(T_DOUBLE, &amp;prim_value, CHECK_NULL);
1118     break;
1119 
1120   default:
1121     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1122                               this_cp(), index, cache_index, tag.value()));
1123     assert(false, &quot;unexpected constant tag&quot;);
1124     break;
1125   }
1126 
1127   if (cache_index &gt;= 0) {
1128     // Benign race condition:  resolved_references may already be filled in.
1129     // The important thing here is that all threads pick up the same result.
1130     // It doesn&#39;t matter which racing thread wins, as long as only one
1131     // result is used by all threads, and all future queries.
1132     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1133     oop old_result = this_cp-&gt;resolved_references()
1134       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1135     if (old_result == NULL) {
1136       return result_oop;  // was installed
1137     } else {
1138       // Return the winning thread&#39;s result.  This can be different than
1139       // the result here for MethodHandles.
1140       if (old_result == Universe::the_null_sentinel())
1141         old_result = NULL;
1142       return old_result;
1143     }
1144   } else {
1145     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);
1146     return result_oop;
1147   }
1148 }
1149 
1150 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1151   Symbol* sym = unresolved_string_at(which);
1152   oop str = StringTable::intern(sym, CHECK_(NULL));
1153   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1154   return str;
1155 }
1156 
1157 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1158                                                     int start_arg, int end_arg,
1159                                                     objArrayHandle info, int pos,
1160                                                     bool must_resolve, Handle if_not_available,
1161                                                     TRAPS) {
1162   int argc;
1163   int limit = pos + end_arg - start_arg;
1164   // checks: index in range [0..this_cp-&gt;length),
1165   // tag at index, start..end in range [0..argc],
1166   // info array non-null, pos..limit in [0..info.length]
1167   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1168       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1169         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1170       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1171       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1172       (0 &gt; pos       || pos &gt; limit)         ||
1173       (info.is_null() || limit &gt; info-&gt;length())) {
1174     // An index or something else went wrong; throw an error.
1175     // Since this is an internal API, we don&#39;t expect this,
1176     // so we don&#39;t bother to craft a nice message.
1177     THROW_MSG(vmSymbols::java_lang_LinkageError(), &quot;bad BSM argument access&quot;);
1178   }
1179   // now we can loop safely
1180   int info_i = pos;
1181   for (int i = start_arg; i &lt; end_arg; i++) {
1182     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1183     oop arg_oop;
1184     if (must_resolve) {
1185       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1186     } else {
1187       bool found_it = false;
1188       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1189       if (!found_it)  arg_oop = if_not_available();
1190     }
1191     info-&gt;obj_at_put(info_i++, arg_oop);
1192   }
1193 }
1194 
1195 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1196   // If the string has already been interned, this entry will be non-null
1197   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
1198   assert(str != Universe::the_null_sentinel(), &quot;&quot;);
1199   if (str != NULL) return str;
1200   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1201   str = StringTable::intern(sym, CHECK_(NULL));
1202   this_cp-&gt;string_at_put(which, obj_index, str);
1203   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1204   return str;
1205 }
1206 
1207 
1208 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1209   // Names are interned, so we can compare Symbol*s directly
1210   Symbol* cp_name = klass_name_at(which);
1211   return (cp_name == k-&gt;name());
1212 }
1213 
1214 
1215 // Iterate over symbols and decrement ones which are Symbol*s
1216 // This is done during GC.
1217 // Only decrement the UTF8 symbols. Strings point to
1218 // these symbols but didn&#39;t increment the reference count.
1219 void ConstantPool::unreference_symbols() {
1220   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
1221     constantTag tag = tag_at(index);
1222     if (tag.is_symbol()) {
1223       symbol_at(index)-&gt;decrement_refcount();
1224     }
1225   }
1226 }
1227 
1228 
1229 // Compare this constant pool&#39;s entry at index1 to the constant pool
1230 // cp2&#39;s entry at index2.
1231 bool ConstantPool::compare_entry_to(int index1, const constantPoolHandle&amp; cp2,
1232        int index2, TRAPS) {
1233 
1234   // The error tags are equivalent to non-error tags when comparing
1235   jbyte t1 = tag_at(index1).non_error_value();
1236   jbyte t2 = cp2-&gt;tag_at(index2).non_error_value();
1237 
1238   if (t1 != t2) {
1239     // Not the same entry type so there is nothing else to check. Note
1240     // that this style of checking will consider resolved/unresolved
1241     // class pairs as different.
1242     // From the ConstantPool* API point of view, this is correct
1243     // behavior. See VM_RedefineClasses::merge_constant_pools() to see how this
1244     // plays out in the context of ConstantPool* merging.
1245     return false;
1246   }
1247 
1248   switch (t1) {
1249   case JVM_CONSTANT_Class:
1250   {
1251     Klass* k1 = klass_at(index1, CHECK_false);
1252     Klass* k2 = cp2-&gt;klass_at(index2, CHECK_false);
1253     if (k1 == k2) {
1254       return true;
1255     }
1256   } break;
1257 
1258   case JVM_CONSTANT_ClassIndex:
1259   {
1260     int recur1 = klass_index_at(index1);
1261     int recur2 = cp2-&gt;klass_index_at(index2);
1262     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1263     if (match) {
1264       return true;
1265     }
1266   } break;
1267 
1268   case JVM_CONSTANT_Double:
1269   {
1270     jdouble d1 = double_at(index1);
1271     jdouble d2 = cp2-&gt;double_at(index2);
1272     if (d1 == d2) {
1273       return true;
1274     }
1275   } break;
1276 
1277   case JVM_CONSTANT_Fieldref:
1278   case JVM_CONSTANT_InterfaceMethodref:
1279   case JVM_CONSTANT_Methodref:
1280   {
1281     int recur1 = uncached_klass_ref_index_at(index1);
1282     int recur2 = cp2-&gt;uncached_klass_ref_index_at(index2);
1283     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1284     if (match) {
1285       recur1 = uncached_name_and_type_ref_index_at(index1);
1286       recur2 = cp2-&gt;uncached_name_and_type_ref_index_at(index2);
1287       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1288       if (match) {
1289         return true;
1290       }
1291     }
1292   } break;
1293 
1294   case JVM_CONSTANT_Float:
1295   {
1296     jfloat f1 = float_at(index1);
1297     jfloat f2 = cp2-&gt;float_at(index2);
1298     if (f1 == f2) {
1299       return true;
1300     }
1301   } break;
1302 
1303   case JVM_CONSTANT_Integer:
1304   {
1305     jint i1 = int_at(index1);
1306     jint i2 = cp2-&gt;int_at(index2);
1307     if (i1 == i2) {
1308       return true;
1309     }
1310   } break;
1311 
1312   case JVM_CONSTANT_Long:
1313   {
1314     jlong l1 = long_at(index1);
1315     jlong l2 = cp2-&gt;long_at(index2);
1316     if (l1 == l2) {
1317       return true;
1318     }
1319   } break;
1320 
1321   case JVM_CONSTANT_NameAndType:
1322   {
1323     int recur1 = name_ref_index_at(index1);
1324     int recur2 = cp2-&gt;name_ref_index_at(index2);
1325     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1326     if (match) {
1327       recur1 = signature_ref_index_at(index1);
1328       recur2 = cp2-&gt;signature_ref_index_at(index2);
1329       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1330       if (match) {
1331         return true;
1332       }
1333     }
1334   } break;
1335 
1336   case JVM_CONSTANT_StringIndex:
1337   {
1338     int recur1 = string_index_at(index1);
1339     int recur2 = cp2-&gt;string_index_at(index2);
1340     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1341     if (match) {
1342       return true;
1343     }
1344   } break;
1345 
1346   case JVM_CONSTANT_UnresolvedClass:
1347   {
1348     Symbol* k1 = klass_name_at(index1);
1349     Symbol* k2 = cp2-&gt;klass_name_at(index2);
1350     if (k1 == k2) {
1351       return true;
1352     }
1353   } break;
1354 
1355   case JVM_CONSTANT_MethodType:
1356   {
1357     int k1 = method_type_index_at(index1);
1358     int k2 = cp2-&gt;method_type_index_at(index2);
1359     bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1360     if (match) {
1361       return true;
1362     }
1363   } break;
1364 
1365   case JVM_CONSTANT_MethodHandle:
1366   {
1367     int k1 = method_handle_ref_kind_at(index1);
1368     int k2 = cp2-&gt;method_handle_ref_kind_at(index2);
1369     if (k1 == k2) {
1370       int i1 = method_handle_index_at(index1);
1371       int i2 = cp2-&gt;method_handle_index_at(index2);
1372       bool match = compare_entry_to(i1, cp2, i2, CHECK_false);
1373       if (match) {
1374         return true;
1375       }
1376     }
1377   } break;
1378 
1379   case JVM_CONSTANT_Dynamic:
1380   {
1381     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1382     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1383     int i1 = bootstrap_methods_attribute_index(index1);
1384     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1385     // separate statements and variables because CHECK_false is used
1386     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1387     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1388     return (match_entry &amp;&amp; match_operand);
1389   } break;
1390 
1391   case JVM_CONSTANT_InvokeDynamic:
1392   {
1393     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1394     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1395     int i1 = bootstrap_methods_attribute_index(index1);
1396     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1397     // separate statements and variables because CHECK_false is used
1398     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1399     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1400     return (match_entry &amp;&amp; match_operand);
1401   } break;
1402 
1403   case JVM_CONSTANT_String:
1404   {
1405     Symbol* s1 = unresolved_string_at(index1);
1406     Symbol* s2 = cp2-&gt;unresolved_string_at(index2);
1407     if (s1 == s2) {
1408       return true;
1409     }
1410   } break;
1411 
1412   case JVM_CONSTANT_Utf8:
1413   {
1414     Symbol* s1 = symbol_at(index1);
1415     Symbol* s2 = cp2-&gt;symbol_at(index2);
1416     if (s1 == s2) {
1417       return true;
1418     }
1419   } break;
1420 
1421   // Invalid is used as the tag for the second constant pool entry
1422   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1423   // not be seen by itself.
1424   case JVM_CONSTANT_Invalid: // fall through
1425 
1426   default:
1427     ShouldNotReachHere();
1428     break;
1429   }
1430 
1431   return false;
1432 } // end compare_entry_to()
1433 
1434 
1435 // Resize the operands array with delta_len and delta_size.
1436 // Used in RedefineClasses for CP merge.
1437 void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {
1438   int old_len  = operand_array_length(operands());
1439   int new_len  = old_len + delta_len;
1440   int min_len  = (delta_len &gt; 0) ? old_len : new_len;
1441 
1442   int old_size = operands()-&gt;length();
1443   int new_size = old_size + delta_size;
1444   int min_size = (delta_size &gt; 0) ? old_size : new_size;
1445 
1446   ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1447   Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, new_size, CHECK);
1448 
1449   // Set index in the resized array for existing elements only
1450   for (int idx = 0; idx &lt; min_len; idx++) {
1451     int offset = operand_offset_at(idx);                       // offset in original array
1452     operand_offset_at_put(new_ops, idx, offset + 2*delta_len); // offset in resized array
1453   }
1454   // Copy the bootstrap specifiers only
1455   Copy::conjoint_memory_atomic(operands()-&gt;adr_at(2*old_len),
1456                                new_ops-&gt;adr_at(2*new_len),
1457                                (min_size - 2*min_len) * sizeof(u2));
1458   // Explicitly deallocate old operands array.
1459   // Note, it is not needed for 7u backport.
1460   if ( operands() != NULL) { // the safety check
1461     MetadataFactory::free_array&lt;u2&gt;(loader_data, operands());
1462   }
1463   set_operands(new_ops);
1464 } // end resize_operands()
1465 
1466 
1467 // Extend the operands array with the length and size of the ext_cp operands.
1468 // Used in RedefineClasses for CP merge.
1469 void ConstantPool::extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS) {
1470   int delta_len = operand_array_length(ext_cp-&gt;operands());
1471   if (delta_len == 0) {
1472     return; // nothing to do
1473   }
1474   int delta_size = ext_cp-&gt;operands()-&gt;length();
1475 
1476   assert(delta_len  &gt; 0 &amp;&amp; delta_size &gt; 0, &quot;extended operands array must be bigger&quot;);
1477 
1478   if (operand_array_length(operands()) == 0) {
1479     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1480     Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, delta_size, CHECK);
1481     // The first element index defines the offset of second part
1482     operand_offset_at_put(new_ops, 0, 2*delta_len); // offset in new array
1483     set_operands(new_ops);
1484   } else {
1485     resize_operands(delta_len, delta_size, CHECK);
1486   }
1487 
1488 } // end extend_operands()
1489 
1490 
1491 // Shrink the operands array to a smaller array with new_len length.
1492 // Used in RedefineClasses for CP merge.
1493 void ConstantPool::shrink_operands(int new_len, TRAPS) {
1494   int old_len = operand_array_length(operands());
1495   if (new_len == old_len) {
1496     return; // nothing to do
1497   }
1498   assert(new_len &lt; old_len, &quot;shrunken operands array must be smaller&quot;);
1499 
1500   int free_base  = operand_next_offset_at(new_len - 1);
1501   int delta_len  = new_len - old_len;
1502   int delta_size = 2*delta_len + free_base - operands()-&gt;length();
1503 
1504   resize_operands(delta_len, delta_size, CHECK);
1505 
1506 } // end shrink_operands()
1507 
1508 
1509 void ConstantPool::copy_operands(const constantPoolHandle&amp; from_cp,
1510                                  const constantPoolHandle&amp; to_cp,
1511                                  TRAPS) {
1512 
1513   int from_oplen = operand_array_length(from_cp-&gt;operands());
1514   int old_oplen  = operand_array_length(to_cp-&gt;operands());
1515   if (from_oplen != 0) {
1516     ClassLoaderData* loader_data = to_cp-&gt;pool_holder()-&gt;class_loader_data();
1517     // append my operands to the target&#39;s operands array
1518     if (old_oplen == 0) {
1519       // Can&#39;t just reuse from_cp&#39;s operand list because of deallocation issues
1520       int len = from_cp-&gt;operands()-&gt;length();
1521       Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, len, CHECK);
1522       Copy::conjoint_memory_atomic(
1523           from_cp-&gt;operands()-&gt;adr_at(0), new_ops-&gt;adr_at(0), len * sizeof(u2));
1524       to_cp-&gt;set_operands(new_ops);
1525     } else {
1526       int old_len  = to_cp-&gt;operands()-&gt;length();
1527       int from_len = from_cp-&gt;operands()-&gt;length();
1528       int old_off  = old_oplen * sizeof(u2);
1529       int from_off = from_oplen * sizeof(u2);
1530       // Use the metaspace for the destination constant pool
1531       Array&lt;u2&gt;* new_operands = MetadataFactory::new_array&lt;u2&gt;(loader_data, old_len + from_len, CHECK);
1532       int fillp = 0, len = 0;
1533       // first part of dest
1534       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(0),
1535                                    new_operands-&gt;adr_at(fillp),
1536                                    (len = old_off) * sizeof(u2));
1537       fillp += len;
1538       // first part of src
1539       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(0),
1540                                    new_operands-&gt;adr_at(fillp),
1541                                    (len = from_off) * sizeof(u2));
1542       fillp += len;
1543       // second part of dest
1544       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(old_off),
1545                                    new_operands-&gt;adr_at(fillp),
1546                                    (len = old_len - old_off) * sizeof(u2));
1547       fillp += len;
1548       // second part of src
1549       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(from_off),
1550                                    new_operands-&gt;adr_at(fillp),
1551                                    (len = from_len - from_off) * sizeof(u2));
1552       fillp += len;
1553       assert(fillp == new_operands-&gt;length(), &quot;&quot;);
1554 
1555       // Adjust indexes in the first part of the copied operands array.
1556       for (int j = 0; j &lt; from_oplen; j++) {
1557         int offset = operand_offset_at(new_operands, old_oplen + j);
1558         assert(offset == operand_offset_at(from_cp-&gt;operands(), j), &quot;correct copy&quot;);
1559         offset += old_len;  // every new tuple is preceded by old_len extra u2&#39;s
1560         operand_offset_at_put(new_operands, old_oplen + j, offset);
1561       }
1562 
1563       // replace target operands array with combined array
1564       to_cp-&gt;set_operands(new_operands);
1565     }
1566   }
1567 } // end copy_operands()
1568 
1569 
1570 // Copy this constant pool&#39;s entries at start_i to end_i (inclusive)
1571 // to the constant pool to_cp&#39;s entries starting at to_i. A total of
1572 // (end_i - start_i) + 1 entries are copied.
1573 void ConstantPool::copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i,
1574        const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
1575 
1576 
1577   int dest_i = to_i;  // leave original alone for debug purposes
1578 
1579   for (int src_i = start_i; src_i &lt;= end_i; /* see loop bottom */ ) {
1580     copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);
1581 
1582     switch (from_cp-&gt;tag_at(src_i).value()) {
1583     case JVM_CONSTANT_Double:
1584     case JVM_CONSTANT_Long:
1585       // double and long take two constant pool entries
1586       src_i += 2;
1587       dest_i += 2;
1588       break;
1589 
1590     default:
1591       // all others take one constant pool entry
1592       src_i++;
1593       dest_i++;
1594       break;
1595     }
1596   }
1597   copy_operands(from_cp, to_cp, CHECK);
1598 
1599 } // end copy_cp_to_impl()
1600 
1601 
1602 // Copy this constant pool&#39;s entry at from_i to the constant pool
1603 // to_cp&#39;s entry at to_i.
1604 void ConstantPool::copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i,
1605                                         const constantPoolHandle&amp; to_cp, int to_i,
1606                                         TRAPS) {
1607 
1608   int tag = from_cp-&gt;tag_at(from_i).value();
1609   switch (tag) {
1610   case JVM_CONSTANT_ClassIndex:
1611   {
1612     jint ki = from_cp-&gt;klass_index_at(from_i);
1613     to_cp-&gt;klass_index_at_put(to_i, ki);
1614   } break;
1615 
1616   case JVM_CONSTANT_Double:
1617   {
1618     jdouble d = from_cp-&gt;double_at(from_i);
1619     to_cp-&gt;double_at_put(to_i, d);
1620     // double takes two constant pool entries so init second entry&#39;s tag
1621     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1622   } break;
1623 
1624   case JVM_CONSTANT_Fieldref:
1625   {
1626     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1627     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1628     to_cp-&gt;field_at_put(to_i, class_index, name_and_type_index);
1629   } break;
1630 
1631   case JVM_CONSTANT_Float:
1632   {
1633     jfloat f = from_cp-&gt;float_at(from_i);
1634     to_cp-&gt;float_at_put(to_i, f);
1635   } break;
1636 
1637   case JVM_CONSTANT_Integer:
1638   {
1639     jint i = from_cp-&gt;int_at(from_i);
1640     to_cp-&gt;int_at_put(to_i, i);
1641   } break;
1642 
1643   case JVM_CONSTANT_InterfaceMethodref:
1644   {
1645     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1646     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1647     to_cp-&gt;interface_method_at_put(to_i, class_index, name_and_type_index);
1648   } break;
1649 
1650   case JVM_CONSTANT_Long:
1651   {
1652     jlong l = from_cp-&gt;long_at(from_i);
1653     to_cp-&gt;long_at_put(to_i, l);
1654     // long takes two constant pool entries so init second entry&#39;s tag
1655     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1656   } break;
1657 
1658   case JVM_CONSTANT_Methodref:
1659   {
1660     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1661     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1662     to_cp-&gt;method_at_put(to_i, class_index, name_and_type_index);
1663   } break;
1664 
1665   case JVM_CONSTANT_NameAndType:
1666   {
1667     int name_ref_index = from_cp-&gt;name_ref_index_at(from_i);
1668     int signature_ref_index = from_cp-&gt;signature_ref_index_at(from_i);
1669     to_cp-&gt;name_and_type_at_put(to_i, name_ref_index, signature_ref_index);
1670   } break;
1671 
1672   case JVM_CONSTANT_StringIndex:
1673   {
1674     jint si = from_cp-&gt;string_index_at(from_i);
1675     to_cp-&gt;string_index_at_put(to_i, si);
1676   } break;
1677 
1678   case JVM_CONSTANT_Class:
1679   case JVM_CONSTANT_UnresolvedClass:
1680   case JVM_CONSTANT_UnresolvedClassInError:
1681   {
1682     // Revert to JVM_CONSTANT_ClassIndex
1683     int name_index = from_cp-&gt;klass_slot_at(from_i).name_index();
1684     assert(from_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
1685     to_cp-&gt;klass_index_at_put(to_i, name_index);
1686   } break;
1687 
1688   case JVM_CONSTANT_String:
1689   {
1690     Symbol* s = from_cp-&gt;unresolved_string_at(from_i);
1691     to_cp-&gt;unresolved_string_at_put(to_i, s);
1692   } break;
1693 
1694   case JVM_CONSTANT_Utf8:
1695   {
1696     Symbol* s = from_cp-&gt;symbol_at(from_i);
1697     // Need to increase refcount, the old one will be thrown away and deferenced
1698     s-&gt;increment_refcount();
1699     to_cp-&gt;symbol_at_put(to_i, s);
1700   } break;
1701 
1702   case JVM_CONSTANT_MethodType:
1703   case JVM_CONSTANT_MethodTypeInError:
1704   {
1705     jint k = from_cp-&gt;method_type_index_at(from_i);
1706     to_cp-&gt;method_type_index_at_put(to_i, k);
1707   } break;
1708 
1709   case JVM_CONSTANT_MethodHandle:
1710   case JVM_CONSTANT_MethodHandleInError:
1711   {
1712     int k1 = from_cp-&gt;method_handle_ref_kind_at(from_i);
1713     int k2 = from_cp-&gt;method_handle_index_at(from_i);
1714     to_cp-&gt;method_handle_index_at_put(to_i, k1, k2);
1715   } break;
1716 
1717   case JVM_CONSTANT_Dynamic:
1718   case JVM_CONSTANT_DynamicInError:
1719   {
1720     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1721     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1722     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1723     to_cp-&gt;dynamic_constant_at_put(to_i, k1, k2);
1724   } break;
1725 
1726   case JVM_CONSTANT_InvokeDynamic:
1727   {
1728     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1729     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1730     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1731     to_cp-&gt;invoke_dynamic_at_put(to_i, k1, k2);
1732   } break;
1733 
1734   // Invalid is used as the tag for the second constant pool entry
1735   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1736   // not be seen by itself.
1737   case JVM_CONSTANT_Invalid: // fall through
1738 
1739   default:
1740   {
1741     ShouldNotReachHere();
1742   } break;
1743   }
1744 } // end copy_entry_to()
1745 
1746 // Search constant pool search_cp for an entry that matches this
1747 // constant pool&#39;s entry at pattern_i. Returns the index of a
1748 // matching entry or zero (0) if there is no matching entry.
1749 int ConstantPool::find_matching_entry(int pattern_i,
1750       const constantPoolHandle&amp; search_cp, TRAPS) {
1751 
1752   // index zero (0) is not used
1753   for (int i = 1; i &lt; search_cp-&gt;length(); i++) {
1754     bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);
1755     if (found) {
1756       return i;
1757     }
1758   }
1759 
1760   return 0;  // entry not found; return unused index zero (0)
1761 } // end find_matching_entry()
1762 
1763 
1764 // Compare this constant pool&#39;s bootstrap specifier at idx1 to the constant pool
1765 // cp2&#39;s bootstrap specifier at idx2.
1766 bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle&amp; cp2, int idx2, TRAPS) {
1767   int k1 = operand_bootstrap_method_ref_index_at(idx1);
1768   int k2 = cp2-&gt;operand_bootstrap_method_ref_index_at(idx2);
1769   bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1770 
1771   if (!match) {
1772     return false;
1773   }
1774   int argc = operand_argument_count_at(idx1);
1775   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1776     for (int j = 0; j &lt; argc; j++) {
1777       k1 = operand_argument_index_at(idx1, j);
1778       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1779       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1780       if (!match) {
1781         return false;
1782       }
1783     }
1784     return true;           // got through loop; all elements equal
1785   }
1786   return false;
1787 } // end compare_operand_to()
1788 
1789 // Search constant pool search_cp for a bootstrap specifier that matches
1790 // this constant pool&#39;s bootstrap specifier data at pattern_i index.
1791 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.
1792 int ConstantPool::find_matching_operand(int pattern_i,
1793                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1794   for (int i = 0; i &lt; search_len; i++) {
1795     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1796     if (found) {
1797       return i;
1798     }
1799   }
1800   return -1;  // bootstrap specifier data not found; return unused index (-1)
1801 } // end find_matching_operand()
1802 
1803 
1804 #ifndef PRODUCT
1805 
1806 const char* ConstantPool::printable_name_at(int which) {
1807 
1808   constantTag tag = tag_at(which);
1809 
1810   if (tag.is_string()) {
1811     return string_at_noresolve(which);
1812   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1813     return klass_name_at(which)-&gt;as_C_string();
1814   } else if (tag.is_symbol()) {
1815     return symbol_at(which)-&gt;as_C_string();
1816   }
1817   return &quot;&quot;;
1818 }
1819 
1820 #endif // PRODUCT
1821 
1822 
1823 // JVMTI GetConstantPool support
1824 
1825 // For debugging of constant pool
1826 const bool debug_cpool = false;
1827 
1828 #define DBG(code) do { if (debug_cpool) { (code); } } while(0)
1829 
1830 static void print_cpool_bytes(jint cnt, u1 *bytes) {
1831   const char* WARN_MSG = &quot;Must not be such entry!&quot;;
1832   jint size = 0;
1833   u2   idx1, idx2;
1834 
1835   for (jint idx = 1; idx &lt; cnt; idx++) {
1836     jint ent_size = 0;
1837     u1   tag  = *bytes++;
1838     size++;                       // count tag
1839 
1840     printf(&quot;const #%03d, tag: %02d &quot;, idx, tag);
1841     switch(tag) {
1842       case JVM_CONSTANT_Invalid: {
1843         printf(&quot;Invalid&quot;);
1844         break;
1845       }
1846       case JVM_CONSTANT_Unicode: {
1847         printf(&quot;Unicode      %s&quot;, WARN_MSG);
1848         break;
1849       }
1850       case JVM_CONSTANT_Utf8: {
1851         u2 len = Bytes::get_Java_u2(bytes);
1852         char str[128];
1853         if (len &gt; 127) {
1854            len = 127;
1855         }
1856         strncpy(str, (char *) (bytes+2), len);
1857         str[len] = &#39;\0&#39;;
1858         printf(&quot;Utf8          \&quot;%s\&quot;&quot;, str);
1859         ent_size = 2 + len;
1860         break;
1861       }
1862       case JVM_CONSTANT_Integer: {
1863         u4 val = Bytes::get_Java_u4(bytes);
1864         printf(&quot;int          %d&quot;, *(int *) &amp;val);
1865         ent_size = 4;
1866         break;
1867       }
1868       case JVM_CONSTANT_Float: {
1869         u4 val = Bytes::get_Java_u4(bytes);
1870         printf(&quot;float        %5.3ff&quot;, *(float *) &amp;val);
1871         ent_size = 4;
1872         break;
1873       }
1874       case JVM_CONSTANT_Long: {
1875         u8 val = Bytes::get_Java_u8(bytes);
1876         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1877         ent_size = 8;
1878         idx++; // Long takes two cpool slots
1879         break;
1880       }
1881       case JVM_CONSTANT_Double: {
1882         u8 val = Bytes::get_Java_u8(bytes);
1883         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1884         ent_size = 8;
1885         idx++; // Double takes two cpool slots
1886         break;
1887       }
1888       case JVM_CONSTANT_Class: {
1889         idx1 = Bytes::get_Java_u2(bytes);
1890         printf(&quot;class        #%03d&quot;, idx1);
1891         ent_size = 2;
1892         break;
1893       }
1894       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {
1895         idx1 = Bytes::get_Java_u2(bytes);
1896         printf(&quot;qclass        #%03d&quot;, idx1);
1897         ent_size = 2;
1898         break;
1899       }
1900       case JVM_CONSTANT_String: {
1901         idx1 = Bytes::get_Java_u2(bytes);
1902         printf(&quot;String       #%03d&quot;, idx1);
1903         ent_size = 2;
1904         break;
1905       }
1906       case JVM_CONSTANT_Fieldref: {
1907         idx1 = Bytes::get_Java_u2(bytes);
1908         idx2 = Bytes::get_Java_u2(bytes+2);
1909         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1910         ent_size = 4;
1911         break;
1912       }
1913       case JVM_CONSTANT_Methodref: {
1914         idx1 = Bytes::get_Java_u2(bytes);
1915         idx2 = Bytes::get_Java_u2(bytes+2);
1916         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1917         ent_size = 4;
1918         break;
1919       }
1920       case JVM_CONSTANT_InterfaceMethodref: {
1921         idx1 = Bytes::get_Java_u2(bytes);
1922         idx2 = Bytes::get_Java_u2(bytes+2);
1923         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1924         ent_size = 4;
1925         break;
1926       }
1927       case JVM_CONSTANT_NameAndType: {
1928         idx1 = Bytes::get_Java_u2(bytes);
1929         idx2 = Bytes::get_Java_u2(bytes+2);
1930         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1931         ent_size = 4;
1932         break;
1933       }
1934       case JVM_CONSTANT_ClassIndex: {
1935         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1936         break;
1937       }
1938       case JVM_CONSTANT_UnresolvedClass: {
1939         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1940         break;
1941       }
1942       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {
1943         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);
1944         break;
1945       }
1946       case JVM_CONSTANT_UnresolvedClassInError: {
1947         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1948         break;
1949       }
1950       case JVM_CONSTANT_StringIndex: {
1951         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1952         break;
1953       }
1954     }
1955     printf(&quot;;\n&quot;);
1956     bytes += ent_size;
1957     size  += ent_size;
1958   }
1959   printf(&quot;Cpool size: %d\n&quot;, size);
1960   fflush(0);
1961   return;
1962 } /* end print_cpool_bytes */
1963 
1964 
1965 // Returns size of constant pool entry.
1966 jint ConstantPool::cpool_entry_size(jint idx) {
1967   switch(tag_at(idx).value()) {
1968     case JVM_CONSTANT_Invalid:
1969     case JVM_CONSTANT_Unicode:
1970       return 1;
1971 
1972     case JVM_CONSTANT_Utf8:
1973       return 3 + symbol_at(idx)-&gt;utf8_length();
1974 
1975     case JVM_CONSTANT_Class:
1976     case JVM_CONSTANT_String:
1977     case JVM_CONSTANT_ClassIndex:
1978     case JVM_CONSTANT_UnresolvedClass:
1979     case JVM_CONSTANT_UnresolvedClassInError:
1980     case JVM_CONSTANT_StringIndex:
1981     case JVM_CONSTANT_MethodType:
1982     case JVM_CONSTANT_MethodTypeInError:
1983       return 3;
1984 
1985     case JVM_CONSTANT_MethodHandle:
1986     case JVM_CONSTANT_MethodHandleInError:
1987       return 4; //tag, ref_kind, ref_index
1988 
1989     case JVM_CONSTANT_Integer:
1990     case JVM_CONSTANT_Float:
1991     case JVM_CONSTANT_Fieldref:
1992     case JVM_CONSTANT_Methodref:
1993     case JVM_CONSTANT_InterfaceMethodref:
1994     case JVM_CONSTANT_NameAndType:
1995       return 5;
1996 
1997     case JVM_CONSTANT_Dynamic:
1998     case JVM_CONSTANT_DynamicInError:
1999     case JVM_CONSTANT_InvokeDynamic:
2000       // u1 tag, u2 bsm, u2 nt
2001       return 5;
2002 
2003     case JVM_CONSTANT_Long:
2004     case JVM_CONSTANT_Double:
2005       return 9;
2006   }
2007   assert(false, &quot;cpool_entry_size: Invalid constant pool entry tag&quot;);
2008   return 1;
2009 } /* end cpool_entry_size */
2010 
2011 
2012 // SymbolHashMap is used to find a constant pool index from a string.
2013 // This function fills in SymbolHashMaps, one for utf8s and one for
2014 // class names, returns size of the cpool raw bytes.
2015 jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,
2016                                           SymbolHashMap *classmap) {
2017   jint size = 0;
2018 
2019   for (u2 idx = 1; idx &lt; length(); idx++) {
2020     u2 tag = tag_at(idx).value();
2021     size += cpool_entry_size(idx);
2022 
2023     switch(tag) {
2024       case JVM_CONSTANT_Utf8: {
2025         Symbol* sym = symbol_at(idx);
2026         symmap-&gt;add_entry(sym, idx);
2027         DBG(printf(&quot;adding symbol entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2028         break;
2029       }
2030       case JVM_CONSTANT_Class:
2031       case JVM_CONSTANT_UnresolvedClass:
2032       case JVM_CONSTANT_UnresolvedClassInError: {
2033         Symbol* sym = klass_name_at(idx);
2034         classmap-&gt;add_entry(sym, idx);
2035         DBG(printf(&quot;adding class entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2036         break;
2037       }
2038       case JVM_CONSTANT_Long:
2039       case JVM_CONSTANT_Double: {
2040         idx++; // Both Long and Double take two cpool slots
2041         break;
2042       }
2043     }
2044   }
2045   return size;
2046 } /* end hash_utf8_entries_to */
2047 
2048 
2049 // Copy cpool bytes.
2050 // Returns:
2051 //    0, in case of OutOfMemoryError
2052 //   -1, in case of internal error
2053 //  &gt; 0, count of the raw cpool bytes that have been copied
2054 int ConstantPool::copy_cpool_bytes(int cpool_size,
2055                                           SymbolHashMap* tbl,
2056                                           unsigned char *bytes) {
2057   u2   idx1, idx2;
2058   jint size  = 0;
2059   jint cnt   = length();
2060   unsigned char *start_bytes = bytes;
2061 
2062   for (jint idx = 1; idx &lt; cnt; idx++) {
2063     u1   tag      = tag_at(idx).value();
2064     jint ent_size = cpool_entry_size(idx);
2065 
2066     assert(size + ent_size &lt;= cpool_size, &quot;Size mismatch&quot;);
2067 
2068     *bytes = tag;
2069     DBG(printf(&quot;#%03hd tag=%03hd, &quot;, (short)idx, (short)tag));
2070     switch(tag) {
2071       case JVM_CONSTANT_Invalid: {
2072         DBG(printf(&quot;JVM_CONSTANT_Invalid&quot;));
2073         break;
2074       }
2075       case JVM_CONSTANT_Unicode: {
2076         assert(false, &quot;Wrong constant pool tag: JVM_CONSTANT_Unicode&quot;);
2077         DBG(printf(&quot;JVM_CONSTANT_Unicode&quot;));
2078         break;
2079       }
2080       case JVM_CONSTANT_Utf8: {
2081         Symbol* sym = symbol_at(idx);
2082         char*     str = sym-&gt;as_utf8();
2083         // Warning! It&#39;s crashing on x86 with len = sym-&gt;utf8_length()
2084         int       len = (int) strlen(str);
2085         Bytes::put_Java_u2((address) (bytes+1), (u2) len);
2086         for (int i = 0; i &lt; len; i++) {
2087             bytes[3+i] = (u1) str[i];
2088         }
2089         DBG(printf(&quot;JVM_CONSTANT_Utf8: %s &quot;, str));
2090         break;
2091       }
2092       case JVM_CONSTANT_Integer: {
2093         jint val = int_at(idx);
2094         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2095         break;
2096       }
2097       case JVM_CONSTANT_Float: {
2098         jfloat val = float_at(idx);
2099         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2100         break;
2101       }
2102       case JVM_CONSTANT_Long: {
2103         jlong val = long_at(idx);
2104         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2105         idx++;             // Long takes two cpool slots
2106         break;
2107       }
2108       case JVM_CONSTANT_Double: {
2109         jdouble val = double_at(idx);
2110         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2111         idx++;             // Double takes two cpool slots
2112         break;
2113       }
2114       case JVM_CONSTANT_Class:
2115       case JVM_CONSTANT_UnresolvedClass:
2116       case JVM_CONSTANT_UnresolvedClassInError: {
2117         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);
2118         *bytes = JVM_CONSTANT_Class;
2119         Symbol* sym = klass_name_at(idx);
2120         idx1 = tbl-&gt;symbol_to_value(sym);
2121         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2122         Bytes::put_Java_u2((address) (bytes+1), idx1);
2123         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2124         break;
2125       }
2126       case JVM_CONSTANT_String: {
2127         *bytes = JVM_CONSTANT_String;
2128         Symbol* sym = unresolved_string_at(idx);
2129         idx1 = tbl-&gt;symbol_to_value(sym);
2130         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2131         Bytes::put_Java_u2((address) (bytes+1), idx1);
2132         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2133         break;
2134       }
2135       case JVM_CONSTANT_Fieldref:
2136       case JVM_CONSTANT_Methodref:
2137       case JVM_CONSTANT_InterfaceMethodref: {
2138         idx1 = uncached_klass_ref_index_at(idx);
2139         idx2 = uncached_name_and_type_ref_index_at(idx);
2140         Bytes::put_Java_u2((address) (bytes+1), idx1);
2141         Bytes::put_Java_u2((address) (bytes+3), idx2);
2142         DBG(printf(&quot;JVM_CONSTANT_Methodref: %hd %hd&quot;, idx1, idx2));
2143         break;
2144       }
2145       case JVM_CONSTANT_NameAndType: {
2146         idx1 = name_ref_index_at(idx);
2147         idx2 = signature_ref_index_at(idx);
2148         Bytes::put_Java_u2((address) (bytes+1), idx1);
2149         Bytes::put_Java_u2((address) (bytes+3), idx2);
2150         DBG(printf(&quot;JVM_CONSTANT_NameAndType: %hd %hd&quot;, idx1, idx2));
2151         break;
2152       }
2153       case JVM_CONSTANT_ClassIndex: {
2154         *bytes = JVM_CONSTANT_Class;
2155         idx1 = klass_index_at(idx);
2156         Bytes::put_Java_u2((address) (bytes+1), idx1);
2157         DBG(printf(&quot;JVM_CONSTANT_ClassIndex: %hd&quot;, idx1));
2158         break;
2159       }
2160       case JVM_CONSTANT_StringIndex: {
2161         *bytes = JVM_CONSTANT_String;
2162         idx1 = string_index_at(idx);
2163         Bytes::put_Java_u2((address) (bytes+1), idx1);
2164         DBG(printf(&quot;JVM_CONSTANT_StringIndex: %hd&quot;, idx1));
2165         break;
2166       }
2167       case JVM_CONSTANT_MethodHandle:
2168       case JVM_CONSTANT_MethodHandleInError: {
2169         *bytes = JVM_CONSTANT_MethodHandle;
2170         int kind = method_handle_ref_kind_at(idx);
2171         idx1 = method_handle_index_at(idx);
2172         *(bytes+1) = (unsigned char) kind;
2173         Bytes::put_Java_u2((address) (bytes+2), idx1);
2174         DBG(printf(&quot;JVM_CONSTANT_MethodHandle: %d %hd&quot;, kind, idx1));
2175         break;
2176       }
2177       case JVM_CONSTANT_MethodType:
2178       case JVM_CONSTANT_MethodTypeInError: {
2179         *bytes = JVM_CONSTANT_MethodType;
2180         idx1 = method_type_index_at(idx);
2181         Bytes::put_Java_u2((address) (bytes+1), idx1);
2182         DBG(printf(&quot;JVM_CONSTANT_MethodType: %hd&quot;, idx1));
2183         break;
2184       }
2185       case JVM_CONSTANT_Dynamic:
2186       case JVM_CONSTANT_DynamicInError: {
2187         *bytes = tag;
2188         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2189         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2190         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2191         Bytes::put_Java_u2((address) (bytes+1), idx1);
2192         Bytes::put_Java_u2((address) (bytes+3), idx2);
2193         DBG(printf(&quot;JVM_CONSTANT_Dynamic: %hd %hd&quot;, idx1, idx2));
2194         break;
2195       }
2196       case JVM_CONSTANT_InvokeDynamic: {
2197         *bytes = tag;
2198         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2199         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2200         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2201         Bytes::put_Java_u2((address) (bytes+1), idx1);
2202         Bytes::put_Java_u2((address) (bytes+3), idx2);
2203         DBG(printf(&quot;JVM_CONSTANT_InvokeDynamic: %hd %hd&quot;, idx1, idx2));
2204         break;
2205       }
2206     }
2207     DBG(printf(&quot;\n&quot;));
2208     bytes += ent_size;
2209     size  += ent_size;
2210   }
2211   assert(size == cpool_size, &quot;Size mismatch&quot;);
2212 
2213   // Keep temorarily for debugging until it&#39;s stable.
2214   DBG(print_cpool_bytes(cnt, start_bytes));
2215   return (int)(bytes - start_bytes);
2216 } /* end copy_cpool_bytes */
2217 
2218 #undef DBG
2219 
2220 
2221 void ConstantPool::set_on_stack(const bool value) {
2222   if (value) {
2223     // Only record if it&#39;s not already set.
2224     if (!on_stack()) {
2225       assert(!is_shared(), &quot;should always be set for shared constant pools&quot;);
2226       _flags |= _on_stack;
2227       MetadataOnStackMark::record(this);
2228     }
2229   } else {
2230     // Clearing is done single-threadedly.
2231     if (!is_shared()) {
2232       _flags &amp;= ~_on_stack;
2233     }
2234   }
2235 }
2236 
2237 // JSR 292 support for patching constant pool oops after the class is linked and
2238 // the oop array for resolved references are created.
2239 // We can&#39;t do this during classfile parsing, which is how the other indexes are
2240 // patched.  The other patches are applied early for some error checking
2241 // so only defer the pseudo_strings.
2242 void ConstantPool::patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches) {
2243   for (int index = 1; index &lt; cp_patches-&gt;length(); index++) { // Index 0 is unused
2244     Handle patch = cp_patches-&gt;at(index);
2245     if (patch.not_null()) {
2246       assert (tag_at(index).is_string(), &quot;should only be string left&quot;);
2247       // Patching a string means pre-resolving it.
2248       // The spelling in the constant pool is ignored.
2249       // The constant reference may be any object whatever.
2250       // If it is not a real interned string, the constant is referred
2251       // to as a &quot;pseudo-string&quot;, and must be presented to the CP
2252       // explicitly, because it may require scavenging.
2253       int obj_index = cp_to_object_index(index);
2254       pseudo_string_at_put(index, obj_index, patch());
2255      DEBUG_ONLY(cp_patches-&gt;at_put(index, Handle());)
2256     }
2257   }
2258 #ifdef ASSERT
2259   // Ensure that all the patches have been used.
2260   for (int index = 0; index &lt; cp_patches-&gt;length(); index++) {
2261     assert(cp_patches-&gt;at(index).is_null(),
2262            &quot;Unused constant pool patch at %d in class file %s&quot;,
2263            index,
2264            pool_holder()-&gt;external_name());
2265   }
2266 #endif // ASSERT
2267 }
2268 
2269 // Printing
2270 
2271 void ConstantPool::print_on(outputStream* st) const {
2272   assert(is_constantPool(), &quot;must be constantPool&quot;);
2273   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2274   if (flags() != 0) {
2275     st-&gt;print(&quot; - flags: 0x%x&quot;, flags());
2276     if (has_preresolution()) st-&gt;print(&quot; has_preresolution&quot;);
2277     if (on_stack()) st-&gt;print(&quot; on_stack&quot;);
2278     st-&gt;cr();
2279   }
2280   if (pool_holder() != NULL) {
2281     st-&gt;print_cr(&quot; - holder: &quot; INTPTR_FORMAT, p2i(pool_holder()));
2282   }
2283   st-&gt;print_cr(&quot; - cache: &quot; INTPTR_FORMAT, p2i(cache()));
2284   st-&gt;print_cr(&quot; - resolved_references: &quot; INTPTR_FORMAT, p2i(resolved_references()));
2285   st-&gt;print_cr(&quot; - reference_map: &quot; INTPTR_FORMAT, p2i(reference_map()));
2286   st-&gt;print_cr(&quot; - resolved_klasses: &quot; INTPTR_FORMAT, p2i(resolved_klasses()));
2287 
2288   for (int index = 1; index &lt; length(); index++) {      // Index 0 is unused
2289     ((ConstantPool*)this)-&gt;print_entry_on(index, st);
2290     switch (tag_at(index).value()) {
2291       case JVM_CONSTANT_Long :
2292       case JVM_CONSTANT_Double :
2293         index++;   // Skip entry following eigth-byte constant
2294     }
2295 
2296   }
2297   st-&gt;cr();
2298 }
2299 
2300 // Print one constant pool entry
2301 void ConstantPool::print_entry_on(const int index, outputStream* st) {
2302   EXCEPTION_MARK;
2303   st-&gt;print(&quot; - %3d : &quot;, index);
2304   tag_at(index).print_on(st);
2305   st-&gt;print(&quot; : &quot;);
2306   switch (tag_at(index).value()) {
2307     case JVM_CONSTANT_Class :
2308       { Klass* k = klass_at(index, CATCH);
2309         guarantee(k != NULL, &quot;need klass&quot;);
2310         k-&gt;print_value_on(st);
2311         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(k));
2312       }
2313       break;
2314     case JVM_CONSTANT_Fieldref :
2315     case JVM_CONSTANT_Methodref :
2316     case JVM_CONSTANT_InterfaceMethodref :
2317       st-&gt;print(&quot;klass_index=%d&quot;, uncached_klass_ref_index_at(index));
2318       st-&gt;print(&quot; name_and_type_index=%d&quot;, uncached_name_and_type_ref_index_at(index));
2319       break;
2320     case JVM_CONSTANT_String :
2321       if (is_pseudo_string_at(index)) {
2322         oop anObj = pseudo_string_at(index);
2323         anObj-&gt;print_value_on(st);
2324         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(anObj));
2325       } else {
2326         unresolved_string_at(index)-&gt;print_value_on(st);
2327       }
2328       break;
2329     case JVM_CONSTANT_Integer :
2330       st-&gt;print(&quot;%d&quot;, int_at(index));
2331       break;
2332     case JVM_CONSTANT_Float :
2333       st-&gt;print(&quot;%f&quot;, float_at(index));
2334       break;
2335     case JVM_CONSTANT_Long :
2336       st-&gt;print_jlong(long_at(index));
2337       break;
2338     case JVM_CONSTANT_Double :
2339       st-&gt;print(&quot;%lf&quot;, double_at(index));
2340       break;
2341     case JVM_CONSTANT_NameAndType :
2342       st-&gt;print(&quot;name_index=%d&quot;, name_ref_index_at(index));
2343       st-&gt;print(&quot; signature_index=%d&quot;, signature_ref_index_at(index));
2344       break;
2345     case JVM_CONSTANT_Utf8 :
2346       symbol_at(index)-&gt;print_value_on(st);
2347       break;
2348     case JVM_CONSTANT_ClassIndex: {
2349         int name_index = *int_at_addr(index);
2350         st-&gt;print(&quot;klass_index=%d &quot;, name_index);
2351         symbol_at(name_index)-&gt;print_value_on(st);
2352       }
2353       break;
2354     case JVM_CONSTANT_UnresolvedClass :               // fall-through
2355     case JVM_CONSTANT_UnresolvedClassInError: {
2356         CPKlassSlot kslot = klass_slot_at(index);
2357         int resolved_klass_index = kslot.resolved_klass_index();
2358         int name_index = kslot.name_index();
2359         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
2360 
2361         Klass* klass = resolved_klasses()-&gt;at(resolved_klass_index);
2362         if (klass != NULL) {
2363           klass-&gt;print_value_on(st);
2364         } else {
2365           symbol_at(name_index)-&gt;print_value_on(st);
2366         }
2367       }
2368       break;
2369     case JVM_CONSTANT_MethodHandle :
2370     case JVM_CONSTANT_MethodHandleInError :
2371       st-&gt;print(&quot;ref_kind=%d&quot;, method_handle_ref_kind_at(index));
2372       st-&gt;print(&quot; ref_index=%d&quot;, method_handle_index_at(index));
2373       break;
2374     case JVM_CONSTANT_MethodType :
2375     case JVM_CONSTANT_MethodTypeInError :
2376       st-&gt;print(&quot;signature_index=%d&quot;, method_type_index_at(index));
2377       break;
2378     case JVM_CONSTANT_Dynamic :
2379     case JVM_CONSTANT_DynamicInError :
2380       {
2381         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2382         st-&gt;print(&quot; type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2383         int argc = bootstrap_argument_count_at(index);
2384         if (argc &gt; 0) {
2385           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2386             int arg = bootstrap_argument_index_at(index, arg_i);
2387             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2388           }
2389           st-&gt;print(&quot;}&quot;);
2390         }
2391       }
2392       break;
2393     case JVM_CONSTANT_InvokeDynamic :
2394       {
2395         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2396         st-&gt;print(&quot; name_and_type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2397         int argc = bootstrap_argument_count_at(index);
2398         if (argc &gt; 0) {
2399           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2400             int arg = bootstrap_argument_index_at(index, arg_i);
2401             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2402           }
2403           st-&gt;print(&quot;}&quot;);
2404         }
2405       }
2406       break;
2407     default:
2408       ShouldNotReachHere();
2409       break;
2410   }
2411   st-&gt;cr();
2412 }
2413 
2414 void ConstantPool::print_value_on(outputStream* st) const {
2415   assert(is_constantPool(), &quot;must be constantPool&quot;);
2416   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2417   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2418   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2419   print_address_on(st);
2420   if (pool_holder() != NULL) {
2421     st-&gt;print(&quot; for &quot;);
2422     pool_holder()-&gt;print_value_on(st);
2423     bool extra = (pool_holder()-&gt;constants() != this);
2424     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2425   }
2426   if (cache() != NULL) {
2427     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2428   }
2429 }
2430 
2431 // Verification
2432 
2433 void ConstantPool::verify_on(outputStream* st) {
2434   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2435   for (int i = 0; i&lt; length();  i++) {
2436     constantTag tag = tag_at(i);
2437     if (tag.is_klass() || tag.is_unresolved_klass()) {
2438       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2439     } else if (tag.is_symbol()) {
2440       CPSlot entry = slot_at(i);
2441       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2442     } else if (tag.is_string()) {
2443       CPSlot entry = slot_at(i);
2444       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2445     }
2446   }
2447   if (pool_holder() != NULL) {
2448     // Note: pool_holder() can be NULL in temporary constant pools
2449     // used during constant pool merging
2450     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
2451   }
2452 }
2453 
2454 
2455 SymbolHashMap::~SymbolHashMap() {
2456   SymbolHashMapEntry* next;
2457   for (int i = 0; i &lt; _table_size; i++) {
2458     for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {
2459       next = cur-&gt;next();
2460       delete(cur);
2461     }
2462   }
2463   FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);
2464 }
2465 
2466 void SymbolHashMap::add_entry(Symbol* sym, u2 value) {
2467   char *str = sym-&gt;as_utf8();
2468   unsigned int hash = compute_hash(str, sym-&gt;utf8_length());
2469   unsigned int index = hash % table_size();
2470 
2471   // check if already in map
2472   // we prefer the first entry since it is more likely to be what was used in
2473   // the class file
2474   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2475     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2476     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2477         return;  // already there
2478     }
2479   }
2480 
2481   SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);
2482   entry-&gt;set_next(bucket(index));
2483   _buckets[index].set_entry(entry);
2484   assert(entry-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2485 }
2486 
2487 SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {
2488   assert(sym != NULL, &quot;SymbolHashMap::find_entry - symbol is NULL&quot;);
2489   char *str = sym-&gt;as_utf8();
2490   int   len = sym-&gt;utf8_length();
2491   unsigned int hash = SymbolHashMap::compute_hash(str, len);
2492   unsigned int index = hash % table_size();
2493   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2494     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2495     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2496       return en;
2497     }
2498   }
2499   return NULL;
2500 }
2501 
2502 void SymbolHashMap::initialize_table(int table_size) {
2503   _table_size = table_size;
2504   _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);
2505   for (int index = 0; index &lt; table_size; index++) {
2506     _buckets[index].clear();
2507   }
2508 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/cfgnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1681   _index_map_count = 0;
1682   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1683 
1684   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1685   _operands_index_map_count = 0;
1686   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1687   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1688 
1689   // reference to the cp holder is needed for copy_operands()
1690   merge_cp-&gt;set_pool_holder(scratch_class);
1691   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1692                   &amp;merge_cp_length, THREAD);
1693   merge_cp-&gt;set_pool_holder(NULL);
1694 
1695   if (!result) {
1696     // The merge can fail due to memory allocation failure or due
1697     // to robustness checks.
1698     return JVMTI_ERROR_INTERNAL;
1699   }
1700 
<span class="line-modified">1701   if (old_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-modified">1702     merge_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-modified">1703     scratch_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-removed">1704   }</span>
1705 
1706   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1707 
1708   if (_index_map_count == 0) {
1709     // there is nothing to map between the new and merged constant pools
1710 
1711     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1712       // The old and new constant pools are the same length and the
1713       // index map is empty. This means that the three constant pools
1714       // are equivalent (but not the same). Unfortunately, the new
1715       // constant pool has not gone through link resolution nor have
1716       // the new class bytecodes gone through constant pool cache
1717       // rewriting so we can&#39;t use the old constant pool with the new
1718       // class.
1719 
1720       // toss the merged constant pool at return
1721     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1722       // The old constant pool has fewer entries than the new constant
1723       // pool and the index map is empty. This means the new constant
1724       // pool is a superset of the old constant pool. However, the old
</pre>
<hr />
<pre>
3355        ClassLoaderData* loader_data,
3356        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3357        int scratch_cp_length, TRAPS) {
3358   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3359 
3360   // scratch_cp is a merged constant pool and has enough space for a
3361   // worst case merge situation. We want to associate the minimum
3362   // sized constant pool with the klass to save space.
3363   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3364   constantPoolHandle smaller_cp(THREAD, cp);
3365 
3366   // preserve version() value in the smaller copy
3367   int version = scratch_cp-&gt;version();
3368   assert(version != 0, &quot;sanity check&quot;);
3369   smaller_cp-&gt;set_version(version);
3370 
3371   // attach klass to new constant pool
3372   // reference to the cp holder is needed for copy_operands()
3373   smaller_cp-&gt;set_pool_holder(scratch_class);
3374 
<span class="line-modified">3375   if (scratch_cp-&gt;has_dynamic_constant()) {</span>
<span class="line-removed">3376     smaller_cp-&gt;set_has_dynamic_constant();</span>
<span class="line-removed">3377   }</span>
3378 
3379   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3380   if (HAS_PENDING_EXCEPTION) {
3381     // Exception is handled in the caller
3382     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3383     return;
3384   }
3385   scratch_cp = smaller_cp;
3386 
3387   // attach new constant pool to klass
3388   scratch_class-&gt;set_constants(scratch_cp());
3389   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3390 
3391   int i;  // for portability
3392 
3393   // update each field in klass to use new constant pool indices as needed
3394   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3395     jshort cur_index = fs.name_index();
3396     jshort new_index = find_new_index(cur_index);
3397     if (new_index != 0) {
</pre>
<hr />
<pre>
4236   the_class-&gt;set_source_debug_extension(
4237     scratch_class-&gt;source_debug_extension(),
4238     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4239     (int)strlen(scratch_class-&gt;source_debug_extension()));
4240 
4241   // Use of javac -g could be different in the old and the new
4242   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4243       the_class-&gt;access_flags().has_localvariable_table()) {
4244 
4245     AccessFlags flags = the_class-&gt;access_flags();
4246     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4247       flags.set_has_localvariable_table();
4248     } else {
4249       flags.clear_has_localvariable_table();
4250     }
4251     the_class-&gt;set_access_flags(flags);
4252   }
4253 
4254   swap_annotations(the_class, scratch_class);
4255 
<span class="line-removed">4256   // Replace minor version number of class file</span>
<span class="line-removed">4257   u2 old_minor_version = the_class-&gt;minor_version();</span>
<span class="line-removed">4258   the_class-&gt;set_minor_version(scratch_class-&gt;minor_version());</span>
<span class="line-removed">4259   scratch_class-&gt;set_minor_version(old_minor_version);</span>
<span class="line-removed">4260 </span>
<span class="line-removed">4261   // Replace major version number of class file</span>
<span class="line-removed">4262   u2 old_major_version = the_class-&gt;major_version();</span>
<span class="line-removed">4263   the_class-&gt;set_major_version(scratch_class-&gt;major_version());</span>
<span class="line-removed">4264   scratch_class-&gt;set_major_version(old_major_version);</span>
<span class="line-removed">4265 </span>
4266   // Replace CP indexes for class and name+type of enclosing method
4267   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4268   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4269   the_class-&gt;set_enclosing_method_indices(
4270     scratch_class-&gt;enclosing_method_class_index(),
4271     scratch_class-&gt;enclosing_method_method_index());
4272   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4273 
4274   // Replace fingerprint data
4275   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4276   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4277 
4278   the_class-&gt;set_has_been_redefined();
4279 
4280   if (!the_class-&gt;should_be_initialized()) {
4281     // Class was already initialized, so AOT has only seen the original version.
4282     // We need to let AOT look at it again.
4283     AOTLoader::load_for_klass(the_class, THREAD);
4284   }
4285 
</pre>
</td>
<td>
<hr />
<pre>
1681   _index_map_count = 0;
1682   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1683 
1684   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1685   _operands_index_map_count = 0;
1686   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1687   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1688 
1689   // reference to the cp holder is needed for copy_operands()
1690   merge_cp-&gt;set_pool_holder(scratch_class);
1691   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1692                   &amp;merge_cp_length, THREAD);
1693   merge_cp-&gt;set_pool_holder(NULL);
1694 
1695   if (!result) {
1696     // The merge can fail due to memory allocation failure or due
1697     // to robustness checks.
1698     return JVMTI_ERROR_INTERNAL;
1699   }
1700 
<span class="line-modified">1701   // Save fields from the old_cp.</span>
<span class="line-modified">1702   merge_cp-&gt;copy_fields(old_cp());</span>
<span class="line-modified">1703   scratch_cp-&gt;copy_fields(old_cp());</span>

1704 
1705   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1706 
1707   if (_index_map_count == 0) {
1708     // there is nothing to map between the new and merged constant pools
1709 
1710     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1711       // The old and new constant pools are the same length and the
1712       // index map is empty. This means that the three constant pools
1713       // are equivalent (but not the same). Unfortunately, the new
1714       // constant pool has not gone through link resolution nor have
1715       // the new class bytecodes gone through constant pool cache
1716       // rewriting so we can&#39;t use the old constant pool with the new
1717       // class.
1718 
1719       // toss the merged constant pool at return
1720     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1721       // The old constant pool has fewer entries than the new constant
1722       // pool and the index map is empty. This means the new constant
1723       // pool is a superset of the old constant pool. However, the old
</pre>
<hr />
<pre>
3354        ClassLoaderData* loader_data,
3355        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3356        int scratch_cp_length, TRAPS) {
3357   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3358 
3359   // scratch_cp is a merged constant pool and has enough space for a
3360   // worst case merge situation. We want to associate the minimum
3361   // sized constant pool with the klass to save space.
3362   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3363   constantPoolHandle smaller_cp(THREAD, cp);
3364 
3365   // preserve version() value in the smaller copy
3366   int version = scratch_cp-&gt;version();
3367   assert(version != 0, &quot;sanity check&quot;);
3368   smaller_cp-&gt;set_version(version);
3369 
3370   // attach klass to new constant pool
3371   // reference to the cp holder is needed for copy_operands()
3372   smaller_cp-&gt;set_pool_holder(scratch_class);
3373 
<span class="line-modified">3374   smaller_cp-&gt;copy_fields(scratch_cp());</span>


3375 
3376   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3377   if (HAS_PENDING_EXCEPTION) {
3378     // Exception is handled in the caller
3379     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3380     return;
3381   }
3382   scratch_cp = smaller_cp;
3383 
3384   // attach new constant pool to klass
3385   scratch_class-&gt;set_constants(scratch_cp());
3386   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3387 
3388   int i;  // for portability
3389 
3390   // update each field in klass to use new constant pool indices as needed
3391   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3392     jshort cur_index = fs.name_index();
3393     jshort new_index = find_new_index(cur_index);
3394     if (new_index != 0) {
</pre>
<hr />
<pre>
4233   the_class-&gt;set_source_debug_extension(
4234     scratch_class-&gt;source_debug_extension(),
4235     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4236     (int)strlen(scratch_class-&gt;source_debug_extension()));
4237 
4238   // Use of javac -g could be different in the old and the new
4239   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4240       the_class-&gt;access_flags().has_localvariable_table()) {
4241 
4242     AccessFlags flags = the_class-&gt;access_flags();
4243     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4244       flags.set_has_localvariable_table();
4245     } else {
4246       flags.clear_has_localvariable_table();
4247     }
4248     the_class-&gt;set_access_flags(flags);
4249   }
4250 
4251   swap_annotations(the_class, scratch_class);
4252 










4253   // Replace CP indexes for class and name+type of enclosing method
4254   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4255   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4256   the_class-&gt;set_enclosing_method_indices(
4257     scratch_class-&gt;enclosing_method_class_index(),
4258     scratch_class-&gt;enclosing_method_method_index());
4259   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4260 
4261   // Replace fingerprint data
4262   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4263   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4264 
4265   the_class-&gt;set_has_been_redefined();
4266 
4267   if (!the_class-&gt;should_be_initialized()) {
4268     // Class was already initialized, so AOT has only seen the original version.
4269     // We need to let AOT look at it again.
4270     AOTLoader::load_for_klass(the_class, THREAD);
4271   }
4272 
</pre>
</td>
</tr>
</table>
<center><a href="../opto/cfgnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
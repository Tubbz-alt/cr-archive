diff a/src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp b/src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp
@@ -187,11 +187,10 @@
   __ jcc(Assembler::equal, done);
 
   // Can we store original value in the thread's buffer?
   // Is index == 0?
   // (The index field is typed as size_t.)
-
   __ movptr(tmp, index);                   // tmp := *index_adr
   __ cmpptr(tmp, 0);                       // tmp == 0?
   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
 
   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
@@ -201,18 +200,14 @@
   // Record the previous value
   __ movptr(Address(tmp, 0), pre_val);
   __ jmp(done);
 
   __ bind(runtime);
-  // save the live input values
-  if(tosca_live) __ push(rax);
-
-  if (obj != noreg && obj != rax)
-    __ push(obj);
-
-  if (pre_val != rax)
-    __ push(pre_val);
+  // FIXME
+  // Barriers might be emitted when converting between (scalarized) calling conventions for inline
+  // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.
+  __ pusha();
 
   // Calling the runtime using the regular call_VM_leaf mechanism generates
   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
   //
@@ -222,12 +217,10 @@
   //
   // Expanding the call directly bypasses the generation of the check.
   // So when we do not have have a full interpreter frame on the stack
   // expand_call should be passed true.
 
-  NOT_LP64( __ push(thread); )
-
   if (expand_call) {
     LP64_ONLY( assert(pre_val != c_rarg1, "smashed arg"); )
 #ifdef _LP64
     if (c_rarg1 != thread) {
       __ mov(c_rarg1, thread);
@@ -242,21 +235,11 @@
     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), 2);
   } else {
     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
   }
 
-  NOT_LP64( __ pop(thread); )
-
-  // save the live input values
-  if (pre_val != rax)
-    __ pop(pre_val);
-
-  if (obj != noreg && obj != rax)
-    __ pop(obj);
-
-  if(tosca_live) __ pop(rax);
-
+  __ popa();
   __ bind(done);
 }
 
 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
                                                   Register store_addr,
@@ -327,30 +310,24 @@
   __ movl(Address(tmp2, 0), card_addr);
 #endif
   __ jmp(done);
 
   __ bind(runtime);
-  // save the live input values
-  __ push(store_addr);
-  __ push(new_val);
-  // Save caller saved registers until JDK-8232094 is fixed (TODO).
-  __ push(rax);
-  __ push(rcx);
-  __ push(rdx);
+  // FIXME
+  // Barriers might be emitted when converting between (scalarized) calling conventions for inline
+  // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.
+  __ pusha();
+
 #ifdef _LP64
   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);
 #else
   __ push(thread);
   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
   __ pop(thread);
 #endif
-  __ pop(rdx);
-  __ pop(rcx);
-  __ pop(rax);
-  __ pop(new_val);
-  __ pop(store_addr);
 
+  __ popa();
   __ bind(done);
 }
 
 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../share/ci/ciReplay.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/g1/g1BarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
172   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
173     __ cmpl(in_progress, 0);
174   } else {
175     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
176     __ cmpb(in_progress, 0);
177   }
178   __ jcc(Assembler::equal, done);
179 
180   // Do we need to load the previous value?
181   if (obj != noreg) {
182     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
183   }
184 
185   // Is the previous value null?
186   __ cmpptr(pre_val, (int32_t) NULL_WORD);
187   __ jcc(Assembler::equal, done);
188 
189   // Can we store original value in the thread&#39;s buffer?
190   // Is index == 0?
191   // (The index field is typed as size_t.)
<span class="line-removed">192 </span>
193   __ movptr(tmp, index);                   // tmp := *index_adr
194   __ cmpptr(tmp, 0);                       // tmp == 0?
195   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
196 
197   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
198   __ movptr(index, tmp);                   // *index_adr := tmp
199   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
200 
201   // Record the previous value
202   __ movptr(Address(tmp, 0), pre_val);
203   __ jmp(done);
204 
205   __ bind(runtime);
<span class="line-modified">206   // save the live input values</span>
<span class="line-modified">207   if(tosca_live) __ push(rax);</span>
<span class="line-modified">208 </span>
<span class="line-modified">209   if (obj != noreg &amp;&amp; obj != rax)</span>
<span class="line-removed">210     __ push(obj);</span>
<span class="line-removed">211 </span>
<span class="line-removed">212   if (pre_val != rax)</span>
<span class="line-removed">213     __ push(pre_val);</span>
214 
215   // Calling the runtime using the regular call_VM_leaf mechanism generates
216   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
217   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
218   //
219   // If we care generating the pre-barrier without a frame (e.g. in the
220   // intrinsified Reference.get() routine) then ebp might be pointing to
221   // the caller frame and so this check will most likely fail at runtime.
222   //
223   // Expanding the call directly bypasses the generation of the check.
224   // So when we do not have have a full interpreter frame on the stack
225   // expand_call should be passed true.
226 
<span class="line-removed">227   NOT_LP64( __ push(thread); )</span>
<span class="line-removed">228 </span>
229   if (expand_call) {
230     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
231 #ifdef _LP64
232     if (c_rarg1 != thread) {
233       __ mov(c_rarg1, thread);
234     }
235     if (c_rarg0 != pre_val) {
236       __ mov(c_rarg0, pre_val);
237     }
238 #else
239     __ push(thread);
240     __ push(pre_val);
241 #endif
242     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), 2);
243   } else {
244     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
245   }
246 
<span class="line-modified">247   NOT_LP64( __ pop(thread); )</span>
<span class="line-removed">248 </span>
<span class="line-removed">249   // save the live input values</span>
<span class="line-removed">250   if (pre_val != rax)</span>
<span class="line-removed">251     __ pop(pre_val);</span>
<span class="line-removed">252 </span>
<span class="line-removed">253   if (obj != noreg &amp;&amp; obj != rax)</span>
<span class="line-removed">254     __ pop(obj);</span>
<span class="line-removed">255 </span>
<span class="line-removed">256   if(tosca_live) __ pop(rax);</span>
<span class="line-removed">257 </span>
258   __ bind(done);
259 }
260 
261 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
262                                                   Register store_addr,
263                                                   Register new_val,
264                                                   Register thread,
265                                                   Register tmp,
266                                                   Register tmp2) {
267 #ifdef _LP64
268   assert(thread == r15_thread, &quot;must be&quot;);
269 #endif // _LP64
270 
271   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
272   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
273 
274   CardTableBarrierSet* ct =
275     barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
276 
277   Label done;
</pre>
<hr />
<pre>
312   // storing a region crossing, non-NULL oop, card is clean.
313   // dirty card and log.
314 
315   __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());
316 
317   __ cmpl(queue_index, 0);
318   __ jcc(Assembler::equal, runtime);
319   __ subl(queue_index, wordSize);
320   __ movptr(tmp2, buffer);
321 #ifdef _LP64
322   __ movslq(rscratch1, queue_index);
323   __ addq(tmp2, rscratch1);
324   __ movq(Address(tmp2, 0), card_addr);
325 #else
326   __ addl(tmp2, queue_index);
327   __ movl(Address(tmp2, 0), card_addr);
328 #endif
329   __ jmp(done);
330 
331   __ bind(runtime);
<span class="line-modified">332   // save the live input values</span>
<span class="line-modified">333   __ push(store_addr);</span>
<span class="line-modified">334   __ push(new_val);</span>
<span class="line-modified">335   // Save caller saved registers until JDK-8232094 is fixed (TODO).</span>
<span class="line-modified">336   __ push(rax);</span>
<span class="line-removed">337   __ push(rcx);</span>
<span class="line-removed">338   __ push(rdx);</span>
339 #ifdef _LP64
340   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);
341 #else
342   __ push(thread);
343   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
344   __ pop(thread);
345 #endif
<span class="line-removed">346   __ pop(rdx);</span>
<span class="line-removed">347   __ pop(rcx);</span>
<span class="line-removed">348   __ pop(rax);</span>
<span class="line-removed">349   __ pop(new_val);</span>
<span class="line-removed">350   __ pop(store_addr);</span>
351 

352   __ bind(done);
353 }
354 
355 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
356                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {
357   bool in_heap = (decorators &amp; IN_HEAP) != 0;
358   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
359   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
360 
361   bool needs_pre_barrier = as_normal &amp;&amp; !dest_uninitialized;
362   bool needs_post_barrier = val != noreg &amp;&amp; in_heap;
363 
364   if (tmp3 == noreg) {
365     tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
366   }
367   Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
368   // flatten object address if needed
369   // We do it regardless of precise because we need the registers
370   if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
371     if (dst.base() != tmp1) {
</pre>
</td>
<td>
<hr />
<pre>
172   if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {
173     __ cmpl(in_progress, 0);
174   } else {
175     assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, &quot;Assumption&quot;);
176     __ cmpb(in_progress, 0);
177   }
178   __ jcc(Assembler::equal, done);
179 
180   // Do we need to load the previous value?
181   if (obj != noreg) {
182     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
183   }
184 
185   // Is the previous value null?
186   __ cmpptr(pre_val, (int32_t) NULL_WORD);
187   __ jcc(Assembler::equal, done);
188 
189   // Can we store original value in the thread&#39;s buffer?
190   // Is index == 0?
191   // (The index field is typed as size_t.)

192   __ movptr(tmp, index);                   // tmp := *index_adr
193   __ cmpptr(tmp, 0);                       // tmp == 0?
194   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
195 
196   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
197   __ movptr(index, tmp);                   // *index_adr := tmp
198   __ addptr(tmp, buffer);                  // tmp := tmp + *buffer_adr
199 
200   // Record the previous value
201   __ movptr(Address(tmp, 0), pre_val);
202   __ jmp(done);
203 
204   __ bind(runtime);
<span class="line-modified">205   // FIXME</span>
<span class="line-modified">206   // Barriers might be emitted when converting between (scalarized) calling conventions for inline</span>
<span class="line-modified">207   // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.</span>
<span class="line-modified">208   __ pusha();</span>




209 
210   // Calling the runtime using the regular call_VM_leaf mechanism generates
211   // code (generated by InterpreterMacroAssember::call_VM_leaf_base)
212   // that checks that the *(ebp+frame::interpreter_frame_last_sp) == NULL.
213   //
214   // If we care generating the pre-barrier without a frame (e.g. in the
215   // intrinsified Reference.get() routine) then ebp might be pointing to
216   // the caller frame and so this check will most likely fail at runtime.
217   //
218   // Expanding the call directly bypasses the generation of the check.
219   // So when we do not have have a full interpreter frame on the stack
220   // expand_call should be passed true.
221 


222   if (expand_call) {
223     LP64_ONLY( assert(pre_val != c_rarg1, &quot;smashed arg&quot;); )
224 #ifdef _LP64
225     if (c_rarg1 != thread) {
226       __ mov(c_rarg1, thread);
227     }
228     if (c_rarg0 != pre_val) {
229       __ mov(c_rarg0, pre_val);
230     }
231 #else
232     __ push(thread);
233     __ push(pre_val);
234 #endif
235     __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), 2);
236   } else {
237     __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), pre_val, thread);
238   }
239 
<span class="line-modified">240   __ popa();</span>










241   __ bind(done);
242 }
243 
244 void G1BarrierSetAssembler::g1_write_barrier_post(MacroAssembler* masm,
245                                                   Register store_addr,
246                                                   Register new_val,
247                                                   Register thread,
248                                                   Register tmp,
249                                                   Register tmp2) {
250 #ifdef _LP64
251   assert(thread == r15_thread, &quot;must be&quot;);
252 #endif // _LP64
253 
254   Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));
255   Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));
256 
257   CardTableBarrierSet* ct =
258     barrier_set_cast&lt;CardTableBarrierSet&gt;(BarrierSet::barrier_set());
259 
260   Label done;
</pre>
<hr />
<pre>
295   // storing a region crossing, non-NULL oop, card is clean.
296   // dirty card and log.
297 
298   __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());
299 
300   __ cmpl(queue_index, 0);
301   __ jcc(Assembler::equal, runtime);
302   __ subl(queue_index, wordSize);
303   __ movptr(tmp2, buffer);
304 #ifdef _LP64
305   __ movslq(rscratch1, queue_index);
306   __ addq(tmp2, rscratch1);
307   __ movq(Address(tmp2, 0), card_addr);
308 #else
309   __ addl(tmp2, queue_index);
310   __ movl(Address(tmp2, 0), card_addr);
311 #endif
312   __ jmp(done);
313 
314   __ bind(runtime);
<span class="line-modified">315   // FIXME</span>
<span class="line-modified">316   // Barriers might be emitted when converting between (scalarized) calling conventions for inline</span>
<span class="line-modified">317   // types. Save all registers until JDK-8232094 is fixed to avoid overwriting argument registers.</span>
<span class="line-modified">318   __ pusha();</span>
<span class="line-modified">319 </span>


320 #ifdef _LP64
321   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);
322 #else
323   __ push(thread);
324   __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);
325   __ pop(thread);
326 #endif





327 
<span class="line-added">328   __ popa();</span>
329   __ bind(done);
330 }
331 
332 void G1BarrierSetAssembler::oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
333                                          Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {
334   bool in_heap = (decorators &amp; IN_HEAP) != 0;
335   bool as_normal = (decorators &amp; AS_NORMAL) != 0;
336   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
337 
338   bool needs_pre_barrier = as_normal &amp;&amp; !dest_uninitialized;
339   bool needs_post_barrier = val != noreg &amp;&amp; in_heap;
340 
341   if (tmp3 == noreg) {
342     tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);
343   }
344   Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
345   // flatten object address if needed
346   // We do it regardless of precise because we need the registers
347   if (dst.index() == noreg &amp;&amp; dst.disp() == 0) {
348     if (dst.base() != tmp1) {
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../share/ci/ciReplay.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciReplay.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 207     if (TraceDeoptimization) {
 208       ttyLocker ttyl;
 209       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 210     }
 211   }
 212   if (objects != NULL || vk != NULL) {
 213     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();
 214     JRT_BLOCK
 215       if (vk != NULL) {
 216         realloc_failures = Deoptimization::realloc_value_type_result(vk, map, return_oops, THREAD);
 217       }
 218       if (objects != NULL) {
 219         realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);
 220         Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal, THREAD);
 221       }
 222     JRT_END
 223 #ifndef PRODUCT
 224     if (TraceDeoptimization) {
 225       ttyLocker ttyl;
 226       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 227       Deoptimization::print_objects(objects, realloc_failures);</span>





 228     }
 229 #endif
 230   }
 231   if (save_oop_result || vk != NULL) {
 232     // Restore result.
 233     assert(return_oops.length() == 1, &quot;no value type&quot;);
 234     deoptee.set_saved_oop_result(&amp;map, return_oops.pop()());
 235   }
 236   return realloc_failures;
 237 }
 238 
 239 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 240 #ifndef PRODUCT
 241   bool first = true;
 242 #endif
 243   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 244     compiledVFrame* cvf = chunk-&gt;at(i);
 245     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 246     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 247     if (monitors-&gt;is_nonempty()) {
</pre>
<hr />
<pre>
1387           // where the thread-local object is bias locked to the current thread.
1388           assert(mark.is_biased_anonymously() ||
1389                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1390           // Reset mark word to unbiased prototype.
1391           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1392           obj-&gt;set_mark(unbiased_prototype);
1393         }
1394         BasicLock* lock = mon_info-&gt;lock();
1395         ObjectSynchronizer::enter(obj, lock, thread);
1396         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1397       }
1398     }
1399   }
1400 }
1401 
1402 
1403 #ifndef PRODUCT
1404 // print information about reallocated objects
1405 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1406   fieldDescriptor fd;
<span class="line-removed">1407 </span>
1408   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1409     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1410     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1411     Handle obj = sv-&gt;value();</span>


1412 
<span class="line-modified">1413     tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(sv-&gt;value()()));</span>
<span class="line-modified">1414     k-&gt;print_value();</span>
<span class="line-modified">1415     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1416     if (obj.is_null()) {</span>
<span class="line-modified">1417       tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1418     } else {</span>
<span class="line-modified">1419       tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1420     }</span>
<span class="line-modified">1421     tty-&gt;cr();</span>

1422 
<span class="line-modified">1423     if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1424       k-&gt;oop_print_on(obj(), tty);</span>
<span class="line-removed">1425     }</span>
1426   }
1427 }
1428 #endif
1429 #endif // COMPILER2_OR_JVMCI
1430 
1431 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1432   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1433 
1434 #ifndef PRODUCT
1435   if (PrintDeoptimizationDetails) {
1436     ttyLocker ttyl;
1437     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1438     fr.print_on(tty);
1439     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1440     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1441       compiledVFrame* vf = chunk-&gt;at(index);
1442       tty-&gt;print(&quot;       %2d - &quot;, index);
1443       vf-&gt;print_value();
1444       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1445       const char* code_name;
</pre>
</td>
<td>
<hr />
<pre>
 207     if (TraceDeoptimization) {
 208       ttyLocker ttyl;
 209       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 210     }
 211   }
 212   if (objects != NULL || vk != NULL) {
 213     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();
 214     JRT_BLOCK
 215       if (vk != NULL) {
 216         realloc_failures = Deoptimization::realloc_value_type_result(vk, map, return_oops, THREAD);
 217       }
 218       if (objects != NULL) {
 219         realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);
 220         Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal, THREAD);
 221       }
 222     JRT_END
 223 #ifndef PRODUCT
 224     if (TraceDeoptimization) {
 225       ttyLocker ttyl;
 226       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 227       if (objects != NULL) {</span>
<span class="line-added"> 228         Deoptimization::print_objects(objects, realloc_failures);</span>
<span class="line-added"> 229       } else {</span>
<span class="line-added"> 230         Handle obj = realloc_failures ? Handle() : return_oops.first();</span>
<span class="line-added"> 231         Deoptimization::print_object(vk, obj, realloc_failures);</span>
<span class="line-added"> 232       }</span>
 233     }
 234 #endif
 235   }
 236   if (save_oop_result || vk != NULL) {
 237     // Restore result.
 238     assert(return_oops.length() == 1, &quot;no value type&quot;);
 239     deoptee.set_saved_oop_result(&amp;map, return_oops.pop()());
 240   }
 241   return realloc_failures;
 242 }
 243 
 244 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 245 #ifndef PRODUCT
 246   bool first = true;
 247 #endif
 248   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 249     compiledVFrame* cvf = chunk-&gt;at(i);
 250     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 251     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 252     if (monitors-&gt;is_nonempty()) {
</pre>
<hr />
<pre>
1392           // where the thread-local object is bias locked to the current thread.
1393           assert(mark.is_biased_anonymously() ||
1394                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1395           // Reset mark word to unbiased prototype.
1396           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1397           obj-&gt;set_mark(unbiased_prototype);
1398         }
1399         BasicLock* lock = mon_info-&gt;lock();
1400         ObjectSynchronizer::enter(obj, lock, thread);
1401         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1402       }
1403     }
1404   }
1405 }
1406 
1407 
1408 #ifndef PRODUCT
1409 // print information about reallocated objects
1410 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1411   fieldDescriptor fd;

1412   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1413     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1414     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1415     print_object(k, sv-&gt;value(), realloc_failures);</span>
<span class="line-added">1416   }</span>
<span class="line-added">1417 }</span>
1418 
<span class="line-modified">1419 void Deoptimization::print_object(Klass* k, Handle obj, bool realloc_failures) {</span>
<span class="line-modified">1420   tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(obj()));</span>
<span class="line-modified">1421   k-&gt;print_value();</span>
<span class="line-modified">1422   assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1423   if (obj.is_null()) {</span>
<span class="line-modified">1424     tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1425   } else {</span>
<span class="line-modified">1426     tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1427   }</span>
<span class="line-added">1428   tty-&gt;cr();</span>
1429 
<span class="line-modified">1430   if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1431     k-&gt;oop_print_on(obj(), tty);</span>

1432   }
1433 }
1434 #endif
1435 #endif // COMPILER2_OR_JVMCI
1436 
1437 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1438   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1439 
1440 #ifndef PRODUCT
1441   if (PrintDeoptimizationDetails) {
1442     ttyLocker ttyl;
1443     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1444     fr.print_on(tty);
1445     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1446     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1447       compiledVFrame* vf = chunk-&gt;at(index);
1448       tty-&gt;print(&quot;       %2d - &quot;, index);
1449       vf-&gt;print_value();
1450       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1451       const char* code_name;
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciReplay.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
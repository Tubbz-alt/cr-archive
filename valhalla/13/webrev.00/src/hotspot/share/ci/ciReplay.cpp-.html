<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/ci/ciReplay.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;ci/ciSymbol.hpp&quot;
  30 #include &quot;ci/ciKlass.hpp&quot;
  31 #include &quot;ci/ciUtilities.inline.hpp&quot;
  32 #include &quot;classfile/symbolTable.hpp&quot;
  33 #include &quot;compiler/compileBroker.hpp&quot;
  34 #include &quot;memory/allocation.inline.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/constantPool.hpp&quot;
  38 #include &quot;oops/method.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/valueKlass.inline.hpp&quot;
  41 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  42 #include &quot;runtime/handles.inline.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;
  45 #include &quot;utilities/utf8.hpp&quot;
  46 
  47 #ifndef PRODUCT
  48 
  49 // ciReplay
  50 
  51 typedef struct _ciMethodDataRecord {
  52   const char* _klass_name;
  53   const char* _method_name;
  54   const char* _signature;
  55 
  56   int _state;
  57   int _current_mileage;
  58 
  59   intptr_t* _data;
  60   char*     _orig_data;
  61   Klass**   _classes;
  62   Method**  _methods;
  63   int*      _classes_offsets;
  64   int*      _methods_offsets;
  65   int       _data_length;
  66   int       _orig_data_length;
  67   int       _classes_length;
  68   int       _methods_length;
  69 } ciMethodDataRecord;
  70 
  71 typedef struct _ciMethodRecord {
  72   const char* _klass_name;
  73   const char* _method_name;
  74   const char* _signature;
  75 
  76   int _instructions_size;
  77   int _interpreter_invocation_count;
  78   int _interpreter_throwout_count;
  79   int _invocation_counter;
  80   int _backedge_counter;
  81 } ciMethodRecord;
  82 
  83 typedef struct _ciInlineRecord {
  84   const char* _klass_name;
  85   const char* _method_name;
  86   const char* _signature;
  87 
  88   int _inline_depth;
  89   int _inline_bci;
  90 } ciInlineRecord;
  91 
  92 class  CompileReplay;
  93 static CompileReplay* replay_state;
  94 
  95 class CompileReplay : public StackObj {
  96  private:
  97   FILE*   _stream;
  98   Thread* _thread;
  99   Handle  _protection_domain;
 100   Handle  _loader;
 101 
 102   GrowableArray&lt;ciMethodRecord*&gt;     _ci_method_records;
 103   GrowableArray&lt;ciMethodDataRecord*&gt; _ci_method_data_records;
 104 
 105   // Use pointer because we may need to return inline records
 106   // without destroying them.
 107   GrowableArray&lt;ciInlineRecord*&gt;*    _ci_inline_records;
 108 
 109   const char* _error_message;
 110 
 111   char* _bufptr;
 112   char* _buffer;
 113   int   _buffer_length;
 114   int   _buffer_pos;
 115 
 116   // &quot;compile&quot; data
 117   ciKlass* _iklass;
 118   Method*  _imethod;
 119   int      _entry_bci;
 120   int      _comp_level;
 121 
 122  public:
 123   CompileReplay(const char* filename, TRAPS) {
 124     _thread = THREAD;
 125     _loader = Handle(_thread, SystemDictionary::java_system_loader());
 126     _protection_domain = Handle();
 127 
 128     _stream = fopen(filename, &quot;rt&quot;);
 129     if (_stream == NULL) {
 130       fprintf(stderr, &quot;ERROR: Can&#39;t open replay file %s\n&quot;, filename);
 131     }
 132 
 133     _ci_inline_records = NULL;
 134     _error_message = NULL;
 135 
 136     _buffer_length = 32;
 137     _buffer = NEW_RESOURCE_ARRAY(char, _buffer_length);
 138     _bufptr = _buffer;
 139     _buffer_pos = 0;
 140 
 141     _imethod = NULL;
 142     _iklass  = NULL;
 143     _entry_bci  = 0;
 144     _comp_level = 0;
 145 
 146     test();
 147   }
 148 
 149   ~CompileReplay() {
 150     if (_stream != NULL) fclose(_stream);
 151   }
 152 
 153   void test() {
 154     strcpy(_buffer, &quot;1 2 foo 4 bar 0x9 \&quot;this is it\&quot;&quot;);
 155     _bufptr = _buffer;
 156     assert(parse_int(&quot;test&quot;) == 1, &quot;what&quot;);
 157     assert(parse_int(&quot;test&quot;) == 2, &quot;what&quot;);
 158     assert(strcmp(parse_string(), &quot;foo&quot;) == 0, &quot;what&quot;);
 159     assert(parse_int(&quot;test&quot;) == 4, &quot;what&quot;);
 160     assert(strcmp(parse_string(), &quot;bar&quot;) == 0, &quot;what&quot;);
 161     assert(parse_intptr_t(&quot;test&quot;) == 9, &quot;what&quot;);
 162     assert(strcmp(parse_quoted_string(), &quot;this is it&quot;) == 0, &quot;what&quot;);
 163   }
 164 
 165   bool had_error() {
 166     return _error_message != NULL || _thread-&gt;has_pending_exception();
 167   }
 168 
 169   bool can_replay() {
 170     return !(_stream == NULL || had_error());
 171   }
 172 
 173   void report_error(const char* msg) {
 174     _error_message = msg;
 175     // Restore the _buffer contents for error reporting
 176     for (int i = 0; i &lt; _buffer_pos; i++) {
 177       if (_buffer[i] == &#39;\0&#39;) _buffer[i] = &#39; &#39;;
 178     }
 179   }
 180 
 181   int parse_int(const char* label) {
 182     if (had_error()) {
 183       return 0;
 184     }
 185 
 186     int v = 0;
 187     int read;
 188     if (sscanf(_bufptr, &quot;%i%n&quot;, &amp;v, &amp;read) != 1) {
 189       report_error(label);
 190     } else {
 191       _bufptr += read;
 192     }
 193     return v;
 194   }
 195 
 196   intptr_t parse_intptr_t(const char* label) {
 197     if (had_error()) {
 198       return 0;
 199     }
 200 
 201     intptr_t v = 0;
 202     int read;
 203     if (sscanf(_bufptr, INTPTR_FORMAT &quot;%n&quot;, &amp;v, &amp;read) != 1) {
 204       report_error(label);
 205     } else {
 206       _bufptr += read;
 207     }
 208     return v;
 209   }
 210 
 211   void skip_ws() {
 212     // Skip any leading whitespace
 213     while (*_bufptr == &#39; &#39; || *_bufptr == &#39;\t&#39;) {
 214       _bufptr++;
 215     }
 216   }
 217 
 218 
 219   char* scan_and_terminate(char delim) {
 220     char* str = _bufptr;
 221     while (*_bufptr != delim &amp;&amp; *_bufptr != &#39;\0&#39;) {
 222       _bufptr++;
 223     }
 224     if (*_bufptr != &#39;\0&#39;) {
 225       *_bufptr++ = &#39;\0&#39;;
 226     }
 227     if (_bufptr == str) {
 228       // nothing here
 229       return NULL;
 230     }
 231     return str;
 232   }
 233 
 234   char* parse_string() {
 235     if (had_error()) return NULL;
 236 
 237     skip_ws();
 238     return scan_and_terminate(&#39; &#39;);
 239   }
 240 
 241   char* parse_quoted_string() {
 242     if (had_error()) return NULL;
 243 
 244     skip_ws();
 245 
 246     if (*_bufptr == &#39;&quot;&#39;) {
 247       _bufptr++;
 248       return scan_and_terminate(&#39;&quot;&#39;);
 249     } else {
 250       return scan_and_terminate(&#39; &#39;);
 251     }
 252   }
 253 
 254   const char* parse_escaped_string() {
 255     char* result = parse_quoted_string();
 256     if (result != NULL) {
 257       unescape_string(result);
 258     }
 259     return result;
 260   }
 261 
 262   // Look for the tag &#39;tag&#39; followed by an
 263   bool parse_tag_and_count(const char* tag, int&amp; length) {
 264     const char* t = parse_string();
 265     if (t == NULL) {
 266       return false;
 267     }
 268 
 269     if (strcmp(tag, t) != 0) {
 270       report_error(tag);
 271       return false;
 272     }
 273     length = parse_int(&quot;parse_tag_and_count&quot;);
 274     return !had_error();
 275   }
 276 
 277   // Parse a sequence of raw data encoded as bytes and return the
 278   // resulting data.
 279   char* parse_data(const char* tag, int&amp; length) {
 280     int read_size = 0;
 281     if (!parse_tag_and_count(tag, read_size)) {
 282       return NULL;
 283     }
 284 
 285     int actual_size = sizeof(MethodData);
 286     char *result = NEW_RESOURCE_ARRAY(char, actual_size);
 287     int i = 0;
 288     if (read_size != actual_size) {
 289       tty-&gt;print_cr(&quot;Warning: ciMethodData parsing sees MethodData size %i in file, current is %i&quot;, read_size,
 290                     actual_size);
 291       // Replay serializes the entire MethodData, but the data is at the end.
 292       // If the MethodData instance size has changed, we can pad or truncate in the beginning
 293       int padding = actual_size - read_size;
 294       if (padding &gt; 0) {
 295         // pad missing data with zeros
 296         tty-&gt;print_cr(&quot;- Padding MethodData&quot;);
 297         for (; i &lt; padding; i++) {
 298           result[i] = 0;
 299         }
 300       } else if (padding &lt; 0) {
 301         // drop some data
 302         tty-&gt;print_cr(&quot;- Truncating MethodData&quot;);
 303         for (int j = 0; j &lt; -padding; j++) {
 304           int val = parse_int(&quot;data&quot;);
 305           // discard val
 306         }
 307       }
 308     }
 309 
 310     assert(i &lt; actual_size, &quot;At least some data must remain to be copied&quot;);
 311     for (; i &lt; actual_size; i++) {
 312       int val = parse_int(&quot;data&quot;);
 313       result[i] = val;
 314     }
 315     length = actual_size;
 316     return result;
 317   }
 318 
 319   // Parse a standard chunk of data emitted as:
 320   //   &#39;tag&#39; &lt;length&gt; # # ...
 321   // Where each # is an intptr_t item
 322   intptr_t* parse_intptr_data(const char* tag, int&amp; length) {
 323     if (!parse_tag_and_count(tag, length)) {
 324       return NULL;
 325     }
 326 
 327     intptr_t* result = NEW_RESOURCE_ARRAY(intptr_t, length);
 328     for (int i = 0; i &lt; length; i++) {
 329       skip_ws();
 330       intptr_t val = parse_intptr_t(&quot;data&quot;);
 331       result[i] = val;
 332     }
 333     return result;
 334   }
 335 
 336   // Parse a possibly quoted version of a symbol into a symbolOop
 337   Symbol* parse_symbol(TRAPS) {
 338     const char* str = parse_escaped_string();
 339     if (str != NULL) {
 340       Symbol* sym = SymbolTable::new_symbol(str);
 341       return sym;
 342     }
 343     return NULL;
 344   }
 345 
 346   // Parse a valid klass name and look it up
 347   Klass* parse_klass(TRAPS) {
 348     const char* str = parse_escaped_string();
 349     Symbol* klass_name = SymbolTable::new_symbol(str);
 350     if (klass_name != NULL) {
 351       Klass* k = NULL;
 352       if (_iklass != NULL) {
 353         k = (Klass*)_iklass-&gt;find_klass(ciSymbol::make(klass_name-&gt;as_C_string()))-&gt;constant_encoding();
 354       } else {
 355         k = SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 356       }
 357       if (HAS_PENDING_EXCEPTION) {
 358         oop throwable = PENDING_EXCEPTION;
 359         java_lang_Throwable::print(throwable, tty);
 360         tty-&gt;cr();
 361         report_error(str);
 362         if (ReplayIgnoreInitErrors) {
 363           CLEAR_PENDING_EXCEPTION;
 364           _error_message = NULL;
 365         }
 366         return NULL;
 367       }
 368       return k;
 369     }
 370     return NULL;
 371   }
 372 
 373   // Lookup a klass
 374   Klass* resolve_klass(const char* klass, TRAPS) {
 375     Symbol* klass_name = SymbolTable::new_symbol(klass);
 376     return SystemDictionary::resolve_or_fail(klass_name, _loader, _protection_domain, true, THREAD);
 377   }
 378 
 379   // Parse the standard tuple of &lt;klass&gt; &lt;name&gt; &lt;signature&gt;
 380   Method* parse_method(TRAPS) {
 381     InstanceKlass* k = (InstanceKlass*)parse_klass(CHECK_NULL);
 382     if (k == NULL) {
 383       report_error(&quot;Can&#39;t find holder klass&quot;);
 384       return NULL;
 385     }
 386     Symbol* method_name = parse_symbol(CHECK_NULL);
 387     Symbol* method_signature = parse_symbol(CHECK_NULL);
 388     Method* m = k-&gt;find_method(method_name, method_signature);
 389     if (m == NULL) {
 390       report_error(&quot;Can&#39;t find method&quot;);
 391     }
 392     return m;
 393   }
 394 
 395   int get_line(int c) {
 396     while(c != EOF) {
 397       if (_buffer_pos + 1 &gt;= _buffer_length) {
 398         int new_length = _buffer_length * 2;
 399         // Next call will throw error in case of OOM.
 400         _buffer = REALLOC_RESOURCE_ARRAY(char, _buffer, _buffer_length, new_length);
 401         _buffer_length = new_length;
 402       }
 403       if (c == &#39;\n&#39;) {
 404         c = getc(_stream); // get next char
 405         break;
 406       } else if (c == &#39;\r&#39;) {
 407         // skip LF
 408       } else {
 409         _buffer[_buffer_pos++] = c;
 410       }
 411       c = getc(_stream);
 412     }
 413     // null terminate it, reset the pointer
 414     _buffer[_buffer_pos] = &#39;\0&#39;; // NL or EOF
 415     _buffer_pos = 0;
 416     _bufptr = _buffer;
 417     return c;
 418   }
 419 
 420   // Process each line of the replay file executing each command until
 421   // the file ends.
 422   void process(TRAPS) {
 423     int line_no = 1;
 424     int c = getc(_stream);
 425     while(c != EOF) {
 426       c = get_line(c);
 427       process_command(THREAD);
 428       if (had_error()) {
 429         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 430         if (ReplayIgnoreInitErrors) {
 431           CLEAR_PENDING_EXCEPTION;
 432           _error_message = NULL;
 433         } else {
 434           return;
 435         }
 436       }
 437       line_no++;
 438     }
 439   }
 440 
 441   void process_command(TRAPS) {
 442     char* cmd = parse_string();
 443     if (cmd == NULL) {
 444       return;
 445     }
 446     if (strcmp(&quot;#&quot;, cmd) == 0) {
 447       // ignore
 448     } else if (strcmp(&quot;compile&quot;, cmd) == 0) {
 449       process_compile(CHECK);
 450     } else if (strcmp(&quot;ciMethod&quot;, cmd) == 0) {
 451       process_ciMethod(CHECK);
 452     } else if (strcmp(&quot;ciMethodData&quot;, cmd) == 0) {
 453       process_ciMethodData(CHECK);
 454     } else if (strcmp(&quot;staticfield&quot;, cmd) == 0) {
 455       process_staticfield(CHECK);
 456     } else if (strcmp(&quot;ciInstanceKlass&quot;, cmd) == 0) {
 457       process_ciInstanceKlass(CHECK);
 458     } else if (strcmp(&quot;instanceKlass&quot;, cmd) == 0) {
 459       process_instanceKlass(CHECK);
 460 #if INCLUDE_JVMTI
 461     } else if (strcmp(&quot;JvmtiExport&quot;, cmd) == 0) {
 462       process_JvmtiExport(CHECK);
 463 #endif // INCLUDE_JVMTI
 464     } else {
 465       report_error(&quot;unknown command&quot;);
 466     }
 467   }
 468 
 469   // validation of comp_level
 470   bool is_valid_comp_level(int comp_level) {
 471     const int msg_len = 256;
 472     char* msg = NULL;
 473     if (!is_compile(comp_level)) {
 474       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 475       jio_snprintf(msg, msg_len, &quot;%d isn&#39;t compilation level&quot;, comp_level);
 476     } else if (!TieredCompilation &amp;&amp; (comp_level != CompLevel_highest_tier)) {
 477       msg = NEW_RESOURCE_ARRAY(char, msg_len);
 478       switch (comp_level) {
 479         case CompLevel_simple:
 480           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Client VM or TieredCompilation&quot;, comp_level);
 481           break;
 482         case CompLevel_full_optimization:
 483           jio_snprintf(msg, msg_len, &quot;compilation level %d requires Server VM&quot;, comp_level);
 484           break;
 485         default:
 486           jio_snprintf(msg, msg_len, &quot;compilation level %d requires TieredCompilation&quot;, comp_level);
 487       }
 488     }
 489     if (msg != NULL) {
 490       report_error(msg);
 491       return false;
 492     }
 493     return true;
 494   }
 495 
 496   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 497   void* process_inline(ciMethod* imethod, Method* m, int entry_bci, int comp_level, TRAPS) {
 498     _imethod    = m;
 499     _iklass     = imethod-&gt;holder();
 500     _entry_bci  = entry_bci;
 501     _comp_level = comp_level;
 502     int line_no = 1;
 503     int c = getc(_stream);
 504     while(c != EOF) {
 505       c = get_line(c);
 506       // Expecting only lines with &quot;compile&quot; command in inline replay file.
 507       char* cmd = parse_string();
 508       if (cmd == NULL || strcmp(&quot;compile&quot;, cmd) != 0) {
 509         return NULL;
 510       }
 511       process_compile(CHECK_NULL);
 512       if (had_error()) {
 513         tty-&gt;print_cr(&quot;Error while parsing line %d: %s\n&quot;, line_no, _error_message);
 514         tty-&gt;print_cr(&quot;%s&quot;, _buffer);
 515         return NULL;
 516       }
 517       if (_ci_inline_records != NULL &amp;&amp; _ci_inline_records-&gt;length() &gt; 0) {
 518         // Found inlining record for the requested method.
 519         return _ci_inline_records;
 520       }
 521       line_no++;
 522     }
 523     return NULL;
 524   }
 525 
 526   // compile &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;entry_bci&gt; &lt;comp_level&gt; inline &lt;count&gt; &lt;depth&gt; &lt;bci&gt; &lt;klass&gt; &lt;name&gt; &lt;signature&gt; ...
 527   void process_compile(TRAPS) {
 528     Method* method = parse_method(CHECK);
 529     if (had_error()) return;
 530     int entry_bci = parse_int(&quot;entry_bci&quot;);
 531     const char* comp_level_label = &quot;comp_level&quot;;
 532     int comp_level = parse_int(comp_level_label);
 533     // old version w/o comp_level
 534     if (had_error() &amp;&amp; (error_message() == comp_level_label)) {
 535       // use highest available tier
 536       if (TieredCompilation) {
 537         comp_level = TieredStopAtLevel;
 538       } else {
 539         comp_level = CompLevel_highest_tier;
 540       }
 541     }
 542     if (!is_valid_comp_level(comp_level)) {
 543       return;
 544     }
 545     if (_imethod != NULL) {
 546       // Replay Inlining
 547       if (entry_bci != _entry_bci || comp_level != _comp_level) {
 548         return;
 549       }
 550       const char* iklass_name  = _imethod-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 551       const char* imethod_name = _imethod-&gt;name()-&gt;as_utf8();
 552       const char* isignature   = _imethod-&gt;signature()-&gt;as_utf8();
 553       const char* klass_name   = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
 554       const char* method_name  = method-&gt;name()-&gt;as_utf8();
 555       const char* signature    = method-&gt;signature()-&gt;as_utf8();
 556       if (strcmp(iklass_name,  klass_name)  != 0 ||
 557           strcmp(imethod_name, method_name) != 0 ||
 558           strcmp(isignature,   signature)   != 0) {
 559         return;
 560       }
 561     }
 562     int inline_count = 0;
 563     if (parse_tag_and_count(&quot;inline&quot;, inline_count)) {
 564       // Record inlining data
 565       _ci_inline_records = new GrowableArray&lt;ciInlineRecord*&gt;();
 566       for (int i = 0; i &lt; inline_count; i++) {
 567         int depth = parse_int(&quot;inline_depth&quot;);
 568         int bci = parse_int(&quot;inline_bci&quot;);
 569         if (had_error()) {
 570           break;
 571         }
 572         Method* inl_method = parse_method(CHECK);
 573         if (had_error()) {
 574           break;
 575         }
 576         new_ciInlineRecord(inl_method, bci, depth);
 577       }
 578     }
 579     if (_imethod != NULL) {
 580       return; // Replay Inlining
 581     }
 582     InstanceKlass* ik = method-&gt;method_holder();
 583     ik-&gt;initialize(THREAD);
 584     if (HAS_PENDING_EXCEPTION) {
 585       oop throwable = PENDING_EXCEPTION;
 586       java_lang_Throwable::print(throwable, tty);
 587       tty-&gt;cr();
 588       if (ReplayIgnoreInitErrors) {
 589         CLEAR_PENDING_EXCEPTION;
 590         ik-&gt;set_init_state(InstanceKlass::fully_initialized);
 591       } else {
 592         return;
 593       }
 594     }
 595     // Make sure the existence of a prior compile doesn&#39;t stop this one
 596     CompiledMethod* nm = (entry_bci != InvocationEntryBci) ? method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) : method-&gt;code();
 597     if (nm != NULL) {
 598       nm-&gt;make_not_entrant();
 599     }
 600     replay_state = this;
 601     CompileBroker::compile_method(methodHandle(THREAD, method), entry_bci, comp_level,
 602                                   methodHandle(), 0, CompileTask::Reason_Replay, THREAD);
 603     replay_state = NULL;
 604     reset();
 605   }
 606 
 607   // ciMethod &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;invocation_counter&gt; &lt;backedge_counter&gt; &lt;interpreter_invocation_count&gt; &lt;interpreter_throwout_count&gt; &lt;instructions_size&gt;
 608   //
 609   //
 610   void process_ciMethod(TRAPS) {
 611     Method* method = parse_method(CHECK);
 612     if (had_error()) return;
 613     ciMethodRecord* rec = new_ciMethod(method);
 614     rec-&gt;_invocation_counter = parse_int(&quot;invocation_counter&quot;);
 615     rec-&gt;_backedge_counter = parse_int(&quot;backedge_counter&quot;);
 616     rec-&gt;_interpreter_invocation_count = parse_int(&quot;interpreter_invocation_count&quot;);
 617     rec-&gt;_interpreter_throwout_count = parse_int(&quot;interpreter_throwout_count&quot;);
 618     rec-&gt;_instructions_size = parse_int(&quot;instructions_size&quot;);
 619   }
 620 
 621   // ciMethodData &lt;klass&gt; &lt;name&gt; &lt;signature&gt; &lt;state&gt; &lt;current mileage&gt; orig &lt;length&gt; # # ... data &lt;length&gt; # # ... oops &lt;length&gt; # ... methods &lt;length&gt;
 622   void process_ciMethodData(TRAPS) {
 623     Method* method = parse_method(CHECK);
 624     if (had_error()) return;
 625     /* just copied from Method, to build interpret data*/
 626 
 627     // To be properly initialized, some profiling in the MDO needs the
 628     // method to be rewritten (number of arguments at a call for
 629     // instance)
 630     method-&gt;method_holder()-&gt;link_class(CHECK);
 631     // methodOopDesc::build_interpreter_method_data(method, CHECK);
 632     {
 633       // Grab a lock here to prevent multiple
 634       // MethodData*s from being created.
 635       MutexLocker ml(THREAD, MethodData_lock);
 636       if (method-&gt;method_data() == NULL) {
 637         ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
 638         MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);
 639         method-&gt;set_method_data(method_data);
 640       }
 641     }
 642 
 643     // collect and record all the needed information for later
 644     ciMethodDataRecord* rec = new_ciMethodData(method);
 645     rec-&gt;_state = parse_int(&quot;state&quot;);
 646     rec-&gt;_current_mileage = parse_int(&quot;current_mileage&quot;);
 647 
 648     rec-&gt;_orig_data = parse_data(&quot;orig&quot;, rec-&gt;_orig_data_length);
 649     if (rec-&gt;_orig_data == NULL) {
 650       return;
 651     }
 652     rec-&gt;_data = parse_intptr_data(&quot;data&quot;, rec-&gt;_data_length);
 653     if (rec-&gt;_data == NULL) {
 654       return;
 655     }
 656     if (!parse_tag_and_count(&quot;oops&quot;, rec-&gt;_classes_length)) {
 657       return;
 658     }
 659     rec-&gt;_classes = NEW_RESOURCE_ARRAY(Klass*, rec-&gt;_classes_length);
 660     rec-&gt;_classes_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_classes_length);
 661     for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
 662       int offset = parse_int(&quot;offset&quot;);
 663       if (had_error()) {
 664         return;
 665       }
 666       Klass* k = parse_klass(CHECK);
 667       rec-&gt;_classes_offsets[i] = offset;
 668       rec-&gt;_classes[i] = k;
 669     }
 670 
 671     if (!parse_tag_and_count(&quot;methods&quot;, rec-&gt;_methods_length)) {
 672       return;
 673     }
 674     rec-&gt;_methods = NEW_RESOURCE_ARRAY(Method*, rec-&gt;_methods_length);
 675     rec-&gt;_methods_offsets = NEW_RESOURCE_ARRAY(int, rec-&gt;_methods_length);
 676     for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
 677       int offset = parse_int(&quot;offset&quot;);
 678       if (had_error()) {
 679         return;
 680       }
 681       Method* m = parse_method(CHECK);
 682       rec-&gt;_methods_offsets[i] = offset;
 683       rec-&gt;_methods[i] = m;
 684     }
 685   }
 686 
 687   // instanceKlass &lt;name&gt;
 688   //
 689   // Loads and initializes the klass &#39;name&#39;.  This can be used to
 690   // create particular class loading environments
 691   void process_instanceKlass(TRAPS) {
 692     // just load the referenced class
 693     Klass* k = parse_klass(CHECK);
 694   }
 695 
 696   // ciInstanceKlass &lt;name&gt; &lt;is_linked&gt; &lt;is_initialized&gt; &lt;length&gt; tag # # # ...
 697   //
 698   // Load the klass &#39;name&#39; and link or initialize it.  Verify that the
 699   // constant pool is the same length as &#39;length&#39; and make sure the
 700   // constant pool tags are in the same state.
 701   void process_ciInstanceKlass(TRAPS) {
 702     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 703     if (k == NULL) {
 704       return;
 705     }
 706     int is_linked = parse_int(&quot;is_linked&quot;);
 707     int is_initialized = parse_int(&quot;is_initialized&quot;);
 708     int length = parse_int(&quot;length&quot;);
 709     if (is_initialized) {
 710       k-&gt;initialize(THREAD);
 711       if (HAS_PENDING_EXCEPTION) {
 712         oop throwable = PENDING_EXCEPTION;
 713         java_lang_Throwable::print(throwable, tty);
 714         tty-&gt;cr();
 715         if (ReplayIgnoreInitErrors) {
 716           CLEAR_PENDING_EXCEPTION;
 717           k-&gt;set_init_state(InstanceKlass::fully_initialized);
 718         } else {
 719           return;
 720         }
 721       }
 722     } else if (is_linked) {
 723       k-&gt;link_class(CHECK);
 724     }
 725     ConstantPool* cp = k-&gt;constants();
 726     if (length != cp-&gt;length()) {
 727       report_error(&quot;constant pool length mismatch: wrong class files?&quot;);
 728       return;
 729     }
 730 
 731     int parsed_two_word = 0;
 732     for (int i = 1; i &lt; length; i++) {
 733       int tag = parse_int(&quot;tag&quot;);
 734       if (had_error()) {
 735         return;
 736       }
 737       switch (cp-&gt;tag_at(i).value()) {
 738         case JVM_CONSTANT_UnresolvedClass: {
 739           if (tag == JVM_CONSTANT_Class) {
 740             tty-&gt;print_cr(&quot;Resolving klass %s at %d&quot;, cp-&gt;klass_name_at(i)-&gt;as_utf8(), i);
 741             Klass* k = cp-&gt;klass_at(i, CHECK);
 742           }
 743           break;
 744         }
 745 
 746         case JVM_CONSTANT_Long:
 747         case JVM_CONSTANT_Double:
 748           parsed_two_word = i + 1;
 749 
 750         case JVM_CONSTANT_ClassIndex:
 751         case JVM_CONSTANT_StringIndex:
 752         case JVM_CONSTANT_String:
 753         case JVM_CONSTANT_UnresolvedClassInError:
 754         case JVM_CONSTANT_Fieldref:
 755         case JVM_CONSTANT_Methodref:
 756         case JVM_CONSTANT_InterfaceMethodref:
 757         case JVM_CONSTANT_NameAndType:
 758         case JVM_CONSTANT_Utf8:
 759         case JVM_CONSTANT_Integer:
 760         case JVM_CONSTANT_Float:
 761         case JVM_CONSTANT_MethodHandle:
 762         case JVM_CONSTANT_MethodType:
 763         case JVM_CONSTANT_Dynamic:
 764         case JVM_CONSTANT_InvokeDynamic:
 765           if (tag != cp-&gt;tag_at(i).value()) {
 766             report_error(&quot;tag mismatch: wrong class files?&quot;);
 767             return;
 768           }
 769           break;
 770 
 771         case JVM_CONSTANT_Class:
 772           if (tag == JVM_CONSTANT_Class) {
 773           } else if (tag == JVM_CONSTANT_UnresolvedClass) {
 774             tty-&gt;print_cr(&quot;Warning: entry was unresolved in the replay data&quot;);
 775           } else {
 776             report_error(&quot;Unexpected tag&quot;);
 777             return;
 778           }
 779           break;
 780 
 781         case 0:
 782           if (parsed_two_word == i) continue;
 783 
 784         default:
 785           fatal(&quot;Unexpected tag: %d&quot;, cp-&gt;tag_at(i).value());
 786           break;
 787       }
 788 
 789     }
 790   }
 791 
 792   class ValueTypeFieldInitializer : public FieldClosure {
 793     oop _vt;
 794     CompileReplay* _replay;
 795   public:
 796     ValueTypeFieldInitializer(oop vt, CompileReplay* replay)
 797   : _vt(vt), _replay(replay) {}
 798 
 799     void do_field(fieldDescriptor* fd) {
 800       BasicType bt = fd-&gt;field_type();
 801       const char* string_value = bt != T_VALUETYPE ? _replay-&gt;parse_escaped_string() : NULL;
 802       switch (bt) {
 803       case T_BYTE: {
 804         int value = atoi(string_value);
 805         _vt-&gt;byte_field_put(fd-&gt;offset(), value);
 806         break;
 807       }
 808       case T_BOOLEAN: {
 809         int value = atoi(string_value);
 810         _vt-&gt;bool_field_put(fd-&gt;offset(), value);
 811         break;
 812       }
 813       case T_SHORT: {
 814         int value = atoi(string_value);
 815         _vt-&gt;short_field_put(fd-&gt;offset(), value);
 816         break;
 817       }
 818       case T_CHAR: {
 819         int value = atoi(string_value);
 820         _vt-&gt;char_field_put(fd-&gt;offset(), value);
 821         break;
 822       }
 823       case T_INT: {
 824         int value = atoi(string_value);
 825         _vt-&gt;int_field_put(fd-&gt;offset(), value);
 826         break;
 827       }
 828       case T_LONG: {
 829         jlong value;
 830         if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 831           fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 832           break;
 833         }
 834         _vt-&gt;long_field_put(fd-&gt;offset(), value);
 835         break;
 836       }
 837       case T_FLOAT: {
 838         float value = atof(string_value);
 839         _vt-&gt;float_field_put(fd-&gt;offset(), value);
 840         break;
 841       }
 842       case T_DOUBLE: {
 843         double value = atof(string_value);
 844         _vt-&gt;double_field_put(fd-&gt;offset(), value);
 845         break;
 846       }
 847       case T_ARRAY:
 848       case T_OBJECT: {
 849         Thread* THREAD = Thread::current();
 850         bool res = _replay-&gt;process_staticfield_reference(string_value, _vt, fd, THREAD);
 851         assert(res, &quot;should succeed for arrays &amp; objects&quot;);
 852         break;
 853       }
 854       case T_VALUETYPE: {
 855         SignatureStream ss(fd-&gt;signature(), false);
 856         ValueKlass* vk = ss.as_value_klass(fd-&gt;field_holder());
 857         if (fd-&gt;is_flattened()) {
 858           int field_offset = fd-&gt;offset() - vk-&gt;first_field_offset();
 859           oop obj = (oop)(cast_from_oop&lt;address&gt;(_vt) + field_offset);
 860           ValueTypeFieldInitializer init_fields(obj, _replay);
 861           vk-&gt;do_nonstatic_fields(&amp;init_fields);
 862         } else {
 863           oop value = vk-&gt;allocate_instance(Thread::current());
 864           _vt-&gt;obj_field_put(fd-&gt;offset(), value);
 865         }
 866         break;
 867       }
 868       default: {
 869         fatal(&quot;Unhandled type: %s&quot;, type2name(bt));
 870       }
 871       }
 872     }
 873   };
 874 
 875   bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {
 876     if (field_signature[0] == JVM_SIGNATURE_ARRAY) {
 877       int length = parse_int(&quot;array length&quot;);
 878       oop value = NULL;
 879 
 880       if (field_signature[1] == JVM_SIGNATURE_ARRAY) {
 881         // multi dimensional array
 882         Klass* k = resolve_klass(field_signature, CHECK_(true));
 883         ArrayKlass* kelem = (ArrayKlass *)k;
 884         int rank = 0;
 885         while (field_signature[rank] == JVM_SIGNATURE_ARRAY) {
 886           rank++;
 887         }
 888         jint* dims = NEW_RESOURCE_ARRAY(jint, rank);
 889         dims[0] = length;
 890         for (int i = 1; i &lt; rank; i++) {
 891           dims[i] = 1; // These aren&#39;t relevant to the compiler
 892         }
 893         value = kelem-&gt;multi_allocate(rank, dims, CHECK_(true));
 894       } else {
 895         if (strcmp(field_signature, &quot;[B&quot;) == 0) {
 896           value = oopFactory::new_byteArray(length, CHECK_(true));
 897         } else if (strcmp(field_signature, &quot;[Z&quot;) == 0) {
 898           value = oopFactory::new_boolArray(length, CHECK_(true));
 899         } else if (strcmp(field_signature, &quot;[C&quot;) == 0) {
 900           value = oopFactory::new_charArray(length, CHECK_(true));
 901         } else if (strcmp(field_signature, &quot;[S&quot;) == 0) {
 902           value = oopFactory::new_shortArray(length, CHECK_(true));
 903         } else if (strcmp(field_signature, &quot;[F&quot;) == 0) {
 904           value = oopFactory::new_floatArray(length, CHECK_(true));
 905         } else if (strcmp(field_signature, &quot;[D&quot;) == 0) {
 906           value = oopFactory::new_doubleArray(length, CHECK_(true));
 907         } else if (strcmp(field_signature, &quot;[I&quot;) == 0) {
 908           value = oopFactory::new_intArray(length, CHECK_(true));
 909         } else if (strcmp(field_signature, &quot;[J&quot;) == 0) {
 910           value = oopFactory::new_longArray(length, CHECK_(true));
 911         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;
 912                    field_signature[1] == JVM_SIGNATURE_CLASS) {
 913           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
 914           value = oopFactory::new_objArray(kelem, length, CHECK_(true));
 915         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &amp;&amp;
 916                    field_signature[1] == JVM_SIGNATURE_VALUETYPE) {
 917           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
 918           value = oopFactory::new_valueArray(kelem, length, CHECK_(true));
 919         } else {
 920           report_error(&quot;unhandled array staticfield&quot;);
 921         }
 922       }
 923       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value);
 924       return true;
 925     } else if (strcmp(field_signature, &quot;Ljava/lang/String;&quot;) == 0) {
 926       const char* string_value = parse_escaped_string();
 927       Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));
 928       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value());
 929       return true;
 930     } else if (field_signature[0] == &#39;L&#39;) {
 931       const char* instance = parse_escaped_string();
 932       Klass* k = resolve_klass(instance, CHECK_(true));
 933       oop value = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK_(true));
 934       java_mirror-&gt;obj_field_put(fd-&gt;offset(), value);
 935       return true;
 936     }
 937     return false;
 938   }
 939 
 940   // Initialize a class and fill in the value for a static field.
 941   // This is useful when the compile was dependent on the value of
 942   // static fields but it&#39;s impossible to properly rerun the static
 943   // initializer.
 944   void process_staticfield(TRAPS) {
 945     InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);
 946 
 947     if (k == NULL || ReplaySuppressInitializers == 0 ||
 948         (ReplaySuppressInitializers == 2 &amp;&amp; k-&gt;class_loader() == NULL)) {
 949       return;
 950     }
 951 
 952     assert(k-&gt;is_initialized(), &quot;must be&quot;);
 953 
 954     const char* field_name = parse_escaped_string();
 955     const char* field_signature = parse_string();
 956     fieldDescriptor fd;
 957     Symbol* name = SymbolTable::new_symbol(field_name);
 958     Symbol* sig = SymbolTable::new_symbol(field_signature);
 959     if (!k-&gt;find_local_field(name, sig, &amp;fd) ||
 960         !fd.is_static() ||
 961         fd.has_initial_value()) {
 962       report_error(field_name);
 963       return;
 964     }
 965 
 966     oop java_mirror = k-&gt;java_mirror();
 967     if (strcmp(field_signature, &quot;I&quot;) == 0) {
 968       const char* string_value = parse_escaped_string();
 969       int value = atoi(string_value);
 970       java_mirror-&gt;int_field_put(fd.offset(), value);
 971     } else if (strcmp(field_signature, &quot;B&quot;) == 0) {
 972       const char* string_value = parse_escaped_string();
 973       int value = atoi(string_value);
 974       java_mirror-&gt;byte_field_put(fd.offset(), value);
 975     } else if (strcmp(field_signature, &quot;C&quot;) == 0) {
 976       const char* string_value = parse_escaped_string();
 977       int value = atoi(string_value);
 978       java_mirror-&gt;char_field_put(fd.offset(), value);
 979     } else if (strcmp(field_signature, &quot;S&quot;) == 0) {
 980       const char* string_value = parse_escaped_string();
 981       int value = atoi(string_value);
 982       java_mirror-&gt;short_field_put(fd.offset(), value);
 983     } else if (strcmp(field_signature, &quot;Z&quot;) == 0) {
 984       const char* string_value = parse_escaped_string();
 985       int value = atoi(string_value);
 986       java_mirror-&gt;bool_field_put(fd.offset(), value);
 987     } else if (strcmp(field_signature, &quot;J&quot;) == 0) {
 988       const char* string_value = parse_escaped_string();
 989       jlong value;
 990       if (sscanf(string_value, JLONG_FORMAT, &amp;value) != 1) {
 991         fprintf(stderr, &quot;Error parsing long: %s\n&quot;, string_value);
 992         return;
 993       }
 994       java_mirror-&gt;long_field_put(fd.offset(), value);
 995     } else if (strcmp(field_signature, &quot;F&quot;) == 0) {
 996       const char* string_value = parse_escaped_string();
 997       float value = atof(string_value);
 998       java_mirror-&gt;float_field_put(fd.offset(), value);
 999     } else if (strcmp(field_signature, &quot;D&quot;) == 0) {
1000       const char* string_value = parse_escaped_string();
1001       double value = atof(string_value);
1002       java_mirror-&gt;double_field_put(fd.offset(), value);
1003     } else if (field_signature[0] == JVM_SIGNATURE_VALUETYPE) {
1004       Klass* kelem = resolve_klass(field_signature, CHECK);
1005       ValueKlass* vk = ValueKlass::cast(kelem);
1006       oop value = vk-&gt;allocate_instance(CHECK);
1007       ValueTypeFieldInitializer init_fields(value, this);
1008       vk-&gt;do_nonstatic_fields(&amp;init_fields);
1009       java_mirror-&gt;obj_field_put(fd.offset(), value);
1010     } else {
1011       bool res = process_staticfield_reference(field_signature, java_mirror, &amp;fd, CHECK);
1012       if (!res)  {
1013         report_error(&quot;unhandled staticfield&quot;);
1014       }
1015     }
1016   }
1017 
1018 #if INCLUDE_JVMTI
1019   void process_JvmtiExport(TRAPS) {
1020     const char* field = parse_string();
1021     bool value = parse_int(&quot;JvmtiExport flag&quot;) != 0;
1022     if (strcmp(field, &quot;can_access_local_variables&quot;) == 0) {
1023       JvmtiExport::set_can_access_local_variables(value);
1024     } else if (strcmp(field, &quot;can_hotswap_or_post_breakpoint&quot;) == 0) {
1025       JvmtiExport::set_can_hotswap_or_post_breakpoint(value);
1026     } else if (strcmp(field, &quot;can_post_on_exceptions&quot;) == 0) {
1027       JvmtiExport::set_can_post_on_exceptions(value);
1028     } else {
1029       report_error(&quot;Unrecognized JvmtiExport directive&quot;);
1030     }
1031   }
1032 #endif // INCLUDE_JVMTI
1033 
1034   // Create and initialize a record for a ciMethod
1035   ciMethodRecord* new_ciMethod(Method* method) {
1036     ciMethodRecord* rec = NEW_RESOURCE_OBJ(ciMethodRecord);
1037     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1038     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1039     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1040     _ci_method_records.append(rec);
1041     return rec;
1042   }
1043 
1044   // Lookup data for a ciMethod
1045   ciMethodRecord* find_ciMethodRecord(Method* method) {
1046     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1047     const char* method_name = method-&gt;name()-&gt;as_utf8();
1048     const char* signature = method-&gt;signature()-&gt;as_utf8();
1049     for (int i = 0; i &lt; _ci_method_records.length(); i++) {
1050       ciMethodRecord* rec = _ci_method_records.at(i);
1051       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
1052           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
1053           strcmp(rec-&gt;_signature, signature) == 0) {
1054         return rec;
1055       }
1056     }
1057     return NULL;
1058   }
1059 
1060   // Create and initialize a record for a ciMethodData
1061   ciMethodDataRecord* new_ciMethodData(Method* method) {
1062     ciMethodDataRecord* rec = NEW_RESOURCE_OBJ(ciMethodDataRecord);
1063     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1064     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1065     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1066     _ci_method_data_records.append(rec);
1067     return rec;
1068   }
1069 
1070   // Lookup data for a ciMethodData
1071   ciMethodDataRecord* find_ciMethodDataRecord(Method* method) {
1072     const char* klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1073     const char* method_name = method-&gt;name()-&gt;as_utf8();
1074     const char* signature = method-&gt;signature()-&gt;as_utf8();
1075     for (int i = 0; i &lt; _ci_method_data_records.length(); i++) {
1076       ciMethodDataRecord* rec = _ci_method_data_records.at(i);
1077       if (strcmp(rec-&gt;_klass_name, klass_name) == 0 &amp;&amp;
1078           strcmp(rec-&gt;_method_name, method_name) == 0 &amp;&amp;
1079           strcmp(rec-&gt;_signature, signature) == 0) {
1080         return rec;
1081       }
1082     }
1083     return NULL;
1084   }
1085 
1086   // Create and initialize a record for a ciInlineRecord
1087   ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {
1088     ciInlineRecord* rec = NEW_RESOURCE_OBJ(ciInlineRecord);
1089     rec-&gt;_klass_name =  method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1090     rec-&gt;_method_name = method-&gt;name()-&gt;as_utf8();
1091     rec-&gt;_signature = method-&gt;signature()-&gt;as_utf8();
1092     rec-&gt;_inline_bci = bci;
1093     rec-&gt;_inline_depth = depth;
1094     _ci_inline_records-&gt;append(rec);
1095     return rec;
1096   }
1097 
1098   // Lookup inlining data for a ciMethod
1099   ciInlineRecord* find_ciInlineRecord(Method* method, int bci, int depth) {
1100     if (_ci_inline_records != NULL) {
1101       return find_ciInlineRecord(_ci_inline_records, method, bci, depth);
1102     }
1103     return NULL;
1104   }
1105 
1106   static ciInlineRecord* find_ciInlineRecord(GrowableArray&lt;ciInlineRecord*&gt;*  records,
1107                                       Method* method, int bci, int depth) {
1108     if (records != NULL) {
1109       const char* klass_name  = method-&gt;method_holder()-&gt;name()-&gt;as_utf8();
1110       const char* method_name = method-&gt;name()-&gt;as_utf8();
1111       const char* signature   = method-&gt;signature()-&gt;as_utf8();
1112       for (int i = 0; i &lt; records-&gt;length(); i++) {
1113         ciInlineRecord* rec = records-&gt;at(i);
1114         if ((rec-&gt;_inline_bci == bci) &amp;&amp;
1115             (rec-&gt;_inline_depth == depth) &amp;&amp;
1116             (strcmp(rec-&gt;_klass_name, klass_name) == 0) &amp;&amp;
1117             (strcmp(rec-&gt;_method_name, method_name) == 0) &amp;&amp;
1118             (strcmp(rec-&gt;_signature, signature) == 0)) {
1119           return rec;
1120         }
1121       }
1122     }
1123     return NULL;
1124   }
1125 
1126   const char* error_message() {
1127     return _error_message;
1128   }
1129 
1130   void reset() {
1131     _error_message = NULL;
1132     _ci_method_records.clear();
1133     _ci_method_data_records.clear();
1134   }
1135 
1136   // Take an ascii string contain \u#### escapes and convert it to utf8
1137   // in place.
1138   static void unescape_string(char* value) {
1139     char* from = value;
1140     char* to = value;
1141     while (*from != &#39;\0&#39;) {
1142       if (*from != &#39;\\&#39;) {
1143         *from++ = *to++;
1144       } else {
1145         switch (from[1]) {
1146           case &#39;u&#39;: {
1147             from += 2;
1148             jchar value=0;
1149             for (int i=0; i&lt;4; i++) {
1150               char c = *from++;
1151               switch (c) {
1152                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
1153                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
1154                   value = (value &lt;&lt; 4) + c - &#39;0&#39;;
1155                   break;
1156                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;:
1157                 case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
1158                   value = (value &lt;&lt; 4) + 10 + c - &#39;a&#39;;
1159                   break;
1160                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;:
1161                 case &#39;D&#39;: case &#39;E&#39;: case &#39;F&#39;:
1162                   value = (value &lt;&lt; 4) + 10 + c - &#39;A&#39;;
1163                   break;
1164                 default:
1165                   ShouldNotReachHere();
1166               }
1167             }
1168             UNICODE::convert_to_utf8(&amp;value, 1, to);
1169             to++;
1170             break;
1171           }
1172           case &#39;t&#39;: *to++ = &#39;\t&#39;; from += 2; break;
1173           case &#39;n&#39;: *to++ = &#39;\n&#39;; from += 2; break;
1174           case &#39;r&#39;: *to++ = &#39;\r&#39;; from += 2; break;
1175           case &#39;f&#39;: *to++ = &#39;\f&#39;; from += 2; break;
1176           default:
1177             ShouldNotReachHere();
1178         }
1179       }
1180     }
1181     *from = *to;
1182   }
1183 };
1184 
1185 void ciReplay::replay(TRAPS) {
1186   int exit_code = replay_impl(THREAD);
1187 
1188   Threads::destroy_vm();
1189 
1190   vm_exit(exit_code);
1191 }
1192 
1193 void* ciReplay::load_inline_data(ciMethod* method, int entry_bci, int comp_level) {
1194   if (FLAG_IS_DEFAULT(InlineDataFile)) {
1195     tty-&gt;print_cr(&quot;ERROR: no inline replay data file specified (use -XX:InlineDataFile=inline_pid12345.txt).&quot;);
1196     return NULL;
1197   }
1198 
1199   VM_ENTRY_MARK;
1200   // Load and parse the replay data
1201   CompileReplay rp(InlineDataFile, THREAD);
1202   if (!rp.can_replay()) {
1203     tty-&gt;print_cr(&quot;ciReplay: !rp.can_replay()&quot;);
1204     return NULL;
1205   }
1206   void* data = rp.process_inline(method, method-&gt;get_Method(), entry_bci, comp_level, THREAD);
1207   if (HAS_PENDING_EXCEPTION) {
1208     Handle throwable(THREAD, PENDING_EXCEPTION);
1209     CLEAR_PENDING_EXCEPTION;
1210     java_lang_Throwable::print_stack_trace(throwable, tty);
1211     tty-&gt;cr();
1212     return NULL;
1213   }
1214 
1215   if (rp.had_error()) {
1216     tty-&gt;print_cr(&quot;ciReplay: Failed on %s&quot;, rp.error_message());
1217     return NULL;
1218   }
1219   return data;
1220 }
1221 
1222 int ciReplay::replay_impl(TRAPS) {
1223   HandleMark hm;
1224   ResourceMark rm;
1225 
1226   if (ReplaySuppressInitializers &gt; 2) {
1227     // ReplaySuppressInitializers &gt; 2 means that we want to allow
1228     // normal VM bootstrap but once we get into the replay itself
1229     // don&#39;t allow any intializers to be run.
1230     ReplaySuppressInitializers = 1;
1231   }
1232 
1233   if (FLAG_IS_DEFAULT(ReplayDataFile)) {
1234     tty-&gt;print_cr(&quot;ERROR: no compiler replay data file specified (use -XX:ReplayDataFile=replay_pid12345.txt).&quot;);
1235     return 1;
1236   }
1237 
1238   // Load and parse the replay data
1239   CompileReplay rp(ReplayDataFile, THREAD);
1240   int exit_code = 0;
1241   if (rp.can_replay()) {
1242     rp.process(THREAD);
1243   } else {
1244     exit_code = 1;
1245     return exit_code;
1246   }
1247 
1248   if (HAS_PENDING_EXCEPTION) {
1249     Handle throwable(THREAD, PENDING_EXCEPTION);
1250     CLEAR_PENDING_EXCEPTION;
1251     java_lang_Throwable::print_stack_trace(throwable, tty);
1252     tty-&gt;cr();
1253     exit_code = 2;
1254   }
1255 
1256   if (rp.had_error()) {
1257     tty-&gt;print_cr(&quot;Failed on %s&quot;, rp.error_message());
1258     exit_code = 1;
1259   }
1260   return exit_code;
1261 }
1262 
1263 void ciReplay::initialize(ciMethodData* m) {
1264   if (replay_state == NULL) {
1265     return;
1266   }
1267 
1268   ASSERT_IN_VM;
1269   ResourceMark rm;
1270 
1271   Method* method = m-&gt;get_MethodData()-&gt;method();
1272   ciMethodDataRecord* rec = replay_state-&gt;find_ciMethodDataRecord(method);
1273   if (rec == NULL) {
1274     // This indicates some mismatch with the original environment and
1275     // the replay environment though it&#39;s not always enough to
1276     // interfere with reproducing a bug
1277     tty-&gt;print_cr(&quot;Warning: requesting ciMethodData record for method with no data: &quot;);
1278     method-&gt;print_name(tty);
1279     tty-&gt;cr();
1280   } else {
1281     m-&gt;_state = rec-&gt;_state;
1282     m-&gt;_current_mileage = rec-&gt;_current_mileage;
1283     if (rec-&gt;_data_length != 0) {
1284       assert(m-&gt;_data_size + m-&gt;_extra_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]) ||
1285              m-&gt;_data_size == rec-&gt;_data_length * (int)sizeof(rec-&gt;_data[0]), &quot;must agree&quot;);
1286 
1287       // Write the correct ciObjects back into the profile data
1288       ciEnv* env = ciEnv::current();
1289       for (int i = 0; i &lt; rec-&gt;_classes_length; i++) {
1290         Klass *k = rec-&gt;_classes[i];
1291         // In case this class pointer is is tagged, preserve the tag bits
1292         intptr_t status = 0;
1293         if (k != NULL) {
1294           status = ciTypeEntries::with_status(env-&gt;get_metadata(k)-&gt;as_klass(), rec-&gt;_data[rec-&gt;_classes_offsets[i]]);
1295         }
1296         rec-&gt;_data[rec-&gt;_classes_offsets[i]] = status;
1297       }
1298       for (int i = 0; i &lt; rec-&gt;_methods_length; i++) {
1299         Method *m = rec-&gt;_methods[i];
1300         *(ciMetadata**)(rec-&gt;_data + rec-&gt;_methods_offsets[i]) =
1301           env-&gt;get_metadata(m);
1302       }
1303       // Copy the updated profile data into place as intptr_ts
1304 #ifdef _LP64
1305       Copy::conjoint_jlongs_atomic((jlong *)rec-&gt;_data, (jlong *)m-&gt;_data, rec-&gt;_data_length);
1306 #else
1307       Copy::conjoint_jints_atomic((jint *)rec-&gt;_data, (jint *)m-&gt;_data, rec-&gt;_data_length);
1308 #endif
1309     }
1310 
1311     // copy in the original header
1312     Copy::conjoint_jbytes(rec-&gt;_orig_data, (char*)&amp;m-&gt;_orig, rec-&gt;_orig_data_length);
1313   }
1314 }
1315 
1316 
1317 bool ciReplay::should_not_inline(ciMethod* method) {
1318   if (replay_state == NULL) {
1319     return false;
1320   }
1321   VM_ENTRY_MARK;
1322   // ciMethod without a record shouldn&#39;t be inlined.
1323   return replay_state-&gt;find_ciMethodRecord(method-&gt;get_Method()) == NULL;
1324 }
1325 
1326 bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1327   if (data != NULL) {
1328     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1329     VM_ENTRY_MARK;
1330     // Inline record are ordered by bci and depth.
1331     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) != NULL;
1332   } else if (replay_state != NULL) {
1333     VM_ENTRY_MARK;
1334     // Inline record are ordered by bci and depth.
1335     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) != NULL;
1336   }
1337   return false;
1338 }
1339 
1340 bool ciReplay::should_not_inline(void* data, ciMethod* method, int bci, int inline_depth) {
1341   if (data != NULL) {
1342     GrowableArray&lt;ciInlineRecord*&gt;*  records = (GrowableArray&lt;ciInlineRecord*&gt;*)data;
1343     VM_ENTRY_MARK;
1344     // Inline record are ordered by bci and depth.
1345     return CompileReplay::find_ciInlineRecord(records, method-&gt;get_Method(), bci, inline_depth) == NULL;
1346   } else if (replay_state != NULL) {
1347     VM_ENTRY_MARK;
1348     // Inline record are ordered by bci and depth.
1349     return replay_state-&gt;find_ciInlineRecord(method-&gt;get_Method(), bci, inline_depth) == NULL;
1350   }
1351   return false;
1352 }
1353 
1354 void ciReplay::initialize(ciMethod* m) {
1355   if (replay_state == NULL) {
1356     return;
1357   }
1358 
1359   ASSERT_IN_VM;
1360   ResourceMark rm;
1361 
1362   Method* method = m-&gt;get_Method();
1363   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1364   if (rec == NULL) {
1365     // This indicates some mismatch with the original environment and
1366     // the replay environment though it&#39;s not always enough to
1367     // interfere with reproducing a bug
1368     tty-&gt;print_cr(&quot;Warning: requesting ciMethod record for method with no data: &quot;);
1369     method-&gt;print_name(tty);
1370     tty-&gt;cr();
1371   } else {
1372     EXCEPTION_CONTEXT;
1373     // m-&gt;_instructions_size = rec-&gt;_instructions_size;
1374     m-&gt;_instructions_size = -1;
1375     m-&gt;_interpreter_invocation_count = rec-&gt;_interpreter_invocation_count;
1376     m-&gt;_interpreter_throwout_count = rec-&gt;_interpreter_throwout_count;
1377     MethodCounters* mcs = method-&gt;get_method_counters(CHECK_AND_CLEAR);
1378     guarantee(mcs != NULL, &quot;method counters allocation failed&quot;);
1379     mcs-&gt;invocation_counter()-&gt;_counter = rec-&gt;_invocation_counter;
1380     mcs-&gt;backedge_counter()-&gt;_counter = rec-&gt;_backedge_counter;
1381   }
1382 }
1383 
1384 bool ciReplay::is_loaded(Method* method) {
1385   if (replay_state == NULL) {
1386     return true;
1387   }
1388 
1389   ASSERT_IN_VM;
1390   ResourceMark rm;
1391 
1392   ciMethodRecord* rec = replay_state-&gt;find_ciMethodRecord(method);
1393   return rec != NULL;
1394 }
1395 #endif // PRODUCT
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../src/hotspot/share/runtime/fieldDescriptor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorld.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33  * @summary Test value type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.valuetypes.ValueTypeTest
  41  *                               compiler.valhalla.valuetypes.TestArrays
  42  */
  43 public class TestArrays extends ValueTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         int CompLevel_none              = 0,         // Interpreter
  48             CompLevel_simple            = 1,         // C1
  49             CompLevel_limited_profile   = 2,         // C1, invocation &amp; backedge counters
  50             CompLevel_full_profile      = 3,         // C1, invocation &amp; backedge counters + mdo
  51             CompLevel_full_optimization = 4;         // C2 or JVMCI
  52 
<span class="line-modified">  53         if (USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;</span>
  54             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= CompLevel_full_optimization) {
  55             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  56         }
  57     }
  58 
  59     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  60     @Override
  61     public String[] getExtraVMParameters(int scenario) {
  62         switch (scenario) {
  63         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  64         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;, &quot;-XX:-UncommonNullCast&quot;};
  65         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  66         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  67         }
  68         return null;
  69     }
  70 
  71     public static void main(String[] args) throws Throwable {
  72         TestArrays test = new TestArrays();
  73         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
</pre>
<hr />
<pre>
 860             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 861         }
 862     }
 863 
 864     static void verify(MyValue2[] src, MyValue2[] dst) {
 865         for (int i = 0; i &lt; src.length; ++i) {
 866             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 867         }
 868     }
 869 
 870     static void verify(MyValue2[] src, Object[] dst) {
 871         for (int i = 0; i &lt; src.length; ++i) {
 872             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 873         }
 874     }
 875 
 876     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
 877         if (!warmup) {
 878             Method m = tests.get(test);
 879             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false)) {
<span class="line-modified"> 880                 if (!ValueTypeArrayFlatten &amp;&amp; !XCOMP) {</span>
 881                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
 882                 }
 883                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 884                 return true;
 885             }
 886         }
 887         return false;
 888     }
 889 
 890     // arraycopy() of value type array of unknown size
 891     @Test
 892     public void test35(Object src, Object dst, int len) {
 893         System.arraycopy(src, 0, dst, 0, len);
 894     }
 895 
 896     @DontCompile
 897     public void test35_verifier(boolean warmup) {
 898         int len = Math.abs(rI) % 10;
 899         MyValue1[] src = new MyValue1[len];
 900         MyValue1[] dst = new MyValue1[len];
</pre>
<hr />
<pre>
 956     public void test38(Object src, MyValue2[] dst) {
 957         System.arraycopy(src, 0, dst, 0, dst.length);
 958     }
 959 
 960     @DontCompile
 961     public void test38_verifier(boolean warmup) {
 962         int len = Math.abs(rI) % 10;
 963         Object[] src = new Object[len];
 964         MyValue2[] dst = new MyValue2[len];
 965         for (int i = 0; i &lt; len; ++i) {
 966             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 967         }
 968         test38(src, dst);
 969         verify(dst, src);
 970         if (!warmup) {
 971             Method m = tests.get(&quot;TestArrays::test38&quot;);
 972             assertDeoptimizedByC2(m);
 973             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 974             test38(src, dst);
 975             verify(dst, src);
<span class="line-modified"> 976             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
 977                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 978             }
 979         }
 980     }
 981 
 982     @Test
 983     public void test39(MyValue2[] src, Object dst) {
 984         System.arraycopy(src, 0, dst, 0, src.length);
 985     }
 986 
 987     @DontCompile
 988     public void test39_verifier(boolean warmup) {
 989         int len = Math.abs(rI) % 10;
 990         MyValue2[] src = new MyValue2[len];
 991         Object[] dst = new Object[len];
 992         for (int i = 0; i &lt; len; ++i) {
 993             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 994         }
 995         test39(src, dst);
 996         verify(src, dst);
</pre>
<hr />
<pre>
1005     public void test40(Object[] src, Object dst) {
1006         System.arraycopy(src, 0, dst, 0, src.length);
1007     }
1008 
1009     @DontCompile
1010     public void test40_verifier(boolean warmup) {
1011         int len = Math.abs(rI) % 10;
1012         Object[] src = new Object[len];
1013         MyValue2[] dst = new MyValue2[len];
1014         for (int i = 0; i &lt; len; ++i) {
1015             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1016         }
1017         test40(src, dst);
1018         verify(dst, src);
1019         if (!warmup) {
1020             Method m = tests.get(&quot;TestArrays::test40&quot;);
1021             assertDeoptimizedByC2(m);
1022             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1023             test40(src, dst);
1024             verify(dst, src);
<span class="line-modified">1025             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
1026                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1027             }
1028         }
1029     }
1030 
1031     @Test
1032     public void test41(Object src, Object[] dst) {
1033         System.arraycopy(src, 0, dst, 0, dst.length);
1034     }
1035 
1036     @DontCompile
1037     public void test41_verifier(boolean warmup) {
1038         int len = Math.abs(rI) % 10;
1039         MyValue2[] src = new MyValue2[len];
1040         Object[] dst = new Object[len];
1041         for (int i = 0; i &lt; len; ++i) {
1042             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1043         }
1044         test41(src, dst);
1045         verify(src, dst);
</pre>
<hr />
<pre>
1049         }
1050     }
1051 
1052     @Test
1053     public void test42(Object[] src, Object[] dst) {
1054         System.arraycopy(src, 0, dst, 0, src.length);
1055     }
1056 
1057     @DontCompile
1058     public void test42_verifier(boolean warmup) {
1059         int len = Math.abs(rI) % 10;
1060         Object[] src = new Object[len];
1061         Object[] dst = new Object[len];
1062         for (int i = 0; i &lt; len; ++i) {
1063             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1064         }
1065         test42(src, dst);
1066         verify(src, dst);
1067         if (!warmup) {
1068             Method m = tests.get(&quot;TestArrays::test42&quot;);
<span class="line-modified">1069             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
1070                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1071             }
1072         }
1073     }
1074 
1075     // short arraycopy()&#39;s
1076     @Test
1077     public void test43(Object src, Object dst) {
1078         System.arraycopy(src, 0, dst, 0, 8);
1079     }
1080 
1081     @DontCompile
1082     public void test43_verifier(boolean warmup) {
1083         MyValue1[] src = new MyValue1[8];
1084         MyValue1[] dst = new MyValue1[8];
1085         for (int i = 0; i &lt; 8; ++i) {
1086             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1087         }
1088         test43(src, dst);
1089         verify(src, dst);
</pre>
<hr />
<pre>
1137     @Warmup(1) // Avoid early compilation
1138     public void test46(Object[] src, MyValue2[] dst) {
1139         System.arraycopy(src, 0, dst, 0, 8);
1140     }
1141 
1142     @DontCompile
1143     public void test46_verifier(boolean warmup) {
1144         Object[] src = new Object[8];
1145         MyValue2[] dst = new MyValue2[8];
1146         for (int i = 0; i &lt; 8; ++i) {
1147             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1148         }
1149         test46(src, dst);
1150         verify(dst, src);
1151         if (!warmup) {
1152             Method m = tests.get(&quot;TestArrays::test46&quot;);
1153             assertDeoptimizedByC2(m);
1154             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1155             test46(src, dst);
1156             verify(dst, src);
<span class="line-modified">1157             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
1158                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1159             }
1160         }
1161     }
1162 
1163     @Test
1164     public void test47(MyValue2[] src, Object[] dst) {
1165         System.arraycopy(src, 0, dst, 0, 8);
1166     }
1167 
1168     @DontCompile
1169     public void test47_verifier(boolean warmup) {
1170         MyValue2[] src = new MyValue2[8];
1171         Object[] dst = new Object[8];
1172         for (int i = 0; i &lt; 8; ++i) {
1173             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1174         }
1175         test47(src, dst);
1176         verify(src, dst);
1177         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
</pre>
<hr />
<pre>
1184     @Warmup(1) // Avoid early compilation
1185     public void test48(Object[] src, Object dst) {
1186         System.arraycopy(src, 0, dst, 0, 8);
1187     }
1188 
1189     @DontCompile
1190     public void test48_verifier(boolean warmup) {
1191         Object[] src = new Object[8];
1192         MyValue2[] dst = new MyValue2[8];
1193         for (int i = 0; i &lt; 8; ++i) {
1194             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1195         }
1196         test48(src, dst);
1197         verify(dst, src);
1198         if (!warmup) {
1199             Method m = tests.get(&quot;TestArrays::test48&quot;);
1200             assertDeoptimizedByC2(m);
1201             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1202             test48(src, dst);
1203             verify(dst, src);
<span class="line-modified">1204             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
1205                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1206             }
1207         }
1208     }
1209 
1210     @Test
1211     public void test49(Object src, Object[] dst) {
1212         System.arraycopy(src, 0, dst, 0, 8);
1213     }
1214 
1215     @DontCompile
1216     public void test49_verifier(boolean warmup) {
1217         MyValue2[] src = new MyValue2[8];
1218         Object[] dst = new Object[8];
1219         for (int i = 0; i &lt; 8; ++i) {
1220             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1221         }
1222         test49(src, dst);
1223         verify(src, dst);
1224         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
</pre>
<hr />
<pre>
1226             verify(src, dst);
1227         }
1228     }
1229 
1230     @Test
1231     public void test50(Object[] src, Object[] dst) {
1232         System.arraycopy(src, 0, dst, 0, 8);
1233     }
1234 
1235     @DontCompile
1236     public void test50_verifier(boolean warmup) {
1237         Object[] src = new Object[8];
1238         Object[] dst = new Object[8];
1239         for (int i = 0; i &lt; 8; ++i) {
1240             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1241         }
1242         test50(src, dst);
1243         verify(src, dst);
1244         if (!warmup) {
1245             Method m = tests.get(&quot;TestArrays::test50&quot;);
<span class="line-modified">1246             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP) {</span>
1247                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1248             }
1249         }
1250     }
1251 
1252     @Test
1253     public MyValue1[] test51(MyValue1[] va) {
1254         return Arrays.copyOf(va, va.length, MyValue1[].class);
1255     }
1256 
1257     @DontCompile
1258     public void test51_verifier(boolean warmup) {
1259         int len = Math.abs(rI) % 10;
1260         MyValue1[] va = new MyValue1[len];
1261         for (int i = 0; i &lt; len; ++i) {
1262             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1263         }
1264         MyValue1[] result = test51(va);
1265         verify(va, result);
1266     }
</pre>
</td>
<td>
<hr />
<pre>
  33  * @summary Test value type arrays
  34  * @library /testlibrary /test/lib /compiler/whitebox /
  35  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  36  * @compile TestArrays.java
  37  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  38  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  39  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  40  *                               compiler.valhalla.valuetypes.ValueTypeTest
  41  *                               compiler.valhalla.valuetypes.TestArrays
  42  */
  43 public class TestArrays extends ValueTypeTest {
  44     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  45     // a normal method invocation when encountering flattened arrays.
  46     private static void assertDeoptimizedByC2(Method m) {
  47         int CompLevel_none              = 0,         // Interpreter
  48             CompLevel_simple            = 1,         // C1
  49             CompLevel_limited_profile   = 2,         // C1, invocation &amp; backedge counters
  50             CompLevel_full_profile      = 3,         // C1, invocation &amp; backedge counters + mdo
  51             CompLevel_full_optimization = 4;         // C2 or JVMCI
  52 
<span class="line-modified">  53         if (USE_COMPILER &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC &amp;&amp; WHITE_BOX.isMethodCompiled(m, false) &amp;&amp;</span>
  54             WHITE_BOX.getMethodCompilationLevel(m, false) &gt;= CompLevel_full_optimization) {
  55             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  56         }
  57     }
  58 
  59     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  60     @Override
  61     public String[] getExtraVMParameters(int scenario) {
  62         switch (scenario) {
  63         case 2: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  64         case 3: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:ValueArrayElemMaxFlatSize=-1&quot;, &quot;-XX:-UncommonNullCast&quot;};
  65         case 4: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;};
  66         case 5: return new String[] {&quot;-XX:-MonomorphicArrayCheck&quot;, &quot;-XX:-UncommonNullCast&quot;, &quot;-XX:+StressArrayCopyMacroNode&quot;};
  67         }
  68         return null;
  69     }
  70 
  71     public static void main(String[] args) throws Throwable {
  72         TestArrays test = new TestArrays();
  73         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
</pre>
<hr />
<pre>
 860             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 861         }
 862     }
 863 
 864     static void verify(MyValue2[] src, MyValue2[] dst) {
 865         for (int i = 0; i &lt; src.length; ++i) {
 866             Asserts.assertEQ(src[i].hash(), dst[i].hash());
 867         }
 868     }
 869 
 870     static void verify(MyValue2[] src, Object[] dst) {
 871         for (int i = 0; i &lt; src.length; ++i) {
 872             Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
 873         }
 874     }
 875 
 876     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
 877         if (!warmup) {
 878             Method m = tests.get(test);
 879             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false)) {
<span class="line-modified"> 880                 if (!ValueTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
 881                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
 882                 }
 883                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 884                 return true;
 885             }
 886         }
 887         return false;
 888     }
 889 
 890     // arraycopy() of value type array of unknown size
 891     @Test
 892     public void test35(Object src, Object dst, int len) {
 893         System.arraycopy(src, 0, dst, 0, len);
 894     }
 895 
 896     @DontCompile
 897     public void test35_verifier(boolean warmup) {
 898         int len = Math.abs(rI) % 10;
 899         MyValue1[] src = new MyValue1[len];
 900         MyValue1[] dst = new MyValue1[len];
</pre>
<hr />
<pre>
 956     public void test38(Object src, MyValue2[] dst) {
 957         System.arraycopy(src, 0, dst, 0, dst.length);
 958     }
 959 
 960     @DontCompile
 961     public void test38_verifier(boolean warmup) {
 962         int len = Math.abs(rI) % 10;
 963         Object[] src = new Object[len];
 964         MyValue2[] dst = new MyValue2[len];
 965         for (int i = 0; i &lt; len; ++i) {
 966             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 967         }
 968         test38(src, dst);
 969         verify(dst, src);
 970         if (!warmup) {
 971             Method m = tests.get(&quot;TestArrays::test38&quot;);
 972             assertDeoptimizedByC2(m);
 973             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
 974             test38(src, dst);
 975             verify(dst, src);
<span class="line-modified"> 976             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
 977                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
 978             }
 979         }
 980     }
 981 
 982     @Test
 983     public void test39(MyValue2[] src, Object dst) {
 984         System.arraycopy(src, 0, dst, 0, src.length);
 985     }
 986 
 987     @DontCompile
 988     public void test39_verifier(boolean warmup) {
 989         int len = Math.abs(rI) % 10;
 990         MyValue2[] src = new MyValue2[len];
 991         Object[] dst = new Object[len];
 992         for (int i = 0; i &lt; len; ++i) {
 993             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 994         }
 995         test39(src, dst);
 996         verify(src, dst);
</pre>
<hr />
<pre>
1005     public void test40(Object[] src, Object dst) {
1006         System.arraycopy(src, 0, dst, 0, src.length);
1007     }
1008 
1009     @DontCompile
1010     public void test40_verifier(boolean warmup) {
1011         int len = Math.abs(rI) % 10;
1012         Object[] src = new Object[len];
1013         MyValue2[] dst = new MyValue2[len];
1014         for (int i = 0; i &lt; len; ++i) {
1015             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1016         }
1017         test40(src, dst);
1018         verify(dst, src);
1019         if (!warmup) {
1020             Method m = tests.get(&quot;TestArrays::test40&quot;);
1021             assertDeoptimizedByC2(m);
1022             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1023             test40(src, dst);
1024             verify(dst, src);
<span class="line-modified">1025             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1026                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1027             }
1028         }
1029     }
1030 
1031     @Test
1032     public void test41(Object src, Object[] dst) {
1033         System.arraycopy(src, 0, dst, 0, dst.length);
1034     }
1035 
1036     @DontCompile
1037     public void test41_verifier(boolean warmup) {
1038         int len = Math.abs(rI) % 10;
1039         MyValue2[] src = new MyValue2[len];
1040         Object[] dst = new Object[len];
1041         for (int i = 0; i &lt; len; ++i) {
1042             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1043         }
1044         test41(src, dst);
1045         verify(src, dst);
</pre>
<hr />
<pre>
1049         }
1050     }
1051 
1052     @Test
1053     public void test42(Object[] src, Object[] dst) {
1054         System.arraycopy(src, 0, dst, 0, src.length);
1055     }
1056 
1057     @DontCompile
1058     public void test42_verifier(boolean warmup) {
1059         int len = Math.abs(rI) % 10;
1060         Object[] src = new Object[len];
1061         Object[] dst = new Object[len];
1062         for (int i = 0; i &lt; len; ++i) {
1063             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1064         }
1065         test42(src, dst);
1066         verify(src, dst);
1067         if (!warmup) {
1068             Method m = tests.get(&quot;TestArrays::test42&quot;);
<span class="line-modified">1069             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1070                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1071             }
1072         }
1073     }
1074 
1075     // short arraycopy()&#39;s
1076     @Test
1077     public void test43(Object src, Object dst) {
1078         System.arraycopy(src, 0, dst, 0, 8);
1079     }
1080 
1081     @DontCompile
1082     public void test43_verifier(boolean warmup) {
1083         MyValue1[] src = new MyValue1[8];
1084         MyValue1[] dst = new MyValue1[8];
1085         for (int i = 0; i &lt; 8; ++i) {
1086             src[i] = MyValue1.createWithFieldsInline(rI, rL);
1087         }
1088         test43(src, dst);
1089         verify(src, dst);
</pre>
<hr />
<pre>
1137     @Warmup(1) // Avoid early compilation
1138     public void test46(Object[] src, MyValue2[] dst) {
1139         System.arraycopy(src, 0, dst, 0, 8);
1140     }
1141 
1142     @DontCompile
1143     public void test46_verifier(boolean warmup) {
1144         Object[] src = new Object[8];
1145         MyValue2[] dst = new MyValue2[8];
1146         for (int i = 0; i &lt; 8; ++i) {
1147             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1148         }
1149         test46(src, dst);
1150         verify(dst, src);
1151         if (!warmup) {
1152             Method m = tests.get(&quot;TestArrays::test46&quot;);
1153             assertDeoptimizedByC2(m);
1154             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1155             test46(src, dst);
1156             verify(dst, src);
<span class="line-modified">1157             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1158                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1159             }
1160         }
1161     }
1162 
1163     @Test
1164     public void test47(MyValue2[] src, Object[] dst) {
1165         System.arraycopy(src, 0, dst, 0, 8);
1166     }
1167 
1168     @DontCompile
1169     public void test47_verifier(boolean warmup) {
1170         MyValue2[] src = new MyValue2[8];
1171         Object[] dst = new Object[8];
1172         for (int i = 0; i &lt; 8; ++i) {
1173             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1174         }
1175         test47(src, dst);
1176         verify(src, dst);
1177         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test47&quot;)) {
</pre>
<hr />
<pre>
1184     @Warmup(1) // Avoid early compilation
1185     public void test48(Object[] src, Object dst) {
1186         System.arraycopy(src, 0, dst, 0, 8);
1187     }
1188 
1189     @DontCompile
1190     public void test48_verifier(boolean warmup) {
1191         Object[] src = new Object[8];
1192         MyValue2[] dst = new MyValue2[8];
1193         for (int i = 0; i &lt; 8; ++i) {
1194             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1195         }
1196         test48(src, dst);
1197         verify(dst, src);
1198         if (!warmup) {
1199             Method m = tests.get(&quot;TestArrays::test48&quot;);
1200             assertDeoptimizedByC2(m);
1201             enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1202             test48(src, dst);
1203             verify(dst, src);
<span class="line-modified">1204             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1205                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1206             }
1207         }
1208     }
1209 
1210     @Test
1211     public void test49(Object src, Object[] dst) {
1212         System.arraycopy(src, 0, dst, 0, 8);
1213     }
1214 
1215     @DontCompile
1216     public void test49_verifier(boolean warmup) {
1217         MyValue2[] src = new MyValue2[8];
1218         Object[] dst = new Object[8];
1219         for (int i = 0; i &lt; 8; ++i) {
1220             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1221         }
1222         test49(src, dst);
1223         verify(src, dst);
1224         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestArrays::test49&quot;)) {
</pre>
<hr />
<pre>
1226             verify(src, dst);
1227         }
1228     }
1229 
1230     @Test
1231     public void test50(Object[] src, Object[] dst) {
1232         System.arraycopy(src, 0, dst, 0, 8);
1233     }
1234 
1235     @DontCompile
1236     public void test50_verifier(boolean warmup) {
1237         Object[] src = new Object[8];
1238         Object[] dst = new Object[8];
1239         for (int i = 0; i &lt; 8; ++i) {
1240             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1241         }
1242         test50(src, dst);
1243         verify(src, dst);
1244         if (!warmup) {
1245             Method m = tests.get(&quot;TestArrays::test50&quot;);
<span class="line-modified">1246             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1247                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1248             }
1249         }
1250     }
1251 
1252     @Test
1253     public MyValue1[] test51(MyValue1[] va) {
1254         return Arrays.copyOf(va, va.length, MyValue1[].class);
1255     }
1256 
1257     @DontCompile
1258     public void test51_verifier(boolean warmup) {
1259         int len = Math.abs(rI) % 10;
1260         MyValue1[] va = new MyValue1[len];
1261         for (int i = 0; i &lt; len; ++i) {
1262             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1263         }
1264         MyValue1[] result = test51(va);
1265         verify(va, result);
1266     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../src/hotspot/share/runtime/fieldDescriptor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorld.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
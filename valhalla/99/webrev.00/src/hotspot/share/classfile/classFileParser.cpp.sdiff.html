<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../prims/unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2462     } else {
2463       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2464     }
2465   } else {
2466     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);
2467   }
2468 
2469   if (name == vmSymbols::object_initializer_name()) {
2470     if (is_interface) {
2471       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2472     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {
2473       // OK, a constructor
2474     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {
2475       // also OK, a static factory, as long as the return value is good
2476       bool ok = false;
2477       SignatureStream ss((Symbol*) signature, true);
2478       while (!ss.at_return_type())  ss.next();
2479       if (ss.is_reference()) {
2480         Symbol* ret = ss.as_symbol();
2481         const Symbol* required = class_name();
<span class="line-modified">2482         if (is_hidden() || is_unsafe_anonymous()) {</span>
<span class="line-modified">2483           // The original class name in hidden classes and in the UAC byte stream gets</span>
<span class="line-modified">2484           // changed.  So using the original name in the return type is no longer valid.</span>



2485           required = vmSymbols::java_lang_Object();
2486         }
2487         ok = (ret == required);
2488       }
2489       if (!ok) {
2490         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2491       }
2492     } else {
2493       // not OK, so throw the same error as in verify_legal_method_signature.
2494       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2495     }
2496     // A declared &lt;init&gt; method must always be either a non-static
2497     // object constructor, with a void return, or else it must be a
2498     // static factory method, with a non-void return.  No other
2499     // definition of &lt;init&gt; is possible.
2500     //
2501     // The verifier (in verify_invoke_instructions) will inspect the
2502     // signature of any attempt to invoke &lt;init&gt;, and ensures that it
2503     // returns non-void if and only if it is being invoked by
2504     // invokestatic, and void if and only if it is being invoked by
</pre>
</td>
<td>
<hr />
<pre>
2462     } else {
2463       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2464     }
2465   } else {
2466     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);
2467   }
2468 
2469   if (name == vmSymbols::object_initializer_name()) {
2470     if (is_interface) {
2471       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2472     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {
2473       // OK, a constructor
2474     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {
2475       // also OK, a static factory, as long as the return value is good
2476       bool ok = false;
2477       SignatureStream ss((Symbol*) signature, true);
2478       while (!ss.at_return_type())  ss.next();
2479       if (ss.is_reference()) {
2480         Symbol* ret = ss.as_symbol();
2481         const Symbol* required = class_name();
<span class="line-modified">2482         if (is_hidden()) {</span>
<span class="line-modified">2483           // The original class name in hidden classes gets changed.  So using</span>
<span class="line-modified">2484           // the original name in the return type is no longer valid.</span>
<span class="line-added">2485           // Note that expecting the return type for inline hidden class factory</span>
<span class="line-added">2486           // methods to be java.lang.Object works around a JVM Spec issue for</span>
<span class="line-added">2487           // hidden classes.</span>
2488           required = vmSymbols::java_lang_Object();
2489         }
2490         ok = (ret == required);
2491       }
2492       if (!ok) {
2493         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2494       }
2495     } else {
2496       // not OK, so throw the same error as in verify_legal_method_signature.
2497       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2498     }
2499     // A declared &lt;init&gt; method must always be either a non-static
2500     // object constructor, with a void return, or else it must be a
2501     // static factory method, with a non-void return.  No other
2502     // definition of &lt;init&gt; is possible.
2503     //
2504     // The verifier (in verify_invoke_instructions) will inspect the
2505     // signature of any attempt to invoke &lt;init&gt;, and ensures that it
2506     // returns non-void if and only if it is being invoked by
2507     // invokestatic, and void if and only if it is being invoked by
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../prims/unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/unsafe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/reflection.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/unsafe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 895 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 896 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn&#39;t matter what the name is).
 897 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 898 
 899 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 900 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 901 // It is not possible for a named class, or an older anonymous class, to refer by
 902 // name (via its CP) to a newer anonymous class.
 903 
 904 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 905 // or type descriptors used in the loaded anonymous class.
 906 
 907 // Finally, CP patching may be used to introduce &quot;live&quot; objects into the constant pool,
 908 // instead of &quot;dead&quot; strings.  A compiled statement like println((Object)&quot;hello&quot;) can
 909 // be changed to println(greeting), where greeting is an arbitrary object created before
 910 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 911 // various kinds of metaobjects must be introduced as constants into bytecode.
 912 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 913 // not just a literal string.  For such ldc instructions, the verifier uses the
 914 // type Object instead of String, if the loaded constant is not in fact a String.


 915 
 916 static InstanceKlass*
 917 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 918                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 919                                  u1** temp_alloc,
 920                                  TRAPS) {
 921   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 922   assert(data != NULL, &quot;data must not be NULL&quot;);
 923 
 924   if (UsePerfData) {
 925     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 926   }
 927 
 928   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 929   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 930 
 931   int class_bytes_length = (int) length;
 932 
 933   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);
 934   if (class_bytes == NULL) {
</pre>
<hr />
<pre>
 990 
 991   Symbol* no_class_name = NULL;
 992   ClassLoadInfo cl_info(host_domain,
 993                         InstanceKlass::cast(host_klass),
 994                         cp_patches,
 995                         NULL,     // dynamic_nest_host
 996                         Handle(), // classData
 997                         false,    // is_hidden
 998                         false,    // is_strong_hidden
 999                         true);    // can_access_vm_annotations
1000 
1001   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
1002                                                 host_loader,
1003                                                 &amp;st,
1004                                                 cl_info,
1005                                                 CHECK_NULL);
1006   if (anonk == NULL) {
1007     return NULL;
1008   }
1009 


1010   return InstanceKlass::cast(anonk);
1011 }
1012 
1013 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
1014   ResourceMark rm(THREAD);
1015 
1016   jobject res_jh = NULL;
1017   u1* temp_alloc = NULL;
1018 
1019   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
1020   if (anon_klass != NULL) {
1021     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
1022   }
1023 
1024   // try/finally clause:
1025   FREE_C_HEAP_ARRAY(u1, temp_alloc);
1026 
1027   // The anonymous class loader data has been artificially been kept alive to
1028   // this point.   The mirror and any instances of this class have to keep
1029   // it alive afterwards.
</pre>
</td>
<td>
<hr />
<pre>
 895 // By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.
 896 // The bytecodes for U2 should refer to U1 by a symbolic name (doesn&#39;t matter what the name is).
 897 // The CONSTANT_Class entry for that name can be patched to refer directly to U1.
 898 
 899 // This allows, for example, U2 to use U1 as a superclass or super-interface, or as
 900 // an outer class (so that U2 is an anonymous inner class of anonymous U1).
 901 // It is not possible for a named class, or an older anonymous class, to refer by
 902 // name (via its CP) to a newer anonymous class.
 903 
 904 // CP patching may also be used to modify (i.e., hack) the names of methods, classes,
 905 // or type descriptors used in the loaded anonymous class.
 906 
 907 // Finally, CP patching may be used to introduce &quot;live&quot; objects into the constant pool,
 908 // instead of &quot;dead&quot; strings.  A compiled statement like println((Object)&quot;hello&quot;) can
 909 // be changed to println(greeting), where greeting is an arbitrary object created before
 910 // the anonymous class is loaded.  This is useful in dynamic languages, in which
 911 // various kinds of metaobjects must be introduced as constants into bytecode.
 912 // Note the cast (Object), which tells the verifier to expect an arbitrary object,
 913 // not just a literal string.  For such ldc instructions, the verifier uses the
 914 // type Object instead of String, if the loaded constant is not in fact a String.
<span class="line-added"> 915 //</span>
<span class="line-added"> 916 // An anonymous class cannot be an inline type.</span>
 917 
 918 static InstanceKlass*
 919 Unsafe_DefineAnonymousClass_impl(JNIEnv *env,
 920                                  jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,
 921                                  u1** temp_alloc,
 922                                  TRAPS) {
 923   assert(host_class != NULL, &quot;host_class must not be NULL&quot;);
 924   assert(data != NULL, &quot;data must not be NULL&quot;);
 925 
 926   if (UsePerfData) {
 927     ClassLoader::unsafe_defineClassCallCounter()-&gt;inc();
 928   }
 929 
 930   jint length = typeArrayOop(JNIHandles::resolve_non_null(data))-&gt;length();
 931   assert(length &gt;= 0, &quot;class_bytes_length must not be negative: %d&quot;, length);
 932 
 933   int class_bytes_length = (int) length;
 934 
 935   u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);
 936   if (class_bytes == NULL) {
</pre>
<hr />
<pre>
 992 
 993   Symbol* no_class_name = NULL;
 994   ClassLoadInfo cl_info(host_domain,
 995                         InstanceKlass::cast(host_klass),
 996                         cp_patches,
 997                         NULL,     // dynamic_nest_host
 998                         Handle(), // classData
 999                         false,    // is_hidden
1000                         false,    // is_strong_hidden
1001                         true);    // can_access_vm_annotations
1002 
1003   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
1004                                                 host_loader,
1005                                                 &amp;st,
1006                                                 cl_info,
1007                                                 CHECK_NULL);
1008   if (anonk == NULL) {
1009     return NULL;
1010   }
1011 
<span class="line-added">1012   assert(!anonk-&gt;is_inline_klass(), &quot;unsafe anonymous class cannot be inline class&quot;);</span>
<span class="line-added">1013 </span>
1014   return InstanceKlass::cast(anonk);
1015 }
1016 
1017 UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {
1018   ResourceMark rm(THREAD);
1019 
1020   jobject res_jh = NULL;
1021   u1* temp_alloc = NULL;
1022 
1023   InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &amp;temp_alloc, THREAD);
1024   if (anon_klass != NULL) {
1025     res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
1026   }
1027 
1028   // try/finally clause:
1029   FREE_C_HEAP_ARRAY(u1, temp_alloc);
1030 
1031   // The anonymous class loader data has been artificially been kept alive to
1032   // this point.   The mirror and any instances of this class have to keep
1033   // it alive afterwards.
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/reflection.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/callnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_CALLNODE_HPP
  26 #define SHARE_OPTO_CALLNODE_HPP
  27 
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/mulnode.hpp&quot;
  30 #include &quot;opto/multnode.hpp&quot;
  31 #include &quot;opto/opcodes.hpp&quot;
  32 #include &quot;opto/phaseX.hpp&quot;
  33 #include &quot;opto/replacednodes.hpp&quot;
  34 #include &quot;opto/type.hpp&quot;
  35 
  36 // Portions of code courtesy of Clifford Click
  37 
  38 // Optimization - Graph Style
  39 
  40 class Chaitin;
  41 class NamedCounter;
  42 class MultiNode;
  43 class  SafePointNode;
  44 class   CallNode;
  45 class     CallJavaNode;
  46 class       CallStaticJavaNode;
  47 class       CallDynamicJavaNode;
  48 class     CallRuntimeNode;
  49 class       CallLeafNode;
  50 class         CallLeafNoFPNode;
  51 class     AllocateNode;
  52 class       AllocateArrayNode;
  53 class     BoxLockNode;
  54 class     LockNode;
  55 class     UnlockNode;
  56 class JVMState;
  57 class OopMap;
  58 class State;
  59 class StartNode;
  60 class MachCallNode;
  61 class FastLockNode;
  62 
  63 //------------------------------StartNode--------------------------------------
  64 // The method start node
  65 class StartNode : public MultiNode {
  66   virtual bool cmp( const Node &amp;n ) const;
  67   virtual uint size_of() const; // Size is bigger
  68 public:
  69   const TypeTuple *_domain;
  70   StartNode( Node *root, const TypeTuple *domain ) : MultiNode(2), _domain(domain) {
  71     init_class_id(Class_Start);
  72     init_req(0,this);
  73     init_req(1,root);
  74   }
  75   virtual int Opcode() const;
  76   virtual bool pinned() const { return true; };
  77   virtual const Type *bottom_type() const;
  78   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
  79   virtual const Type* Value(PhaseGVN* phase) const;
  80   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
  81   virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_reg, uint length ) const;
  82   virtual const RegMask &amp;in_RegMask(uint) const;
  83   virtual Node *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);
  84   virtual uint ideal_reg() const { return 0; }
  85 #ifndef PRODUCT
  86   virtual void  dump_spec(outputStream *st) const;
  87   virtual void  dump_compact_spec(outputStream *st) const;
  88 #endif
  89 };
  90 
  91 //------------------------------StartOSRNode-----------------------------------
  92 // The method start node for on stack replacement code
  93 class StartOSRNode : public StartNode {
  94 public:
  95   StartOSRNode( Node *root, const TypeTuple *domain ) : StartNode(root, domain) {}
  96   virtual int   Opcode() const;
  97 };
  98 
  99 
 100 //------------------------------ParmNode---------------------------------------
 101 // Incoming parameters
 102 class ParmNode : public ProjNode {
 103   static const char * const names[TypeFunc::Parms+1];
 104 public:
 105   ParmNode( StartNode *src, uint con ) : ProjNode(src,con) {
 106     init_class_id(Class_Parm);
 107   }
 108   virtual int Opcode() const;
 109   virtual bool  is_CFG() const { return (_con == TypeFunc::Control); }
 110   virtual uint ideal_reg() const;
 111 #ifndef PRODUCT
 112   virtual void dump_spec(outputStream *st) const;
 113   virtual void dump_compact_spec(outputStream *st) const;
 114   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
 115 #endif
 116 };
 117 
 118 
 119 //------------------------------ReturnNode-------------------------------------
 120 // Return from subroutine node
 121 class ReturnNode : public Node {
 122 public:
 123   ReturnNode( uint edges, Node *cntrl, Node *i_o, Node *memory, Node *retadr, Node *frameptr );
 124   virtual int Opcode() const;
 125   virtual bool  is_CFG() const { return true; }
 126   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 127   virtual bool depends_only_on_test() const { return false; }
 128   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 129   virtual const Type* Value(PhaseGVN* phase) const;
 130   virtual uint ideal_reg() const { return NotAMachineReg; }
 131   virtual uint match_edge(uint idx) const;
 132 #ifndef PRODUCT
 133   virtual void dump_req(outputStream *st = tty) const;
 134 #endif
 135 };
 136 
 137 
 138 //------------------------------RethrowNode------------------------------------
 139 // Rethrow of exception at call site.  Ends a procedure before rethrowing;
 140 // ends the current basic block like a ReturnNode.  Restores registers and
 141 // unwinds stack.  Rethrow happens in the caller&#39;s method.
 142 class RethrowNode : public Node {
 143  public:
 144   RethrowNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *ret_adr, Node *exception );
 145   virtual int Opcode() const;
 146   virtual bool  is_CFG() const { return true; }
 147   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 148   virtual bool depends_only_on_test() const { return false; }
 149   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 150   virtual const Type* Value(PhaseGVN* phase) const;
 151   virtual uint match_edge(uint idx) const;
 152   virtual uint ideal_reg() const { return NotAMachineReg; }
 153 #ifndef PRODUCT
 154   virtual void dump_req(outputStream *st = tty) const;
 155 #endif
 156 };
 157 
 158 
 159 //------------------------------TailCallNode-----------------------------------
 160 // Pop stack frame and jump indirect
 161 class TailCallNode : public ReturnNode {
 162 public:
 163   TailCallNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr, Node *target, Node *moop )
 164     : ReturnNode( TypeFunc::Parms+2, cntrl, i_o, memory, frameptr, retadr ) {
 165     init_req(TypeFunc::Parms, target);
 166     init_req(TypeFunc::Parms+1, moop);
 167   }
 168 
 169   virtual int Opcode() const;
 170   virtual uint match_edge(uint idx) const;
 171 };
 172 
 173 //------------------------------TailJumpNode-----------------------------------
 174 // Pop stack frame and jump indirect
 175 class TailJumpNode : public ReturnNode {
 176 public:
 177   TailJumpNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *target, Node *ex_oop)
 178     : ReturnNode(TypeFunc::Parms+2, cntrl, i_o, memory, frameptr, Compile::current()-&gt;top()) {
 179     init_req(TypeFunc::Parms, target);
 180     init_req(TypeFunc::Parms+1, ex_oop);
 181   }
 182 
 183   virtual int Opcode() const;
 184   virtual uint match_edge(uint idx) const;
 185 };
 186 
 187 //-------------------------------JVMState-------------------------------------
 188 // A linked list of JVMState nodes captures the whole interpreter state,
 189 // plus GC roots, for all active calls at some call site in this compilation
 190 // unit.  (If there is no inlining, then the list has exactly one link.)
 191 // This provides a way to map the optimized program back into the interpreter,
 192 // or to let the GC mark the stack.
 193 class JVMState : public ResourceObj {
 194   friend class VMStructs;
 195 public:
 196   typedef enum {
 197     Reexecute_Undefined = -1, // not defined -- will be translated into false later
 198     Reexecute_False     =  0, // false       -- do not reexecute
 199     Reexecute_True      =  1  // true        -- reexecute the bytecode
 200   } ReexecuteState; //Reexecute State
 201 
 202 private:
 203   JVMState*         _caller;    // List pointer for forming scope chains
 204   uint              _depth;     // One more than caller depth, or one.
 205   uint              _locoff;    // Offset to locals in input edge mapping
 206   uint              _stkoff;    // Offset to stack in input edge mapping
 207   uint              _monoff;    // Offset to monitors in input edge mapping
 208   uint              _scloff;    // Offset to fields of scalar objs in input edge mapping
 209   uint              _endoff;    // Offset to end of input edge mapping
 210   uint              _sp;        // Jave Expression Stack Pointer for this state
 211   int               _bci;       // Byte Code Index of this JVM point
 212   ReexecuteState    _reexecute; // Whether this bytecode need to be re-executed
 213   ciMethod*         _method;    // Method Pointer
 214   SafePointNode*    _map;       // Map node associated with this scope
 215 public:
 216   friend class Compile;
 217   friend class PreserveReexecuteState;
 218 
 219   // Because JVMState objects live over the entire lifetime of the
 220   // Compile object, they are allocated into the comp_arena, which
 221   // does not get resource marked or reset during the compile process
 222   void *operator new( size_t x, Compile* C ) throw() { return C-&gt;comp_arena()-&gt;Amalloc(x); }
 223   void operator delete( void * ) { } // fast deallocation
 224 
 225   // Create a new JVMState, ready for abstract interpretation.
 226   JVMState(ciMethod* method, JVMState* caller);
 227   JVMState(int stack_size);  // root state; has a null method
 228 
 229   // Access functions for the JVM
 230   // ... --|--- loc ---|--- stk ---|--- arg ---|--- mon ---|--- scl ---|
 231   //       \ locoff    \ stkoff    \ argoff    \ monoff    \ scloff    \ endoff
 232   uint              locoff() const { return _locoff; }
 233   uint              stkoff() const { return _stkoff; }
 234   uint              argoff() const { return _stkoff + _sp; }
 235   uint              monoff() const { return _monoff; }
 236   uint              scloff() const { return _scloff; }
 237   uint              endoff() const { return _endoff; }
 238   uint              oopoff() const { return debug_end(); }
 239 
 240   int            loc_size() const { return stkoff() - locoff(); }
 241   int            stk_size() const { return monoff() - stkoff(); }
 242   int            mon_size() const { return scloff() - monoff(); }
 243   int            scl_size() const { return endoff() - scloff(); }
 244 
 245   bool        is_loc(uint i) const { return locoff() &lt;= i &amp;&amp; i &lt; stkoff(); }
 246   bool        is_stk(uint i) const { return stkoff() &lt;= i &amp;&amp; i &lt; monoff(); }
 247   bool        is_mon(uint i) const { return monoff() &lt;= i &amp;&amp; i &lt; scloff(); }
 248   bool        is_scl(uint i) const { return scloff() &lt;= i &amp;&amp; i &lt; endoff(); }
 249 
 250   uint                      sp() const { return _sp; }
 251   int                      bci() const { return _bci; }
 252   bool        should_reexecute() const { return _reexecute==Reexecute_True; }
 253   bool  is_reexecute_undefined() const { return _reexecute==Reexecute_Undefined; }
 254   bool              has_method() const { return _method != NULL; }
 255   ciMethod*             method() const { assert(has_method(), &quot;&quot;); return _method; }
 256   JVMState*             caller() const { return _caller; }
 257   SafePointNode*           map() const { return _map; }
 258   uint                   depth() const { return _depth; }
 259   uint             debug_start() const; // returns locoff of root caller
 260   uint               debug_end() const; // returns endoff of self
 261   uint              debug_size() const {
 262     return loc_size() + sp() + mon_size() + scl_size();
 263   }
 264   uint        debug_depth()  const; // returns sum of debug_size values at all depths
 265 
 266   // Returns the JVM state at the desired depth (1 == root).
 267   JVMState* of_depth(int d) const;
 268 
 269   // Tells if two JVM states have the same call chain (depth, methods, &amp; bcis).
 270   bool same_calls_as(const JVMState* that) const;
 271 
 272   // Monitors (monitors are stored as (boxNode, objNode) pairs
 273   enum { logMonitorEdges = 1 };
 274   int  nof_monitors()              const { return mon_size() &gt;&gt; logMonitorEdges; }
 275   int  monitor_depth()             const { return nof_monitors() + (caller() ? caller()-&gt;monitor_depth() : 0); }
 276   int  monitor_box_offset(int idx) const { return monoff() + (idx &lt;&lt; logMonitorEdges) + 0; }
 277   int  monitor_obj_offset(int idx) const { return monoff() + (idx &lt;&lt; logMonitorEdges) + 1; }
 278   bool is_monitor_box(uint off)    const {
 279     assert(is_mon(off), &quot;should be called only for monitor edge&quot;);
 280     return (0 == bitfield(off - monoff(), 0, logMonitorEdges));
 281   }
 282   bool is_monitor_use(uint off)    const { return (is_mon(off)
 283                                                    &amp;&amp; is_monitor_box(off))
 284                                              || (caller() &amp;&amp; caller()-&gt;is_monitor_use(off)); }
 285 
 286   // Initialization functions for the JVM
 287   void              set_locoff(uint off) { _locoff = off; }
 288   void              set_stkoff(uint off) { _stkoff = off; }
 289   void              set_monoff(uint off) { _monoff = off; }
 290   void              set_scloff(uint off) { _scloff = off; }
 291   void              set_endoff(uint off) { _endoff = off; }
 292   void              set_offsets(uint off) {
 293     _locoff = _stkoff = _monoff = _scloff = _endoff = off;
 294   }
 295   void              set_map(SafePointNode *map) { _map = map; }
 296   void              set_sp(uint sp) { _sp = sp; }
 297                     // _reexecute is initialized to &quot;undefined&quot; for a new bci
 298   void              set_bci(int bci) {if(_bci != bci)_reexecute=Reexecute_Undefined; _bci = bci; }
 299   void              set_should_reexecute(bool reexec) {_reexecute = reexec ? Reexecute_True : Reexecute_False;}
 300 
 301   // Miscellaneous utility functions
 302   JVMState* clone_deep(Compile* C) const;    // recursively clones caller chain
 303   JVMState* clone_shallow(Compile* C) const; // retains uncloned caller
 304   void      set_map_deep(SafePointNode *map);// reset map for all callers
 305   void      adapt_position(int delta);       // Adapt offsets in in-array after adding an edge.
 306   int       interpreter_frame_size() const;
 307 
 308 #ifndef PRODUCT
 309   void      format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const;
 310   void      dump_spec(outputStream *st) const;
 311   void      dump_on(outputStream* st) const;
 312   void      dump() const {
 313     dump_on(tty);
 314   }
 315 #endif
 316 };
 317 
 318 //------------------------------SafePointNode----------------------------------
 319 // A SafePointNode is a subclass of a MultiNode for convenience (and
 320 // potential code sharing) only - conceptually it is independent of
 321 // the Node semantics.
 322 class SafePointNode : public MultiNode {
 323   virtual bool           cmp( const Node &amp;n ) const;
 324   virtual uint           size_of() const;       // Size is bigger
 325 
 326 public:
 327   SafePointNode(uint edges, JVMState* jvms,
 328                 // A plain safepoint advertises no memory effects (NULL):
 329                 const TypePtr* adr_type = NULL)
 330     : MultiNode( edges ),
 331       _oop_map(NULL),
 332       _jvms(jvms),
 333       _adr_type(adr_type)
 334   {
 335     init_class_id(Class_SafePoint);
 336   }
 337 
 338   OopMap*         _oop_map;   // Array of OopMap info (8-bit char) for GC
 339   JVMState* const _jvms;      // Pointer to list of JVM State objects
 340   const TypePtr*  _adr_type;  // What type of memory does this node produce?
 341   ReplacedNodes   _replaced_nodes; // During parsing: list of pair of nodes from calls to GraphKit::replace_in_map()
 342 
 343   // Many calls take *all* of memory as input,
 344   // but some produce a limited subset of that memory as output.
 345   // The adr_type reports the call&#39;s behavior as a store, not a load.
 346 
 347   virtual JVMState* jvms() const { return _jvms; }
 348   void set_jvms(JVMState* s) {
 349     *(JVMState**)&amp;_jvms = s;  // override const attribute in the accessor
 350   }
 351   OopMap *oop_map() const { return _oop_map; }
 352   void set_oop_map(OopMap *om) { _oop_map = om; }
 353 
 354  private:
 355   void verify_input(JVMState* jvms, uint idx) const {
 356     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 357     Node* n = in(idx);
 358     assert((!n-&gt;bottom_type()-&gt;isa_long() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_double()) ||
 359            in(idx + 1)-&gt;is_top(), &quot;2nd half of long/double&quot;);
 360   }
 361 
 362  public:
 363   // Functionality from old debug nodes which has changed
 364   Node *local(JVMState* jvms, uint idx) const {
 365     verify_input(jvms, jvms-&gt;locoff() + idx);
 366     return in(jvms-&gt;locoff() + idx);
 367   }
 368   Node *stack(JVMState* jvms, uint idx) const {
 369     verify_input(jvms, jvms-&gt;stkoff() + idx);
 370     return in(jvms-&gt;stkoff() + idx);
 371   }
 372   Node *argument(JVMState* jvms, uint idx) const {
 373     verify_input(jvms, jvms-&gt;argoff() + idx);
 374     return in(jvms-&gt;argoff() + idx);
 375   }
 376   Node *monitor_box(JVMState* jvms, uint idx) const {
 377     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 378     return in(jvms-&gt;monitor_box_offset(idx));
 379   }
 380   Node *monitor_obj(JVMState* jvms, uint idx) const {
 381     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 382     return in(jvms-&gt;monitor_obj_offset(idx));
 383   }
 384 
 385   void  set_local(JVMState* jvms, uint idx, Node *c);
 386 
 387   void  set_stack(JVMState* jvms, uint idx, Node *c) {
 388     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 389     set_req(jvms-&gt;stkoff() + idx, c);
 390   }
 391   void  set_argument(JVMState* jvms, uint idx, Node *c) {
 392     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 393     set_req(jvms-&gt;argoff() + idx, c);
 394   }
 395   void ensure_stack(JVMState* jvms, uint stk_size) {
 396     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 397     int grow_by = (int)stk_size - (int)jvms-&gt;stk_size();
 398     if (grow_by &gt; 0)  grow_stack(jvms, grow_by);
 399   }
 400   void grow_stack(JVMState* jvms, uint grow_by);
 401   // Handle monitor stack
 402   void push_monitor( const FastLockNode *lock );
 403   void pop_monitor ();
 404   Node *peek_monitor_box() const;
 405   Node *peek_monitor_obj() const;
 406 
 407   // Access functions for the JVM
 408   Node *control  () const { return in(TypeFunc::Control  ); }
 409   Node *i_o      () const { return in(TypeFunc::I_O      ); }
 410   Node *memory   () const { return in(TypeFunc::Memory   ); }
 411   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 412   Node *frameptr () const { return in(TypeFunc::FramePtr ); }
 413 
 414   void set_control  ( Node *c ) { set_req(TypeFunc::Control,c); }
 415   void set_i_o      ( Node *c ) { set_req(TypeFunc::I_O    ,c); }
 416   void set_memory   ( Node *c ) { set_req(TypeFunc::Memory ,c); }
 417 
 418   MergeMemNode* merged_memory() const {
 419     return in(TypeFunc::Memory)-&gt;as_MergeMem();
 420   }
 421 
 422   // The parser marks useless maps as dead when it&#39;s done with them:
 423   bool is_killed() { return in(TypeFunc::Control) == NULL; }
 424 
 425   // Exception states bubbling out of subgraphs such as inlined calls
 426   // are recorded here.  (There might be more than one, hence the &quot;next&quot;.)
 427   // This feature is used only for safepoints which serve as &quot;maps&quot;
 428   // for JVM states during parsing, intrinsic expansion, etc.
 429   SafePointNode*         next_exception() const;
 430   void               set_next_exception(SafePointNode* n);
 431   bool                   has_exceptions() const { return next_exception() != NULL; }
 432 
 433   // Helper methods to operate on replaced nodes
 434   ReplacedNodes replaced_nodes() const {
 435     return _replaced_nodes;
 436   }
 437 
 438   void set_replaced_nodes(ReplacedNodes replaced_nodes) {
 439     _replaced_nodes = replaced_nodes;
 440   }
 441 
 442   void clone_replaced_nodes() {
 443     _replaced_nodes.clone();
 444   }
 445   void record_replaced_node(Node* initial, Node* improved) {
 446     _replaced_nodes.record(initial, improved);
 447   }
 448   void transfer_replaced_nodes_from(SafePointNode* sfpt, uint idx = 0) {
 449     _replaced_nodes.transfer_from(sfpt-&gt;_replaced_nodes, idx);
 450   }
 451   void delete_replaced_nodes() {
 452     _replaced_nodes.reset();
 453   }
 454   void apply_replaced_nodes(uint idx) {
 455     _replaced_nodes.apply(this, idx);
 456   }
 457   void merge_replaced_nodes_with(SafePointNode* sfpt) {
 458     _replaced_nodes.merge_with(sfpt-&gt;_replaced_nodes);
 459   }
 460   bool has_replaced_nodes() const {
 461     return !_replaced_nodes.is_empty();
 462   }
 463 
 464   void disconnect_from_root(PhaseIterGVN *igvn);
 465 
 466   // Standard Node stuff
 467   virtual int            Opcode() const;
 468   virtual bool           pinned() const { return true; }
 469   virtual const Type*    Value(PhaseGVN* phase) const;
 470   virtual const Type    *bottom_type() const { return Type::CONTROL; }
 471   virtual const TypePtr *adr_type() const { return _adr_type; }
 472   virtual Node          *Ideal(PhaseGVN *phase, bool can_reshape);
 473   virtual Node*          Identity(PhaseGVN* phase);
 474   virtual uint           ideal_reg() const { return 0; }
 475   virtual const RegMask &amp;in_RegMask(uint) const;
 476   virtual const RegMask &amp;out_RegMask() const;
 477   virtual uint           match_edge(uint idx) const;
 478 
 479   static  bool           needs_polling_address_input();
 480 
 481 #ifndef PRODUCT
 482   virtual void           dump_spec(outputStream *st) const;
 483   virtual void           related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
 484 #endif
 485 };
 486 
 487 //------------------------------SafePointScalarObjectNode----------------------
 488 // A SafePointScalarObjectNode represents the state of a scalarized object
 489 // at a safepoint.
 490 
 491 class SafePointScalarObjectNode: public TypeNode {
 492   uint _first_index; // First input edge relative index of a SafePoint node where
 493                      // states of the scalarized object fields are collected.
 494                      // It is relative to the last (youngest) jvms-&gt;_scloff.
 495   uint _n_fields;    // Number of non-static fields of the scalarized object.
 496   DEBUG_ONLY(AllocateNode* _alloc;)
 497 
 498   virtual uint hash() const ; // { return NO_HASH; }
 499   virtual bool cmp( const Node &amp;n ) const;
 500 
 501   uint first_index() const { return _first_index; }
 502 
 503 public:
 504   SafePointScalarObjectNode(const TypeOopPtr* tp,
 505 #ifdef ASSERT
 506                             AllocateNode* alloc,
 507 #endif
 508                             uint first_index, uint n_fields);
 509   virtual int Opcode() const;
 510   virtual uint           ideal_reg() const;
 511   virtual const RegMask &amp;in_RegMask(uint) const;
 512   virtual const RegMask &amp;out_RegMask() const;
 513   virtual uint           match_edge(uint idx) const;
 514 
 515   uint first_index(JVMState* jvms) const {
 516     assert(jvms != NULL, &quot;missed JVMS&quot;);
 517     return jvms-&gt;scloff() + _first_index;
 518   }
 519   uint n_fields()    const { return _n_fields; }
 520 
 521 #ifdef ASSERT
 522   AllocateNode* alloc() const { return _alloc; }
 523 #endif
 524 
 525   virtual uint size_of() const { return sizeof(*this); }
 526 
 527   // Assumes that &quot;this&quot; is an argument to a safepoint node &quot;s&quot;, and that
 528   // &quot;new_call&quot; is being created to correspond to &quot;s&quot;.  But the difference
 529   // between the start index of the jvmstates of &quot;new_call&quot; and &quot;s&quot; is
 530   // &quot;jvms_adj&quot;.  Produce and return a SafePointScalarObjectNode that
 531   // corresponds appropriately to &quot;this&quot; in &quot;new_call&quot;.  Assumes that
 532   // &quot;sosn_map&quot; is a map, specific to the translation of &quot;s&quot; to &quot;new_call&quot;,
 533   // mapping old SafePointScalarObjectNodes to new, to avoid multiple copies.
 534   SafePointScalarObjectNode* clone(Dict* sosn_map) const;
 535 
 536 #ifndef PRODUCT
 537   virtual void              dump_spec(outputStream *st) const;
 538 #endif
 539 };
 540 
 541 
 542 // Simple container for the outgoing projections of a call.  Useful
 543 // for serious surgery on calls.
 544 class CallProjections {
 545 public:
 546   Node* fallthrough_proj;
 547   Node* fallthrough_catchproj;
 548   Node* fallthrough_memproj;
 549   Node* fallthrough_ioproj;
 550   Node* catchall_catchproj;
 551   Node* catchall_memproj;
 552   Node* catchall_ioproj;
 553   Node* exobj;
 554   uint nb_resproj;
 555   Node* resproj[1]; // at least one projection
 556 
 557   CallProjections(uint nbres) {
 558     fallthrough_proj      = NULL;
 559     fallthrough_catchproj = NULL;
 560     fallthrough_memproj   = NULL;
 561     fallthrough_ioproj    = NULL;
 562     catchall_catchproj    = NULL;
 563     catchall_memproj      = NULL;
 564     catchall_ioproj       = NULL;
 565     exobj                 = NULL;
 566     nb_resproj            = nbres;
 567     resproj[0]            = NULL;
 568     for (uint i = 1; i &lt; nb_resproj; i++) {
 569       resproj[i]          = NULL;
 570     }
 571   }
 572 
 573 };
 574 
 575 class CallGenerator;
 576 
 577 //------------------------------CallNode---------------------------------------
 578 // Call nodes now subsume the function of debug nodes at callsites, so they
 579 // contain the functionality of a full scope chain of debug nodes.
 580 class CallNode : public SafePointNode {
 581   friend class VMStructs;
 582 
 583 protected:
 584   bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase);
 585 
 586 public:
 587   const TypeFunc *_tf;        // Function type
 588   address      _entry_point;  // Address of method being called
 589   float        _cnt;          // Estimate of number of times called
 590   CallGenerator* _generator;  // corresponding CallGenerator for some late inline calls
 591   const char *_name;           // Printable name, if _method is NULL
 592 
 593   CallNode(const TypeFunc* tf, address addr, const TypePtr* adr_type)
 594     : SafePointNode(tf-&gt;domain_cc()-&gt;cnt(), NULL, adr_type),
 595       _tf(tf),
 596       _entry_point(addr),
 597       _cnt(COUNT_UNKNOWN),
 598       _generator(NULL),
 599       _name(NULL)
 600   {
 601     init_class_id(Class_Call);
 602   }
 603 
 604   const TypeFunc* tf()         const { return _tf; }
 605   const address  entry_point() const { return _entry_point; }
 606   const float    cnt()         const { return _cnt; }
 607   CallGenerator* generator()   const { return _generator; }
 608 
 609   void set_tf(const TypeFunc* tf)       { _tf = tf; }
 610   void set_entry_point(address p)       { _entry_point = p; }
 611   void set_cnt(float c)                 { _cnt = c; }
 612   void set_generator(CallGenerator* cg) { _generator = cg; }
 613 
 614   virtual const Type *bottom_type() const;
 615   virtual const Type* Value(PhaseGVN* phase) const;
 616   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 617   virtual Node* Identity(PhaseGVN* phase) { return this; }
 618   virtual bool        cmp( const Node &amp;n ) const;
 619   virtual uint        size_of() const = 0;
 620   virtual void        calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
 621   virtual Node       *match(const ProjNode *proj, const Matcher *m, const RegMask* mask);
 622   virtual uint        ideal_reg() const { return NotAMachineReg; }
 623   // Are we guaranteed that this node is a safepoint?  Not true for leaf calls and
 624   // for some macro nodes whose expansion does not have a safepoint on the fast path.
 625   virtual bool        guaranteed_safepoint()  { return true; }
 626   // For macro nodes, the JVMState gets modified during expansion. If calls
 627   // use MachConstantBase, it gets modified during matching. So when cloning
 628   // the node the JVMState must be cloned. Default is not to clone.
 629   virtual void clone_jvms(Compile* C) {
 630     if (C-&gt;needs_clone_jvms() &amp;&amp; jvms() != NULL) {
 631       set_jvms(jvms()-&gt;clone_deep(C));
 632       jvms()-&gt;set_map_deep(this);
 633     }
 634   }
 635 
 636   // Returns true if the call may modify n
 637   virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);
 638   // Does this node have a use of n other than in debug information?
 639   bool                has_non_debug_use(Node *n);
 640   bool                has_debug_use(Node *n);
 641   // Returns the unique CheckCastPP of a call
 642   // or result projection is there are several CheckCastPP
 643   // or returns NULL if there is no one.
 644   Node *result_cast();
 645   // Does this node returns pointer?
 646   bool returns_pointer() const {
 647     const TypeTuple *r = tf()-&gt;range_sig();
 648     return (!tf()-&gt;returns_value_type_as_fields() &amp;&amp;
 649             r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
 650             r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
 651   }
 652 
 653   // Collect all the interesting edges from a call for use in
 654   // replacing the call by something else.  Used by macro expansion
 655   // and the late inlining support.
 656   CallProjections* extract_projections(bool separate_io_proj, bool do_asserts = true);
 657 
 658   virtual uint match_edge(uint idx) const;
 659 
 660   bool is_call_to_arraycopystub() const;
 661 
 662   virtual void copy_call_debug_info(PhaseIterGVN* phase, CallNode *oldcall) {}
 663 
 664 #ifndef PRODUCT
 665   virtual void        dump_req(outputStream *st = tty) const;
 666   virtual void        dump_spec(outputStream *st) const;
 667 #endif
 668 };
 669 
 670 
 671 //------------------------------CallJavaNode-----------------------------------
 672 // Make a static or dynamic subroutine call node using Java calling
 673 // convention.  (The &quot;Java&quot; calling convention is the compiler&#39;s calling
 674 // convention, as opposed to the interpreter&#39;s or that of native C.)
 675 class CallJavaNode : public CallNode {
 676   friend class VMStructs;
 677 protected:
 678   virtual bool cmp( const Node &amp;n ) const;
 679   virtual uint size_of() const; // Size is bigger
 680 
 681   bool    _optimized_virtual;
 682   bool    _method_handle_invoke;
 683   bool    _override_symbolic_info; // Override symbolic call site info from bytecode
 684   ciMethod* _method;               // Method being direct called
 685 public:
 686   const int       _bci;         // Byte Code Index of call byte code
 687   CallJavaNode(const TypeFunc* tf , address addr, ciMethod* method, int bci)
 688     : CallNode(tf, addr, TypePtr::BOTTOM),
 689       _optimized_virtual(false),
 690       _method_handle_invoke(false),
 691       _override_symbolic_info(false),
 692       _method(method), _bci(bci)
 693   {
 694     init_class_id(Class_CallJava);
 695   }
 696 
 697   virtual int   Opcode() const;
 698   ciMethod* method() const                 { return _method; }
 699   void  set_method(ciMethod *m)            { _method = m; }
 700   void  set_optimized_virtual(bool f)      { _optimized_virtual = f; }
 701   bool  is_optimized_virtual() const       { return _optimized_virtual; }
 702   void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }
 703   bool  is_method_handle_invoke() const    { return _method_handle_invoke; }
 704   void  set_override_symbolic_info(bool f) { _override_symbolic_info = f; }
 705   bool  override_symbolic_info() const     { return _override_symbolic_info; }
 706 
 707   void copy_call_debug_info(PhaseIterGVN* phase, CallNode *oldcall);
 708 
 709   DEBUG_ONLY( bool validate_symbolic_info() const; )
 710 
 711 #ifndef PRODUCT
 712   virtual void  dump_spec(outputStream *st) const;
 713   virtual void  dump_compact_spec(outputStream *st) const;
 714 #endif
 715 };
 716 
 717 //------------------------------CallStaticJavaNode-----------------------------
 718 // Make a direct subroutine call using Java calling convention (for static
 719 // calls and optimized virtual calls, plus calls to wrappers for run-time
 720 // routines); generates static stub.
 721 class CallStaticJavaNode : public CallJavaNode {
 722   virtual bool cmp( const Node &amp;n ) const;
 723   virtual uint size_of() const; // Size is bigger
 724 
 725   bool remove_useless_allocation(PhaseGVN *phase, Node* ctl, Node* mem, Node* unc_arg);
 726 
 727 public:
 728   CallStaticJavaNode(Compile* C, const TypeFunc* tf, address addr, ciMethod* method, int bci)
 729     : CallJavaNode(tf, addr, method, bci) {
 730     init_class_id(Class_CallStaticJava);
 731     if (C-&gt;eliminate_boxing() &amp;&amp; (method != NULL) &amp;&amp; method-&gt;is_boxing_method()) {
 732       init_flags(Flag_is_macro);
 733       C-&gt;add_macro_node(this);
 734     }
 735     const TypeTuple *r = tf-&gt;range_sig();
 736     if (InlineTypeReturnedAsFields &amp;&amp;
 737         method != NULL &amp;&amp;
 738         method-&gt;is_method_handle_intrinsic() &amp;&amp;
 739         r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
 740         r-&gt;field_at(TypeFunc::Parms)-&gt;isa_oopptr() &amp;&amp;
 741         r-&gt;field_at(TypeFunc::Parms)-&gt;is_oopptr()-&gt;can_be_value_type()) {
 742       // Make sure this call is processed by PhaseMacroExpand::expand_mh_intrinsic_return
 743       init_flags(Flag_is_macro);
 744       C-&gt;add_macro_node(this);
 745     }
 746 
 747     _is_scalar_replaceable = false;
 748     _is_non_escaping = false;
 749   }
 750   CallStaticJavaNode(const TypeFunc* tf, address addr, const char* name, int bci,
 751                      const TypePtr* adr_type)
 752     : CallJavaNode(tf, addr, NULL, bci) {
 753     init_class_id(Class_CallStaticJava);
 754     // This node calls a runtime stub, which often has narrow memory effects.
 755     _adr_type = adr_type;
 756     _is_scalar_replaceable = false;
 757     _is_non_escaping = false;
 758     _name = name;
 759   }
 760 
 761   // Result of Escape Analysis
 762   bool _is_scalar_replaceable;
 763   bool _is_non_escaping;
 764 
 765   // If this is an uncommon trap, return the request code, else zero.
 766   int uncommon_trap_request() const;
 767   static int extract_uncommon_trap_request(const Node* call);
 768 
 769   bool is_boxing_method() const {
 770     return is_macro() &amp;&amp; (method() != NULL) &amp;&amp; method()-&gt;is_boxing_method();
 771   }
 772   // Later inlining modifies the JVMState, so we need to clone it
 773   // when the call node is cloned (because it is macro node).
 774   virtual void  clone_jvms(Compile* C) {
 775     if ((jvms() != NULL) &amp;&amp; is_boxing_method()) {
 776       set_jvms(jvms()-&gt;clone_deep(C));
 777       jvms()-&gt;set_map_deep(this);
 778     }
 779   }
 780 
 781   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 782 
 783   virtual int         Opcode() const;
 784 #ifndef PRODUCT
 785   virtual void        dump_spec(outputStream *st) const;
 786   virtual void        dump_compact_spec(outputStream *st) const;
 787 #endif
 788 };
 789 
 790 //------------------------------CallDynamicJavaNode----------------------------
 791 // Make a dispatched call using Java calling convention.
 792 class CallDynamicJavaNode : public CallJavaNode {
 793   virtual bool cmp( const Node &amp;n ) const;
 794   virtual uint size_of() const; // Size is bigger
 795 public:
 796   CallDynamicJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int vtable_index, int bci ) : CallJavaNode(tf,addr,method,bci), _vtable_index(vtable_index) {
 797     init_class_id(Class_CallDynamicJava);
 798   }
 799 
 800   int _vtable_index;
 801   virtual int   Opcode() const;
 802 #ifndef PRODUCT
 803   virtual void  dump_spec(outputStream *st) const;
 804 #endif
 805 };
 806 
 807 //------------------------------CallRuntimeNode--------------------------------
 808 // Make a direct subroutine call node into compiled C++ code.
 809 class CallRuntimeNode : public CallNode {
 810   virtual bool cmp( const Node &amp;n ) const;
 811   virtual uint size_of() const; // Size is bigger
 812 public:
 813   CallRuntimeNode(const TypeFunc* tf, address addr, const char* name,
 814                   const TypePtr* adr_type)
 815     : CallNode(tf, addr, adr_type)
 816   {
 817     init_class_id(Class_CallRuntime);
 818     _name = name;
 819   }
 820 
 821   virtual int   Opcode() const;
 822   virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
 823 
 824 #ifndef PRODUCT
 825   virtual void  dump_spec(outputStream *st) const;
 826 #endif
 827 };
 828 
 829 //------------------------------CallLeafNode-----------------------------------
 830 // Make a direct subroutine call node into compiled C++ code, without
 831 // safepoints
 832 class CallLeafNode : public CallRuntimeNode {
 833 public:
 834   CallLeafNode(const TypeFunc* tf, address addr, const char* name,
 835                const TypePtr* adr_type)
 836     : CallRuntimeNode(tf, addr, name, adr_type)
 837   {
 838     init_class_id(Class_CallLeaf);
 839   }
 840   virtual int   Opcode() const;
 841   virtual bool        guaranteed_safepoint()  { return false; }
 842 #ifndef PRODUCT
 843   virtual void  dump_spec(outputStream *st) const;
 844 #endif
 845 };
 846 
 847 //------------------------------CallLeafNoFPNode-------------------------------
 848 // CallLeafNode, not using floating point or using it in the same manner as
 849 // the generated code
 850 class CallLeafNoFPNode : public CallLeafNode {
 851 public:
 852   CallLeafNoFPNode(const TypeFunc* tf, address addr, const char* name,
 853                    const TypePtr* adr_type)
 854     : CallLeafNode(tf, addr, name, adr_type)
 855   {
 856   }
 857   virtual int   Opcode() const;
 858   virtual uint match_edge(uint idx) const;
 859 };
 860 
 861 
 862 //------------------------------Allocate---------------------------------------
 863 // High-level memory allocation
 864 //
 865 //  AllocateNode and AllocateArrayNode are subclasses of CallNode because they will
 866 //  get expanded into a code sequence containing a call.  Unlike other CallNodes,
 867 //  they have 2 memory projections and 2 i_o projections (which are distinguished by
 868 //  the _is_io_use flag in the projection.)  This is needed when expanding the node in
 869 //  order to differentiate the uses of the projection on the normal control path from
 870 //  those on the exception return path.
 871 //
 872 class AllocateNode : public CallNode {
 873 public:
 874   enum {
 875     // Output:
 876     RawAddress  = TypeFunc::Parms,    // the newly-allocated raw address
 877     // Inputs:
 878     AllocSize   = TypeFunc::Parms,    // size (in bytes) of the new object
 879     KlassNode,                        // type (maybe dynamic) of the obj.
 880     InitialTest,                      // slow-path test (may be constant)
 881     ALength,                          // array length (or TOP if none)
 882     ValueNode,
 883     DefaultValue,                     // default value in case of non flattened value array
 884     RawDefaultValue,                  // same as above but as raw machine word
 885     ParmLimit
 886   };
 887 
 888   static const TypeFunc* alloc_type(const Type* t) {
 889     const Type** fields = TypeTuple::fields(ParmLimit - TypeFunc::Parms);
 890     fields[AllocSize]   = TypeInt::POS;
 891     fields[KlassNode]   = TypeInstPtr::NOTNULL;
 892     fields[InitialTest] = TypeInt::BOOL;
 893     fields[ALength]     = t;  // length (can be a bad length)
 894     fields[ValueNode]   = Type::BOTTOM;
 895     fields[DefaultValue] = TypeInstPtr::NOTNULL;
 896     fields[RawDefaultValue] = TypeX_X;
 897 
 898     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 899 
 900     // create result type (range)
 901     fields = TypeTuple::fields(1);
 902     fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 903 
 904     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 905 
 906     return TypeFunc::make(domain, range);
 907   }
 908 
 909   // Result of Escape Analysis
 910   bool _is_scalar_replaceable;
 911   bool _is_non_escaping;
 912   // True when MemBar for new is redundant with MemBar at initialzer exit
 913   bool _is_allocation_MemBar_redundant;
 914   bool _larval;
 915 
 916   virtual uint size_of() const; // Size is bigger
 917   AllocateNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,
 918                Node *size, Node *klass_node, Node *initial_test,
 919                ValueTypeBaseNode* value_node = NULL);
 920   // Expansion modifies the JVMState, so we need to clone it
 921   virtual void  clone_jvms(Compile* C) {
 922     if (jvms() != NULL) {
 923       set_jvms(jvms()-&gt;clone_deep(C));
 924       jvms()-&gt;set_map_deep(this);
 925     }
 926   }
 927   virtual int Opcode() const;
 928   virtual uint ideal_reg() const { return Op_RegP; }
 929   virtual bool        guaranteed_safepoint()  { return false; }
 930 
<a name="1" id="anc1"></a>

 931   // allocations do not modify their arguments
 932   virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) { return false;}
 933 
 934   // Pattern-match a possible usage of AllocateNode.
 935   // Return null if no allocation is recognized.
 936   // The operand is the pointer produced by the (possible) allocation.
 937   // It must be a projection of the Allocate or its subsequent CastPP.
 938   // (Note:  This function is defined in file graphKit.cpp, near
 939   // GraphKit::new_instance/new_array, whose output it recognizes.)
 940   // The &#39;ptr&#39; may not have an offset unless the &#39;offset&#39; argument is given.
 941   static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase);
 942 
 943   // Fancy version which uses AddPNode::Ideal_base_and_offset to strip
 944   // an offset, which is reported back to the caller.
 945   // (Note:  AllocateNode::Ideal_allocation is defined in graphKit.cpp.)
 946   static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase,
 947                                         intptr_t&amp; offset);
 948 
 949   // Dig the klass operand out of a (possible) allocation site.
 950   static Node* Ideal_klass(Node* ptr, PhaseTransform* phase) {
 951     AllocateNode* allo = Ideal_allocation(ptr, phase);
 952     return (allo == NULL) ? NULL : allo-&gt;in(KlassNode);
 953   }
 954 
 955   // Conservatively small estimate of offset of first non-header byte.
 956   int minimum_header_size() {
 957     return is_AllocateArray() ? arrayOopDesc::base_offset_in_bytes(T_BYTE) :
 958                                 instanceOopDesc::base_offset_in_bytes();
 959   }
 960 
 961   // Return the corresponding initialization barrier (or null if none).
 962   // Walks out edges to find it...
 963   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
 964   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
 965   InitializeNode* initialization();
 966 
 967   // Convenience for initialization-&gt;maybe_set_complete(phase)
 968   bool maybe_set_complete(PhaseGVN* phase);
 969 
 970   // Return true if allocation doesn&#39;t escape thread, its escape state
 971   // needs be noEscape or ArgEscape. InitializeNode._does_not_escape
 972   // is true when its allocation&#39;s escape state is noEscape or
 973   // ArgEscape. In case allocation&#39;s InitializeNode is NULL, check
 974   // AlllocateNode._is_non_escaping flag.
 975   // AlllocateNode._is_non_escaping is true when its escape state is
 976   // noEscape.
 977   bool does_not_escape_thread() {
 978     InitializeNode* init = NULL;
 979     return _is_non_escaping || (((init = initialization()) != NULL) &amp;&amp; init-&gt;does_not_escape());
 980   }
 981 
 982   // If object doesn&#39;t escape in &lt;.init&gt; method and there is memory barrier
 983   // inserted at exit of its &lt;.init&gt;, memory barrier for new is not necessary.
 984   // Inovke this method when MemBar at exit of initializer and post-dominate
 985   // allocation node.
 986   void compute_MemBar_redundancy(ciMethod* initializer);
 987   bool is_allocation_MemBar_redundant() { return _is_allocation_MemBar_redundant; }
 988 
 989   Node* make_ideal_mark(PhaseGVN* phase, Node* control, Node* mem);
 990 };
 991 
 992 //------------------------------AllocateArray---------------------------------
 993 //
 994 // High-level array allocation
 995 //
 996 class AllocateArrayNode : public AllocateNode {
 997 public:
 998   AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,
 999                     Node* size, Node* klass_node, Node* initial_test,
1000                     Node* count_val, Node* default_value, Node* raw_default_value)
1001     : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node, initial_test)
1002   {
1003     init_class_id(Class_AllocateArray);
1004     set_req(AllocateNode::ALength,        count_val);
1005     init_req(AllocateNode::DefaultValue,  default_value);
1006     init_req(AllocateNode::RawDefaultValue, raw_default_value);
1007   }
1008   virtual int Opcode() const;
1009   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1010 
1011   // Dig the length operand out of a array allocation site.
1012   Node* Ideal_length() {
1013     return in(AllocateNode::ALength);
1014   }
1015 
1016   // Dig the length operand out of a array allocation site and narrow the
1017   // type with a CastII, if necesssary
1018   Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseTransform *phase, bool can_create = true);
1019 
1020   // Pattern-match a possible usage of AllocateArrayNode.
1021   // Return null if no allocation is recognized.
1022   static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseTransform* phase) {
1023     AllocateNode* allo = Ideal_allocation(ptr, phase);
1024     return (allo == NULL || !allo-&gt;is_AllocateArray())
1025            ? NULL : allo-&gt;as_AllocateArray();
1026   }
1027 };
1028 
1029 //------------------------------AbstractLockNode-----------------------------------
1030 class AbstractLockNode: public CallNode {
1031 private:
1032   enum {
1033     Regular = 0,  // Normal lock
1034     NonEscObj,    // Lock is used for non escaping object
1035     Coarsened,    // Lock was coarsened
1036     Nested        // Nested lock
1037   } _kind;
1038 #ifndef PRODUCT
1039   NamedCounter* _counter;
1040   static const char* _kind_names[Nested+1];
1041 #endif
1042 
1043 protected:
1044   // helper functions for lock elimination
1045   //
1046 
1047   bool find_matching_unlock(const Node* ctrl, LockNode* lock,
1048                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1049   bool find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1050                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1051   bool find_unlocks_for_region(const RegionNode* region, LockNode* lock,
1052                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1053   LockNode *find_matching_lock(UnlockNode* unlock);
1054 
1055   // Update the counter to indicate that this lock was eliminated.
1056   void set_eliminated_lock_counter() PRODUCT_RETURN;
1057 
1058 public:
1059   AbstractLockNode(const TypeFunc *tf)
1060     : CallNode(tf, NULL, TypeRawPtr::BOTTOM),
1061       _kind(Regular)
1062   {
1063 #ifndef PRODUCT
1064     _counter = NULL;
1065 #endif
1066   }
1067   virtual int Opcode() const = 0;
1068   Node *   obj_node() const       {return in(TypeFunc::Parms + 0); }
1069   Node *   box_node() const       {return in(TypeFunc::Parms + 1); }
1070   Node *   fastlock_node() const  {return in(TypeFunc::Parms + 2); }
1071   void     set_box_node(Node* box) { set_req(TypeFunc::Parms + 1, box); }
1072 
1073   const Type *sub(const Type *t1, const Type *t2) const { return TypeInt::CC;}
1074 
1075   virtual uint size_of() const { return sizeof(*this); }
1076 
1077   bool is_eliminated()  const { return (_kind != Regular); }
1078   bool is_non_esc_obj() const { return (_kind == NonEscObj); }
1079   bool is_coarsened()   const { return (_kind == Coarsened); }
1080   bool is_nested()      const { return (_kind == Nested); }
1081 
1082   const char * kind_as_string() const;
1083   void log_lock_optimization(Compile* c, const char * tag) const;
1084 
1085   void set_non_esc_obj() { _kind = NonEscObj; set_eliminated_lock_counter(); }
1086   void set_coarsened()   { _kind = Coarsened; set_eliminated_lock_counter(); }
1087   void set_nested()      { _kind = Nested; set_eliminated_lock_counter(); }
1088 
1089   // locking does not modify its arguments
1090   virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase){ return false;}
1091 
1092 #ifndef PRODUCT
1093   void create_lock_counter(JVMState* s);
1094   NamedCounter* counter() const { return _counter; }
1095   virtual void dump_spec(outputStream* st) const;
1096   virtual void dump_compact_spec(outputStream* st) const;
1097   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
1098 #endif
1099 };
1100 
1101 //------------------------------Lock---------------------------------------
1102 // High-level lock operation
1103 //
1104 // This is a subclass of CallNode because it is a macro node which gets expanded
1105 // into a code sequence containing a call.  This node takes 3 &quot;parameters&quot;:
1106 //    0  -  object to lock
1107 //    1 -   a BoxLockNode
1108 //    2 -   a FastLockNode
1109 //
1110 class LockNode : public AbstractLockNode {
1111 public:
1112 
1113   static const TypeFunc *lock_type() {
1114     // create input type (domain)
1115     const Type **fields = TypeTuple::fields(3);
1116     fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
1117     fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;    // Address of stack location for lock
1118     fields[TypeFunc::Parms+2] = TypeInt::BOOL;         // FastLock
1119     const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3,fields);
1120 
1121     // create result type (range)
1122     fields = TypeTuple::fields(0);
1123 
1124     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1125 
1126     return TypeFunc::make(domain, range);
1127   }
1128 
1129   virtual int Opcode() const;
1130   virtual uint size_of() const; // Size is bigger
1131   LockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf ) {
1132     init_class_id(Class_Lock);
1133     init_flags(Flag_is_macro);
1134     C-&gt;add_macro_node(this);
1135   }
1136   virtual bool        guaranteed_safepoint()  { return false; }
1137 
1138   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1139   // Expansion modifies the JVMState, so we need to clone it
1140   virtual void  clone_jvms(Compile* C) {
1141     if (jvms() != NULL) {
1142       set_jvms(jvms()-&gt;clone_deep(C));
1143       jvms()-&gt;set_map_deep(this);
1144     }
1145   }
1146 
1147   bool is_nested_lock_region(); // Is this Lock nested?
1148   bool is_nested_lock_region(Compile * c); // Why isn&#39;t this Lock nested?
1149 };
1150 
1151 //------------------------------Unlock---------------------------------------
1152 // High-level unlock operation
1153 class UnlockNode : public AbstractLockNode {
1154 private:
1155 #ifdef ASSERT
1156   JVMState* const _dbg_jvms;      // Pointer to list of JVM State objects
1157 #endif
1158 public:
1159   virtual int Opcode() const;
1160   virtual uint size_of() const; // Size is bigger
1161   UnlockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf )
1162 #ifdef ASSERT
1163     , _dbg_jvms(NULL)
1164 #endif
1165   {
1166     init_class_id(Class_Unlock);
1167     init_flags(Flag_is_macro);
1168     C-&gt;add_macro_node(this);
1169   }
1170   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1171   // unlock is never a safepoint
1172   virtual bool        guaranteed_safepoint()  { return false; }
1173 #ifdef ASSERT
1174   void set_dbg_jvms(JVMState* s) {
1175     *(JVMState**)&amp;_dbg_jvms = s;  // override const attribute in the accessor
1176   }
1177   JVMState* dbg_jvms() const { return _dbg_jvms; }
1178 #else
1179   JVMState* dbg_jvms() const { return NULL; }
1180 #endif
1181 };
1182 #endif // SHARE_OPTO_CALLNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
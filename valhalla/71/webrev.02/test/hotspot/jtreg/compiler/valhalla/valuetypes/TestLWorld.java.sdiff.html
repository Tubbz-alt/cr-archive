<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../src/hotspot/share/opto/valuetypenode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2390 
2391     @Test
2392     public boolean test91(Object obj) {
2393         return obj.getClass() == MyValue2[].class;
2394     }
2395 
2396     @DontCompile
2397     public void test91_verifier(boolean warmup) {
2398         Asserts.assertTrue(test91(new MyValue2[1]));
2399         Asserts.assertFalse(test91(new Object()));
2400     }
2401 
2402     static inline class Test92Value {
2403         final int field;
2404         public Test92Value() {
2405             field = 0x42;
2406         }
2407     }
2408 
2409     @Warmup(10000)
<span class="line-modified">2410     @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 2 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G)</span>
2411     public Object test92(Object[] array) {
2412         // Dummy loops to ensure we run enough passes of split if
2413         for (int i = 0; i &lt; 2; i++) {
2414             for (int j = 0; j &lt; 2; j++) {
2415               for (int k = 0; k &lt; 2; k++) {
2416               }
2417             }
2418         }
2419 
2420         return (Integer)array[0];
2421     }
2422 
2423     @DontCompile
2424     public void test92_verifier(boolean warmup) {
2425         Object[] array = new Object[1];
2426         array[0] = 0x42;
2427         Object result = test92(array);
2428         Asserts.assertEquals(result, 0x42);
2429     }
2430 
</pre>
<hr />
<pre>
2454             Object[] array = new Test92Value[1];
2455             Method m = tests.get(&quot;TestLWorld::test93&quot;);
2456             int extra = 3;
2457             for (int j = 0; j &lt; extra; j++) {
2458                 for (int i = 0; i &lt; 10; i++) {
2459                     try {
2460                         test93(array);
2461                     } catch (ClassCastException cce) {
2462                     }
2463                 }
2464                 boolean compiled = isCompiledByC2(m);
2465                 Asserts.assertTrue(!USE_COMPILER || XCOMP || STRESS_CC || TEST_C1 || compiled || (j != extra-1));
2466                 if (!compiled) {
2467                     enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2468                 }
2469             }
2470         }
2471     }
2472 
2473     @Warmup(10000)
<span class="line-modified">2474     @Test(match = { CLASS_CHECK_TRAP, LOOP }, matchCount = { 2, 1 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G)</span>
2475     public int test94(Object[] array) {
2476         int res = 0;
2477         for (int i = 1; i &lt; 4; i *= 2) {
2478             Object v = array[i];
2479             res += (Integer)v;
2480         }
2481         return res;
2482     }
2483 
2484     @DontCompile
2485     public void test94_verifier(boolean warmup) {
2486         Object[] array = new Object[4];
2487         array[0] = 0x42;
2488         array[1] = 0x42;
2489         array[2] = 0x42;
2490         array[3] = 0x42;
2491         int result = test94(array);
2492         Asserts.assertEquals(result, 0x42 * 2);
2493     }
2494 
</pre>
<hr />
<pre>
2723     @DontCompile
2724     public void test102_verifier(boolean warmup) {
2725         boolean result = test102(null);
2726         Asserts.assertFalse(result);
2727     }
2728 
2729     // An abstract class with a non-static field can never be implemented by a value type
2730     abstract class NoValueImplementors1 {
2731         int field = 42;
2732     }
2733 
2734     class MyObject3 extends NoValueImplementors1 {
2735 
2736     }
2737 
2738     class MyObject4 extends NoValueImplementors1 {
2739 
2740     }
2741 
2742     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
<span class="line-modified">2743     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
2744     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2745         return array[i];
2746     }
2747 
2748     @DontCompile
2749     public void test103_verifier(boolean warmup) {
2750         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2751         MyObject3[] array2 = new MyObject3[3];
2752         MyObject4[] array3 = new MyObject4[3];
2753         NoValueImplementors1 result = test103(array1, 0);
2754         Asserts.assertEquals(result, array1[0]);
2755 
2756         result = test103(array2, 1);
2757         Asserts.assertEquals(result, array1[1]);
2758 
2759         result = test103(array3, 2);
2760         Asserts.assertEquals(result, array1[2]);
2761     }
2762 
2763     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
</pre>
<hr />
<pre>
2788         Asserts.assertEquals(array2[2], o);
2789         Asserts.assertEquals(result, o);
2790 
2791         result = test104(array3, v, null, 1);
2792         Asserts.assertEquals(array3[0], v);
2793         Asserts.assertEquals(array3[1], v);
2794         Asserts.assertEquals(array3[2], null);
2795         Asserts.assertEquals(result, v);
2796     }
2797 
2798     // An abstract class with a single, non-value implementor
2799     abstract class NoValueImplementors2 {
2800 
2801     }
2802 
2803     class MyObject5 extends NoValueImplementors2 {
2804 
2805     }
2806 
2807     // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor
<span class="line-modified">2808     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
2809     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
2810         return array[i];
2811     }
2812 
2813     @DontCompile
2814     public void test105_verifier(boolean warmup) {
2815         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2816         MyObject5[] array2 = new MyObject5[3];
2817         NoValueImplementors2 result = test105(array1, 0);
2818         Asserts.assertEquals(result, array1[0]);
2819 
2820         result = test105(array2, 1);
2821         Asserts.assertEquals(result, array1[1]);
2822     }
2823 
2824     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor
2825     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2826     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
2827         array[0] = v;
2828         array[1] = array[0];
</pre>
<hr />
<pre>
2887         }
2888     }
2889 
2890     @DontCompile
2891     public void test108_verifier(boolean warmup) {
2892         MyValue2[] dst1 = new MyValue2[100];
2893         Object[] dst2 = new Object[100];
2894         Object o1 = new Object();
2895         rerun_and_recompile_for(&quot;TestLWorld::test108&quot;, 10,
2896                                 () -&gt; { test108(dst1, dst2, testValue2, o1);
2897                                         for (int i = 0; i &lt; dst1.length; i++) {
2898                                             Asserts.assertEquals(dst1[i], testValue2);
2899                                             Asserts.assertEquals(dst2[i], o1);
2900                                         }
2901                                         test108(dst2, dst1, o1, testValue2);
2902                                         for (int i = 0; i &lt; dst1.length; i++) {
2903                                             Asserts.assertEquals(dst1[i], testValue2);
2904                                             Asserts.assertEquals(dst2[i], o1);
2905                                         } });
2906     }

















































































































































































































































































































































2907 }
</pre>
</td>
<td>
<hr />
<pre>
2390 
2391     @Test
2392     public boolean test91(Object obj) {
2393         return obj.getClass() == MyValue2[].class;
2394     }
2395 
2396     @DontCompile
2397     public void test91_verifier(boolean warmup) {
2398         Asserts.assertTrue(test91(new MyValue2[1]));
2399         Asserts.assertFalse(test91(new Object()));
2400     }
2401 
2402     static inline class Test92Value {
2403         final int field;
2404         public Test92Value() {
2405             field = 0x42;
2406         }
2407     }
2408 
2409     @Warmup(10000)
<span class="line-modified">2410     @Test(match = { CLASS_CHECK_TRAP }, matchCount = { 2 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G + MEMBAR)</span>
2411     public Object test92(Object[] array) {
2412         // Dummy loops to ensure we run enough passes of split if
2413         for (int i = 0; i &lt; 2; i++) {
2414             for (int j = 0; j &lt; 2; j++) {
2415               for (int k = 0; k &lt; 2; k++) {
2416               }
2417             }
2418         }
2419 
2420         return (Integer)array[0];
2421     }
2422 
2423     @DontCompile
2424     public void test92_verifier(boolean warmup) {
2425         Object[] array = new Object[1];
2426         array[0] = 0x42;
2427         Object result = test92(array);
2428         Asserts.assertEquals(result, 0x42);
2429     }
2430 
</pre>
<hr />
<pre>
2454             Object[] array = new Test92Value[1];
2455             Method m = tests.get(&quot;TestLWorld::test93&quot;);
2456             int extra = 3;
2457             for (int j = 0; j &lt; extra; j++) {
2458                 for (int i = 0; i &lt; 10; i++) {
2459                     try {
2460                         test93(array);
2461                     } catch (ClassCastException cce) {
2462                     }
2463                 }
2464                 boolean compiled = isCompiledByC2(m);
2465                 Asserts.assertTrue(!USE_COMPILER || XCOMP || STRESS_CC || TEST_C1 || compiled || (j != extra-1));
2466                 if (!compiled) {
2467                     enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
2468                 }
2469             }
2470         }
2471     }
2472 
2473     @Warmup(10000)
<span class="line-modified">2474     @Test(match = { CLASS_CHECK_TRAP, LOOP }, matchCount = { 2, 1 }, failOn = LOAD_UNKNOWN_VALUE + ALLOC_G + MEMBAR)</span>
2475     public int test94(Object[] array) {
2476         int res = 0;
2477         for (int i = 1; i &lt; 4; i *= 2) {
2478             Object v = array[i];
2479             res += (Integer)v;
2480         }
2481         return res;
2482     }
2483 
2484     @DontCompile
2485     public void test94_verifier(boolean warmup) {
2486         Object[] array = new Object[4];
2487         array[0] = 0x42;
2488         array[1] = 0x42;
2489         array[2] = 0x42;
2490         array[3] = 0x42;
2491         int result = test94(array);
2492         Asserts.assertEquals(result, 0x42 * 2);
2493     }
2494 
</pre>
<hr />
<pre>
2723     @DontCompile
2724     public void test102_verifier(boolean warmup) {
2725         boolean result = test102(null);
2726         Asserts.assertFalse(result);
2727     }
2728 
2729     // An abstract class with a non-static field can never be implemented by a value type
2730     abstract class NoValueImplementors1 {
2731         int field = 42;
2732     }
2733 
2734     class MyObject3 extends NoValueImplementors1 {
2735 
2736     }
2737 
2738     class MyObject4 extends NoValueImplementors1 {
2739 
2740     }
2741 
2742     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
<span class="line-modified">2743     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
2744     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
2745         return array[i];
2746     }
2747 
2748     @DontCompile
2749     public void test103_verifier(boolean warmup) {
2750         NoValueImplementors1[] array1 = new NoValueImplementors1[3];
2751         MyObject3[] array2 = new MyObject3[3];
2752         MyObject4[] array3 = new MyObject4[3];
2753         NoValueImplementors1 result = test103(array1, 0);
2754         Asserts.assertEquals(result, array1[0]);
2755 
2756         result = test103(array2, 1);
2757         Asserts.assertEquals(result, array1[1]);
2758 
2759         result = test103(array3, 2);
2760         Asserts.assertEquals(result, array1[2]);
2761     }
2762 
2763     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
</pre>
<hr />
<pre>
2788         Asserts.assertEquals(array2[2], o);
2789         Asserts.assertEquals(result, o);
2790 
2791         result = test104(array3, v, null, 1);
2792         Asserts.assertEquals(array3[0], v);
2793         Asserts.assertEquals(array3[1], v);
2794         Asserts.assertEquals(array3[2], null);
2795         Asserts.assertEquals(result, v);
2796     }
2797 
2798     // An abstract class with a single, non-value implementor
2799     abstract class NoValueImplementors2 {
2800 
2801     }
2802 
2803     class MyObject5 extends NoValueImplementors2 {
2804 
2805     }
2806 
2807     // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor
<span class="line-modified">2808     @Test(failOn = ALLOC_G + MEMBAR + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
2809     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
2810         return array[i];
2811     }
2812 
2813     @DontCompile
2814     public void test105_verifier(boolean warmup) {
2815         NoValueImplementors2[] array1 = new NoValueImplementors2[3];
2816         MyObject5[] array2 = new MyObject5[3];
2817         NoValueImplementors2 result = test105(array1, 0);
2818         Asserts.assertEquals(result, array1[0]);
2819 
2820         result = test105(array2, 1);
2821         Asserts.assertEquals(result, array1[1]);
2822     }
2823 
2824     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor
2825     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
2826     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
2827         array[0] = v;
2828         array[1] = array[0];
</pre>
<hr />
<pre>
2887         }
2888     }
2889 
2890     @DontCompile
2891     public void test108_verifier(boolean warmup) {
2892         MyValue2[] dst1 = new MyValue2[100];
2893         Object[] dst2 = new Object[100];
2894         Object o1 = new Object();
2895         rerun_and_recompile_for(&quot;TestLWorld::test108&quot;, 10,
2896                                 () -&gt; { test108(dst1, dst2, testValue2, o1);
2897                                         for (int i = 0; i &lt; dst1.length; i++) {
2898                                             Asserts.assertEquals(dst1[i], testValue2);
2899                                             Asserts.assertEquals(dst2[i], o1);
2900                                         }
2901                                         test108(dst2, dst1, o1, testValue2);
2902                                         for (int i = 0; i &lt; dst1.length; i++) {
2903                                             Asserts.assertEquals(dst1[i], testValue2);
2904                                             Asserts.assertEquals(dst2[i], o1);
2905                                         } });
2906     }
<span class="line-added">2907 </span>
<span class="line-added">2908     // Escape analysis tests</span>
<span class="line-added">2909 </span>
<span class="line-added">2910     static interface WrapperInterface {</span>
<span class="line-added">2911         long value();</span>
<span class="line-added">2912 </span>
<span class="line-added">2913         final static WrapperInterface ZERO = new LongWrapper(0);</span>
<span class="line-added">2914 </span>
<span class="line-added">2915         static WrapperInterface wrap(long val) {</span>
<span class="line-added">2916             return (val == 0L) ? ZERO : new LongWrapper(val);</span>
<span class="line-added">2917         }</span>
<span class="line-added">2918     }</span>
<span class="line-added">2919 </span>
<span class="line-added">2920     static inline class LongWrapper implements WrapperInterface {</span>
<span class="line-added">2921         final static LongWrapper ZERO = new LongWrapper(0);</span>
<span class="line-added">2922         private long val;</span>
<span class="line-added">2923 </span>
<span class="line-added">2924         LongWrapper(long val) {</span>
<span class="line-added">2925             this.val = val;</span>
<span class="line-added">2926         }</span>
<span class="line-added">2927 </span>
<span class="line-added">2928         static LongWrapper wrap(long val) {</span>
<span class="line-added">2929             return (val == 0L) ? ZERO : new LongWrapper(val);</span>
<span class="line-added">2930         }</span>
<span class="line-added">2931 </span>
<span class="line-added">2932         public long value() {</span>
<span class="line-added">2933             return val;</span>
<span class="line-added">2934         }</span>
<span class="line-added">2935     }</span>
<span class="line-added">2936 </span>
<span class="line-added">2937     static class InterfaceBox {</span>
<span class="line-added">2938         WrapperInterface content;</span>
<span class="line-added">2939 </span>
<span class="line-added">2940         InterfaceBox(WrapperInterface content) {</span>
<span class="line-added">2941             this.content = content;</span>
<span class="line-added">2942         }</span>
<span class="line-added">2943 </span>
<span class="line-added">2944         static InterfaceBox box_sharp(long val) {</span>
<span class="line-added">2945             return new InterfaceBox(LongWrapper.wrap(val));</span>
<span class="line-added">2946         }</span>
<span class="line-added">2947 </span>
<span class="line-added">2948         static InterfaceBox box(long val) {</span>
<span class="line-added">2949             return new InterfaceBox(WrapperInterface.wrap(val));</span>
<span class="line-added">2950         }</span>
<span class="line-added">2951     }</span>
<span class="line-added">2952 </span>
<span class="line-added">2953     static class ObjectBox {</span>
<span class="line-added">2954         Object content;</span>
<span class="line-added">2955 </span>
<span class="line-added">2956         ObjectBox(Object content) {</span>
<span class="line-added">2957             this.content = content;</span>
<span class="line-added">2958         }</span>
<span class="line-added">2959 </span>
<span class="line-added">2960         static ObjectBox box_sharp(long val) {</span>
<span class="line-added">2961             return new ObjectBox(LongWrapper.wrap(val));</span>
<span class="line-added">2962         }</span>
<span class="line-added">2963 </span>
<span class="line-added">2964         static ObjectBox box(long val) {</span>
<span class="line-added">2965             return new ObjectBox(WrapperInterface.wrap(val));</span>
<span class="line-added">2966         }</span>
<span class="line-added">2967     }</span>
<span class="line-added">2968 </span>
<span class="line-added">2969     static class RefBox {</span>
<span class="line-added">2970         LongWrapper.ref content;</span>
<span class="line-added">2971 </span>
<span class="line-added">2972         RefBox(LongWrapper.ref content) {</span>
<span class="line-added">2973             this.content = content;</span>
<span class="line-added">2974         }</span>
<span class="line-added">2975 </span>
<span class="line-added">2976         static RefBox box_sharp(long val) {</span>
<span class="line-added">2977             return new RefBox(LongWrapper.wrap(val));</span>
<span class="line-added">2978         }</span>
<span class="line-added">2979 </span>
<span class="line-added">2980         static RefBox box(long val) {</span>
<span class="line-added">2981             return new RefBox((LongWrapper.ref)WrapperInterface.wrap(val));</span>
<span class="line-added">2982         }</span>
<span class="line-added">2983     }</span>
<span class="line-added">2984 </span>
<span class="line-added">2985     static class InlineBox {</span>
<span class="line-added">2986         LongWrapper content;</span>
<span class="line-added">2987 </span>
<span class="line-added">2988         InlineBox(long val) {</span>
<span class="line-added">2989             this.content = LongWrapper.wrap(val);</span>
<span class="line-added">2990         }</span>
<span class="line-added">2991 </span>
<span class="line-added">2992         static InlineBox box(long val) {</span>
<span class="line-added">2993             return new InlineBox(val);</span>
<span class="line-added">2994         }</span>
<span class="line-added">2995     }</span>
<span class="line-added">2996 </span>
<span class="line-added">2997     static class GenericBox&lt;T&gt; {</span>
<span class="line-added">2998         T content;</span>
<span class="line-added">2999 </span>
<span class="line-added">3000         static GenericBox&lt;LongWrapper.ref&gt; box_sharp(long val) {</span>
<span class="line-added">3001             GenericBox&lt;LongWrapper.ref&gt; res = new GenericBox&lt;&gt;();</span>
<span class="line-added">3002             res.content = LongWrapper.wrap(val);</span>
<span class="line-added">3003             return res;</span>
<span class="line-added">3004         }</span>
<span class="line-added">3005 </span>
<span class="line-added">3006         static GenericBox&lt;WrapperInterface&gt; box(long val) {</span>
<span class="line-added">3007             GenericBox&lt;WrapperInterface&gt; res = new GenericBox&lt;&gt;();</span>
<span class="line-added">3008             res.content = WrapperInterface.wrap(val);</span>
<span class="line-added">3009             return res;</span>
<span class="line-added">3010         }</span>
<span class="line-added">3011     }</span>
<span class="line-added">3012 </span>
<span class="line-added">3013     long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};</span>
<span class="line-added">3014 </span>
<span class="line-added">3015     // Test removal of allocations when inline type instance is wrapped into box object</span>
<span class="line-added">3016     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3017     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3018     public long test109() {</span>
<span class="line-added">3019         long res = 0;</span>
<span class="line-added">3020         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3021             res += InterfaceBox.box(lArr[i]).content.value();</span>
<span class="line-added">3022         }</span>
<span class="line-added">3023         return res;</span>
<span class="line-added">3024     }</span>
<span class="line-added">3025 </span>
<span class="line-added">3026     @DontCompile</span>
<span class="line-added">3027     public void test109_verifier(boolean warmup) {</span>
<span class="line-added">3028         long res = test109();</span>
<span class="line-added">3029         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3030     }</span>
<span class="line-added">3031 </span>
<span class="line-added">3032     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3033     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3034     public long test109_sharp() {</span>
<span class="line-added">3035         long res = 0;</span>
<span class="line-added">3036         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3037             res += InterfaceBox.box_sharp(lArr[i]).content.value();</span>
<span class="line-added">3038         }</span>
<span class="line-added">3039         return res;</span>
<span class="line-added">3040     }</span>
<span class="line-added">3041 </span>
<span class="line-added">3042     @DontCompile</span>
<span class="line-added">3043     public void test109_sharp_verifier(boolean warmup) {</span>
<span class="line-added">3044         long res = test109_sharp();</span>
<span class="line-added">3045         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3046     }</span>
<span class="line-added">3047 </span>
<span class="line-added">3048     // Same as test109 but with ObjectBox</span>
<span class="line-added">3049     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3050     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3051     public long test110() {</span>
<span class="line-added">3052         long res = 0;</span>
<span class="line-added">3053         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3054             res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();</span>
<span class="line-added">3055         }</span>
<span class="line-added">3056         return res;</span>
<span class="line-added">3057     }</span>
<span class="line-added">3058 </span>
<span class="line-added">3059     @DontCompile</span>
<span class="line-added">3060     public void test110_verifier(boolean warmup) {</span>
<span class="line-added">3061         long res = test110();</span>
<span class="line-added">3062         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3063     }</span>
<span class="line-added">3064 </span>
<span class="line-added">3065     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3066     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3067     public long test110_sharp() {</span>
<span class="line-added">3068         long res = 0;</span>
<span class="line-added">3069         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3070             res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();</span>
<span class="line-added">3071         }</span>
<span class="line-added">3072         return res;</span>
<span class="line-added">3073     }</span>
<span class="line-added">3074 </span>
<span class="line-added">3075     @DontCompile</span>
<span class="line-added">3076     public void test110_sharp_verifier(boolean warmup) {</span>
<span class="line-added">3077         long res = test110_sharp();</span>
<span class="line-added">3078         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3079     }</span>
<span class="line-added">3080 </span>
<span class="line-added">3081     // Same as test109 but with RefBox</span>
<span class="line-added">3082     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3083     public long test111() {</span>
<span class="line-added">3084         long res = 0;</span>
<span class="line-added">3085         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3086             res += RefBox.box(lArr[i]).content.value();</span>
<span class="line-added">3087         }</span>
<span class="line-added">3088         return res;</span>
<span class="line-added">3089     }</span>
<span class="line-added">3090 </span>
<span class="line-added">3091     @DontCompile</span>
<span class="line-added">3092     public void test111_verifier(boolean warmup) {</span>
<span class="line-added">3093         long res = test111();</span>
<span class="line-added">3094         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3095     }</span>
<span class="line-added">3096 </span>
<span class="line-added">3097     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3098     public long test111_sharp() {</span>
<span class="line-added">3099         long res = 0;</span>
<span class="line-added">3100         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3101             res += RefBox.box_sharp(lArr[i]).content.value();</span>
<span class="line-added">3102         }</span>
<span class="line-added">3103         return res;</span>
<span class="line-added">3104     }</span>
<span class="line-added">3105 </span>
<span class="line-added">3106     @DontCompile</span>
<span class="line-added">3107     public void test111_sharp_verifier(boolean warmup) {</span>
<span class="line-added">3108         long res = test111_sharp();</span>
<span class="line-added">3109         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3110     }</span>
<span class="line-added">3111 </span>
<span class="line-added">3112     // Same as test109 but with InlineBox</span>
<span class="line-added">3113     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3114     public long test112() {</span>
<span class="line-added">3115         long res = 0;</span>
<span class="line-added">3116         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3117             res += InlineBox.box(lArr[i]).content.value();</span>
<span class="line-added">3118         }</span>
<span class="line-added">3119         return res;</span>
<span class="line-added">3120     }</span>
<span class="line-added">3121 </span>
<span class="line-added">3122     @DontCompile</span>
<span class="line-added">3123     public void test112_verifier(boolean warmup) {</span>
<span class="line-added">3124         long res = test112();</span>
<span class="line-added">3125         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3126     }</span>
<span class="line-added">3127 </span>
<span class="line-added">3128     // Same as test109 but with GenericBox</span>
<span class="line-added">3129     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3130     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3131     public long test113() {</span>
<span class="line-added">3132         long res = 0;</span>
<span class="line-added">3133         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3134             res += GenericBox.box(lArr[i]).content.value();</span>
<span class="line-added">3135         }</span>
<span class="line-added">3136         return res;</span>
<span class="line-added">3137     }</span>
<span class="line-added">3138 </span>
<span class="line-added">3139     @DontCompile</span>
<span class="line-added">3140     public void test113_verifier(boolean warmup) {</span>
<span class="line-added">3141         long res = test113();</span>
<span class="line-added">3142         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3143     }</span>
<span class="line-added">3144 </span>
<span class="line-added">3145     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3146     @Warmup(10000) // Make sure interface calls are inlined</span>
<span class="line-added">3147     public long test113_sharp() {</span>
<span class="line-added">3148         long res = 0;</span>
<span class="line-added">3149         for (int i = 0 ; i &lt; lArr.length; i++) {</span>
<span class="line-added">3150             res += GenericBox.box_sharp(lArr[i]).content.value();</span>
<span class="line-added">3151         }</span>
<span class="line-added">3152         return res;</span>
<span class="line-added">3153     }</span>
<span class="line-added">3154 </span>
<span class="line-added">3155     @DontCompile</span>
<span class="line-added">3156     public void test113_sharp_verifier(boolean warmup) {</span>
<span class="line-added">3157         long res = test113_sharp();</span>
<span class="line-added">3158         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3159     }</span>
<span class="line-added">3160 </span>
<span class="line-added">3161     static interface WrapperInterface2 {</span>
<span class="line-added">3162         public long value();</span>
<span class="line-added">3163 </span>
<span class="line-added">3164         static final InlineWrapper.ref ZERO = new InlineWrapper(0);</span>
<span class="line-added">3165 </span>
<span class="line-added">3166         public static WrapperInterface2 wrap(long val) {</span>
<span class="line-added">3167             return (val == 0) ? ZERO.content : new LongWrapper2(val);</span>
<span class="line-added">3168         }</span>
<span class="line-added">3169 </span>
<span class="line-added">3170         public static WrapperInterface2 wrap_default(long val) {</span>
<span class="line-added">3171             return (val == 0) ? LongWrapper2.default : new LongWrapper2(val);</span>
<span class="line-added">3172         }</span>
<span class="line-added">3173     }</span>
<span class="line-added">3174 </span>
<span class="line-added">3175     static inline class LongWrapper2 implements WrapperInterface2 {</span>
<span class="line-added">3176         private long val;</span>
<span class="line-added">3177 </span>
<span class="line-added">3178         public LongWrapper2(long val) {</span>
<span class="line-added">3179             this.val = val;</span>
<span class="line-added">3180         }</span>
<span class="line-added">3181 </span>
<span class="line-added">3182         public long value() {</span>
<span class="line-added">3183             return val;</span>
<span class="line-added">3184         }</span>
<span class="line-added">3185     }</span>
<span class="line-added">3186 </span>
<span class="line-added">3187     static inline class InlineWrapper {</span>
<span class="line-added">3188         WrapperInterface2 content;</span>
<span class="line-added">3189 </span>
<span class="line-added">3190         public InlineWrapper(long val) {</span>
<span class="line-added">3191             content = new LongWrapper2(val);</span>
<span class="line-added">3192         }</span>
<span class="line-added">3193     }</span>
<span class="line-added">3194 </span>
<span class="line-added">3195     static class InterfaceBox2 {</span>
<span class="line-added">3196         WrapperInterface2 content;</span>
<span class="line-added">3197 </span>
<span class="line-added">3198         public InterfaceBox2(long val, boolean def) {</span>
<span class="line-added">3199             this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);</span>
<span class="line-added">3200         }</span>
<span class="line-added">3201 </span>
<span class="line-added">3202         static InterfaceBox2 box(long val) {</span>
<span class="line-added">3203             return new InterfaceBox2(val, false);</span>
<span class="line-added">3204         }</span>
<span class="line-added">3205 </span>
<span class="line-added">3206         static InterfaceBox2 box_default(long val) {</span>
<span class="line-added">3207             return new InterfaceBox2(val, true);</span>
<span class="line-added">3208         }</span>
<span class="line-added">3209     }</span>
<span class="line-added">3210 </span>
<span class="line-added">3211     // Same as tests above but with ZERO hidden in field of another inline type</span>
<span class="line-added">3212     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3213     @Warmup(10000)</span>
<span class="line-added">3214     public long test114() {</span>
<span class="line-added">3215         long res = 0;</span>
<span class="line-added">3216         for (int i = 0; i &lt; lArr.length; i++) {</span>
<span class="line-added">3217             res += InterfaceBox2.box(lArr[i]).content.value();</span>
<span class="line-added">3218         }</span>
<span class="line-added">3219         return res;</span>
<span class="line-added">3220     }</span>
<span class="line-added">3221 </span>
<span class="line-added">3222     @DontCompile</span>
<span class="line-added">3223     public void test114_verifier(boolean warmup) {</span>
<span class="line-added">3224         long res = test114();</span>
<span class="line-added">3225         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3226     }</span>
<span class="line-added">3227 </span>
<span class="line-added">3228     // Same as test114 but with .default instead of ZERO field</span>
<span class="line-added">3229     @Test(failOn = ALLOC_G + MEMBAR, match = { PREDICATE_TRAP }, matchCount = { 1 })</span>
<span class="line-added">3230     @Warmup(10000)</span>
<span class="line-added">3231     public long test115() {</span>
<span class="line-added">3232         long res = 0;</span>
<span class="line-added">3233         for (int i = 0; i &lt; lArr.length; i++) {</span>
<span class="line-added">3234             res += InterfaceBox2.box_default(lArr[i]).content.value();</span>
<span class="line-added">3235         }</span>
<span class="line-added">3236         return res;</span>
<span class="line-added">3237     }</span>
<span class="line-added">3238 </span>
<span class="line-added">3239     @DontCompile</span>
<span class="line-added">3240     public void test115_verifier(boolean warmup) {</span>
<span class="line-added">3241         long res = test115();</span>
<span class="line-added">3242         Asserts.assertEquals(res, 5*rL);</span>
<span class="line-added">3243     }</span>
3244 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../src/hotspot/share/opto/valuetypenode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cfgnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 405,12 ***</span>
      if (!useful.member(opaq)) {
        remove_opaque4_node(opaq);
      }
    }
    // Remove useless value type nodes
<span class="line-modified">!   if (_value_type_nodes != NULL) {</span>
<span class="line-modified">!     _value_type_nodes-&gt;remove_useless_nodes(useful.member_set());</span>
    }
    BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
    bs-&gt;eliminate_useless_gc_barriers(useful, this);
    // clean up the late inline lists
    remove_useless_late_inlines(&amp;_string_late_inlines, useful);
<span class="line-new-header">--- 405,15 ---</span>
      if (!useful.member(opaq)) {
        remove_opaque4_node(opaq);
      }
    }
    // Remove useless value type nodes
<span class="line-modified">!   for (int i = _value_type_nodes-&gt;length() - 1; i &gt;= 0; i--) {</span>
<span class="line-modified">!     Node* vt = _value_type_nodes-&gt;at(i);</span>
<span class="line-added">+     if (!useful.member(vt)) {</span>
<span class="line-added">+       _value_type_nodes-&gt;remove(vt);</span>
<span class="line-added">+     }</span>
    }
    BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
    bs-&gt;eliminate_useless_gc_barriers(useful, this);
    // clean up the late inline lists
    remove_useless_late_inlines(&amp;_string_late_inlines, useful);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1018,11 ***</span>
    _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
<span class="line-modified">!   _value_type_nodes = new (comp_arena()) Unique_Node_List(comp_arena());</span>
    register_library_intrinsics();
  #ifdef ASSERT
    _type_verify_symmetry = true;
  #endif
  }
<span class="line-new-header">--- 1021,11 ---</span>
    _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
<span class="line-modified">!   _value_type_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);</span>
    register_library_intrinsics();
  #ifdef ASSERT
    _type_verify_symmetry = true;
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1874,28 ***</span>
    }
  }
  
  void Compile::remove_value_type(Node* n) {
    assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
<span class="line-modified">!   if (_value_type_nodes != NULL) {</span>
      _value_type_nodes-&gt;remove(n);
    }
  }
  
<span class="line-modified">! // Does the return value keep otherwise useless value type allocations</span>
<span class="line-removed">- // alive?</span>
  static bool return_val_keeps_allocations_alive(Node* ret_val) {
    ResourceMark rm;
    Unique_Node_List wq;
    wq.push(ret_val);
    bool some_allocations = false;
    for (uint i = 0; i &lt; wq.size(); i++) {
      Node* n = wq.at(i);
<span class="line-modified">!     assert(!n-&gt;is_ValueTypeBase(), &quot;chain of value type nodes&quot;);</span>
      if (n-&gt;outcnt() &gt; 1) {
        // Some other use for the allocation
        return false;
      } else if (n-&gt;is_Phi()) {
        for (uint j = 1; j &lt; n-&gt;req(); j++) {
          wq.push(n-&gt;in(j));
        }
      } else if (n-&gt;is_CheckCastPP() &amp;&amp;
<span class="line-new-header">--- 1877,29 ---</span>
    }
  }
  
  void Compile::remove_value_type(Node* n) {
    assert(n-&gt;is_ValueTypeBase(), &quot;unexpected node&quot;);
<span class="line-modified">!   if (_value_type_nodes != NULL &amp;&amp; _value_type_nodes-&gt;contains(n)) {</span>
      _value_type_nodes-&gt;remove(n);
    }
  }
  
<span class="line-modified">! // Does the return value keep otherwise useless value type allocations alive?</span>
  static bool return_val_keeps_allocations_alive(Node* ret_val) {
    ResourceMark rm;
    Unique_Node_List wq;
    wq.push(ret_val);
    bool some_allocations = false;
    for (uint i = 0; i &lt; wq.size(); i++) {
      Node* n = wq.at(i);
<span class="line-modified">!     assert(!n-&gt;is_ValueType(), &quot;chain of value type nodes&quot;);</span>
      if (n-&gt;outcnt() &gt; 1) {
        // Some other use for the allocation
        return false;
<span class="line-added">+     } else if (n-&gt;is_ValueTypePtr()) {</span>
<span class="line-added">+       wq.push(n-&gt;in(1));</span>
      } else if (n-&gt;is_Phi()) {
        for (uint j = 1; j &lt; n-&gt;req(); j++) {
          wq.push(n-&gt;in(j));
        }
      } else if (n-&gt;is_CheckCastPP() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1905,22 ***</span>
      }
    }
    return some_allocations;
  }
  
<span class="line-modified">! void Compile::process_value_types(PhaseIterGVN &amp;igvn) {</span>
    // Make value types scalar in safepoints
<span class="line-modified">!   while (_value_type_nodes-&gt;size() != 0) {</span>
<span class="line-modified">!     ValueTypeBaseNode* vt = _value_type_nodes-&gt;pop()-&gt;as_ValueTypeBase();</span>
      vt-&gt;make_scalar_in_safepoints(&amp;igvn);
<span class="line-modified">!     if (vt-&gt;is_ValueTypePtr()) {</span>
<span class="line-modified">!       igvn.replace_node(vt, vt-&gt;get_oop());</span>
<span class="line-modified">!     } else if (vt-&gt;outcnt() == 0) {</span>
<span class="line-modified">!       igvn.remove_dead_node(vt);</span>
      }
    }
<span class="line-modified">!   _value_type_nodes = NULL;</span>
    if (tf()-&gt;returns_value_type_as_fields()) {
      Node* ret = NULL;
      for (uint i = 1; i &lt; root()-&gt;req(); i++){
        Node* in = root()-&gt;in(i);
        if (in-&gt;Opcode() == Op_Return) {
<span class="line-new-header">--- 1909,28 ---</span>
      }
    }
    return some_allocations;
  }
  
<span class="line-modified">! void Compile::process_value_types(PhaseIterGVN &amp;igvn, bool post_ea) {</span>
    // Make value types scalar in safepoints
<span class="line-modified">!   for (int i = _value_type_nodes-&gt;length()-1; i &gt;= 0; i--) {</span>
<span class="line-modified">!     ValueTypeBaseNode* vt = _value_type_nodes-&gt;at(i)-&gt;as_ValueTypeBase();</span>
      vt-&gt;make_scalar_in_safepoints(&amp;igvn);
<span class="line-modified">!   }</span>
<span class="line-modified">!   // Remove ValueTypePtr nodes only after EA to give scalar replacement a chance</span>
<span class="line-modified">!   // to remove buffer allocations. ValueType nodes are kept until loop opts and</span>
<span class="line-modified">!   // removed via ValueTypeNode::remove_redundant_allocations.</span>
<span class="line-added">+   if (post_ea) {</span>
<span class="line-added">+     while (_value_type_nodes-&gt;length() &gt; 0) {</span>
<span class="line-added">+       ValueTypeBaseNode* vt = _value_type_nodes-&gt;pop()-&gt;as_ValueTypeBase();</span>
<span class="line-added">+       if (vt-&gt;is_ValueTypePtr()) {</span>
<span class="line-added">+         igvn.replace_node(vt, vt-&gt;get_oop());</span>
<span class="line-added">+       }</span>
      }
    }
<span class="line-modified">!   // Make sure that the return value does not keep an unused allocation alive</span>
    if (tf()-&gt;returns_value_type_as_fields()) {
      Node* ret = NULL;
      for (uint i = 1; i &lt; root()-&gt;req(); i++){
        Node* in = root()-&gt;in(i);
        if (in-&gt;Opcode() == Op_Return) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2485,11 ***</span>
      set_for_igvn(&amp;new_worklist);
      igvn = PhaseIterGVN(initial_gvn());
      igvn.optimize();
    }
  
<span class="line-modified">!   if (_value_type_nodes-&gt;size() &gt; 0) {</span>
      // Do this once all inlining is over to avoid getting inconsistent debug info
      process_value_types(igvn);
    }
  
    adjust_flattened_array_access_aliases(igvn);
<span class="line-new-header">--- 2495,11 ---</span>
      set_for_igvn(&amp;new_worklist);
      igvn = PhaseIterGVN(initial_gvn());
      igvn.optimize();
    }
  
<span class="line-modified">!   if (_value_type_nodes-&gt;length() &gt; 0) {</span>
      // Do this once all inlining is over to avoid getting inconsistent debug info
      process_value_types(igvn);
    }
  
    adjust_flattened_array_access_aliases(igvn);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2524,10 ***</span>
<span class="line-new-header">--- 2534,15 ---</span>
  
        if (failing())  return;
      }
    }
  
<span class="line-added">+   if (_value_type_nodes-&gt;length() &gt; 0) {</span>
<span class="line-added">+     // Process value types again now that EA might have simplified the graph</span>
<span class="line-added">+     process_value_types(igvn, /* post_ea= */ true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Loop transforms on the ideal graph.  Range Check Elimination,
    // peeling, unrolling, etc.
  
    // Set loop opts counter
    if((_loop_opts_cnt &gt; 0) &amp;&amp; (has_loops() || has_split_ifs())) {
</pre>
<center><a href="cfgnode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
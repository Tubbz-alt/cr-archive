<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/valuetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/valuetypenode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;opto/rootnode.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the values type to handle control flow merges involving multiple value types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 ValueTypeBaseNode* ValueTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);
 38   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(value_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
<span class="line-modified"> 50     if (type-&gt;is_valuetype() &amp;&amp; value-&gt;isa_ValueType()) {</span>
 51       // Handle flattened value type fields recursively
<span class="line-modified"> 52       value = value-&gt;as_ValueType()-&gt;clone_with_phis(gvn, region);</span>
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the ValueBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see ValueBaseTypeNode::clone_with_phis).
 66 bool ValueTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
</pre>
<hr />
<pre>
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 ValueTypeBaseNode* ValueTypeBaseNode::merge_with(PhaseGVN* gvn, const ValueTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
<span class="line-modified"> 98     if (val1-&gt;is_ValueType()) {</span>
<span class="line-modified"> 99       val1-&gt;as_ValueType()-&gt;merge_with(gvn, val2-&gt;as_ValueType(), pnum, transform);</span>
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       assert(!val2-&gt;is_ValueType(), &quot;inconsistent merge values&quot;);
103       val1-&gt;set_req(pnum, val2);
104     }
105     if (transform) {
106       set_field_value(i, gvn-&gt;transform(val1));
107       gvn-&gt;record_for_igvn(val1);
108     }
109   }
110   return this;
111 }
112 
113 // Adds a new merge path to a valuetype node with phi inputs
114 void ValueTypeBaseNode::add_new_path(Node* region) {
115   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
116 
117   PhiNode* phi = get_oop()-&gt;as_Phi();
118   phi-&gt;add_req(NULL);
119   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
</pre>
<hr />
<pre>
236   Unique_Node_List worklist;
237   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
238     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
239     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
240       int nb = 0;
241       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
242         // Value type is allocated with a constant oop, link it directly
243         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
244         igvn-&gt;rehash_node_delayed(sfpt);
245       } else {
246         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
247       }
248       --i; imax -= nb;
249     }
250   }
251   // Now scalarize non-flattened fields
252   for (uint i = 0; i &lt; worklist.size(); ++i) {
253     Node* vt = worklist.at(i);
254     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(igvn);
255   }

256 }
257 
258 const TypePtr* ValueTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
259   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
260   const TypePtr* adr_type = NULL;
261   bool is_array = ary_type != NULL;
262   if ((decorators &amp; C2_MISMATCHED) != 0) {
263     adr_type = TypeRawPtr::BOTTOM;
264   } else if (is_array) {
265     // In the case of a flattened value type array, each field has its own slice
266     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
267   } else {
268     ciField* field = holder-&gt;get_field_by_offset(offset, false);
269     assert(field != NULL, &quot;field not found&quot;);
270     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
271   }
272   return adr_type;
273 }
274 
275 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
</pre>
<hr />
<pre>
279     int offset = holder_offset + field_offset(i);
280     Node* value = NULL;
281     ciType* ft = field_type(i);
282     bool is_flattenable = field_is_flattenable(i);
283     if (field_is_flattened(i)) {
284       // Recursively load the flattened value type field
285       value = ValueTypeNode::make_from_flattened(kit, ft-&gt;as_value_klass(), base, ptr, holder, offset, decorators);
286     } else {
287       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
288       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
289       if (base-&gt;is_Con() &amp;&amp; !is_array) {
290         // If the oop to the value type is constant (static final field), we can
291         // also treat the fields as constants because the value type is immutable.
292         ciObject* constant_oop = oop_ptr-&gt;const_oop();
293         ciField* field = holder-&gt;get_field_by_offset(offset, false);
294         assert(field != NULL, &quot;field not found&quot;);
295         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
296         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
297         assert(con_type != NULL, &quot;type not found&quot;);
298         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
<span class="line-modified">299         if (ft-&gt;is_valuetype() &amp;&amp; !constant.as_object()-&gt;is_null_object()) {</span>

300           // Null-free, treat as flattenable

301           is_flattenable = true;
302         }
303       } else {
304         // Load field value from memory
305         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
306         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
307         BasicType bt = type2field[ft-&gt;basic_type()];
308         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
309         const Type* val_type = Type::get_const_type(ft);
310         if (is_array) {
311           decorators |= IS_ARRAY;
312         }
313         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
314       }
315       if (is_flattenable) {
316         // Loading a non-flattened but flattenable value type from memory
317         if (ft-&gt;as_value_klass()-&gt;is_scalarizable()) {
318           value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
319         } else {
320           value = kit-&gt;null2default(value, ft-&gt;as_value_klass());
</pre>
<hr />
<pre>
347         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);
348         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
349       }
350       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
351     } else {
352       // Store field value to memory
353       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
354       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
355       BasicType bt = type2field[ft-&gt;basic_type()];
356       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
357       const Type* val_type = Type::get_const_type(ft);
358       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
359       if (ary_type != NULL) {
360         decorators |= IS_ARRAY;
361       }
362       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
363     }
364   }
365 }
366 
<span class="line-modified">367 ValueTypeBaseNode* ValueTypeBaseNode::allocate(GraphKit* kit, bool safe_for_replace) {</span>

368   // Check if value type is already allocated
369   Node* null_ctl = kit-&gt;top();
370   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
371   if (null_ctl-&gt;is_top()) {
372     // Value type is allocated
<span class="line-modified">373     return this;</span>
374   }
375   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
376   RegionNode* region = new RegionNode(3);
377 
378   // Oop is non-NULL, use it
379   region-&gt;init_req(1, kit-&gt;control());
380   PhiNode* oop = PhiNode::make(region, not_null_oop, value_ptr());
381   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
382   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
383 
384   int bci = kit-&gt;bci();
385   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
386   {
387     // Oop is NULL, allocate and initialize buffer
388     PreserveJVMState pjvms(kit);
389     // Propagate re-execution state and bci
390     kit-&gt;set_bci(bci);
391     kit-&gt;jvms()-&gt;set_bci(bci);
392     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
393     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
413   kit-&gt;set_control(kit-&gt;gvn().transform(region));
414   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
415   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
416   kit-&gt;record_for_igvn(region);
417   kit-&gt;record_for_igvn(oop);
418   kit-&gt;record_for_igvn(io);
419   kit-&gt;record_for_igvn(mem);
420 
421   // Use cloned ValueTypeNode to propagate oop from now on
422   Node* res_oop = kit-&gt;gvn().transform(oop);
423   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
424   vt-&gt;set_oop(res_oop);
425   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
426   if (safe_for_replace) {
427     kit-&gt;replace_in_map(this, vt);
428   }
429   // ValueTypeNode::remove_redundant_allocations piggybacks on split if.
430   // Make sure it gets a chance to remove this allocation.
431   kit-&gt;C-&gt;set_has_split_ifs(true);
432   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
<span class="line-modified">433   return vt;</span>
434 }
435 
436 bool ValueTypeBaseNode::is_allocated(PhaseGVN* phase) const {
437   Node* oop = get_oop();
438   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
439   return !oop_type-&gt;maybe_null();
440 }
441 
442 // When a call returns multiple values, it has several result
443 // projections, one per field. Replacing the result of the call by a
444 // value type node (after late inlining) requires that for each result
445 // projection, we find the corresponding value type field.
446 void ValueTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
447   ciValueKlass* vk = value_klass();
448   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
449     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
450     uint con = pn-&gt;_con;
451     if (con &gt;= TypeFunc::Parms+1) {
452       uint field_nb = con - (TypeFunc::Parms+1);
453       int extra = 0;
</pre>
<hr />
<pre>
464         assert(field-&gt;as_ValueType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
465         field = field-&gt;as_ValueType()-&gt;get_oop();
466       }
467       C-&gt;gvn_replace_by(pn, field);
468       C-&gt;initial_gvn()-&gt;hash_delete(pn);
469       pn-&gt;set_req(0, C-&gt;top());
470       --i; --imax;
471     }
472   }
473 }
474 
475 Node* ValueTypeBaseNode::allocate_fields(GraphKit* kit) {
476   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
477   for (uint i = 0; i &lt; field_count(); i++) {
478      ValueTypeNode* value = field_value(i)-&gt;isa_ValueType();
479      if (field_is_flattened(i)) {
480        // Flattened value type field
481        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
482      } else if (value != NULL) {
483        // Non-flattened value type field
<span class="line-modified">484        vt-&gt;set_field_value(i, value-&gt;allocate(kit));</span>
485      }
486   }
487   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
488   kit-&gt;replace_in_map(this, vt);
489   return vt;
490 }
491 
492 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
493   // Create a new ValueTypeNode with uninitialized values and NULL oop
494   return new ValueTypeNode(vk, gvn.zerocon(T_VALUETYPE));
495 }
496 
497 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
498   // Returns the constant oop of the default value type allocation
499   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
500 }
501 
502 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
503   // Create a new ValueTypeNode with default values
504   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
</pre>
<hr />
<pre>
701   intptr_t bits = tk-&gt;get_con();
702   set_nth_bit(bits, 0);
703   return gvn.makecon(TypeRawPtr::make((address)bits));
704 }
705 
706 void ValueTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
707   for (uint i = 0; i &lt; field_count(); i++) {
708     int sig_offset = (*sig)._offset;
709     uint idx = field_index(sig_offset - base_offset);
710     Node* arg = field_value(idx);
711 
712     if (field_is_flattened(idx)) {
713       // Flattened value type field
714       ValueTypeNode* vt = arg-&gt;as_ValueType();
715       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;value_klass()-&gt;first_field_offset());
716     } else {
717       if (arg-&gt;is_ValueType()) {
718         // Non-flattened value type field
719         ValueTypeNode* vt = arg-&gt;as_ValueType();
720         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;value type field should be allocated on return&quot;);
<span class="line-modified">721         arg = vt-&gt;allocate(kit)-&gt;get_oop();</span>
722       }
723       // Initialize call/return arguments
724       BasicType bt = field_type(i)-&gt;basic_type();
725       n-&gt;init_req(base_input++, arg);
726       if (type2size[bt] == 2) {
727         n-&gt;init_req(base_input++, kit-&gt;top());
728       }
729       // Skip reserved arguments
730       while (SigEntry::next_is_reserved(sig, bt)) {
731         n-&gt;init_req(base_input++, kit-&gt;top());
732         if (type2size[bt] == 2) {
733           n-&gt;init_req(base_input++, kit-&gt;top());
734         }
735       }
736     }
737   }
738 }
739 
740 void ValueTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
741   PhaseGVN&amp; gvn = kit-&gt;gvn();
</pre>
<hr />
<pre>
875         // The value type is already allocated but still connected to an AllocateNode.
876         // This can happen with late inlining when we first allocate a value type argument
877         // but later decide to inline the call with the callee code also allocating.
878         res_dom = get_oop();
879       } else {
880         // Search for a dominating allocation of the same value type
881         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
882           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
883           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::ValueNode) == this) {
884             Node* res_other = alloc_other-&gt;result_cast();
885             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
886                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
887               res_dom = res_other;
888             }
889           }
890         }
891       }
892       if (res_dom != res) {
893         // Move users to dominating allocation
894         igvn-&gt;replace_node(res, res_dom);
<span class="line-modified">895         // The result of the dominated allocation is now unused and will be</span>
<span class="line-modified">896         // removed later in AllocateNode::Ideal() to not confuse loop opts.</span>
897         igvn-&gt;record_for_igvn(alloc);
<span class="line-removed">898 #ifdef ASSERT</span>
<span class="line-removed">899         if (PrintEliminateAllocations) {</span>
<span class="line-removed">900           tty-&gt;print(&quot;++++ Eliminated: %d Allocate &quot;, alloc-&gt;_idx);</span>
<span class="line-removed">901           dump_spec(tty);</span>
<span class="line-removed">902           tty-&gt;cr();</span>
<span class="line-removed">903         }</span>
<span class="line-removed">904 #endif</span>
905       }
906     }
907   }
908 
909   // Process users
910   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
911     Node* out = fast_out(i);
912     if (out-&gt;is_ValueType()) {
913       // Recursively process value type users
914       out-&gt;as_ValueType()-&gt;remove_redundant_allocations(igvn, phase);
915       --i; --imax;
916     } else if (out-&gt;isa_Allocate() != NULL) {
917       // Unlink AllocateNode
918       assert(out-&gt;in(AllocateNode::ValueNode) == this, &quot;should be linked&quot;);
919       igvn-&gt;replace_input_of(out, AllocateNode::ValueNode, igvn-&gt;C-&gt;top());
920       --i; --imax;
921     } else {
922 #ifdef ASSERT
923       // The value type should not have any other users at this time
924       out-&gt;dump();
925       assert(false, &quot;unexpected user of value type&quot;);
926 #endif
927     }
928   }
929   igvn-&gt;remove_dead_node(this);
930 }
<span class="line-removed">931 </span>
<span class="line-removed">932 ValueTypePtrNode* ValueTypePtrNode::make_from_value_type(GraphKit* kit, ValueTypeNode* vt) {</span>
<span class="line-removed">933   Node* oop = vt-&gt;allocate(kit)-&gt;get_oop();</span>
<span class="line-removed">934   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vt-&gt;value_klass(), oop);</span>
<span class="line-removed">935   for (uint i = Oop+1; i &lt; vt-&gt;req(); i++) {</span>
<span class="line-removed">936     vtptr-&gt;init_req(i, vt-&gt;in(i));</span>
<span class="line-removed">937   }</span>
<span class="line-removed">938   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">939 }</span>
<span class="line-removed">940 </span>
<span class="line-removed">941 ValueTypePtrNode* ValueTypePtrNode::make_from_oop(GraphKit* kit, Node* oop) {</span>
<span class="line-removed">942   // Create and initialize a ValueTypePtrNode by loading all field</span>
<span class="line-removed">943   // values from a heap-allocated version and also save the oop.</span>
<span class="line-removed">944   ciValueKlass* vk = kit-&gt;gvn().type(oop)-&gt;value_klass();</span>
<span class="line-removed">945   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vk, oop);</span>
<span class="line-removed">946   vtptr-&gt;load(kit, oop, oop, vk);</span>
<span class="line-removed">947   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">948 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;opto/rootnode.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the values type to handle control flow merges involving multiple value types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 ValueTypeBaseNode* ValueTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);
 38   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(value_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
<span class="line-modified"> 50     if (value-&gt;is_ValueTypeBase()) {</span>
 51       // Handle flattened value type fields recursively
<span class="line-modified"> 52       value = value-&gt;as_ValueTypeBase()-&gt;clone_with_phis(gvn, region);</span>
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the ValueBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see ValueBaseTypeNode::clone_with_phis).
 66 bool ValueTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
</pre>
<hr />
<pre>
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 ValueTypeBaseNode* ValueTypeBaseNode::merge_with(PhaseGVN* gvn, const ValueTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
<span class="line-modified"> 98     if (val1-&gt;is_ValueTypeBase()) {</span>
<span class="line-modified"> 99       val1-&gt;as_ValueTypeBase()-&gt;merge_with(gvn, val2-&gt;as_ValueTypeBase(), pnum, transform);</span>
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       assert(!val2-&gt;is_ValueType(), &quot;inconsistent merge values&quot;);
103       val1-&gt;set_req(pnum, val2);
104     }
105     if (transform) {
106       set_field_value(i, gvn-&gt;transform(val1));
107       gvn-&gt;record_for_igvn(val1);
108     }
109   }
110   return this;
111 }
112 
113 // Adds a new merge path to a valuetype node with phi inputs
114 void ValueTypeBaseNode::add_new_path(Node* region) {
115   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
116 
117   PhiNode* phi = get_oop()-&gt;as_Phi();
118   phi-&gt;add_req(NULL);
119   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
</pre>
<hr />
<pre>
236   Unique_Node_List worklist;
237   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
238     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
239     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
240       int nb = 0;
241       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
242         // Value type is allocated with a constant oop, link it directly
243         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
244         igvn-&gt;rehash_node_delayed(sfpt);
245       } else {
246         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
247       }
248       --i; imax -= nb;
249     }
250   }
251   // Now scalarize non-flattened fields
252   for (uint i = 0; i &lt; worklist.size(); ++i) {
253     Node* vt = worklist.at(i);
254     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(igvn);
255   }
<span class="line-added">256   igvn-&gt;record_for_igvn(this);</span>
257 }
258 
259 const TypePtr* ValueTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
260   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
261   const TypePtr* adr_type = NULL;
262   bool is_array = ary_type != NULL;
263   if ((decorators &amp; C2_MISMATCHED) != 0) {
264     adr_type = TypeRawPtr::BOTTOM;
265   } else if (is_array) {
266     // In the case of a flattened value type array, each field has its own slice
267     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
268   } else {
269     ciField* field = holder-&gt;get_field_by_offset(offset, false);
270     assert(field != NULL, &quot;field not found&quot;);
271     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
272   }
273   return adr_type;
274 }
275 
276 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
</pre>
<hr />
<pre>
280     int offset = holder_offset + field_offset(i);
281     Node* value = NULL;
282     ciType* ft = field_type(i);
283     bool is_flattenable = field_is_flattenable(i);
284     if (field_is_flattened(i)) {
285       // Recursively load the flattened value type field
286       value = ValueTypeNode::make_from_flattened(kit, ft-&gt;as_value_klass(), base, ptr, holder, offset, decorators);
287     } else {
288       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
289       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
290       if (base-&gt;is_Con() &amp;&amp; !is_array) {
291         // If the oop to the value type is constant (static final field), we can
292         // also treat the fields as constants because the value type is immutable.
293         ciObject* constant_oop = oop_ptr-&gt;const_oop();
294         ciField* field = holder-&gt;get_field_by_offset(offset, false);
295         assert(field != NULL, &quot;field not found&quot;);
296         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
297         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
298         assert(con_type != NULL, &quot;type not found&quot;);
299         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
<span class="line-modified">300         // Check type of constant which might be more precise</span>
<span class="line-added">301         if (con_type-&gt;is_valuetypeptr() &amp;&amp; !con_type-&gt;is_zero_type()) {</span>
302           // Null-free, treat as flattenable
<span class="line-added">303           ft = con_type-&gt;value_klass();</span>
304           is_flattenable = true;
305         }
306       } else {
307         // Load field value from memory
308         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
309         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
310         BasicType bt = type2field[ft-&gt;basic_type()];
311         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
312         const Type* val_type = Type::get_const_type(ft);
313         if (is_array) {
314           decorators |= IS_ARRAY;
315         }
316         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
317       }
318       if (is_flattenable) {
319         // Loading a non-flattened but flattenable value type from memory
320         if (ft-&gt;as_value_klass()-&gt;is_scalarizable()) {
321           value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
322         } else {
323           value = kit-&gt;null2default(value, ft-&gt;as_value_klass());
</pre>
<hr />
<pre>
350         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);
351         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
352       }
353       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
354     } else {
355       // Store field value to memory
356       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
357       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
358       BasicType bt = type2field[ft-&gt;basic_type()];
359       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
360       const Type* val_type = Type::get_const_type(ft);
361       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
362       if (ary_type != NULL) {
363         decorators |= IS_ARRAY;
364       }
365       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
366     }
367   }
368 }
369 
<span class="line-modified">370 ValueTypePtrNode* ValueTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {</span>
<span class="line-added">371   assert(is_ValueType(), &quot;sanity&quot;);</span>
372   // Check if value type is already allocated
373   Node* null_ctl = kit-&gt;top();
374   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
375   if (null_ctl-&gt;is_top()) {
376     // Value type is allocated
<span class="line-modified">377     return kit-&gt;gvn().transform(new ValueTypePtrNode(this))-&gt;as_ValueTypePtr();</span>
378   }
379   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
380   RegionNode* region = new RegionNode(3);
381 
382   // Oop is non-NULL, use it
383   region-&gt;init_req(1, kit-&gt;control());
384   PhiNode* oop = PhiNode::make(region, not_null_oop, value_ptr());
385   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
386   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
387 
388   int bci = kit-&gt;bci();
389   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
390   {
391     // Oop is NULL, allocate and initialize buffer
392     PreserveJVMState pjvms(kit);
393     // Propagate re-execution state and bci
394     kit-&gt;set_bci(bci);
395     kit-&gt;jvms()-&gt;set_bci(bci);
396     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
397     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
417   kit-&gt;set_control(kit-&gt;gvn().transform(region));
418   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
419   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
420   kit-&gt;record_for_igvn(region);
421   kit-&gt;record_for_igvn(oop);
422   kit-&gt;record_for_igvn(io);
423   kit-&gt;record_for_igvn(mem);
424 
425   // Use cloned ValueTypeNode to propagate oop from now on
426   Node* res_oop = kit-&gt;gvn().transform(oop);
427   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
428   vt-&gt;set_oop(res_oop);
429   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
430   if (safe_for_replace) {
431     kit-&gt;replace_in_map(this, vt);
432   }
433   // ValueTypeNode::remove_redundant_allocations piggybacks on split if.
434   // Make sure it gets a chance to remove this allocation.
435   kit-&gt;C-&gt;set_has_split_ifs(true);
436   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
<span class="line-modified">437   return kit-&gt;gvn().transform(new ValueTypePtrNode(vt))-&gt;as_ValueTypePtr();</span>
438 }
439 
440 bool ValueTypeBaseNode::is_allocated(PhaseGVN* phase) const {
441   Node* oop = get_oop();
442   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
443   return !oop_type-&gt;maybe_null();
444 }
445 
446 // When a call returns multiple values, it has several result
447 // projections, one per field. Replacing the result of the call by a
448 // value type node (after late inlining) requires that for each result
449 // projection, we find the corresponding value type field.
450 void ValueTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
451   ciValueKlass* vk = value_klass();
452   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
453     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
454     uint con = pn-&gt;_con;
455     if (con &gt;= TypeFunc::Parms+1) {
456       uint field_nb = con - (TypeFunc::Parms+1);
457       int extra = 0;
</pre>
<hr />
<pre>
468         assert(field-&gt;as_ValueType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
469         field = field-&gt;as_ValueType()-&gt;get_oop();
470       }
471       C-&gt;gvn_replace_by(pn, field);
472       C-&gt;initial_gvn()-&gt;hash_delete(pn);
473       pn-&gt;set_req(0, C-&gt;top());
474       --i; --imax;
475     }
476   }
477 }
478 
479 Node* ValueTypeBaseNode::allocate_fields(GraphKit* kit) {
480   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
481   for (uint i = 0; i &lt; field_count(); i++) {
482      ValueTypeNode* value = field_value(i)-&gt;isa_ValueType();
483      if (field_is_flattened(i)) {
484        // Flattened value type field
485        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
486      } else if (value != NULL) {
487        // Non-flattened value type field
<span class="line-modified">488        vt-&gt;set_field_value(i, value-&gt;buffer(kit));</span>
489      }
490   }
491   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
492   kit-&gt;replace_in_map(this, vt);
493   return vt;
494 }
495 
496 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
497   // Create a new ValueTypeNode with uninitialized values and NULL oop
498   return new ValueTypeNode(vk, gvn.zerocon(T_VALUETYPE));
499 }
500 
501 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
502   // Returns the constant oop of the default value type allocation
503   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
504 }
505 
506 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
507   // Create a new ValueTypeNode with default values
508   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
</pre>
<hr />
<pre>
705   intptr_t bits = tk-&gt;get_con();
706   set_nth_bit(bits, 0);
707   return gvn.makecon(TypeRawPtr::make((address)bits));
708 }
709 
710 void ValueTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
711   for (uint i = 0; i &lt; field_count(); i++) {
712     int sig_offset = (*sig)._offset;
713     uint idx = field_index(sig_offset - base_offset);
714     Node* arg = field_value(idx);
715 
716     if (field_is_flattened(idx)) {
717       // Flattened value type field
718       ValueTypeNode* vt = arg-&gt;as_ValueType();
719       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;value_klass()-&gt;first_field_offset());
720     } else {
721       if (arg-&gt;is_ValueType()) {
722         // Non-flattened value type field
723         ValueTypeNode* vt = arg-&gt;as_ValueType();
724         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;value type field should be allocated on return&quot;);
<span class="line-modified">725         arg = vt-&gt;buffer(kit);</span>
726       }
727       // Initialize call/return arguments
728       BasicType bt = field_type(i)-&gt;basic_type();
729       n-&gt;init_req(base_input++, arg);
730       if (type2size[bt] == 2) {
731         n-&gt;init_req(base_input++, kit-&gt;top());
732       }
733       // Skip reserved arguments
734       while (SigEntry::next_is_reserved(sig, bt)) {
735         n-&gt;init_req(base_input++, kit-&gt;top());
736         if (type2size[bt] == 2) {
737           n-&gt;init_req(base_input++, kit-&gt;top());
738         }
739       }
740     }
741   }
742 }
743 
744 void ValueTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
745   PhaseGVN&amp; gvn = kit-&gt;gvn();
</pre>
<hr />
<pre>
879         // The value type is already allocated but still connected to an AllocateNode.
880         // This can happen with late inlining when we first allocate a value type argument
881         // but later decide to inline the call with the callee code also allocating.
882         res_dom = get_oop();
883       } else {
884         // Search for a dominating allocation of the same value type
885         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
886           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
887           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::ValueNode) == this) {
888             Node* res_other = alloc_other-&gt;result_cast();
889             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
890                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
891               res_dom = res_other;
892             }
893           }
894         }
895       }
896       if (res_dom != res) {
897         // Move users to dominating allocation
898         igvn-&gt;replace_node(res, res_dom);
<span class="line-modified">899         // The result of the dominated allocation is now unused and will be removed</span>
<span class="line-modified">900         // later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.</span>
901         igvn-&gt;record_for_igvn(alloc);







902       }
903     }
904   }
905 
906   // Process users
907   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
908     Node* out = fast_out(i);
909     if (out-&gt;is_ValueType()) {
910       // Recursively process value type users
911       out-&gt;as_ValueType()-&gt;remove_redundant_allocations(igvn, phase);
912       --i; --imax;
913     } else if (out-&gt;isa_Allocate() != NULL) {
914       // Unlink AllocateNode
915       assert(out-&gt;in(AllocateNode::ValueNode) == this, &quot;should be linked&quot;);
916       igvn-&gt;replace_input_of(out, AllocateNode::ValueNode, igvn-&gt;C-&gt;top());
917       --i; --imax;
918     } else {
919 #ifdef ASSERT
920       // The value type should not have any other users at this time
921       out-&gt;dump();
922       assert(false, &quot;unexpected user of value type&quot;);
923 #endif
924     }
925   }
926   igvn-&gt;remove_dead_node(this);
927 }


















</pre>
</td>
</tr>
</table>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1708   tmp_jvms-&gt;set_should_reexecute(true);
1709   map()-&gt;set_jvms(tmp_jvms);
1710   // Execution needs to restart a the next bytecode (entry of next
1711   // block)
1712   if (target-&gt;is_merged() ||
1713       pnum &gt; PhiNode::Input ||
1714       target-&gt;is_handler() ||
1715       target-&gt;is_loop_head()) {
1716     set_parse_bci(target-&gt;start());
1717     for (uint j = TypeFunc::Parms; j &lt; map()-&gt;req(); j++) {
1718       Node* n = map()-&gt;in(j);                 // Incoming change to target state.
1719       const Type* t = NULL;
1720       if (tmp_jvms-&gt;is_loc(j)) {
1721         t = target-&gt;local_type_at(j - tmp_jvms-&gt;locoff());
1722       } else if (tmp_jvms-&gt;is_stk(j) &amp;&amp; j &lt; (uint)sp() + tmp_jvms-&gt;stkoff()) {
1723         t = target-&gt;stack_type_at(j - tmp_jvms-&gt;stkoff());
1724       }
1725       if (t != NULL &amp;&amp; t != Type::BOTTOM) {
1726         if (n-&gt;is_ValueType() &amp;&amp; !t-&gt;isa_valuetype()) {
1727           // Allocate value type in src block to be able to merge it with oop in target block
<span class="line-modified">1728           map()-&gt;set_req(j, ValueTypePtrNode::make_from_value_type(this, n-&gt;as_ValueType()));</span>
1729         }
1730         assert(!t-&gt;isa_valuetype() || n-&gt;is_ValueType(), &quot;inconsistent typeflow info&quot;);
1731       }
1732     }
1733   }
1734   map()-&gt;set_jvms(old_jvms);
1735   set_parse_bci(old_bci);
1736 
1737   if (!target-&gt;is_merged()) {   // No prior mapping at this bci
1738     if (TraceOptoParse) { tty-&gt;print(&quot; with empty state&quot;);  }
1739 
1740     // If this path is dead, do not bother capturing it as a merge.
1741     // It is &quot;as if&quot; we had 1 fewer predecessors from the beginning.
1742     if (stopped()) {
1743       if (TraceOptoParse)  tty-&gt;print_cr(&quot;, but path is dead and doesn&#39;t count&quot;);
1744       return;
1745     }
1746 
1747     // Make a region if we know there are multiple or unpredictable inputs.
1748     // (Also, if this is a plain fall-through, we might see another region,
</pre>
<hr />
<pre>
2348     if (return_type-&gt;isa_valuetype() &amp;&amp; !Compile::current()-&gt;inlining_incrementally()) {
2349       // Value type is returned as fields, make sure it is scalarized
2350       if (!value-&gt;is_ValueType()) {
2351         value = ValueTypeNode::make_from_oop(this, value, return_type-&gt;value_klass());
2352       }
2353       if (!_caller-&gt;has_method()) {
2354         // Value type is returned as fields from root method, make sure all non-flattened
2355         // fields are buffered and re-execute if allocation triggers deoptimization.
2356         PreserveReexecuteState preexecs(this);
2357         assert(tf()-&gt;returns_value_type_as_fields(), &quot;must be returned as fields&quot;);
2358         jvms()-&gt;set_should_reexecute(true);
2359         inc_sp(1);
2360         value = value-&gt;as_ValueType()-&gt;allocate_fields(this);
2361       }
2362     } else if (value-&gt;is_ValueType()) {
2363       // Value type is returned as oop, make sure it is buffered and re-execute
2364       // if allocation triggers deoptimization.
2365       PreserveReexecuteState preexecs(this);
2366       jvms()-&gt;set_should_reexecute(true);
2367       inc_sp(1);
<span class="line-modified">2368       value = ValueTypePtrNode::make_from_value_type(this, value-&gt;as_ValueType());</span>
2369       if (Compile::current()-&gt;inlining_incrementally()) {
2370         value = value-&gt;as_ValueTypeBase()-&gt;allocate_fields(this);
2371       }
2372     } else if (tr &amp;&amp; tr-&gt;isa_instptr() &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp; tr-&gt;klass()-&gt;is_interface()) {
2373       // If returning oops to an interface-return, there is a silent free
2374       // cast from oop to interface allowed by the Verifier. Make it explicit here.
2375       const TypeInstPtr* tp = value-&gt;bottom_type()-&gt;isa_instptr();
2376       if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
2377         // sharpen the type eagerly; this eases certain assert checking
2378         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
2379           tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
2380         }
2381         value = _gvn.transform(new CheckCastPPNode(0, value, tr));
2382       }
2383     } else {
2384       // Handle returns of oop-arrays to an arrays-of-interface return
2385       const TypeInstPtr* phi_tip;
2386       const TypeInstPtr* val_tip;
2387       Type::get_arrays_base_elements(return_type, value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);
2388       if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
</pre>
</td>
<td>
<hr />
<pre>
1708   tmp_jvms-&gt;set_should_reexecute(true);
1709   map()-&gt;set_jvms(tmp_jvms);
1710   // Execution needs to restart a the next bytecode (entry of next
1711   // block)
1712   if (target-&gt;is_merged() ||
1713       pnum &gt; PhiNode::Input ||
1714       target-&gt;is_handler() ||
1715       target-&gt;is_loop_head()) {
1716     set_parse_bci(target-&gt;start());
1717     for (uint j = TypeFunc::Parms; j &lt; map()-&gt;req(); j++) {
1718       Node* n = map()-&gt;in(j);                 // Incoming change to target state.
1719       const Type* t = NULL;
1720       if (tmp_jvms-&gt;is_loc(j)) {
1721         t = target-&gt;local_type_at(j - tmp_jvms-&gt;locoff());
1722       } else if (tmp_jvms-&gt;is_stk(j) &amp;&amp; j &lt; (uint)sp() + tmp_jvms-&gt;stkoff()) {
1723         t = target-&gt;stack_type_at(j - tmp_jvms-&gt;stkoff());
1724       }
1725       if (t != NULL &amp;&amp; t != Type::BOTTOM) {
1726         if (n-&gt;is_ValueType() &amp;&amp; !t-&gt;isa_valuetype()) {
1727           // Allocate value type in src block to be able to merge it with oop in target block
<span class="line-modified">1728           map()-&gt;set_req(j, n-&gt;as_ValueType()-&gt;buffer(this));</span>
1729         }
1730         assert(!t-&gt;isa_valuetype() || n-&gt;is_ValueType(), &quot;inconsistent typeflow info&quot;);
1731       }
1732     }
1733   }
1734   map()-&gt;set_jvms(old_jvms);
1735   set_parse_bci(old_bci);
1736 
1737   if (!target-&gt;is_merged()) {   // No prior mapping at this bci
1738     if (TraceOptoParse) { tty-&gt;print(&quot; with empty state&quot;);  }
1739 
1740     // If this path is dead, do not bother capturing it as a merge.
1741     // It is &quot;as if&quot; we had 1 fewer predecessors from the beginning.
1742     if (stopped()) {
1743       if (TraceOptoParse)  tty-&gt;print_cr(&quot;, but path is dead and doesn&#39;t count&quot;);
1744       return;
1745     }
1746 
1747     // Make a region if we know there are multiple or unpredictable inputs.
1748     // (Also, if this is a plain fall-through, we might see another region,
</pre>
<hr />
<pre>
2348     if (return_type-&gt;isa_valuetype() &amp;&amp; !Compile::current()-&gt;inlining_incrementally()) {
2349       // Value type is returned as fields, make sure it is scalarized
2350       if (!value-&gt;is_ValueType()) {
2351         value = ValueTypeNode::make_from_oop(this, value, return_type-&gt;value_klass());
2352       }
2353       if (!_caller-&gt;has_method()) {
2354         // Value type is returned as fields from root method, make sure all non-flattened
2355         // fields are buffered and re-execute if allocation triggers deoptimization.
2356         PreserveReexecuteState preexecs(this);
2357         assert(tf()-&gt;returns_value_type_as_fields(), &quot;must be returned as fields&quot;);
2358         jvms()-&gt;set_should_reexecute(true);
2359         inc_sp(1);
2360         value = value-&gt;as_ValueType()-&gt;allocate_fields(this);
2361       }
2362     } else if (value-&gt;is_ValueType()) {
2363       // Value type is returned as oop, make sure it is buffered and re-execute
2364       // if allocation triggers deoptimization.
2365       PreserveReexecuteState preexecs(this);
2366       jvms()-&gt;set_should_reexecute(true);
2367       inc_sp(1);
<span class="line-modified">2368       value = value-&gt;as_ValueType()-&gt;buffer(this);</span>
2369       if (Compile::current()-&gt;inlining_incrementally()) {
2370         value = value-&gt;as_ValueTypeBase()-&gt;allocate_fields(this);
2371       }
2372     } else if (tr &amp;&amp; tr-&gt;isa_instptr() &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp; tr-&gt;klass()-&gt;is_interface()) {
2373       // If returning oops to an interface-return, there is a silent free
2374       // cast from oop to interface allowed by the Verifier. Make it explicit here.
2375       const TypeInstPtr* tp = value-&gt;bottom_type()-&gt;isa_instptr();
2376       if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
2377         // sharpen the type eagerly; this eases certain assert checking
2378         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL)) {
2379           tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
2380         }
2381         value = _gvn.transform(new CheckCastPPNode(0, value, tr));
2382       }
2383     } else {
2384       // Handle returns of oop-arrays to an arrays-of-interface return
2385       const TypeInstPtr* phi_tip;
2386       const TypeInstPtr* val_tip;
2387       Type::get_arrays_base_elements(return_type, value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);
2388       if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
</pre>
</td>
</tr>
</table>
<center><a href="macro.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse2.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
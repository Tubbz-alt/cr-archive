<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/valuetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciValueKlass.hpp&quot;
 27 #include &quot;opto/addnode.hpp&quot;
 28 #include &quot;opto/castnode.hpp&quot;
 29 #include &quot;opto/graphKit.hpp&quot;
 30 #include &quot;opto/rootnode.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the values type to handle control flow merges involving multiple value types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 ValueTypeBaseNode* ValueTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);
 38   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(value_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
<a name="1" id="anc1"></a><span class="line-modified"> 50     if (type-&gt;is_valuetype() &amp;&amp; value-&gt;isa_ValueType()) {</span>
 51       // Handle flattened value type fields recursively
<a name="2" id="anc2"></a><span class="line-modified"> 52       value = value-&gt;as_ValueType()-&gt;clone_with_phis(gvn, region);</span>
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the ValueBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see ValueBaseTypeNode::clone_with_phis).
 66 bool ValueTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
 73       Node* n = in(i);
 74       if (n-&gt;is_ValueTypeBase()) {
 75         assert(n-&gt;as_ValueTypeBase()-&gt;has_phi_inputs(region), &quot;inconsistent phi inputs&quot;);
 76       } else {
 77         assert(n-&gt;is_Phi() &amp;&amp; n-&gt;as_Phi()-&gt;region() == region, &quot;inconsistent phi inputs&quot;);
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 ValueTypeBaseNode* ValueTypeBaseNode::merge_with(PhaseGVN* gvn, const ValueTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
<a name="3" id="anc3"></a><span class="line-modified"> 98     if (val1-&gt;is_ValueType()) {</span>
<span class="line-modified"> 99       val1-&gt;as_ValueType()-&gt;merge_with(gvn, val2-&gt;as_ValueType(), pnum, transform);</span>
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       assert(!val2-&gt;is_ValueType(), &quot;inconsistent merge values&quot;);
103       val1-&gt;set_req(pnum, val2);
104     }
105     if (transform) {
106       set_field_value(i, gvn-&gt;transform(val1));
107       gvn-&gt;record_for_igvn(val1);
108     }
109   }
110   return this;
111 }
112 
113 // Adds a new merge path to a valuetype node with phi inputs
114 void ValueTypeBaseNode::add_new_path(Node* region) {
115   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
116 
117   PhiNode* phi = get_oop()-&gt;as_Phi();
118   phi-&gt;add_req(NULL);
119   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
120 
121   for (uint i = 0; i &lt; field_count(); ++i) {
122     Node* val = field_value(i);
123     if (val-&gt;is_ValueType()) {
124       val-&gt;as_ValueType()-&gt;add_new_path(region);
125     } else {
126       val-&gt;as_Phi()-&gt;add_req(NULL);
127       assert(val-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
128     }
129   }
130 }
131 
132 Node* ValueTypeBaseNode::field_value(uint index) const {
133   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
134   return in(Values + index);
135 }
136 
137 // Get the value of the field at the given offset.
138 // If &#39;recursive&#39; is true, flattened value type fields will be resolved recursively.
139 Node* ValueTypeBaseNode::field_value_by_offset(int offset, bool recursive) const {
140   // If the field at &#39;offset&#39; belongs to a flattened value type field, &#39;index&#39; refers to the
141   // corresponding ValueTypeNode input and &#39;sub_offset&#39; is the offset in flattened value type.
142   int index = value_klass()-&gt;field_index_by_offset(offset);
143   int sub_offset = offset - field_offset(index);
144   Node* value = field_value(index);
145   assert(value != NULL, &quot;field value not found&quot;);
146   if (recursive &amp;&amp; value-&gt;is_ValueType()) {
147     ValueTypeNode* vt = value-&gt;as_ValueType();
148     if (field_is_flattened(index)) {
149       // Flattened value type field
150       sub_offset += vt-&gt;value_klass()-&gt;first_field_offset(); // Add header size
151       return vt-&gt;field_value_by_offset(sub_offset, recursive);
152     } else {
153       assert(sub_offset == 0, &quot;should not have a sub offset&quot;);
154       return vt;
155     }
156   }
157   assert(!(recursive &amp;&amp; value-&gt;is_ValueType()), &quot;should not be a value type&quot;);
158   assert(sub_offset == 0, &quot;offset mismatch&quot;);
159   return value;
160 }
161 
162 void ValueTypeBaseNode::set_field_value(uint index, Node* value) {
163   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
164   set_req(Values + index, value);
165 }
166 
167 void ValueTypeBaseNode::set_field_value_by_offset(int offset, Node* value) {
168   set_field_value(field_index(offset), value);
169 }
170 
171 int ValueTypeBaseNode::field_offset(uint index) const {
172   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
173   return value_klass()-&gt;declared_nonstatic_field_at(index)-&gt;offset();
174 }
175 
176 uint ValueTypeBaseNode::field_index(int offset) const {
177   uint i = 0;
178   for (; i &lt; field_count() &amp;&amp; field_offset(i) != offset; i++) { }
179   assert(i &lt; field_count(), &quot;field not found&quot;);
180   return i;
181 }
182 
183 ciType* ValueTypeBaseNode::field_type(uint index) const {
184   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
185   return value_klass()-&gt;declared_nonstatic_field_at(index)-&gt;type();
186 }
187 
188 bool ValueTypeBaseNode::field_is_flattened(uint index) const {
189   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
190   ciField* field = value_klass()-&gt;declared_nonstatic_field_at(index);
191   assert(!field-&gt;is_flattened() || field-&gt;type()-&gt;is_valuetype(), &quot;must be a value type&quot;);
192   return field-&gt;is_flattened();
193 }
194 
195 bool ValueTypeBaseNode::field_is_flattenable(uint index) const {
196   assert(index &lt; field_count(), &quot;index out of bounds&quot;);
197   ciField* field = value_klass()-&gt;declared_nonstatic_field_at(index);
198   assert(!field-&gt;is_flattenable() || field-&gt;type()-&gt;is_valuetype(), &quot;must be a value type&quot;);
199   return field-&gt;is_flattenable();
200 }
201 
202 int ValueTypeBaseNode::make_scalar_in_safepoint(PhaseIterGVN* igvn, Unique_Node_List&amp; worklist, SafePointNode* sfpt) {
203   ciValueKlass* vk = value_klass();
204   uint nfields = vk-&gt;nof_nonstatic_fields();
205   JVMState* jvms = sfpt-&gt;jvms();
206   int start = jvms-&gt;debug_start();
207   int end   = jvms-&gt;debug_end();
208   // Replace safepoint edge by SafePointScalarObjectNode and add field values
209   assert(jvms != NULL, &quot;missing JVMS&quot;);
210   uint first_ind = (sfpt-&gt;req() - jvms-&gt;scloff());
211   SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(value_ptr(),
212 #ifdef ASSERT
213                                                                   NULL,
214 #endif
215                                                                   first_ind, nfields);
216   sobj-&gt;init_req(0, igvn-&gt;C-&gt;root());
217   // Iterate over the value type fields in order of increasing
218   // offset and add the field values to the safepoint.
219   for (uint j = 0; j &lt; nfields; ++j) {
220     int offset = vk-&gt;nonstatic_field_at(j)-&gt;offset();
221     Node* value = field_value_by_offset(offset, true /* include flattened value type fields */);
222     if (value-&gt;is_ValueType()) {
223       // Add value type field to the worklist to process later
224       worklist.push(value);
225     }
226     sfpt-&gt;add_req(value);
227   }
228   jvms-&gt;set_endoff(sfpt-&gt;req());
229   sobj = igvn-&gt;transform(sobj)-&gt;as_SafePointScalarObject();
230   igvn-&gt;rehash_node_delayed(sfpt);
231   return sfpt-&gt;replace_edges_in_range(this, sobj, start, end);
232 }
233 
234 void ValueTypeBaseNode::make_scalar_in_safepoints(PhaseIterGVN* igvn) {
235   // Process all safepoint uses and scalarize value type
236   Unique_Node_List worklist;
237   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
238     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
239     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
240       int nb = 0;
241       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
242         // Value type is allocated with a constant oop, link it directly
243         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
244         igvn-&gt;rehash_node_delayed(sfpt);
245       } else {
246         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
247       }
248       --i; imax -= nb;
249     }
250   }
251   // Now scalarize non-flattened fields
252   for (uint i = 0; i &lt; worklist.size(); ++i) {
253     Node* vt = worklist.at(i);
254     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(igvn);
255   }
<a name="4" id="anc4"></a>
256 }
257 
258 const TypePtr* ValueTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
259   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
260   const TypePtr* adr_type = NULL;
261   bool is_array = ary_type != NULL;
262   if ((decorators &amp; C2_MISMATCHED) != 0) {
263     adr_type = TypeRawPtr::BOTTOM;
264   } else if (is_array) {
265     // In the case of a flattened value type array, each field has its own slice
266     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
267   } else {
268     ciField* field = holder-&gt;get_field_by_offset(offset, false);
269     assert(field != NULL, &quot;field not found&quot;);
270     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
271   }
272   return adr_type;
273 }
274 
275 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
276   // Initialize the value type by loading its field values from
277   // memory and adding the values as input edges to the node.
278   for (uint i = 0; i &lt; field_count(); ++i) {
279     int offset = holder_offset + field_offset(i);
280     Node* value = NULL;
281     ciType* ft = field_type(i);
282     bool is_flattenable = field_is_flattenable(i);
283     if (field_is_flattened(i)) {
284       // Recursively load the flattened value type field
285       value = ValueTypeNode::make_from_flattened(kit, ft-&gt;as_value_klass(), base, ptr, holder, offset, decorators);
286     } else {
287       const TypeOopPtr* oop_ptr = kit-&gt;gvn().type(base)-&gt;isa_oopptr();
288       bool is_array = (oop_ptr-&gt;isa_aryptr() != NULL);
289       if (base-&gt;is_Con() &amp;&amp; !is_array) {
290         // If the oop to the value type is constant (static final field), we can
291         // also treat the fields as constants because the value type is immutable.
292         ciObject* constant_oop = oop_ptr-&gt;const_oop();
293         ciField* field = holder-&gt;get_field_by_offset(offset, false);
294         assert(field != NULL, &quot;field not found&quot;);
295         ciConstant constant = constant_oop-&gt;as_instance()-&gt;field_value(field);
296         const Type* con_type = Type::make_from_constant(constant, /*require_const=*/ true);
297         assert(con_type != NULL, &quot;type not found&quot;);
298         value = kit-&gt;gvn().transform(kit-&gt;makecon(con_type));
<a name="5" id="anc5"></a><span class="line-modified">299         if (ft-&gt;is_valuetype() &amp;&amp; !constant.as_object()-&gt;is_null_object()) {</span>

300           // Null-free, treat as flattenable
<a name="6" id="anc6"></a>
301           is_flattenable = true;
302         }
303       } else {
304         // Load field value from memory
305         const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
306         Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
307         BasicType bt = type2field[ft-&gt;basic_type()];
308         assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
309         const Type* val_type = Type::get_const_type(ft);
310         if (is_array) {
311           decorators |= IS_ARRAY;
312         }
313         value = kit-&gt;access_load_at(base, adr, adr_type, val_type, bt, decorators);
314       }
315       if (is_flattenable) {
316         // Loading a non-flattened but flattenable value type from memory
317         if (ft-&gt;as_value_klass()-&gt;is_scalarizable()) {
318           value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
319         } else {
320           value = kit-&gt;null2default(value, ft-&gt;as_value_klass());
321         }
322       }
323     }
324     set_field_value(i, value);
325   }
326 }
327 
328 void ValueTypeBaseNode::store_flattened(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
329   // The value type is embedded into the object without an oop header. Subtract the
330   // offset of the first field to account for the missing header when storing the values.
331   if (holder == NULL) {
332     holder = value_klass();
333   }
334   holder_offset -= value_klass()-&gt;first_field_offset();
335   store(kit, base, ptr, holder, holder_offset, decorators);
336 }
337 
338 void ValueTypeBaseNode::store(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) const {
339   // Write field values to memory
340   for (uint i = 0; i &lt; field_count(); ++i) {
341     int offset = holder_offset + field_offset(i);
342     Node* value = field_value(i);
343     ciType* ft = field_type(i);
344     if (field_is_flattened(i)) {
345       // Recursively store the flattened value type field
346       if (!value-&gt;is_ValueType()) {
347         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);
348         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
349       }
350       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
351     } else {
352       // Store field value to memory
353       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
354       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
355       BasicType bt = type2field[ft-&gt;basic_type()];
356       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
357       const Type* val_type = Type::get_const_type(ft);
358       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
359       if (ary_type != NULL) {
360         decorators |= IS_ARRAY;
361       }
362       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
363     }
364   }
365 }
366 
<a name="7" id="anc7"></a><span class="line-modified">367 ValueTypeBaseNode* ValueTypeBaseNode::allocate(GraphKit* kit, bool safe_for_replace) {</span>

368   // Check if value type is already allocated
369   Node* null_ctl = kit-&gt;top();
370   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
371   if (null_ctl-&gt;is_top()) {
372     // Value type is allocated
<a name="8" id="anc8"></a><span class="line-modified">373     return this;</span>
374   }
375   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
376   RegionNode* region = new RegionNode(3);
377 
378   // Oop is non-NULL, use it
379   region-&gt;init_req(1, kit-&gt;control());
380   PhiNode* oop = PhiNode::make(region, not_null_oop, value_ptr());
381   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
382   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
383 
384   int bci = kit-&gt;bci();
385   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
386   {
387     // Oop is NULL, allocate and initialize buffer
388     PreserveJVMState pjvms(kit);
389     // Propagate re-execution state and bci
390     kit-&gt;set_bci(bci);
391     kit-&gt;jvms()-&gt;set_bci(bci);
392     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
393     kit-&gt;set_control(null_ctl);
394     kit-&gt;kill_dead_locals();
395     ciValueKlass* vk = value_klass();
396     Node* klass_node = kit-&gt;makecon(TypeKlassPtr::make(vk));
397     Node* alloc_oop  = kit-&gt;new_instance(klass_node, NULL, NULL, /* deoptimize_on_exception */ true, this);
398     store(kit, alloc_oop, alloc_oop, vk, 0);
399 
400     // Do not let stores that initialize this buffer be reordered with a subsequent
401     // store that would make this buffer accessible by other threads.
402     AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &amp;kit-&gt;gvn());
403     assert(alloc != NULL, &quot;must have an allocation node&quot;);
404     kit-&gt;insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
405 
406     region-&gt;init_req(2, kit-&gt;control());
407     oop   -&gt;init_req(2, alloc_oop);
408     io    -&gt;init_req(2, kit-&gt;i_o());
409     mem   -&gt;init_req(2, kit-&gt;merged_memory());
410   }
411 
412   // Update GraphKit
413   kit-&gt;set_control(kit-&gt;gvn().transform(region));
414   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
415   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
416   kit-&gt;record_for_igvn(region);
417   kit-&gt;record_for_igvn(oop);
418   kit-&gt;record_for_igvn(io);
419   kit-&gt;record_for_igvn(mem);
420 
421   // Use cloned ValueTypeNode to propagate oop from now on
422   Node* res_oop = kit-&gt;gvn().transform(oop);
423   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
424   vt-&gt;set_oop(res_oop);
425   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
426   if (safe_for_replace) {
427     kit-&gt;replace_in_map(this, vt);
428   }
429   // ValueTypeNode::remove_redundant_allocations piggybacks on split if.
430   // Make sure it gets a chance to remove this allocation.
431   kit-&gt;C-&gt;set_has_split_ifs(true);
432   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
<a name="9" id="anc9"></a><span class="line-modified">433   return vt;</span>
434 }
435 
436 bool ValueTypeBaseNode::is_allocated(PhaseGVN* phase) const {
437   Node* oop = get_oop();
438   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
439   return !oop_type-&gt;maybe_null();
440 }
441 
442 // When a call returns multiple values, it has several result
443 // projections, one per field. Replacing the result of the call by a
444 // value type node (after late inlining) requires that for each result
445 // projection, we find the corresponding value type field.
446 void ValueTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
447   ciValueKlass* vk = value_klass();
448   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
449     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
450     uint con = pn-&gt;_con;
451     if (con &gt;= TypeFunc::Parms+1) {
452       uint field_nb = con - (TypeFunc::Parms+1);
453       int extra = 0;
454       for (uint j = 0; j &lt; field_nb - extra; j++) {
455         ciField* f = vk-&gt;nonstatic_field_at(j);
456         BasicType bt = f-&gt;type()-&gt;basic_type();
457         if (bt == T_LONG || bt == T_DOUBLE) {
458           extra++;
459         }
460       }
461       ciField* f = vk-&gt;nonstatic_field_at(field_nb - extra);
462       Node* field = field_value_by_offset(f-&gt;offset(), true);
463       if (field-&gt;is_ValueType()) {
464         assert(field-&gt;as_ValueType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
465         field = field-&gt;as_ValueType()-&gt;get_oop();
466       }
467       C-&gt;gvn_replace_by(pn, field);
468       C-&gt;initial_gvn()-&gt;hash_delete(pn);
469       pn-&gt;set_req(0, C-&gt;top());
470       --i; --imax;
471     }
472   }
473 }
474 
475 Node* ValueTypeBaseNode::allocate_fields(GraphKit* kit) {
476   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
477   for (uint i = 0; i &lt; field_count(); i++) {
478      ValueTypeNode* value = field_value(i)-&gt;isa_ValueType();
479      if (field_is_flattened(i)) {
480        // Flattened value type field
481        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
482      } else if (value != NULL) {
483        // Non-flattened value type field
<a name="10" id="anc10"></a><span class="line-modified">484        vt-&gt;set_field_value(i, value-&gt;allocate(kit));</span>
485      }
486   }
487   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
488   kit-&gt;replace_in_map(this, vt);
489   return vt;
490 }
491 
492 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
493   // Create a new ValueTypeNode with uninitialized values and NULL oop
494   return new ValueTypeNode(vk, gvn.zerocon(T_VALUETYPE));
495 }
496 
497 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
498   // Returns the constant oop of the default value type allocation
499   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
500 }
501 
502 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
503   // Create a new ValueTypeNode with default values
504   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
505   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
506     ciType* field_type = vt-&gt;field_type(i);
507     Node* value = NULL;
508     if (field_type-&gt;is_valuetype() &amp;&amp; vt-&gt;field_is_flattenable(i)) {
509       ciValueKlass* field_klass = field_type-&gt;as_value_klass();
510       if (field_klass-&gt;is_scalarizable() || vt-&gt;field_is_flattened(i)) {
511         value = ValueTypeNode::make_default(gvn, field_klass);
512       } else {
513         value = default_oop(gvn, field_klass);
514       }
515     } else {
516       value = gvn.zerocon(field_type-&gt;basic_type());
517     }
518     vt-&gt;set_field_value(i, value);
519   }
520   vt = gvn.transform(vt)-&gt;as_ValueType();
521   assert(vt-&gt;is_default(gvn), &quot;must be the default value type&quot;);
522   return vt;
523 }
524 
525 bool ValueTypeNode::is_default(PhaseGVN&amp; gvn) const {
526   for (uint i = 0; i &lt; field_count(); ++i) {
527     Node* value = field_value(i);
528     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;
529         !(value-&gt;is_ValueType() &amp;&amp; value-&gt;as_ValueType()-&gt;is_default(gvn)) &amp;&amp;
530         !(field_type(i)-&gt;is_valuetype() &amp;&amp; value == default_oop(gvn, field_type(i)-&gt;as_value_klass()))) {
531       return false;
532     }
533   }
534   return true;
535 }
536 
537 ValueTypeNode* ValueTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciValueKlass* vk) {
538   PhaseGVN&amp; gvn = kit-&gt;gvn();
539 
540   // Create and initialize a ValueTypeNode by loading all field
541   // values from a heap-allocated version and also save the oop.
542   ValueTypeNode* vt = new ValueTypeNode(vk, oop);
543 
544   if (oop-&gt;isa_ValueTypePtr()) {
545     // Can happen with late inlining
546     ValueTypePtrNode* vtptr = oop-&gt;as_ValueTypePtr();
547     vt-&gt;set_oop(vtptr-&gt;get_oop());
548     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
549       vt-&gt;init_req(i, vtptr-&gt;in(i));
550     }
551   } else if (gvn.type(oop)-&gt;maybe_null()) {
552     // Add a null check because the oop may be null
553     Node* null_ctl = kit-&gt;top();
554     Node* not_null_oop = kit-&gt;null_check_oop(oop, &amp;null_ctl);
555     if (kit-&gt;stopped()) {
556       // Constant null
557       kit-&gt;set_control(null_ctl);
558       return make_default(gvn, vk);
559     }
560     vt-&gt;set_oop(not_null_oop);
561     vt-&gt;load(kit, not_null_oop, not_null_oop, vk, /* holder_offset */ 0);
562 
563     if (null_ctl != kit-&gt;top()) {
564       // Return default value type if oop is null
565       ValueTypeNode* def = make_default(gvn, vk);
566       Node* region = new RegionNode(3);
567       region-&gt;init_req(1, kit-&gt;control());
568       region-&gt;init_req(2, null_ctl);
569 
570       vt = vt-&gt;clone_with_phis(&amp;gvn, region)-&gt;as_ValueType();
571       vt-&gt;merge_with(&amp;gvn, def, 2, true);
572       kit-&gt;set_control(gvn.transform(region));
573     }
574   } else {
575     // Oop can never be null
576     Node* init_ctl = kit-&gt;control();
577     vt-&gt;load(kit, oop, oop, vk, /* holder_offset */ 0);
578     assert(init_ctl != kit-&gt;control() || !gvn.type(oop)-&gt;is_valuetypeptr() || oop-&gt;is_Con() || oop-&gt;Opcode() == Op_ValueTypePtr ||
579            AllocateNode::Ideal_allocation(oop, &amp;gvn) != NULL || vt-&gt;is_loaded(&amp;gvn) == oop, &quot;value type should be loaded&quot;);
580   }
581 
582   assert(vt-&gt;is_allocated(&amp;gvn), &quot;value type should be allocated&quot;);
583   return gvn.transform(vt)-&gt;as_ValueType();
584 }
585 
586 // GraphKit wrapper for the &#39;make_from_flattened&#39; method
587 ValueTypeNode* ValueTypeNode::make_from_flattened(GraphKit* kit, ciValueKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
588   // Create and initialize a ValueTypeNode by loading all field values from
589   // a flattened value type field at &#39;holder_offset&#39; or from a value type array.
590   ValueTypeNode* vt = make_uninitialized(kit-&gt;gvn(), vk);
591   // The value type is flattened into the object without an oop header. Subtract the
592   // offset of the first field to account for the missing header when loading the values.
593   holder_offset -= vk-&gt;first_field_offset();
594   vt-&gt;load(kit, obj, ptr, holder, holder_offset, decorators);
595   assert(vt-&gt;is_loaded(&amp;kit-&gt;gvn()) != obj, &quot;holder oop should not be used as flattened value type oop&quot;);
596   return kit-&gt;gvn().transform(vt)-&gt;as_ValueType();
597 }
598 
599 ValueTypeNode* ValueTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, ciValueKlass* vk, uint&amp; base_input, bool in) {
600   ValueTypeNode* vt = ValueTypeNode::make_uninitialized(kit-&gt;gvn(), vk);
601   vt-&gt;initialize_fields(kit, multi, sig, base_input, 0, in);
602   return kit-&gt;gvn().transform(vt)-&gt;as_ValueType();
603 }
604 
605 ValueTypeNode* ValueTypeNode::make_larval(GraphKit* kit, bool allocate) const {
606   ciValueKlass* vk = value_klass();
607   ValueTypeNode* res = clone()-&gt;as_ValueType();
608   if (allocate) {
609     // Re-execute if buffering triggers deoptimization
610     PreserveReexecuteState preexecs(kit);
611     kit-&gt;jvms()-&gt;set_should_reexecute(true);
612     Node* klass_node = kit-&gt;makecon(TypeKlassPtr::make(vk));
613     Node* alloc_oop  = kit-&gt;new_instance(klass_node, NULL, NULL, true);
614     AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &amp;kit-&gt;gvn());
615     alloc-&gt;_larval = true;
616 
617     store(kit, alloc_oop, alloc_oop, vk, 0);
618     res-&gt;set_oop(alloc_oop);
619   }
620   res-&gt;set_type(TypeValueType::make(vk, true));
621   res = kit-&gt;gvn().transform(res)-&gt;as_ValueType();
622   assert(!allocate || res-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
623   return res;
624 }
625 
626 ValueTypeNode* ValueTypeNode::finish_larval(GraphKit* kit) const {
627   Node* obj = get_oop();
628   Node* mark_addr = kit-&gt;basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
629   Node* mark = kit-&gt;make_load(NULL, mark_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
630   mark = kit-&gt;gvn().transform(new AndXNode(mark, kit-&gt;MakeConX(~markWord::larval_mask_in_place)));
631   kit-&gt;store_to_memory(kit-&gt;control(), mark_addr, mark, TypeX_X-&gt;basic_type(), kit-&gt;gvn().type(mark_addr)-&gt;is_ptr(), MemNode::unordered);
632 
633   // Do not let stores that initialize this buffer be reordered with a subsequent
634   // store that would make this buffer accessible by other threads.
635   AllocateNode* alloc = AllocateNode::Ideal_allocation(obj, &amp;kit-&gt;gvn());
636   assert(alloc != NULL, &quot;must have an allocation node&quot;);
637   kit-&gt;insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
638 
639   ciValueKlass* vk = value_klass();
640   ValueTypeNode* res = clone()-&gt;as_ValueType();
641   res-&gt;set_type(TypeValueType::make(vk, false));
642   res = kit-&gt;gvn().transform(res)-&gt;as_ValueType();
643   return res;
644 }
645 
646 Node* ValueTypeNode::is_loaded(PhaseGVN* phase, ciValueKlass* vk, Node* base, int holder_offset) {
647   if (vk == NULL) {
648     vk = value_klass();
649   }
650   if (field_count() == 0) {
651     assert(is_allocated(phase), &quot;must be allocated&quot;);
652     return get_oop();
653   }
654   for (uint i = 0; i &lt; field_count(); ++i) {
655     int offset = holder_offset + field_offset(i);
656     Node* value = field_value(i);
657     if (value-&gt;is_ValueType()) {
658       ValueTypeNode* vt = value-&gt;as_ValueType();
659       if (field_is_flattened(i)) {
660         // Check value type field load recursively
661         base = vt-&gt;is_loaded(phase, vk, base, offset - vt-&gt;value_klass()-&gt;first_field_offset());
662         if (base == NULL) {
663           return NULL;
664         }
665         continue;
666       } else {
667         value = vt-&gt;get_oop();
668         if (value-&gt;Opcode() == Op_CastPP) {
669           // Skip CastPP
670           value = value-&gt;in(1);
671         }
672       }
673     }
674     if (value-&gt;isa_DecodeN()) {
675       // Skip DecodeN
676       value = value-&gt;in(1);
677     }
678     if (value-&gt;isa_Load()) {
679       // Check if base and offset of field load matches value type layout
680       intptr_t loffset = 0;
681       Node* lbase = AddPNode::Ideal_base_and_offset(value-&gt;in(MemNode::Address), phase, loffset);
682       if (lbase == NULL || (lbase != base &amp;&amp; base != NULL) || loffset != offset) {
683         return NULL;
684       } else if (base == NULL) {
685         // Set base and check if pointer type matches
686         base = lbase;
687         const TypeInstPtr* vtptr = phase-&gt;type(base)-&gt;isa_instptr();
688         if (vtptr == NULL || !vtptr-&gt;klass()-&gt;equals(vk)) {
689           return NULL;
690         }
691       }
692     } else {
693       return NULL;
694     }
695   }
696   return base;
697 }
698 
699 Node* ValueTypeNode::tagged_klass(ciValueKlass* vk, PhaseGVN&amp; gvn) {
700   const TypeKlassPtr* tk = TypeKlassPtr::make(vk);
701   intptr_t bits = tk-&gt;get_con();
702   set_nth_bit(bits, 0);
703   return gvn.makecon(TypeRawPtr::make((address)bits));
704 }
705 
706 void ValueTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
707   for (uint i = 0; i &lt; field_count(); i++) {
708     int sig_offset = (*sig)._offset;
709     uint idx = field_index(sig_offset - base_offset);
710     Node* arg = field_value(idx);
711 
712     if (field_is_flattened(idx)) {
713       // Flattened value type field
714       ValueTypeNode* vt = arg-&gt;as_ValueType();
715       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;value_klass()-&gt;first_field_offset());
716     } else {
717       if (arg-&gt;is_ValueType()) {
718         // Non-flattened value type field
719         ValueTypeNode* vt = arg-&gt;as_ValueType();
720         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;value type field should be allocated on return&quot;);
<a name="11" id="anc11"></a><span class="line-modified">721         arg = vt-&gt;allocate(kit)-&gt;get_oop();</span>
722       }
723       // Initialize call/return arguments
724       BasicType bt = field_type(i)-&gt;basic_type();
725       n-&gt;init_req(base_input++, arg);
726       if (type2size[bt] == 2) {
727         n-&gt;init_req(base_input++, kit-&gt;top());
728       }
729       // Skip reserved arguments
730       while (SigEntry::next_is_reserved(sig, bt)) {
731         n-&gt;init_req(base_input++, kit-&gt;top());
732         if (type2size[bt] == 2) {
733           n-&gt;init_req(base_input++, kit-&gt;top());
734         }
735       }
736     }
737   }
738 }
739 
740 void ValueTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
741   PhaseGVN&amp; gvn = kit-&gt;gvn();
742   for (uint i = 0; i &lt; field_count(); i++) {
743     int sig_offset = (*sig)._offset;
744     uint idx = field_index(sig_offset - base_offset);
745     ciType* type = field_type(idx);
746 
747     Node* parm = NULL;
748     if (field_is_flattened(idx)) {
749       // Flattened value type field
750       ValueTypeNode* vt = ValueTypeNode::make_uninitialized(gvn, type-&gt;as_value_klass());
751       vt-&gt;initialize_fields(kit, multi, sig, base_input, sig_offset - type-&gt;as_value_klass()-&gt;first_field_offset(), in);
752       parm = gvn.transform(vt);
753     } else {
754       if (multi-&gt;is_Start()) {
755         assert(in, &quot;return from start?&quot;);
756         parm = gvn.transform(new ParmNode(multi-&gt;as_Start(), base_input));
757       } else if (in) {
758         parm = multi-&gt;as_Call()-&gt;in(base_input);
759       } else {
760         parm = gvn.transform(new ProjNode(multi-&gt;as_Call(), base_input));
761       }
762       if (field_is_flattenable(idx)) {
763         // Non-flattened but flattenable value type
764         if (type-&gt;as_value_klass()-&gt;is_scalarizable()) {
765           parm = ValueTypeNode::make_from_oop(kit, parm, type-&gt;as_value_klass());
766         } else {
767           parm = kit-&gt;null2default(parm, type-&gt;as_value_klass());
768         }
769       }
770       base_input += type2size[type-&gt;basic_type()];
771       // Skip reserved arguments
772       BasicType bt = type-&gt;basic_type();
773       while (SigEntry::next_is_reserved(sig, bt)) {
774         base_input += type2size[bt];
775       }
776     }
777     assert(parm != NULL, &quot;should never be null&quot;);
778     set_field_value(idx, parm);
779     gvn.record_for_igvn(parm);
780   }
781 }
782 
783 Node* ValueTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
784   Node* oop = get_oop();
785   if (is_default(*phase) &amp;&amp; (!oop-&gt;is_Con() || phase-&gt;type(oop)-&gt;is_zero_type())) {
786     // Use the pre-allocated oop for default value types
787     set_oop(default_oop(*phase, value_klass()));
788     return this;
789   } else if (oop-&gt;isa_ValueTypePtr()) {
790     // Can happen with late inlining
791     ValueTypePtrNode* vtptr = oop-&gt;as_ValueTypePtr();
792     set_oop(vtptr-&gt;get_oop());
793     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
794       set_req(i, vtptr-&gt;in(i));
795     }
796     return this;
797   }
798 
799   if (!is_allocated(phase)) {
800     // Save base oop if fields are loaded from memory and the value
801     // type is not buffered (in this case we should not use the oop).
802     Node* base = is_loaded(phase);
803     if (base != NULL) {
804       set_oop(base);
805       assert(is_allocated(phase), &quot;should now be allocated&quot;);
806       return this;
807     }
808   }
809 
810   if (can_reshape) {
811     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
812 
813     if (is_default(*phase)) {
814       // Search for users of the default value type
815       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
816         Node* user = fast_out(i);
817         AllocateNode* alloc = user-&gt;isa_Allocate();
818         if (alloc != NULL &amp;&amp; alloc-&gt;result_cast() != NULL &amp;&amp; alloc-&gt;in(AllocateNode::ValueNode) == this) {
819           // Found an allocation of the default value type.
820           // If the code in StoreNode::Identity() that removes useless stores was not yet
821           // executed or ReduceFieldZeroing is disabled, there can still be initializing
822           // stores (only zero-type or default value stores, because value types are immutable).
823           Node* res = alloc-&gt;result_cast();
824           for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax); j &lt; jmax; j++) {
825             AddPNode* addp = res-&gt;fast_out(j)-&gt;isa_AddP();
826             if (addp != NULL) {
827               for (DUIterator_Fast kmax, k = addp-&gt;fast_outs(kmax); k &lt; kmax; k++) {
828                 StoreNode* store = addp-&gt;fast_out(k)-&gt;isa_Store();
829                 if (store != NULL &amp;&amp; store-&gt;outcnt() != 0) {
830                   // Remove the useless store
831                   igvn-&gt;replace_in_uses(store, store-&gt;in(MemNode::Memory));
832                 }
833               }
834             }
835           }
836           // Replace allocation by pre-allocated oop
837           igvn-&gt;replace_node(res, default_oop(*phase, value_klass()));
838         } else if (user-&gt;is_ValueType()) {
839           // Add value type user to worklist to give it a chance to get optimized as well
840           igvn-&gt;_worklist.push(user);
841         }
842       }
843     }
844 
845     if (is_allocated(igvn)) {
846       // Value type is heap allocated, search for safepoint uses
847       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
848         Node* out = fast_out(i);
849         if (out-&gt;is_SafePoint()) {
850           // Let SafePointNode::Ideal() take care of re-wiring the
851           // safepoint to the oop input instead of the value type node.
852           igvn-&gt;rehash_node_delayed(out);
853         }
854       }
855     }
856   }
857   return NULL;
858 }
859 
860 // Search for multiple allocations of this value type
861 // and try to replace them by dominating allocations.
862 // Then unlink the value type node and remove it.
863 void ValueTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {
864   // Search for allocations of this value type
865   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
866     AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();
867     if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::ValueNode) == this) {
868       assert(!is_default(*igvn), &quot;default value type allocation&quot;);
869       Node* res = alloc-&gt;result_cast();
870       if (res == NULL || !res-&gt;is_CheckCastPP()) {
871         break; // No unique CheckCastPP
872       }
873       Node* res_dom = res;
874       if (is_allocated(igvn)) {
875         // The value type is already allocated but still connected to an AllocateNode.
876         // This can happen with late inlining when we first allocate a value type argument
877         // but later decide to inline the call with the callee code also allocating.
878         res_dom = get_oop();
879       } else {
880         // Search for a dominating allocation of the same value type
881         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
882           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
883           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::ValueNode) == this) {
884             Node* res_other = alloc_other-&gt;result_cast();
885             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
886                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
887               res_dom = res_other;
888             }
889           }
890         }
891       }
892       if (res_dom != res) {
893         // Move users to dominating allocation
894         igvn-&gt;replace_node(res, res_dom);
<a name="12" id="anc12"></a><span class="line-modified">895         // The result of the dominated allocation is now unused and will be</span>
<span class="line-modified">896         // removed later in AllocateNode::Ideal() to not confuse loop opts.</span>
897         igvn-&gt;record_for_igvn(alloc);
<a name="13" id="anc13"></a><span class="line-removed">898 #ifdef ASSERT</span>
<span class="line-removed">899         if (PrintEliminateAllocations) {</span>
<span class="line-removed">900           tty-&gt;print(&quot;++++ Eliminated: %d Allocate &quot;, alloc-&gt;_idx);</span>
<span class="line-removed">901           dump_spec(tty);</span>
<span class="line-removed">902           tty-&gt;cr();</span>
<span class="line-removed">903         }</span>
<span class="line-removed">904 #endif</span>
905       }
906     }
907   }
908 
909   // Process users
910   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
911     Node* out = fast_out(i);
912     if (out-&gt;is_ValueType()) {
913       // Recursively process value type users
914       out-&gt;as_ValueType()-&gt;remove_redundant_allocations(igvn, phase);
915       --i; --imax;
916     } else if (out-&gt;isa_Allocate() != NULL) {
917       // Unlink AllocateNode
918       assert(out-&gt;in(AllocateNode::ValueNode) == this, &quot;should be linked&quot;);
919       igvn-&gt;replace_input_of(out, AllocateNode::ValueNode, igvn-&gt;C-&gt;top());
920       --i; --imax;
921     } else {
922 #ifdef ASSERT
923       // The value type should not have any other users at this time
924       out-&gt;dump();
925       assert(false, &quot;unexpected user of value type&quot;);
926 #endif
927     }
928   }
929   igvn-&gt;remove_dead_node(this);
930 }
<a name="14" id="anc14"></a><span class="line-removed">931 </span>
<span class="line-removed">932 ValueTypePtrNode* ValueTypePtrNode::make_from_value_type(GraphKit* kit, ValueTypeNode* vt) {</span>
<span class="line-removed">933   Node* oop = vt-&gt;allocate(kit)-&gt;get_oop();</span>
<span class="line-removed">934   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vt-&gt;value_klass(), oop);</span>
<span class="line-removed">935   for (uint i = Oop+1; i &lt; vt-&gt;req(); i++) {</span>
<span class="line-removed">936     vtptr-&gt;init_req(i, vt-&gt;in(i));</span>
<span class="line-removed">937   }</span>
<span class="line-removed">938   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">939 }</span>
<span class="line-removed">940 </span>
<span class="line-removed">941 ValueTypePtrNode* ValueTypePtrNode::make_from_oop(GraphKit* kit, Node* oop) {</span>
<span class="line-removed">942   // Create and initialize a ValueTypePtrNode by loading all field</span>
<span class="line-removed">943   // values from a heap-allocated version and also save the oop.</span>
<span class="line-removed">944   ciValueKlass* vk = kit-&gt;gvn().type(oop)-&gt;value_klass();</span>
<span class="line-removed">945   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vk, oop);</span>
<span class="line-removed">946   vtptr-&gt;load(kit, oop, oop, vk);</span>
<span class="line-removed">947   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">948 }</span>
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
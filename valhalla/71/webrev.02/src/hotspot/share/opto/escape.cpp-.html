<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/escape.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/c2compiler.hpp&quot;
  34 #include &quot;opto/arraycopynode.hpp&quot;
  35 #include &quot;opto/callnode.hpp&quot;
  36 #include &quot;opto/cfgnode.hpp&quot;
  37 #include &quot;opto/compile.hpp&quot;
  38 #include &quot;opto/escape.hpp&quot;
  39 #include &quot;opto/phaseX.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn) :
  45   _nodes(C-&gt;comp_arena(), C-&gt;unique(), C-&gt;unique(), NULL),
  46   _in_worklist(C-&gt;comp_arena()),
  47   _next_pidx(0),
  48   _collecting(true),
  49   _verify(false),
  50   _compile(C),
  51   _igvn(igvn),
  52   _node_map(C-&gt;comp_arena()) {
  53   // Add unknown java object.
  54   add_java_object(C-&gt;top(), PointsToNode::GlobalEscape);
  55   phantom_obj = ptnode_adr(C-&gt;top()-&gt;_idx)-&gt;as_JavaObject();
  56   // Add ConP(#NULL) and ConN(#NULL) nodes.
  57   Node* oop_null = igvn-&gt;zerocon(T_OBJECT);
  58   assert(oop_null-&gt;_idx &lt; nodes_size(), &quot;should be created already&quot;);
  59   add_java_object(oop_null, PointsToNode::NoEscape);
  60   null_obj = ptnode_adr(oop_null-&gt;_idx)-&gt;as_JavaObject();
  61   if (UseCompressedOops) {
  62     Node* noop_null = igvn-&gt;zerocon(T_NARROWOOP);
  63     assert(noop_null-&gt;_idx &lt; nodes_size(), &quot;should be created already&quot;);
  64     map_ideal_node(noop_null, null_obj);
  65   }
  66   _pcmp_neq = NULL; // Should be initialized
  67   _pcmp_eq  = NULL;
  68 }
  69 
  70 bool ConnectionGraph::has_candidates(Compile *C) {
  71   // EA brings benefits only when the code has allocations and/or locks which
  72   // are represented by ideal Macro nodes.
  73   int cnt = C-&gt;macro_count();
  74   for (int i = 0; i &lt; cnt; i++) {
  75     Node *n = C-&gt;macro_node(i);
  76     if (n-&gt;is_Allocate())
  77       return true;
  78     if (n-&gt;is_Lock()) {
  79       Node* obj = n-&gt;as_Lock()-&gt;obj_node()-&gt;uncast();
  80       if (!(obj-&gt;is_Parm() || obj-&gt;is_Con()))
  81         return true;
  82     }
  83     if (n-&gt;is_CallStaticJava() &amp;&amp;
  84         n-&gt;as_CallStaticJava()-&gt;is_boxing_method()) {
  85       return true;
  86     }
  87   }
  88   return false;
  89 }
  90 
  91 void ConnectionGraph::do_analysis(Compile *C, PhaseIterGVN *igvn) {
  92   Compile::TracePhase tp(&quot;escapeAnalysis&quot;, &amp;Phase::timers[Phase::_t_escapeAnalysis]);
  93   ResourceMark rm;
  94 
  95   // Add ConP#NULL and ConN#NULL nodes before ConnectionGraph construction
  96   // to create space for them in ConnectionGraph::_nodes[].
  97   Node* oop_null = igvn-&gt;zerocon(T_OBJECT);
  98   Node* noop_null = igvn-&gt;zerocon(T_NARROWOOP);
  99   ConnectionGraph* congraph = new(C-&gt;comp_arena()) ConnectionGraph(C, igvn);
 100   // Perform escape analysis
 101   if (congraph-&gt;compute_escape()) {
 102     // There are non escaping objects.
 103     C-&gt;set_congraph(congraph);
 104   }
 105   // Cleanup.
 106   if (oop_null-&gt;outcnt() == 0)
 107     igvn-&gt;hash_delete(oop_null);
 108   if (noop_null-&gt;outcnt() == 0)
 109     igvn-&gt;hash_delete(noop_null);
 110 }
 111 
 112 bool ConnectionGraph::compute_escape() {
 113   Compile* C = _compile;
 114   PhaseGVN* igvn = _igvn;
 115 
 116   // Worklists used by EA.
 117   Unique_Node_List delayed_worklist;
 118   GrowableArray&lt;Node*&gt; alloc_worklist;
 119   GrowableArray&lt;Node*&gt; ptr_cmp_worklist;
 120   GrowableArray&lt;Node*&gt; storestore_worklist;
 121   GrowableArray&lt;ArrayCopyNode*&gt; arraycopy_worklist;
 122   GrowableArray&lt;PointsToNode*&gt;   ptnodes_worklist;
 123   GrowableArray&lt;JavaObjectNode*&gt; java_objects_worklist;
 124   GrowableArray&lt;JavaObjectNode*&gt; non_escaped_worklist;
 125   GrowableArray&lt;FieldNode*&gt;      oop_fields_worklist;
 126   DEBUG_ONLY( GrowableArray&lt;Node*&gt; addp_worklist; )
 127 
 128   { Compile::TracePhase tp(&quot;connectionGraph&quot;, &amp;Phase::timers[Phase::_t_connectionGraph]);
 129 
 130   // 1. Populate Connection Graph (CG) with PointsTo nodes.
 131   ideal_nodes.map(C-&gt;live_nodes(), NULL);  // preallocate space
 132   // Initialize worklist
 133   if (C-&gt;root() != NULL) {
 134     ideal_nodes.push(C-&gt;root());
 135   }
 136   // Processed ideal nodes are unique on ideal_nodes list
 137   // but several ideal nodes are mapped to the phantom_obj.
 138   // To avoid duplicated entries on the following worklists
 139   // add the phantom_obj only once to them.
 140   ptnodes_worklist.append(phantom_obj);
 141   java_objects_worklist.append(phantom_obj);
 142   for( uint next = 0; next &lt; ideal_nodes.size(); ++next ) {
 143     Node* n = ideal_nodes.at(next);
 144     if ((n-&gt;Opcode() == Op_LoadX || n-&gt;Opcode() == Op_StoreX) &amp;&amp;
 145         !n-&gt;in(MemNode::Address)-&gt;is_AddP() &amp;&amp;
 146         _igvn-&gt;type(n-&gt;in(MemNode::Address))-&gt;isa_oopptr()) {
 147       // Load/Store at mark work address is at offset 0 so has no AddP which confuses EA
 148       Node* addp = new AddPNode(n-&gt;in(MemNode::Address), n-&gt;in(MemNode::Address), _igvn-&gt;MakeConX(0));
 149       _igvn-&gt;register_new_node_with_optimizer(addp);
 150       _igvn-&gt;replace_input_of(n, MemNode::Address, addp);
 151       ideal_nodes.push(addp);
 152       _nodes.at_put_grow(addp-&gt;_idx, NULL, NULL);
 153     }
 154     // Create PointsTo nodes and add them to Connection Graph. Called
 155     // only once per ideal node since ideal_nodes is Unique_Node list.
 156     add_node_to_connection_graph(n, &amp;delayed_worklist);
 157     PointsToNode* ptn = ptnode_adr(n-&gt;_idx);
 158     if (ptn != NULL &amp;&amp; ptn != phantom_obj) {
 159       ptnodes_worklist.append(ptn);
 160       if (ptn-&gt;is_JavaObject()) {
 161         java_objects_worklist.append(ptn-&gt;as_JavaObject());
 162         if ((n-&gt;is_Allocate() || n-&gt;is_CallStaticJava()) &amp;&amp;
 163             (ptn-&gt;escape_state() &lt; PointsToNode::GlobalEscape)) {
 164           // Only allocations and java static calls results are interesting.
 165           non_escaped_worklist.append(ptn-&gt;as_JavaObject());
 166         }
 167       } else if (ptn-&gt;is_Field() &amp;&amp; ptn-&gt;as_Field()-&gt;is_oop()) {
 168         oop_fields_worklist.append(ptn-&gt;as_Field());
 169       }
 170     }
 171     if (n-&gt;is_MergeMem()) {
 172       // Collect all MergeMem nodes to add memory slices for
 173       // scalar replaceable objects in split_unique_types().
 174       _mergemem_worklist.append(n-&gt;as_MergeMem());
 175     } else if (OptimizePtrCompare &amp;&amp; n-&gt;is_Cmp() &amp;&amp;
 176                (n-&gt;Opcode() == Op_CmpP || n-&gt;Opcode() == Op_CmpN)) {
 177       // Collect compare pointers nodes.
 178       ptr_cmp_worklist.append(n);
 179     } else if (n-&gt;is_MemBarStoreStore()) {
 180       // Collect all MemBarStoreStore nodes so that depending on the
 181       // escape status of the associated Allocate node some of them
 182       // may be eliminated.
 183       storestore_worklist.append(n);
 184     } else if (n-&gt;is_MemBar() &amp;&amp; (n-&gt;Opcode() == Op_MemBarRelease) &amp;&amp;
 185                (n-&gt;req() &gt; MemBarNode::Precedent)) {
 186       record_for_optimizer(n);
 187 #ifdef ASSERT
 188     } else if (n-&gt;is_AddP()) {
 189       // Collect address nodes for graph verification.
 190       addp_worklist.append(n);
 191 #endif
 192     } else if (n-&gt;is_ArrayCopy()) {
 193       // Keep a list of ArrayCopy nodes so if one of its input is non
 194       // escaping, we can record a unique type
 195       arraycopy_worklist.append(n-&gt;as_ArrayCopy());
 196     }
 197     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 198       Node* m = n-&gt;fast_out(i);   // Get user
 199       ideal_nodes.push(m);
 200     }
 201   }
 202   if (non_escaped_worklist.length() == 0) {
 203     _collecting = false;
 204     return false; // Nothing to do.
 205   }
 206   // Add final simple edges to graph.
 207   while(delayed_worklist.size() &gt; 0) {
 208     Node* n = delayed_worklist.pop();
 209     add_final_edges(n);
 210   }
 211   int ptnodes_length = ptnodes_worklist.length();
 212 
 213 #ifdef ASSERT
 214   if (VerifyConnectionGraph) {
 215     // Verify that no new simple edges could be created and all
 216     // local vars has edges.
 217     _verify = true;
 218     for (int next = 0; next &lt; ptnodes_length; ++next) {
 219       PointsToNode* ptn = ptnodes_worklist.at(next);
 220       add_final_edges(ptn-&gt;ideal_node());
 221       if (ptn-&gt;is_LocalVar() &amp;&amp; ptn-&gt;edge_count() == 0) {
 222         ptn-&gt;dump();
 223         assert(ptn-&gt;as_LocalVar()-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
 224       }
 225     }
 226     _verify = false;
 227   }
 228 #endif
 229   // Bytecode analyzer BCEscapeAnalyzer, used for Call nodes
 230   // processing, calls to CI to resolve symbols (types, fields, methods)
 231   // referenced in bytecode. During symbol resolution VM may throw
 232   // an exception which CI cleans and converts to compilation failure.
 233   if (C-&gt;failing())  return false;
 234 
 235   // 2. Finish Graph construction by propagating references to all
 236   //    java objects through graph.
 237   if (!complete_connection_graph(ptnodes_worklist, non_escaped_worklist,
 238                                  java_objects_worklist, oop_fields_worklist)) {
 239     // All objects escaped or hit time or iterations limits.
 240     _collecting = false;
 241     return false;
 242   }
 243 
 244   // 3. Adjust scalar_replaceable state of nonescaping objects and push
 245   //    scalar replaceable allocations on alloc_worklist for processing
 246   //    in split_unique_types().
 247   int non_escaped_length = non_escaped_worklist.length();
 248   for (int next = 0; next &lt; non_escaped_length; next++) {
 249     JavaObjectNode* ptn = non_escaped_worklist.at(next);
 250     bool noescape = (ptn-&gt;escape_state() == PointsToNode::NoEscape);
 251     Node* n = ptn-&gt;ideal_node();
 252     if (n-&gt;is_Allocate()) {
 253       n-&gt;as_Allocate()-&gt;_is_non_escaping = noescape;
 254     }
 255     if (n-&gt;is_CallStaticJava()) {
 256       n-&gt;as_CallStaticJava()-&gt;_is_non_escaping = noescape;
 257     }
 258     if (noescape &amp;&amp; ptn-&gt;scalar_replaceable()) {
 259       adjust_scalar_replaceable_state(ptn);
 260       if (ptn-&gt;scalar_replaceable()) {
 261         alloc_worklist.append(ptn-&gt;ideal_node());
 262       }
 263     }
 264   }
 265 
 266 #ifdef ASSERT
 267   if (VerifyConnectionGraph) {
 268     // Verify that graph is complete - no new edges could be added or needed.
 269     verify_connection_graph(ptnodes_worklist, non_escaped_worklist,
 270                             java_objects_worklist, addp_worklist);
 271   }
 272   assert(C-&gt;unique() == nodes_size(), &quot;no new ideal nodes should be added during ConnectionGraph build&quot;);
 273   assert(null_obj-&gt;escape_state() == PointsToNode::NoEscape &amp;&amp;
 274          null_obj-&gt;edge_count() == 0 &amp;&amp;
 275          !null_obj-&gt;arraycopy_src() &amp;&amp;
 276          !null_obj-&gt;arraycopy_dst(), &quot;sanity&quot;);
 277 #endif
 278 
 279   _collecting = false;
 280 
 281   } // TracePhase t3(&quot;connectionGraph&quot;)
 282 
 283   // 4. Optimize ideal graph based on EA information.
 284   bool has_non_escaping_obj = (non_escaped_worklist.length() &gt; 0);
 285   if (has_non_escaping_obj) {
 286     optimize_ideal_graph(ptr_cmp_worklist, storestore_worklist);
 287   }
 288 
 289 #ifndef PRODUCT
 290   if (PrintEscapeAnalysis) {
 291     dump(ptnodes_worklist); // Dump ConnectionGraph
 292   }
 293 #endif
 294 
 295   bool has_scalar_replaceable_candidates = (alloc_worklist.length() &gt; 0);
 296 #ifdef ASSERT
 297   if (VerifyConnectionGraph) {
 298     int alloc_length = alloc_worklist.length();
 299     for (int next = 0; next &lt; alloc_length; ++next) {
 300       Node* n = alloc_worklist.at(next);
 301       PointsToNode* ptn = ptnode_adr(n-&gt;_idx);
 302       assert(ptn-&gt;escape_state() == PointsToNode::NoEscape &amp;&amp; ptn-&gt;scalar_replaceable(), &quot;sanity&quot;);
 303     }
 304   }
 305 #endif
 306 
 307   // 5. Separate memory graph for scalar replaceable allcations.
 308   if (has_scalar_replaceable_candidates &amp;&amp;
 309       C-&gt;AliasLevel() &gt;= 3 &amp;&amp; EliminateAllocations) {
 310     // Now use the escape information to create unique types for
 311     // scalar replaceable objects.
 312     split_unique_types(alloc_worklist, arraycopy_worklist);
 313     if (C-&gt;failing())  return false;
 314     C-&gt;print_method(PHASE_AFTER_EA, 2);
 315 
 316 #ifdef ASSERT
 317   } else if (Verbose &amp;&amp; (PrintEscapeAnalysis || PrintEliminateAllocations)) {
 318     tty-&gt;print(&quot;=== No allocations eliminated for &quot;);
 319     C-&gt;method()-&gt;print_short_name();
 320     if(!EliminateAllocations) {
 321       tty-&gt;print(&quot; since EliminateAllocations is off ===&quot;);
 322     } else if(!has_scalar_replaceable_candidates) {
 323       tty-&gt;print(&quot; since there are no scalar replaceable candidates ===&quot;);
 324     } else if(C-&gt;AliasLevel() &lt; 3) {
 325       tty-&gt;print(&quot; since AliasLevel &lt; 3 ===&quot;);
 326     }
 327     tty-&gt;cr();
 328 #endif
 329   }
 330   return has_non_escaping_obj;
 331 }
 332 
 333 // Utility function for nodes that load an object
 334 void ConnectionGraph::add_objload_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist) {
 335   // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 336   // ThreadLocal has RawPtr type.
 337   const Type* t = _igvn-&gt;type(n);
 338   if (t-&gt;make_ptr() != NULL) {
 339     Node* adr = n-&gt;in(MemNode::Address);
 340 #ifdef ASSERT
 341     if (!adr-&gt;is_AddP()) {
 342       assert(_igvn-&gt;type(adr)-&gt;isa_rawptr(), &quot;sanity&quot;);
 343     } else {
 344       assert((ptnode_adr(adr-&gt;_idx) == NULL ||
 345               ptnode_adr(adr-&gt;_idx)-&gt;as_Field()-&gt;is_oop()), &quot;sanity&quot;);
 346     }
 347 #endif
 348     add_local_var_and_edge(n, PointsToNode::NoEscape,
 349                            adr, delayed_worklist);
 350   }
 351 }
 352 
 353 // Populate Connection Graph with PointsTo nodes and create simple
 354 // connection graph edges.
 355 void ConnectionGraph::add_node_to_connection_graph(Node *n, Unique_Node_List *delayed_worklist) {
 356   assert(!_verify, &quot;this method should not be called for verification&quot;);
 357   PhaseGVN* igvn = _igvn;
 358   uint n_idx = n-&gt;_idx;
 359   PointsToNode* n_ptn = ptnode_adr(n_idx);
 360   if (n_ptn != NULL)
 361     return; // No need to redefine PointsTo node during first iteration.
 362 
 363   int opcode = n-&gt;Opcode();
 364   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_to_con_graph(this, igvn, delayed_worklist, n, opcode);
 365   if (gc_handled) {
 366     return; // Ignore node if already handled by GC.
 367   }
 368 
 369   if (n-&gt;is_Call()) {
 370     // Arguments to allocation and locking don&#39;t escape.
 371     if (n-&gt;is_AbstractLock()) {
 372       // Put Lock and Unlock nodes on IGVN worklist to process them during
 373       // first IGVN optimization when escape information is still available.
 374       record_for_optimizer(n);
 375     } else if (n-&gt;is_Allocate()) {
 376       add_call_node(n-&gt;as_Call());
 377       record_for_optimizer(n);
 378     } else {
 379       if (n-&gt;is_CallStaticJava()) {
 380         const char* name = n-&gt;as_CallStaticJava()-&gt;_name;
 381         if (name != NULL &amp;&amp; strcmp(name, &quot;uncommon_trap&quot;) == 0)
 382           return; // Skip uncommon traps
 383       }
 384       // Don&#39;t mark as processed since call&#39;s arguments have to be processed.
 385       delayed_worklist-&gt;push(n);
 386       // Check if a call returns an object.
 387       if ((n-&gt;as_Call()-&gt;returns_pointer() &amp;&amp;
 388            n-&gt;as_Call()-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) ||
 389           (n-&gt;is_CallStaticJava() &amp;&amp;
 390            n-&gt;as_CallStaticJava()-&gt;is_boxing_method())) {
 391         add_call_node(n-&gt;as_Call());
 392       } else if (n-&gt;as_Call()-&gt;tf()-&gt;returns_value_type_as_fields()) {
 393         bool returns_oop = false;
 394         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !returns_oop; i++) {
 395           ProjNode* pn = n-&gt;fast_out(i)-&gt;as_Proj();
 396           if (pn-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; pn-&gt;bottom_type()-&gt;isa_ptr()) {
 397             returns_oop = true;
 398           }
 399         }
 400         if (returns_oop) {
 401           add_call_node(n-&gt;as_Call());
 402         }
 403       }
 404     }
 405     return;
 406   }
 407   // Put this check here to process call arguments since some call nodes
 408   // point to phantom_obj.
 409   if (n_ptn == phantom_obj || n_ptn == null_obj)
 410     return; // Skip predefined nodes.
 411 
 412   switch (opcode) {
 413     case Op_AddP: {
 414       Node* base = get_addp_base(n);
 415       PointsToNode* ptn_base = ptnode_adr(base-&gt;_idx);
 416       // Field nodes are created for all field types. They are used in
 417       // adjust_scalar_replaceable_state() and split_unique_types().
 418       // Note, non-oop fields will have only base edges in Connection
 419       // Graph because such fields are not used for oop loads and stores.
 420       int offset = address_offset(n, igvn);
 421       add_field(n, PointsToNode::NoEscape, offset);
 422       if (ptn_base == NULL) {
 423         delayed_worklist-&gt;push(n); // Process it later.
 424       } else {
 425         n_ptn = ptnode_adr(n_idx);
 426         add_base(n_ptn-&gt;as_Field(), ptn_base);
 427       }
 428       break;
 429     }
 430     case Op_CastX2P: {
 431       map_ideal_node(n, phantom_obj);
 432       break;
 433     }
 434     case Op_CastPP:
 435     case Op_CheckCastPP:
 436     case Op_EncodeP:
 437     case Op_DecodeN:
 438     case Op_EncodePKlass:
 439     case Op_DecodeNKlass: {
 440       add_local_var_and_edge(n, PointsToNode::NoEscape,
 441                              n-&gt;in(1), delayed_worklist);
 442       break;
 443     }
 444     case Op_CMoveP: {
 445       add_local_var(n, PointsToNode::NoEscape);
 446       // Do not add edges during first iteration because some could be
 447       // not defined yet.
 448       delayed_worklist-&gt;push(n);
 449       break;
 450     }
 451     case Op_ConP:
 452     case Op_ConN:
 453     case Op_ConNKlass: {
 454       // assume all oop constants globally escape except for null
 455       PointsToNode::EscapeState es;
 456       const Type* t = igvn-&gt;type(n);
 457       if (t == TypePtr::NULL_PTR || t == TypeNarrowOop::NULL_PTR) {
 458         es = PointsToNode::NoEscape;
 459       } else {
 460         es = PointsToNode::GlobalEscape;
 461       }
 462       add_java_object(n, es);
 463       break;
 464     }
 465     case Op_CreateEx: {
 466       // assume that all exception objects globally escape
 467       map_ideal_node(n, phantom_obj);
 468       break;
 469     }
 470     case Op_LoadKlass:
 471     case Op_LoadNKlass: {
 472       // Unknown class is loaded
 473       map_ideal_node(n, phantom_obj);
 474       break;
 475     }
 476     case Op_LoadP:
 477     case Op_LoadN:
 478     case Op_LoadPLocked: {
 479       add_objload_to_connection_graph(n, delayed_worklist);
 480       break;
 481     }
 482     case Op_Parm: {
 483       map_ideal_node(n, phantom_obj);
 484       break;
 485     }
 486     case Op_PartialSubtypeCheck: {
 487       // Produces Null or notNull and is used in only in CmpP so
 488       // phantom_obj could be used.
 489       map_ideal_node(n, phantom_obj); // Result is unknown
 490       break;
 491     }
 492     case Op_Phi: {
 493       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 494       // ThreadLocal has RawPtr type.
 495       const Type* t = n-&gt;as_Phi()-&gt;type();
 496       if (t-&gt;make_ptr() != NULL) {
 497         add_local_var(n, PointsToNode::NoEscape);
 498         // Do not add edges during first iteration because some could be
 499         // not defined yet.
 500         delayed_worklist-&gt;push(n);
 501       }
 502       break;
 503     }
 504     case Op_Proj: {
 505       // we are only interested in the oop result projection from a call
 506       if (n-&gt;as_Proj()-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;is_Call() &amp;&amp;
 507           (n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer() || n-&gt;bottom_type()-&gt;isa_ptr())) {
 508         assert((n-&gt;as_Proj()-&gt;_con == TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()) ||
 509                n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;returns_value_type_as_fields(), &quot;what kind of oop return is it?&quot;);
 510         add_local_var_and_edge(n, PointsToNode::NoEscape,
 511                                n-&gt;in(0), delayed_worklist);
 512       }
 513       break;
 514     }
 515     case Op_Rethrow: // Exception object escapes
 516     case Op_Return: {
 517       if (n-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
 518           igvn-&gt;type(n-&gt;in(TypeFunc::Parms))-&gt;isa_oopptr()) {
 519         // Treat Return value as LocalVar with GlobalEscape escape state.
 520         add_local_var_and_edge(n, PointsToNode::GlobalEscape,
 521                                n-&gt;in(TypeFunc::Parms), delayed_worklist);
 522       }
 523       break;
 524     }
 525     case Op_CompareAndExchangeP:
 526     case Op_CompareAndExchangeN:
 527     case Op_GetAndSetP:
 528     case Op_GetAndSetN: {
 529       add_objload_to_connection_graph(n, delayed_worklist);
 530       // fallthrough
 531     }
 532     case Op_StoreP:
 533     case Op_StoreN:
 534     case Op_StoreNKlass:
 535     case Op_StorePConditional:
 536     case Op_WeakCompareAndSwapP:
 537     case Op_WeakCompareAndSwapN:
 538     case Op_CompareAndSwapP:
 539     case Op_CompareAndSwapN: {
 540       add_to_congraph_unsafe_access(n, opcode, delayed_worklist);
 541       break;
 542     }
 543     case Op_AryEq:
 544     case Op_HasNegatives:
 545     case Op_StrComp:
 546     case Op_StrEquals:
 547     case Op_StrIndexOf:
 548     case Op_StrIndexOfChar:
 549     case Op_StrInflatedCopy:
 550     case Op_StrCompressedCopy:
 551     case Op_EncodeISOArray: {
 552       add_local_var(n, PointsToNode::ArgEscape);
 553       delayed_worklist-&gt;push(n); // Process it later.
 554       break;
 555     }
 556     case Op_ThreadLocal: {
 557       add_java_object(n, PointsToNode::ArgEscape);
 558       break;
 559     }
 560     default:
 561       ; // Do nothing for nodes not related to EA.
 562   }
 563   return;
 564 }
 565 
 566 #ifdef ASSERT
 567 #define ELSE_FAIL(name)                               \
 568       /* Should not be called for not pointer type. */  \
 569       n-&gt;dump(1);                                       \
 570       assert(false, name);                              \
 571       break;
 572 #else
 573 #define ELSE_FAIL(name) \
 574       break;
 575 #endif
 576 
 577 // Add final simple edges to graph.
 578 void ConnectionGraph::add_final_edges(Node *n) {
 579   PointsToNode* n_ptn = ptnode_adr(n-&gt;_idx);
 580 #ifdef ASSERT
 581   if (_verify &amp;&amp; n_ptn-&gt;is_JavaObject())
 582     return; // This method does not change graph for JavaObject.
 583 #endif
 584 
 585   if (n-&gt;is_Call()) {
 586     process_call_arguments(n-&gt;as_Call());
 587     return;
 588   }
 589   assert(n-&gt;is_Store() || n-&gt;is_LoadStore() ||
 590          (n_ptn != NULL) &amp;&amp; (n_ptn-&gt;ideal_node() != NULL),
 591          &quot;node should be registered already&quot;);
 592   int opcode = n-&gt;Opcode();
 593   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_add_final_edges(this, _igvn, n, opcode);
 594   if (gc_handled) {
 595     return; // Ignore node if already handled by GC.
 596   }
 597   switch (opcode) {
 598     case Op_AddP: {
 599       Node* base = get_addp_base(n);
 600       PointsToNode* ptn_base = ptnode_adr(base-&gt;_idx);
 601       assert(ptn_base != NULL, &quot;field&#39;s base should be registered&quot;);
 602       add_base(n_ptn-&gt;as_Field(), ptn_base);
 603       break;
 604     }
 605     case Op_CastPP:
 606     case Op_CheckCastPP:
 607     case Op_EncodeP:
 608     case Op_DecodeN:
 609     case Op_EncodePKlass:
 610     case Op_DecodeNKlass: {
 611       add_local_var_and_edge(n, PointsToNode::NoEscape,
 612                              n-&gt;in(1), NULL);
 613       break;
 614     }
 615     case Op_CMoveP: {
 616       for (uint i = CMoveNode::IfFalse; i &lt; n-&gt;req(); i++) {
 617         Node* in = n-&gt;in(i);
 618         if (in == NULL)
 619           continue;  // ignore NULL
 620         Node* uncast_in = in-&gt;uncast();
 621         if (uncast_in-&gt;is_top() || uncast_in == n)
 622           continue;  // ignore top or inputs which go back this node
 623         PointsToNode* ptn = ptnode_adr(in-&gt;_idx);
 624         assert(ptn != NULL, &quot;node should be registered&quot;);
 625         add_edge(n_ptn, ptn);
 626       }
 627       break;
 628     }
 629     case Op_LoadP:
 630     case Op_LoadN:
 631     case Op_LoadPLocked: {
 632       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 633       // ThreadLocal has RawPtr type.
 634       const Type* t = _igvn-&gt;type(n);
 635       if (t-&gt;make_ptr() != NULL) {
 636         Node* adr = n-&gt;in(MemNode::Address);
 637         add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
 638         break;
 639       }
 640       ELSE_FAIL(&quot;Op_LoadP&quot;);
 641     }
 642     case Op_Phi: {
 643       // Using isa_ptr() instead of isa_oopptr() for LoadP and Phi because
 644       // ThreadLocal has RawPtr type.
 645       const Type* t = n-&gt;as_Phi()-&gt;type();
 646       if (t-&gt;make_ptr() != NULL) {
 647         for (uint i = 1; i &lt; n-&gt;req(); i++) {
 648           Node* in = n-&gt;in(i);
 649           if (in == NULL)
 650             continue;  // ignore NULL
 651           Node* uncast_in = in-&gt;uncast();
 652           if (uncast_in-&gt;is_top() || uncast_in == n)
 653             continue;  // ignore top or inputs which go back this node
 654           PointsToNode* ptn = ptnode_adr(in-&gt;_idx);
 655           assert(ptn != NULL, &quot;node should be registered&quot;);
 656           add_edge(n_ptn, ptn);
 657         }
 658         break;
 659       }
 660       ELSE_FAIL(&quot;Op_Phi&quot;);
 661     }
 662     case Op_Proj: {
 663       // we are only interested in the oop result projection from a call
 664       if (n-&gt;as_Proj()-&gt;_con &gt;= TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;is_Call() &amp;&amp;
 665           (n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()|| n-&gt;bottom_type()-&gt;isa_ptr())) {
 666         assert((n-&gt;as_Proj()-&gt;_con == TypeFunc::Parms &amp;&amp; n-&gt;in(0)-&gt;as_Call()-&gt;returns_pointer()) ||
 667                n-&gt;in(0)-&gt;as_Call()-&gt;tf()-&gt;returns_value_type_as_fields(), &quot;what kind of oop return is it?&quot;);
 668         add_local_var_and_edge(n, PointsToNode::NoEscape, n-&gt;in(0), NULL);
 669         break;
 670       }
 671       ELSE_FAIL(&quot;Op_Proj&quot;);
 672     }
 673     case Op_Rethrow: // Exception object escapes
 674     case Op_Return: {
 675       if (n-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
 676           _igvn-&gt;type(n-&gt;in(TypeFunc::Parms))-&gt;isa_oopptr()) {
 677         // Treat Return value as LocalVar with GlobalEscape escape state.
 678         add_local_var_and_edge(n, PointsToNode::GlobalEscape,
 679                                n-&gt;in(TypeFunc::Parms), NULL);
 680         break;
 681       }
 682       ELSE_FAIL(&quot;Op_Return&quot;);
 683     }
 684     case Op_StoreP:
 685     case Op_StoreN:
 686     case Op_StoreNKlass:
 687     case Op_StorePConditional:
 688     case Op_CompareAndExchangeP:
 689     case Op_CompareAndExchangeN:
 690     case Op_CompareAndSwapP:
 691     case Op_CompareAndSwapN:
 692     case Op_WeakCompareAndSwapP:
 693     case Op_WeakCompareAndSwapN:
 694     case Op_GetAndSetP:
 695     case Op_GetAndSetN: {
 696       if (add_final_edges_unsafe_access(n, opcode)) {
 697         break;
 698       }
 699       ELSE_FAIL(&quot;Op_StoreP&quot;);
 700     }
 701     case Op_AryEq:
 702     case Op_HasNegatives:
 703     case Op_StrComp:
 704     case Op_StrEquals:
 705     case Op_StrIndexOf:
 706     case Op_StrIndexOfChar:
 707     case Op_StrInflatedCopy:
 708     case Op_StrCompressedCopy:
 709     case Op_EncodeISOArray: {
 710       // char[]/byte[] arrays passed to string intrinsic do not escape but
 711       // they are not scalar replaceable. Adjust escape state for them.
 712       // Start from in(2) edge since in(1) is memory edge.
 713       for (uint i = 2; i &lt; n-&gt;req(); i++) {
 714         Node* adr = n-&gt;in(i);
 715         const Type* at = _igvn-&gt;type(adr);
 716         if (!adr-&gt;is_top() &amp;&amp; at-&gt;isa_ptr()) {
 717           assert(at == Type::TOP || at == TypePtr::NULL_PTR ||
 718                  at-&gt;isa_ptr() != NULL, &quot;expecting a pointer&quot;);
 719           if (adr-&gt;is_AddP()) {
 720             adr = get_addp_base(adr);
 721           }
 722           PointsToNode* ptn = ptnode_adr(adr-&gt;_idx);
 723           assert(ptn != NULL, &quot;node should be registered&quot;);
 724           add_edge(n_ptn, ptn);
 725         }
 726       }
 727       break;
 728     }
 729     default: {
 730       // This method should be called only for EA specific nodes which may
 731       // miss some edges when they were created.
 732 #ifdef ASSERT
 733       n-&gt;dump(1);
 734 #endif
 735       guarantee(false, &quot;unknown node&quot;);
 736     }
 737   }
 738   return;
 739 }
 740 
 741 void ConnectionGraph::add_to_congraph_unsafe_access(Node* n, uint opcode, Unique_Node_List* delayed_worklist) {
 742   Node* adr = n-&gt;in(MemNode::Address);
 743   const Type* adr_type = _igvn-&gt;type(adr);
 744   adr_type = adr_type-&gt;make_ptr();
 745   if (adr_type == NULL) {
 746     return; // skip dead nodes
 747   }
 748   if (adr_type-&gt;isa_oopptr()
 749       || ((opcode == Op_StoreP || opcode == Op_StoreN || opcode == Op_StoreNKlass)
 750           &amp;&amp; adr_type == TypeRawPtr::NOTNULL
 751           &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;is_Proj()
 752           &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate())) {
 753     delayed_worklist-&gt;push(n); // Process it later.
 754 #ifdef ASSERT
 755     assert (adr-&gt;is_AddP(), &quot;expecting an AddP&quot;);
 756     if (adr_type == TypeRawPtr::NOTNULL) {
 757       // Verify a raw address for a store captured by Initialize node.
 758       int offs = (int) _igvn-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
 759       assert(offs != Type::OffsetBot, &quot;offset must be a constant&quot;);
 760     }
 761 #endif
 762   } else {
 763     // Ignore copy the displaced header to the BoxNode (OSR compilation).
 764     if (adr-&gt;is_BoxLock()) {
 765       return;
 766     }
 767     // Stored value escapes in unsafe access.
 768     if ((opcode == Op_StoreP) &amp;&amp; adr_type-&gt;isa_rawptr()) {
 769       delayed_worklist-&gt;push(n); // Process unsafe access later.
 770       return;
 771     }
 772 #ifdef ASSERT
 773     n-&gt;dump(1);
 774     assert(false, &quot;not unsafe&quot;);
 775 #endif
 776   }
 777 }
 778 
 779 bool ConnectionGraph::add_final_edges_unsafe_access(Node* n, uint opcode) {
 780   Node* adr = n-&gt;in(MemNode::Address);
 781   const Type *adr_type = _igvn-&gt;type(adr);
 782   adr_type = adr_type-&gt;make_ptr();
 783 #ifdef ASSERT
 784   if (adr_type == NULL) {
 785     n-&gt;dump(1);
 786     assert(adr_type != NULL, &quot;dead node should not be on list&quot;);
 787     return true;
 788   }
 789 #endif
 790 
 791   if (opcode == Op_GetAndSetP || opcode == Op_GetAndSetN ||
 792       opcode == Op_CompareAndExchangeN || opcode == Op_CompareAndExchangeP) {
 793     add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);
 794   }
 795 
 796   if (adr_type-&gt;isa_oopptr()
 797       || ((opcode == Op_StoreP || opcode == Op_StoreN || opcode == Op_StoreNKlass)
 798            &amp;&amp; adr_type == TypeRawPtr::NOTNULL
 799            &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;is_Proj()
 800            &amp;&amp; adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate())) {
 801     // Point Address to Value
 802     PointsToNode* adr_ptn = ptnode_adr(adr-&gt;_idx);
 803     assert(adr_ptn != NULL &amp;&amp;
 804            adr_ptn-&gt;as_Field()-&gt;is_oop(), &quot;node should be registered&quot;);
 805     Node* val = n-&gt;in(MemNode::ValueIn);
 806     PointsToNode* ptn = ptnode_adr(val-&gt;_idx);
 807     assert(ptn != NULL, &quot;node should be registered&quot;);
 808     add_edge(adr_ptn, ptn);
 809     return true;
 810   } else if ((opcode == Op_StoreP) &amp;&amp; adr_type-&gt;isa_rawptr()) {
 811     // Stored value escapes in unsafe access.
 812     Node* val = n-&gt;in(MemNode::ValueIn);
 813     PointsToNode* ptn = ptnode_adr(val-&gt;_idx);
 814     assert(ptn != NULL, &quot;node should be registered&quot;);
 815     set_escape_state(ptn, PointsToNode::GlobalEscape);
 816     // Add edge to object for unsafe access with offset.
 817     PointsToNode* adr_ptn = ptnode_adr(adr-&gt;_idx);
 818     assert(adr_ptn != NULL, &quot;node should be registered&quot;);
 819     if (adr_ptn-&gt;is_Field()) {
 820       assert(adr_ptn-&gt;as_Field()-&gt;is_oop(), &quot;should be oop field&quot;);
 821       add_edge(adr_ptn, ptn);
 822     }
 823     return true;
 824   }
 825   return false;
 826 }
 827 
 828 void ConnectionGraph::add_call_node(CallNode* call) {
 829   assert(call-&gt;returns_pointer() || call-&gt;tf()-&gt;returns_value_type_as_fields(), &quot;only for call which returns pointer&quot;);
 830   uint call_idx = call-&gt;_idx;
 831   if (call-&gt;is_Allocate()) {
 832     Node* k = call-&gt;in(AllocateNode::KlassNode);
 833     const TypeKlassPtr* kt = k-&gt;bottom_type()-&gt;isa_klassptr();
 834     assert(kt != NULL, &quot;TypeKlassPtr  required.&quot;);
 835     ciKlass* cik = kt-&gt;klass();
 836     PointsToNode::EscapeState es = PointsToNode::NoEscape;
 837     bool scalar_replaceable = true;
 838     if (call-&gt;is_AllocateArray()) {
 839       if (!cik-&gt;is_array_klass()) { // StressReflectiveCode
 840         es = PointsToNode::GlobalEscape;
 841       } else {
 842         int length = call-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 843         if (length &lt; 0 || length &gt; EliminateAllocationArraySizeLimit) {
 844           // Not scalar replaceable if the length is not constant or too big.
 845           scalar_replaceable = false;
 846         }
 847       }
 848     } else {  // Allocate instance
 849       if (cik-&gt;is_subclass_of(_compile-&gt;env()-&gt;Thread_klass()) ||
 850           cik-&gt;is_subclass_of(_compile-&gt;env()-&gt;Reference_klass()) ||
 851          !cik-&gt;is_instance_klass() || // StressReflectiveCode
 852          !cik-&gt;as_instance_klass()-&gt;can_be_instantiated() ||
 853           cik-&gt;as_instance_klass()-&gt;has_finalizer()) {
 854         es = PointsToNode::GlobalEscape;
 855       }
 856     }
 857     add_java_object(call, es);
 858     PointsToNode* ptn = ptnode_adr(call_idx);
 859     if (!scalar_replaceable &amp;&amp; ptn-&gt;scalar_replaceable()) {
 860       ptn-&gt;set_scalar_replaceable(false);
 861     }
 862   } else if (call-&gt;is_CallStaticJava()) {
 863     // Call nodes could be different types:
 864     //
 865     // 1. CallDynamicJavaNode (what happened during call is unknown):
 866     //
 867     //    - mapped to GlobalEscape JavaObject node if oop is returned;
 868     //
 869     //    - all oop arguments are escaping globally;
 870     //
 871     // 2. CallStaticJavaNode (execute bytecode analysis if possible):
 872     //
 873     //    - the same as CallDynamicJavaNode if can&#39;t do bytecode analysis;
 874     //
 875     //    - mapped to GlobalEscape JavaObject node if unknown oop is returned;
 876     //    - mapped to NoEscape JavaObject node if non-escaping object allocated
 877     //      during call is returned;
 878     //    - mapped to ArgEscape LocalVar node pointed to object arguments
 879     //      which are returned and does not escape during call;
 880     //
 881     //    - oop arguments escaping status is defined by bytecode analysis;
 882     //
 883     // For a static call, we know exactly what method is being called.
 884     // Use bytecode estimator to record whether the call&#39;s return value escapes.
 885     ciMethod* meth = call-&gt;as_CallJava()-&gt;method();
 886     if (meth == NULL) {
 887       const char* name = call-&gt;as_CallStaticJava()-&gt;_name;
 888       assert(strncmp(name, &quot;_multianewarray&quot;, 15) == 0, &quot;TODO: add failed case check&quot;);
 889       // Returns a newly allocated unescaped object.
 890       add_java_object(call, PointsToNode::NoEscape);
 891       ptnode_adr(call_idx)-&gt;set_scalar_replaceable(false);
 892     } else if (meth-&gt;is_boxing_method()) {
 893       // Returns boxing object
 894       PointsToNode::EscapeState es;
 895       vmIntrinsics::ID intr = meth-&gt;intrinsic_id();
 896       if (intr == vmIntrinsics::_floatValue || intr == vmIntrinsics::_doubleValue) {
 897         // It does not escape if object is always allocated.
 898         es = PointsToNode::NoEscape;
 899       } else {
 900         // It escapes globally if object could be loaded from cache.
 901         es = PointsToNode::GlobalEscape;
 902       }
 903       add_java_object(call, es);
 904     } else {
 905       BCEscapeAnalyzer* call_analyzer = meth-&gt;get_bcea();
 906       call_analyzer-&gt;copy_dependencies(_compile-&gt;dependencies());
 907       if (call_analyzer-&gt;is_return_allocated()) {
 908         // Returns a newly allocated unescaped object, simply
 909         // update dependency information.
 910         // Mark it as NoEscape so that objects referenced by
 911         // it&#39;s fields will be marked as NoEscape at least.
 912         add_java_object(call, PointsToNode::NoEscape);
 913         ptnode_adr(call_idx)-&gt;set_scalar_replaceable(false);
 914       } else {
 915         // Determine whether any arguments are returned.
 916         const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
 917         bool ret_arg = false;
 918         for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 919           if (d-&gt;field_at(i)-&gt;isa_ptr() != NULL &amp;&amp;
 920               call_analyzer-&gt;is_arg_returned(i - TypeFunc::Parms)) {
 921             ret_arg = true;
 922             break;
 923           }
 924         }
 925         if (ret_arg) {
 926           add_local_var(call, PointsToNode::ArgEscape);
 927         } else {
 928           // Returns unknown object.
 929           map_ideal_node(call, phantom_obj);
 930         }
 931       }
 932     }
 933   } else {
 934     // An other type of call, assume the worst case:
 935     // returned value is unknown and globally escapes.
 936     assert(call-&gt;Opcode() == Op_CallDynamicJava, &quot;add failed case check&quot;);
 937     map_ideal_node(call, phantom_obj);
 938   }
 939 }
 940 
 941 void ConnectionGraph::process_call_arguments(CallNode *call) {
 942     bool is_arraycopy = false;
 943     switch (call-&gt;Opcode()) {
 944 #ifdef ASSERT
 945     case Op_Allocate:
 946     case Op_AllocateArray:
 947     case Op_Lock:
 948     case Op_Unlock:
 949       assert(false, &quot;should be done already&quot;);
 950       break;
 951 #endif
 952     case Op_ArrayCopy:
 953     case Op_CallLeafNoFP:
 954       // Most array copies are ArrayCopy nodes at this point but there
 955       // are still a few direct calls to the copy subroutines (See
 956       // PhaseStringOpts::copy_string())
 957       is_arraycopy = (call-&gt;Opcode() == Op_ArrayCopy) ||
 958         call-&gt;as_CallLeaf()-&gt;is_call_to_arraycopystub();
 959       // fall through
 960     case Op_CallLeaf: {
 961       // Stub calls, objects do not escape but they are not scale replaceable.
 962       // Adjust escape state for outgoing arguments.
 963       const TypeTuple * d = call-&gt;tf()-&gt;domain_sig();
 964       bool src_has_oops = false;
 965       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 966         const Type* at = d-&gt;field_at(i);
 967         Node *arg = call-&gt;in(i);
 968         if (arg == NULL) {
 969           continue;
 970         }
 971         const Type *aat = _igvn-&gt;type(arg);
 972         if (arg-&gt;is_top() || !at-&gt;isa_ptr() || !aat-&gt;isa_ptr())
 973           continue;
 974         if (arg-&gt;is_AddP()) {
 975           //
 976           // The inline_native_clone() case when the arraycopy stub is called
 977           // after the allocation before Initialize and CheckCastPP nodes.
 978           // Or normal arraycopy for object arrays case.
 979           //
 980           // Set AddP&#39;s base (Allocate) as not scalar replaceable since
 981           // pointer to the base (with offset) is passed as argument.
 982           //
 983           arg = get_addp_base(arg);
 984         }
 985         PointsToNode* arg_ptn = ptnode_adr(arg-&gt;_idx);
 986         assert(arg_ptn != NULL, &quot;should be registered&quot;);
 987         PointsToNode::EscapeState arg_esc = arg_ptn-&gt;escape_state();
 988         if (is_arraycopy || arg_esc &lt; PointsToNode::ArgEscape) {
 989           assert(aat == Type::TOP || aat == TypePtr::NULL_PTR ||
 990                  aat-&gt;isa_ptr() != NULL, &quot;expecting an Ptr&quot;);
 991           bool arg_has_oops = aat-&gt;isa_oopptr() &amp;&amp;
 992                               (aat-&gt;isa_oopptr()-&gt;klass() == NULL || aat-&gt;isa_instptr() ||
 993                                (aat-&gt;isa_aryptr() &amp;&amp; aat-&gt;isa_aryptr()-&gt;klass()-&gt;is_obj_array_klass()) ||
 994                                (aat-&gt;isa_aryptr() &amp;&amp; aat-&gt;isa_aryptr()-&gt;elem() != NULL &amp;&amp;
 995                                 aat-&gt;isa_aryptr()-&gt;elem()-&gt;isa_valuetype() &amp;&amp;
 996                                 aat-&gt;isa_aryptr()-&gt;elem()-&gt;value_klass()-&gt;contains_oops()));
 997           if (i == TypeFunc::Parms) {
 998             src_has_oops = arg_has_oops;
 999           }
1000           //
1001           // src or dst could be j.l.Object when other is basic type array:
1002           //
1003           //   arraycopy(char[],0,Object*,0,size);
1004           //   arraycopy(Object*,0,char[],0,size);
1005           //
1006           // Don&#39;t add edges in such cases.
1007           //
1008           bool arg_is_arraycopy_dest = src_has_oops &amp;&amp; is_arraycopy &amp;&amp;
1009                                        arg_has_oops &amp;&amp; (i &gt; TypeFunc::Parms);
1010 #ifdef ASSERT
1011           if (!(is_arraycopy ||
1012                 BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(call) ||
1013                 (call-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
1014                  (strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesCRC32&quot;) == 0 ||
1015                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesCRC32C&quot;) == 0 ||
1016                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;updateBytesAdler32&quot;) == 0 ||
1017                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_encryptBlock&quot;) == 0 ||
1018                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;aescrypt_decryptBlock&quot;) == 0 ||
1019                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_encryptAESCrypt&quot;) == 0 ||
1020                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;cipherBlockChaining_decryptAESCrypt&quot;) == 0 ||
1021                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_encryptAESCrypt&quot;) == 0 ||
1022                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;electronicCodeBook_decryptAESCrypt&quot;) == 0 ||
1023                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;counterMode_AESCrypt&quot;) == 0 ||
1024                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;ghash_processBlocks&quot;) == 0 ||
1025                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;encodeBlock&quot;) == 0 ||
1026                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompress&quot;) == 0 ||
1027                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha1_implCompressMB&quot;) == 0 ||
1028                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha256_implCompress&quot;) == 0 ||
1029                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha256_implCompressMB&quot;) == 0 ||
1030                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha512_implCompress&quot;) == 0 ||
1031                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;sha512_implCompressMB&quot;) == 0 ||
1032                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;multiplyToLen&quot;) == 0 ||
1033                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;squareToLen&quot;) == 0 ||
1034                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;mulAdd&quot;) == 0 ||
1035                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_multiply&quot;) == 0 ||
1036                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;montgomery_square&quot;) == 0 ||
1037                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;vectorizedMismatch&quot;) == 0 ||
1038                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;load_unknown_value&quot;) == 0 ||
1039                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_value&quot;) == 0 ||
1040                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerRightShiftWorker&quot;) == 0 ||
1041                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;bigIntegerLeftShiftWorker&quot;) == 0 ||
1042                   strcmp(call-&gt;as_CallLeaf()-&gt;_name, &quot;vectorizedMismatch&quot;) == 0)
1043                  ))) {
1044             call-&gt;dump();
1045             fatal(&quot;EA unexpected CallLeaf %s&quot;, call-&gt;as_CallLeaf()-&gt;_name);
1046           }
1047 #endif
1048           // Always process arraycopy&#39;s destination object since
1049           // we need to add all possible edges to references in
1050           // source object.
1051           if (arg_esc &gt;= PointsToNode::ArgEscape &amp;&amp;
1052               !arg_is_arraycopy_dest) {
1053             continue;
1054           }
1055           PointsToNode::EscapeState es = PointsToNode::ArgEscape;
1056           if (call-&gt;is_ArrayCopy()) {
1057             ArrayCopyNode* ac = call-&gt;as_ArrayCopy();
1058             if (ac-&gt;is_clonebasic() ||
1059                 ac-&gt;is_arraycopy_validated() ||
1060                 ac-&gt;is_copyof_validated() ||
1061                 ac-&gt;is_copyofrange_validated()) {
1062               es = PointsToNode::NoEscape;
1063             }
1064           }
1065           set_escape_state(arg_ptn, es);
1066           if (arg_is_arraycopy_dest) {
1067             Node* src = call-&gt;in(TypeFunc::Parms);
1068             if (src-&gt;is_AddP()) {
1069               src = get_addp_base(src);
1070             }
1071             PointsToNode* src_ptn = ptnode_adr(src-&gt;_idx);
1072             assert(src_ptn != NULL, &quot;should be registered&quot;);
1073             if (arg_ptn != src_ptn) {
1074               // Special arraycopy edge:
1075               // A destination object&#39;s field can&#39;t have the source object
1076               // as base since objects escape states are not related.
1077               // Only escape state of destination object&#39;s fields affects
1078               // escape state of fields in source object.
1079               add_arraycopy(call, es, src_ptn, arg_ptn);
1080             }
1081           }
1082         }
1083       }
1084       break;
1085     }
1086     case Op_CallStaticJava: {
1087       // For a static call, we know exactly what method is being called.
1088       // Use bytecode estimator to record the call&#39;s escape affects
1089 #ifdef ASSERT
1090       const char* name = call-&gt;as_CallStaticJava()-&gt;_name;
1091       assert((name == NULL || strcmp(name, &quot;uncommon_trap&quot;) != 0), &quot;normal calls only&quot;);
1092 #endif
1093       ciMethod* meth = call-&gt;as_CallJava()-&gt;method();
1094       if ((meth != NULL) &amp;&amp; meth-&gt;is_boxing_method()) {
1095         break; // Boxing methods do not modify any oops.
1096       }
1097       BCEscapeAnalyzer* call_analyzer = (meth !=NULL) ? meth-&gt;get_bcea() : NULL;
1098       // fall-through if not a Java method or no analyzer information
1099       if (call_analyzer != NULL) {
1100         PointsToNode* call_ptn = ptnode_adr(call-&gt;_idx);
1101         const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
1102         for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
1103           const Type* at = d-&gt;field_at(i);
1104           int k = i - TypeFunc::Parms;
1105           Node* arg = call-&gt;in(i);
1106           PointsToNode* arg_ptn = ptnode_adr(arg-&gt;_idx);
1107           if (at-&gt;isa_ptr() != NULL &amp;&amp;
1108               call_analyzer-&gt;is_arg_returned(k)) {
1109             // The call returns arguments.
1110             if (call_ptn != NULL) { // Is call&#39;s result used?
1111               assert(call_ptn-&gt;is_LocalVar(), &quot;node should be registered&quot;);
1112               assert(arg_ptn != NULL, &quot;node should be registered&quot;);
1113               add_edge(call_ptn, arg_ptn);
1114             }
1115           }
1116           if (at-&gt;isa_oopptr() != NULL &amp;&amp;
1117               arg_ptn-&gt;escape_state() &lt; PointsToNode::GlobalEscape) {
1118             if (!call_analyzer-&gt;is_arg_stack(k)) {
1119               // The argument global escapes
1120               set_escape_state(arg_ptn, PointsToNode::GlobalEscape);
1121             } else {
1122               set_escape_state(arg_ptn, PointsToNode::ArgEscape);
1123               if (!call_analyzer-&gt;is_arg_local(k)) {
1124                 // The argument itself doesn&#39;t escape, but any fields might
1125                 set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);
1126               }
1127             }
1128           }
1129         }
1130         if (call_ptn != NULL &amp;&amp; call_ptn-&gt;is_LocalVar()) {
1131           // The call returns arguments.
1132           assert(call_ptn-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
1133           if (!call_analyzer-&gt;is_return_local()) {
1134             // Returns also unknown object.
1135             add_edge(call_ptn, phantom_obj);
1136           }
1137         }
1138         break;
1139       }
1140     }
1141     default: {
1142       // Fall-through here if not a Java method or no analyzer information
1143       // or some other type of call, assume the worst case: all arguments
1144       // globally escape.
1145       const TypeTuple* d = call-&gt;tf()-&gt;domain_cc();
1146       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
1147         const Type* at = d-&gt;field_at(i);
1148         if (at-&gt;isa_oopptr() != NULL) {
1149           Node* arg = call-&gt;in(i);
1150           if (arg-&gt;is_AddP()) {
1151             arg = get_addp_base(arg);
1152           }
1153           assert(ptnode_adr(arg-&gt;_idx) != NULL, &quot;should be defined already&quot;);
1154           set_escape_state(ptnode_adr(arg-&gt;_idx), PointsToNode::GlobalEscape);
1155         }
1156       }
1157     }
1158   }
1159 }
1160 
1161 
1162 // Finish Graph construction.
1163 bool ConnectionGraph::complete_connection_graph(
1164                          GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
1165                          GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
1166                          GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
1167                          GrowableArray&lt;FieldNode*&gt;&amp;      oop_fields_worklist) {
1168   // Normally only 1-3 passes needed to build Connection Graph depending
1169   // on graph complexity. Observed 8 passes in jvm2008 compiler.compiler.
1170   // Set limit to 20 to catch situation when something did go wrong and
1171   // bailout Escape Analysis.
1172   // Also limit build time to 20 sec (60 in debug VM), EscapeAnalysisTimeout flag.
1173 #define CG_BUILD_ITER_LIMIT 20
1174 
1175   // Propagate GlobalEscape and ArgEscape escape states and check that
1176   // we still have non-escaping objects. The method pushs on _worklist
1177   // Field nodes which reference phantom_object.
1178   if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {
1179     return false; // Nothing to do.
1180   }
1181   // Now propagate references to all JavaObject nodes.
1182   int java_objects_length = java_objects_worklist.length();
1183   elapsedTimer time;
1184   bool timeout = false;
1185   int new_edges = 1;
1186   int iterations = 0;
1187   do {
1188     while ((new_edges &gt; 0) &amp;&amp;
1189            (iterations++ &lt; CG_BUILD_ITER_LIMIT)) {
1190       double start_time = time.seconds();
1191       time.start();
1192       new_edges = 0;
1193       // Propagate references to phantom_object for nodes pushed on _worklist
1194       // by find_non_escaped_objects() and find_field_value().
1195       new_edges += add_java_object_edges(phantom_obj, false);
1196       for (int next = 0; next &lt; java_objects_length; ++next) {
1197         JavaObjectNode* ptn = java_objects_worklist.at(next);
1198         new_edges += add_java_object_edges(ptn, true);
1199 
1200 #define SAMPLE_SIZE 4
1201         if ((next % SAMPLE_SIZE) == 0) {
1202           // Each 4 iterations calculate how much time it will take
1203           // to complete graph construction.
1204           time.stop();
1205           // Poll for requests from shutdown mechanism to quiesce compiler
1206           // because Connection graph construction may take long time.
1207           CompileBroker::maybe_block();
1208           double stop_time = time.seconds();
1209           double time_per_iter = (stop_time - start_time) / (double)SAMPLE_SIZE;
1210           double time_until_end = time_per_iter * (double)(java_objects_length - next);
1211           if ((start_time + time_until_end) &gt;= EscapeAnalysisTimeout) {
1212             timeout = true;
1213             break; // Timeout
1214           }
1215           start_time = stop_time;
1216           time.start();
1217         }
1218 #undef SAMPLE_SIZE
1219 
1220       }
1221       if (timeout) break;
1222       if (new_edges &gt; 0) {
1223         // Update escape states on each iteration if graph was updated.
1224         if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {
1225           return false; // Nothing to do.
1226         }
1227       }
1228       time.stop();
1229       if (time.seconds() &gt;= EscapeAnalysisTimeout) {
1230         timeout = true;
1231         break;
1232       }
1233     }
1234     if ((iterations &lt; CG_BUILD_ITER_LIMIT) &amp;&amp; !timeout) {
1235       time.start();
1236       // Find fields which have unknown value.
1237       int fields_length = oop_fields_worklist.length();
1238       for (int next = 0; next &lt; fields_length; next++) {
1239         FieldNode* field = oop_fields_worklist.at(next);
1240         if (field-&gt;edge_count() == 0) {
1241           new_edges += find_field_value(field);
1242           // This code may added new edges to phantom_object.
1243           // Need an other cycle to propagate references to phantom_object.
1244         }
1245       }
1246       time.stop();
1247       if (time.seconds() &gt;= EscapeAnalysisTimeout) {
1248         timeout = true;
1249         break;
1250       }
1251     } else {
1252       new_edges = 0; // Bailout
1253     }
1254   } while (new_edges &gt; 0);
1255 
1256   // Bailout if passed limits.
1257   if ((iterations &gt;= CG_BUILD_ITER_LIMIT) || timeout) {
1258     Compile* C = _compile;
1259     if (C-&gt;log() != NULL) {
1260       C-&gt;log()-&gt;begin_elem(&quot;connectionGraph_bailout reason=&#39;reached &quot;);
1261       C-&gt;log()-&gt;text(&quot;%s&quot;, timeout ? &quot;time&quot; : &quot;iterations&quot;);
1262       C-&gt;log()-&gt;end_elem(&quot; limit&#39;&quot;);
1263     }
1264     assert(ExitEscapeAnalysisOnTimeout, &quot;infinite EA connection graph build (%f sec, %d iterations) with %d nodes and worklist size %d&quot;,
1265            time.seconds(), iterations, nodes_size(), ptnodes_worklist.length());
1266     // Possible infinite build_connection_graph loop,
1267     // bailout (no changes to ideal graph were made).
1268     return false;
1269   }
1270 #ifdef ASSERT
1271   if (Verbose &amp;&amp; PrintEscapeAnalysis) {
1272     tty-&gt;print_cr(&quot;EA: %d iterations to build connection graph with %d nodes and worklist size %d&quot;,
1273                   iterations, nodes_size(), ptnodes_worklist.length());
1274   }
1275 #endif
1276 
1277 #undef CG_BUILD_ITER_LIMIT
1278 
1279   // Find fields initialized by NULL for non-escaping Allocations.
1280   int non_escaped_length = non_escaped_worklist.length();
1281   for (int next = 0; next &lt; non_escaped_length; next++) {
1282     JavaObjectNode* ptn = non_escaped_worklist.at(next);
1283     PointsToNode::EscapeState es = ptn-&gt;escape_state();
1284     assert(es &lt;= PointsToNode::ArgEscape, &quot;sanity&quot;);
1285     if (es == PointsToNode::NoEscape) {
1286       if (find_init_values(ptn, null_obj, _igvn) &gt; 0) {
1287         // Adding references to NULL object does not change escape states
1288         // since it does not escape. Also no fields are added to NULL object.
1289         add_java_object_edges(null_obj, false);
1290       }
1291     }
1292     Node* n = ptn-&gt;ideal_node();
1293     if (n-&gt;is_Allocate()) {
1294       // The object allocated by this Allocate node will never be
1295       // seen by an other thread. Mark it so that when it is
1296       // expanded no MemBarStoreStore is added.
1297       InitializeNode* ini = n-&gt;as_Allocate()-&gt;initialization();
1298       if (ini != NULL)
1299         ini-&gt;set_does_not_escape();
1300     }
1301   }
1302   return true; // Finished graph construction.
1303 }
1304 
1305 // Propagate GlobalEscape and ArgEscape escape states to all nodes
1306 // and check that we still have non-escaping java objects.
1307 bool ConnectionGraph::find_non_escaped_objects(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist,
1308                                                GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist) {
1309   GrowableArray&lt;PointsToNode*&gt; escape_worklist;
1310   // First, put all nodes with GlobalEscape and ArgEscape states on worklist.
1311   int ptnodes_length = ptnodes_worklist.length();
1312   for (int next = 0; next &lt; ptnodes_length; ++next) {
1313     PointsToNode* ptn = ptnodes_worklist.at(next);
1314     if (ptn-&gt;escape_state() &gt;= PointsToNode::ArgEscape ||
1315         ptn-&gt;fields_escape_state() &gt;= PointsToNode::ArgEscape) {
1316       escape_worklist.push(ptn);
1317     }
1318   }
1319   // Set escape states to referenced nodes (edges list).
1320   while (escape_worklist.length() &gt; 0) {
1321     PointsToNode* ptn = escape_worklist.pop();
1322     PointsToNode::EscapeState es  = ptn-&gt;escape_state();
1323     PointsToNode::EscapeState field_es = ptn-&gt;fields_escape_state();
1324     if (ptn-&gt;is_Field() &amp;&amp; ptn-&gt;as_Field()-&gt;is_oop() &amp;&amp;
1325         es &gt;= PointsToNode::ArgEscape) {
1326       // GlobalEscape or ArgEscape state of field means it has unknown value.
1327       if (add_edge(ptn, phantom_obj)) {
1328         // New edge was added
1329         add_field_uses_to_worklist(ptn-&gt;as_Field());
1330       }
1331     }
1332     for (EdgeIterator i(ptn); i.has_next(); i.next()) {
1333       PointsToNode* e = i.get();
1334       if (e-&gt;is_Arraycopy()) {
1335         assert(ptn-&gt;arraycopy_dst(), &quot;sanity&quot;);
1336         // Propagate only fields escape state through arraycopy edge.
1337         if (e-&gt;fields_escape_state() &lt; field_es) {
1338           set_fields_escape_state(e, field_es);
1339           escape_worklist.push(e);
1340         }
1341       } else if (es &gt;= field_es) {
1342         // fields_escape_state is also set to &#39;es&#39; if it is less than &#39;es&#39;.
1343         if (e-&gt;escape_state() &lt; es) {
1344           set_escape_state(e, es);
1345           escape_worklist.push(e);
1346         }
1347       } else {
1348         // Propagate field escape state.
1349         bool es_changed = false;
1350         if (e-&gt;fields_escape_state() &lt; field_es) {
1351           set_fields_escape_state(e, field_es);
1352           es_changed = true;
1353         }
1354         if ((e-&gt;escape_state() &lt; field_es) &amp;&amp;
1355             e-&gt;is_Field() &amp;&amp; ptn-&gt;is_JavaObject() &amp;&amp;
1356             e-&gt;as_Field()-&gt;is_oop()) {
1357           // Change escape state of referenced fields.
1358           set_escape_state(e, field_es);
1359           es_changed = true;
1360         } else if (e-&gt;escape_state() &lt; es) {
1361           set_escape_state(e, es);
1362           es_changed = true;
1363         }
1364         if (es_changed) {
1365           escape_worklist.push(e);
1366         }
1367       }
1368     }
1369   }
1370   // Remove escaped objects from non_escaped list.
1371   for (int next = non_escaped_worklist.length()-1; next &gt;= 0 ; --next) {
1372     JavaObjectNode* ptn = non_escaped_worklist.at(next);
1373     if (ptn-&gt;escape_state() &gt;= PointsToNode::GlobalEscape) {
1374       non_escaped_worklist.delete_at(next);
1375     }
1376     if (ptn-&gt;escape_state() == PointsToNode::NoEscape) {
1377       // Find fields in non-escaped allocations which have unknown value.
1378       find_init_values(ptn, phantom_obj, NULL);
1379     }
1380   }
1381   return (non_escaped_worklist.length() &gt; 0);
1382 }
1383 
1384 // Add all references to JavaObject node by walking over all uses.
1385 int ConnectionGraph::add_java_object_edges(JavaObjectNode* jobj, bool populate_worklist) {
1386   int new_edges = 0;
1387   if (populate_worklist) {
1388     // Populate _worklist by uses of jobj&#39;s uses.
1389     for (UseIterator i(jobj); i.has_next(); i.next()) {
1390       PointsToNode* use = i.get();
1391       if (use-&gt;is_Arraycopy())
1392         continue;
1393       add_uses_to_worklist(use);
1394       if (use-&gt;is_Field() &amp;&amp; use-&gt;as_Field()-&gt;is_oop()) {
1395         // Put on worklist all field&#39;s uses (loads) and
1396         // related field nodes (same base and offset).
1397         add_field_uses_to_worklist(use-&gt;as_Field());
1398       }
1399     }
1400   }
1401   for (int l = 0; l &lt; _worklist.length(); l++) {
1402     PointsToNode* use = _worklist.at(l);
1403     if (PointsToNode::is_base_use(use)) {
1404       // Add reference from jobj to field and from field to jobj (field&#39;s base).
1405       use = PointsToNode::get_use_node(use)-&gt;as_Field();
1406       if (add_base(use-&gt;as_Field(), jobj)) {
1407         new_edges++;
1408       }
1409       continue;
1410     }
1411     assert(!use-&gt;is_JavaObject(), &quot;sanity&quot;);
1412     if (use-&gt;is_Arraycopy()) {
1413       if (jobj == null_obj) // NULL object does not have field edges
1414         continue;
1415       // Added edge from Arraycopy node to arraycopy&#39;s source java object
1416       if (add_edge(use, jobj)) {
1417         jobj-&gt;set_arraycopy_src();
1418         new_edges++;
1419       }
1420       // and stop here.
1421       continue;
1422     }
1423     if (!add_edge(use, jobj))
1424       continue; // No new edge added, there was such edge already.
1425     new_edges++;
1426     if (use-&gt;is_LocalVar()) {
1427       add_uses_to_worklist(use);
1428       if (use-&gt;arraycopy_dst()) {
1429         for (EdgeIterator i(use); i.has_next(); i.next()) {
1430           PointsToNode* e = i.get();
1431           if (e-&gt;is_Arraycopy()) {
1432             if (jobj == null_obj) // NULL object does not have field edges
1433               continue;
1434             // Add edge from arraycopy&#39;s destination java object to Arraycopy node.
1435             if (add_edge(jobj, e)) {
1436               new_edges++;
1437               jobj-&gt;set_arraycopy_dst();
1438             }
1439           }
1440         }
1441       }
1442     } else {
1443       // Added new edge to stored in field values.
1444       // Put on worklist all field&#39;s uses (loads) and
1445       // related field nodes (same base and offset).
1446       add_field_uses_to_worklist(use-&gt;as_Field());
1447     }
1448   }
1449   _worklist.clear();
1450   _in_worklist.reset();
1451   return new_edges;
1452 }
1453 
1454 // Put on worklist all related field nodes.
1455 void ConnectionGraph::add_field_uses_to_worklist(FieldNode* field) {
1456   assert(field-&gt;is_oop(), &quot;sanity&quot;);
1457   int offset = field-&gt;offset();
1458   add_uses_to_worklist(field);
1459   // Loop over all bases of this field and push on worklist Field nodes
1460   // with the same offset and base (since they may reference the same field).
1461   for (BaseIterator i(field); i.has_next(); i.next()) {
1462     PointsToNode* base = i.get();
1463     add_fields_to_worklist(field, base);
1464     // Check if the base was source object of arraycopy and go over arraycopy&#39;s
1465     // destination objects since values stored to a field of source object are
1466     // accessable by uses (loads) of fields of destination objects.
1467     if (base-&gt;arraycopy_src()) {
1468       for (UseIterator j(base); j.has_next(); j.next()) {
1469         PointsToNode* arycp = j.get();
1470         if (arycp-&gt;is_Arraycopy()) {
1471           for (UseIterator k(arycp); k.has_next(); k.next()) {
1472             PointsToNode* abase = k.get();
1473             if (abase-&gt;arraycopy_dst() &amp;&amp; abase != base) {
1474               // Look for the same arraycopy reference.
1475               add_fields_to_worklist(field, abase);
1476             }
1477           }
1478         }
1479       }
1480     }
1481   }
1482 }
1483 
1484 // Put on worklist all related field nodes.
1485 void ConnectionGraph::add_fields_to_worklist(FieldNode* field, PointsToNode* base) {
1486   int offset = field-&gt;offset();
1487   if (base-&gt;is_LocalVar()) {
1488     for (UseIterator j(base); j.has_next(); j.next()) {
1489       PointsToNode* f = j.get();
1490       if (PointsToNode::is_base_use(f)) { // Field
1491         f = PointsToNode::get_use_node(f);
1492         if (f == field || !f-&gt;as_Field()-&gt;is_oop())
1493           continue;
1494         int offs = f-&gt;as_Field()-&gt;offset();
1495         if (offs == offset || offset == Type::OffsetBot || offs == Type::OffsetBot) {
1496           add_to_worklist(f);
1497         }
1498       }
1499     }
1500   } else {
1501     assert(base-&gt;is_JavaObject(), &quot;sanity&quot;);
1502     if (// Skip phantom_object since it is only used to indicate that
1503         // this field&#39;s content globally escapes.
1504         (base != phantom_obj) &amp;&amp;
1505         // NULL object node does not have fields.
1506         (base != null_obj)) {
1507       for (EdgeIterator i(base); i.has_next(); i.next()) {
1508         PointsToNode* f = i.get();
1509         // Skip arraycopy edge since store to destination object field
1510         // does not update value in source object field.
1511         if (f-&gt;is_Arraycopy()) {
1512           assert(base-&gt;arraycopy_dst(), &quot;sanity&quot;);
1513           continue;
1514         }
1515         if (f == field || !f-&gt;as_Field()-&gt;is_oop())
1516           continue;
1517         int offs = f-&gt;as_Field()-&gt;offset();
1518         if (offs == offset || offset == Type::OffsetBot || offs == Type::OffsetBot) {
1519           add_to_worklist(f);
1520         }
1521       }
1522     }
1523   }
1524 }
1525 
1526 // Find fields which have unknown value.
1527 int ConnectionGraph::find_field_value(FieldNode* field) {
1528   // Escaped fields should have init value already.
1529   assert(field-&gt;escape_state() == PointsToNode::NoEscape, &quot;sanity&quot;);
1530   int new_edges = 0;
1531   for (BaseIterator i(field); i.has_next(); i.next()) {
1532     PointsToNode* base = i.get();
1533     if (base-&gt;is_JavaObject()) {
1534       // Skip Allocate&#39;s fields which will be processed later.
1535       if (base-&gt;ideal_node()-&gt;is_Allocate())
1536         return 0;
1537       assert(base == null_obj, &quot;only NULL ptr base expected here&quot;);
1538     }
1539   }
1540   if (add_edge(field, phantom_obj)) {
1541     // New edge was added
1542     new_edges++;
1543     add_field_uses_to_worklist(field);
1544   }
1545   return new_edges;
1546 }
1547 
1548 // Find fields initializing values for allocations.
1549 int ConnectionGraph::find_init_values(JavaObjectNode* pta, PointsToNode* init_val, PhaseTransform* phase) {
1550   assert(pta-&gt;escape_state() == PointsToNode::NoEscape, &quot;Not escaped Allocate nodes only&quot;);
1551   int new_edges = 0;
1552   Node* alloc = pta-&gt;ideal_node();
1553   if (init_val == phantom_obj) {
1554     // Do nothing for Allocate nodes since its fields values are
1555     // &quot;known&quot; unless they are initialized by arraycopy/clone.
1556     if (alloc-&gt;is_Allocate() &amp;&amp; !pta-&gt;arraycopy_dst())
1557       return 0;
1558     assert(pta-&gt;arraycopy_dst() || alloc-&gt;as_CallStaticJava(), &quot;sanity&quot;);
1559 #ifdef ASSERT
1560     if (!pta-&gt;arraycopy_dst() &amp;&amp; alloc-&gt;as_CallStaticJava()-&gt;method() == NULL) {
1561       const char* name = alloc-&gt;as_CallStaticJava()-&gt;_name;
1562       assert(strncmp(name, &quot;_multianewarray&quot;, 15) == 0, &quot;sanity&quot;);
1563     }
1564 #endif
1565     // Non-escaped allocation returned from Java or runtime call have
1566     // unknown values in fields.
1567     for (EdgeIterator i(pta); i.has_next(); i.next()) {
1568       PointsToNode* field = i.get();
1569       if (field-&gt;is_Field() &amp;&amp; field-&gt;as_Field()-&gt;is_oop()) {
1570         if (add_edge(field, phantom_obj)) {
1571           // New edge was added
1572           new_edges++;
1573           add_field_uses_to_worklist(field-&gt;as_Field());
1574         }
1575       }
1576     }
1577     return new_edges;
1578   }
1579   assert(init_val == null_obj, &quot;sanity&quot;);
1580   // Do nothing for Call nodes since its fields values are unknown.
1581   if (!alloc-&gt;is_Allocate())
1582     return 0;
1583 
1584   InitializeNode* ini = alloc-&gt;as_Allocate()-&gt;initialization();
1585   bool visited_bottom_offset = false;
1586   GrowableArray&lt;int&gt; offsets_worklist;
1587 
1588   // Check if an oop field&#39;s initializing value is recorded and add
1589   // a corresponding NULL if field&#39;s value if it is not recorded.
1590   // Connection Graph does not record a default initialization by NULL
1591   // captured by Initialize node.
1592   //
1593   for (EdgeIterator i(pta); i.has_next(); i.next()) {
1594     PointsToNode* field = i.get(); // Field (AddP)
1595     if (!field-&gt;is_Field() || !field-&gt;as_Field()-&gt;is_oop())
1596       continue; // Not oop field
1597     int offset = field-&gt;as_Field()-&gt;offset();
1598     if (offset == Type::OffsetBot) {
1599       if (!visited_bottom_offset) {
1600         // OffsetBot is used to reference array&#39;s element,
1601         // always add reference to NULL to all Field nodes since we don&#39;t
1602         // known which element is referenced.
1603         if (add_edge(field, null_obj)) {
1604           // New edge was added
1605           new_edges++;
1606           add_field_uses_to_worklist(field-&gt;as_Field());
1607           visited_bottom_offset = true;
1608         }
1609       }
1610     } else {
1611       // Check only oop fields.
1612       const Type* adr_type = field-&gt;ideal_node()-&gt;as_AddP()-&gt;bottom_type();
1613       if (adr_type-&gt;isa_rawptr()) {
1614 #ifdef ASSERT
1615         // Raw pointers are used for initializing stores so skip it
1616         // since it should be recorded already
1617         Node* base = get_addp_base(field-&gt;ideal_node());
1618         assert(adr_type-&gt;isa_rawptr() &amp;&amp; base-&gt;is_Proj() &amp;&amp;
1619                (base-&gt;in(0) == alloc),&quot;unexpected pointer type&quot;);
1620 #endif
1621         continue;
1622       }
1623       if (!offsets_worklist.contains(offset)) {
1624         offsets_worklist.append(offset);
1625         Node* value = NULL;
1626         if (ini != NULL) {
1627           // StoreP::memory_type() == T_ADDRESS
1628           BasicType ft = UseCompressedOops ? T_NARROWOOP : T_ADDRESS;
1629           Node* store = ini-&gt;find_captured_store(offset, type2aelembytes(ft, true), phase);
1630           // Make sure initializing store has the same type as this AddP.
1631           // This AddP may reference non existing field because it is on a
1632           // dead branch of bimorphic call which is not eliminated yet.
1633           if (store != NULL &amp;&amp; store-&gt;is_Store() &amp;&amp;
1634               store-&gt;as_Store()-&gt;memory_type() == ft) {
1635             value = store-&gt;in(MemNode::ValueIn);
1636 #ifdef ASSERT
1637             if (VerifyConnectionGraph) {
1638               // Verify that AddP already points to all objects the value points to.
1639               PointsToNode* val = ptnode_adr(value-&gt;_idx);
1640               assert((val != NULL), &quot;should be processed already&quot;);
1641               PointsToNode* missed_obj = NULL;
1642               if (val-&gt;is_JavaObject()) {
1643                 if (!field-&gt;points_to(val-&gt;as_JavaObject())) {
1644                   missed_obj = val;
1645                 }
1646               } else {
1647                 if (!val-&gt;is_LocalVar() || (val-&gt;edge_count() == 0)) {
1648                   tty-&gt;print_cr(&quot;----------init store has invalid value -----&quot;);
1649                   store-&gt;dump();
1650                   val-&gt;dump();
1651                   assert(val-&gt;is_LocalVar() &amp;&amp; (val-&gt;edge_count() &gt; 0), &quot;should be processed already&quot;);
1652                 }
1653                 for (EdgeIterator j(val); j.has_next(); j.next()) {
1654                   PointsToNode* obj = j.get();
1655                   if (obj-&gt;is_JavaObject()) {
1656                     if (!field-&gt;points_to(obj-&gt;as_JavaObject())) {
1657                       missed_obj = obj;
1658                       break;
1659                     }
1660                   }
1661                 }
1662               }
1663               if (missed_obj != NULL) {
1664                 tty-&gt;print_cr(&quot;----------field---------------------------------&quot;);
1665                 field-&gt;dump();
1666                 tty-&gt;print_cr(&quot;----------missed reference to object------------&quot;);
1667                 missed_obj-&gt;dump();
1668                 tty-&gt;print_cr(&quot;----------object referenced by init store-------&quot;);
1669                 store-&gt;dump();
1670                 val-&gt;dump();
1671                 assert(!field-&gt;points_to(missed_obj-&gt;as_JavaObject()), &quot;missed JavaObject reference&quot;);
1672               }
1673             }
1674 #endif
1675           } else {
1676             // There could be initializing stores which follow allocation.
1677             // For example, a volatile field store is not collected
1678             // by Initialize node.
1679             //
1680             // Need to check for dependent loads to separate such stores from
1681             // stores which follow loads. For now, add initial value NULL so
1682             // that compare pointers optimization works correctly.
1683           }
1684         }
1685         if (value == NULL) {
1686           // A field&#39;s initializing value was not recorded. Add NULL.
1687           if (add_edge(field, null_obj)) {
1688             // New edge was added
1689             new_edges++;
1690             add_field_uses_to_worklist(field-&gt;as_Field());
1691           }
1692         }
1693       }
1694     }
1695   }
1696   return new_edges;
1697 }
1698 
1699 // Adjust scalar_replaceable state after Connection Graph is built.
1700 void ConnectionGraph::adjust_scalar_replaceable_state(JavaObjectNode* jobj) {
1701   // Search for non-escaping objects which are not scalar replaceable
1702   // and mark them to propagate the state to referenced objects.
1703 
1704   // 1. An object is not scalar replaceable if the field into which it is
1705   // stored has unknown offset (stored into unknown element of an array).
1706   //
1707   for (UseIterator i(jobj); i.has_next(); i.next()) {
1708     PointsToNode* use = i.get();
1709     if (use-&gt;is_Arraycopy()) {
1710       continue;
1711     }
1712     if (use-&gt;is_Field()) {
1713       FieldNode* field = use-&gt;as_Field();
1714       assert(field-&gt;is_oop() &amp;&amp; field-&gt;scalar_replaceable(), &quot;sanity&quot;);
1715       if (field-&gt;offset() == Type::OffsetBot) {
1716         jobj-&gt;set_scalar_replaceable(false);
1717         return;
1718       }
1719       // 2. An object is not scalar replaceable if the field into which it is
1720       // stored has multiple bases one of which is null.
1721       if (field-&gt;base_count() &gt; 1) {
1722         for (BaseIterator i(field); i.has_next(); i.next()) {
1723           PointsToNode* base = i.get();
1724           if (base == null_obj) {
1725             jobj-&gt;set_scalar_replaceable(false);
1726             return;
1727           }
1728         }
1729       }
1730     }
1731     assert(use-&gt;is_Field() || use-&gt;is_LocalVar(), &quot;sanity&quot;);
1732     // 3. An object is not scalar replaceable if it is merged with other objects.
1733     for (EdgeIterator j(use); j.has_next(); j.next()) {
1734       PointsToNode* ptn = j.get();
1735       if (ptn-&gt;is_JavaObject() &amp;&amp; ptn != jobj) {
1736         // Mark all objects.
1737         jobj-&gt;set_scalar_replaceable(false);
1738         ptn-&gt;set_scalar_replaceable(false);
1739       }
1740     }
1741     if (!jobj-&gt;scalar_replaceable()) {
1742       return;
1743     }
1744   }
1745 
1746   for (EdgeIterator j(jobj); j.has_next(); j.next()) {
1747     if (j.get()-&gt;is_Arraycopy()) {
1748       continue;
1749     }
1750 
1751     // Non-escaping object node should point only to field nodes.
1752     FieldNode* field = j.get()-&gt;as_Field();
1753     int offset = field-&gt;as_Field()-&gt;offset();
1754 
1755     // 4. An object is not scalar replaceable if it has a field with unknown
1756     // offset (array&#39;s element is accessed in loop).
1757     if (offset == Type::OffsetBot) {
1758       jobj-&gt;set_scalar_replaceable(false);
1759       return;
1760     }
1761     // 5. Currently an object is not scalar replaceable if a LoadStore node
1762     // access its field since the field value is unknown after it.
1763     //
1764     Node* n = field-&gt;ideal_node();
1765 
1766     // Test for an unsafe access that was parsed as maybe off heap
1767     // (with a CheckCastPP to raw memory).
1768     assert(n-&gt;is_AddP(), &quot;expect an address computation&quot;);
1769     if (n-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
1770         n-&gt;in(AddPNode::Address)-&gt;Opcode() == Op_CheckCastPP) {
1771       assert(n-&gt;in(AddPNode::Address)-&gt;bottom_type()-&gt;isa_rawptr(), &quot;raw address so raw cast expected&quot;);
1772       assert(_igvn-&gt;type(n-&gt;in(AddPNode::Address)-&gt;in(1))-&gt;isa_oopptr(), &quot;cast pattern at unsafe access expected&quot;);
1773       jobj-&gt;set_scalar_replaceable(false);
1774       return;
1775     }
1776 
1777     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1778       Node* u = n-&gt;fast_out(i);
1779       if (u-&gt;is_LoadStore() || (u-&gt;is_Mem() &amp;&amp; u-&gt;as_Mem()-&gt;is_mismatched_access())) {
1780         jobj-&gt;set_scalar_replaceable(false);
1781         return;
1782       }
1783     }
1784 
1785     // 6. Or the address may point to more then one object. This may produce
1786     // the false positive result (set not scalar replaceable)
1787     // since the flow-insensitive escape analysis can&#39;t separate
1788     // the case when stores overwrite the field&#39;s value from the case
1789     // when stores happened on different control branches.
1790     //
1791     // Note: it will disable scalar replacement in some cases:
1792     //
1793     //    Point p[] = new Point[1];
1794     //    p[0] = new Point(); // Will be not scalar replaced
1795     //
1796     // but it will save us from incorrect optimizations in next cases:
1797     //
1798     //    Point p[] = new Point[1];
1799     //    if ( x ) p[0] = new Point(); // Will be not scalar replaced
1800     //
1801     if (field-&gt;base_count() &gt; 1) {
1802       for (BaseIterator i(field); i.has_next(); i.next()) {
1803         PointsToNode* base = i.get();
1804         // Don&#39;t take into account LocalVar nodes which
1805         // may point to only one object which should be also
1806         // this field&#39;s base by now.
1807         if (base-&gt;is_JavaObject() &amp;&amp; base != jobj) {
1808           // Mark all bases.
1809           jobj-&gt;set_scalar_replaceable(false);
1810           base-&gt;set_scalar_replaceable(false);
1811         }
1812       }
1813     }
1814   }
1815 }
1816 
1817 #ifdef ASSERT
1818 void ConnectionGraph::verify_connection_graph(
1819                          GrowableArray&lt;PointsToNode*&gt;&amp;   ptnodes_worklist,
1820                          GrowableArray&lt;JavaObjectNode*&gt;&amp; non_escaped_worklist,
1821                          GrowableArray&lt;JavaObjectNode*&gt;&amp; java_objects_worklist,
1822                          GrowableArray&lt;Node*&gt;&amp; addp_worklist) {
1823   // Verify that graph is complete - no new edges could be added.
1824   int java_objects_length = java_objects_worklist.length();
1825   int non_escaped_length  = non_escaped_worklist.length();
1826   int new_edges = 0;
1827   for (int next = 0; next &lt; java_objects_length; ++next) {
1828     JavaObjectNode* ptn = java_objects_worklist.at(next);
1829     new_edges += add_java_object_edges(ptn, true);
1830   }
1831   assert(new_edges == 0, &quot;graph was not complete&quot;);
1832   // Verify that escape state is final.
1833   int length = non_escaped_worklist.length();
1834   find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist);
1835   assert((non_escaped_length == non_escaped_worklist.length()) &amp;&amp;
1836          (non_escaped_length == length) &amp;&amp;
1837          (_worklist.length() == 0), &quot;escape state was not final&quot;);
1838 
1839   // Verify fields information.
1840   int addp_length = addp_worklist.length();
1841   for (int next = 0; next &lt; addp_length; ++next ) {
1842     Node* n = addp_worklist.at(next);
1843     FieldNode* field = ptnode_adr(n-&gt;_idx)-&gt;as_Field();
1844     if (field-&gt;is_oop()) {
1845       // Verify that field has all bases
1846       Node* base = get_addp_base(n);
1847       PointsToNode* ptn = ptnode_adr(base-&gt;_idx);
1848       if (ptn-&gt;is_JavaObject()) {
1849         assert(field-&gt;has_base(ptn-&gt;as_JavaObject()), &quot;sanity&quot;);
1850       } else {
1851         assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
1852         for (EdgeIterator i(ptn); i.has_next(); i.next()) {
1853           PointsToNode* e = i.get();
1854           if (e-&gt;is_JavaObject()) {
1855             assert(field-&gt;has_base(e-&gt;as_JavaObject()), &quot;sanity&quot;);
1856           }
1857         }
1858       }
1859       // Verify that all fields have initializing values.
1860       if (field-&gt;edge_count() == 0) {
1861         tty-&gt;print_cr(&quot;----------field does not have references----------&quot;);
1862         field-&gt;dump();
1863         for (BaseIterator i(field); i.has_next(); i.next()) {
1864           PointsToNode* base = i.get();
1865           tty-&gt;print_cr(&quot;----------field has next base---------------------&quot;);
1866           base-&gt;dump();
1867           if (base-&gt;is_JavaObject() &amp;&amp; (base != phantom_obj) &amp;&amp; (base != null_obj)) {
1868             tty-&gt;print_cr(&quot;----------base has fields-------------------------&quot;);
1869             for (EdgeIterator j(base); j.has_next(); j.next()) {
1870               j.get()-&gt;dump();
1871             }
1872             tty-&gt;print_cr(&quot;----------base has references---------------------&quot;);
1873             for (UseIterator j(base); j.has_next(); j.next()) {
1874               j.get()-&gt;dump();
1875             }
1876           }
1877         }
1878         for (UseIterator i(field); i.has_next(); i.next()) {
1879           i.get()-&gt;dump();
1880         }
1881         assert(field-&gt;edge_count() &gt; 0, &quot;sanity&quot;);
1882       }
1883     }
1884   }
1885 }
1886 #endif
1887 
1888 // Optimize ideal graph.
1889 void ConnectionGraph::optimize_ideal_graph(GrowableArray&lt;Node*&gt;&amp; ptr_cmp_worklist,
1890                                            GrowableArray&lt;Node*&gt;&amp; storestore_worklist) {
1891   Compile* C = _compile;
1892   PhaseIterGVN* igvn = _igvn;
1893   if (EliminateLocks) {
1894     // Mark locks before changing ideal graph.
1895     int cnt = C-&gt;macro_count();
1896     for( int i=0; i &lt; cnt; i++ ) {
1897       Node *n = C-&gt;macro_node(i);
1898       if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
1899         AbstractLockNode* alock = n-&gt;as_AbstractLock();
1900         if (!alock-&gt;is_non_esc_obj()) {
1901           const Type* obj_type = igvn-&gt;type(alock-&gt;obj_node());
1902           if (not_global_escape(alock-&gt;obj_node()) &amp;&amp;
1903               !obj_type-&gt;isa_valuetype() &amp;&amp; !obj_type-&gt;is_valuetypeptr()) {
1904             assert(!alock-&gt;is_eliminated() || alock-&gt;is_coarsened(), &quot;sanity&quot;);
1905             // The lock could be marked eliminated by lock coarsening
1906             // code during first IGVN before EA. Replace coarsened flag
1907             // to eliminate all associated locks/unlocks.
1908 #ifdef ASSERT
1909             alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc3&quot;);
1910 #endif
1911             alock-&gt;set_non_esc_obj();
1912           }
1913         }
1914       }
1915     }
1916   }
1917 
1918   if (OptimizePtrCompare) {
1919     // Add ConI(#CC_GT) and ConI(#CC_EQ).
1920     _pcmp_neq = igvn-&gt;makecon(TypeInt::CC_GT);
1921     _pcmp_eq = igvn-&gt;makecon(TypeInt::CC_EQ);
1922     // Optimize objects compare.
1923     while (ptr_cmp_worklist.length() != 0) {
1924       Node *n = ptr_cmp_worklist.pop();
1925       Node *res = optimize_ptr_compare(n);
1926       if (res != NULL) {
1927 #ifndef PRODUCT
1928         if (PrintOptimizePtrCompare) {
1929           tty-&gt;print_cr(&quot;++++ Replaced: %d %s(%d,%d) --&gt; %s&quot;, n-&gt;_idx, (n-&gt;Opcode() == Op_CmpP ? &quot;CmpP&quot; : &quot;CmpN&quot;), n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, (res == _pcmp_eq ? &quot;EQ&quot; : &quot;NotEQ&quot;));
1930           if (Verbose) {
1931             n-&gt;dump(1);
1932           }
1933         }
1934 #endif
1935         igvn-&gt;replace_node(n, res);
1936       }
1937     }
1938     // cleanup
1939     if (_pcmp_neq-&gt;outcnt() == 0)
1940       igvn-&gt;hash_delete(_pcmp_neq);
1941     if (_pcmp_eq-&gt;outcnt()  == 0)
1942       igvn-&gt;hash_delete(_pcmp_eq);
1943   }
1944 
1945   // For MemBarStoreStore nodes added in library_call.cpp, check
1946   // escape status of associated AllocateNode and optimize out
1947   // MemBarStoreStore node if the allocated object never escapes.
1948   while (storestore_worklist.length() != 0) {
1949     Node *n = storestore_worklist.pop();
1950     MemBarStoreStoreNode *storestore = n -&gt;as_MemBarStoreStore();
1951     Node *alloc = storestore-&gt;in(MemBarNode::Precedent)-&gt;in(0);
1952     assert (alloc-&gt;is_Allocate(), &quot;storestore should point to AllocateNode&quot;);
1953     if (not_global_escape(alloc)) {
1954       MemBarNode* mb = MemBarNode::make(C, Op_MemBarCPUOrder, Compile::AliasIdxBot);
1955       mb-&gt;init_req(TypeFunc::Memory, storestore-&gt;in(TypeFunc::Memory));
1956       mb-&gt;init_req(TypeFunc::Control, storestore-&gt;in(TypeFunc::Control));
1957       igvn-&gt;register_new_node_with_optimizer(mb);
1958       igvn-&gt;replace_node(storestore, mb);
1959     }
1960   }
1961 }
1962 
1963 // Optimize objects compare.
1964 Node* ConnectionGraph::optimize_ptr_compare(Node* n) {
1965   assert(OptimizePtrCompare, &quot;sanity&quot;);
1966   PointsToNode* ptn1 = ptnode_adr(n-&gt;in(1)-&gt;_idx);
1967   PointsToNode* ptn2 = ptnode_adr(n-&gt;in(2)-&gt;_idx);
1968   JavaObjectNode* jobj1 = unique_java_object(n-&gt;in(1));
1969   JavaObjectNode* jobj2 = unique_java_object(n-&gt;in(2));
1970   assert(ptn1-&gt;is_JavaObject() || ptn1-&gt;is_LocalVar(), &quot;sanity&quot;);
1971   assert(ptn2-&gt;is_JavaObject() || ptn2-&gt;is_LocalVar(), &quot;sanity&quot;);
1972 
1973   // Check simple cases first.
1974   if (jobj1 != NULL) {
1975     if (jobj1-&gt;escape_state() == PointsToNode::NoEscape) {
1976       if (jobj1 == jobj2) {
1977         // Comparing the same not escaping object.
1978         return _pcmp_eq;
1979       }
1980       Node* obj = jobj1-&gt;ideal_node();
1981       // Comparing not escaping allocation.
1982       if ((obj-&gt;is_Allocate() || obj-&gt;is_CallStaticJava()) &amp;&amp;
1983           !ptn2-&gt;points_to(jobj1)) {
1984         return _pcmp_neq; // This includes nullness check.
1985       }
1986     }
1987   }
1988   if (jobj2 != NULL) {
1989     if (jobj2-&gt;escape_state() == PointsToNode::NoEscape) {
1990       Node* obj = jobj2-&gt;ideal_node();
1991       // Comparing not escaping allocation.
1992       if ((obj-&gt;is_Allocate() || obj-&gt;is_CallStaticJava()) &amp;&amp;
1993           !ptn1-&gt;points_to(jobj2)) {
1994         return _pcmp_neq; // This includes nullness check.
1995       }
1996     }
1997   }
1998   if (jobj1 != NULL &amp;&amp; jobj1 != phantom_obj &amp;&amp;
1999       jobj2 != NULL &amp;&amp; jobj2 != phantom_obj &amp;&amp;
2000       jobj1-&gt;ideal_node()-&gt;is_Con() &amp;&amp;
2001       jobj2-&gt;ideal_node()-&gt;is_Con()) {
2002     // Klass or String constants compare. Need to be careful with
2003     // compressed pointers - compare types of ConN and ConP instead of nodes.
2004     const Type* t1 = jobj1-&gt;ideal_node()-&gt;get_ptr_type();
2005     const Type* t2 = jobj2-&gt;ideal_node()-&gt;get_ptr_type();
2006     if (t1-&gt;make_ptr() == t2-&gt;make_ptr()) {
2007       return _pcmp_eq;
2008     } else {
2009       return _pcmp_neq;
2010     }
2011   }
2012   if (ptn1-&gt;meet(ptn2)) {
2013     return NULL; // Sets are not disjoint
2014   }
2015 
2016   // Sets are disjoint.
2017   bool set1_has_unknown_ptr = ptn1-&gt;points_to(phantom_obj);
2018   bool set2_has_unknown_ptr = ptn2-&gt;points_to(phantom_obj);
2019   bool set1_has_null_ptr    = ptn1-&gt;points_to(null_obj);
2020   bool set2_has_null_ptr    = ptn2-&gt;points_to(null_obj);
2021   if ((set1_has_unknown_ptr &amp;&amp; set2_has_null_ptr) ||
2022       (set2_has_unknown_ptr &amp;&amp; set1_has_null_ptr)) {
2023     // Check nullness of unknown object.
2024     return NULL;
2025   }
2026 
2027   // Disjointness by itself is not sufficient since
2028   // alias analysis is not complete for escaped objects.
2029   // Disjoint sets are definitely unrelated only when
2030   // at least one set has only not escaping allocations.
2031   if (!set1_has_unknown_ptr &amp;&amp; !set1_has_null_ptr) {
2032     if (ptn1-&gt;non_escaping_allocation()) {
2033       return _pcmp_neq;
2034     }
2035   }
2036   if (!set2_has_unknown_ptr &amp;&amp; !set2_has_null_ptr) {
2037     if (ptn2-&gt;non_escaping_allocation()) {
2038       return _pcmp_neq;
2039     }
2040   }
2041   return NULL;
2042 }
2043 
2044 // Connection Graph constuction functions.
2045 
2046 void ConnectionGraph::add_local_var(Node *n, PointsToNode::EscapeState es) {
2047   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2048   if (ptadr != NULL) {
2049     assert(ptadr-&gt;is_LocalVar() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2050     return;
2051   }
2052   Compile* C = _compile;
2053   ptadr = new (C-&gt;comp_arena()) LocalVarNode(this, n, es);
2054   _nodes.at_put(n-&gt;_idx, ptadr);
2055 }
2056 
2057 void ConnectionGraph::add_java_object(Node *n, PointsToNode::EscapeState es) {
2058   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2059   if (ptadr != NULL) {
2060     assert(ptadr-&gt;is_JavaObject() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2061     return;
2062   }
2063   Compile* C = _compile;
2064   ptadr = new (C-&gt;comp_arena()) JavaObjectNode(this, n, es);
2065   _nodes.at_put(n-&gt;_idx, ptadr);
2066 }
2067 
2068 void ConnectionGraph::add_field(Node *n, PointsToNode::EscapeState es, int offset) {
2069   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2070   if (ptadr != NULL) {
2071     assert(ptadr-&gt;is_Field() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2072     return;
2073   }
2074   bool unsafe = false;
2075   bool is_oop = is_oop_field(n, offset, &amp;unsafe);
2076   if (unsafe) {
2077     es = PointsToNode::GlobalEscape;
2078   }
2079   Compile* C = _compile;
2080   FieldNode* field = new (C-&gt;comp_arena()) FieldNode(this, n, es, offset, is_oop);
2081   _nodes.at_put(n-&gt;_idx, field);
2082 }
2083 
2084 void ConnectionGraph::add_arraycopy(Node *n, PointsToNode::EscapeState es,
2085                                     PointsToNode* src, PointsToNode* dst) {
2086   assert(!src-&gt;is_Field() &amp;&amp; !dst-&gt;is_Field(), &quot;only for JavaObject and LocalVar&quot;);
2087   assert((src != null_obj) &amp;&amp; (dst != null_obj), &quot;not for ConP NULL&quot;);
2088   PointsToNode* ptadr = _nodes.at(n-&gt;_idx);
2089   if (ptadr != NULL) {
2090     assert(ptadr-&gt;is_Arraycopy() &amp;&amp; ptadr-&gt;ideal_node() == n, &quot;sanity&quot;);
2091     return;
2092   }
2093   Compile* C = _compile;
2094   ptadr = new (C-&gt;comp_arena()) ArraycopyNode(this, n, es);
2095   _nodes.at_put(n-&gt;_idx, ptadr);
2096   // Add edge from arraycopy node to source object.
2097   (void)add_edge(ptadr, src);
2098   src-&gt;set_arraycopy_src();
2099   // Add edge from destination object to arraycopy node.
2100   (void)add_edge(dst, ptadr);
2101   dst-&gt;set_arraycopy_dst();
2102 }
2103 
2104 bool ConnectionGraph::is_oop_field(Node* n, int offset, bool* unsafe) {
2105   const Type* adr_type = n-&gt;as_AddP()-&gt;bottom_type();
2106   int field_offset = adr_type-&gt;isa_aryptr() ? adr_type-&gt;isa_aryptr()-&gt;field_offset().get() : Type::OffsetBot;
2107   BasicType bt = T_INT;
2108   if (offset == Type::OffsetBot &amp;&amp; field_offset == Type::OffsetBot) {
2109     // Check only oop fields.
2110     if (!adr_type-&gt;isa_aryptr() ||
2111         (adr_type-&gt;isa_aryptr()-&gt;klass() == NULL) ||
2112          adr_type-&gt;isa_aryptr()-&gt;klass()-&gt;is_obj_array_klass()) {
2113       // OffsetBot is used to reference array&#39;s element. Ignore first AddP.
2114       if (find_second_addp(n, n-&gt;in(AddPNode::Base)) == NULL) {
2115         bt = T_OBJECT;
2116       }
2117     }
2118   } else if (offset != oopDesc::klass_offset_in_bytes()) {
2119     if (adr_type-&gt;isa_instptr()) {
2120       ciField* field = _compile-&gt;alias_type(adr_type-&gt;is_ptr())-&gt;field();
2121       if (field != NULL) {
2122         bt = field-&gt;layout_type();
2123       } else {
2124         // Check for unsafe oop field access
2125         if (n-&gt;has_out_with(Op_StoreP, Op_LoadP, Op_StoreN, Op_LoadN) ||
2126             n-&gt;has_out_with(Op_GetAndSetP, Op_GetAndSetN, Op_CompareAndExchangeP, Op_CompareAndExchangeN) ||
2127             n-&gt;has_out_with(Op_CompareAndSwapP, Op_CompareAndSwapN, Op_WeakCompareAndSwapP, Op_WeakCompareAndSwapN) ||
2128             BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
2129           bt = T_OBJECT;
2130           (*unsafe) = true;
2131         }
2132       }
2133     } else if (adr_type-&gt;isa_aryptr()) {
2134       if (offset == arrayOopDesc::length_offset_in_bytes()) {
2135         // Ignore array length load.
2136       } else if (find_second_addp(n, n-&gt;in(AddPNode::Base)) != NULL) {
2137         // Ignore first AddP.
2138       } else {
2139         const Type* elemtype = adr_type-&gt;isa_aryptr()-&gt;elem();
2140         if (elemtype-&gt;isa_valuetype() &amp;&amp; field_offset != Type::OffsetBot) {
2141           ciValueKlass* vk = elemtype-&gt;value_klass();
2142           field_offset += vk-&gt;first_field_offset();
2143           bt = vk-&gt;get_field_by_offset(field_offset, false)-&gt;layout_type();
2144         } else {
2145           bt = elemtype-&gt;array_element_basic_type();
2146         }
2147       }
2148     } else if (adr_type-&gt;isa_rawptr() || adr_type-&gt;isa_klassptr()) {
2149       // Allocation initialization, ThreadLocal field access, unsafe access
2150       if (n-&gt;has_out_with(Op_StoreP, Op_LoadP, Op_StoreN, Op_LoadN) ||
2151           n-&gt;has_out_with(Op_GetAndSetP, Op_GetAndSetN, Op_CompareAndExchangeP, Op_CompareAndExchangeN) ||
2152           n-&gt;has_out_with(Op_CompareAndSwapP, Op_CompareAndSwapN, Op_WeakCompareAndSwapP, Op_WeakCompareAndSwapN) ||
2153           BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;escape_has_out_with_unsafe_object(n)) {
2154         bt = T_OBJECT;
2155       }
2156     }
2157   }
2158   // Note: T_NARROWOOP is not classed as a real reference type
2159   return (is_reference_type(bt) || bt == T_NARROWOOP);
2160 }
2161 
2162 // Returns unique pointed java object or NULL.
2163 JavaObjectNode* ConnectionGraph::unique_java_object(Node *n) {
2164   assert(!_collecting, &quot;should not call when constructed graph&quot;);
2165   // If the node was created after the escape computation we can&#39;t answer.
2166   uint idx = n-&gt;_idx;
2167   if (idx &gt;= nodes_size()) {
2168     return NULL;
2169   }
2170   PointsToNode* ptn = ptnode_adr(idx);
2171   if (ptn == NULL) {
2172     return NULL;
2173   }
2174   if (ptn-&gt;is_JavaObject()) {
2175     return ptn-&gt;as_JavaObject();
2176   }
2177   assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2178   // Check all java objects it points to.
2179   JavaObjectNode* jobj = NULL;
2180   for (EdgeIterator i(ptn); i.has_next(); i.next()) {
2181     PointsToNode* e = i.get();
2182     if (e-&gt;is_JavaObject()) {
2183       if (jobj == NULL) {
2184         jobj = e-&gt;as_JavaObject();
2185       } else if (jobj != e) {
2186         return NULL;
2187       }
2188     }
2189   }
2190   return jobj;
2191 }
2192 
2193 // Return true if this node points only to non-escaping allocations.
2194 bool PointsToNode::non_escaping_allocation() {
2195   if (is_JavaObject()) {
2196     Node* n = ideal_node();
2197     if (n-&gt;is_Allocate() || n-&gt;is_CallStaticJava()) {
2198       return (escape_state() == PointsToNode::NoEscape);
2199     } else {
2200       return false;
2201     }
2202   }
2203   assert(is_LocalVar(), &quot;sanity&quot;);
2204   // Check all java objects it points to.
2205   for (EdgeIterator i(this); i.has_next(); i.next()) {
2206     PointsToNode* e = i.get();
2207     if (e-&gt;is_JavaObject()) {
2208       Node* n = e-&gt;ideal_node();
2209       if ((e-&gt;escape_state() != PointsToNode::NoEscape) ||
2210           !(n-&gt;is_Allocate() || n-&gt;is_CallStaticJava())) {
2211         return false;
2212       }
2213     }
2214   }
2215   return true;
2216 }
2217 
2218 // Return true if we know the node does not escape globally.
2219 bool ConnectionGraph::not_global_escape(Node *n) {
2220   assert(!_collecting, &quot;should not call during graph construction&quot;);
2221   // If the node was created after the escape computation we can&#39;t answer.
2222   uint idx = n-&gt;_idx;
2223   if (idx &gt;= nodes_size()) {
2224     return false;
2225   }
2226   PointsToNode* ptn = ptnode_adr(idx);
2227   if (ptn == NULL) {
2228     return false; // not in congraph (e.g. ConI)
2229   }
2230   PointsToNode::EscapeState es = ptn-&gt;escape_state();
2231   // If we have already computed a value, return it.
2232   if (es &gt;= PointsToNode::GlobalEscape)
2233     return false;
2234   if (ptn-&gt;is_JavaObject()) {
2235     return true; // (es &lt; PointsToNode::GlobalEscape);
2236   }
2237   assert(ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2238   // Check all java objects it points to.
2239   for (EdgeIterator i(ptn); i.has_next(); i.next()) {
2240     if (i.get()-&gt;escape_state() &gt;= PointsToNode::GlobalEscape)
2241       return false;
2242   }
2243   return true;
2244 }
2245 
2246 
2247 // Helper functions
2248 
2249 // Return true if this node points to specified node or nodes it points to.
2250 bool PointsToNode::points_to(JavaObjectNode* ptn) const {
2251   if (is_JavaObject()) {
2252     return (this == ptn);
2253   }
2254   assert(is_LocalVar() || is_Field(), &quot;sanity&quot;);
2255   for (EdgeIterator i(this); i.has_next(); i.next()) {
2256     if (i.get() == ptn)
2257       return true;
2258   }
2259   return false;
2260 }
2261 
2262 // Return true if one node points to an other.
2263 bool PointsToNode::meet(PointsToNode* ptn) {
2264   if (this == ptn) {
2265     return true;
2266   } else if (ptn-&gt;is_JavaObject()) {
2267     return this-&gt;points_to(ptn-&gt;as_JavaObject());
2268   } else if (this-&gt;is_JavaObject()) {
2269     return ptn-&gt;points_to(this-&gt;as_JavaObject());
2270   }
2271   assert(this-&gt;is_LocalVar() &amp;&amp; ptn-&gt;is_LocalVar(), &quot;sanity&quot;);
2272   int ptn_count =  ptn-&gt;edge_count();
2273   for (EdgeIterator i(this); i.has_next(); i.next()) {
2274     PointsToNode* this_e = i.get();
2275     for (int j = 0; j &lt; ptn_count; j++) {
2276       if (this_e == ptn-&gt;edge(j))
2277         return true;
2278     }
2279   }
2280   return false;
2281 }
2282 
2283 #ifdef ASSERT
2284 // Return true if bases point to this java object.
2285 bool FieldNode::has_base(JavaObjectNode* jobj) const {
2286   for (BaseIterator i(this); i.has_next(); i.next()) {
2287     if (i.get() == jobj)
2288       return true;
2289   }
2290   return false;
2291 }
2292 #endif
2293 
2294 int ConnectionGraph::address_offset(Node* adr, PhaseTransform *phase) {
2295   const Type *adr_type = phase-&gt;type(adr);
2296   if (adr-&gt;is_AddP() &amp;&amp; adr_type-&gt;isa_oopptr() == NULL &amp;&amp;
2297       adr-&gt;in(AddPNode::Address)-&gt;is_Proj() &amp;&amp;
2298       adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_Allocate()) {
2299     // We are computing a raw address for a store captured by an Initialize
2300     // compute an appropriate address type. AddP cases #3 and #5 (see below).
2301     int offs = (int)phase-&gt;find_intptr_t_con(adr-&gt;in(AddPNode::Offset), Type::OffsetBot);
2302     assert(offs != Type::OffsetBot ||
2303            adr-&gt;in(AddPNode::Address)-&gt;in(0)-&gt;is_AllocateArray(),
2304            &quot;offset must be a constant or it is initialization of array&quot;);
2305     return offs;
2306   }
2307   return adr_type-&gt;is_ptr()-&gt;flattened_offset();
2308 }
2309 
2310 Node* ConnectionGraph::get_addp_base(Node *addp) {
2311   assert(addp-&gt;is_AddP(), &quot;must be AddP&quot;);
2312   //
2313   // AddP cases for Base and Address inputs:
2314   // case #1. Direct object&#39;s field reference:
2315   //     Allocate
2316   //       |
2317   //     Proj #5 ( oop result )
2318   //       |
2319   //     CheckCastPP (cast to instance type)
2320   //      | |
2321   //     AddP  ( base == address )
2322   //
2323   // case #2. Indirect object&#39;s field reference:
2324   //      Phi
2325   //       |
2326   //     CastPP (cast to instance type)
2327   //      | |
2328   //     AddP  ( base == address )
2329   //
2330   // case #3. Raw object&#39;s field reference for Initialize node:
2331   //      Allocate
2332   //        |
2333   //      Proj #5 ( oop result )
2334   //  top   |
2335   //     \  |
2336   //     AddP  ( base == top )
2337   //
2338   // case #4. Array&#39;s element reference:
2339   //   {CheckCastPP | CastPP}
2340   //     |  | |
2341   //     |  AddP ( array&#39;s element offset )
2342   //     |  |
2343   //     AddP ( array&#39;s offset )
2344   //
2345   // case #5. Raw object&#39;s field reference for arraycopy stub call:
2346   //          The inline_native_clone() case when the arraycopy stub is called
2347   //          after the allocation before Initialize and CheckCastPP nodes.
2348   //      Allocate
2349   //        |
2350   //      Proj #5 ( oop result )
2351   //       | |
2352   //       AddP  ( base == address )
2353   //
2354   // case #6. Constant Pool, ThreadLocal, CastX2P or
2355   //          Raw object&#39;s field reference:
2356   //      {ConP, ThreadLocal, CastX2P, raw Load}
2357   //  top   |
2358   //     \  |
2359   //     AddP  ( base == top )
2360   //
2361   // case #7. Klass&#39;s field reference.
2362   //      LoadKlass
2363   //       | |
2364   //       AddP  ( base == address )
2365   //
2366   // case #8. narrow Klass&#39;s field reference.
2367   //      LoadNKlass
2368   //       |
2369   //      DecodeN
2370   //       | |
2371   //       AddP  ( base == address )
2372   //
2373   // case #9. Mixed unsafe access
2374   //    {instance}
2375   //        |
2376   //      CheckCastPP (raw)
2377   //  top   |
2378   //     \  |
2379   //     AddP  ( base == top )
2380   //
2381   Node *base = addp-&gt;in(AddPNode::Base);
2382   if (base-&gt;uncast()-&gt;is_top()) { // The AddP case #3 and #6 and #9.
2383     base = addp-&gt;in(AddPNode::Address);
2384     while (base-&gt;is_AddP()) {
2385       // Case #6 (unsafe access) may have several chained AddP nodes.
2386       assert(base-&gt;in(AddPNode::Base)-&gt;uncast()-&gt;is_top(), &quot;expected unsafe access address only&quot;);
2387       base = base-&gt;in(AddPNode::Address);
2388     }
2389     if (base-&gt;Opcode() == Op_CheckCastPP &amp;&amp;
2390         base-&gt;bottom_type()-&gt;isa_rawptr() &amp;&amp;
2391         _igvn-&gt;type(base-&gt;in(1))-&gt;isa_oopptr()) {
2392       base = base-&gt;in(1); // Case #9
2393     } else {
2394       Node* uncast_base = base-&gt;uncast();
2395       int opcode = uncast_base-&gt;Opcode();
2396       assert(opcode == Op_ConP || opcode == Op_ThreadLocal ||
2397              opcode == Op_CastX2P || uncast_base-&gt;is_DecodeNarrowPtr() ||
2398              (uncast_base-&gt;is_Mem() &amp;&amp; (uncast_base-&gt;bottom_type()-&gt;isa_rawptr() != NULL)) ||
2399              (uncast_base-&gt;is_Proj() &amp;&amp; uncast_base-&gt;in(0)-&gt;is_Allocate()), &quot;sanity&quot;);
2400     }
2401   }
2402   return base;
2403 }
2404 
2405 Node* ConnectionGraph::find_second_addp(Node* addp, Node* n) {
2406   assert(addp-&gt;is_AddP() &amp;&amp; addp-&gt;outcnt() &gt; 0, &quot;Don&#39;t process dead nodes&quot;);
2407   Node* addp2 = addp-&gt;raw_out(0);
2408   if (addp-&gt;outcnt() == 1 &amp;&amp; addp2-&gt;is_AddP() &amp;&amp;
2409       addp2-&gt;in(AddPNode::Base) == n &amp;&amp;
2410       addp2-&gt;in(AddPNode::Address) == addp) {
2411     assert(addp-&gt;in(AddPNode::Base) == n, &quot;expecting the same base&quot;);
2412     //
2413     // Find array&#39;s offset to push it on worklist first and
2414     // as result process an array&#39;s element offset first (pushed second)
2415     // to avoid CastPP for the array&#39;s offset.
2416     // Otherwise the inserted CastPP (LocalVar) will point to what
2417     // the AddP (Field) points to. Which would be wrong since
2418     // the algorithm expects the CastPP has the same point as
2419     // as AddP&#39;s base CheckCastPP (LocalVar).
2420     //
2421     //    ArrayAllocation
2422     //     |
2423     //    CheckCastPP
2424     //     |
2425     //    memProj (from ArrayAllocation CheckCastPP)
2426     //     |  ||
2427     //     |  ||   Int (element index)
2428     //     |  ||    |   ConI (log(element size))
2429     //     |  ||    |   /
2430     //     |  ||   LShift
2431     //     |  ||  /
2432     //     |  AddP (array&#39;s element offset)
2433     //     |  |
2434     //     |  | ConI (array&#39;s offset: #12(32-bits) or #24(64-bits))
2435     //     | / /
2436     //     AddP (array&#39;s offset)
2437     //      |
2438     //     Load/Store (memory operation on array&#39;s element)
2439     //
2440     return addp2;
2441   }
2442   return NULL;
2443 }
2444 
2445 //
2446 // Adjust the type and inputs of an AddP which computes the
2447 // address of a field of an instance
2448 //
2449 bool ConnectionGraph::split_AddP(Node *addp, Node *base) {
2450   PhaseGVN* igvn = _igvn;
2451   const TypeOopPtr *base_t = igvn-&gt;type(base)-&gt;isa_oopptr();
2452   assert(base_t != NULL &amp;&amp; base_t-&gt;is_known_instance(), &quot;expecting instance oopptr&quot;);
2453   const TypeOopPtr *t = igvn-&gt;type(addp)-&gt;isa_oopptr();
2454   if (t == NULL) {
2455     // We are computing a raw address for a store captured by an Initialize
2456     // compute an appropriate address type (cases #3 and #5).
2457     assert(igvn-&gt;type(addp) == TypeRawPtr::NOTNULL, &quot;must be raw pointer&quot;);
2458     assert(addp-&gt;in(AddPNode::Address)-&gt;is_Proj(), &quot;base of raw address must be result projection from allocation&quot;);
2459     intptr_t offs = (int)igvn-&gt;find_intptr_t_con(addp-&gt;in(AddPNode::Offset), Type::OffsetBot);
2460     assert(offs != Type::OffsetBot, &quot;offset must be a constant&quot;);
2461     if (base_t-&gt;isa_aryptr() != NULL) {
2462       // In the case of a flattened value type array, each field has its
2463       // own slice so we need to extract the field being accessed from
2464       // the address computation
2465       t = base_t-&gt;isa_aryptr()-&gt;add_field_offset_and_offset(offs)-&gt;is_oopptr();
2466     } else {
2467       t = base_t-&gt;add_offset(offs)-&gt;is_oopptr();
2468     }
2469   }
2470   int inst_id = base_t-&gt;instance_id();
2471   assert(!t-&gt;is_known_instance() || t-&gt;instance_id() == inst_id,
2472                              &quot;old type must be non-instance or match new type&quot;);
2473 
2474   // The type &#39;t&#39; could be subclass of &#39;base_t&#39;.
2475   // As result t-&gt;offset() could be large then base_t&#39;s size and it will
2476   // cause the failure in add_offset() with narrow oops since TypeOopPtr()
2477   // constructor verifies correctness of the offset.
2478   //
2479   // It could happened on subclass&#39;s branch (from the type profiling
2480   // inlining) which was not eliminated during parsing since the exactness
2481   // of the allocation type was not propagated to the subclass type check.
2482   //
2483   // Or the type &#39;t&#39; could be not related to &#39;base_t&#39; at all.
2484   // It could happen when CHA type is different from MDO type on a dead path
2485   // (for example, from instanceof check) which is not collapsed during parsing.
2486   //
2487   // Do nothing for such AddP node and don&#39;t process its users since
2488   // this code branch will go away.
2489   //
2490   if (!t-&gt;is_known_instance() &amp;&amp;
2491       !base_t-&gt;klass()-&gt;is_subtype_of(t-&gt;klass())) {
2492      return false; // bail out
2493   }
2494   const TypePtr* tinst = base_t-&gt;add_offset(t-&gt;offset());
2495   if (tinst-&gt;isa_aryptr() &amp;&amp; t-&gt;isa_aryptr()) {
2496     // In the case of a flattened value type array, each field has its
2497     // own slice so we need to keep track of the field being accessed.
2498     tinst = tinst-&gt;is_aryptr()-&gt;with_field_offset(t-&gt;is_aryptr()-&gt;field_offset().get());
2499   }
2500 
2501   // Do NOT remove the next line: ensure a new alias index is allocated
2502   // for the instance type. Note: C++ will not remove it since the call
2503   // has side effect.
2504   int alias_idx = _compile-&gt;get_alias_index(tinst);
2505   igvn-&gt;set_type(addp, tinst);
2506   // record the allocation in the node map
2507   set_map(addp, get_map(base-&gt;_idx));
2508   // Set addp&#39;s Base and Address to &#39;base&#39;.
2509   Node *abase = addp-&gt;in(AddPNode::Base);
2510   Node *adr   = addp-&gt;in(AddPNode::Address);
2511   if (adr-&gt;is_Proj() &amp;&amp; adr-&gt;in(0)-&gt;is_Allocate() &amp;&amp;
2512       adr-&gt;in(0)-&gt;_idx == (uint)inst_id) {
2513     // Skip AddP cases #3 and #5.
2514   } else {
2515     assert(!abase-&gt;is_top(), &quot;sanity&quot;); // AddP case #3
2516     if (abase != base) {
2517       igvn-&gt;hash_delete(addp);
2518       addp-&gt;set_req(AddPNode::Base, base);
2519       if (abase == adr) {
2520         addp-&gt;set_req(AddPNode::Address, base);
2521       } else {
2522         // AddP case #4 (adr is array&#39;s element offset AddP node)
2523 #ifdef ASSERT
2524         const TypeOopPtr *atype = igvn-&gt;type(adr)-&gt;isa_oopptr();
2525         assert(adr-&gt;is_AddP() &amp;&amp; atype != NULL &amp;&amp;
2526                atype-&gt;instance_id() == inst_id, &quot;array&#39;s element offset should be processed first&quot;);
2527 #endif
2528       }
2529       igvn-&gt;hash_insert(addp);
2530     }
2531   }
2532   // Put on IGVN worklist since at least addp&#39;s type was changed above.
2533   record_for_optimizer(addp);
2534   return true;
2535 }
2536 
2537 //
2538 // Create a new version of orig_phi if necessary. Returns either the newly
2539 // created phi or an existing phi.  Sets create_new to indicate whether a new
2540 // phi was created.  Cache the last newly created phi in the node map.
2541 //
2542 PhiNode *ConnectionGraph::create_split_phi(PhiNode *orig_phi, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phi_worklist, bool &amp;new_created) {
2543   Compile *C = _compile;
2544   PhaseGVN* igvn = _igvn;
2545   new_created = false;
2546   int phi_alias_idx = C-&gt;get_alias_index(orig_phi-&gt;adr_type());
2547   // nothing to do if orig_phi is bottom memory or matches alias_idx
2548   if (phi_alias_idx == alias_idx) {
2549     return orig_phi;
2550   }
2551   // Have we recently created a Phi for this alias index?
2552   PhiNode *result = get_map_phi(orig_phi-&gt;_idx);
2553   if (result != NULL &amp;&amp; C-&gt;get_alias_index(result-&gt;adr_type()) == alias_idx) {
2554     return result;
2555   }
2556   // Previous check may fail when the same wide memory Phi was split into Phis
2557   // for different memory slices. Search all Phis for this region.
2558   if (result != NULL) {
2559     Node* region = orig_phi-&gt;in(0);
2560     for (DUIterator_Fast imax, i = region-&gt;fast_outs(imax); i &lt; imax; i++) {
2561       Node* phi = region-&gt;fast_out(i);
2562       if (phi-&gt;is_Phi() &amp;&amp;
2563           C-&gt;get_alias_index(phi-&gt;as_Phi()-&gt;adr_type()) == alias_idx) {
2564         assert(phi-&gt;_idx &gt;= nodes_size(), &quot;only new Phi per instance memory slice&quot;);
2565         return phi-&gt;as_Phi();
2566       }
2567     }
2568   }
2569   if (C-&gt;live_nodes() + 2*NodeLimitFudgeFactor &gt; C-&gt;max_node_limit()) {
2570     if (C-&gt;do_escape_analysis() == true &amp;&amp; !C-&gt;failing()) {
2571       // Retry compilation without escape analysis.
2572       // If this is the first failure, the sentinel string will &quot;stick&quot;
2573       // to the Compile object, and the C2Compiler will see it and retry.
2574       C-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
2575     }
2576     return NULL;
2577   }
2578   orig_phi_worklist.append_if_missing(orig_phi);
2579   const TypePtr *atype = C-&gt;get_adr_type(alias_idx);
2580   result = PhiNode::make(orig_phi-&gt;in(0), NULL, Type::MEMORY, atype);
2581   C-&gt;copy_node_notes_to(result, orig_phi);
2582   igvn-&gt;set_type(result, result-&gt;bottom_type());
2583   record_for_optimizer(result);
2584   set_map(orig_phi, result);
2585   new_created = true;
2586   return result;
2587 }
2588 
2589 //
2590 // Return a new version of Memory Phi &quot;orig_phi&quot; with the inputs having the
2591 // specified alias index.
2592 //
2593 PhiNode *ConnectionGraph::split_memory_phi(PhiNode *orig_phi, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phi_worklist) {
2594   assert(alias_idx != Compile::AliasIdxBot, &quot;can&#39;t split out bottom memory&quot;);
2595   Compile *C = _compile;
2596   PhaseGVN* igvn = _igvn;
2597   bool new_phi_created;
2598   PhiNode *result = create_split_phi(orig_phi, alias_idx, orig_phi_worklist, new_phi_created);
2599   if (!new_phi_created) {
2600     return result;
2601   }
2602   GrowableArray&lt;PhiNode *&gt;  phi_list;
2603   GrowableArray&lt;uint&gt;  cur_input;
2604   PhiNode *phi = orig_phi;
2605   uint idx = 1;
2606   bool finished = false;
2607   while(!finished) {
2608     while (idx &lt; phi-&gt;req()) {
2609       Node *mem = find_inst_mem(phi-&gt;in(idx), alias_idx, orig_phi_worklist);
2610       if (mem != NULL &amp;&amp; mem-&gt;is_Phi()) {
2611         PhiNode *newphi = create_split_phi(mem-&gt;as_Phi(), alias_idx, orig_phi_worklist, new_phi_created);
2612         if (new_phi_created) {
2613           // found an phi for which we created a new split, push current one on worklist and begin
2614           // processing new one
2615           phi_list.push(phi);
2616           cur_input.push(idx);
2617           phi = mem-&gt;as_Phi();
2618           result = newphi;
2619           idx = 1;
2620           continue;
2621         } else {
2622           mem = newphi;
2623         }
2624       }
2625       if (C-&gt;failing()) {
2626         return NULL;
2627       }
2628       result-&gt;set_req(idx++, mem);
2629     }
2630 #ifdef ASSERT
2631     // verify that the new Phi has an input for each input of the original
2632     assert( phi-&gt;req() == result-&gt;req(), &quot;must have same number of inputs.&quot;);
2633     assert( result-&gt;in(0) != NULL &amp;&amp; result-&gt;in(0) == phi-&gt;in(0), &quot;regions must match&quot;);
2634 #endif
2635     // Check if all new phi&#39;s inputs have specified alias index.
2636     // Otherwise use old phi.
2637     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
2638       Node* in = result-&gt;in(i);
2639       assert((phi-&gt;in(i) == NULL) == (in == NULL), &quot;inputs must correspond.&quot;);
2640     }
2641     // we have finished processing a Phi, see if there are any more to do
2642     finished = (phi_list.length() == 0 );
2643     if (!finished) {
2644       phi = phi_list.pop();
2645       idx = cur_input.pop();
2646       PhiNode *prev_result = get_map_phi(phi-&gt;_idx);
2647       prev_result-&gt;set_req(idx++, result);
2648       result = prev_result;
2649     }
2650   }
2651   return result;
2652 }
2653 
2654 //
2655 // The next methods are derived from methods in MemNode.
2656 //
2657 Node* ConnectionGraph::step_through_mergemem(MergeMemNode *mmem, int alias_idx, const TypeOopPtr *toop) {
2658   Node *mem = mmem;
2659   // TypeOopPtr::NOTNULL+any is an OOP with unknown offset - generally
2660   // means an array I have not precisely typed yet.  Do not do any
2661   // alias stuff with it any time soon.
2662   if (toop-&gt;base() != Type::AnyPtr &amp;&amp;
2663       !(toop-&gt;klass() != NULL &amp;&amp;
2664         toop-&gt;klass()-&gt;is_java_lang_Object() &amp;&amp;
2665         toop-&gt;offset() == Type::OffsetBot)) {
2666     mem = mmem-&gt;memory_at(alias_idx);
2667     // Update input if it is progress over what we have now
2668   }
2669   return mem;
2670 }
2671 
2672 //
2673 // Move memory users to their memory slices.
2674 //
2675 void ConnectionGraph::move_inst_mem(Node* n, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phis) {
2676   Compile* C = _compile;
2677   PhaseGVN* igvn = _igvn;
2678   const TypePtr* tp = igvn-&gt;type(n-&gt;in(MemNode::Address))-&gt;isa_ptr();
2679   assert(tp != NULL, &quot;ptr type&quot;);
2680   int alias_idx = C-&gt;get_alias_index(tp);
2681   int general_idx = C-&gt;get_general_index(alias_idx);
2682 
2683   // Move users first
2684   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2685     Node* use = n-&gt;fast_out(i);
2686     if (use-&gt;is_MergeMem()) {
2687       MergeMemNode* mmem = use-&gt;as_MergeMem();
2688       assert(n == mmem-&gt;memory_at(alias_idx), &quot;should be on instance memory slice&quot;);
2689       if (n != mmem-&gt;memory_at(general_idx) || alias_idx == general_idx) {
2690         continue; // Nothing to do
2691       }
2692       // Replace previous general reference to mem node.
2693       uint orig_uniq = C-&gt;unique();
2694       Node* m = find_inst_mem(n, general_idx, orig_phis);
2695       assert(orig_uniq == C-&gt;unique(), &quot;no new nodes&quot;);
2696       mmem-&gt;set_memory_at(general_idx, m);
2697       --imax;
2698       --i;
2699     } else if (use-&gt;is_MemBar()) {
2700       assert(!use-&gt;is_Initialize(), &quot;initializing stores should not be moved&quot;);
2701       if (use-&gt;req() &gt; MemBarNode::Precedent &amp;&amp;
2702           use-&gt;in(MemBarNode::Precedent) == n) {
2703         // Don&#39;t move related membars.
2704         record_for_optimizer(use);
2705         continue;
2706       }
2707       tp = use-&gt;as_MemBar()-&gt;adr_type()-&gt;isa_ptr();
2708       if ((tp != NULL &amp;&amp; C-&gt;get_alias_index(tp) == alias_idx) ||
2709           alias_idx == general_idx) {
2710         continue; // Nothing to do
2711       }
2712       // Move to general memory slice.
2713       uint orig_uniq = C-&gt;unique();
2714       Node* m = find_inst_mem(n, general_idx, orig_phis);
2715       assert(orig_uniq == C-&gt;unique(), &quot;no new nodes&quot;);
2716       igvn-&gt;hash_delete(use);
2717       imax -= use-&gt;replace_edge(n, m);
2718       igvn-&gt;hash_insert(use);
2719       record_for_optimizer(use);
2720       --i;
2721 #ifdef ASSERT
2722     } else if (use-&gt;is_Mem()) {
2723       if (use-&gt;Opcode() == Op_StoreCM &amp;&amp; use-&gt;in(MemNode::OopStore) == n) {
2724         // Don&#39;t move related cardmark.
2725         continue;
2726       }
2727       // Memory nodes should have new memory input.
2728       tp = igvn-&gt;type(use-&gt;in(MemNode::Address))-&gt;isa_ptr();
2729       assert(tp != NULL, &quot;ptr type&quot;);
2730       int idx = C-&gt;get_alias_index(tp);
2731       assert(get_map(use-&gt;_idx) != NULL || idx == alias_idx,
2732              &quot;Following memory nodes should have new memory input or be on the same memory slice&quot;);
2733     } else if (use-&gt;is_Phi()) {
2734       // Phi nodes should be split and moved already.
2735       tp = use-&gt;as_Phi()-&gt;adr_type()-&gt;isa_ptr();
2736       assert(tp != NULL, &quot;ptr type&quot;);
2737       int idx = C-&gt;get_alias_index(tp);
2738       assert(idx == alias_idx, &quot;Following Phi nodes should be on the same memory slice&quot;);
2739     } else {
2740       use-&gt;dump();
2741       assert(false, &quot;should not be here&quot;);
2742 #endif
2743     }
2744   }
2745 }
2746 
2747 //
2748 // Search memory chain of &quot;mem&quot; to find a MemNode whose address
2749 // is the specified alias index.
2750 //
2751 Node* ConnectionGraph::find_inst_mem(Node *orig_mem, int alias_idx, GrowableArray&lt;PhiNode *&gt;  &amp;orig_phis) {
2752   if (orig_mem == NULL)
2753     return orig_mem;
2754   Compile* C = _compile;
2755   PhaseGVN* igvn = _igvn;
2756   const TypeOopPtr *toop = C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
2757   bool is_instance = (toop != NULL) &amp;&amp; toop-&gt;is_known_instance();
2758   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
2759   Node *prev = NULL;
2760   Node *result = orig_mem;
2761   while (prev != result) {
2762     prev = result;
2763     if (result == start_mem)
2764       break;  // hit one of our sentinels
2765     if (result-&gt;is_Mem()) {
2766       const Type *at = igvn-&gt;type(result-&gt;in(MemNode::Address));
2767       if (at == Type::TOP)
2768         break; // Dead
2769       assert (at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2770       int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2771       if (idx == alias_idx)
2772         break; // Found
2773       if (!is_instance &amp;&amp; (at-&gt;isa_oopptr() == NULL ||
2774                            !at-&gt;is_oopptr()-&gt;is_known_instance())) {
2775         break; // Do not skip store to general memory slice.
2776       }
2777       result = result-&gt;in(MemNode::Memory);
2778     }
2779     if (!is_instance)
2780       continue;  // don&#39;t search further for non-instance types
2781     // skip over a call which does not affect this memory slice
2782     if (result-&gt;is_Proj() &amp;&amp; result-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
2783       Node *proj_in = result-&gt;in(0);
2784       if (proj_in-&gt;is_Allocate() &amp;&amp; proj_in-&gt;_idx == (uint)toop-&gt;instance_id()) {
2785         break;  // hit one of our sentinels
2786       } else if (proj_in-&gt;is_Call()) {
2787         // ArrayCopy node processed here as well
2788         CallNode *call = proj_in-&gt;as_Call();
2789         if (!call-&gt;may_modify(toop, igvn)) {
2790           result = call-&gt;in(TypeFunc::Memory);
2791         }
2792       } else if (proj_in-&gt;is_Initialize()) {
2793         AllocateNode* alloc = proj_in-&gt;as_Initialize()-&gt;allocation();
2794         // Stop if this is the initialization for the object instance which
2795         // which contains this memory slice, otherwise skip over it.
2796         if (alloc == NULL || alloc-&gt;_idx != (uint)toop-&gt;instance_id()) {
2797           result = proj_in-&gt;in(TypeFunc::Memory);
2798         }
2799       } else if (proj_in-&gt;is_MemBar()) {
2800         // Check if there is an array copy for a clone
2801         // Step over GC barrier when ReduceInitialCardMarks is disabled
2802         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2803         Node* control_proj_ac = bs-&gt;step_over_gc_barrier(proj_in-&gt;in(0));
2804 
2805         if (control_proj_ac-&gt;is_Proj() &amp;&amp; control_proj_ac-&gt;in(0)-&gt;is_ArrayCopy()) {
2806           // Stop if it is a clone
2807           ArrayCopyNode* ac = control_proj_ac-&gt;in(0)-&gt;as_ArrayCopy();
2808           if (ac-&gt;may_modify(toop, igvn)) {
2809             break;
2810           }
2811         }
2812         result = proj_in-&gt;in(TypeFunc::Memory);
2813       }
2814     } else if (result-&gt;is_MergeMem()) {
2815       MergeMemNode *mmem = result-&gt;as_MergeMem();
2816       result = step_through_mergemem(mmem, alias_idx, toop);
2817       if (result == mmem-&gt;base_memory()) {
2818         // Didn&#39;t find instance memory, search through general slice recursively.
2819         result = mmem-&gt;memory_at(C-&gt;get_general_index(alias_idx));
2820         result = find_inst_mem(result, alias_idx, orig_phis);
2821         if (C-&gt;failing()) {
2822           return NULL;
2823         }
2824         mmem-&gt;set_memory_at(alias_idx, result);
2825       }
2826     } else if (result-&gt;is_Phi() &amp;&amp;
2827                C-&gt;get_alias_index(result-&gt;as_Phi()-&gt;adr_type()) != alias_idx) {
2828       Node *un = result-&gt;as_Phi()-&gt;unique_input(igvn);
2829       if (un != NULL) {
2830         orig_phis.append_if_missing(result-&gt;as_Phi());
2831         result = un;
2832       } else {
2833         break;
2834       }
2835     } else if (result-&gt;is_ClearArray()) {
2836       if (!ClearArrayNode::step_through(&amp;result, (uint)toop-&gt;instance_id(), igvn)) {
2837         // Can not bypass initialization of the instance
2838         // we are looking for.
2839         break;
2840       }
2841       // Otherwise skip it (the call updated &#39;result&#39; value).
2842     } else if (result-&gt;Opcode() == Op_SCMemProj) {
2843       Node* mem = result-&gt;in(0);
2844       Node* adr = NULL;
2845       if (mem-&gt;is_LoadStore()) {
2846         adr = mem-&gt;in(MemNode::Address);
2847       } else {
2848         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
2849                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
2850         adr = mem-&gt;in(3); // Memory edge corresponds to destination array
2851       }
2852       const Type *at = igvn-&gt;type(adr);
2853       if (at != Type::TOP) {
2854         assert(at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2855         int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2856         if (idx == alias_idx) {
2857           // Assert in debug mode
2858           assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
2859           break; // In product mode return SCMemProj node
2860         }
2861       }
2862       result = mem-&gt;in(MemNode::Memory);
2863     } else if (result-&gt;Opcode() == Op_StrInflatedCopy) {
2864       Node* adr = result-&gt;in(3); // Memory edge corresponds to destination array
2865       const Type *at = igvn-&gt;type(adr);
2866       if (at != Type::TOP) {
2867         assert(at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
2868         int idx = C-&gt;get_alias_index(at-&gt;is_ptr());
2869         if (idx == alias_idx) {
2870           // Assert in debug mode
2871           assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
2872           break; // In product mode return SCMemProj node
2873         }
2874       }
2875       result = result-&gt;in(MemNode::Memory);
2876     }
2877   }
2878   if (result-&gt;is_Phi()) {
2879     PhiNode *mphi = result-&gt;as_Phi();
2880     assert(mphi-&gt;bottom_type() == Type::MEMORY, &quot;memory phi required&quot;);
2881     const TypePtr *t = mphi-&gt;adr_type();
2882     if (!is_instance) {
2883       // Push all non-instance Phis on the orig_phis worklist to update inputs
2884       // during Phase 4 if needed.
2885       orig_phis.append_if_missing(mphi);
2886     } else if (C-&gt;get_alias_index(t) != alias_idx) {
2887       // Create a new Phi with the specified alias index type.
2888       result = split_memory_phi(mphi, alias_idx, orig_phis);
2889     }
2890   }
2891   // the result is either MemNode, PhiNode, InitializeNode.
2892   return result;
2893 }
2894 
2895 //
2896 //  Convert the types of unescaped object to instance types where possible,
2897 //  propagate the new type information through the graph, and update memory
2898 //  edges and MergeMem inputs to reflect the new type.
2899 //
2900 //  We start with allocations (and calls which may be allocations)  on alloc_worklist.
2901 //  The processing is done in 4 phases:
2902 //
2903 //  Phase 1:  Process possible allocations from alloc_worklist.  Create instance
2904 //            types for the CheckCastPP for allocations where possible.
2905 //            Propagate the new types through users as follows:
2906 //               casts and Phi:  push users on alloc_worklist
2907 //               AddP:  cast Base and Address inputs to the instance type
2908 //                      push any AddP users on alloc_worklist and push any memnode
2909 //                      users onto memnode_worklist.
2910 //  Phase 2:  Process MemNode&#39;s from memnode_worklist. compute new address type and
2911 //            search the Memory chain for a store with the appropriate type
2912 //            address type.  If a Phi is found, create a new version with
2913 //            the appropriate memory slices from each of the Phi inputs.
2914 //            For stores, process the users as follows:
2915 //               MemNode:  push on memnode_worklist
2916 //               MergeMem: push on mergemem_worklist
2917 //  Phase 3:  Process MergeMem nodes from mergemem_worklist.  Walk each memory slice
2918 //            moving the first node encountered of each  instance type to the
2919 //            the input corresponding to its alias index.
2920 //            appropriate memory slice.
2921 //  Phase 4:  Update the inputs of non-instance memory Phis and the Memory input of memnodes.
2922 //
2923 // In the following example, the CheckCastPP nodes are the cast of allocation
2924 // results and the allocation of node 29 is unescaped and eligible to be an
2925 // instance type.
2926 //
2927 // We start with:
2928 //
2929 //     7 Parm #memory
2930 //    10  ConI  &quot;12&quot;
2931 //    19  CheckCastPP   &quot;Foo&quot;
2932 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2933 //    29  CheckCastPP   &quot;Foo&quot;
2934 //    30  AddP  _ 29 29 10  Foo+12  alias_index=4
2935 //
2936 //    40  StoreP  25   7  20   ... alias_index=4
2937 //    50  StoreP  35  40  30   ... alias_index=4
2938 //    60  StoreP  45  50  20   ... alias_index=4
2939 //    70  LoadP    _  60  30   ... alias_index=4
2940 //    80  Phi     75  50  60   Memory alias_index=4
2941 //    90  LoadP    _  80  30   ... alias_index=4
2942 //   100  LoadP    _  80  20   ... alias_index=4
2943 //
2944 //
2945 // Phase 1 creates an instance type for node 29 assigning it an instance id of 24
2946 // and creating a new alias index for node 30.  This gives:
2947 //
2948 //     7 Parm #memory
2949 //    10  ConI  &quot;12&quot;
2950 //    19  CheckCastPP   &quot;Foo&quot;
2951 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2952 //    29  CheckCastPP   &quot;Foo&quot;  iid=24
2953 //    30  AddP  _ 29 29 10  Foo+12  alias_index=6  iid=24
2954 //
2955 //    40  StoreP  25   7  20   ... alias_index=4
2956 //    50  StoreP  35  40  30   ... alias_index=6
2957 //    60  StoreP  45  50  20   ... alias_index=4
2958 //    70  LoadP    _  60  30   ... alias_index=6
2959 //    80  Phi     75  50  60   Memory alias_index=4
2960 //    90  LoadP    _  80  30   ... alias_index=6
2961 //   100  LoadP    _  80  20   ... alias_index=4
2962 //
2963 // In phase 2, new memory inputs are computed for the loads and stores,
2964 // And a new version of the phi is created.  In phase 4, the inputs to
2965 // node 80 are updated and then the memory nodes are updated with the
2966 // values computed in phase 2.  This results in:
2967 //
2968 //     7 Parm #memory
2969 //    10  ConI  &quot;12&quot;
2970 //    19  CheckCastPP   &quot;Foo&quot;
2971 //    20  AddP  _ 19 19 10  Foo+12  alias_index=4
2972 //    29  CheckCastPP   &quot;Foo&quot;  iid=24
2973 //    30  AddP  _ 29 29 10  Foo+12  alias_index=6  iid=24
2974 //
2975 //    40  StoreP  25  7   20   ... alias_index=4
2976 //    50  StoreP  35  7   30   ... alias_index=6
2977 //    60  StoreP  45  40  20   ... alias_index=4
2978 //    70  LoadP    _  50  30   ... alias_index=6
2979 //    80  Phi     75  40  60   Memory alias_index=4
2980 //   120  Phi     75  50  50   Memory alias_index=6
2981 //    90  LoadP    _ 120  30   ... alias_index=6
2982 //   100  LoadP    _  80  20   ... alias_index=4
2983 //
2984 void ConnectionGraph::split_unique_types(GrowableArray&lt;Node *&gt;  &amp;alloc_worklist, GrowableArray&lt;ArrayCopyNode*&gt; &amp;arraycopy_worklist) {
2985   GrowableArray&lt;Node *&gt;  memnode_worklist;
2986   GrowableArray&lt;PhiNode *&gt;  orig_phis;
2987   PhaseIterGVN  *igvn = _igvn;
2988   uint new_index_start = (uint) _compile-&gt;num_alias_types();
2989   Arena* arena = Thread::current()-&gt;resource_area();
2990   VectorSet visited(arena);
2991   ideal_nodes.clear(); // Reset for use with set_map/get_map.
2992   uint unique_old = _compile-&gt;unique();
2993 
2994   //  Phase 1:  Process possible allocations from alloc_worklist.
2995   //  Create instance types for the CheckCastPP for allocations where possible.
2996   //
2997   // (Note: don&#39;t forget to change the order of the second AddP node on
2998   //  the alloc_worklist if the order of the worklist processing is changed,
2999   //  see the comment in find_second_addp().)
3000   //
3001   while (alloc_worklist.length() != 0) {
3002     Node *n = alloc_worklist.pop();
3003     uint ni = n-&gt;_idx;
3004     if (n-&gt;is_Call()) {
3005       CallNode *alloc = n-&gt;as_Call();
3006       // copy escape information to call node
3007       PointsToNode* ptn = ptnode_adr(alloc-&gt;_idx);
3008       PointsToNode::EscapeState es = ptn-&gt;escape_state();
3009       // We have an allocation or call which returns a Java object,
3010       // see if it is unescaped.
3011       if (es != PointsToNode::NoEscape || !ptn-&gt;scalar_replaceable())
3012         continue;
3013       // Find CheckCastPP for the allocate or for the return value of a call
3014       n = alloc-&gt;result_cast();
3015       if (n == NULL) {            // No uses except Initialize node
3016         if (alloc-&gt;is_Allocate()) {
3017           // Set the scalar_replaceable flag for allocation
3018           // so it could be eliminated if it has no uses.
3019           alloc-&gt;as_Allocate()-&gt;_is_scalar_replaceable = true;
3020         }
3021         if (alloc-&gt;is_CallStaticJava()) {
3022           // Set the scalar_replaceable flag for boxing method
3023           // so it could be eliminated if it has no uses.
3024           alloc-&gt;as_CallStaticJava()-&gt;_is_scalar_replaceable = true;
3025         }
3026         continue;
3027       }
3028       if (!n-&gt;is_CheckCastPP()) { // not unique CheckCastPP.
3029         assert(!alloc-&gt;is_Allocate(), &quot;allocation should have unique type&quot;);
3030         continue;
3031       }
3032 
3033       // The inline code for Object.clone() casts the allocation result to
3034       // java.lang.Object and then to the actual type of the allocated
3035       // object. Detect this case and use the second cast.
3036       // Also detect j.l.reflect.Array.newInstance(jobject, jint) case when
3037       // the allocation result is cast to java.lang.Object and then
3038       // to the actual Array type.
3039       if (alloc-&gt;is_Allocate() &amp;&amp; n-&gt;as_Type()-&gt;type() == TypeInstPtr::NOTNULL
3040           &amp;&amp; (alloc-&gt;is_AllocateArray() ||
3041               igvn-&gt;type(alloc-&gt;in(AllocateNode::KlassNode)) != TypeKlassPtr::OBJECT)) {
3042         Node *cast2 = NULL;
3043         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3044           Node *use = n-&gt;fast_out(i);
3045           if (use-&gt;is_CheckCastPP()) {
3046             cast2 = use;
3047             break;
3048           }
3049         }
3050         if (cast2 != NULL) {
3051           n = cast2;
3052         } else {
3053           // Non-scalar replaceable if the allocation type is unknown statically
3054           // (reflection allocation), the object can&#39;t be restored during
3055           // deoptimization without precise type.
3056           continue;
3057         }
3058       }
3059 
3060       const TypeOopPtr *t = igvn-&gt;type(n)-&gt;isa_oopptr();
3061       if (t == NULL)
3062         continue;  // not a TypeOopPtr
3063       if (!t-&gt;klass_is_exact())
3064         continue; // not an unique type
3065 
3066       if (alloc-&gt;is_Allocate()) {
3067         // Set the scalar_replaceable flag for allocation
3068         // so it could be eliminated.
3069         alloc-&gt;as_Allocate()-&gt;_is_scalar_replaceable = true;
3070       }
3071       if (alloc-&gt;is_CallStaticJava()) {
3072         // Set the scalar_replaceable flag for boxing method
3073         // so it could be eliminated.
3074         alloc-&gt;as_CallStaticJava()-&gt;_is_scalar_replaceable = true;
3075       }
3076       set_escape_state(ptnode_adr(n-&gt;_idx), es); // CheckCastPP escape state
3077       // in order for an object to be scalar-replaceable, it must be:
3078       //   - a direct allocation (not a call returning an object)
3079       //   - non-escaping
3080       //   - eligible to be a unique type
3081       //   - not determined to be ineligible by escape analysis
3082       set_map(alloc, n);
3083       set_map(n, alloc);
3084       const TypeOopPtr* tinst = t-&gt;cast_to_instance_id(ni);
3085       igvn-&gt;hash_delete(n);
3086       igvn-&gt;set_type(n,  tinst);
3087       n-&gt;raise_bottom_type(tinst);
3088       igvn-&gt;hash_insert(n);
3089       record_for_optimizer(n);
3090       // Allocate an alias index for the header fields. Accesses to
3091       // the header emitted during macro expansion wouldn&#39;t have
3092       // correct memory state otherwise.
3093       _compile-&gt;get_alias_index(tinst-&gt;add_offset(oopDesc::mark_offset_in_bytes()));
3094       _compile-&gt;get_alias_index(tinst-&gt;add_offset(oopDesc::klass_offset_in_bytes()));
3095       if (alloc-&gt;is_Allocate() &amp;&amp; (t-&gt;isa_instptr() || t-&gt;isa_aryptr())) {
3096 
3097         // First, put on the worklist all Field edges from Connection Graph
3098         // which is more accurate than putting immediate users from Ideal Graph.
3099         for (EdgeIterator e(ptn); e.has_next(); e.next()) {
3100           PointsToNode* tgt = e.get();
3101           if (tgt-&gt;is_Arraycopy()) {
3102             continue;
3103           }
3104           Node* use = tgt-&gt;ideal_node();
3105           assert(tgt-&gt;is_Field() &amp;&amp; use-&gt;is_AddP(),
3106                  &quot;only AddP nodes are Field edges in CG&quot;);
3107           if (use-&gt;outcnt() &gt; 0) { // Don&#39;t process dead nodes
3108             Node* addp2 = find_second_addp(use, use-&gt;in(AddPNode::Base));
3109             if (addp2 != NULL) {
3110               assert(alloc-&gt;is_AllocateArray(),&quot;array allocation was expected&quot;);
3111               alloc_worklist.append_if_missing(addp2);
3112             }
3113             alloc_worklist.append_if_missing(use);
3114           }
3115         }
3116 
3117         // An allocation may have an Initialize which has raw stores. Scan
3118         // the users of the raw allocation result and push AddP users
3119         // on alloc_worklist.
3120         Node *raw_result = alloc-&gt;proj_out_or_null(TypeFunc::Parms);
3121         assert (raw_result != NULL, &quot;must have an allocation result&quot;);
3122         for (DUIterator_Fast imax, i = raw_result-&gt;fast_outs(imax); i &lt; imax; i++) {
3123           Node *use = raw_result-&gt;fast_out(i);
3124           if (use-&gt;is_AddP() &amp;&amp; use-&gt;outcnt() &gt; 0) { // Don&#39;t process dead nodes
3125             Node* addp2 = find_second_addp(use, raw_result);
3126             if (addp2 != NULL) {
3127               assert(alloc-&gt;is_AllocateArray(),&quot;array allocation was expected&quot;);
3128               alloc_worklist.append_if_missing(addp2);
3129             }
3130             alloc_worklist.append_if_missing(use);
3131           } else if (use-&gt;is_MemBar()) {
3132             memnode_worklist.append_if_missing(use);
3133           }
3134         }
3135       }
3136     } else if (n-&gt;is_AddP()) {
3137       JavaObjectNode* jobj = unique_java_object(get_addp_base(n));
3138       if (jobj == NULL || jobj == phantom_obj) {
3139 #ifdef ASSERT
3140         ptnode_adr(get_addp_base(n)-&gt;_idx)-&gt;dump();
3141         ptnode_adr(n-&gt;_idx)-&gt;dump();
3142         assert(jobj != NULL &amp;&amp; jobj != phantom_obj, &quot;escaped allocation&quot;);
3143 #endif
3144         _compile-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
3145         return;
3146       }
3147       Node *base = get_map(jobj-&gt;idx());  // CheckCastPP node
3148       if (!split_AddP(n, base)) continue; // wrong type from dead path
3149     } else if (n-&gt;is_Phi() ||
3150                n-&gt;is_CheckCastPP() ||
3151                n-&gt;is_EncodeP() ||
3152                n-&gt;is_DecodeN() ||
3153                (n-&gt;is_ConstraintCast() &amp;&amp; n-&gt;Opcode() == Op_CastPP)) {
3154       if (visited.test_set(n-&gt;_idx)) {
3155         assert(n-&gt;is_Phi(), &quot;loops only through Phi&#39;s&quot;);
3156         continue;  // already processed
3157       }
3158       JavaObjectNode* jobj = unique_java_object(n);
3159       if (jobj == NULL || jobj == phantom_obj) {
3160 #ifdef ASSERT
3161         ptnode_adr(n-&gt;_idx)-&gt;dump();
3162         assert(jobj != NULL &amp;&amp; jobj != phantom_obj, &quot;escaped allocation&quot;);
3163 #endif
3164         _compile-&gt;record_failure(C2Compiler::retry_no_escape_analysis());
3165         return;
3166       } else {
3167         Node *val = get_map(jobj-&gt;idx());   // CheckCastPP node
3168         TypeNode *tn = n-&gt;as_Type();
3169         const TypeOopPtr* tinst = igvn-&gt;type(val)-&gt;isa_oopptr();
3170         assert(tinst != NULL &amp;&amp; tinst-&gt;is_known_instance() &amp;&amp;
3171                tinst-&gt;instance_id() == jobj-&gt;idx() , &quot;instance type expected.&quot;);
3172 
3173         const Type *tn_type = igvn-&gt;type(tn);
3174         const TypeOopPtr *tn_t;
3175         if (tn_type-&gt;isa_narrowoop()) {
3176           tn_t = tn_type-&gt;make_ptr()-&gt;isa_oopptr();
3177         } else {
3178           tn_t = tn_type-&gt;isa_oopptr();
3179         }
3180         if (tn_t != NULL &amp;&amp; tinst-&gt;klass()-&gt;is_subtype_of(tn_t-&gt;klass())) {
3181           if (tn_type-&gt;isa_narrowoop()) {
3182             tn_type = tinst-&gt;make_narrowoop();
3183           } else {
3184             tn_type = tinst;
3185           }
3186           igvn-&gt;hash_delete(tn);
3187           igvn-&gt;set_type(tn, tn_type);
3188           tn-&gt;set_type(tn_type);
3189           igvn-&gt;hash_insert(tn);
3190           record_for_optimizer(n);
3191         } else {
3192           assert(tn_type == TypePtr::NULL_PTR ||
3193                  tn_t != NULL &amp;&amp; !tinst-&gt;klass()-&gt;is_subtype_of(tn_t-&gt;klass()),
3194                  &quot;unexpected type&quot;);
3195           continue; // Skip dead path with different type
3196         }
3197       }
3198     } else {
3199       debug_only(n-&gt;dump();)
3200       assert(false, &quot;EA: unexpected node&quot;);
3201       continue;
3202     }
3203     // push allocation&#39;s users on appropriate worklist
3204     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3205       Node *use = n-&gt;fast_out(i);
3206       if (use-&gt;is_Mem() &amp;&amp; use-&gt;in(MemNode::Address) == n) {
3207         // Load/store to instance&#39;s field
3208         memnode_worklist.append_if_missing(use);
3209       } else if (use-&gt;is_MemBar()) {
3210         if (use-&gt;in(TypeFunc::Memory) == n) { // Ignore precedent edge
3211           memnode_worklist.append_if_missing(use);
3212         }
3213       } else if (use-&gt;is_AddP() &amp;&amp; use-&gt;outcnt() &gt; 0) { // No dead nodes
3214         Node* addp2 = find_second_addp(use, n);
3215         if (addp2 != NULL) {
3216           alloc_worklist.append_if_missing(addp2);
3217         }
3218         alloc_worklist.append_if_missing(use);
3219       } else if (use-&gt;is_Phi() ||
3220                  use-&gt;is_CheckCastPP() ||
3221                  use-&gt;is_EncodeNarrowPtr() ||
3222                  use-&gt;is_DecodeNarrowPtr() ||
3223                  (use-&gt;is_ConstraintCast() &amp;&amp; use-&gt;Opcode() == Op_CastPP)) {
3224         alloc_worklist.append_if_missing(use);
3225 #ifdef ASSERT
3226       } else if (use-&gt;is_Mem()) {
3227         assert(use-&gt;in(MemNode::Address) != n, &quot;EA: missing allocation reference path&quot;);
3228       } else if (use-&gt;is_MergeMem()) {
3229         assert(_mergemem_worklist.contains(use-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3230       } else if (use-&gt;is_SafePoint()) {
3231         // Look for MergeMem nodes for calls which reference unique allocation
3232         // (through CheckCastPP nodes) even for debug info.
3233         Node* m = use-&gt;in(TypeFunc::Memory);
3234         if (m-&gt;is_MergeMem()) {
3235           assert(_mergemem_worklist.contains(m-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3236         }
3237       } else if (use-&gt;Opcode() == Op_EncodeISOArray) {
3238         if (use-&gt;in(MemNode::Memory) == n || use-&gt;in(3) == n) {
3239           // EncodeISOArray overwrites destination array
3240           memnode_worklist.append_if_missing(use);
3241         }
3242       } else if (use-&gt;Opcode() == Op_Return) {
3243         assert(_compile-&gt;tf()-&gt;returns_value_type_as_fields(), &quot;must return a value type&quot;);
3244         // Get ValueKlass by removing the tag bit from the metadata pointer
3245         Node* klass = use-&gt;in(TypeFunc::Parms);
3246         intptr_t ptr = igvn-&gt;type(klass)-&gt;isa_rawptr()-&gt;get_con();
3247         clear_nth_bit(ptr, 0);
3248         assert(Metaspace::contains((void*)ptr), &quot;should be klass&quot;);
3249         assert(((ValueKlass*)ptr)-&gt;contains_oops(), &quot;returned value type must contain a reference field&quot;);
3250       } else {
3251         uint op = use-&gt;Opcode();
3252         if ((op == Op_StrCompressedCopy || op == Op_StrInflatedCopy) &amp;&amp;
3253             (use-&gt;in(MemNode::Memory) == n)) {
3254           // They overwrite memory edge corresponding to destination array,
3255           memnode_worklist.append_if_missing(use);
3256         } else if (!(op == Op_CmpP || op == Op_Conv2B ||
3257               op == Op_CastP2X || op == Op_StoreCM ||
3258               op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||
3259               op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||
3260               op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||
3261               op == Op_SubTypeCheck || op == Op_ValueType ||
3262               BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(use))) {
3263           n-&gt;dump();
3264           use-&gt;dump();
3265           assert(false, &quot;EA: missing allocation reference path&quot;);
3266         }
3267 #endif
3268       }
3269     }
3270 
3271   }
3272 
3273   // Go over all ArrayCopy nodes and if one of the inputs has a unique
3274   // type, record it in the ArrayCopy node so we know what memory this
3275   // node uses/modified.
3276   for (int next = 0; next &lt; arraycopy_worklist.length(); next++) {
3277     ArrayCopyNode* ac = arraycopy_worklist.at(next);
3278     Node* dest = ac-&gt;in(ArrayCopyNode::Dest);
3279     if (dest-&gt;is_AddP()) {
3280       dest = get_addp_base(dest);
3281     }
3282     JavaObjectNode* jobj = unique_java_object(dest);
3283     if (jobj != NULL) {
3284       Node *base = get_map(jobj-&gt;idx());
3285       if (base != NULL) {
3286         const TypeOopPtr *base_t = _igvn-&gt;type(base)-&gt;isa_oopptr();
3287         ac-&gt;_dest_type = base_t;
3288       }
3289     }
3290     Node* src = ac-&gt;in(ArrayCopyNode::Src);
3291     if (src-&gt;is_AddP()) {
3292       src = get_addp_base(src);
3293     }
3294     jobj = unique_java_object(src);
3295     if (jobj != NULL) {
3296       Node* base = get_map(jobj-&gt;idx());
3297       if (base != NULL) {
3298         const TypeOopPtr *base_t = _igvn-&gt;type(base)-&gt;isa_oopptr();
3299         ac-&gt;_src_type = base_t;
3300       }
3301     }
3302   }
3303 
3304   // New alias types were created in split_AddP().
3305   uint new_index_end = (uint) _compile-&gt;num_alias_types();
3306   assert(unique_old == _compile-&gt;unique(), &quot;there should be no new ideal nodes after Phase 1&quot;);
3307 
3308   //  Phase 2:  Process MemNode&#39;s from memnode_worklist. compute new address type and
3309   //            compute new values for Memory inputs  (the Memory inputs are not
3310   //            actually updated until phase 4.)
3311   if (memnode_worklist.length() == 0)
3312     return;  // nothing to do
3313   while (memnode_worklist.length() != 0) {
3314     Node *n = memnode_worklist.pop();
3315     if (visited.test_set(n-&gt;_idx))
3316       continue;
3317     if (n-&gt;is_Phi() || n-&gt;is_ClearArray()) {
3318       // we don&#39;t need to do anything, but the users must be pushed
3319     } else if (n-&gt;is_MemBar()) { // Initialize, MemBar nodes
3320       // we don&#39;t need to do anything, but the users must be pushed
3321       n = n-&gt;as_MemBar()-&gt;proj_out_or_null(TypeFunc::Memory);
3322       if (n == NULL)
3323         continue;
3324     } else if (n-&gt;Opcode() == Op_StrCompressedCopy ||
3325                n-&gt;Opcode() == Op_EncodeISOArray) {
3326       // get the memory projection
3327       n = n-&gt;find_out_with(Op_SCMemProj);
3328       assert(n != NULL &amp;&amp; n-&gt;Opcode() == Op_SCMemProj, &quot;memory projection required&quot;);
3329     } else if (n-&gt;is_CallLeaf() &amp;&amp; n-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
3330                strcmp(n-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_value&quot;) == 0) {
3331       n = n-&gt;as_CallLeaf()-&gt;proj_out(TypeFunc::Memory);
3332     } else {
3333       assert(n-&gt;is_Mem(), &quot;memory node required.&quot;);
3334       Node *addr = n-&gt;in(MemNode::Address);
3335       const Type *addr_t = igvn-&gt;type(addr);
3336       if (addr_t == Type::TOP)
3337         continue;
3338       assert (addr_t-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
3339       int alias_idx = _compile-&gt;get_alias_index(addr_t-&gt;is_ptr());
3340       assert ((uint)alias_idx &lt; new_index_end, &quot;wrong alias index&quot;);
3341       Node *mem = find_inst_mem(n-&gt;in(MemNode::Memory), alias_idx, orig_phis);
3342       if (_compile-&gt;failing()) {
3343         return;
3344       }
3345       if (mem != n-&gt;in(MemNode::Memory)) {
3346         // We delay the memory edge update since we need old one in
3347         // MergeMem code below when instances memory slices are separated.
3348         set_map(n, mem);
3349       }
3350       if (n-&gt;is_Load()) {
3351         continue;  // don&#39;t push users
3352       } else if (n-&gt;is_LoadStore()) {
3353         // get the memory projection
3354         n = n-&gt;find_out_with(Op_SCMemProj);
3355         assert(n != NULL &amp;&amp; n-&gt;Opcode() == Op_SCMemProj, &quot;memory projection required&quot;);
3356       }
3357     }
3358     // push user on appropriate worklist
3359     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3360       Node *use = n-&gt;fast_out(i);
3361       if (use-&gt;is_Phi() || use-&gt;is_ClearArray()) {
3362         memnode_worklist.append_if_missing(use);
3363       } else if (use-&gt;is_Mem() &amp;&amp; use-&gt;in(MemNode::Memory) == n) {
3364         if (use-&gt;Opcode() == Op_StoreCM) // Ignore cardmark stores
3365           continue;
3366         memnode_worklist.append_if_missing(use);
3367       } else if (use-&gt;is_MemBar()) {
3368         if (use-&gt;in(TypeFunc::Memory) == n) { // Ignore precedent edge
3369           memnode_worklist.append_if_missing(use);
3370         }
3371 #ifdef ASSERT
3372       } else if (use-&gt;is_Mem()) {
3373         assert(use-&gt;in(MemNode::Memory) != n, &quot;EA: missing memory path&quot;);
3374       } else if (use-&gt;is_MergeMem()) {
3375         assert(_mergemem_worklist.contains(use-&gt;as_MergeMem()), &quot;EA: missing MergeMem node in the worklist&quot;);
3376       } else if (use-&gt;Opcode() == Op_EncodeISOArray) {
3377         if (use-&gt;in(MemNode::Memory) == n || use-&gt;in(3) == n) {
3378           // EncodeISOArray overwrites destination array
3379           memnode_worklist.append_if_missing(use);
3380         }
3381       } else if (use-&gt;is_CallLeaf() &amp;&amp; use-&gt;as_CallLeaf()-&gt;_name != NULL &amp;&amp;
3382                  strcmp(use-&gt;as_CallLeaf()-&gt;_name, &quot;store_unknown_value&quot;) == 0) {
3383         // store_unknown_value overwrites destination array
3384         memnode_worklist.append_if_missing(use);
3385       } else {
3386         uint op = use-&gt;Opcode();
3387         if ((use-&gt;in(MemNode::Memory) == n) &amp;&amp;
3388             (op == Op_StrCompressedCopy || op == Op_StrInflatedCopy)) {
3389           // They overwrite memory edge corresponding to destination array,
3390           memnode_worklist.append_if_missing(use);
3391         } else if (!(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(use) ||
3392               op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||
3393               op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||
3394               op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {
3395           n-&gt;dump();
3396           use-&gt;dump();
3397           assert(false, &quot;EA: missing memory path&quot;);
3398         }
3399 #endif
3400       }
3401     }
3402   }
3403 
3404   //  Phase 3:  Process MergeMem nodes from mergemem_worklist.
3405   //            Walk each memory slice moving the first node encountered of each
3406   //            instance type to the input corresponding to its alias index.
3407   uint length = _mergemem_worklist.length();
3408   for( uint next = 0; next &lt; length; ++next ) {
3409     MergeMemNode* nmm = _mergemem_worklist.at(next);
3410     assert(!visited.test_set(nmm-&gt;_idx), &quot;should not be visited before&quot;);
3411     // Note: we don&#39;t want to use MergeMemStream here because we only want to
3412     // scan inputs which exist at the start, not ones we add during processing.
3413     // Note 2: MergeMem may already contains instance memory slices added
3414     // during find_inst_mem() call when memory nodes were processed above.
3415     igvn-&gt;hash_delete(nmm);
3416     uint nslices = MIN2(nmm-&gt;req(), new_index_start);
3417     for (uint i = Compile::AliasIdxRaw+1; i &lt; nslices; i++) {
3418       Node* mem = nmm-&gt;in(i);
3419       Node* cur = NULL;
3420       if (mem == NULL || mem-&gt;is_top())
3421         continue;
3422       // First, update mergemem by moving memory nodes to corresponding slices
3423       // if their type became more precise since this mergemem was created.
3424       while (mem-&gt;is_Mem()) {
3425         const Type *at = igvn-&gt;type(mem-&gt;in(MemNode::Address));
3426         if (at != Type::TOP) {
3427           assert (at-&gt;isa_ptr() != NULL, &quot;pointer type required.&quot;);
3428           uint idx = (uint)_compile-&gt;get_alias_index(at-&gt;is_ptr());
3429           if (idx == i) {
3430             if (cur == NULL)
3431               cur = mem;
3432           } else {
3433             if (idx &gt;= nmm-&gt;req() || nmm-&gt;is_empty_memory(nmm-&gt;in(idx))) {
3434               nmm-&gt;set_memory_at(idx, mem);
3435             }
3436           }
3437         }
3438         mem = mem-&gt;in(MemNode::Memory);
3439       }
3440       nmm-&gt;set_memory_at(i, (cur != NULL) ? cur : mem);
3441       // Find any instance of the current type if we haven&#39;t encountered
3442       // already a memory slice of the instance along the memory chain.
3443       for (uint ni = new_index_start; ni &lt; new_index_end; ni++) {
3444         if((uint)_compile-&gt;get_general_index(ni) == i) {
3445           Node *m = (ni &gt;= nmm-&gt;req()) ? nmm-&gt;empty_memory() : nmm-&gt;in(ni);
3446           if (nmm-&gt;is_empty_memory(m)) {
3447             Node* result = find_inst_mem(mem, ni, orig_phis);
3448             if (_compile-&gt;failing()) {
3449               return;
3450             }
3451             nmm-&gt;set_memory_at(ni, result);
3452           }
3453         }
3454       }
3455     }
3456     // Find the rest of instances values
3457     for (uint ni = new_index_start; ni &lt; new_index_end; ni++) {
3458       const TypeOopPtr *tinst = _compile-&gt;get_adr_type(ni)-&gt;isa_oopptr();
3459       Node* result = step_through_mergemem(nmm, ni, tinst);
3460       if (result == nmm-&gt;base_memory()) {
3461         // Didn&#39;t find instance memory, search through general slice recursively.
3462         result = nmm-&gt;memory_at(_compile-&gt;get_general_index(ni));
3463         result = find_inst_mem(result, ni, orig_phis);
3464         if (_compile-&gt;failing()) {
3465           return;
3466         }
3467         nmm-&gt;set_memory_at(ni, result);
3468       }
3469     }
3470     igvn-&gt;hash_insert(nmm);
3471     record_for_optimizer(nmm);
3472   }
3473 
3474   //  Phase 4:  Update the inputs of non-instance memory Phis and
3475   //            the Memory input of memnodes
3476   // First update the inputs of any non-instance Phi&#39;s from
3477   // which we split out an instance Phi.  Note we don&#39;t have
3478   // to recursively process Phi&#39;s encountered on the input memory
3479   // chains as is done in split_memory_phi() since they will
3480   // also be processed here.
3481   for (int j = 0; j &lt; orig_phis.length(); j++) {
3482     PhiNode *phi = orig_phis.at(j);
3483     int alias_idx = _compile-&gt;get_alias_index(phi-&gt;adr_type());
3484     igvn-&gt;hash_delete(phi);
3485     for (uint i = 1; i &lt; phi-&gt;req(); i++) {
3486       Node *mem = phi-&gt;in(i);
3487       Node *new_mem = find_inst_mem(mem, alias_idx, orig_phis);
3488       if (_compile-&gt;failing()) {
3489         return;
3490       }
3491       if (mem != new_mem) {
3492         phi-&gt;set_req(i, new_mem);
3493       }
3494     }
3495     igvn-&gt;hash_insert(phi);
3496     record_for_optimizer(phi);
3497   }
3498 
3499   // Update the memory inputs of MemNodes with the value we computed
3500   // in Phase 2 and move stores memory users to corresponding memory slices.
3501   // Disable memory split verification code until the fix for 6984348.
3502   // Currently it produces false negative results since it does not cover all cases.
3503 #if 0 // ifdef ASSERT
3504   visited.Reset();
3505   Node_Stack old_mems(arena, _compile-&gt;unique() &gt;&gt; 2);
3506 #endif
3507   for (uint i = 0; i &lt; ideal_nodes.size(); i++) {
3508     Node*    n = ideal_nodes.at(i);
3509     Node* nmem = get_map(n-&gt;_idx);
3510     assert(nmem != NULL, &quot;sanity&quot;);
3511     if (n-&gt;is_Mem()) {
3512 #if 0 // ifdef ASSERT
3513       Node* old_mem = n-&gt;in(MemNode::Memory);
3514       if (!visited.test_set(old_mem-&gt;_idx)) {
3515         old_mems.push(old_mem, old_mem-&gt;outcnt());
3516       }
3517 #endif
3518       assert(n-&gt;in(MemNode::Memory) != nmem, &quot;sanity&quot;);
3519       if (!n-&gt;is_Load()) {
3520         // Move memory users of a store first.
3521         move_inst_mem(n, orig_phis);
3522       }
3523       // Now update memory input
3524       igvn-&gt;hash_delete(n);
3525       n-&gt;set_req(MemNode::Memory, nmem);
3526       igvn-&gt;hash_insert(n);
3527       record_for_optimizer(n);
3528     } else {
3529       assert(n-&gt;is_Allocate() || n-&gt;is_CheckCastPP() ||
3530              n-&gt;is_AddP() || n-&gt;is_Phi(), &quot;unknown node used for set_map()&quot;);
3531     }
3532   }
3533 #if 0 // ifdef ASSERT
3534   // Verify that memory was split correctly
3535   while (old_mems.is_nonempty()) {
3536     Node* old_mem = old_mems.node();
3537     uint  old_cnt = old_mems.index();
3538     old_mems.pop();
3539     assert(old_cnt == old_mem-&gt;outcnt(), &quot;old mem could be lost&quot;);
3540   }
3541 #endif
3542 }
3543 
3544 #ifndef PRODUCT
3545 static const char *node_type_names[] = {
3546   &quot;UnknownType&quot;,
3547   &quot;JavaObject&quot;,
3548   &quot;LocalVar&quot;,
3549   &quot;Field&quot;,
3550   &quot;Arraycopy&quot;
3551 };
3552 
3553 static const char *esc_names[] = {
3554   &quot;UnknownEscape&quot;,
3555   &quot;NoEscape&quot;,
3556   &quot;ArgEscape&quot;,
3557   &quot;GlobalEscape&quot;
3558 };
3559 
3560 void PointsToNode::dump(bool print_state) const {
3561   NodeType nt = node_type();
3562   tty-&gt;print(&quot;%s &quot;, node_type_names[(int) nt]);
3563   if (print_state) {
3564     EscapeState es = escape_state();
3565     EscapeState fields_es = fields_escape_state();
3566     tty-&gt;print(&quot;%s(%s) &quot;, esc_names[(int)es], esc_names[(int)fields_es]);
3567     if (nt == PointsToNode::JavaObject &amp;&amp; !this-&gt;scalar_replaceable())
3568       tty-&gt;print(&quot;NSR &quot;);
3569   }
3570   if (is_Field()) {
3571     FieldNode* f = (FieldNode*)this;
3572     if (f-&gt;is_oop())
3573       tty-&gt;print(&quot;oop &quot;);
3574     if (f-&gt;offset() &gt; 0)
3575       tty-&gt;print(&quot;+%d &quot;, f-&gt;offset());
3576     tty-&gt;print(&quot;(&quot;);
3577     for (BaseIterator i(f); i.has_next(); i.next()) {
3578       PointsToNode* b = i.get();
3579       tty-&gt;print(&quot; %d%s&quot;, b-&gt;idx(),(b-&gt;is_JavaObject() ? &quot;P&quot; : &quot;&quot;));
3580     }
3581     tty-&gt;print(&quot; )&quot;);
3582   }
3583   tty-&gt;print(&quot;[&quot;);
3584   for (EdgeIterator i(this); i.has_next(); i.next()) {
3585     PointsToNode* e = i.get();
3586     tty-&gt;print(&quot; %d%s%s&quot;, e-&gt;idx(),(e-&gt;is_JavaObject() ? &quot;P&quot; : (e-&gt;is_Field() ? &quot;F&quot; : &quot;&quot;)), e-&gt;is_Arraycopy() ? &quot;cp&quot; : &quot;&quot;);
3587   }
3588   tty-&gt;print(&quot; [&quot;);
3589   for (UseIterator i(this); i.has_next(); i.next()) {
3590     PointsToNode* u = i.get();
3591     bool is_base = false;
3592     if (PointsToNode::is_base_use(u)) {
3593       is_base = true;
3594       u = PointsToNode::get_use_node(u)-&gt;as_Field();
3595     }
3596     tty-&gt;print(&quot; %d%s%s&quot;, u-&gt;idx(), is_base ? &quot;b&quot; : &quot;&quot;, u-&gt;is_Arraycopy() ? &quot;cp&quot; : &quot;&quot;);
3597   }
3598   tty-&gt;print(&quot; ]]  &quot;);
3599   if (_node == NULL)
3600     tty-&gt;print_cr(&quot;&lt;null&gt;&quot;);
3601   else
3602     _node-&gt;dump();
3603 }
3604 
3605 void ConnectionGraph::dump(GrowableArray&lt;PointsToNode*&gt;&amp; ptnodes_worklist) {
3606   bool first = true;
3607   int ptnodes_length = ptnodes_worklist.length();
3608   for (int i = 0; i &lt; ptnodes_length; i++) {
3609     PointsToNode *ptn = ptnodes_worklist.at(i);
3610     if (ptn == NULL || !ptn-&gt;is_JavaObject())
3611       continue;
3612     PointsToNode::EscapeState es = ptn-&gt;escape_state();
3613     if ((es != PointsToNode::NoEscape) &amp;&amp; !Verbose) {
3614       continue;
3615     }
3616     Node* n = ptn-&gt;ideal_node();
3617     if (n-&gt;is_Allocate() || (n-&gt;is_CallStaticJava() &amp;&amp;
3618                              n-&gt;as_CallStaticJava()-&gt;is_boxing_method())) {
3619       if (first) {
3620         tty-&gt;cr();
3621         tty-&gt;print(&quot;======== Connection graph for &quot;);
3622         _compile-&gt;method()-&gt;print_short_name();
3623         tty-&gt;cr();
3624         first = false;
3625       }
3626       ptn-&gt;dump();
3627       // Print all locals and fields which reference this allocation
3628       for (UseIterator j(ptn); j.has_next(); j.next()) {
3629         PointsToNode* use = j.get();
3630         if (use-&gt;is_LocalVar()) {
3631           use-&gt;dump(Verbose);
3632         } else if (Verbose) {
3633           use-&gt;dump();
3634         }
3635       }
3636       tty-&gt;cr();
3637     }
3638   }
3639 }
3640 #endif
3641 
3642 void ConnectionGraph::record_for_optimizer(Node *n) {
3643   _igvn-&gt;_worklist.push(n);
3644   _igvn-&gt;add_users_to_worklist(n);
3645 }
    </pre>
  </body>
</html>
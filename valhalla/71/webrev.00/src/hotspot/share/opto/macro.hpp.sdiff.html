<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93 
 94   // Additional data collected during macro expansion
 95   bool _has_locks;
 96 
 97   void expand_allocate(AllocateNode *alloc);
 98   void expand_allocate_array(AllocateArrayNode *alloc);
 99   void expand_allocate_common(AllocateNode* alloc,
100                               Node* length,
101                               const TypeFunc* slow_call_type,
102                               address slow_call_address);
103   void yank_initalize_node(InitializeNode* node);
104   void yank_alloc_node(AllocateNode* alloc);
105   Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);
106   Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);
107   Node* value_type_from_mem(Node* mem, Node* ctl, ciValueKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);
108 
109   bool eliminate_boxing_node(CallStaticJavaNode *boxing);
110   bool eliminate_allocate_node(AllocateNode *alloc);
111   bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints);
112   bool scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints_done);
<span class="line-modified">113   void process_users_of_allocation(CallNode *alloc);</span>
114 
115   void eliminate_gc_barrier(Node *p2x);
116   void mark_eliminated_box(Node* box, Node* obj);
117   void mark_eliminated_locking_nodes(AbstractLockNode *alock);
118   bool eliminate_locking_node(AbstractLockNode *alock);
119   void expand_lock_node(LockNode *lock);
120   void expand_unlock_node(UnlockNode *unlock);
121   void expand_mh_intrinsic_return(CallStaticJavaNode* call);
122 
123   // More helper methods modeled after GraphKit for array copy
124   void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);
125   Node* array_element_address(Node* ary, Node* idx, BasicType elembt);
126   Node* ConvI2L(Node* offset);
127 
128   // helper methods modeled after LibraryCallKit for array copy
129   Node* generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob);
130   Node* generate_slow_guard(Node** ctrl, Node* test, RegionNode* region);
131   Node* generate_fair_guard(Node** ctrl, Node* test, RegionNode* region);
132   void generate_negative_guard(Node** ctrl, Node* index, RegionNode* region);
133   void generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region);
</pre>
</td>
<td>
<hr />
<pre>
 93 
 94   // Additional data collected during macro expansion
 95   bool _has_locks;
 96 
 97   void expand_allocate(AllocateNode *alloc);
 98   void expand_allocate_array(AllocateArrayNode *alloc);
 99   void expand_allocate_common(AllocateNode* alloc,
100                               Node* length,
101                               const TypeFunc* slow_call_type,
102                               address slow_call_address);
103   void yank_initalize_node(InitializeNode* node);
104   void yank_alloc_node(AllocateNode* alloc);
105   Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);
106   Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);
107   Node* value_type_from_mem(Node* mem, Node* ctl, ciValueKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);
108 
109   bool eliminate_boxing_node(CallStaticJavaNode *boxing);
110   bool eliminate_allocate_node(AllocateNode *alloc);
111   bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints);
112   bool scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints_done);
<span class="line-modified">113   void process_users_of_allocation(CallNode *alloc, bool inline_alloc = false);</span>
114 
115   void eliminate_gc_barrier(Node *p2x);
116   void mark_eliminated_box(Node* box, Node* obj);
117   void mark_eliminated_locking_nodes(AbstractLockNode *alock);
118   bool eliminate_locking_node(AbstractLockNode *alock);
119   void expand_lock_node(LockNode *lock);
120   void expand_unlock_node(UnlockNode *unlock);
121   void expand_mh_intrinsic_return(CallStaticJavaNode* call);
122 
123   // More helper methods modeled after GraphKit for array copy
124   void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);
125   Node* array_element_address(Node* ary, Node* idx, BasicType elembt);
126   Node* ConvI2L(Node* offset);
127 
128   // helper methods modeled after LibraryCallKit for array copy
129   Node* generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob);
130   Node* generate_slow_guard(Node** ctrl, Node* test, RegionNode* region);
131   Node* generate_fair_guard(Node** ctrl, Node* test, RegionNode* region);
132   void generate_negative_guard(Node** ctrl, Node* index, RegionNode* region);
133   void generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region);
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
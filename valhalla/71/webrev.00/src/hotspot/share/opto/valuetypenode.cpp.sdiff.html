<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/valuetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/valuetypenode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;opto/rootnode.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the values type to handle control flow merges involving multiple value types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 ValueTypeBaseNode* ValueTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);
 38   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(value_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
<span class="line-modified"> 50     if (type-&gt;is_valuetype() &amp;&amp; value-&gt;isa_ValueType()) {</span>
 51       // Handle flattened value type fields recursively
<span class="line-modified"> 52       value = value-&gt;as_ValueType()-&gt;clone_with_phis(gvn, region);</span>
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the ValueBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see ValueBaseTypeNode::clone_with_phis).
 66 bool ValueTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
</pre>
<hr />
<pre>
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 ValueTypeBaseNode* ValueTypeBaseNode::merge_with(PhaseGVN* gvn, const ValueTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
<span class="line-modified"> 98     if (val1-&gt;is_ValueType()) {</span>
<span class="line-modified"> 99       val1-&gt;as_ValueType()-&gt;merge_with(gvn, val2-&gt;as_ValueType(), pnum, transform);</span>
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       assert(!val2-&gt;is_ValueType(), &quot;inconsistent merge values&quot;);
103       val1-&gt;set_req(pnum, val2);
104     }
105     if (transform) {
106       set_field_value(i, gvn-&gt;transform(val1));
107       gvn-&gt;record_for_igvn(val1);
108     }
109   }
110   return this;
111 }
112 
113 // Adds a new merge path to a valuetype node with phi inputs
114 void ValueTypeBaseNode::add_new_path(Node* region) {
115   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
116 
117   PhiNode* phi = get_oop()-&gt;as_Phi();
118   phi-&gt;add_req(NULL);
119   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
</pre>
<hr />
<pre>
236   Unique_Node_List worklist;
237   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
238     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
239     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
240       int nb = 0;
241       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
242         // Value type is allocated with a constant oop, link it directly
243         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
244         igvn-&gt;rehash_node_delayed(sfpt);
245       } else {
246         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
247       }
248       --i; imax -= nb;
249     }
250   }
251   // Now scalarize non-flattened fields
252   for (uint i = 0; i &lt; worklist.size(); ++i) {
253     Node* vt = worklist.at(i);
254     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(igvn);
255   }

256 }
257 
258 const TypePtr* ValueTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
259   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
260   const TypePtr* adr_type = NULL;
261   bool is_array = ary_type != NULL;
262   if ((decorators &amp; C2_MISMATCHED) != 0) {
263     adr_type = TypeRawPtr::BOTTOM;
264   } else if (is_array) {
265     // In the case of a flattened value type array, each field has its own slice
266     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
267   } else {
268     ciField* field = holder-&gt;get_field_by_offset(offset, false);
269     assert(field != NULL, &quot;field not found&quot;);
270     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
271   }
272   return adr_type;
273 }
274 
275 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
</pre>
<hr />
<pre>
347         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);
348         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
349       }
350       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
351     } else {
352       // Store field value to memory
353       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
354       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
355       BasicType bt = type2field[ft-&gt;basic_type()];
356       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
357       const Type* val_type = Type::get_const_type(ft);
358       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
359       if (ary_type != NULL) {
360         decorators |= IS_ARRAY;
361       }
362       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
363     }
364   }
365 }
366 
<span class="line-modified">367 ValueTypeBaseNode* ValueTypeBaseNode::allocate(GraphKit* kit, bool safe_for_replace) {</span>

368   // Check if value type is already allocated
369   Node* null_ctl = kit-&gt;top();
370   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
371   if (null_ctl-&gt;is_top()) {
372     // Value type is allocated
<span class="line-modified">373     return this;</span>
374   }
375   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
376   RegionNode* region = new RegionNode(3);
377 
378   // Oop is non-NULL, use it
379   region-&gt;init_req(1, kit-&gt;control());
380   PhiNode* oop = PhiNode::make(region, not_null_oop, value_ptr());
381   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
382   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
383 
384   int bci = kit-&gt;bci();
385   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
386   {
387     // Oop is NULL, allocate and initialize buffer
388     PreserveJVMState pjvms(kit);
389     // Propagate re-execution state and bci
390     kit-&gt;set_bci(bci);
391     kit-&gt;jvms()-&gt;set_bci(bci);
392     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
393     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
413   kit-&gt;set_control(kit-&gt;gvn().transform(region));
414   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
415   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
416   kit-&gt;record_for_igvn(region);
417   kit-&gt;record_for_igvn(oop);
418   kit-&gt;record_for_igvn(io);
419   kit-&gt;record_for_igvn(mem);
420 
421   // Use cloned ValueTypeNode to propagate oop from now on
422   Node* res_oop = kit-&gt;gvn().transform(oop);
423   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
424   vt-&gt;set_oop(res_oop);
425   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
426   if (safe_for_replace) {
427     kit-&gt;replace_in_map(this, vt);
428   }
429   // ValueTypeNode::remove_redundant_allocations piggybacks on split if.
430   // Make sure it gets a chance to remove this allocation.
431   kit-&gt;C-&gt;set_has_split_ifs(true);
432   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
<span class="line-modified">433   return vt;</span>
434 }
435 
436 bool ValueTypeBaseNode::is_allocated(PhaseGVN* phase) const {
437   Node* oop = get_oop();
438   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
439   return !oop_type-&gt;maybe_null();
440 }
441 
442 // When a call returns multiple values, it has several result
443 // projections, one per field. Replacing the result of the call by a
444 // value type node (after late inlining) requires that for each result
445 // projection, we find the corresponding value type field.
446 void ValueTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
447   ciValueKlass* vk = value_klass();
448   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
449     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
450     uint con = pn-&gt;_con;
451     if (con &gt;= TypeFunc::Parms+1) {
452       uint field_nb = con - (TypeFunc::Parms+1);
453       int extra = 0;
</pre>
<hr />
<pre>
464         assert(field-&gt;as_ValueType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
465         field = field-&gt;as_ValueType()-&gt;get_oop();
466       }
467       C-&gt;gvn_replace_by(pn, field);
468       C-&gt;initial_gvn()-&gt;hash_delete(pn);
469       pn-&gt;set_req(0, C-&gt;top());
470       --i; --imax;
471     }
472   }
473 }
474 
475 Node* ValueTypeBaseNode::allocate_fields(GraphKit* kit) {
476   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
477   for (uint i = 0; i &lt; field_count(); i++) {
478      ValueTypeNode* value = field_value(i)-&gt;isa_ValueType();
479      if (field_is_flattened(i)) {
480        // Flattened value type field
481        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
482      } else if (value != NULL) {
483        // Non-flattened value type field
<span class="line-modified">484        vt-&gt;set_field_value(i, value-&gt;allocate(kit));</span>
485      }
486   }
487   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
488   kit-&gt;replace_in_map(this, vt);
489   return vt;
490 }
491 
492 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
493   // Create a new ValueTypeNode with uninitialized values and NULL oop
494   return new ValueTypeNode(vk, gvn.zerocon(T_VALUETYPE));
495 }
496 
497 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
498   // Returns the constant oop of the default value type allocation
499   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
500 }
501 
502 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
503   // Create a new ValueTypeNode with default values
504   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
</pre>
<hr />
<pre>
701   intptr_t bits = tk-&gt;get_con();
702   set_nth_bit(bits, 0);
703   return gvn.makecon(TypeRawPtr::make((address)bits));
704 }
705 
706 void ValueTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
707   for (uint i = 0; i &lt; field_count(); i++) {
708     int sig_offset = (*sig)._offset;
709     uint idx = field_index(sig_offset - base_offset);
710     Node* arg = field_value(idx);
711 
712     if (field_is_flattened(idx)) {
713       // Flattened value type field
714       ValueTypeNode* vt = arg-&gt;as_ValueType();
715       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;value_klass()-&gt;first_field_offset());
716     } else {
717       if (arg-&gt;is_ValueType()) {
718         // Non-flattened value type field
719         ValueTypeNode* vt = arg-&gt;as_ValueType();
720         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;value type field should be allocated on return&quot;);
<span class="line-modified">721         arg = vt-&gt;allocate(kit)-&gt;get_oop();</span>
722       }
723       // Initialize call/return arguments
724       BasicType bt = field_type(i)-&gt;basic_type();
725       n-&gt;init_req(base_input++, arg);
726       if (type2size[bt] == 2) {
727         n-&gt;init_req(base_input++, kit-&gt;top());
728       }
729       // Skip reserved arguments
730       while (SigEntry::next_is_reserved(sig, bt)) {
731         n-&gt;init_req(base_input++, kit-&gt;top());
732         if (type2size[bt] == 2) {
733           n-&gt;init_req(base_input++, kit-&gt;top());
734         }
735       }
736     }
737   }
738 }
739 
740 void ValueTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
741   PhaseGVN&amp; gvn = kit-&gt;gvn();
</pre>
<hr />
<pre>
875         // The value type is already allocated but still connected to an AllocateNode.
876         // This can happen with late inlining when we first allocate a value type argument
877         // but later decide to inline the call with the callee code also allocating.
878         res_dom = get_oop();
879       } else {
880         // Search for a dominating allocation of the same value type
881         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
882           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
883           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::ValueNode) == this) {
884             Node* res_other = alloc_other-&gt;result_cast();
885             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
886                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
887               res_dom = res_other;
888             }
889           }
890         }
891       }
892       if (res_dom != res) {
893         // Move users to dominating allocation
894         igvn-&gt;replace_node(res, res_dom);
<span class="line-modified">895         // The result of the dominated allocation is now unused and will be</span>
<span class="line-modified">896         // removed later in AllocateNode::Ideal() to not confuse loop opts.</span>
897         igvn-&gt;record_for_igvn(alloc);
<span class="line-removed">898 #ifdef ASSERT</span>
<span class="line-removed">899         if (PrintEliminateAllocations) {</span>
<span class="line-removed">900           tty-&gt;print(&quot;++++ Eliminated: %d Allocate &quot;, alloc-&gt;_idx);</span>
<span class="line-removed">901           dump_spec(tty);</span>
<span class="line-removed">902           tty-&gt;cr();</span>
<span class="line-removed">903         }</span>
<span class="line-removed">904 #endif</span>
905       }
906     }
907   }
908 
909   // Process users
910   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
911     Node* out = fast_out(i);
912     if (out-&gt;is_ValueType()) {
913       // Recursively process value type users
914       out-&gt;as_ValueType()-&gt;remove_redundant_allocations(igvn, phase);
915       --i; --imax;
916     } else if (out-&gt;isa_Allocate() != NULL) {
917       // Unlink AllocateNode
918       assert(out-&gt;in(AllocateNode::ValueNode) == this, &quot;should be linked&quot;);
919       igvn-&gt;replace_input_of(out, AllocateNode::ValueNode, igvn-&gt;C-&gt;top());
920       --i; --imax;
921     } else {
922 #ifdef ASSERT
923       // The value type should not have any other users at this time
924       out-&gt;dump();
925       assert(false, &quot;unexpected user of value type&quot;);
926 #endif
927     }
928   }
929   igvn-&gt;remove_dead_node(this);
930 }
<span class="line-removed">931 </span>
<span class="line-removed">932 ValueTypePtrNode* ValueTypePtrNode::make_from_value_type(GraphKit* kit, ValueTypeNode* vt) {</span>
<span class="line-removed">933   Node* oop = vt-&gt;allocate(kit)-&gt;get_oop();</span>
<span class="line-removed">934   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vt-&gt;value_klass(), oop);</span>
<span class="line-removed">935   for (uint i = Oop+1; i &lt; vt-&gt;req(); i++) {</span>
<span class="line-removed">936     vtptr-&gt;init_req(i, vt-&gt;in(i));</span>
<span class="line-removed">937   }</span>
<span class="line-removed">938   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">939 }</span>
<span class="line-removed">940 </span>
<span class="line-removed">941 ValueTypePtrNode* ValueTypePtrNode::make_from_oop(GraphKit* kit, Node* oop) {</span>
<span class="line-removed">942   // Create and initialize a ValueTypePtrNode by loading all field</span>
<span class="line-removed">943   // values from a heap-allocated version and also save the oop.</span>
<span class="line-removed">944   ciValueKlass* vk = kit-&gt;gvn().type(oop)-&gt;value_klass();</span>
<span class="line-removed">945   ValueTypePtrNode* vtptr = new ValueTypePtrNode(vk, oop);</span>
<span class="line-removed">946   vtptr-&gt;load(kit, oop, oop, vk);</span>
<span class="line-removed">947   return kit-&gt;gvn().transform(vtptr)-&gt;as_ValueTypePtr();</span>
<span class="line-removed">948 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;opto/rootnode.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;opto/phaseX.hpp&quot;
 33 
 34 // Clones the values type to handle control flow merges involving multiple value types.
 35 // The inputs are replaced by PhiNodes to represent the merged values for the given region.
 36 ValueTypeBaseNode* ValueTypeBaseNode::clone_with_phis(PhaseGVN* gvn, Node* region) {
 37   assert(!has_phi_inputs(region), &quot;already cloned with phis&quot;);
 38   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
 39 
 40   // Create a PhiNode for merging the oop values
 41   const Type* phi_type = Type::get_const_type(value_klass());
 42   PhiNode* oop = PhiNode::make(region, vt-&gt;get_oop(), phi_type);
 43   gvn-&gt;set_type(oop, phi_type);
 44   vt-&gt;set_oop(oop);
 45 
 46   // Create a PhiNode each for merging the field values
 47   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
 48     ciType* type = vt-&gt;field_type(i);
 49     Node*  value = vt-&gt;field_value(i);
<span class="line-modified"> 50     if (value-&gt;is_ValueTypeBase()) {</span>
 51       // Handle flattened value type fields recursively
<span class="line-modified"> 52       value = value-&gt;as_ValueTypeBase()-&gt;clone_with_phis(gvn, region);</span>
 53     } else {
 54       phi_type = Type::get_const_type(type);
 55       value = PhiNode::make(region, value, phi_type);
 56       gvn-&gt;set_type(value, phi_type);
 57     }
 58     vt-&gt;set_field_value(i, value);
 59   }
 60   gvn-&gt;set_type(vt, vt-&gt;bottom_type());
 61   return vt;
 62 }
 63 
 64 // Checks if the inputs of the ValueBaseTypeNode were replaced by PhiNodes
 65 // for the given region (see ValueBaseTypeNode::clone_with_phis).
 66 bool ValueTypeBaseNode::has_phi_inputs(Node* region) {
 67   // Check oop input
 68   bool result = get_oop()-&gt;is_Phi() &amp;&amp; get_oop()-&gt;as_Phi()-&gt;region() == region;
 69 #ifdef ASSERT
 70   if (result) {
 71     // Check all field value inputs for consistency
 72     for (uint i = Oop; i &lt; field_count(); ++i) {
</pre>
<hr />
<pre>
 78       }
 79     }
 80   }
 81 #endif
 82   return result;
 83 }
 84 
 85 // Merges &#39;this&#39; with &#39;other&#39; by updating the input PhiNodes added by &#39;clone_with_phis&#39;
 86 ValueTypeBaseNode* ValueTypeBaseNode::merge_with(PhaseGVN* gvn, const ValueTypeBaseNode* other, int pnum, bool transform) {
 87   // Merge oop inputs
 88   PhiNode* phi = get_oop()-&gt;as_Phi();
 89   phi-&gt;set_req(pnum, other-&gt;get_oop());
 90   if (transform) {
 91     set_oop(gvn-&gt;transform(phi));
 92     gvn-&gt;record_for_igvn(phi);
 93   }
 94   // Merge field values
 95   for (uint i = 0; i &lt; field_count(); ++i) {
 96     Node* val1 =        field_value(i);
 97     Node* val2 = other-&gt;field_value(i);
<span class="line-modified"> 98     if (val1-&gt;is_ValueTypeBase()) {</span>
<span class="line-modified"> 99       val1-&gt;as_ValueTypeBase()-&gt;merge_with(gvn, val2-&gt;as_ValueTypeBase(), pnum, transform);</span>
100     } else {
101       assert(val1-&gt;is_Phi(), &quot;must be a phi node&quot;);
102       assert(!val2-&gt;is_ValueType(), &quot;inconsistent merge values&quot;);
103       val1-&gt;set_req(pnum, val2);
104     }
105     if (transform) {
106       set_field_value(i, gvn-&gt;transform(val1));
107       gvn-&gt;record_for_igvn(val1);
108     }
109   }
110   return this;
111 }
112 
113 // Adds a new merge path to a valuetype node with phi inputs
114 void ValueTypeBaseNode::add_new_path(Node* region) {
115   assert(has_phi_inputs(region), &quot;must have phi inputs&quot;);
116 
117   PhiNode* phi = get_oop()-&gt;as_Phi();
118   phi-&gt;add_req(NULL);
119   assert(phi-&gt;req() == region-&gt;req(), &quot;must be same size as region&quot;);
</pre>
<hr />
<pre>
236   Unique_Node_List worklist;
237   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
238     SafePointNode* sfpt = fast_out(i)-&gt;isa_SafePoint();
239     if (sfpt != NULL &amp;&amp; !sfpt-&gt;is_CallLeaf() &amp;&amp; (!sfpt-&gt;is_Call() || sfpt-&gt;as_Call()-&gt;has_debug_use(this))) {
240       int nb = 0;
241       if (is_allocated(igvn) &amp;&amp; get_oop()-&gt;is_Con()) {
242         // Value type is allocated with a constant oop, link it directly
243         nb = sfpt-&gt;replace_edges_in_range(this, get_oop(), sfpt-&gt;jvms()-&gt;debug_start(), sfpt-&gt;jvms()-&gt;debug_end());
244         igvn-&gt;rehash_node_delayed(sfpt);
245       } else {
246         nb = make_scalar_in_safepoint(igvn, worklist, sfpt);
247       }
248       --i; imax -= nb;
249     }
250   }
251   // Now scalarize non-flattened fields
252   for (uint i = 0; i &lt; worklist.size(); ++i) {
253     Node* vt = worklist.at(i);
254     vt-&gt;as_ValueType()-&gt;make_scalar_in_safepoints(igvn);
255   }
<span class="line-added">256   igvn-&gt;record_for_igvn(this);</span>
257 }
258 
259 const TypePtr* ValueTypeBaseNode::field_adr_type(Node* base, int offset, ciInstanceKlass* holder, DecoratorSet decorators, PhaseGVN&amp; gvn) const {
260   const TypeAryPtr* ary_type = gvn.type(base)-&gt;isa_aryptr();
261   const TypePtr* adr_type = NULL;
262   bool is_array = ary_type != NULL;
263   if ((decorators &amp; C2_MISMATCHED) != 0) {
264     adr_type = TypeRawPtr::BOTTOM;
265   } else if (is_array) {
266     // In the case of a flattened value type array, each field has its own slice
267     adr_type = ary_type-&gt;with_field_offset(offset)-&gt;add_offset(Type::OffsetBot);
268   } else {
269     ciField* field = holder-&gt;get_field_by_offset(offset, false);
270     assert(field != NULL, &quot;field not found&quot;);
271     adr_type = gvn.C-&gt;alias_type(field)-&gt;adr_type();
272   }
273   return adr_type;
274 }
275 
276 void ValueTypeBaseNode::load(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, DecoratorSet decorators) {
</pre>
<hr />
<pre>
348         assert(!kit-&gt;gvn().type(value)-&gt;maybe_null(), &quot;should never be null&quot;);
349         value = ValueTypeNode::make_from_oop(kit, value, ft-&gt;as_value_klass());
350       }
351       value-&gt;as_ValueType()-&gt;store_flattened(kit, base, ptr, holder, offset, decorators);
352     } else {
353       // Store field value to memory
354       const TypePtr* adr_type = field_adr_type(base, offset, holder, decorators, kit-&gt;gvn());
355       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
356       BasicType bt = type2field[ft-&gt;basic_type()];
357       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
358       const Type* val_type = Type::get_const_type(ft);
359       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
360       if (ary_type != NULL) {
361         decorators |= IS_ARRAY;
362       }
363       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
364     }
365   }
366 }
367 
<span class="line-modified">368 ValueTypePtrNode* ValueTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {</span>
<span class="line-added">369   assert(is_ValueType(), &quot;sanity&quot;);</span>
370   // Check if value type is already allocated
371   Node* null_ctl = kit-&gt;top();
372   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
373   if (null_ctl-&gt;is_top()) {
374     // Value type is allocated
<span class="line-modified">375     return kit-&gt;gvn().transform(new ValueTypePtrNode(this))-&gt;as_ValueTypePtr();</span>
376   }
377   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
378   RegionNode* region = new RegionNode(3);
379 
380   // Oop is non-NULL, use it
381   region-&gt;init_req(1, kit-&gt;control());
382   PhiNode* oop = PhiNode::make(region, not_null_oop, value_ptr());
383   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
384   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
385 
386   int bci = kit-&gt;bci();
387   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
388   {
389     // Oop is NULL, allocate and initialize buffer
390     PreserveJVMState pjvms(kit);
391     // Propagate re-execution state and bci
392     kit-&gt;set_bci(bci);
393     kit-&gt;jvms()-&gt;set_bci(bci);
394     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
395     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
415   kit-&gt;set_control(kit-&gt;gvn().transform(region));
416   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
417   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
418   kit-&gt;record_for_igvn(region);
419   kit-&gt;record_for_igvn(oop);
420   kit-&gt;record_for_igvn(io);
421   kit-&gt;record_for_igvn(mem);
422 
423   // Use cloned ValueTypeNode to propagate oop from now on
424   Node* res_oop = kit-&gt;gvn().transform(oop);
425   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
426   vt-&gt;set_oop(res_oop);
427   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
428   if (safe_for_replace) {
429     kit-&gt;replace_in_map(this, vt);
430   }
431   // ValueTypeNode::remove_redundant_allocations piggybacks on split if.
432   // Make sure it gets a chance to remove this allocation.
433   kit-&gt;C-&gt;set_has_split_ifs(true);
434   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
<span class="line-modified">435   return kit-&gt;gvn().transform(new ValueTypePtrNode(vt))-&gt;as_ValueTypePtr();</span>
436 }
437 
438 bool ValueTypeBaseNode::is_allocated(PhaseGVN* phase) const {
439   Node* oop = get_oop();
440   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
441   return !oop_type-&gt;maybe_null();
442 }
443 
444 // When a call returns multiple values, it has several result
445 // projections, one per field. Replacing the result of the call by a
446 // value type node (after late inlining) requires that for each result
447 // projection, we find the corresponding value type field.
448 void ValueTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
449   ciValueKlass* vk = value_klass();
450   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
451     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
452     uint con = pn-&gt;_con;
453     if (con &gt;= TypeFunc::Parms+1) {
454       uint field_nb = con - (TypeFunc::Parms+1);
455       int extra = 0;
</pre>
<hr />
<pre>
466         assert(field-&gt;as_ValueType()-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);
467         field = field-&gt;as_ValueType()-&gt;get_oop();
468       }
469       C-&gt;gvn_replace_by(pn, field);
470       C-&gt;initial_gvn()-&gt;hash_delete(pn);
471       pn-&gt;set_req(0, C-&gt;top());
472       --i; --imax;
473     }
474   }
475 }
476 
477 Node* ValueTypeBaseNode::allocate_fields(GraphKit* kit) {
478   ValueTypeBaseNode* vt = clone()-&gt;as_ValueTypeBase();
479   for (uint i = 0; i &lt; field_count(); i++) {
480      ValueTypeNode* value = field_value(i)-&gt;isa_ValueType();
481      if (field_is_flattened(i)) {
482        // Flattened value type field
483        vt-&gt;set_field_value(i, value-&gt;allocate_fields(kit));
484      } else if (value != NULL) {
485        // Non-flattened value type field
<span class="line-modified">486        vt-&gt;set_field_value(i, value-&gt;buffer(kit));</span>
487      }
488   }
489   vt = kit-&gt;gvn().transform(vt)-&gt;as_ValueTypeBase();
490   kit-&gt;replace_in_map(this, vt);
491   return vt;
492 }
493 
494 ValueTypeNode* ValueTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciValueKlass* vk) {
495   // Create a new ValueTypeNode with uninitialized values and NULL oop
496   return new ValueTypeNode(vk, gvn.zerocon(T_VALUETYPE));
497 }
498 
499 Node* ValueTypeNode::default_oop(PhaseGVN&amp; gvn, ciValueKlass* vk) {
500   // Returns the constant oop of the default value type allocation
501   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_value_instance()));
502 }
503 
504 ValueTypeNode* ValueTypeNode::make_default(PhaseGVN&amp; gvn, ciValueKlass* vk) {
505   // Create a new ValueTypeNode with default values
506   ValueTypeNode* vt = new ValueTypeNode(vk, default_oop(gvn, vk));
</pre>
<hr />
<pre>
703   intptr_t bits = tk-&gt;get_con();
704   set_nth_bit(bits, 0);
705   return gvn.makecon(TypeRawPtr::make((address)bits));
706 }
707 
708 void ValueTypeNode::pass_fields(GraphKit* kit, Node* n, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset) {
709   for (uint i = 0; i &lt; field_count(); i++) {
710     int sig_offset = (*sig)._offset;
711     uint idx = field_index(sig_offset - base_offset);
712     Node* arg = field_value(idx);
713 
714     if (field_is_flattened(idx)) {
715       // Flattened value type field
716       ValueTypeNode* vt = arg-&gt;as_ValueType();
717       vt-&gt;pass_fields(kit, n, sig, base_input, sig_offset - vt-&gt;value_klass()-&gt;first_field_offset());
718     } else {
719       if (arg-&gt;is_ValueType()) {
720         // Non-flattened value type field
721         ValueTypeNode* vt = arg-&gt;as_ValueType();
722         assert(n-&gt;Opcode() != Op_Return || vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;value type field should be allocated on return&quot;);
<span class="line-modified">723         arg = vt-&gt;buffer(kit);</span>
724       }
725       // Initialize call/return arguments
726       BasicType bt = field_type(i)-&gt;basic_type();
727       n-&gt;init_req(base_input++, arg);
728       if (type2size[bt] == 2) {
729         n-&gt;init_req(base_input++, kit-&gt;top());
730       }
731       // Skip reserved arguments
732       while (SigEntry::next_is_reserved(sig, bt)) {
733         n-&gt;init_req(base_input++, kit-&gt;top());
734         if (type2size[bt] == 2) {
735           n-&gt;init_req(base_input++, kit-&gt;top());
736         }
737       }
738     }
739   }
740 }
741 
742 void ValueTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, ExtendedSignature&amp; sig, uint&amp; base_input, int base_offset, bool in) {
743   PhaseGVN&amp; gvn = kit-&gt;gvn();
</pre>
<hr />
<pre>
877         // The value type is already allocated but still connected to an AllocateNode.
878         // This can happen with late inlining when we first allocate a value type argument
879         // but later decide to inline the call with the callee code also allocating.
880         res_dom = get_oop();
881       } else {
882         // Search for a dominating allocation of the same value type
883         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
884           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();
885           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::ValueNode) == this) {
886             Node* res_other = alloc_other-&gt;result_cast();
887             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;
888                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {
889               res_dom = res_other;
890             }
891           }
892         }
893       }
894       if (res_dom != res) {
895         // Move users to dominating allocation
896         igvn-&gt;replace_node(res, res_dom);
<span class="line-modified">897         // The result of the dominated allocation is now unused and will be removed</span>
<span class="line-modified">898         // later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.</span>
899         igvn-&gt;record_for_igvn(alloc);







900       }
901     }
902   }
903 
904   // Process users
905   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
906     Node* out = fast_out(i);
907     if (out-&gt;is_ValueType()) {
908       // Recursively process value type users
909       out-&gt;as_ValueType()-&gt;remove_redundant_allocations(igvn, phase);
910       --i; --imax;
911     } else if (out-&gt;isa_Allocate() != NULL) {
912       // Unlink AllocateNode
913       assert(out-&gt;in(AllocateNode::ValueNode) == this, &quot;should be linked&quot;);
914       igvn-&gt;replace_input_of(out, AllocateNode::ValueNode, igvn-&gt;C-&gt;top());
915       --i; --imax;
916     } else {
917 #ifdef ASSERT
918       // The value type should not have any other users at this time
919       out-&gt;dump();
920       assert(false, &quot;unexpected user of value type&quot;);
921 #endif
922     }
923   }
924   igvn-&gt;remove_dead_node(this);
925 }


















</pre>
</td>
</tr>
</table>
<center><a href="parseHelper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valuetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
  36 #include &quot;ci/ciValueKlass.hpp&quot;
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/compilerEvent.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/powerOfTwo.hpp&quot;
  47 
  48 class BlockListBuilder {
  49  private:
  50   Compilation* _compilation;
  51   IRScope*     _scope;
  52 
  53   BlockList    _blocks;                // internal list of all blocks
  54   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  55 
  56   // fields used by mark_loops
  57   ResourceBitMap _active;              // for iteration of control flow graph
  58   ResourceBitMap _visited;             // for iteration of control flow graph
  59   intArray       _loop_map;            // caches the information if a block is contained in a loop
  60   int            _next_loop_index;     // next free loop number
  61   int            _next_block_number;   // for reverse postorder numbering of blocks
  62 
  63   // accessors
  64   Compilation*  compilation() const              { return _compilation; }
  65   IRScope*      scope() const                    { return _scope; }
  66   ciMethod*     method() const                   { return scope()-&gt;method(); }
  67   XHandlers*    xhandlers() const                { return scope()-&gt;xhandlers(); }
  68 
  69   // unified bailout support
  70   void          bailout(const char* msg) const   { compilation()-&gt;bailout(msg); }
  71   bool          bailed_out() const               { return compilation()-&gt;bailed_out(); }
  72 
  73   // helper functions
  74   BlockBegin* make_block_at(int bci, BlockBegin* predecessor);
  75   void handle_exceptions(BlockBegin* current, int cur_bci);
  76   void handle_jsr(BlockBegin* current, int sr_bci, int next_bci);
  77   void store_one(BlockBegin* current, int local);
  78   void store_two(BlockBegin* current, int local);
  79   void set_entries(int osr_bci);
  80   void set_leaders();
  81 
  82   void make_loop_header(BlockBegin* block);
  83   void mark_loops();
  84   int  mark_loops(BlockBegin* b, bool in_subroutine);
  85 
  86   // debugging
  87 #ifndef PRODUCT
  88   void print();
  89 #endif
  90 
  91  public:
  92   // creation
  93   BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci);
  94 
  95   // accessors for GraphBuilder
  96   BlockList*    bci2block() const                { return _bci2block; }
  97 };
  98 
  99 
 100 // Implementation of BlockListBuilder
 101 
 102 BlockListBuilder::BlockListBuilder(Compilation* compilation, IRScope* scope, int osr_bci)
 103  : _compilation(compilation)
 104  , _scope(scope)
 105  , _blocks(16)
 106  , _bci2block(new BlockList(scope-&gt;method()-&gt;code_size(), NULL))
 107  , _active()         // size not known yet
 108  , _visited()        // size not known yet
 109  , _loop_map() // size not known yet
 110  , _next_loop_index(0)
 111  , _next_block_number(0)
 112 {
 113   set_entries(osr_bci);
 114   set_leaders();
 115   CHECK_BAILOUT();
 116 
 117   mark_loops();
 118   NOT_PRODUCT(if (PrintInitialBlockList) print());
 119 
 120 #ifndef PRODUCT
 121   if (PrintCFGToFile) {
 122     stringStream title;
 123     title.print(&quot;BlockListBuilder &quot;);
 124     scope-&gt;method()-&gt;print_name(&amp;title);
 125     CFGPrinter::print_cfg(_bci2block, title.as_string(), false, false);
 126   }
 127 #endif
 128 }
 129 
 130 
 131 void BlockListBuilder::set_entries(int osr_bci) {
 132   // generate start blocks
 133   BlockBegin* std_entry = make_block_at(0, NULL);
 134   if (scope()-&gt;caller() == NULL) {
 135     std_entry-&gt;set(BlockBegin::std_entry_flag);
 136   }
 137   if (osr_bci != -1) {
 138     BlockBegin* osr_entry = make_block_at(osr_bci, NULL);
 139     osr_entry-&gt;set(BlockBegin::osr_entry_flag);
 140   }
 141 
 142   // generate exception entry blocks
 143   XHandlers* list = xhandlers();
 144   const int n = list-&gt;length();
 145   for (int i = 0; i &lt; n; i++) {
 146     XHandler* h = list-&gt;handler_at(i);
 147     BlockBegin* entry = make_block_at(h-&gt;handler_bci(), NULL);
 148     entry-&gt;set(BlockBegin::exception_entry_flag);
 149     h-&gt;set_entry_block(entry);
 150   }
 151 }
 152 
 153 
 154 BlockBegin* BlockListBuilder::make_block_at(int cur_bci, BlockBegin* predecessor) {
 155   assert(method()-&gt;bci_block_start().at(cur_bci), &quot;wrong block starts of MethodLivenessAnalyzer&quot;);
 156 
 157   BlockBegin* block = _bci2block-&gt;at(cur_bci);
 158   if (block == NULL) {
 159     block = new BlockBegin(cur_bci);
 160     block-&gt;init_stores_to_locals(method()-&gt;max_locals());
 161     _bci2block-&gt;at_put(cur_bci, block);
 162     _blocks.append(block);
 163 
 164     assert(predecessor == NULL || predecessor-&gt;bci() &lt; cur_bci, &quot;targets for backward branches must already exist&quot;);
 165   }
 166 
 167   if (predecessor != NULL) {
 168     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 169       BAILOUT_(&quot;Exception handler can be reached by both normal and exceptional control flow&quot;, block);
 170     }
 171 
 172     predecessor-&gt;add_successor(block);
 173     block-&gt;increment_total_preds();
 174   }
 175 
 176   return block;
 177 }
 178 
 179 
 180 inline void BlockListBuilder::store_one(BlockBegin* current, int local) {
 181   current-&gt;stores_to_locals().set_bit(local);
 182 }
 183 inline void BlockListBuilder::store_two(BlockBegin* current, int local) {
 184   store_one(current, local);
 185   store_one(current, local + 1);
 186 }
 187 
 188 
 189 void BlockListBuilder::handle_exceptions(BlockBegin* current, int cur_bci) {
 190   // Draws edges from a block to its exception handlers
 191   XHandlers* list = xhandlers();
 192   const int n = list-&gt;length();
 193 
 194   for (int i = 0; i &lt; n; i++) {
 195     XHandler* h = list-&gt;handler_at(i);
 196 
 197     if (h-&gt;covers(cur_bci)) {
 198       BlockBegin* entry = h-&gt;entry_block();
 199       assert(entry != NULL &amp;&amp; entry == _bci2block-&gt;at(h-&gt;handler_bci()), &quot;entry must be set&quot;);
 200       assert(entry-&gt;is_set(BlockBegin::exception_entry_flag), &quot;flag must be set&quot;);
 201 
 202       // add each exception handler only once
 203       if (!current-&gt;is_successor(entry)) {
 204         current-&gt;add_successor(entry);
 205         entry-&gt;increment_total_preds();
 206       }
 207 
 208       // stop when reaching catchall
 209       if (h-&gt;catch_type() == 0) break;
 210     }
 211   }
 212 }
 213 
 214 void BlockListBuilder::handle_jsr(BlockBegin* current, int sr_bci, int next_bci) {
 215   // start a new block after jsr-bytecode and link this block into cfg
 216   make_block_at(next_bci, current);
 217 
 218   // start a new block at the subroutine entry at mark it with special flag
 219   BlockBegin* sr_block = make_block_at(sr_bci, current);
 220   if (!sr_block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 221     sr_block-&gt;set(BlockBegin::subroutine_entry_flag);
 222   }
 223 }
 224 
 225 
 226 void BlockListBuilder::set_leaders() {
 227   bool has_xhandlers = xhandlers()-&gt;has_handlers();
 228   BlockBegin* current = NULL;
 229 
 230   // The information which bci starts a new block simplifies the analysis
 231   // Without it, backward branches could jump to a bci where no block was created
 232   // during bytecode iteration. This would require the creation of a new block at the
 233   // branch target and a modification of the successor lists.
 234   const BitMap&amp; bci_block_start = method()-&gt;bci_block_start();
 235 
 236   ciBytecodeStream s(method());
 237   while (s.next() != ciBytecodeStream::EOBC()) {
 238     int cur_bci = s.cur_bci();
 239 
 240     if (bci_block_start.at(cur_bci)) {
 241       current = make_block_at(cur_bci, current);
 242     }
 243     assert(current != NULL, &quot;must have current block&quot;);
 244 
 245     if (has_xhandlers &amp;&amp; GraphBuilder::can_trap(method(), s.cur_bc())) {
 246       handle_exceptions(current, cur_bci);
 247     }
 248 
 249     switch (s.cur_bc()) {
 250       // track stores to local variables for selective creation of phi functions
 251       case Bytecodes::_iinc:     store_one(current, s.get_index()); break;
 252       case Bytecodes::_istore:   store_one(current, s.get_index()); break;
 253       case Bytecodes::_lstore:   store_two(current, s.get_index()); break;
 254       case Bytecodes::_fstore:   store_one(current, s.get_index()); break;
 255       case Bytecodes::_dstore:   store_two(current, s.get_index()); break;
 256       case Bytecodes::_astore:   store_one(current, s.get_index()); break;
 257       case Bytecodes::_istore_0: store_one(current, 0); break;
 258       case Bytecodes::_istore_1: store_one(current, 1); break;
 259       case Bytecodes::_istore_2: store_one(current, 2); break;
 260       case Bytecodes::_istore_3: store_one(current, 3); break;
 261       case Bytecodes::_lstore_0: store_two(current, 0); break;
 262       case Bytecodes::_lstore_1: store_two(current, 1); break;
 263       case Bytecodes::_lstore_2: store_two(current, 2); break;
 264       case Bytecodes::_lstore_3: store_two(current, 3); break;
 265       case Bytecodes::_fstore_0: store_one(current, 0); break;
 266       case Bytecodes::_fstore_1: store_one(current, 1); break;
 267       case Bytecodes::_fstore_2: store_one(current, 2); break;
 268       case Bytecodes::_fstore_3: store_one(current, 3); break;
 269       case Bytecodes::_dstore_0: store_two(current, 0); break;
 270       case Bytecodes::_dstore_1: store_two(current, 1); break;
 271       case Bytecodes::_dstore_2: store_two(current, 2); break;
 272       case Bytecodes::_dstore_3: store_two(current, 3); break;
 273       case Bytecodes::_astore_0: store_one(current, 0); break;
 274       case Bytecodes::_astore_1: store_one(current, 1); break;
 275       case Bytecodes::_astore_2: store_one(current, 2); break;
 276       case Bytecodes::_astore_3: store_one(current, 3); break;
 277 
 278       // track bytecodes that affect the control flow
 279       case Bytecodes::_athrow:  // fall through
 280       case Bytecodes::_ret:     // fall through
 281       case Bytecodes::_ireturn: // fall through
 282       case Bytecodes::_lreturn: // fall through
 283       case Bytecodes::_freturn: // fall through
 284       case Bytecodes::_dreturn: // fall through
 285       case Bytecodes::_areturn: // fall through
 286       case Bytecodes::_return:
 287         current = NULL;
 288         break;
 289 
 290       case Bytecodes::_ifeq:      // fall through
 291       case Bytecodes::_ifne:      // fall through
 292       case Bytecodes::_iflt:      // fall through
 293       case Bytecodes::_ifge:      // fall through
 294       case Bytecodes::_ifgt:      // fall through
 295       case Bytecodes::_ifle:      // fall through
 296       case Bytecodes::_if_icmpeq: // fall through
 297       case Bytecodes::_if_icmpne: // fall through
 298       case Bytecodes::_if_icmplt: // fall through
 299       case Bytecodes::_if_icmpge: // fall through
 300       case Bytecodes::_if_icmpgt: // fall through
 301       case Bytecodes::_if_icmple: // fall through
 302       case Bytecodes::_if_acmpeq: // fall through
 303       case Bytecodes::_if_acmpne: // fall through
 304       case Bytecodes::_ifnull:    // fall through
 305       case Bytecodes::_ifnonnull:
 306         make_block_at(s.next_bci(), current);
 307         make_block_at(s.get_dest(), current);
 308         current = NULL;
 309         break;
 310 
 311       case Bytecodes::_goto:
 312         make_block_at(s.get_dest(), current);
 313         current = NULL;
 314         break;
 315 
 316       case Bytecodes::_goto_w:
 317         make_block_at(s.get_far_dest(), current);
 318         current = NULL;
 319         break;
 320 
 321       case Bytecodes::_jsr:
 322         handle_jsr(current, s.get_dest(), s.next_bci());
 323         current = NULL;
 324         break;
 325 
 326       case Bytecodes::_jsr_w:
 327         handle_jsr(current, s.get_far_dest(), s.next_bci());
 328         current = NULL;
 329         break;
 330 
 331       case Bytecodes::_tableswitch: {
 332         // set block for each case
 333         Bytecode_tableswitch sw(&amp;s);
 334         int l = sw.length();
 335         for (int i = 0; i &lt; l; i++) {
 336           make_block_at(cur_bci + sw.dest_offset_at(i), current);
 337         }
 338         make_block_at(cur_bci + sw.default_offset(), current);
 339         current = NULL;
 340         break;
 341       }
 342 
 343       case Bytecodes::_lookupswitch: {
 344         // set block for each case
 345         Bytecode_lookupswitch sw(&amp;s);
 346         int l = sw.number_of_pairs();
 347         for (int i = 0; i &lt; l; i++) {
 348           make_block_at(cur_bci + sw.pair_at(i).offset(), current);
 349         }
 350         make_block_at(cur_bci + sw.default_offset(), current);
 351         current = NULL;
 352         break;
 353       }
 354 
 355       default:
 356         break;
 357     }
 358   }
 359 }
 360 
 361 
 362 void BlockListBuilder::mark_loops() {
 363   ResourceMark rm;
 364 
 365   _active.initialize(BlockBegin::number_of_blocks());
 366   _visited.initialize(BlockBegin::number_of_blocks());
 367   _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);
 368   _next_loop_index = 0;
 369   _next_block_number = _blocks.length();
 370 
 371   // recursively iterate the control flow graph
 372   mark_loops(_bci2block-&gt;at(0), false);
 373   assert(_next_block_number &gt;= 0, &quot;invalid block numbers&quot;);
 374 
 375   // Remove dangling Resource pointers before the ResourceMark goes out-of-scope.
 376   _active.resize(0);
 377   _visited.resize(0);
 378 }
 379 
 380 void BlockListBuilder::make_loop_header(BlockBegin* block) {
 381   if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 382     // exception edges may look like loops but don&#39;t mark them as such
 383     // since it screws up block ordering.
 384     return;
 385   }
 386   if (!block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 387     block-&gt;set(BlockBegin::parser_loop_header_flag);
 388 
 389     assert(_loop_map.at(block-&gt;block_id()) == 0, &quot;must not be set yet&quot;);
 390     assert(0 &lt;= _next_loop_index &amp;&amp; _next_loop_index &lt; BitsPerInt, &quot;_next_loop_index is used as a bit-index in integer&quot;);
 391     _loop_map.at_put(block-&gt;block_id(), 1 &lt;&lt; _next_loop_index);
 392     if (_next_loop_index &lt; 31) _next_loop_index++;
 393   } else {
 394     // block already marked as loop header
 395     assert(is_power_of_2((unsigned int)_loop_map.at(block-&gt;block_id())), &quot;exactly one bit must be set&quot;);
 396   }
 397 }
 398 
 399 int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {
 400   int block_id = block-&gt;block_id();
 401 
 402   if (_visited.at(block_id)) {
 403     if (_active.at(block_id)) {
 404       // reached block via backward branch
 405       make_loop_header(block);
 406     }
 407     // return cached loop information for this block
 408     return _loop_map.at(block_id);
 409   }
 410 
 411   if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) {
 412     in_subroutine = true;
 413   }
 414 
 415   // set active and visited bits before successors are processed
 416   _visited.set_bit(block_id);
 417   _active.set_bit(block_id);
 418 
 419   intptr_t loop_state = 0;
 420   for (int i = block-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
 421     // recursively process all successors
 422     loop_state |= mark_loops(block-&gt;sux_at(i), in_subroutine);
 423   }
 424 
 425   // clear active-bit after all successors are processed
 426   _active.clear_bit(block_id);
 427 
 428   // reverse-post-order numbering of all blocks
 429   block-&gt;set_depth_first_number(_next_block_number);
 430   _next_block_number--;
 431 
 432   if (loop_state != 0 || in_subroutine ) {
 433     // block is contained at least in one loop, so phi functions are necessary
 434     // phi functions are also necessary for all locals stored in a subroutine
 435     scope()-&gt;requires_phi_function().set_union(block-&gt;stores_to_locals());
 436   }
 437 
 438   if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
 439     int header_loop_state = _loop_map.at(block_id);
 440     assert(is_power_of_2((unsigned)header_loop_state), &quot;exactly one bit must be set&quot;);
 441 
 442     // If the highest bit is set (i.e. when integer value is negative), the method
 443     // has 32 or more loops. This bit is never cleared because it is used for multiple loops
 444     if (header_loop_state &gt;= 0) {
 445       clear_bits(loop_state, header_loop_state);
 446     }
 447   }
 448 
 449   // cache and return loop information for this block
 450   _loop_map.at_put(block_id, loop_state);
 451   return loop_state;
 452 }
 453 
 454 
 455 #ifndef PRODUCT
 456 
 457 int compare_depth_first(BlockBegin** a, BlockBegin** b) {
 458   return (*a)-&gt;depth_first_number() - (*b)-&gt;depth_first_number();
 459 }
 460 
 461 void BlockListBuilder::print() {
 462   tty-&gt;print(&quot;----- initial block list of BlockListBuilder for method &quot;);
 463   method()-&gt;print_short_name();
 464   tty-&gt;cr();
 465 
 466   // better readability if blocks are sorted in processing order
 467   _blocks.sort(compare_depth_first);
 468 
 469   for (int i = 0; i &lt; _blocks.length(); i++) {
 470     BlockBegin* cur = _blocks.at(i);
 471     tty-&gt;print(&quot;%4d: B%-4d bci: %-4d  preds: %-4d &quot;, cur-&gt;depth_first_number(), cur-&gt;block_id(), cur-&gt;bci(), cur-&gt;total_preds());
 472 
 473     tty-&gt;print(cur-&gt;is_set(BlockBegin::std_entry_flag)               ? &quot; std&quot; : &quot;    &quot;);
 474     tty-&gt;print(cur-&gt;is_set(BlockBegin::osr_entry_flag)               ? &quot; osr&quot; : &quot;    &quot;);
 475     tty-&gt;print(cur-&gt;is_set(BlockBegin::exception_entry_flag)         ? &quot; ex&quot; : &quot;   &quot;);
 476     tty-&gt;print(cur-&gt;is_set(BlockBegin::subroutine_entry_flag)        ? &quot; sr&quot; : &quot;   &quot;);
 477     tty-&gt;print(cur-&gt;is_set(BlockBegin::parser_loop_header_flag)      ? &quot; lh&quot; : &quot;   &quot;);
 478 
 479     if (cur-&gt;number_of_sux() &gt; 0) {
 480       tty-&gt;print(&quot;    sux: &quot;);
 481       for (int j = 0; j &lt; cur-&gt;number_of_sux(); j++) {
 482         BlockBegin* sux = cur-&gt;sux_at(j);
 483         tty-&gt;print(&quot;B%d &quot;, sux-&gt;block_id());
 484       }
 485     }
 486     tty-&gt;cr();
 487   }
 488 }
 489 
 490 #endif
 491 
 492 
 493 // A simple growable array of Values indexed by ciFields
 494 class FieldBuffer: public CompilationResourceObj {
 495  private:
 496   GrowableArray&lt;Value&gt; _values;
 497 
 498  public:
 499   FieldBuffer() {}
 500 
 501   void kill() {
 502     _values.trunc_to(0);
 503   }
 504 
 505   Value at(ciField* field) {
 506     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 507     int offset = field-&gt;offset();
 508     if (offset &lt; _values.length()) {
 509       return _values.at(offset);
 510     } else {
 511       return NULL;
 512     }
 513   }
 514 
 515   void at_put(ciField* field, Value value) {
 516     assert(field-&gt;holder()-&gt;is_loaded(), &quot;must be a loaded field&quot;);
 517     int offset = field-&gt;offset();
 518     _values.at_put_grow(offset, value, NULL);
 519   }
 520 
 521 };
 522 
 523 
 524 // MemoryBuffer is fairly simple model of the current state of memory.
 525 // It partitions memory into several pieces.  The first piece is
 526 // generic memory where little is known about the owner of the memory.
 527 // This is conceptually represented by the tuple &lt;O, F, V&gt; which says
 528 // that the field F of object O has value V.  This is flattened so
 529 // that F is represented by the offset of the field and the parallel
 530 // arrays _objects and _values are used for O and V.  Loads of O.F can
 531 // simply use V.  Newly allocated objects are kept in a separate list
 532 // along with a parallel array for each object which represents the
 533 // current value of its fields.  Stores of the default value to fields
 534 // which have never been stored to before are eliminated since they
 535 // are redundant.  Once newly allocated objects are stored into
 536 // another object or they are passed out of the current compile they
 537 // are treated like generic memory.
 538 
 539 class MemoryBuffer: public CompilationResourceObj {
 540  private:
 541   FieldBuffer                 _values;
 542   GrowableArray&lt;Value&gt;        _objects;
 543   GrowableArray&lt;Value&gt;        _newobjects;
 544   GrowableArray&lt;FieldBuffer*&gt; _fields;
 545 
 546  public:
 547   MemoryBuffer() {}
 548 
 549   StoreField* store(StoreField* st) {
 550     if (!EliminateFieldAccess) {
 551       return st;
 552     }
 553 
 554     Value object = st-&gt;obj();
 555     Value value = st-&gt;value();
 556     ciField* field = st-&gt;field();
 557     if (field-&gt;holder()-&gt;is_loaded()) {
 558       int offset = field-&gt;offset();
 559       int index = _newobjects.find(object);
 560       if (index != -1) {
 561         // newly allocated object with no other stores performed on this field
 562         FieldBuffer* buf = _fields.at(index);
 563         if (buf-&gt;at(field) == NULL &amp;&amp; is_default_value(value)) {
 564 #ifndef PRODUCT
 565           if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 566             tty-&gt;print_cr(&quot;Eliminated store for object %d:&quot;, index);
 567             st-&gt;print_line();
 568           }
 569 #endif
 570           return NULL;
 571         } else {
 572           buf-&gt;at_put(field, value);
 573         }
 574       } else {
 575         _objects.at_put_grow(offset, object, NULL);
 576         _values.at_put(field, value);
 577       }
 578 
 579       store_value(value);
 580     } else {
 581       // if we held onto field names we could alias based on names but
 582       // we don&#39;t know what&#39;s being stored to so kill it all.
 583       kill();
 584     }
 585     return st;
 586   }
 587 
 588 
 589   // return true if this value correspond to the default value of a field.
 590   bool is_default_value(Value value) {
 591     Constant* con = value-&gt;as_Constant();
 592     if (con) {
 593       switch (con-&gt;type()-&gt;tag()) {
 594         case intTag:    return con-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0;
 595         case longTag:   return con-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0;
 596         case floatTag:  return jint_cast(con-&gt;type()-&gt;as_FloatConstant()-&gt;value()) == 0;
 597         case doubleTag: return jlong_cast(con-&gt;type()-&gt;as_DoubleConstant()-&gt;value()) == jlong_cast(0);
 598         case objectTag: return con-&gt;type() == objectNull;
 599         default:  ShouldNotReachHere();
 600       }
 601     }
 602     return false;
 603   }
 604 
 605 
 606   // return either the actual value of a load or the load itself
 607   Value load(LoadField* load) {
 608     if (!EliminateFieldAccess) {
 609       return load;
 610     }
 611 
 612     if (strict_fp_requires_explicit_rounding &amp;&amp; load-&gt;type()-&gt;is_float_kind()) {
 613 #ifdef IA32
 614       if (UseSSE &lt; 2) {
 615         // can&#39;t skip load since value might get rounded as a side effect
 616         return load;
 617       }
 618 #else
 619       Unimplemented();
 620 #endif // IA32
 621     }
 622 
 623     ciField* field = load-&gt;field();
 624     Value object   = load-&gt;obj();
 625     if (field-&gt;holder()-&gt;is_loaded() &amp;&amp; !field-&gt;is_volatile()) {
 626       int offset = field-&gt;offset();
 627       Value result = NULL;
 628       int index = _newobjects.find(object);
 629       if (index != -1) {
 630         result = _fields.at(index)-&gt;at(field);
 631       } else if (_objects.at_grow(offset, NULL) == object) {
 632         result = _values.at(field);
 633       }
 634       if (result != NULL) {
 635 #ifndef PRODUCT
 636         if (PrintIRDuringConstruction &amp;&amp; Verbose) {
 637           tty-&gt;print_cr(&quot;Eliminated load: &quot;);
 638           load-&gt;print_line();
 639         }
 640 #endif
 641         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 642         return result;
 643       }
 644     }
 645     return load;
 646   }
 647 
 648   // Record this newly allocated object
 649   void new_instance(NewInstance* object) {
 650     int index = _newobjects.length();
 651     _newobjects.append(object);
 652     if (_fields.at_grow(index, NULL) == NULL) {
 653       _fields.at_put(index, new FieldBuffer());
 654     } else {
 655       _fields.at(index)-&gt;kill();
 656     }
 657   }
 658 
 659   // Record this newly allocated object
 660   void new_instance(NewValueTypeInstance* object) {
 661     int index = _newobjects.length();
 662     _newobjects.append(object);
 663     if (_fields.at_grow(index, NULL) == NULL) {
 664       _fields.at_put(index, new FieldBuffer());
 665     } else {
 666       _fields.at(index)-&gt;kill();
 667     }
 668   }
 669 
 670   void store_value(Value value) {
 671     int index = _newobjects.find(value);
 672     if (index != -1) {
 673       // stored a newly allocated object into another object.
 674       // Assume we&#39;ve lost track of it as separate slice of memory.
 675       // We could do better by keeping track of whether individual
 676       // fields could alias each other.
 677       _newobjects.remove_at(index);
 678       // pull out the field info and store it at the end up the list
 679       // of field info list to be reused later.
 680       _fields.append(_fields.at(index));
 681       _fields.remove_at(index);
 682     }
 683   }
 684 
 685   void kill() {
 686     _newobjects.trunc_to(0);
 687     _objects.trunc_to(0);
 688     _values.kill();
 689   }
 690 };
 691 
 692 
 693 // Implementation of GraphBuilder&#39;s ScopeData
 694 
 695 GraphBuilder::ScopeData::ScopeData(ScopeData* parent)
 696   : _parent(parent)
 697   , _bci2block(NULL)
 698   , _scope(NULL)
 699   , _has_handler(false)
 700   , _stream(NULL)
 701   , _work_list(NULL)
 702   , _caller_stack_size(-1)
 703   , _continuation(NULL)
 704   , _parsing_jsr(false)
 705   , _jsr_xhandlers(NULL)
 706   , _num_returns(0)
 707   , _cleanup_block(NULL)
 708   , _cleanup_return_prev(NULL)
 709   , _cleanup_state(NULL)
 710   , _ignore_return(false)
 711 {
 712   if (parent != NULL) {
 713     _max_inline_size = (intx) ((float) NestedInliningSizeRatio * (float) parent-&gt;max_inline_size() / 100.0f);
 714   } else {
 715     _max_inline_size = MaxInlineSize;
 716   }
 717   if (_max_inline_size &lt; MaxTrivialSize) {
 718     _max_inline_size = MaxTrivialSize;
 719   }
 720 }
 721 
 722 
 723 void GraphBuilder::kill_all() {
 724   if (UseLocalValueNumbering) {
 725     vmap()-&gt;kill_all();
 726   }
 727   _memory-&gt;kill();
 728 }
 729 
 730 
 731 BlockBegin* GraphBuilder::ScopeData::block_at(int bci) {
 732   if (parsing_jsr()) {
 733     // It is necessary to clone all blocks associated with a
 734     // subroutine, including those for exception handlers in the scope
 735     // of the method containing the jsr (because those exception
 736     // handlers may contain ret instructions in some cases).
 737     BlockBegin* block = bci2block()-&gt;at(bci);
 738     if (block != NULL &amp;&amp; block == parent()-&gt;bci2block()-&gt;at(bci)) {
 739       BlockBegin* new_block = new BlockBegin(block-&gt;bci());
 740       if (PrintInitialBlockList) {
 741         tty-&gt;print_cr(&quot;CFG: cloned block %d (bci %d) as block %d for jsr&quot;,
 742                       block-&gt;block_id(), block-&gt;bci(), new_block-&gt;block_id());
 743       }
 744       // copy data from cloned blocked
 745       new_block-&gt;set_depth_first_number(block-&gt;depth_first_number());
 746       if (block-&gt;is_set(BlockBegin::parser_loop_header_flag)) new_block-&gt;set(BlockBegin::parser_loop_header_flag);
 747       // Preserve certain flags for assertion checking
 748       if (block-&gt;is_set(BlockBegin::subroutine_entry_flag)) new_block-&gt;set(BlockBegin::subroutine_entry_flag);
 749       if (block-&gt;is_set(BlockBegin::exception_entry_flag))  new_block-&gt;set(BlockBegin::exception_entry_flag);
 750 
 751       // copy was_visited_flag to allow early detection of bailouts
 752       // if a block that is used in a jsr has already been visited before,
 753       // it is shared between the normal control flow and a subroutine
 754       // BlockBegin::try_merge returns false when the flag is set, this leads
 755       // to a compilation bailout
 756       if (block-&gt;is_set(BlockBegin::was_visited_flag))  new_block-&gt;set(BlockBegin::was_visited_flag);
 757 
 758       bci2block()-&gt;at_put(bci, new_block);
 759       block = new_block;
 760     }
 761     return block;
 762   } else {
 763     return bci2block()-&gt;at(bci);
 764   }
 765 }
 766 
 767 
 768 XHandlers* GraphBuilder::ScopeData::xhandlers() const {
 769   if (_jsr_xhandlers == NULL) {
 770     assert(!parsing_jsr(), &quot;&quot;);
 771     return scope()-&gt;xhandlers();
 772   }
 773   assert(parsing_jsr(), &quot;&quot;);
 774   return _jsr_xhandlers;
 775 }
 776 
 777 
 778 void GraphBuilder::ScopeData::set_scope(IRScope* scope) {
 779   _scope = scope;
 780   bool parent_has_handler = false;
 781   if (parent() != NULL) {
 782     parent_has_handler = parent()-&gt;has_handler();
 783   }
 784   _has_handler = parent_has_handler || scope-&gt;xhandlers()-&gt;has_handlers();
 785 }
 786 
 787 
 788 void GraphBuilder::ScopeData::set_inline_cleanup_info(BlockBegin* block,
 789                                                       Instruction* return_prev,
 790                                                       ValueStack* return_state) {
 791   _cleanup_block       = block;
 792   _cleanup_return_prev = return_prev;
 793   _cleanup_state       = return_state;
 794 }
 795 
 796 
 797 void GraphBuilder::ScopeData::add_to_work_list(BlockBegin* block) {
 798   if (_work_list == NULL) {
 799     _work_list = new BlockList();
 800   }
 801 
 802   if (!block-&gt;is_set(BlockBegin::is_on_work_list_flag)) {
 803     // Do not start parsing the continuation block while in a
 804     // sub-scope
 805     if (parsing_jsr()) {
 806       if (block == jsr_continuation()) {
 807         return;
 808       }
 809     } else {
 810       if (block == continuation()) {
 811         return;
 812       }
 813     }
 814     block-&gt;set(BlockBegin::is_on_work_list_flag);
 815     _work_list-&gt;push(block);
 816 
 817     sort_top_into_worklist(_work_list, block);
 818   }
 819 }
 820 
 821 
 822 void GraphBuilder::sort_top_into_worklist(BlockList* worklist, BlockBegin* top) {
 823   assert(worklist-&gt;top() == top, &quot;&quot;);
 824   // sort block descending into work list
 825   const int dfn = top-&gt;depth_first_number();
 826   assert(dfn != -1, &quot;unknown depth first number&quot;);
 827   int i = worklist-&gt;length()-2;
 828   while (i &gt;= 0) {
 829     BlockBegin* b = worklist-&gt;at(i);
 830     if (b-&gt;depth_first_number() &lt; dfn) {
 831       worklist-&gt;at_put(i+1, b);
 832     } else {
 833       break;
 834     }
 835     i --;
 836   }
 837   if (i &gt;= -1) worklist-&gt;at_put(i + 1, top);
 838 }
 839 
 840 
 841 BlockBegin* GraphBuilder::ScopeData::remove_from_work_list() {
 842   if (is_work_list_empty()) {
 843     return NULL;
 844   }
 845   return _work_list-&gt;pop();
 846 }
 847 
 848 
 849 bool GraphBuilder::ScopeData::is_work_list_empty() const {
 850   return (_work_list == NULL || _work_list-&gt;length() == 0);
 851 }
 852 
 853 
 854 void GraphBuilder::ScopeData::setup_jsr_xhandlers() {
 855   assert(parsing_jsr(), &quot;&quot;);
 856   // clone all the exception handlers from the scope
 857   XHandlers* handlers = new XHandlers(scope()-&gt;xhandlers());
 858   const int n = handlers-&gt;length();
 859   for (int i = 0; i &lt; n; i++) {
 860     // The XHandlers need to be adjusted to dispatch to the cloned
 861     // handler block instead of the default one but the synthetic
 862     // unlocker needs to be handled specially.  The synthetic unlocker
 863     // should be left alone since there can be only one and all code
 864     // should dispatch to the same one.
 865     XHandler* h = handlers-&gt;handler_at(i);
 866     assert(h-&gt;handler_bci() != SynchronizationEntryBCI, &quot;must be real&quot;);
 867     h-&gt;set_entry_block(block_at(h-&gt;handler_bci()));
 868   }
 869   _jsr_xhandlers = handlers;
 870 }
 871 
 872 
 873 int GraphBuilder::ScopeData::num_returns() {
 874   if (parsing_jsr()) {
 875     return parent()-&gt;num_returns();
 876   }
 877   return _num_returns;
 878 }
 879 
 880 
 881 void GraphBuilder::ScopeData::incr_num_returns() {
 882   if (parsing_jsr()) {
 883     parent()-&gt;incr_num_returns();
 884   } else {
 885     ++_num_returns;
 886   }
 887 }
 888 
 889 
 890 // Implementation of GraphBuilder
 891 
 892 #define INLINE_BAILOUT(msg)        { inline_bailout(msg); return false; }
 893 
 894 
 895 void GraphBuilder::load_constant() {
 896   ciConstant con = stream()-&gt;get_constant();
 897   if (con.basic_type() == T_ILLEGAL) {
 898     // FIXME: an unresolved Dynamic constant can get here,
 899     // and that should not terminate the whole compilation.
 900     BAILOUT(&quot;could not resolve a constant&quot;);
 901   } else {
 902     ValueType* t = illegalType;
 903     ValueStack* patch_state = NULL;
 904     switch (con.basic_type()) {
 905       case T_BOOLEAN: t = new IntConstant     (con.as_boolean()); break;
 906       case T_BYTE   : t = new IntConstant     (con.as_byte   ()); break;
 907       case T_CHAR   : t = new IntConstant     (con.as_char   ()); break;
 908       case T_SHORT  : t = new IntConstant     (con.as_short  ()); break;
 909       case T_INT    : t = new IntConstant     (con.as_int    ()); break;
 910       case T_LONG   : t = new LongConstant    (con.as_long   ()); break;
 911       case T_FLOAT  : t = new FloatConstant   (con.as_float  ()); break;
 912       case T_DOUBLE : t = new DoubleConstant  (con.as_double ()); break;
 913       case T_ARRAY  : t = new ArrayConstant   (con.as_object ()-&gt;as_array   ()); break;
 914       case T_OBJECT :
 915        {
 916         ciObject* obj = con.as_object();
 917         if (!obj-&gt;is_loaded()
 918             || (PatchALot &amp;&amp; obj-&gt;klass() != ciEnv::current()-&gt;String_klass())) {
 919           // A Class, MethodType, MethodHandle, or String.
 920           // Unloaded condy nodes show up as T_ILLEGAL, above.
 921           patch_state = copy_state_before();
 922           t = new ObjectConstant(obj);
 923         } else {
 924           // Might be a Class, MethodType, MethodHandle, or Dynamic constant
 925           // result, which might turn out to be an array.
 926           if (obj-&gt;is_null_object())
 927             t = objectNull;
 928           else if (obj-&gt;is_array())
 929             t = new ArrayConstant(obj-&gt;as_array());
 930           else
 931             t = new InstanceConstant(obj-&gt;as_instance());
 932         }
 933         break;
 934        }
 935       default       : ShouldNotReachHere();
 936     }
 937     Value x;
 938     if (patch_state != NULL) {
 939       x = new Constant(t, patch_state);
 940     } else {
 941       x = new Constant(t);
 942     }
 943     push(t, append(x));
 944   }
 945 }
 946 
 947 
 948 void GraphBuilder::load_local(ValueType* type, int index) {
 949   Value x = state()-&gt;local_at(index);
 950   assert(x != NULL &amp;&amp; !x-&gt;type()-&gt;is_illegal(), &quot;access of illegal local variable&quot;);
 951   push(type, x);
 952 }
 953 
 954 
 955 void GraphBuilder::store_local(ValueType* type, int index) {
 956   Value x = pop(type);
 957   store_local(state(), x, index);
 958 }
 959 
 960 
 961 void GraphBuilder::store_local(ValueStack* state, Value x, int index) {
 962   if (parsing_jsr()) {
 963     // We need to do additional tracking of the location of the return
 964     // address for jsrs since we don&#39;t handle arbitrary jsr/ret
 965     // constructs. Here we are figuring out in which circumstances we
 966     // need to bail out.
 967     if (x-&gt;type()-&gt;is_address()) {
 968       scope_data()-&gt;set_jsr_return_address_local(index);
 969 
 970       // Also check parent jsrs (if any) at this time to see whether
 971       // they are using this local. We don&#39;t handle skipping over a
 972       // ret.
 973       for (ScopeData* cur_scope_data = scope_data()-&gt;parent();
 974            cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
 975            cur_scope_data = cur_scope_data-&gt;parent()) {
 976         if (cur_scope_data-&gt;jsr_return_address_local() == index) {
 977           BAILOUT(&quot;subroutine overwrites return address from previous subroutine&quot;);
 978         }
 979       }
 980     } else if (index == scope_data()-&gt;jsr_return_address_local()) {
 981       scope_data()-&gt;set_jsr_return_address_local(-1);
 982     }
 983   }
 984 
 985   x-&gt;set_local_index(index);
 986   state-&gt;store_local(index, round_fp(x));
 987 }
 988 
 989 
 990 void GraphBuilder::load_indexed(BasicType type) {
 991   // In case of in block code motion in range check elimination
 992   ValueStack* state_before = NULL;
 993   int array_idx = state()-&gt;stack_size() - 2;
 994   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {
 995     // Save the entire state and re-execute on deopt when accessing flattened arrays
 996     state_before = copy_state_before();
 997     state_before-&gt;set_should_reexecute(true);
 998   } else {
 999     state_before = copy_state_indexed_access();
1000   }
1001   compilation()-&gt;set_has_access_indexed(true);
1002   Value index = ipop();
1003   Value array = apop();
1004   Value length = NULL;
1005   if (CSEArrayLength ||
1006       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1007       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1008     length = append(new ArrayLength(array, state_before));
1009   }
1010 
1011   LoadIndexed* load_indexed = NULL;
1012   Instruction* result = NULL;
1013   if (array-&gt;is_loaded_flattened_array()) {
1014     ciType* array_type = array-&gt;declared_type();
1015     ciValueKlass* elem_klass = array_type-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
1016     NewValueTypeInstance* new_instance = new NewValueTypeInstance(elem_klass, state_before, false);
1017     _memory-&gt;new_instance(new_instance);
1018     apush(append_split(new_instance));
1019     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1020     load_indexed-&gt;set_vt(new_instance);
1021   } else {
1022     load_indexed = new LoadIndexed(array, index, length, type, state_before);
1023   }
1024   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1025     compilation()-&gt;set_would_profile(true);
1026     load_indexed-&gt;set_should_profile(true);
1027     load_indexed-&gt;set_profiled_method(method());
1028     load_indexed-&gt;set_profiled_bci(bci());
1029   }
1030   result = append(load_indexed);
1031   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);
1032   if (!array-&gt;is_loaded_flattened_array()) {
1033     push(as_ValueType(type), result);
1034   }
1035 }
1036 
1037 
1038 void GraphBuilder::store_indexed(BasicType type) {
1039   // In case of in block code motion in range check elimination
1040   ValueStack* state_before = NULL;
1041   int array_idx = state()-&gt;stack_size() - 3;
1042   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {
1043     // Save the entire state and re-execute on deopt when accessing flattened arrays
1044     state_before = copy_state_before();
1045     state_before-&gt;set_should_reexecute(true);
1046   } else {
1047     state_before = copy_state_indexed_access();
1048   }
1049   compilation()-&gt;set_has_access_indexed(true);
1050   Value value = pop(as_ValueType(type));
1051   Value index = ipop();
1052   Value array = apop();
1053   Value length = NULL;
1054   value-&gt;set_escaped();
1055   if (CSEArrayLength ||
1056       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1057       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1058     length = append(new ArrayLength(array, state_before));
1059   }
1060   ciType* array_type = array-&gt;declared_type();
1061   bool check_boolean = false;
1062   if (array_type != NULL) {
1063     if (array_type-&gt;is_loaded() &amp;&amp;
1064       array_type-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() == T_BOOLEAN) {
1065       assert(type == T_BYTE, &quot;boolean store uses bastore&quot;);
1066       Value mask = append(new Constant(new IntConstant(1)));
1067       value = append(new LogicOp(Bytecodes::_iand, value, mask));
1068     }
1069   } else if (type == T_BYTE) {
1070     check_boolean = true;
1071   }
1072 
1073   StoreIndexed* store_indexed = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);
1074   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1075     compilation()-&gt;set_would_profile(true);
1076     store_indexed-&gt;set_should_profile(true);
1077     store_indexed-&gt;set_profiled_method(method());
1078     store_indexed-&gt;set_profiled_bci(bci());
1079   }
1080   Instruction* result = append(store_indexed);
1081   assert(!store_indexed-&gt;should_profile() || store_indexed == result, &quot;should not be optimized out&quot;);
1082   _memory-&gt;store_value(value);
1083 
1084 }
1085 
1086 
1087 void GraphBuilder::stack_op(Bytecodes::Code code) {
1088   switch (code) {
1089     case Bytecodes::_pop:
1090       { state()-&gt;raw_pop();
1091       }
1092       break;
1093     case Bytecodes::_pop2:
1094       { state()-&gt;raw_pop();
1095         state()-&gt;raw_pop();
1096       }
1097       break;
1098     case Bytecodes::_dup:
1099       { Value w = state()-&gt;raw_pop();
1100         state()-&gt;raw_push(w);
1101         state()-&gt;raw_push(w);
1102       }
1103       break;
1104     case Bytecodes::_dup_x1:
1105       { Value w1 = state()-&gt;raw_pop();
1106         Value w2 = state()-&gt;raw_pop();
1107         state()-&gt;raw_push(w1);
1108         state()-&gt;raw_push(w2);
1109         state()-&gt;raw_push(w1);
1110       }
1111       break;
1112     case Bytecodes::_dup_x2:
1113       { Value w1 = state()-&gt;raw_pop();
1114         Value w2 = state()-&gt;raw_pop();
1115         Value w3 = state()-&gt;raw_pop();
1116         state()-&gt;raw_push(w1);
1117         state()-&gt;raw_push(w3);
1118         state()-&gt;raw_push(w2);
1119         state()-&gt;raw_push(w1);
1120       }
1121       break;
1122     case Bytecodes::_dup2:
1123       { Value w1 = state()-&gt;raw_pop();
1124         Value w2 = state()-&gt;raw_pop();
1125         state()-&gt;raw_push(w2);
1126         state()-&gt;raw_push(w1);
1127         state()-&gt;raw_push(w2);
1128         state()-&gt;raw_push(w1);
1129       }
1130       break;
1131     case Bytecodes::_dup2_x1:
1132       { Value w1 = state()-&gt;raw_pop();
1133         Value w2 = state()-&gt;raw_pop();
1134         Value w3 = state()-&gt;raw_pop();
1135         state()-&gt;raw_push(w2);
1136         state()-&gt;raw_push(w1);
1137         state()-&gt;raw_push(w3);
1138         state()-&gt;raw_push(w2);
1139         state()-&gt;raw_push(w1);
1140       }
1141       break;
1142     case Bytecodes::_dup2_x2:
1143       { Value w1 = state()-&gt;raw_pop();
1144         Value w2 = state()-&gt;raw_pop();
1145         Value w3 = state()-&gt;raw_pop();
1146         Value w4 = state()-&gt;raw_pop();
1147         state()-&gt;raw_push(w2);
1148         state()-&gt;raw_push(w1);
1149         state()-&gt;raw_push(w4);
1150         state()-&gt;raw_push(w3);
1151         state()-&gt;raw_push(w2);
1152         state()-&gt;raw_push(w1);
1153       }
1154       break;
1155     case Bytecodes::_swap:
1156       { Value w1 = state()-&gt;raw_pop();
1157         Value w2 = state()-&gt;raw_pop();
1158         state()-&gt;raw_push(w1);
1159         state()-&gt;raw_push(w2);
1160       }
1161       break;
1162     default:
1163       ShouldNotReachHere();
1164       break;
1165   }
1166 }
1167 
1168 
1169 void GraphBuilder::arithmetic_op(ValueType* type, Bytecodes::Code code, ValueStack* state_before) {
1170   Value y = pop(type);
1171   Value x = pop(type);
1172   // NOTE: strictfp can be queried from current method since we don&#39;t
1173   // inline methods with differing strictfp bits
1174   Value res = new ArithmeticOp(code, x, y, method()-&gt;is_strict(), state_before);
1175   // Note: currently single-precision floating-point rounding on Intel is handled at the LIRGenerator level
1176   res = append(res);
1177   if (method()-&gt;is_strict()) {
1178     res = round_fp(res);
1179   }
1180   push(type, res);
1181 }
1182 
1183 
1184 void GraphBuilder::negate_op(ValueType* type) {
1185   push(type, append(new NegateOp(pop(type))));
1186 }
1187 
1188 
1189 void GraphBuilder::shift_op(ValueType* type, Bytecodes::Code code) {
1190   Value s = ipop();
1191   Value x = pop(type);
1192   // try to simplify
1193   // Note: This code should go into the canonicalizer as soon as it can
1194   //       can handle canonicalized forms that contain more than one node.
1195   if (CanonicalizeNodes &amp;&amp; code == Bytecodes::_iushr) {
1196     // pattern: x &gt;&gt;&gt; s
1197     IntConstant* s1 = s-&gt;type()-&gt;as_IntConstant();
1198     if (s1 != NULL) {
1199       // pattern: x &gt;&gt;&gt; s1, with s1 constant
1200       ShiftOp* l = x-&gt;as_ShiftOp();
1201       if (l != NULL &amp;&amp; l-&gt;op() == Bytecodes::_ishl) {
1202         // pattern: (a &lt;&lt; b) &gt;&gt;&gt; s1
1203         IntConstant* s0 = l-&gt;y()-&gt;type()-&gt;as_IntConstant();
1204         if (s0 != NULL) {
1205           // pattern: (a &lt;&lt; s0) &gt;&gt;&gt; s1
1206           const int s0c = s0-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1207           const int s1c = s1-&gt;value() &amp; 0x1F; // only the low 5 bits are significant for shifts
1208           if (s0c == s1c) {
1209             if (s0c == 0) {
1210               // pattern: (a &lt;&lt; 0) &gt;&gt;&gt; 0 =&gt; simplify to: a
1211               ipush(l-&gt;x());
1212             } else {
1213               // pattern: (a &lt;&lt; s0c) &gt;&gt;&gt; s0c =&gt; simplify to: a &amp; m, with m constant
1214               assert(0 &lt; s0c &amp;&amp; s0c &lt; BitsPerInt, &quot;adjust code below to handle corner cases&quot;);
1215               const int m = (1 &lt;&lt; (BitsPerInt - s0c)) - 1;
1216               Value s = append(new Constant(new IntConstant(m)));
1217               ipush(append(new LogicOp(Bytecodes::_iand, l-&gt;x(), s)));
1218             }
1219             return;
1220           }
1221         }
1222       }
1223     }
1224   }
1225   // could not simplify
1226   push(type, append(new ShiftOp(code, x, s)));
1227 }
1228 
1229 
1230 void GraphBuilder::logic_op(ValueType* type, Bytecodes::Code code) {
1231   Value y = pop(type);
1232   Value x = pop(type);
1233   push(type, append(new LogicOp(code, x, y)));
1234 }
1235 
1236 
1237 void GraphBuilder::compare_op(ValueType* type, Bytecodes::Code code) {
1238   ValueStack* state_before = copy_state_before();
1239   Value y = pop(type);
1240   Value x = pop(type);
1241   ipush(append(new CompareOp(code, x, y, state_before)));
1242 }
1243 
1244 
1245 void GraphBuilder::convert(Bytecodes::Code op, BasicType from, BasicType to) {
1246   push(as_ValueType(to), append(new Convert(op, pop(as_ValueType(from)), as_ValueType(to))));
1247 }
1248 
1249 
1250 void GraphBuilder::increment() {
1251   int index = stream()-&gt;get_index();
1252   int delta = stream()-&gt;is_wide() ? (signed short)Bytes::get_Java_u2(stream()-&gt;cur_bcp() + 4) : (signed char)(stream()-&gt;cur_bcp()[2]);
1253   load_local(intType, index);
1254   ipush(append(new Constant(new IntConstant(delta))));
1255   arithmetic_op(intType, Bytecodes::_iadd);
1256   store_local(intType, index);
1257 }
1258 
1259 
1260 void GraphBuilder::_goto(int from_bci, int to_bci) {
1261   Goto *x = new Goto(block_at(to_bci), to_bci &lt;= from_bci);
1262   if (is_profiling()) {
1263     compilation()-&gt;set_would_profile(true);
1264     x-&gt;set_profiled_bci(bci());
1265     if (profile_branches()) {
1266       x-&gt;set_profiled_method(method());
1267       x-&gt;set_should_profile(true);
1268     }
1269   }
1270   append(x);
1271 }
1272 
1273 
1274 void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
1275   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1276   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1277   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
1278 
1279   bool subst_check = false;
1280   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;
1281       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {
1282     // If current method is ValueBootstrapMethods::isSubstitutable(),
1283     // compile the acmp as a regular pointer comparison otherwise we
1284     // could call ValueBootstrapMethods::isSubstitutable() back
1285     ValueType* left_vt = x-&gt;type();
1286     ValueType* right_vt = y-&gt;type();
1287     if (left_vt-&gt;is_object()) {
1288       assert(right_vt-&gt;is_object(), &quot;must be&quot;);
1289       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();
1290       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();
1291 
1292       if (left_klass == NULL || right_klass == NULL) {
1293         // The klass is still unloaded, or came from a Phi node. Go slow case;
1294         subst_check = true;
1295       } else if (left_klass-&gt;is_java_lang_Object() || left_klass-&gt;is_interface() ||
1296                  right_klass-&gt;is_java_lang_Object() || right_klass-&gt;is_interface()) {
1297         // Either operand may be a value object, but we&#39;re not sure.  Go slow case;
1298         subst_check = true;
1299       } else if (left_klass-&gt;is_valuetype() || right_klass-&gt;is_valuetype()) {
1300         subst_check = true;
1301       } else {
1302         // No need to do substitutability check
1303       }
1304     }
1305   }
1306 
1307   // In case of loop invariant code motion or predicate insertion
1308   // before the body of a loop the state is needed
1309   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));
1310 
1311   assert(i-&gt;as_Goto() == NULL ||
1312          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1313          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1314          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1315 
1316   if (is_profiling()) {
1317     If* if_node = i-&gt;as_If();
1318     if (if_node != NULL) {
1319       // Note that we&#39;d collect profile data in this method if we wanted it.
1320       compilation()-&gt;set_would_profile(true);
1321       // At level 2 we need the proper bci to count backedges
1322       if_node-&gt;set_profiled_bci(bci());
1323       if (profile_branches()) {
1324         // Successors can be rotated by the canonicalizer, check for this case.
1325         if_node-&gt;set_profiled_method(method());
1326         if_node-&gt;set_should_profile(true);
1327         if (if_node-&gt;tsux() == fsux) {
1328           if_node-&gt;set_swapped(true);
1329         }
1330       }
1331       return;
1332     }
1333 
1334     // Check if this If was reduced to Goto.
1335     Goto *goto_node = i-&gt;as_Goto();
1336     if (goto_node != NULL) {
1337       compilation()-&gt;set_would_profile(true);
1338       goto_node-&gt;set_profiled_bci(bci());
1339       if (profile_branches()) {
1340         goto_node-&gt;set_profiled_method(method());
1341         goto_node-&gt;set_should_profile(true);
1342         // Find out which successor is used.
1343         if (goto_node-&gt;default_sux() == tsux) {
1344           goto_node-&gt;set_direction(Goto::taken);
1345         } else if (goto_node-&gt;default_sux() == fsux) {
1346           goto_node-&gt;set_direction(Goto::not_taken);
1347         } else {
1348           ShouldNotReachHere();
1349         }
1350       }
1351       return;
1352     }
1353   }
1354 }
1355 
1356 
1357 void GraphBuilder::if_zero(ValueType* type, If::Condition cond) {
1358   Value y = append(new Constant(intZero));
1359   ValueStack* state_before = copy_state_before();
1360   Value x = ipop();
1361   if_node(x, cond, y, state_before);
1362 }
1363 
1364 
1365 void GraphBuilder::if_null(ValueType* type, If::Condition cond) {
1366   Value y = append(new Constant(objectNull));
1367   ValueStack* state_before = copy_state_before();
1368   Value x = apop();
1369   if_node(x, cond, y, state_before);
1370 }
1371 
1372 
1373 void GraphBuilder::if_same(ValueType* type, If::Condition cond) {
1374   ValueStack* state_before = copy_state_before();
1375   Value y = pop(type);
1376   Value x = pop(type);
1377   if_node(x, cond, y, state_before);
1378 }
1379 
1380 
1381 void GraphBuilder::jsr(int dest) {
1382   // We only handle well-formed jsrs (those which are &quot;block-structured&quot;).
1383   // If the bytecodes are strange (jumping out of a jsr block) then we
1384   // might end up trying to re-parse a block containing a jsr which
1385   // has already been activated. Watch for this case and bail out.
1386   for (ScopeData* cur_scope_data = scope_data();
1387        cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
1388        cur_scope_data = cur_scope_data-&gt;parent()) {
1389     if (cur_scope_data-&gt;jsr_entry_bci() == dest) {
1390       BAILOUT(&quot;too-complicated jsr/ret structure&quot;);
1391     }
1392   }
1393 
1394   push(addressType, append(new Constant(new AddressConstant(next_bci()))));
1395   if (!try_inline_jsr(dest)) {
1396     return; // bailed out while parsing and inlining subroutine
1397   }
1398 }
1399 
1400 
1401 void GraphBuilder::ret(int local_index) {
1402   if (!parsing_jsr()) BAILOUT(&quot;ret encountered while not parsing subroutine&quot;);
1403 
1404   if (local_index != scope_data()-&gt;jsr_return_address_local()) {
1405     BAILOUT(&quot;can not handle complicated jsr/ret constructs&quot;);
1406   }
1407 
1408   // Rets simply become (NON-SAFEPOINT) gotos to the jsr continuation
1409   append(new Goto(scope_data()-&gt;jsr_continuation(), false));
1410 }
1411 
1412 
1413 void GraphBuilder::table_switch() {
1414   Bytecode_tableswitch sw(stream());
1415   const int l = sw.length();
1416   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1417     // total of 2 successors =&gt; use If instead of switch
1418     // Note: This code should go into the canonicalizer as soon as it can
1419     //       can handle canonicalized forms that contain more than one node.
1420     Value key = append(new Constant(new IntConstant(sw.low_key())));
1421     BlockBegin* tsux = block_at(bci() + sw.dest_offset_at(0));
1422     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1423     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1424     // In case of loop invariant code motion or predicate insertion
1425     // before the body of a loop the state is needed
1426     ValueStack* state_before = copy_state_if_bb(is_bb);
1427     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1428   } else {
1429     // collect successors
1430     BlockList* sux = new BlockList(l + 1, NULL);
1431     int i;
1432     bool has_bb = false;
1433     for (i = 0; i &lt; l; i++) {
1434       sux-&gt;at_put(i, block_at(bci() + sw.dest_offset_at(i)));
1435       if (sw.dest_offset_at(i) &lt; 0) has_bb = true;
1436     }
1437     // add default successor
1438     if (sw.default_offset() &lt; 0) has_bb = true;
1439     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1440     // In case of loop invariant code motion or predicate insertion
1441     // before the body of a loop the state is needed
1442     ValueStack* state_before = copy_state_if_bb(has_bb);
1443     Instruction* res = append(new TableSwitch(ipop(), sux, sw.low_key(), state_before, has_bb));
1444 #ifdef ASSERT
1445     if (res-&gt;as_Goto()) {
1446       for (i = 0; i &lt; l; i++) {
1447         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1448           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.dest_offset_at(i) &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1449         }
1450       }
1451     }
1452 #endif
1453   }
1454 }
1455 
1456 
1457 void GraphBuilder::lookup_switch() {
1458   Bytecode_lookupswitch sw(stream());
1459   const int l = sw.number_of_pairs();
1460   if (CanonicalizeNodes &amp;&amp; l == 1 &amp;&amp; compilation()-&gt;env()-&gt;comp_level() != CompLevel_full_profile) {
1461     // total of 2 successors =&gt; use If instead of switch
1462     // Note: This code should go into the canonicalizer as soon as it can
1463     //       can handle canonicalized forms that contain more than one node.
1464     // simplify to If
1465     LookupswitchPair pair = sw.pair_at(0);
1466     Value key = append(new Constant(new IntConstant(pair.match())));
1467     BlockBegin* tsux = block_at(bci() + pair.offset());
1468     BlockBegin* fsux = block_at(bci() + sw.default_offset());
1469     bool is_bb = tsux-&gt;bci() &lt; bci() || fsux-&gt;bci() &lt; bci();
1470     // In case of loop invariant code motion or predicate insertion
1471     // before the body of a loop the state is needed
1472     ValueStack* state_before = copy_state_if_bb(is_bb);;
1473     append(new If(ipop(), If::eql, true, key, tsux, fsux, state_before, is_bb));
1474   } else {
1475     // collect successors &amp; keys
1476     BlockList* sux = new BlockList(l + 1, NULL);
1477     intArray* keys = new intArray(l, l, 0);
1478     int i;
1479     bool has_bb = false;
1480     for (i = 0; i &lt; l; i++) {
1481       LookupswitchPair pair = sw.pair_at(i);
1482       if (pair.offset() &lt; 0) has_bb = true;
1483       sux-&gt;at_put(i, block_at(bci() + pair.offset()));
1484       keys-&gt;at_put(i, pair.match());
1485     }
1486     // add default successor
1487     if (sw.default_offset() &lt; 0) has_bb = true;
1488     sux-&gt;at_put(i, block_at(bci() + sw.default_offset()));
1489     // In case of loop invariant code motion or predicate insertion
1490     // before the body of a loop the state is needed
1491     ValueStack* state_before = copy_state_if_bb(has_bb);
1492     Instruction* res = append(new LookupSwitch(ipop(), sux, keys, state_before, has_bb));
1493 #ifdef ASSERT
1494     if (res-&gt;as_Goto()) {
1495       for (i = 0; i &lt; l; i++) {
1496         if (sux-&gt;at(i) == res-&gt;as_Goto()-&gt;sux_at(0)) {
1497           assert(res-&gt;as_Goto()-&gt;is_safepoint() == sw.pair_at(i).offset() &lt; 0, &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1498         }
1499       }
1500     }
1501 #endif
1502   }
1503 }
1504 
1505 void GraphBuilder::call_register_finalizer() {
1506   // If the receiver requires finalization then emit code to perform
1507   // the registration on return.
1508 
1509   // Gather some type information about the receiver
1510   Value receiver = state()-&gt;local_at(0);
1511   assert(receiver != NULL, &quot;must have a receiver&quot;);
1512   ciType* declared_type = receiver-&gt;declared_type();
1513   ciType* exact_type = receiver-&gt;exact_type();
1514   if (exact_type == NULL &amp;&amp;
1515       receiver-&gt;as_Local() &amp;&amp;
1516       receiver-&gt;as_Local()-&gt;java_index() == 0) {
1517     ciInstanceKlass* ik = compilation()-&gt;method()-&gt;holder();
1518     if (ik-&gt;is_final()) {
1519       exact_type = ik;
1520     } else if (UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
1521       // test class is leaf class
1522       compilation()-&gt;dependency_recorder()-&gt;assert_leaf_type(ik);
1523       exact_type = ik;
1524     } else {
1525       declared_type = ik;
1526     }
1527   }
1528 
1529   // see if we know statically that registration isn&#39;t required
1530   bool needs_check = true;
1531   if (exact_type != NULL) {
1532     needs_check = exact_type-&gt;as_instance_klass()-&gt;has_finalizer();
1533   } else if (declared_type != NULL) {
1534     ciInstanceKlass* ik = declared_type-&gt;as_instance_klass();
1535     if (!Dependencies::has_finalizable_subclass(ik)) {
1536       compilation()-&gt;dependency_recorder()-&gt;assert_has_no_finalizable_subclasses(ik);
1537       needs_check = false;
1538     }
1539   }
1540 
1541   if (needs_check) {
1542     // Perform the registration of finalizable objects.
1543     ValueStack* state_before = copy_state_for_exception();
1544     load_local(objectType, 0);
1545     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1546                                state()-&gt;pop_arguments(1),
1547                                true, state_before, true));
1548   }
1549 }
1550 
1551 
1552 void GraphBuilder::method_return(Value x, bool ignore_return) {
1553   if (RegisterFinalizersAtInit &amp;&amp;
1554       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1555     call_register_finalizer();
1556   }
1557 
1558   // The conditions for a memory barrier are described in Parse::do_exits().
1559   bool need_mem_bar = false;
1560   if (method()-&gt;is_object_constructor() &amp;&amp;
1561        (scope()-&gt;wrote_final() ||
1562          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
1563          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
1564     need_mem_bar = true;
1565   }
1566 
1567   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1568   switch (bt) {
1569     case T_BYTE:
1570     {
1571       Value shift = append(new Constant(new IntConstant(24)));
1572       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1573       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1574       break;
1575     }
1576     case T_SHORT:
1577     {
1578       Value shift = append(new Constant(new IntConstant(16)));
1579       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1580       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1581       break;
1582     }
1583     case T_CHAR:
1584     {
1585       Value mask = append(new Constant(new IntConstant(0xFFFF)));
1586       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1587       break;
1588     }
1589     case T_BOOLEAN:
1590     {
1591       Value mask = append(new Constant(new IntConstant(1)));
1592       x = append(new LogicOp(Bytecodes::_iand, x, mask));
1593       break;
1594     }
1595     default:
1596       break;
1597   }
1598 
1599   // Check to see whether we are inlining. If so, Return
1600   // instructions become Gotos to the continuation point.
1601   if (continuation() != NULL) {
1602 
1603     int invoke_bci = state()-&gt;caller_state()-&gt;bci();
1604 
1605     if (x != NULL  &amp;&amp; !ignore_return) {
1606       ciMethod* caller = state()-&gt;scope()-&gt;caller()-&gt;method();
1607       Bytecodes::Code invoke_raw_bc = caller-&gt;raw_code_at_bci(invoke_bci);
1608       if (invoke_raw_bc == Bytecodes::_invokehandle || invoke_raw_bc == Bytecodes::_invokedynamic) {
1609         ciType* declared_ret_type = caller-&gt;get_declared_signature_at_bci(invoke_bci)-&gt;return_type();
1610         if (declared_ret_type-&gt;is_klass() &amp;&amp; x-&gt;exact_type() == NULL &amp;&amp;
1611             x-&gt;declared_type() != declared_ret_type &amp;&amp; declared_ret_type != compilation()-&gt;env()-&gt;Object_klass()) {
1612           x = append(new TypeCast(declared_ret_type-&gt;as_klass(), x, copy_state_before()));
1613         }
1614       }
1615     }
1616 
1617     assert(!method()-&gt;is_synchronized() || InlineSynchronizedMethods, &quot;can not inline synchronized methods yet&quot;);
1618 
1619     if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
1620       // Report exit from inline methods
1621       Values* args = new Values(1);
1622       args-&gt;push(append(new Constant(new MethodConstant(method()))));
1623       append(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args));
1624     }
1625 
1626     // If the inlined method is synchronized, the monitor must be
1627     // released before we jump to the continuation block.
1628     if (method()-&gt;is_synchronized()) {
1629       assert(state()-&gt;locks_size() == 1, &quot;receiver must be locked here&quot;);
1630       monitorexit(state()-&gt;lock_at(0), SynchronizationEntryBCI);
1631     }
1632 
1633     if (need_mem_bar) {
1634       append(new MemBar(lir_membar_storestore));
1635     }
1636 
1637     // State at end of inlined method is the state of the caller
1638     // without the method parameters on stack, including the
1639     // return value, if any, of the inlined method on operand stack.
1640     set_state(state()-&gt;caller_state()-&gt;copy_for_parsing());
1641     if (x != NULL) {
1642       if (!ignore_return) {
1643         state()-&gt;push(x-&gt;type(), x);
1644       }
1645       if (profile_return() &amp;&amp; x-&gt;type()-&gt;is_object_kind()) {
1646         ciMethod* caller = state()-&gt;scope()-&gt;method();
1647         profile_return_type(x, method(), caller, invoke_bci);
1648       }
1649     }
1650     Goto* goto_callee = new Goto(continuation(), false);
1651 
1652     // See whether this is the first return; if so, store off some
1653     // of the state for later examination
1654     if (num_returns() == 0) {
1655       set_inline_cleanup_info();
1656     }
1657 
1658     // The current bci() is in the wrong scope, so use the bci() of
1659     // the continuation point.
1660     append_with_bci(goto_callee, scope_data()-&gt;continuation()-&gt;bci());
1661     incr_num_returns();
1662     return;
1663   }
1664 
1665   state()-&gt;truncate_stack(0);
1666   if (method()-&gt;is_synchronized()) {
1667     // perform the unlocking before exiting the method
1668     Value receiver;
1669     if (!method()-&gt;is_static()) {
1670       receiver = _initial_state-&gt;local_at(0);
1671     } else {
1672       receiver = append(new Constant(new ClassConstant(method()-&gt;holder())));
1673     }
1674     append_split(new MonitorExit(receiver, state()-&gt;unlock()));
1675   }
1676 
1677   if (need_mem_bar) {
1678       append(new MemBar(lir_membar_storestore));
1679   }
1680 
1681   assert(!ignore_return, &quot;Ignoring return value works only for inlining&quot;);
1682   append(new Return(x));
1683 }
1684 
1685 Value GraphBuilder::make_constant(ciConstant field_value, ciField* field) {
1686   if (!field_value.is_valid())  return NULL;
1687 
1688   BasicType field_type = field_value.basic_type();
1689   ValueType* value = as_ValueType(field_value);
1690 
1691   // Attach dimension info to stable arrays.
1692   if (FoldStableValues &amp;&amp;
1693       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1694     ciArray* array = field_value.as_object()-&gt;as_array();
1695     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1696     value = new StableArrayConstant(array, dimension);
1697   }
1698 
1699   switch (field_type) {
1700     case T_ARRAY:
1701     case T_OBJECT:
1702       if (field_value.as_object()-&gt;should_be_constant()) {
1703         return new Constant(value);
1704       }
1705       return NULL; // Not a constant.
1706     default:
1707       return new Constant(value);
1708   }
1709 }
1710 
1711 void GraphBuilder::copy_value_content(ciValueKlass* vk, Value src, int src_off, Value dest, int dest_off,
1712     ValueStack* state_before, bool needs_patching) {
1713   src-&gt;set_escaped();
1714   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {
1715     ciField* inner_field = vk-&gt;nonstatic_field_at(i);
1716     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);
1717     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();
1718     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);
1719     Value replacement = append(load);
1720     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);
1721     append(store);
1722   }
1723 }
1724 
1725 void GraphBuilder::access_field(Bytecodes::Code code) {
1726   bool will_link;
1727   ciField* field = stream()-&gt;get_field(will_link);
1728   ciInstanceKlass* holder = field-&gt;holder();
1729   BasicType field_type = field-&gt;type()-&gt;basic_type();
1730   ValueType* type = as_ValueType(field_type);
1731 
1732   // call will_link again to determine if the field is valid.
1733   const bool needs_patching = !holder-&gt;is_loaded() ||
1734                               !field-&gt;will_link(method(), code) ||
1735                               PatchALot;
1736 
1737   ValueStack* state_before = NULL;
1738   if (!holder-&gt;is_initialized() || needs_patching) {
1739     // save state before instruction for debug info when
1740     // deoptimization happens during patching
1741     state_before = copy_state_before();
1742   }
1743 
1744   Value obj = NULL;
1745   if (code == Bytecodes::_getstatic || code == Bytecodes::_putstatic) {
1746     if (state_before != NULL) {
1747       // build a patching constant
1748       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()), state_before);
1749     } else {
1750       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
1751     }
1752   }
1753 
1754   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield || code == Bytecodes::_withfield)) {
1755     scope()-&gt;set_wrote_final();
1756   }
1757 
1758   if (code == Bytecodes::_putfield || code == Bytecodes::_withfield) {
1759     scope()-&gt;set_wrote_fields();
1760     if (field-&gt;is_volatile()) {
1761       scope()-&gt;set_wrote_volatile();
1762     }
1763   }
1764 
1765   const int offset = !needs_patching ? field-&gt;offset() : -1;
1766   switch (code) {
1767     case Bytecodes::_getstatic: {
1768       // check for compile-time constants, i.e., initialized static final fields
1769       Value constant = NULL;
1770       if (field-&gt;is_static_constant() &amp;&amp; !PatchALot) {
1771         ciConstant field_value = field-&gt;constant_value();
1772         assert(!field-&gt;is_stable() || !field_value.is_null_or_zero(),
1773                &quot;stable static w/ default value shouldn&#39;t be a constant&quot;);
1774         constant = make_constant(field_value, field);
1775       }
1776       if (constant != NULL) {
1777         push(type, append(constant));
1778       } else {
1779         if (state_before == NULL) {
1780           state_before = copy_state_for_exception();
1781         }
1782         LoadField* load_field = new LoadField(append(obj), offset, field, true,
1783                                         state_before, needs_patching);
1784         if (field-&gt;is_flattenable()) {
1785           load_field-&gt;set_never_null(true);
1786         }
1787         push(type, append(load_field));
1788       }
1789       break;
1790     }
1791     case Bytecodes::_putstatic: {
1792       Value val = pop(type);
1793       val-&gt;set_escaped();
1794       if (state_before == NULL) {
1795         state_before = copy_state_for_exception();
1796       }
1797       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1798         Value mask = append(new Constant(new IntConstant(1)));
1799         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1800       }
1801       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1802       break;
1803     }
1804     case Bytecodes::_getfield: {
1805       // Check for compile-time constants, i.e., trusted final non-static fields.
1806       Value constant = NULL;
1807       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {
1808         // Save the entire state and re-execute on deopt when accessing flattened fields
1809         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);
1810         state_before = copy_state_before();
1811       }
1812       obj = apop();
1813       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
1814       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {
1815         ciObject* const_oop = obj_type-&gt;constant_value();
1816         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1817           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1818           if (field_value.is_valid()) {
1819             constant = make_constant(field_value, field);
1820             // For CallSite objects add a dependency for invalidation of the optimization.
1821             if (field-&gt;is_call_site_target()) {
1822               ciCallSite* call_site = const_oop-&gt;as_call_site();
1823               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1824                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1825                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1826               }
1827             }
1828           }
1829         }
1830       }
1831       if (constant != NULL) {
1832         push(type, append(constant));
1833       } else {
1834         if (state_before == NULL) {
1835           state_before = copy_state_for_exception();
1836         }
1837         if (!field-&gt;is_flattened()) {
1838           LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);
1839           Value replacement = !needs_patching ? _memory-&gt;load(load) : load;
1840           if (replacement != load) {
1841             assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);
1842             // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing
1843             // conversion. Emit an explicit conversion here to get the correct field value after the write.
1844             BasicType bt = field-&gt;type()-&gt;basic_type();
1845             switch (bt) {
1846             case T_BOOLEAN:
1847             case T_BYTE:
1848               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));
1849               break;
1850             case T_CHAR:
1851               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));
1852               break;
1853             case T_SHORT:
1854               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));
1855               break;
1856             default:
1857               break;
1858             }
1859             push(type, replacement);
1860           } else {
1861             push(type, append(load));
1862           }
1863         } else { // flattened field, not optimized solution: re-instantiate the flattened value
1864           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);
1865           ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();
1866           int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();
1867           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);
1868           scope()-&gt;set_wrote_final();
1869           scope()-&gt;set_wrote_fields();
1870           NewValueTypeInstance* new_instance = new NewValueTypeInstance(value_klass, state_before, false);
1871           _memory-&gt;new_instance(new_instance);
1872           apush(append_split(new_instance));
1873           copy_value_content(value_klass, obj, field-&gt;offset(), new_instance, value_klass-&gt;first_field_offset(),
1874                        state_before, needs_patching);
1875         }
1876       }
1877       break;
1878     }
1879     case Bytecodes::_withfield:
1880     case Bytecodes::_putfield: {
1881       Value val = pop(type);
1882       val-&gt;set_escaped();
1883       obj = apop();
1884       if (state_before == NULL) {
1885         state_before = copy_state_for_exception();
1886       }
1887       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1888         Value mask = append(new Constant(new IntConstant(1)));
1889         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1890       }
1891 
1892       if (!field-&gt;is_flattened()) {
1893         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);
1894         if (!needs_patching) store = _memory-&gt;store(store);
1895         if (store != NULL) {
1896           append(store);
1897         }
1898       } else {
1899         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);
1900         ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();
1901         int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();
1902         copy_value_content(value_klass, val, value_klass-&gt;first_field_offset(), obj, field-&gt;offset(),
1903                    state_before, needs_patching);
1904       }
1905       break;
1906     }
1907     default:
1908       ShouldNotReachHere();
1909       break;
1910   }
1911 }
1912 
1913 // Baseline version of withfield, allocate every time
1914 void GraphBuilder::withfield(int field_index)
1915 {
1916   bool will_link;
1917   ciField* field_modify = stream()-&gt;get_field(will_link);
1918   ciInstanceKlass* holder = field_modify-&gt;holder();
1919   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();
1920   ValueType* type = as_ValueType(field_type);
1921 
1922   // call will_link again to determine if the field is valid.
1923   const bool needs_patching = !holder-&gt;is_loaded() ||
1924                               !field_modify-&gt;will_link(method(), Bytecodes::_withfield) ||
1925                               PatchALot;
1926 
1927 
1928   scope()-&gt;set_wrote_final();
1929   scope()-&gt;set_wrote_fields();
1930 
1931   const int offset = !needs_patching ? field_modify-&gt;offset() : -1;
1932 
1933   if (!holder-&gt;is_loaded()
1934       || needs_patching /* FIXME: 8228634 - field_modify-&gt;will_link() may incorrectly return false */
1935       ) {
1936     ValueStack* state_before = copy_state_before();
1937     Value val = pop(type);
1938     Value obj = apop();
1939     apush(append_split(new WithField(state_before)));
1940     return;
1941   }
1942   ValueStack* state_before = copy_state_before();
1943 
1944   Value val = pop(type);
1945   Value obj = apop();
1946 
1947   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {
1948     int astore_index;
1949     ciBytecodeStream s(method());
1950     s.force_bci(bci());
1951     s.next();
1952     switch (s.cur_bc()) {
1953     case Bytecodes::_astore:    astore_index = s.get_index(); break;
1954     case Bytecodes::_astore_0:  astore_index = 0; break;
1955     case Bytecodes::_astore_1:  astore_index = 1; break;
1956     case Bytecodes::_astore_2:  astore_index = 2; break;
1957     case Bytecodes::_astore_3:  astore_index = 3; break;
1958     default: astore_index = -1;
1959     }
1960 
1961     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {
1962       // We have a sequence like this, where we load a value object from a local slot,
1963       // and overwrite the same local slot with a modified copy of the value object.
1964       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1
1965       //      astore 9
1966       //      ...
1967       //      iload_0
1968       //      aload 9
1969       //      swap
1970       //      withfield #7 // Field x:I
1971       //      astore 9
1972       // If this object was created by defaultvalue, and has not escaped, and is not stored
1973       // in any other local slots, we can effectively treat the withfield/astore
1974       // sequence as a single putfield bytecode.
1975       push(objectType, obj);
1976       push(type, val);
1977       access_field(Bytecodes::_withfield);
1978       stream()-&gt;next(); // skip the next astore/astore_n bytecode.
1979       return;
1980     }
1981   }
1982 
1983   assert(holder-&gt;is_valuetype(), &quot;must be a value klass&quot;);
1984   // Save the entire state and re-execute on deopt when executing withfield
1985   state_before-&gt;set_should_reexecute(true);
1986   NewValueTypeInstance* new_instance = new NewValueTypeInstance(holder-&gt;as_value_klass(), state_before, false);
1987   _memory-&gt;new_instance(new_instance);
1988   apush(append_split(new_instance));
1989 
1990   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {
1991     ciField* field = holder-&gt;nonstatic_field_at(i);
1992     int off = field-&gt;offset();
1993 
1994     if (field-&gt;offset() != offset) {
1995       if (field-&gt;is_flattened()) {
1996         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);
1997         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);
1998         ciValueKlass* vk = field-&gt;type()-&gt;as_value_klass();
1999         copy_value_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);
2000       } else {
2001         // Only load those fields who are not modified
2002         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);
2003         Value replacement = append(load);
2004         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);
2005         append(store);
2006       }
2007     }
2008   }
2009 
2010   // Field to modify
2011   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
2012     Value mask = append(new Constant(new IntConstant(1)));
2013     val = append(new LogicOp(Bytecodes::_iand, val, mask));
2014   }
2015   if (field_modify-&gt;is_flattened()) {
2016     assert(field_modify-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);
2017     ciValueKlass* vk = field_modify-&gt;type()-&gt;as_value_klass();
2018     copy_value_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);
2019   } else {
2020     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);
2021     append(store);
2022   }
2023 }
2024 
2025 Dependencies* GraphBuilder::dependency_recorder() const {
2026   assert(DeoptC1, &quot;need debug information&quot;);
2027   return compilation()-&gt;dependency_recorder();
2028 }
2029 
2030 // How many arguments do we want to profile?
2031 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2032   int n = 0;
2033   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2034   start = has_receiver ? 1 : 0;
2035   if (profile_arguments()) {
2036     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2037     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2038       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
2039     }
2040   }
2041   // If we are inlining then we need to collect arguments to profile parameters for the target
2042   if (profile_parameters() &amp;&amp; target != NULL) {
2043     if (target-&gt;method_data() != NULL &amp;&amp; target-&gt;method_data()-&gt;parameters_type_data() != NULL) {
2044       // The receiver is profiled on method entry so it&#39;s included in
2045       // the number of parameters but here we&#39;re only interested in
2046       // actual arguments.
2047       n = MAX2(n, target-&gt;method_data()-&gt;parameters_type_data()-&gt;number_of_parameters() - start);
2048     }
2049   }
2050   if (n &gt; 0) {
2051     return new Values(n);
2052   }
2053   return NULL;
2054 }
2055 
2056 void GraphBuilder::check_args_for_profiling(Values* obj_args, int expected) {
2057 #ifdef ASSERT
2058   bool ignored_will_link;
2059   ciSignature* declared_signature = NULL;
2060   ciMethod* real_target = method()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
2061   assert(expected == obj_args-&gt;max_length() || real_target-&gt;is_method_handle_intrinsic(), &quot;missed on arg?&quot;);
2062 #endif
2063 }
2064 
2065 // Collect arguments that we want to profile in a list
2066 Values* GraphBuilder::collect_args_for_profiling(Values* args, ciMethod* target, bool may_have_receiver) {
2067   int start = 0;
2068   Values* obj_args = args_list_for_profiling(target, start, may_have_receiver);
2069   if (obj_args == NULL) {
2070     return NULL;
2071   }
2072   int s = obj_args-&gt;max_length();
2073   // if called through method handle invoke, some arguments may have been popped
2074   for (int i = start, j = 0; j &lt; s &amp;&amp; i &lt; args-&gt;length(); i++) {
2075     if (args-&gt;at(i)-&gt;type()-&gt;is_object_kind()) {
2076       obj_args-&gt;push(args-&gt;at(i));
2077       j++;
2078     }
2079   }
2080   check_args_for_profiling(obj_args, s);
2081   return obj_args;
2082 }
2083 
2084 
2085 void GraphBuilder::invoke(Bytecodes::Code code) {
2086   bool will_link;
2087   ciSignature* declared_signature = NULL;
2088   ciMethod*             target = stream()-&gt;get_method(will_link, &amp;declared_signature);
2089   ciKlass*              holder = stream()-&gt;get_declared_method_holder();
2090   const Bytecodes::Code bc_raw = stream()-&gt;cur_bc_raw();
2091   assert(declared_signature != NULL, &quot;cannot be null&quot;);
2092   assert(will_link == target-&gt;is_loaded(), &quot;&quot;);
2093 
2094   ciInstanceKlass* klass = target-&gt;holder();
2095   assert(!target-&gt;is_loaded() || klass-&gt;is_loaded(), &quot;loaded target must imply loaded klass&quot;);
2096 
2097   // check if CHA possible: if so, change the code to invoke_special
2098   ciInstanceKlass* calling_klass = method()-&gt;holder();
2099   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
2100   ciInstanceKlass* actual_recv = callee_holder;
2101 
2102   CompileLog* log = compilation()-&gt;log();
2103   if (log != NULL)
2104       log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
2105                 log-&gt;identify(target),
2106                 Bytecodes::name(code));
2107 
2108   // invoke-special-super
2109   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_constructor()) {
2110     ciInstanceKlass* sender_klass =
2111           calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
2112                                                  calling_klass;
2113     if (sender_klass-&gt;is_interface()) {
2114       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
2115       Value receiver = state()-&gt;stack_at(index);
2116       CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());
2117       c-&gt;set_invokespecial_receiver_check();
2118       state()-&gt;stack_at_put(index, append_split(c));
2119     }
2120   }
2121 
2122   // Some methods are obviously bindable without any type checks so
2123   // convert them directly to an invokespecial or invokestatic.
2124   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
2125     switch (bc_raw) {
2126     case Bytecodes::_invokevirtual:
2127       code = Bytecodes::_invokespecial;
2128       break;
2129     case Bytecodes::_invokehandle:
2130       code = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokespecial;
2131       break;
2132     default:
2133       break;
2134     }
2135   } else {
2136     if (bc_raw == Bytecodes::_invokehandle) {
2137       assert(!will_link, &quot;should come here only for unlinked call&quot;);
2138       code = Bytecodes::_invokespecial;
2139     }
2140   }
2141 
2142   // Push appendix argument (MethodType, CallSite, etc.), if one.
2143   bool patch_for_appendix = false;
2144   int patching_appendix_arg = 0;
2145   if (Bytecodes::has_optional_appendix(bc_raw) &amp;&amp; (!will_link || PatchALot)) {
2146     Value arg = append(new Constant(new ObjectConstant(compilation()-&gt;env()-&gt;unloaded_ciinstance()), copy_state_before()));
2147     apush(arg);
2148     patch_for_appendix = true;
2149     patching_appendix_arg = (will_link &amp;&amp; stream()-&gt;has_appendix()) ? 0 : 1;
2150   } else if (stream()-&gt;has_appendix()) {
2151     ciObject* appendix = stream()-&gt;get_appendix();
2152     Value arg = append(new Constant(new ObjectConstant(appendix)));
2153     apush(arg);
2154   }
2155 
2156   ciMethod* cha_monomorphic_target = NULL;
2157   ciMethod* exact_target = NULL;
2158   Value better_receiver = NULL;
2159   if (UseCHA &amp;&amp; DeoptC1 &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2160       !(// %%% FIXME: Are both of these relevant?
2161         target-&gt;is_method_handle_intrinsic() ||
2162         target-&gt;is_compiled_lambda_form()) &amp;&amp;
2163       !patch_for_appendix) {
2164     Value receiver = NULL;
2165     ciInstanceKlass* receiver_klass = NULL;
2166     bool type_is_exact = false;
2167     // try to find a precise receiver type
2168     if (will_link &amp;&amp; !target-&gt;is_static()) {
2169       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
2170       receiver = state()-&gt;stack_at(index);
2171       ciType* type = receiver-&gt;exact_type();
2172       if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
2173           type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
2174         receiver_klass = (ciInstanceKlass*) type;
2175         type_is_exact = true;
2176       }
2177       if (type == NULL) {
2178         type = receiver-&gt;declared_type();
2179         if (type != NULL &amp;&amp; type-&gt;is_loaded() &amp;&amp;
2180             type-&gt;is_instance_klass() &amp;&amp; !type-&gt;as_instance_klass()-&gt;is_interface()) {
2181           receiver_klass = (ciInstanceKlass*) type;
2182           if (receiver_klass-&gt;is_leaf_type() &amp;&amp; !receiver_klass-&gt;is_final()) {
2183             // Insert a dependency on this type since
2184             // find_monomorphic_target may assume it&#39;s already done.
2185             dependency_recorder()-&gt;assert_leaf_type(receiver_klass);
2186             type_is_exact = true;
2187           }
2188         }
2189       }
2190     }
2191     if (receiver_klass != NULL &amp;&amp; type_is_exact &amp;&amp;
2192         receiver_klass-&gt;is_loaded() &amp;&amp; code != Bytecodes::_invokespecial) {
2193       // If we have the exact receiver type we can bind directly to
2194       // the method to call.
2195       exact_target = target-&gt;resolve_invoke(calling_klass, receiver_klass);
2196       if (exact_target != NULL) {
2197         target = exact_target;
2198         code = Bytecodes::_invokespecial;
2199       }
2200     }
2201     if (receiver_klass != NULL &amp;&amp;
2202         receiver_klass-&gt;is_subtype_of(actual_recv) &amp;&amp;
2203         actual_recv-&gt;is_initialized()) {
2204       actual_recv = receiver_klass;
2205     }
2206 
2207     if ((code == Bytecodes::_invokevirtual &amp;&amp; callee_holder-&gt;is_initialized()) ||
2208         (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_initialized() &amp;&amp; !actual_recv-&gt;is_interface())) {
2209       // Use CHA on the receiver to select a more precise method.
2210       cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, callee_holder, actual_recv);
2211     } else if (code == Bytecodes::_invokeinterface &amp;&amp; callee_holder-&gt;is_loaded() &amp;&amp; receiver != NULL) {
2212       assert(callee_holder-&gt;is_interface(), &quot;invokeinterface to non interface?&quot;);
2213       // If there is only one implementor of this interface then we
2214       // may be able bind this invoke directly to the implementing
2215       // klass but we need both a dependence on the single interface
2216       // and on the method we bind to.  Additionally since all we know
2217       // about the receiver type is the it&#39;s supposed to implement the
2218       // interface we have to insert a check that it&#39;s the class we
2219       // expect.  Interface types are not checked by the verifier so
2220       // they are roughly equivalent to Object.
2221       // The number of implementors for declared_interface is less or
2222       // equal to the number of implementors for target-&gt;holder() so
2223       // if number of implementors of target-&gt;holder() == 1 then
2224       // number of implementors for decl_interface is 0 or 1. If
2225       // it&#39;s 0 then no class implements decl_interface and there&#39;s
2226       // no point in inlining.
2227       ciInstanceKlass* declared_interface = callee_holder;
2228       ciInstanceKlass* singleton = declared_interface-&gt;unique_implementor();
2229       if (singleton != NULL &amp;&amp;
2230           (!target-&gt;is_default_method() || target-&gt;is_overpass()) /* CHA doesn&#39;t support default methods yet. */ ) {
2231         assert(singleton != declared_interface, &quot;not a unique implementor&quot;);
2232         cha_monomorphic_target = target-&gt;find_monomorphic_target(calling_klass, declared_interface, singleton);
2233         if (cha_monomorphic_target != NULL) {
2234           if (cha_monomorphic_target-&gt;holder() != compilation()-&gt;env()-&gt;Object_klass()) {
2235             // If CHA is able to bind this invoke then update the class
2236             // to match that class, otherwise klass will refer to the
2237             // interface.
2238             klass = cha_monomorphic_target-&gt;holder();
2239             actual_recv = declared_interface;
2240 
2241             // insert a check it&#39;s really the expected class.
2242             CheckCast* c = new CheckCast(klass, receiver, copy_state_for_exception());
2243             c-&gt;set_incompatible_class_change_check();
2244             c-&gt;set_direct_compare(klass-&gt;is_final());
2245             // pass the result of the checkcast so that the compiler has
2246             // more accurate type info in the inlinee
2247             better_receiver = append_split(c);
2248           } else {
2249             cha_monomorphic_target = NULL; // subtype check against Object is useless
2250           }
2251         }
2252       }
2253     }
2254   }
2255 
2256   if (cha_monomorphic_target != NULL) {
2257     assert(!target-&gt;can_be_statically_bound() || target == cha_monomorphic_target, &quot;&quot;);
2258     assert(!cha_monomorphic_target-&gt;is_abstract(), &quot;&quot;);
2259     if (!cha_monomorphic_target-&gt;can_be_statically_bound(actual_recv)) {
2260       // If we inlined because CHA revealed only a single target method,
2261       // then we are dependent on that target method not getting overridden
2262       // by dynamic class loading.  Be sure to test the &quot;static&quot; receiver
2263       // dest_method here, as opposed to the actual receiver, which may
2264       // falsely lead us to believe that the receiver is final or private.
2265       dependency_recorder()-&gt;assert_unique_concrete_method(actual_recv, cha_monomorphic_target);
2266     }
2267     code = Bytecodes::_invokespecial;
2268   }
2269 
2270   // check if we could do inlining
2271   if (!PatchALot &amp;&amp; Inline &amp;&amp; target-&gt;is_loaded() &amp;&amp;
2272       (klass-&gt;is_initialized() || (klass-&gt;is_interface() &amp;&amp; target-&gt;holder()-&gt;is_initialized()))
2273       &amp;&amp; !patch_for_appendix) {
2274     // callee is known =&gt; check if we have static binding
2275     if (code == Bytecodes::_invokestatic  ||
2276         code == Bytecodes::_invokespecial ||
2277         (code == Bytecodes::_invokevirtual &amp;&amp; target-&gt;is_final_method()) ||
2278         code == Bytecodes::_invokedynamic) {
2279       ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;
2280       // static binding =&gt; check if callee is ok
2281       bool success = try_inline(inline_target, (cha_monomorphic_target != NULL) || (exact_target != NULL), false, code, better_receiver);
2282 
2283       CHECK_BAILOUT();
2284       clear_inline_bailout();
2285 
2286       if (success) {
2287         // Register dependence if JVMTI has either breakpoint
2288         // setting or hotswapping of methods capabilities since they may
2289         // cause deoptimization.
2290         if (compilation()-&gt;env()-&gt;jvmti_can_hotswap_or_post_breakpoint()) {
2291           dependency_recorder()-&gt;assert_evol_method(inline_target);
2292         }
2293         return;
2294       }
2295     } else {
2296       print_inlining(target, &quot;no static binding&quot;, /*success*/ false);
2297     }
2298   } else {
2299     print_inlining(target, &quot;not inlineable&quot;, /*success*/ false);
2300   }
2301 
2302   // If we attempted an inline which did not succeed because of a
2303   // bailout during construction of the callee graph, the entire
2304   // compilation has to be aborted. This is fairly rare and currently
2305   // seems to only occur for jasm-generated classes which contain
2306   // jsr/ret pairs which are not associated with finally clauses and
2307   // do not have exception handlers in the containing method, and are
2308   // therefore not caught early enough to abort the inlining without
2309   // corrupting the graph. (We currently bail out with a non-empty
2310   // stack at a ret in these situations.)
2311   CHECK_BAILOUT();
2312 
2313   // inlining not successful =&gt; standard invoke
2314   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2315   ValueStack* state_before = copy_state_exhandling();
2316 
2317   // The bytecode (code) might change in this method so we are checking this very late.
2318   const bool has_receiver =
2319     code == Bytecodes::_invokespecial   ||
2320     code == Bytecodes::_invokevirtual   ||
2321     code == Bytecodes::_invokeinterface;
2322   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2323   Value recv = has_receiver ? apop() : NULL;
2324   int vtable_index = Method::invalid_vtable_index;
2325 
2326 #ifdef SPARC
2327   // Currently only supported on Sparc.
2328   // The UseInlineCaches only controls dispatch to invokevirtuals for
2329   // loaded classes which we weren&#39;t able to statically bind.
2330   if (!UseInlineCaches &amp;&amp; target-&gt;is_loaded() &amp;&amp; code == Bytecodes::_invokevirtual
2331       &amp;&amp; !target-&gt;can_be_statically_bound()) {
2332     // Find a vtable index if one is available
2333     // For arrays, callee_holder is Object. Resolving the call with
2334     // Object would allow an illegal call to finalize() on an
2335     // array. We use holder instead: illegal calls to finalize() won&#39;t
2336     // be compiled as vtable calls (IC call resolution will catch the
2337     // illegal call) and the few legal calls on array types won&#39;t be
2338     // either.
2339     vtable_index = target-&gt;resolve_vtable_index(calling_klass, holder);
2340   }
2341 #endif
2342 
2343   // A null check is required here (when there is a receiver) for any of the following cases
2344   // - invokespecial, always need a null check.
2345   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2346   //   and require null checking. If the target is loaded a null check is emitted here.
2347   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2348   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2349   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2350   //   potentially fail, and can&#39;t have the null check before the resolution.)
2351   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2352   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2353   //
2354   // Normal invokevirtual will perform the null check during lookup
2355 
2356   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2357       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2358 
2359   if (need_null_check) {
2360     if (recv != NULL) {
2361       null_check(recv);
2362     }
2363 
2364     if (is_profiling()) {
2365       // Note that we&#39;d collect profile data in this method if we wanted it.
2366       compilation()-&gt;set_would_profile(true);
2367 
2368       if (profile_calls()) {
2369         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2370         ciKlass* target_klass = NULL;
2371         if (cha_monomorphic_target != NULL) {
2372           target_klass = cha_monomorphic_target-&gt;holder();
2373         } else if (exact_target != NULL) {
2374           target_klass = exact_target-&gt;holder();
2375         }
2376         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2377       }
2378     }
2379   }
2380 
2381   if (recv != NULL) {
2382     recv-&gt;set_escaped();
2383   }
2384   for (int i=0; i&lt;args-&gt;length(); i++) {
2385     args-&gt;at(0)-&gt;set_escaped();
2386   }
2387 
2388   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,
2389                               declared_signature-&gt;returns_never_null());
2390   // push result
2391   append_split(result);
2392 
2393   if (result_type != voidType) {
2394     if (method()-&gt;is_strict()) {
2395       push(result_type, round_fp(result));
2396     } else {
2397       push(result_type, result);
2398     }
2399   }
2400   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2401     profile_return_type(result, target);
2402   }
2403 }
2404 
2405 
2406 void GraphBuilder::new_instance(int klass_index) {
2407   ValueStack* state_before = copy_state_exhandling();
2408   bool will_link;
2409   ciKlass* klass = stream()-&gt;get_klass(will_link);
2410   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2411   assert(!klass-&gt;is_valuetype(), &quot;must not be a value klass&quot;);
2412   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2413   _memory-&gt;new_instance(new_instance);
2414   apush(append_split(new_instance));
2415 }
2416 
2417 void GraphBuilder::default_value(int klass_index) {
2418   bool will_link;
2419   ciValueKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_value_klass();
2420   if (!stream()-&gt;is_unresolved_klass()) {
2421     apush(append(new Constant(new InstanceConstant(vk-&gt;default_value_instance()))));
2422   } else {
2423     ValueStack* state_before = copy_state_before();
2424     apush(append_split(new DefaultValue(state_before)));
2425   }
2426 }
2427 
2428 void GraphBuilder::new_type_array() {
2429   ValueStack* state_before = copy_state_exhandling();
2430   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2431 }
2432 
2433 
2434 void GraphBuilder::new_object_array() {
2435   bool will_link;
2436   ciKlass* klass = stream()-&gt;get_klass(will_link);
2437   bool never_null = stream()-&gt;is_klass_never_null();
2438   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2439   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);
2440   apush(append_split(n));
2441 }
2442 
2443 
2444 bool GraphBuilder::direct_compare(ciKlass* k) {
2445   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2446     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2447     if (ik-&gt;is_final()) {
2448       return true;
2449     } else {
2450       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2451         // test class is leaf class
2452         dependency_recorder()-&gt;assert_leaf_type(ik);
2453         return true;
2454       }
2455     }
2456   }
2457   return false;
2458 }
2459 
2460 
2461 void GraphBuilder::check_cast(int klass_index) {
2462   bool will_link;
2463   ciKlass* klass = stream()-&gt;get_klass(will_link);
2464   bool never_null = stream()-&gt;is_klass_never_null();
2465   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
2466   CheckCast* c = new CheckCast(klass, apop(), state_before, never_null);
2467   apush(append_split(c));
2468   c-&gt;set_direct_compare(direct_compare(klass));
2469 
2470   if (is_profiling()) {
2471     // Note that we&#39;d collect profile data in this method if we wanted it.
2472     compilation()-&gt;set_would_profile(true);
2473 
2474     if (profile_checkcasts()) {
2475       c-&gt;set_profiled_method(method());
2476       c-&gt;set_profiled_bci(bci());
2477       c-&gt;set_should_profile(true);
2478     }
2479   }
2480 }
2481 
2482 
2483 void GraphBuilder::instance_of(int klass_index) {
2484   bool will_link;
2485   ciKlass* klass = stream()-&gt;get_klass(will_link);
2486   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2487   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2488   ipush(append_split(i));
2489   i-&gt;set_direct_compare(direct_compare(klass));
2490 
2491   if (is_profiling()) {
2492     // Note that we&#39;d collect profile data in this method if we wanted it.
2493     compilation()-&gt;set_would_profile(true);
2494 
2495     if (profile_checkcasts()) {
2496       i-&gt;set_profiled_method(method());
2497       i-&gt;set_profiled_bci(bci());
2498       i-&gt;set_should_profile(true);
2499     }
2500   }
2501 }
2502 
2503 
2504 void GraphBuilder::monitorenter(Value x, int bci) {
2505   bool maybe_valuetype = false;
2506   if (bci == InvocationEntryBci) {
2507     // Called by GraphBuilder::inline_sync_entry.
2508 #ifdef ASSERT
2509     ciType* obj_type = x-&gt;declared_type();
2510     assert(obj_type == NULL || !obj_type-&gt;is_valuetype(), &quot;valuetypes cannot have synchronized methods&quot;);
2511 #endif
2512   } else {
2513     // We are compiling a monitorenter bytecode
2514     if (EnableValhalla) {
2515       ciType* obj_type = x-&gt;declared_type();
2516       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_value_klass()) {
2517         // If we&#39;re (possibly) locking on a valuetype, check for markWord::always_locked_pattern
2518         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).
2519         maybe_valuetype = true;
2520       }
2521     }
2522   }
2523 
2524   // save state before locking in case of deoptimization after a NullPointerException
2525   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
2526   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_valuetype), bci);
2527   kill_all();
2528 }
2529 
2530 
2531 void GraphBuilder::monitorexit(Value x, int bci) {
2532   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2533   kill_all();
2534 }
2535 
2536 
2537 void GraphBuilder::new_multi_array(int dimensions) {
2538   bool will_link;
2539   ciKlass* klass = stream()-&gt;get_klass(will_link);
2540   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2541 
2542   Values* dims = new Values(dimensions, dimensions, NULL);
2543   // fill in all dimensions
2544   int i = dimensions;
2545   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2546   // create array
2547   NewArray* n = new NewMultiArray(klass, dims, state_before);
2548   apush(append_split(n));
2549 }
2550 
2551 
2552 void GraphBuilder::throw_op(int bci) {
2553   // We require that the debug info for a Throw be the &quot;state before&quot;
2554   // the Throw (i.e., exception oop is still on TOS)
2555   ValueStack* state_before = copy_state_before_with_bci(bci);
2556   Throw* t = new Throw(apop(), state_before);
2557   // operand stack not needed after a throw
2558   state()-&gt;truncate_stack(0);
2559   append_with_bci(t, bci);
2560 }
2561 
2562 
2563 Value GraphBuilder::round_fp(Value fp_value) {
2564   if (strict_fp_requires_explicit_rounding) {
2565 #ifdef IA32
2566     // no rounding needed if SSE2 is used
2567     if (UseSSE &lt; 2) {
2568       // Must currently insert rounding node for doubleword values that
2569       // are results of expressions (i.e., not loads from memory or
2570       // constants)
2571       if (fp_value-&gt;type()-&gt;tag() == doubleTag &amp;&amp;
2572           fp_value-&gt;as_Constant() == NULL &amp;&amp;
2573           fp_value-&gt;as_Local() == NULL &amp;&amp;       // method parameters need no rounding
2574           fp_value-&gt;as_RoundFP() == NULL) {
2575         return append(new RoundFP(fp_value));
2576       }
2577     }
2578 #else
2579     Unimplemented();
2580 #endif // IA32
2581   }
2582   return fp_value;
2583 }
2584 
2585 
2586 Instruction* GraphBuilder::append_with_bci(Instruction* instr, int bci) {
2587   Canonicalizer canon(compilation(), instr, bci);
2588   Instruction* i1 = canon.canonical();
2589   if (i1-&gt;is_linked() || !i1-&gt;can_be_linked()) {
2590     // Canonicalizer returned an instruction which was already
2591     // appended so simply return it.
2592     return i1;
2593   }
2594 
2595   if (UseLocalValueNumbering) {
2596     // Lookup the instruction in the ValueMap and add it to the map if
2597     // it&#39;s not found.
2598     Instruction* i2 = vmap()-&gt;find_insert(i1);
2599     if (i2 != i1) {
2600       // found an entry in the value map, so just return it.
2601       assert(i2-&gt;is_linked(), &quot;should already be linked&quot;);
2602       return i2;
2603     }
2604     ValueNumberingEffects vne(vmap());
2605     i1-&gt;visit(&amp;vne);
2606   }
2607 
2608   // i1 was not eliminated =&gt; append it
2609   assert(i1-&gt;next() == NULL, &quot;shouldn&#39;t already be linked&quot;);
2610   _last = _last-&gt;set_next(i1, canon.bci());
2611 
2612   if (++_instruction_count &gt;= InstructionCountCutoff &amp;&amp; !bailed_out()) {
2613     // set the bailout state but complete normal processing.  We
2614     // might do a little more work before noticing the bailout so we
2615     // want processing to continue normally until it&#39;s noticed.
2616     bailout(&quot;Method and/or inlining is too large&quot;);
2617   }
2618 
2619 #ifndef PRODUCT
2620   if (PrintIRDuringConstruction) {
2621     InstructionPrinter ip;
2622     ip.print_line(i1);
2623     if (Verbose) {
2624       state()-&gt;print();
2625     }
2626   }
2627 #endif
2628 
2629   // save state after modification of operand stack for StateSplit instructions
2630   StateSplit* s = i1-&gt;as_StateSplit();
2631   if (s != NULL) {
2632     if (EliminateFieldAccess) {
2633       Intrinsic* intrinsic = s-&gt;as_Intrinsic();
2634       if (s-&gt;as_Invoke() != NULL || (intrinsic &amp;&amp; !intrinsic-&gt;preserves_state())) {
2635         _memory-&gt;kill();
2636       }
2637     }
2638     s-&gt;set_state(state()-&gt;copy(ValueStack::StateAfter, canon.bci()));
2639   }
2640 
2641   // set up exception handlers for this instruction if necessary
2642   if (i1-&gt;can_trap()) {
2643     i1-&gt;set_exception_handlers(handle_exception(i1));
2644     assert(i1-&gt;exception_state() != NULL || !i1-&gt;needs_exception_state() || bailed_out(), &quot;handle_exception must set exception state&quot;);
2645   }
2646   return i1;
2647 }
2648 
2649 
2650 Instruction* GraphBuilder::append(Instruction* instr) {
2651   assert(instr-&gt;as_StateSplit() == NULL || instr-&gt;as_BlockEnd() != NULL, &quot;wrong append used&quot;);
2652   return append_with_bci(instr, bci());
2653 }
2654 
2655 
2656 Instruction* GraphBuilder::append_split(StateSplit* instr) {
2657   return append_with_bci(instr, bci());
2658 }
2659 
2660 
2661 void GraphBuilder::null_check(Value value) {
2662   if (value-&gt;as_NewArray() != NULL || value-&gt;as_NewInstance() != NULL) {
2663     return;
2664   } else {
2665     Constant* con = value-&gt;as_Constant();
2666     if (con) {
2667       ObjectType* c = con-&gt;type()-&gt;as_ObjectType();
2668       if (c &amp;&amp; c-&gt;is_loaded()) {
2669         ObjectConstant* oc = c-&gt;as_ObjectConstant();
2670         if (!oc || !oc-&gt;value()-&gt;is_null_object()) {
2671           return;
2672         }
2673       }
2674     }
2675   }
2676   append(new NullCheck(value, copy_state_for_exception()));
2677 }
2678 
2679 
2680 
2681 XHandlers* GraphBuilder::handle_exception(Instruction* instruction) {
2682   if (!has_handler() &amp;&amp; (!instruction-&gt;needs_exception_state() || instruction-&gt;exception_state() != NULL)) {
2683     assert(instruction-&gt;exception_state() == NULL
2684            || instruction-&gt;exception_state()-&gt;kind() == ValueStack::EmptyExceptionState
2685            || (instruction-&gt;exception_state()-&gt;kind() == ValueStack::ExceptionState &amp;&amp; _compilation-&gt;env()-&gt;should_retain_local_variables()),
2686            &quot;exception_state should be of exception kind&quot;);
2687     return new XHandlers();
2688   }
2689 
2690   XHandlers*  exception_handlers = new XHandlers();
2691   ScopeData*  cur_scope_data = scope_data();
2692   ValueStack* cur_state = instruction-&gt;state_before();
2693   ValueStack* prev_state = NULL;
2694   int scope_count = 0;
2695 
2696   assert(cur_state != NULL, &quot;state_before must be set&quot;);
2697   do {
2698     int cur_bci = cur_state-&gt;bci();
2699     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2700     assert(cur_bci == SynchronizationEntryBCI || cur_bci == cur_scope_data-&gt;stream()-&gt;cur_bci(), &quot;invalid bci&quot;);
2701 
2702     // join with all potential exception handlers
2703     XHandlers* list = cur_scope_data-&gt;xhandlers();
2704     const int n = list-&gt;length();
2705     for (int i = 0; i &lt; n; i++) {
2706       XHandler* h = list-&gt;handler_at(i);
2707       if (h-&gt;covers(cur_bci)) {
2708         // h is a potential exception handler =&gt; join it
2709         compilation()-&gt;set_has_exception_handlers(true);
2710 
2711         BlockBegin* entry = h-&gt;entry_block();
2712         if (entry == block()) {
2713           // It&#39;s acceptable for an exception handler to cover itself
2714           // but we don&#39;t handle that in the parser currently.  It&#39;s
2715           // very rare so we bailout instead of trying to handle it.
2716           BAILOUT_(&quot;exception handler covers itself&quot;, exception_handlers);
2717         }
2718         assert(entry-&gt;bci() == h-&gt;handler_bci(), &quot;must match&quot;);
2719         assert(entry-&gt;bci() == -1 || entry == cur_scope_data-&gt;block_at(entry-&gt;bci()), &quot;blocks must correspond&quot;);
2720 
2721         // previously this was a BAILOUT, but this is not necessary
2722         // now because asynchronous exceptions are not handled this way.
2723         assert(entry-&gt;state() == NULL || cur_state-&gt;total_locks_size() == entry-&gt;state()-&gt;total_locks_size(), &quot;locks do not match&quot;);
2724 
2725         // xhandler start with an empty expression stack
2726         if (cur_state-&gt;stack_size() != 0) {
2727           cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2728         }
2729         if (instruction-&gt;exception_state() == NULL) {
2730           instruction-&gt;set_exception_state(cur_state);
2731         }
2732 
2733         // Note: Usually this join must work. However, very
2734         // complicated jsr-ret structures where we don&#39;t ret from
2735         // the subroutine can cause the objects on the monitor
2736         // stacks to not match because blocks can be parsed twice.
2737         // The only test case we&#39;ve seen so far which exhibits this
2738         // problem is caught by the infinite recursion test in
2739         // GraphBuilder::jsr() if the join doesn&#39;t work.
2740         if (!entry-&gt;try_merge(cur_state)) {
2741           BAILOUT_(&quot;error while joining with exception handler, prob. due to complicated jsr/rets&quot;, exception_handlers);
2742         }
2743 
2744         // add current state for correct handling of phi functions at begin of xhandler
2745         int phi_operand = entry-&gt;add_exception_state(cur_state);
2746 
2747         // add entry to the list of xhandlers of this block
2748         _block-&gt;add_exception_handler(entry);
2749 
2750         // add back-edge from xhandler entry to this block
2751         if (!entry-&gt;is_predecessor(_block)) {
2752           entry-&gt;add_predecessor(_block);
2753         }
2754 
2755         // clone XHandler because phi_operand and scope_count can not be shared
2756         XHandler* new_xhandler = new XHandler(h);
2757         new_xhandler-&gt;set_phi_operand(phi_operand);
2758         new_xhandler-&gt;set_scope_count(scope_count);
2759         exception_handlers-&gt;append(new_xhandler);
2760 
2761         // fill in exception handler subgraph lazily
2762         assert(!entry-&gt;is_set(BlockBegin::was_visited_flag), &quot;entry must not be visited yet&quot;);
2763         cur_scope_data-&gt;add_to_work_list(entry);
2764 
2765         // stop when reaching catchall
2766         if (h-&gt;catch_type() == 0) {
2767           return exception_handlers;
2768         }
2769       }
2770     }
2771 
2772     if (exception_handlers-&gt;length() == 0) {
2773       // This scope and all callees do not handle exceptions, so the local
2774       // variables of this scope are not needed. However, the scope itself is
2775       // required for a correct exception stack trace -&gt; clear out the locals.
2776       if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
2777         cur_state = cur_state-&gt;copy(ValueStack::ExceptionState, cur_state-&gt;bci());
2778       } else {
2779         cur_state = cur_state-&gt;copy(ValueStack::EmptyExceptionState, cur_state-&gt;bci());
2780       }
2781       if (prev_state != NULL) {
2782         prev_state-&gt;set_caller_state(cur_state);
2783       }
2784       if (instruction-&gt;exception_state() == NULL) {
2785         instruction-&gt;set_exception_state(cur_state);
2786       }
2787     }
2788 
2789     // Set up iteration for next time.
2790     // If parsing a jsr, do not grab exception handlers from the
2791     // parent scopes for this method (already got them, and they
2792     // needed to be cloned)
2793 
2794     while (cur_scope_data-&gt;parsing_jsr()) {
2795       cur_scope_data = cur_scope_data-&gt;parent();
2796     }
2797 
2798     assert(cur_scope_data-&gt;scope() == cur_state-&gt;scope(), &quot;scopes do not match&quot;);
2799     assert(cur_state-&gt;locks_size() == 0 || cur_state-&gt;locks_size() == 1, &quot;unlocking must be done in a catchall exception handler&quot;);
2800 
2801     prev_state = cur_state;
2802     cur_state = cur_state-&gt;caller_state();
2803     cur_scope_data = cur_scope_data-&gt;parent();
2804     scope_count++;
2805   } while (cur_scope_data != NULL);
2806 
2807   return exception_handlers;
2808 }
2809 
2810 
2811 // Helper class for simplifying Phis.
2812 class PhiSimplifier : public BlockClosure {
2813  private:
2814   bool _has_substitutions;
2815   Value simplify(Value v);
2816 
2817  public:
2818   PhiSimplifier(BlockBegin* start) : _has_substitutions(false) {
2819     start-&gt;iterate_preorder(this);
2820     if (_has_substitutions) {
2821       SubstitutionResolver sr(start);
2822     }
2823   }
2824   void block_do(BlockBegin* b);
2825   bool has_substitutions() const { return _has_substitutions; }
2826 };
2827 
2828 
2829 Value PhiSimplifier::simplify(Value v) {
2830   Phi* phi = v-&gt;as_Phi();
2831 
2832   if (phi == NULL) {
2833     // no phi function
2834     return v;
2835   } else if (v-&gt;has_subst()) {
2836     // already substituted; subst can be phi itself -&gt; simplify
2837     return simplify(v-&gt;subst());
2838   } else if (phi-&gt;is_set(Phi::cannot_simplify)) {
2839     // already tried to simplify phi before
2840     return phi;
2841   } else if (phi-&gt;is_set(Phi::visited)) {
2842     // break cycles in phi functions
2843     return phi;
2844   } else if (phi-&gt;type()-&gt;is_illegal()) {
2845     // illegal phi functions are ignored anyway
2846     return phi;
2847 
2848   } else {
2849     // mark phi function as processed to break cycles in phi functions
2850     phi-&gt;set(Phi::visited);
2851 
2852     // simplify x = [y, x] and x = [y, y] to y
2853     Value subst = NULL;
2854     int opd_count = phi-&gt;operand_count();
2855     for (int i = 0; i &lt; opd_count; i++) {
2856       Value opd = phi-&gt;operand_at(i);
2857       assert(opd != NULL, &quot;Operand must exist!&quot;);
2858 
2859       if (opd-&gt;type()-&gt;is_illegal()) {
2860         // if one operand is illegal, the entire phi function is illegal
2861         phi-&gt;make_illegal();
2862         phi-&gt;clear(Phi::visited);
2863         return phi;
2864       }
2865 
2866       Value new_opd = simplify(opd);
2867       assert(new_opd != NULL, &quot;Simplified operand must exist!&quot;);
2868 
2869       if (new_opd != phi &amp;&amp; new_opd != subst) {
2870         if (subst == NULL) {
2871           subst = new_opd;
2872         } else {
2873           // no simplification possible
2874           phi-&gt;set(Phi::cannot_simplify);
2875           phi-&gt;clear(Phi::visited);
2876           return phi;
2877         }
2878       }
2879     }
2880 
2881     // sucessfully simplified phi function
2882     assert(subst != NULL, &quot;illegal phi function&quot;);
2883     _has_substitutions = true;
2884     phi-&gt;clear(Phi::visited);
2885     phi-&gt;set_subst(subst);
2886 
2887 #ifndef PRODUCT
2888     if (PrintPhiFunctions) {
2889       tty-&gt;print_cr(&quot;simplified phi function %c%d to %c%d (Block B%d)&quot;, phi-&gt;type()-&gt;tchar(), phi-&gt;id(), subst-&gt;type()-&gt;tchar(), subst-&gt;id(), phi-&gt;block()-&gt;block_id());
2890     }
2891 #endif
2892 
2893     return subst;
2894   }
2895 }
2896 
2897 
2898 void PhiSimplifier::block_do(BlockBegin* b) {
2899   for_each_phi_fun(b, phi,
2900     simplify(phi);
2901   );
2902 
2903 #ifdef ASSERT
2904   for_each_phi_fun(b, phi,
2905                    assert(phi-&gt;operand_count() != 1 || phi-&gt;subst() != phi || phi-&gt;is_illegal(), &quot;missed trivial simplification&quot;);
2906   );
2907 
2908   ValueStack* state = b-&gt;state()-&gt;caller_state();
2909   for_each_state_value(state, value,
2910     Phi* phi = value-&gt;as_Phi();
2911     assert(phi == NULL || phi-&gt;block() != b, &quot;must not have phi function to simplify in caller state&quot;);
2912   );
2913 #endif
2914 }
2915 
2916 // This method is called after all blocks are filled with HIR instructions
2917 // It eliminates all Phi functions of the form x = [y, y] and x = [y, x]
2918 void GraphBuilder::eliminate_redundant_phis(BlockBegin* start) {
2919   PhiSimplifier simplifier(start);
2920 }
2921 
2922 
2923 void GraphBuilder::connect_to_end(BlockBegin* beg) {
2924   // setup iteration
2925   kill_all();
2926   _block = beg;
2927   _state = beg-&gt;state()-&gt;copy_for_parsing();
2928   _last  = beg;
2929   iterate_bytecodes_for_block(beg-&gt;bci());
2930 }
2931 
2932 
2933 BlockEnd* GraphBuilder::iterate_bytecodes_for_block(int bci) {
2934 #ifndef PRODUCT
2935   if (PrintIRDuringConstruction) {
2936     tty-&gt;cr();
2937     InstructionPrinter ip;
2938     ip.print_instr(_block); tty-&gt;cr();
2939     ip.print_stack(_block-&gt;state()); tty-&gt;cr();
2940     ip.print_inline_level(_block);
2941     ip.print_head();
2942     tty-&gt;print_cr(&quot;locals size: %d stack size: %d&quot;, state()-&gt;locals_size(), state()-&gt;stack_size());
2943   }
2944 #endif
2945   _skip_block = false;
2946   assert(state() != NULL, &quot;ValueStack missing!&quot;);
2947   CompileLog* log = compilation()-&gt;log();
2948   ciBytecodeStream s(method());
2949   s.reset_to_bci(bci);
2950   int prev_bci = bci;
2951   scope_data()-&gt;set_stream(&amp;s);
2952   // iterate
2953   Bytecodes::Code code = Bytecodes::_illegal;
2954   bool push_exception = false;
2955 
2956   if (block()-&gt;is_set(BlockBegin::exception_entry_flag) &amp;&amp; block()-&gt;next() == NULL) {
2957     // first thing in the exception entry block should be the exception object.
2958     push_exception = true;
2959   }
2960 
2961   bool ignore_return = scope_data()-&gt;ignore_return();
2962 
2963   while (!bailed_out() &amp;&amp; last()-&gt;as_BlockEnd() == NULL &amp;&amp;
2964          (code = stream()-&gt;next()) != ciBytecodeStream::EOBC() &amp;&amp;
2965          (block_at(s.cur_bci()) == NULL || block_at(s.cur_bci()) == block())) {
2966     assert(state()-&gt;kind() == ValueStack::Parsing, &quot;invalid state kind&quot;);
2967 
2968     if (log != NULL)
2969       log-&gt;set_context(&quot;bc code=&#39;%d&#39; bci=&#39;%d&#39;&quot;, (int)code, s.cur_bci());
2970 
2971     // Check for active jsr during OSR compilation
2972     if (compilation()-&gt;is_osr_compile()
2973         &amp;&amp; scope()-&gt;is_top_scope()
2974         &amp;&amp; parsing_jsr()
2975         &amp;&amp; s.cur_bci() == compilation()-&gt;osr_bci()) {
2976       bailout(&quot;OSR not supported while a jsr is active&quot;);
2977     }
2978 
2979     if (push_exception) {
2980       apush(append(new ExceptionObject()));
2981       push_exception = false;
2982     }
2983 
2984     // handle bytecode
2985     switch (code) {
2986       case Bytecodes::_nop            : /* nothing to do */ break;
2987       case Bytecodes::_aconst_null    : apush(append(new Constant(objectNull            ))); break;
2988       case Bytecodes::_iconst_m1      : ipush(append(new Constant(new IntConstant   (-1)))); break;
2989       case Bytecodes::_iconst_0       : ipush(append(new Constant(intZero               ))); break;
2990       case Bytecodes::_iconst_1       : ipush(append(new Constant(intOne                ))); break;
2991       case Bytecodes::_iconst_2       : ipush(append(new Constant(new IntConstant   ( 2)))); break;
2992       case Bytecodes::_iconst_3       : ipush(append(new Constant(new IntConstant   ( 3)))); break;
2993       case Bytecodes::_iconst_4       : ipush(append(new Constant(new IntConstant   ( 4)))); break;
2994       case Bytecodes::_iconst_5       : ipush(append(new Constant(new IntConstant   ( 5)))); break;
2995       case Bytecodes::_lconst_0       : lpush(append(new Constant(new LongConstant  ( 0)))); break;
2996       case Bytecodes::_lconst_1       : lpush(append(new Constant(new LongConstant  ( 1)))); break;
2997       case Bytecodes::_fconst_0       : fpush(append(new Constant(new FloatConstant ( 0)))); break;
2998       case Bytecodes::_fconst_1       : fpush(append(new Constant(new FloatConstant ( 1)))); break;
2999       case Bytecodes::_fconst_2       : fpush(append(new Constant(new FloatConstant ( 2)))); break;
3000       case Bytecodes::_dconst_0       : dpush(append(new Constant(new DoubleConstant( 0)))); break;
3001       case Bytecodes::_dconst_1       : dpush(append(new Constant(new DoubleConstant( 1)))); break;
3002       case Bytecodes::_bipush         : ipush(append(new Constant(new IntConstant(((signed char*)s.cur_bcp())[1])))); break;
3003       case Bytecodes::_sipush         : ipush(append(new Constant(new IntConstant((short)Bytes::get_Java_u2(s.cur_bcp()+1))))); break;
3004       case Bytecodes::_ldc            : // fall through
3005       case Bytecodes::_ldc_w          : // fall through
3006       case Bytecodes::_ldc2_w         : load_constant(); break;
3007       case Bytecodes::_iload          : load_local(intType     , s.get_index()); break;
3008       case Bytecodes::_lload          : load_local(longType    , s.get_index()); break;
3009       case Bytecodes::_fload          : load_local(floatType   , s.get_index()); break;
3010       case Bytecodes::_dload          : load_local(doubleType  , s.get_index()); break;
3011       case Bytecodes::_aload          : load_local(instanceType, s.get_index()); break;
3012       case Bytecodes::_iload_0        : load_local(intType   , 0); break;
3013       case Bytecodes::_iload_1        : load_local(intType   , 1); break;
3014       case Bytecodes::_iload_2        : load_local(intType   , 2); break;
3015       case Bytecodes::_iload_3        : load_local(intType   , 3); break;
3016       case Bytecodes::_lload_0        : load_local(longType  , 0); break;
3017       case Bytecodes::_lload_1        : load_local(longType  , 1); break;
3018       case Bytecodes::_lload_2        : load_local(longType  , 2); break;
3019       case Bytecodes::_lload_3        : load_local(longType  , 3); break;
3020       case Bytecodes::_fload_0        : load_local(floatType , 0); break;
3021       case Bytecodes::_fload_1        : load_local(floatType , 1); break;
3022       case Bytecodes::_fload_2        : load_local(floatType , 2); break;
3023       case Bytecodes::_fload_3        : load_local(floatType , 3); break;
3024       case Bytecodes::_dload_0        : load_local(doubleType, 0); break;
3025       case Bytecodes::_dload_1        : load_local(doubleType, 1); break;
3026       case Bytecodes::_dload_2        : load_local(doubleType, 2); break;
3027       case Bytecodes::_dload_3        : load_local(doubleType, 3); break;
3028       case Bytecodes::_aload_0        : load_local(objectType, 0); break;
3029       case Bytecodes::_aload_1        : load_local(objectType, 1); break;
3030       case Bytecodes::_aload_2        : load_local(objectType, 2); break;
3031       case Bytecodes::_aload_3        : load_local(objectType, 3); break;
3032       case Bytecodes::_iaload         : load_indexed(T_INT   ); break;
3033       case Bytecodes::_laload         : load_indexed(T_LONG  ); break;
3034       case Bytecodes::_faload         : load_indexed(T_FLOAT ); break;
3035       case Bytecodes::_daload         : load_indexed(T_DOUBLE); break;
3036       case Bytecodes::_aaload         : load_indexed(T_OBJECT); break;
3037       case Bytecodes::_baload         : load_indexed(T_BYTE  ); break;
3038       case Bytecodes::_caload         : load_indexed(T_CHAR  ); break;
3039       case Bytecodes::_saload         : load_indexed(T_SHORT ); break;
3040       case Bytecodes::_istore         : store_local(intType   , s.get_index()); break;
3041       case Bytecodes::_lstore         : store_local(longType  , s.get_index()); break;
3042       case Bytecodes::_fstore         : store_local(floatType , s.get_index()); break;
3043       case Bytecodes::_dstore         : store_local(doubleType, s.get_index()); break;
3044       case Bytecodes::_astore         : store_local(objectType, s.get_index()); break;
3045       case Bytecodes::_istore_0       : store_local(intType   , 0); break;
3046       case Bytecodes::_istore_1       : store_local(intType   , 1); break;
3047       case Bytecodes::_istore_2       : store_local(intType   , 2); break;
3048       case Bytecodes::_istore_3       : store_local(intType   , 3); break;
3049       case Bytecodes::_lstore_0       : store_local(longType  , 0); break;
3050       case Bytecodes::_lstore_1       : store_local(longType  , 1); break;
3051       case Bytecodes::_lstore_2       : store_local(longType  , 2); break;
3052       case Bytecodes::_lstore_3       : store_local(longType  , 3); break;
3053       case Bytecodes::_fstore_0       : store_local(floatType , 0); break;
3054       case Bytecodes::_fstore_1       : store_local(floatType , 1); break;
3055       case Bytecodes::_fstore_2       : store_local(floatType , 2); break;
3056       case Bytecodes::_fstore_3       : store_local(floatType , 3); break;
3057       case Bytecodes::_dstore_0       : store_local(doubleType, 0); break;
3058       case Bytecodes::_dstore_1       : store_local(doubleType, 1); break;
3059       case Bytecodes::_dstore_2       : store_local(doubleType, 2); break;
3060       case Bytecodes::_dstore_3       : store_local(doubleType, 3); break;
3061       case Bytecodes::_astore_0       : store_local(objectType, 0); break;
3062       case Bytecodes::_astore_1       : store_local(objectType, 1); break;
3063       case Bytecodes::_astore_2       : store_local(objectType, 2); break;
3064       case Bytecodes::_astore_3       : store_local(objectType, 3); break;
3065       case Bytecodes::_iastore        : store_indexed(T_INT   ); break;
3066       case Bytecodes::_lastore        : store_indexed(T_LONG  ); break;
3067       case Bytecodes::_fastore        : store_indexed(T_FLOAT ); break;
3068       case Bytecodes::_dastore        : store_indexed(T_DOUBLE); break;
3069       case Bytecodes::_aastore        : store_indexed(T_OBJECT); break;
3070       case Bytecodes::_bastore        : store_indexed(T_BYTE  ); break;
3071       case Bytecodes::_castore        : store_indexed(T_CHAR  ); break;
3072       case Bytecodes::_sastore        : store_indexed(T_SHORT ); break;
3073       case Bytecodes::_pop            : // fall through
3074       case Bytecodes::_pop2           : // fall through
3075       case Bytecodes::_dup            : // fall through
3076       case Bytecodes::_dup_x1         : // fall through
3077       case Bytecodes::_dup_x2         : // fall through
3078       case Bytecodes::_dup2           : // fall through
3079       case Bytecodes::_dup2_x1        : // fall through
3080       case Bytecodes::_dup2_x2        : // fall through
3081       case Bytecodes::_swap           : stack_op(code); break;
3082       case Bytecodes::_iadd           : arithmetic_op(intType   , code); break;
3083       case Bytecodes::_ladd           : arithmetic_op(longType  , code); break;
3084       case Bytecodes::_fadd           : arithmetic_op(floatType , code); break;
3085       case Bytecodes::_dadd           : arithmetic_op(doubleType, code); break;
3086       case Bytecodes::_isub           : arithmetic_op(intType   , code); break;
3087       case Bytecodes::_lsub           : arithmetic_op(longType  , code); break;
3088       case Bytecodes::_fsub           : arithmetic_op(floatType , code); break;
3089       case Bytecodes::_dsub           : arithmetic_op(doubleType, code); break;
3090       case Bytecodes::_imul           : arithmetic_op(intType   , code); break;
3091       case Bytecodes::_lmul           : arithmetic_op(longType  , code); break;
3092       case Bytecodes::_fmul           : arithmetic_op(floatType , code); break;
3093       case Bytecodes::_dmul           : arithmetic_op(doubleType, code); break;
3094       case Bytecodes::_idiv           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
3095       case Bytecodes::_ldiv           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
3096       case Bytecodes::_fdiv           : arithmetic_op(floatType , code); break;
3097       case Bytecodes::_ddiv           : arithmetic_op(doubleType, code); break;
3098       case Bytecodes::_irem           : arithmetic_op(intType   , code, copy_state_for_exception()); break;
3099       case Bytecodes::_lrem           : arithmetic_op(longType  , code, copy_state_for_exception()); break;
3100       case Bytecodes::_frem           : arithmetic_op(floatType , code); break;
3101       case Bytecodes::_drem           : arithmetic_op(doubleType, code); break;
3102       case Bytecodes::_ineg           : negate_op(intType   ); break;
3103       case Bytecodes::_lneg           : negate_op(longType  ); break;
3104       case Bytecodes::_fneg           : negate_op(floatType ); break;
3105       case Bytecodes::_dneg           : negate_op(doubleType); break;
3106       case Bytecodes::_ishl           : shift_op(intType , code); break;
3107       case Bytecodes::_lshl           : shift_op(longType, code); break;
3108       case Bytecodes::_ishr           : shift_op(intType , code); break;
3109       case Bytecodes::_lshr           : shift_op(longType, code); break;
3110       case Bytecodes::_iushr          : shift_op(intType , code); break;
3111       case Bytecodes::_lushr          : shift_op(longType, code); break;
3112       case Bytecodes::_iand           : logic_op(intType , code); break;
3113       case Bytecodes::_land           : logic_op(longType, code); break;
3114       case Bytecodes::_ior            : logic_op(intType , code); break;
3115       case Bytecodes::_lor            : logic_op(longType, code); break;
3116       case Bytecodes::_ixor           : logic_op(intType , code); break;
3117       case Bytecodes::_lxor           : logic_op(longType, code); break;
3118       case Bytecodes::_iinc           : increment(); break;
3119       case Bytecodes::_i2l            : convert(code, T_INT   , T_LONG  ); break;
3120       case Bytecodes::_i2f            : convert(code, T_INT   , T_FLOAT ); break;
3121       case Bytecodes::_i2d            : convert(code, T_INT   , T_DOUBLE); break;
3122       case Bytecodes::_l2i            : convert(code, T_LONG  , T_INT   ); break;
3123       case Bytecodes::_l2f            : convert(code, T_LONG  , T_FLOAT ); break;
3124       case Bytecodes::_l2d            : convert(code, T_LONG  , T_DOUBLE); break;
3125       case Bytecodes::_f2i            : convert(code, T_FLOAT , T_INT   ); break;
3126       case Bytecodes::_f2l            : convert(code, T_FLOAT , T_LONG  ); break;
3127       case Bytecodes::_f2d            : convert(code, T_FLOAT , T_DOUBLE); break;
3128       case Bytecodes::_d2i            : convert(code, T_DOUBLE, T_INT   ); break;
3129       case Bytecodes::_d2l            : convert(code, T_DOUBLE, T_LONG  ); break;
3130       case Bytecodes::_d2f            : convert(code, T_DOUBLE, T_FLOAT ); break;
3131       case Bytecodes::_i2b            : convert(code, T_INT   , T_BYTE  ); break;
3132       case Bytecodes::_i2c            : convert(code, T_INT   , T_CHAR  ); break;
3133       case Bytecodes::_i2s            : convert(code, T_INT   , T_SHORT ); break;
3134       case Bytecodes::_lcmp           : compare_op(longType  , code); break;
3135       case Bytecodes::_fcmpl          : compare_op(floatType , code); break;
3136       case Bytecodes::_fcmpg          : compare_op(floatType , code); break;
3137       case Bytecodes::_dcmpl          : compare_op(doubleType, code); break;
3138       case Bytecodes::_dcmpg          : compare_op(doubleType, code); break;
3139       case Bytecodes::_ifeq           : if_zero(intType   , If::eql); break;
3140       case Bytecodes::_ifne           : if_zero(intType   , If::neq); break;
3141       case Bytecodes::_iflt           : if_zero(intType   , If::lss); break;
3142       case Bytecodes::_ifge           : if_zero(intType   , If::geq); break;
3143       case Bytecodes::_ifgt           : if_zero(intType   , If::gtr); break;
3144       case Bytecodes::_ifle           : if_zero(intType   , If::leq); break;
3145       case Bytecodes::_if_icmpeq      : if_same(intType   , If::eql); break;
3146       case Bytecodes::_if_icmpne      : if_same(intType   , If::neq); break;
3147       case Bytecodes::_if_icmplt      : if_same(intType   , If::lss); break;
3148       case Bytecodes::_if_icmpge      : if_same(intType   , If::geq); break;
3149       case Bytecodes::_if_icmpgt      : if_same(intType   , If::gtr); break;
3150       case Bytecodes::_if_icmple      : if_same(intType   , If::leq); break;
3151       case Bytecodes::_if_acmpeq      : if_same(objectType, If::eql); break;
3152       case Bytecodes::_if_acmpne      : if_same(objectType, If::neq); break;
3153       case Bytecodes::_goto           : _goto(s.cur_bci(), s.get_dest()); break;
3154       case Bytecodes::_jsr            : jsr(s.get_dest()); break;
3155       case Bytecodes::_ret            : ret(s.get_index()); break;
3156       case Bytecodes::_tableswitch    : table_switch(); break;
3157       case Bytecodes::_lookupswitch   : lookup_switch(); break;
3158       case Bytecodes::_ireturn        : method_return(ipop(), ignore_return); break;
3159       case Bytecodes::_lreturn        : method_return(lpop(), ignore_return); break;
3160       case Bytecodes::_freturn        : method_return(fpop(), ignore_return); break;
3161       case Bytecodes::_dreturn        : method_return(dpop(), ignore_return); break;
3162       case Bytecodes::_areturn        : method_return(apop(), ignore_return); break;
3163       case Bytecodes::_return         : method_return(NULL  , ignore_return); break;
3164       case Bytecodes::_getstatic      : // fall through
3165       case Bytecodes::_putstatic      : // fall through
3166       case Bytecodes::_getfield       : // fall through
3167       case Bytecodes::_putfield       : access_field(code); break;
3168       case Bytecodes::_invokevirtual  : // fall through
3169       case Bytecodes::_invokespecial  : // fall through
3170       case Bytecodes::_invokestatic   : // fall through
3171       case Bytecodes::_invokedynamic  : // fall through
3172       case Bytecodes::_invokeinterface: invoke(code); break;
3173       case Bytecodes::_new            : new_instance(s.get_index_u2()); break;
3174       case Bytecodes::_newarray       : new_type_array(); break;
3175       case Bytecodes::_anewarray      : new_object_array(); break;
3176       case Bytecodes::_arraylength    : { ValueStack* state_before = copy_state_for_exception(); ipush(append(new ArrayLength(apop(), state_before))); break; }
3177       case Bytecodes::_athrow         : throw_op(s.cur_bci()); break;
3178       case Bytecodes::_checkcast      : check_cast(s.get_index_u2()); break;
3179       case Bytecodes::_instanceof     : instance_of(s.get_index_u2()); break;
3180       case Bytecodes::_monitorenter   : monitorenter(apop(), s.cur_bci()); break;
3181       case Bytecodes::_monitorexit    : monitorexit (apop(), s.cur_bci()); break;
3182       case Bytecodes::_wide           : ShouldNotReachHere(); break;
3183       case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
3184       case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
3185       case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
3186       case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
3187       case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;
3188       case Bytecodes::_defaultvalue   : default_value(s.get_index_u2()); break;
3189       case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;
3190       case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
3191       default                         : ShouldNotReachHere(); break;
3192     }
3193 
3194     if (log != NULL)
3195       log-&gt;clear_context(); // skip marker if nothing was printed
3196 
3197     // save current bci to setup Goto at the end
3198     prev_bci = s.cur_bci();
3199 
3200   }
3201   CHECK_BAILOUT_(NULL);
3202   // stop processing of this block (see try_inline_full)
3203   if (_skip_block) {
3204     _skip_block = false;
3205     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
3206     return _last-&gt;as_BlockEnd();
3207   }
3208   // if there are any, check if last instruction is a BlockEnd instruction
3209   BlockEnd* end = last()-&gt;as_BlockEnd();
3210   if (end == NULL) {
3211     // all blocks must end with a BlockEnd instruction =&gt; add a Goto
3212     end = new Goto(block_at(s.cur_bci()), false);
3213     append(end);
3214   }
3215   assert(end == last()-&gt;as_BlockEnd(), &quot;inconsistency&quot;);
3216 
3217   assert(end-&gt;state() != NULL, &quot;state must already be present&quot;);
3218   assert(end-&gt;as_Return() == NULL || end-&gt;as_Throw() == NULL || end-&gt;state()-&gt;stack_size() == 0, &quot;stack not needed for return and throw&quot;);
3219 
3220   // connect to begin &amp; set state
3221   // NOTE that inlining may have changed the block we are parsing
3222   block()-&gt;set_end(end);
3223   // propagate state
3224   for (int i = end-&gt;number_of_sux() - 1; i &gt;= 0; i--) {
3225     BlockBegin* sux = end-&gt;sux_at(i);
3226     assert(sux-&gt;is_predecessor(block()), &quot;predecessor missing&quot;);
3227     // be careful, bailout if bytecodes are strange
3228     if (!sux-&gt;try_merge(end-&gt;state())) BAILOUT_(&quot;block join failed&quot;, NULL);
3229     scope_data()-&gt;add_to_work_list(end-&gt;sux_at(i));
3230   }
3231 
3232   scope_data()-&gt;set_stream(NULL);
3233 
3234   // done
3235   return end;
3236 }
3237 
3238 
3239 void GraphBuilder::iterate_all_blocks(bool start_in_current_block_for_inlining) {
3240   do {
3241     if (start_in_current_block_for_inlining &amp;&amp; !bailed_out()) {
3242       iterate_bytecodes_for_block(0);
3243       start_in_current_block_for_inlining = false;
3244     } else {
3245       BlockBegin* b;
3246       while ((b = scope_data()-&gt;remove_from_work_list()) != NULL) {
3247         if (!b-&gt;is_set(BlockBegin::was_visited_flag)) {
3248           if (b-&gt;is_set(BlockBegin::osr_entry_flag)) {
3249             // we&#39;re about to parse the osr entry block, so make sure
3250             // we setup the OSR edge leading into this block so that
3251             // Phis get setup correctly.
3252             setup_osr_entry_block();
3253             // this is no longer the osr entry block, so clear it.
3254             b-&gt;clear(BlockBegin::osr_entry_flag);
3255           }
3256           b-&gt;set(BlockBegin::was_visited_flag);
3257           connect_to_end(b);
3258         }
3259       }
3260     }
3261   } while (!bailed_out() &amp;&amp; !scope_data()-&gt;is_work_list_empty());
3262 }
3263 
3264 
3265 bool GraphBuilder::_can_trap      [Bytecodes::number_of_java_codes];
3266 
3267 void GraphBuilder::initialize() {
3268   // the following bytecodes are assumed to potentially
3269   // throw exceptions in compiled code - note that e.g.
3270   // monitorexit &amp; the return bytecodes do not throw
3271   // exceptions since monitor pairing proved that they
3272   // succeed (if monitor pairing succeeded)
3273   Bytecodes::Code can_trap_list[] =
3274     { Bytecodes::_ldc
3275     , Bytecodes::_ldc_w
3276     , Bytecodes::_ldc2_w
3277     , Bytecodes::_iaload
3278     , Bytecodes::_laload
3279     , Bytecodes::_faload
3280     , Bytecodes::_daload
3281     , Bytecodes::_aaload
3282     , Bytecodes::_baload
3283     , Bytecodes::_caload
3284     , Bytecodes::_saload
3285     , Bytecodes::_iastore
3286     , Bytecodes::_lastore
3287     , Bytecodes::_fastore
3288     , Bytecodes::_dastore
3289     , Bytecodes::_aastore
3290     , Bytecodes::_bastore
3291     , Bytecodes::_castore
3292     , Bytecodes::_sastore
3293     , Bytecodes::_idiv
3294     , Bytecodes::_ldiv
3295     , Bytecodes::_irem
3296     , Bytecodes::_lrem
3297     , Bytecodes::_getstatic
3298     , Bytecodes::_putstatic
3299     , Bytecodes::_getfield
3300     , Bytecodes::_putfield
3301     , Bytecodes::_invokevirtual
3302     , Bytecodes::_invokespecial
3303     , Bytecodes::_invokestatic
3304     , Bytecodes::_invokedynamic
3305     , Bytecodes::_invokeinterface
3306     , Bytecodes::_new
3307     , Bytecodes::_newarray
3308     , Bytecodes::_anewarray
3309     , Bytecodes::_arraylength
3310     , Bytecodes::_athrow
3311     , Bytecodes::_checkcast
3312     , Bytecodes::_instanceof
3313     , Bytecodes::_monitorenter
3314     , Bytecodes::_multianewarray
3315     };
3316 
3317   // inititialize trap tables
3318   for (int i = 0; i &lt; Bytecodes::number_of_java_codes; i++) {
3319     _can_trap[i] = false;
3320   }
3321   // set standard trap info
3322   for (uint j = 0; j &lt; ARRAY_SIZE(can_trap_list); j++) {
3323     _can_trap[can_trap_list[j]] = true;
3324   }
3325 }
3326 
3327 
3328 BlockBegin* GraphBuilder::header_block(BlockBegin* entry, BlockBegin::Flag f, ValueStack* state) {
3329   assert(entry-&gt;is_set(f), &quot;entry/flag mismatch&quot;);
3330   // create header block
3331   BlockBegin* h = new BlockBegin(entry-&gt;bci());
3332   h-&gt;set_depth_first_number(0);
3333 
3334   Value l = h;
3335   BlockEnd* g = new Goto(entry, false);
3336   l-&gt;set_next(g, entry-&gt;bci());
3337   h-&gt;set_end(g);
3338   h-&gt;set(f);
3339   // setup header block end state
3340   ValueStack* s = state-&gt;copy(ValueStack::StateAfter, entry-&gt;bci()); // can use copy since stack is empty (=&gt; no phis)
3341   assert(s-&gt;stack_is_empty(), &quot;must have empty stack at entry point&quot;);
3342   g-&gt;set_state(s);
3343   return h;
3344 }
3345 
3346 
3347 
3348 BlockBegin* GraphBuilder::setup_start_block(int osr_bci, BlockBegin* std_entry, BlockBegin* osr_entry, ValueStack* state) {
3349   BlockBegin* start = new BlockBegin(0);
3350 
3351   // This code eliminates the empty start block at the beginning of
3352   // each method.  Previously, each method started with the
3353   // start-block created below, and this block was followed by the
3354   // header block that was always empty.  This header block is only
3355   // necesary if std_entry is also a backward branch target because
3356   // then phi functions may be necessary in the header block.  It&#39;s
3357   // also necessary when profiling so that there&#39;s a single block that
3358   // can increment the interpreter_invocation_count.
3359   BlockBegin* new_header_block;
3360   if (std_entry-&gt;number_of_preds() &gt; 0 || count_invocations() || count_backedges()) {
3361     new_header_block = header_block(std_entry, BlockBegin::std_entry_flag, state);
3362   } else {
3363     new_header_block = std_entry;
3364   }
3365 
3366   // setup start block (root for the IR graph)
3367   Base* base =
3368     new Base(
3369       new_header_block,
3370       osr_entry
3371     );
3372   start-&gt;set_next(base, 0);
3373   start-&gt;set_end(base);
3374   // create &amp; setup state for start block
3375   start-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3376   base-&gt;set_state(state-&gt;copy(ValueStack::StateAfter, std_entry-&gt;bci()));
3377 
3378   if (base-&gt;std_entry()-&gt;state() == NULL) {
3379     // setup states for header blocks
3380     base-&gt;std_entry()-&gt;merge(state);
3381   }
3382 
3383   assert(base-&gt;std_entry()-&gt;state() != NULL, &quot;&quot;);
3384   return start;
3385 }
3386 
3387 
3388 void GraphBuilder::setup_osr_entry_block() {
3389   assert(compilation()-&gt;is_osr_compile(), &quot;only for osrs&quot;);
3390 
3391   int osr_bci = compilation()-&gt;osr_bci();
3392   ciBytecodeStream s(method());
3393   s.reset_to_bci(osr_bci);
3394   s.next();
3395   scope_data()-&gt;set_stream(&amp;s);
3396 
3397   // create a new block to be the osr setup code
3398   _osr_entry = new BlockBegin(osr_bci);
3399   _osr_entry-&gt;set(BlockBegin::osr_entry_flag);
3400   _osr_entry-&gt;set_depth_first_number(0);
3401   BlockBegin* target = bci2block()-&gt;at(osr_bci);
3402   assert(target != NULL &amp;&amp; target-&gt;is_set(BlockBegin::osr_entry_flag), &quot;must be there&quot;);
3403   // the osr entry has no values for locals
3404   ValueStack* state = target-&gt;state()-&gt;copy();
3405   _osr_entry-&gt;set_state(state);
3406 
3407   kill_all();
3408   _block = _osr_entry;
3409   _state = _osr_entry-&gt;state()-&gt;copy();
3410   assert(_state-&gt;bci() == osr_bci, &quot;mismatch&quot;);
3411   _last  = _osr_entry;
3412   Value e = append(new OsrEntry());
3413   e-&gt;set_needs_null_check(false);
3414 
3415   // OSR buffer is
3416   //
3417   // locals[nlocals-1..0]
3418   // monitors[number_of_locks-1..0]
3419   //
3420   // locals is a direct copy of the interpreter frame so in the osr buffer
3421   // so first slot in the local array is the last local from the interpreter
3422   // and last slot is local[0] (receiver) from the interpreter
3423   //
3424   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
3425   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
3426   // in the interpreter frame (the method lock if a sync method)
3427 
3428   // Initialize monitors in the compiled activation.
3429 
3430   int index;
3431   Value local;
3432 
3433   // find all the locals that the interpreter thinks contain live oops
3434   const ResourceBitMap live_oops = method()-&gt;live_local_oops_at_bci(osr_bci);
3435 
3436   // compute the offset into the locals so that we can treat the buffer
3437   // as if the locals were still in the interpreter frame
3438   int locals_offset = BytesPerWord * (method()-&gt;max_locals() - 1);
3439   for_each_local_value(state, index, local) {
3440     int offset = locals_offset - (index + local-&gt;type()-&gt;size() - 1) * BytesPerWord;
3441     Value get;
3442     if (local-&gt;type()-&gt;is_object_kind() &amp;&amp; !live_oops.at(index)) {
3443       // The interpreter thinks this local is dead but the compiler
3444       // doesn&#39;t so pretend that the interpreter passed in null.
3445       get = append(new Constant(objectNull));
3446     } else {
3447       get = append(new UnsafeGetRaw(as_BasicType(local-&gt;type()), e,
3448                                     append(new Constant(new IntConstant(offset))),
3449                                     0,
3450                                     true /*unaligned*/, true /*wide*/));
3451     }
3452     _state-&gt;store_local(index, get);
3453   }
3454 
3455   // the storage for the OSR buffer is freed manually in the LIRGenerator.
3456 
3457   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3458   state-&gt;clear_locals();
3459   Goto* g = new Goto(target, false);
3460   append(g);
3461   _osr_entry-&gt;set_end(g);
3462   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3463 
3464   scope_data()-&gt;set_stream(NULL);
3465 }
3466 
3467 
3468 ValueStack* GraphBuilder::state_at_entry() {
3469   ValueStack* state = new ValueStack(scope(), NULL);
3470 
3471   // Set up locals for receiver
3472   int idx = 0;
3473   if (!method()-&gt;is_static()) {
3474     // we should always see the receiver
3475     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
3476              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_value_array_klass()));
3477     idx = 1;
3478   }
3479 
3480   // Set up locals for incoming arguments
3481   ciSignature* sig = method()-&gt;signature();
3482   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3483     ciType* type = sig-&gt;type_at(i);
3484     BasicType basic_type = type-&gt;basic_type();
3485     // don&#39;t allow T_ARRAY to propagate into locals types
3486     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3487     ValueType* vt = as_ValueType(basic_type);
3488     state-&gt;store_local(idx, new Local(type, vt, idx, false, sig-&gt;is_never_null_at(i)));
3489     idx += type-&gt;size();
3490   }
3491 
3492   // lock synchronized method
3493   if (method()-&gt;is_synchronized()) {
3494     state-&gt;lock(NULL);
3495   }
3496 
3497   return state;
3498 }
3499 
3500 
3501 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3502   : _scope_data(NULL)
3503   , _compilation(compilation)
3504   , _memory(new MemoryBuffer())
3505   , _inline_bailout_msg(NULL)
3506   , _instruction_count(0)
3507   , _osr_entry(NULL)
3508 {
3509   int osr_bci = compilation-&gt;osr_bci();
3510 
3511   // determine entry points and bci2block mapping
3512   BlockListBuilder blm(compilation, scope, osr_bci);
3513   CHECK_BAILOUT();
3514 
3515   BlockList* bci2block = blm.bci2block();
3516   BlockBegin* start_block = bci2block-&gt;at(0);
3517 
3518   push_root_scope(scope, bci2block, start_block);
3519 
3520   // setup state for std entry
3521   _initial_state = state_at_entry();
3522   start_block-&gt;merge(_initial_state);
3523 
3524   // complete graph
3525   _vmap        = new ValueMap();
3526   switch (scope-&gt;method()-&gt;intrinsic_id()) {
3527   case vmIntrinsics::_dabs          : // fall through
3528   case vmIntrinsics::_dsqrt         : // fall through
3529   case vmIntrinsics::_dsin          : // fall through
3530   case vmIntrinsics::_dcos          : // fall through
3531   case vmIntrinsics::_dtan          : // fall through
3532   case vmIntrinsics::_dlog          : // fall through
3533   case vmIntrinsics::_dlog10        : // fall through
3534   case vmIntrinsics::_dexp          : // fall through
3535   case vmIntrinsics::_dpow          : // fall through
3536     {
3537       // Compiles where the root method is an intrinsic need a special
3538       // compilation environment because the bytecodes for the method
3539       // shouldn&#39;t be parsed during the compilation, only the special
3540       // Intrinsic node should be emitted.  If this isn&#39;t done the the
3541       // code for the inlined version will be different than the root
3542       // compiled version which could lead to monotonicity problems on
3543       // intel.
3544       if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3545         BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3546       }
3547 
3548       // Set up a stream so that appending instructions works properly.
3549       ciBytecodeStream s(scope-&gt;method());
3550       s.reset_to_bci(0);
3551       scope_data()-&gt;set_stream(&amp;s);
3552       s.next();
3553 
3554       // setup the initial block state
3555       _block = start_block;
3556       _state = start_block-&gt;state()-&gt;copy_for_parsing();
3557       _last  = start_block;
3558       load_local(doubleType, 0);
3559       if (scope-&gt;method()-&gt;intrinsic_id() == vmIntrinsics::_dpow) {
3560         load_local(doubleType, 2);
3561       }
3562 
3563       // Emit the intrinsic node.
3564       bool result = try_inline_intrinsics(scope-&gt;method());
3565       if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3566       method_return(dpop());
3567 
3568       // connect the begin and end blocks and we&#39;re all done.
3569       BlockEnd* end = last()-&gt;as_BlockEnd();
3570       block()-&gt;set_end(end);
3571       break;
3572     }
3573 
3574   case vmIntrinsics::_Reference_get:
3575     {
3576       {
3577         // With java.lang.ref.reference.get() we must go through the
3578         // intrinsic - when G1 is enabled - even when get() is the root
3579         // method of the compile so that, if necessary, the value in
3580         // the referent field of the reference object gets recorded by
3581         // the pre-barrier code.
3582         // Specifically, if G1 is enabled, the value in the referent
3583         // field is recorded by the G1 SATB pre barrier. This will
3584         // result in the referent being marked live and the reference
3585         // object removed from the list of discovered references during
3586         // reference processing.
3587         if (CheckIntrinsics &amp;&amp; !scope-&gt;method()-&gt;intrinsic_candidate()) {
3588           BAILOUT(&quot;failed to inline intrinsic, method not annotated&quot;);
3589         }
3590 
3591         // Also we need intrinsic to prevent commoning reads from this field
3592         // across safepoint since GC can change its value.
3593 
3594         // Set up a stream so that appending instructions works properly.
3595         ciBytecodeStream s(scope-&gt;method());
3596         s.reset_to_bci(0);
3597         scope_data()-&gt;set_stream(&amp;s);
3598         s.next();
3599 
3600         // setup the initial block state
3601         _block = start_block;
3602         _state = start_block-&gt;state()-&gt;copy_for_parsing();
3603         _last  = start_block;
3604         load_local(objectType, 0);
3605 
3606         // Emit the intrinsic node.
3607         bool result = try_inline_intrinsics(scope-&gt;method());
3608         if (!result) BAILOUT(&quot;failed to inline intrinsic&quot;);
3609         method_return(apop());
3610 
3611         // connect the begin and end blocks and we&#39;re all done.
3612         BlockEnd* end = last()-&gt;as_BlockEnd();
3613         block()-&gt;set_end(end);
3614         break;
3615       }
3616       // Otherwise, fall thru
3617     }
3618 
3619   default:
3620     scope_data()-&gt;add_to_work_list(start_block);
3621     iterate_all_blocks();
3622     break;
3623   }
3624   CHECK_BAILOUT();
3625 
3626   _start = setup_start_block(osr_bci, start_block, _osr_entry, _initial_state);
3627 
3628   eliminate_redundant_phis(_start);
3629 
3630   NOT_PRODUCT(if (PrintValueNumbering &amp;&amp; Verbose) print_stats());
3631   // for osr compile, bailout if some requirements are not fulfilled
3632   if (osr_bci != -1) {
3633     BlockBegin* osr_block = blm.bci2block()-&gt;at(osr_bci);
3634     if (!osr_block-&gt;is_set(BlockBegin::was_visited_flag)) {
3635       BAILOUT(&quot;osr entry must have been visited for osr compile&quot;);
3636     }
3637 
3638     // check if osr entry point has empty stack - we cannot handle non-empty stacks at osr entry points
3639     if (!osr_block-&gt;state()-&gt;stack_is_empty()) {
3640       BAILOUT(&quot;stack not empty at OSR entry point&quot;);
3641     }
3642   }
3643 #ifndef PRODUCT
3644   if (PrintCompilation &amp;&amp; Verbose) tty-&gt;print_cr(&quot;Created %d Instructions&quot;, _instruction_count);
3645 #endif
3646 }
3647 
3648 
3649 ValueStack* GraphBuilder::copy_state_before() {
3650   return copy_state_before_with_bci(bci());
3651 }
3652 
3653 ValueStack* GraphBuilder::copy_state_exhandling() {
3654   return copy_state_exhandling_with_bci(bci());
3655 }
3656 
3657 ValueStack* GraphBuilder::copy_state_for_exception() {
3658   return copy_state_for_exception_with_bci(bci());
3659 }
3660 
3661 ValueStack* GraphBuilder::copy_state_before_with_bci(int bci) {
3662   return state()-&gt;copy(ValueStack::StateBefore, bci);
3663 }
3664 
3665 ValueStack* GraphBuilder::copy_state_exhandling_with_bci(int bci) {
3666   if (!has_handler()) return NULL;
3667   return state()-&gt;copy(ValueStack::StateBefore, bci);
3668 }
3669 
3670 ValueStack* GraphBuilder::copy_state_for_exception_with_bci(int bci) {
3671   ValueStack* s = copy_state_exhandling_with_bci(bci);
3672   if (s == NULL) {
3673     if (_compilation-&gt;env()-&gt;should_retain_local_variables()) {
3674       s = state()-&gt;copy(ValueStack::ExceptionState, bci);
3675     } else {
3676       s = state()-&gt;copy(ValueStack::EmptyExceptionState, bci);
3677     }
3678   }
3679   return s;
3680 }
3681 
3682 int GraphBuilder::recursive_inline_level(ciMethod* cur_callee) const {
3683   int recur_level = 0;
3684   for (IRScope* s = scope(); s != NULL; s = s-&gt;caller()) {
3685     if (s-&gt;method() == cur_callee) {
3686       ++recur_level;
3687     }
3688   }
3689   return recur_level;
3690 }
3691 
3692 
3693 bool GraphBuilder::try_inline(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
3694   const char* msg = NULL;
3695 
3696   // clear out any existing inline bailout condition
3697   clear_inline_bailout();
3698 
3699   // exclude methods we don&#39;t want to inline
3700   msg = should_not_inline(callee);
3701   if (msg != NULL) {
3702     print_inlining(callee, msg, /*success*/ false);
3703     return false;
3704   }
3705 
3706   // method handle invokes
3707   if (callee-&gt;is_method_handle_intrinsic()) {
3708     if (try_method_handle_inline(callee, ignore_return)) {
3709       if (callee-&gt;has_reserved_stack_access()) {
3710         compilation()-&gt;set_has_reserved_stack_access(true);
3711       }
3712       return true;
3713     }
3714     return false;
3715   }
3716 
3717   // handle intrinsics
3718   if (callee-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
3719       (CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true)) {
3720     if (try_inline_intrinsics(callee, ignore_return)) {
3721       print_inlining(callee, &quot;intrinsic&quot;);
3722       if (callee-&gt;has_reserved_stack_access()) {
3723         compilation()-&gt;set_has_reserved_stack_access(true);
3724       }
3725       return true;
3726     }
3727     // try normal inlining
3728   }
3729 
3730   // certain methods cannot be parsed at all
3731   msg = check_can_parse(callee);
3732   if (msg != NULL) {
3733     print_inlining(callee, msg, /*success*/ false);
3734     return false;
3735   }
3736 
3737   // If bytecode not set use the current one.
3738   if (bc == Bytecodes::_illegal) {
3739     bc = code();
3740   }
3741   if (try_inline_full(callee, holder_known, ignore_return, bc, receiver)) {
3742     if (callee-&gt;has_reserved_stack_access()) {
3743       compilation()-&gt;set_has_reserved_stack_access(true);
3744     }
3745     return true;
3746   }
3747 
3748   // Entire compilation could fail during try_inline_full call.
3749   // In that case printing inlining decision info is useless.
3750   if (!bailed_out())
3751     print_inlining(callee, _inline_bailout_msg, /*success*/ false);
3752 
3753   return false;
3754 }
3755 
3756 
3757 const char* GraphBuilder::check_can_parse(ciMethod* callee) const {
3758   // Certain methods cannot be parsed at all:
3759   if ( callee-&gt;is_native())            return &quot;native method&quot;;
3760   if ( callee-&gt;is_abstract())          return &quot;abstract method&quot;;
3761   if (!callee-&gt;can_be_compiled())      return &quot;not compilable (disabled)&quot;;
3762   if (!callee-&gt;can_be_parsed())        return &quot;cannot be parsed&quot;;
3763   return NULL;
3764 }
3765 
3766 // negative filter: should callee NOT be inlined?  returns NULL, ok to inline, or rejection msg
3767 const char* GraphBuilder::should_not_inline(ciMethod* callee) const {
3768   if ( compilation()-&gt;directive()-&gt;should_not_inline(callee)) return &quot;disallowed by CompileCommand&quot;;
3769   if ( callee-&gt;dont_inline())          return &quot;don&#39;t inline by annotation&quot;;
3770   return NULL;
3771 }
3772 
3773 void GraphBuilder::build_graph_for_intrinsic(ciMethod* callee, bool ignore_return) {
3774   vmIntrinsics::ID id = callee-&gt;intrinsic_id();
3775   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
3776 
3777   // Some intrinsics need special IR nodes.
3778   switch(id) {
3779   case vmIntrinsics::_getReference       : append_unsafe_get_obj(callee, T_OBJECT,  false); return;
3780   case vmIntrinsics::_getBoolean         : append_unsafe_get_obj(callee, T_BOOLEAN, false); return;
3781   case vmIntrinsics::_getByte            : append_unsafe_get_obj(callee, T_BYTE,    false); return;
3782   case vmIntrinsics::_getShort           : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3783   case vmIntrinsics::_getChar            : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3784   case vmIntrinsics::_getInt             : append_unsafe_get_obj(callee, T_INT,     false); return;
3785   case vmIntrinsics::_getLong            : append_unsafe_get_obj(callee, T_LONG,    false); return;
3786   case vmIntrinsics::_getFloat           : append_unsafe_get_obj(callee, T_FLOAT,   false); return;
3787   case vmIntrinsics::_getDouble          : append_unsafe_get_obj(callee, T_DOUBLE,  false); return;
3788   case vmIntrinsics::_putReference       : append_unsafe_put_obj(callee, T_OBJECT,  false); return;
3789   case vmIntrinsics::_putBoolean         : append_unsafe_put_obj(callee, T_BOOLEAN, false); return;
3790   case vmIntrinsics::_putByte            : append_unsafe_put_obj(callee, T_BYTE,    false); return;
3791   case vmIntrinsics::_putShort           : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3792   case vmIntrinsics::_putChar            : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3793   case vmIntrinsics::_putInt             : append_unsafe_put_obj(callee, T_INT,     false); return;
3794   case vmIntrinsics::_putLong            : append_unsafe_put_obj(callee, T_LONG,    false); return;
3795   case vmIntrinsics::_putFloat           : append_unsafe_put_obj(callee, T_FLOAT,   false); return;
3796   case vmIntrinsics::_putDouble          : append_unsafe_put_obj(callee, T_DOUBLE,  false); return;
3797   case vmIntrinsics::_getShortUnaligned  : append_unsafe_get_obj(callee, T_SHORT,   false); return;
3798   case vmIntrinsics::_getCharUnaligned   : append_unsafe_get_obj(callee, T_CHAR,    false); return;
3799   case vmIntrinsics::_getIntUnaligned    : append_unsafe_get_obj(callee, T_INT,     false); return;
3800   case vmIntrinsics::_getLongUnaligned   : append_unsafe_get_obj(callee, T_LONG,    false); return;
3801   case vmIntrinsics::_putShortUnaligned  : append_unsafe_put_obj(callee, T_SHORT,   false); return;
3802   case vmIntrinsics::_putCharUnaligned   : append_unsafe_put_obj(callee, T_CHAR,    false); return;
3803   case vmIntrinsics::_putIntUnaligned    : append_unsafe_put_obj(callee, T_INT,     false); return;
3804   case vmIntrinsics::_putLongUnaligned   : append_unsafe_put_obj(callee, T_LONG,    false); return;
3805   case vmIntrinsics::_getReferenceVolatile  : append_unsafe_get_obj(callee, T_OBJECT,  true); return;
3806   case vmIntrinsics::_getBooleanVolatile : append_unsafe_get_obj(callee, T_BOOLEAN, true); return;
3807   case vmIntrinsics::_getByteVolatile    : append_unsafe_get_obj(callee, T_BYTE,    true); return;
3808   case vmIntrinsics::_getShortVolatile   : append_unsafe_get_obj(callee, T_SHORT,   true); return;
3809   case vmIntrinsics::_getCharVolatile    : append_unsafe_get_obj(callee, T_CHAR,    true); return;
3810   case vmIntrinsics::_getIntVolatile     : append_unsafe_get_obj(callee, T_INT,     true); return;
3811   case vmIntrinsics::_getLongVolatile    : append_unsafe_get_obj(callee, T_LONG,    true); return;
3812   case vmIntrinsics::_getFloatVolatile   : append_unsafe_get_obj(callee, T_FLOAT,   true); return;
3813   case vmIntrinsics::_getDoubleVolatile  : append_unsafe_get_obj(callee, T_DOUBLE,  true); return;
3814   case vmIntrinsics::_putReferenceVolatile : append_unsafe_put_obj(callee, T_OBJECT,  true); return;
3815   case vmIntrinsics::_putBooleanVolatile : append_unsafe_put_obj(callee, T_BOOLEAN, true); return;
3816   case vmIntrinsics::_putByteVolatile    : append_unsafe_put_obj(callee, T_BYTE,    true); return;
3817   case vmIntrinsics::_putShortVolatile   : append_unsafe_put_obj(callee, T_SHORT,   true); return;
3818   case vmIntrinsics::_putCharVolatile    : append_unsafe_put_obj(callee, T_CHAR,    true); return;
3819   case vmIntrinsics::_putIntVolatile     : append_unsafe_put_obj(callee, T_INT,     true); return;
3820   case vmIntrinsics::_putLongVolatile    : append_unsafe_put_obj(callee, T_LONG,    true); return;
3821   case vmIntrinsics::_putFloatVolatile   : append_unsafe_put_obj(callee, T_FLOAT,   true); return;
3822   case vmIntrinsics::_putDoubleVolatile  : append_unsafe_put_obj(callee, T_DOUBLE,  true); return;
3823   case vmIntrinsics::_compareAndSetLong:
3824   case vmIntrinsics::_compareAndSetInt:
3825   case vmIntrinsics::_compareAndSetReference : append_unsafe_CAS(callee); return;
3826   case vmIntrinsics::_getAndAddInt:
3827   case vmIntrinsics::_getAndAddLong      : append_unsafe_get_and_set_obj(callee, true); return;
3828   case vmIntrinsics::_getAndSetInt       :
3829   case vmIntrinsics::_getAndSetLong      :
3830   case vmIntrinsics::_getAndSetReference : append_unsafe_get_and_set_obj(callee, false); return;
3831   case vmIntrinsics::_getCharStringU     : append_char_access(callee, false); return;
3832   case vmIntrinsics::_putCharStringU     : append_char_access(callee, true); return;
3833   default:
3834     break;
3835   }
3836 
3837   // create intrinsic node
3838   const bool has_receiver = !callee-&gt;is_static();
3839   ValueType* result_type = as_ValueType(callee-&gt;return_type());
3840   ValueStack* state_before = copy_state_for_exception();
3841 
3842   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
3843 
3844   if (is_profiling()) {
3845     // Don&#39;t profile in the special case where the root method
3846     // is the intrinsic
3847     if (callee != method()) {
3848       // Note that we&#39;d collect profile data in this method if we wanted it.
3849       compilation()-&gt;set_would_profile(true);
3850       if (profile_calls()) {
3851         Value recv = NULL;
3852         if (has_receiver) {
3853           recv = args-&gt;at(0);
3854           null_check(recv);
3855         }
3856         profile_call(callee, recv, NULL, collect_args_for_profiling(args, callee, true), true);
3857       }
3858     }
3859   }
3860 
3861   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(),
3862                                     args, has_receiver, state_before,
3863                                     vmIntrinsics::preserves_state(id),
3864                                     vmIntrinsics::can_trap(id));
3865   // append instruction &amp; push result
3866   Value value = append_split(result);
3867   if (result_type != voidType &amp;&amp; !ignore_return) {
3868     push(result_type, value);
3869   }
3870 
3871   if (callee != method() &amp;&amp; profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
3872     profile_return_type(result, callee);
3873   }
3874 }
3875 
3876 bool GraphBuilder::try_inline_intrinsics(ciMethod* callee, bool ignore_return) {
3877   // For calling is_intrinsic_available we need to transition to
3878   // the &#39;_thread_in_vm&#39; state because is_intrinsic_available()
3879   // accesses critical VM-internal data.
3880   bool is_available = false;
3881   {
3882     VM_ENTRY_MARK;
3883     methodHandle mh(THREAD, callee-&gt;get_Method());
3884     is_available = _compilation-&gt;compiler()-&gt;is_intrinsic_available(mh, _compilation-&gt;directive());
3885   }
3886 
3887   if (!is_available) {
3888     if (!InlineNatives) {
3889       // Return false and also set message that the inlining of
3890       // intrinsics has been disabled in general.
3891       INLINE_BAILOUT(&quot;intrinsic method inlining disabled&quot;);
3892     } else {
3893       return false;
3894     }
3895   }
3896   build_graph_for_intrinsic(callee, ignore_return);
3897   return true;
3898 }
3899 
3900 
3901 bool GraphBuilder::try_inline_jsr(int jsr_dest_bci) {
3902   // Introduce a new callee continuation point - all Ret instructions
3903   // will be replaced with Gotos to this point.
3904   BlockBegin* cont = block_at(next_bci());
3905   assert(cont != NULL, &quot;continuation must exist (BlockListBuilder starts a new block after a jsr&quot;);
3906 
3907   // Note: can not assign state to continuation yet, as we have to
3908   // pick up the state from the Ret instructions.
3909 
3910   // Push callee scope
3911   push_scope_for_jsr(cont, jsr_dest_bci);
3912 
3913   // Temporarily set up bytecode stream so we can append instructions
3914   // (only using the bci of this stream)
3915   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
3916 
3917   BlockBegin* jsr_start_block = block_at(jsr_dest_bci);
3918   assert(jsr_start_block != NULL, &quot;jsr start block must exist&quot;);
3919   assert(!jsr_start_block-&gt;is_set(BlockBegin::was_visited_flag), &quot;should not have visited jsr yet&quot;);
3920   Goto* goto_sub = new Goto(jsr_start_block, false);
3921   // Must copy state to avoid wrong sharing when parsing bytecodes
3922   assert(jsr_start_block-&gt;state() == NULL, &quot;should have fresh jsr starting block&quot;);
3923   jsr_start_block-&gt;set_state(copy_state_before_with_bci(jsr_dest_bci));
3924   append(goto_sub);
3925   _block-&gt;set_end(goto_sub);
3926   _last = _block = jsr_start_block;
3927 
3928   // Clear out bytecode stream
3929   scope_data()-&gt;set_stream(NULL);
3930 
3931   scope_data()-&gt;add_to_work_list(jsr_start_block);
3932 
3933   // Ready to resume parsing in subroutine
3934   iterate_all_blocks();
3935 
3936   // If we bailed out during parsing, return immediately (this is bad news)
3937   CHECK_BAILOUT_(false);
3938 
3939   // Detect whether the continuation can actually be reached. If not,
3940   // it has not had state set by the join() operations in
3941   // iterate_bytecodes_for_block()/ret() and we should not touch the
3942   // iteration state. The calling activation of
3943   // iterate_bytecodes_for_block will then complete normally.
3944   if (cont-&gt;state() != NULL) {
3945     if (!cont-&gt;is_set(BlockBegin::was_visited_flag)) {
3946       // add continuation to work list instead of parsing it immediately
3947       scope_data()-&gt;parent()-&gt;add_to_work_list(cont);
3948     }
3949   }
3950 
3951   assert(jsr_continuation() == cont, &quot;continuation must not have changed&quot;);
3952   assert(!jsr_continuation()-&gt;is_set(BlockBegin::was_visited_flag) ||
3953          jsr_continuation()-&gt;is_set(BlockBegin::parser_loop_header_flag),
3954          &quot;continuation can only be visited in case of backward branches&quot;);
3955   assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;block must have end&quot;);
3956 
3957   // continuation is in work list, so end iteration of current block
3958   _skip_block = true;
3959   pop_scope_for_jsr();
3960 
3961   return true;
3962 }
3963 
3964 
3965 // Inline the entry of a synchronized method as a monitor enter and
3966 // register the exception handler which releases the monitor if an
3967 // exception is thrown within the callee. Note that the monitor enter
3968 // cannot throw an exception itself, because the receiver is
3969 // guaranteed to be non-null by the explicit null check at the
3970 // beginning of inlining.
3971 void GraphBuilder::inline_sync_entry(Value lock, BlockBegin* sync_handler) {
3972   assert(lock != NULL &amp;&amp; sync_handler != NULL, &quot;lock or handler missing&quot;);
3973 
3974   monitorenter(lock, SynchronizationEntryBCI);
3975   assert(_last-&gt;as_MonitorEnter() != NULL, &quot;monitor enter expected&quot;);
3976   _last-&gt;set_needs_null_check(false);
3977 
3978   sync_handler-&gt;set(BlockBegin::exception_entry_flag);
3979   sync_handler-&gt;set(BlockBegin::is_on_work_list_flag);
3980 
3981   ciExceptionHandler* desc = new ciExceptionHandler(method()-&gt;holder(), 0, method()-&gt;code_size(), -1, 0);
3982   XHandler* h = new XHandler(desc);
3983   h-&gt;set_entry_block(sync_handler);
3984   scope_data()-&gt;xhandlers()-&gt;append(h);
3985   scope_data()-&gt;set_has_handler();
3986 }
3987 
3988 
3989 // If an exception is thrown and not handled within an inlined
3990 // synchronized method, the monitor must be released before the
3991 // exception is rethrown in the outer scope. Generate the appropriate
3992 // instructions here.
3993 void GraphBuilder::fill_sync_handler(Value lock, BlockBegin* sync_handler, bool default_handler) {
3994   BlockBegin* orig_block = _block;
3995   ValueStack* orig_state = _state;
3996   Instruction* orig_last = _last;
3997   _last = _block = sync_handler;
3998   _state = sync_handler-&gt;state()-&gt;copy();
3999 
4000   assert(sync_handler != NULL, &quot;handler missing&quot;);
4001   assert(!sync_handler-&gt;is_set(BlockBegin::was_visited_flag), &quot;is visited here&quot;);
4002 
4003   assert(lock != NULL || default_handler, &quot;lock or handler missing&quot;);
4004 
4005   XHandler* h = scope_data()-&gt;xhandlers()-&gt;remove_last();
4006   assert(h-&gt;entry_block() == sync_handler, &quot;corrupt list of handlers&quot;);
4007 
4008   block()-&gt;set(BlockBegin::was_visited_flag);
4009   Value exception = append_with_bci(new ExceptionObject(), SynchronizationEntryBCI);
4010   assert(exception-&gt;is_pinned(), &quot;must be&quot;);
4011 
4012   int bci = SynchronizationEntryBCI;
4013   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
4014     // Report exit from inline methods.  We don&#39;t have a stream here
4015     // so pass an explicit bci of SynchronizationEntryBCI.
4016     Values* args = new Values(1);
4017     args-&gt;push(append_with_bci(new Constant(new MethodConstant(method())), bci));
4018     append_with_bci(new RuntimeCall(voidType, &quot;dtrace_method_exit&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args), bci);
4019   }
4020 
4021   if (lock) {
4022     assert(state()-&gt;locks_size() &gt; 0 &amp;&amp; state()-&gt;lock_at(state()-&gt;locks_size() - 1) == lock, &quot;lock is missing&quot;);
4023     if (!lock-&gt;is_linked()) {
4024       lock = append_with_bci(lock, bci);
4025     }
4026 
4027     // exit the monitor in the context of the synchronized method
4028     monitorexit(lock, bci);
4029 
4030     // exit the context of the synchronized method
4031     if (!default_handler) {
4032       pop_scope();
4033       bci = _state-&gt;caller_state()-&gt;bci();
4034       _state = _state-&gt;caller_state()-&gt;copy_for_parsing();
4035     }
4036   }
4037 
4038   // perform the throw as if at the the call site
4039   apush(exception);
4040   throw_op(bci);
4041 
4042   BlockEnd* end = last()-&gt;as_BlockEnd();
4043   block()-&gt;set_end(end);
4044 
4045   _block = orig_block;
4046   _state = orig_state;
4047   _last = orig_last;
4048 }
4049 
4050 
4051 bool GraphBuilder::try_inline_full(ciMethod* callee, bool holder_known, bool ignore_return, Bytecodes::Code bc, Value receiver) {
4052   assert(!callee-&gt;is_native(), &quot;callee must not be native&quot;);
4053   if (CompilationPolicy::policy()-&gt;should_not_inline(compilation()-&gt;env(), callee)) {
4054     INLINE_BAILOUT(&quot;inlining prohibited by policy&quot;);
4055   }
4056   // first perform tests of things it&#39;s not possible to inline
4057   if (callee-&gt;has_exception_handlers() &amp;&amp;
4058       !InlineMethodsWithExceptionHandlers) INLINE_BAILOUT(&quot;callee has exception handlers&quot;);
4059   if (callee-&gt;is_synchronized() &amp;&amp;
4060       !InlineSynchronizedMethods         ) INLINE_BAILOUT(&quot;callee is synchronized&quot;);
4061   if (!callee-&gt;holder()-&gt;is_initialized()) INLINE_BAILOUT(&quot;callee&#39;s klass not initialized yet&quot;);
4062   if (!callee-&gt;has_balanced_monitors())    INLINE_BAILOUT(&quot;callee&#39;s monitors do not match&quot;);
4063 
4064   // Proper inlining of methods with jsrs requires a little more work.
4065   if (callee-&gt;has_jsrs()                 ) INLINE_BAILOUT(&quot;jsrs not handled properly by inliner yet&quot;);
4066 
4067   if (strict_fp_requires_explicit_rounding &amp;&amp;
4068       method()-&gt;is_strict() != callee-&gt;is_strict()) {
4069 #ifdef IA32
4070     // If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).
4071     // When SSE2 is present, no special handling is needed.
4072     if (UseSSE &lt; 2) {
4073       INLINE_BAILOUT(&quot;caller and callee have different strict fp requirements&quot;);
4074     }
4075 #else
4076     Unimplemented();
4077 #endif // IA32
4078   }
4079 
4080   if (is_profiling() &amp;&amp; !callee-&gt;ensure_method_data()) {
4081     INLINE_BAILOUT(&quot;mdo allocation failed&quot;);
4082   }
4083 
4084   const bool is_invokedynamic = (bc == Bytecodes::_invokedynamic);
4085   const bool has_receiver = (bc != Bytecodes::_invokestatic &amp;&amp; !is_invokedynamic);
4086 
4087   const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4088   assert(args_base &gt;= 0, &quot;stack underflow during inlining&quot;);
4089 
4090   Value recv = NULL;
4091   if (has_receiver) {
4092     assert(!callee-&gt;is_static(), &quot;callee must not be static&quot;);
4093     assert(callee-&gt;arg_size() &gt; 0, &quot;must have at least a receiver&quot;);
4094 
4095     recv = state()-&gt;stack_at(args_base);
4096     if (recv-&gt;is_null_obj()) {
4097       INLINE_BAILOUT(&quot;receiver is always null&quot;);
4098     }
4099   }
4100 
4101   // now perform tests that are based on flag settings
4102   bool inlinee_by_directive = compilation()-&gt;directive()-&gt;should_inline(callee);
4103   if (callee-&gt;force_inline() || inlinee_by_directive) {
4104     if (inline_level() &gt; MaxForceInlineLevel                    ) INLINE_BAILOUT(&quot;MaxForceInlineLevel&quot;);
4105     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4106 
4107     const char* msg = &quot;&quot;;
4108     if (callee-&gt;force_inline())  msg = &quot;force inline by annotation&quot;;
4109     if (inlinee_by_directive)    msg = &quot;force inline by CompileCommand&quot;;
4110     print_inlining(callee, msg);
4111   } else {
4112     // use heuristic controls on inlining
4113     if (inline_level() &gt; MaxInlineLevel                         ) INLINE_BAILOUT(&quot;inlining too deep&quot;);
4114     if (recursive_inline_level(callee) &gt; MaxRecursiveInlineLevel) INLINE_BAILOUT(&quot;recursive inlining too deep&quot;);
4115     if (callee-&gt;code_size_for_inlining() &gt; max_inline_size()    ) INLINE_BAILOUT(&quot;callee is too large&quot;);
4116 
4117     // don&#39;t inline throwable methods unless the inlining tree is rooted in a throwable class
4118     if (callee-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;
4119         callee-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4120       // Throwable constructor call
4121       IRScope* top = scope();
4122       while (top-&gt;caller() != NULL) {
4123         top = top-&gt;caller();
4124       }
4125       if (!top-&gt;method()-&gt;holder()-&gt;is_subclass_of(ciEnv::current()-&gt;Throwable_klass())) {
4126         INLINE_BAILOUT(&quot;don&#39;t inline Throwable constructors&quot;);
4127       }
4128     }
4129 
4130     if (compilation()-&gt;env()-&gt;num_inlined_bytecodes() &gt; DesiredMethodLimit) {
4131       INLINE_BAILOUT(&quot;total inlining greater than DesiredMethodLimit&quot;);
4132     }
4133     // printing
4134     print_inlining(callee, &quot;inline&quot;, /*success*/ true);
4135   }
4136 
4137   // NOTE: Bailouts from this point on, which occur at the
4138   // GraphBuilder level, do not cause bailout just of the inlining but
4139   // in fact of the entire compilation.
4140 
4141   BlockBegin* orig_block = block();
4142 
4143   // Insert null check if necessary
4144   if (has_receiver) {
4145     // note: null check must happen even if first instruction of callee does
4146     //       an implicit null check since the callee is in a different scope
4147     //       and we must make sure exception handling does the right thing
4148     null_check(recv);
4149   }
4150 
4151   if (is_profiling()) {
4152     // Note that we&#39;d collect profile data in this method if we wanted it.
4153     // this may be redundant here...
4154     compilation()-&gt;set_would_profile(true);
4155 
4156     if (profile_calls()) {
4157       int start = 0;
4158       Values* obj_args = args_list_for_profiling(callee, start, has_receiver);
4159       if (obj_args != NULL) {
4160         int s = obj_args-&gt;max_length();
4161         // if called through method handle invoke, some arguments may have been popped
4162         for (int i = args_base+start, j = 0; j &lt; obj_args-&gt;max_length() &amp;&amp; i &lt; state()-&gt;stack_size(); ) {
4163           Value v = state()-&gt;stack_at_inc(i);
4164           if (v-&gt;type()-&gt;is_object_kind()) {
4165             obj_args-&gt;push(v);
4166             j++;
4167           }
4168         }
4169         check_args_for_profiling(obj_args, s);
4170       }
4171       profile_call(callee, recv, holder_known ? callee-&gt;holder() : NULL, obj_args, true);
4172     }
4173   }
4174 
4175   // Introduce a new callee continuation point - if the callee has
4176   // more than one return instruction or the return does not allow
4177   // fall-through of control flow, all return instructions of the
4178   // callee will need to be replaced by Goto&#39;s pointing to this
4179   // continuation point.
4180   BlockBegin* cont = block_at(next_bci());
4181   bool continuation_existed = true;
4182   if (cont == NULL) {
4183     cont = new BlockBegin(next_bci());
4184     // low number so that continuation gets parsed as early as possible
4185     cont-&gt;set_depth_first_number(0);
4186     if (PrintInitialBlockList) {
4187       tty-&gt;print_cr(&quot;CFG: created block %d (bci %d) as continuation for inline at bci %d&quot;,
4188                     cont-&gt;block_id(), cont-&gt;bci(), bci());
4189     }
4190     continuation_existed = false;
4191   }
4192   // Record number of predecessors of continuation block before
4193   // inlining, to detect if inlined method has edges to its
4194   // continuation after inlining.
4195   int continuation_preds = cont-&gt;number_of_preds();
4196 
4197   // Push callee scope
4198   push_scope(callee, cont);
4199 
4200   // the BlockListBuilder for the callee could have bailed out
4201   if (bailed_out())
4202       return false;
4203 
4204   // Temporarily set up bytecode stream so we can append instructions
4205   // (only using the bci of this stream)
4206   scope_data()-&gt;set_stream(scope_data()-&gt;parent()-&gt;stream());
4207 
4208   // Pass parameters into callee state: add assignments
4209   // note: this will also ensure that all arguments are computed before being passed
4210   ValueStack* callee_state = state();
4211   ValueStack* caller_state = state()-&gt;caller_state();
4212   for (int i = args_base; i &lt; caller_state-&gt;stack_size(); ) {
4213     const int arg_no = i - args_base;
4214     Value arg = caller_state-&gt;stack_at_inc(i);
4215     store_local(callee_state, arg, arg_no);
4216   }
4217 
4218   // Remove args from stack.
4219   // Note that we preserve locals state in case we can use it later
4220   // (see use of pop_scope() below)
4221   caller_state-&gt;truncate_stack(args_base);
4222   assert(callee_state-&gt;stack_size() == 0, &quot;callee stack must be empty&quot;);
4223 
4224   Value lock = NULL;
4225   BlockBegin* sync_handler = NULL;
4226 
4227   // Inline the locking of the receiver if the callee is synchronized
4228   if (callee-&gt;is_synchronized()) {
4229     lock = callee-&gt;is_static() ? append(new Constant(new InstanceConstant(callee-&gt;holder()-&gt;java_mirror())))
4230                                : state()-&gt;local_at(0);
4231     sync_handler = new BlockBegin(SynchronizationEntryBCI);
4232     inline_sync_entry(lock, sync_handler);
4233   }
4234 
4235   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
4236     Values* args = new Values(1);
4237     args-&gt;push(append(new Constant(new MethodConstant(method()))));
4238     append(new RuntimeCall(voidType, &quot;dtrace_method_entry&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), args));
4239   }
4240 
4241   if (profile_inlined_calls()) {
4242     profile_invocation(callee, copy_state_before_with_bci(SynchronizationEntryBCI));
4243   }
4244 
4245   BlockBegin* callee_start_block = block_at(0);
4246   if (callee_start_block != NULL) {
4247     assert(callee_start_block-&gt;is_set(BlockBegin::parser_loop_header_flag), &quot;must be loop header&quot;);
4248     Goto* goto_callee = new Goto(callee_start_block, false);
4249     // The state for this goto is in the scope of the callee, so use
4250     // the entry bci for the callee instead of the call site bci.
4251     append_with_bci(goto_callee, 0);
4252     _block-&gt;set_end(goto_callee);
4253     callee_start_block-&gt;merge(callee_state);
4254 
4255     _last = _block = callee_start_block;
4256 
4257     scope_data()-&gt;add_to_work_list(callee_start_block);
4258   }
4259 
4260   // Clear out bytecode stream
4261   scope_data()-&gt;set_stream(NULL);
4262   scope_data()-&gt;set_ignore_return(ignore_return);
4263 
4264   CompileLog* log = compilation()-&gt;log();
4265   if (log != NULL) log-&gt;head(&quot;parse method=&#39;%d&#39;&quot;, log-&gt;identify(callee));
4266 
4267   // Ready to resume parsing in callee (either in the same block we
4268   // were in before or in the callee&#39;s start block)
4269   iterate_all_blocks(callee_start_block == NULL);
4270 
4271   if (log != NULL) log-&gt;done(&quot;parse&quot;);
4272 
4273   // If we bailed out during parsing, return immediately (this is bad news)
4274   if (bailed_out())
4275       return false;
4276 
4277   // iterate_all_blocks theoretically traverses in random order; in
4278   // practice, we have only traversed the continuation if we are
4279   // inlining into a subroutine
4280   assert(continuation_existed ||
4281          !continuation()-&gt;is_set(BlockBegin::was_visited_flag),
4282          &quot;continuation should not have been parsed yet if we created it&quot;);
4283 
4284   // At this point we are almost ready to return and resume parsing of
4285   // the caller back in the GraphBuilder. The only thing we want to do
4286   // first is an optimization: during parsing of the callee we
4287   // generated at least one Goto to the continuation block. If we
4288   // generated exactly one, and if the inlined method spanned exactly
4289   // one block (and we didn&#39;t have to Goto its entry), then we snip
4290   // off the Goto to the continuation, allowing control to fall
4291   // through back into the caller block and effectively performing
4292   // block merging. This allows load elimination and CSE to take place
4293   // across multiple callee scopes if they are relatively simple, and
4294   // is currently essential to making inlining profitable.
4295   if (num_returns() == 1
4296       &amp;&amp; block() == orig_block
4297       &amp;&amp; block() == inline_cleanup_block()) {
4298     _last  = inline_cleanup_return_prev();
4299     _state = inline_cleanup_state();
4300   } else if (continuation_preds == cont-&gt;number_of_preds()) {
4301     // Inlining caused that the instructions after the invoke in the
4302     // caller are not reachable any more. So skip filling this block
4303     // with instructions!
4304     assert(cont == continuation(), &quot;&quot;);
4305     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4306     _skip_block = true;
4307   } else {
4308     // Resume parsing in continuation block unless it was already parsed.
4309     // Note that if we don&#39;t change _last here, iteration in
4310     // iterate_bytecodes_for_block will stop when we return.
4311     if (!continuation()-&gt;is_set(BlockBegin::was_visited_flag)) {
4312       // add continuation to work list instead of parsing it immediately
4313       assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
4314       scope_data()-&gt;parent()-&gt;add_to_work_list(continuation());
4315       _skip_block = true;
4316     }
4317   }
4318 
4319   // Fill the exception handler for synchronized methods with instructions
4320   if (callee-&gt;is_synchronized() &amp;&amp; sync_handler-&gt;state() != NULL) {
4321     fill_sync_handler(lock, sync_handler);
4322   } else {
4323     pop_scope();
4324   }
4325 
4326   compilation()-&gt;notice_inlined_method(callee);
4327 
4328   return true;
4329 }
4330 
4331 
4332 bool GraphBuilder::try_method_handle_inline(ciMethod* callee, bool ignore_return) {
4333   ValueStack* state_before = copy_state_before();
4334   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
4335   switch (iid) {
4336   case vmIntrinsics::_invokeBasic:
4337     {
4338       // get MethodHandle receiver
4339       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4340       ValueType* type = state()-&gt;stack_at(args_base)-&gt;type();
4341       if (type-&gt;is_constant()) {
4342         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_method_handle()-&gt;get_vmtarget();
4343         // We don&#39;t do CHA here so only inline static and statically bindable methods.
4344         if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4345           if (ciMethod::is_consistent_info(callee, target)) {
4346             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4347             ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4348             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {
4349               return true;
4350             }
4351           } else {
4352             print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4353           }
4354         } else {
4355           print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4356         }
4357       } else {
4358         print_inlining(callee, &quot;receiver not constant&quot;, /*success*/ false);
4359       }
4360     }
4361     break;
4362 
4363   case vmIntrinsics::_linkToVirtual:
4364   case vmIntrinsics::_linkToStatic:
4365   case vmIntrinsics::_linkToSpecial:
4366   case vmIntrinsics::_linkToInterface:
4367     {
4368       // pop MemberName argument
4369       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4370       ValueType* type = apop()-&gt;type();
4371       if (type-&gt;is_constant()) {
4372         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_member_name()-&gt;get_vmtarget();
4373         ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
4374         // If the target is another method handle invoke, try to recursively get
4375         // a better target.
4376         if (target-&gt;is_method_handle_intrinsic()) {
4377           if (try_method_handle_inline(target, ignore_return)) {
4378             return true;
4379           }
4380         } else if (!ciMethod::is_consistent_info(callee, target)) {
4381           print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4382         } else {
4383           ciSignature* signature = target-&gt;signature();
4384           const int receiver_skip = target-&gt;is_static() ? 0 : 1;
4385           // Cast receiver to its type.
4386           if (!target-&gt;is_static()) {
4387             ciKlass* tk = signature-&gt;accessing_klass();
4388             Value obj = state()-&gt;stack_at(args_base);
4389             if (obj-&gt;exact_type() == NULL &amp;&amp;
4390                 obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4391               TypeCast* c = new TypeCast(tk, obj, state_before);
4392               append(c);
4393               state()-&gt;stack_at_put(args_base, c);
4394             }
4395           }
4396           // Cast reference arguments to its type.
4397           for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
4398             ciType* t = signature-&gt;type_at(i);
4399             if (t-&gt;is_klass()) {
4400               ciKlass* tk = t-&gt;as_klass();
4401               Value obj = state()-&gt;stack_at(args_base + receiver_skip + j);
4402               if (obj-&gt;exact_type() == NULL &amp;&amp;
4403                   obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4404                 TypeCast* c = new TypeCast(t, obj, state_before);
4405                 append(c);
4406                 state()-&gt;stack_at_put(args_base + receiver_skip + j, c);
4407               }
4408             }
4409             j += t-&gt;size();  // long and double take two slots
4410           }
4411           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4412           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4413             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4414             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {
4415               return true;
4416             }
4417           } else {
4418             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4419           }
4420         }
4421       } else {
4422         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4423       }
4424     }
4425     break;
4426 
4427   default:
4428     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4429     break;
4430   }
4431   set_state(state_before-&gt;copy_for_parsing());
4432   return false;
4433 }
4434 
4435 
4436 void GraphBuilder::inline_bailout(const char* msg) {
4437   assert(msg != NULL, &quot;inline bailout msg must exist&quot;);
4438   _inline_bailout_msg = msg;
4439 }
4440 
4441 
4442 void GraphBuilder::clear_inline_bailout() {
4443   _inline_bailout_msg = NULL;
4444 }
4445 
4446 
4447 void GraphBuilder::push_root_scope(IRScope* scope, BlockList* bci2block, BlockBegin* start) {
4448   ScopeData* data = new ScopeData(NULL);
4449   data-&gt;set_scope(scope);
4450   data-&gt;set_bci2block(bci2block);
4451   _scope_data = data;
4452   _block = start;
4453 }
4454 
4455 
4456 void GraphBuilder::push_scope(ciMethod* callee, BlockBegin* continuation) {
4457   IRScope* callee_scope = new IRScope(compilation(), scope(), bci(), callee, -1, false);
4458   scope()-&gt;add_callee(callee_scope);
4459 
4460   BlockListBuilder blb(compilation(), callee_scope, -1);
4461   CHECK_BAILOUT();
4462 
4463   if (!blb.bci2block()-&gt;at(0)-&gt;is_set(BlockBegin::parser_loop_header_flag)) {
4464     // this scope can be inlined directly into the caller so remove
4465     // the block at bci 0.
4466     blb.bci2block()-&gt;at_put(0, NULL);
4467   }
4468 
4469   set_state(new ValueStack(callee_scope, state()-&gt;copy(ValueStack::CallerState, bci())));
4470 
4471   ScopeData* data = new ScopeData(scope_data());
4472   data-&gt;set_scope(callee_scope);
4473   data-&gt;set_bci2block(blb.bci2block());
4474   data-&gt;set_continuation(continuation);
4475   _scope_data = data;
4476 }
4477 
4478 
4479 void GraphBuilder::push_scope_for_jsr(BlockBegin* jsr_continuation, int jsr_dest_bci) {
4480   ScopeData* data = new ScopeData(scope_data());
4481   data-&gt;set_parsing_jsr();
4482   data-&gt;set_jsr_entry_bci(jsr_dest_bci);
4483   data-&gt;set_jsr_return_address_local(-1);
4484   // Must clone bci2block list as we will be mutating it in order to
4485   // properly clone all blocks in jsr region as well as exception
4486   // handlers containing rets
4487   BlockList* new_bci2block = new BlockList(bci2block()-&gt;length());
4488   new_bci2block-&gt;appendAll(bci2block());
4489   data-&gt;set_bci2block(new_bci2block);
4490   data-&gt;set_scope(scope());
4491   data-&gt;setup_jsr_xhandlers();
4492   data-&gt;set_continuation(continuation());
4493   data-&gt;set_jsr_continuation(jsr_continuation);
4494   _scope_data = data;
4495 }
4496 
4497 
4498 void GraphBuilder::pop_scope() {
4499   int number_of_locks = scope()-&gt;number_of_locks();
4500   _scope_data = scope_data()-&gt;parent();
4501   // accumulate minimum number of monitor slots to be reserved
4502   scope()-&gt;set_min_number_of_locks(number_of_locks);
4503 }
4504 
4505 
4506 void GraphBuilder::pop_scope_for_jsr() {
4507   _scope_data = scope_data()-&gt;parent();
4508 }
4509 
4510 void GraphBuilder::append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4511   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4512   null_check(args-&gt;at(0));
4513   Instruction* offset = args-&gt;at(2);
4514 #ifndef _LP64
4515   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4516 #endif
4517   Instruction* op = append(new UnsafeGetObject(t, args-&gt;at(1), offset, is_volatile));
4518   push(op-&gt;type(), op);
4519   compilation()-&gt;set_has_unsafe_access(true);
4520 }
4521 
4522 
4523 void GraphBuilder::append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile) {
4524   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4525   null_check(args-&gt;at(0));
4526   Instruction* offset = args-&gt;at(2);
4527 #ifndef _LP64
4528   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4529 #endif
4530   Value val = args-&gt;at(3);
4531   if (t == T_BOOLEAN) {
4532     Value mask = append(new Constant(new IntConstant(1)));
4533     val = append(new LogicOp(Bytecodes::_iand, val, mask));
4534   }
4535   Instruction* op = append(new UnsafePutObject(t, args-&gt;at(1), offset, val, is_volatile));
4536   compilation()-&gt;set_has_unsafe_access(true);
4537   kill_all();
4538 }
4539 
4540 
4541 void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {
4542   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4543   null_check(args-&gt;at(0));
4544   Instruction* op = append(new UnsafeGetRaw(t, args-&gt;at(1), false));
4545   push(op-&gt;type(), op);
4546   compilation()-&gt;set_has_unsafe_access(true);
4547 }
4548 
4549 
4550 void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {
4551   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4552   null_check(args-&gt;at(0));
4553   Instruction* op = append(new UnsafePutRaw(t, args-&gt;at(1), args-&gt;at(2)));
4554   compilation()-&gt;set_has_unsafe_access(true);
4555 }
4556 
4557 
4558 void GraphBuilder::append_unsafe_CAS(ciMethod* callee) {
4559   ValueStack* state_before = copy_state_for_exception();
4560   ValueType* result_type = as_ValueType(callee-&gt;return_type());
4561   assert(result_type-&gt;is_int(), &quot;int result&quot;);
4562   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4563 
4564   // Pop off some args to specially handle, then push back
4565   Value newval = args-&gt;pop();
4566   Value cmpval = args-&gt;pop();
4567   Value offset = args-&gt;pop();
4568   Value src = args-&gt;pop();
4569   Value unsafe_obj = args-&gt;pop();
4570 
4571   // Separately handle the unsafe arg. It is not needed for code
4572   // generation, but must be null checked
4573   null_check(unsafe_obj);
4574 
4575 #ifndef _LP64
4576   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4577 #endif
4578 
4579   args-&gt;push(src);
4580   args-&gt;push(offset);
4581   args-&gt;push(cmpval);
4582   args-&gt;push(newval);
4583 
4584   // An unsafe CAS can alias with other field accesses, but we don&#39;t
4585   // know which ones so mark the state as no preserved.  This will
4586   // cause CSE to invalidate memory across it.
4587   bool preserves_state = false;
4588   Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(), args, false, state_before, preserves_state);
4589   append_split(result);
4590   push(result_type, result);
4591   compilation()-&gt;set_has_unsafe_access(true);
4592 }
4593 
4594 void GraphBuilder::append_char_access(ciMethod* callee, bool is_store) {
4595   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
4596   // correctly requires matched array shapes.
4597   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
4598           &quot;sanity: byte[] and char[] bases agree&quot;);
4599   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
4600           &quot;sanity: byte[] and char[] scales agree&quot;);
4601 
4602   ValueStack* state_before = copy_state_indexed_access();
4603   compilation()-&gt;set_has_access_indexed(true);
4604   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4605   Value array = args-&gt;at(0);
4606   Value index = args-&gt;at(1);
4607   if (is_store) {
4608     Value value = args-&gt;at(2);
4609     Instruction* store = append(new StoreIndexed(array, index, NULL, T_CHAR, value, state_before, false, true));
4610     store-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4611     _memory-&gt;store_value(value);
4612   } else {
4613     Instruction* load = append(new LoadIndexed(array, index, NULL, T_CHAR, state_before, true));
4614     load-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
4615     push(load-&gt;type(), load);
4616   }
4617 }
4618 
4619 void GraphBuilder::print_inlining(ciMethod* callee, const char* msg, bool success) {
4620   CompileLog* log = compilation()-&gt;log();
4621   if (log != NULL) {
4622     assert(msg != NULL, &quot;inlining msg should not be null!&quot;);
4623     if (success) {
4624       log-&gt;inline_success(msg);
4625     } else {
4626       log-&gt;inline_fail(msg);
4627     }
4628   }
4629   EventCompilerInlining event;
4630   if (event.should_commit()) {
4631     CompilerEvent::InlineEvent::post(event, compilation()-&gt;env()-&gt;task()-&gt;compile_id(), method()-&gt;get_Method(), callee, success, msg, bci());
4632   }
4633 
4634   CompileTask::print_inlining_ul(callee, scope()-&gt;level(), bci(), msg);
4635 
4636   if (!compilation()-&gt;directive()-&gt;PrintInliningOption) {
4637     return;
4638   }
4639   CompileTask::print_inlining_tty(callee, scope()-&gt;level(), bci(), msg);
4640   if (success &amp;&amp; CIPrintMethodCodes) {
4641     callee-&gt;print_codes();
4642   }
4643 }
4644 
4645 void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {
4646   Values* args = state()-&gt;pop_arguments(callee-&gt;arg_size());
4647   BasicType t = callee-&gt;return_type()-&gt;basic_type();
4648   null_check(args-&gt;at(0));
4649   Instruction* offset = args-&gt;at(2);
4650 #ifndef _LP64
4651   offset = append(new Convert(Bytecodes::_l2i, offset, as_ValueType(T_INT)));
4652 #endif
4653   Instruction* op = append(new UnsafeGetAndSetObject(t, args-&gt;at(1), offset, args-&gt;at(3), is_add));
4654   compilation()-&gt;set_has_unsafe_access(true);
4655   kill_all();
4656   push(op-&gt;type(), op);
4657 }
4658 
4659 #ifndef PRODUCT
4660 void GraphBuilder::print_stats() {
4661   vmap()-&gt;print();
4662 }
4663 #endif // PRODUCT
4664 
4665 void GraphBuilder::profile_call(ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined) {
4666   assert(known_holder == NULL || (known_holder-&gt;is_instance_klass() &amp;&amp;
4667                                   (!known_holder-&gt;is_interface() ||
4668                                    ((ciInstanceKlass*)known_holder)-&gt;has_nonstatic_concrete_methods())), &quot;should be non-static concrete method&quot;);
4669   if (known_holder != NULL) {
4670     if (known_holder-&gt;exact_klass() == NULL) {
4671       known_holder = compilation()-&gt;cha_exact_type(known_holder);
4672     }
4673   }
4674 
4675   append(new ProfileCall(method(), bci(), callee, recv, known_holder, obj_args, inlined));
4676 }
4677 
4678 void GraphBuilder::profile_return_type(Value ret, ciMethod* callee, ciMethod* m, int invoke_bci) {
4679   assert((m == NULL) == (invoke_bci &lt; 0), &quot;invalid method and invalid bci together&quot;);
4680   if (m == NULL) {
4681     m = method();
4682   }
4683   if (invoke_bci &lt; 0) {
4684     invoke_bci = bci();
4685   }
4686   ciMethodData* md = m-&gt;method_data_or_null();
4687   ciProfileData* data = md-&gt;bci_to_data(invoke_bci);
4688   if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
4689     bool has_return = data-&gt;is_CallTypeData() ? ((ciCallTypeData*)data)-&gt;has_return() : ((ciVirtualCallTypeData*)data)-&gt;has_return();
4690     if (has_return) {
4691       append(new ProfileReturnType(m , invoke_bci, callee, ret));
4692     }
4693   }
4694 }
4695 
4696 void GraphBuilder::profile_invocation(ciMethod* callee, ValueStack* state) {
4697   append(new ProfileInvoke(callee, state));
4698 }
    </pre>
  </body>
</html>
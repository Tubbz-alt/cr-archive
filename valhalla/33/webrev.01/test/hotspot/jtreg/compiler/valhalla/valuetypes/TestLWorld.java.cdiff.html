<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestIntrinsics.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,14 ***</span>
          MyValue1 def = MyValue1.createDefaultDontInline();
          long result = test12(vt, vt);
          Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
      }
  
<span class="line-modified">!     class MyObject implements MyInterface {</span>
          public int x;
  
<span class="line-modified">!         public MyObject(int x) {</span>
              this.x = x;
          }
  
          @ForceInline
          public long hash() {
<span class="line-new-header">--- 434,14 ---</span>
          MyValue1 def = MyValue1.createDefaultDontInline();
          long result = test12(vt, vt);
          Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
      }
  
<span class="line-modified">!     class MyObject1 implements MyInterface {</span>
          public int x;
  
<span class="line-modified">!         public MyObject1(int x) {</span>
              this.x = x;
          }
  
          @ForceInline
          public long hash() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,11 ***</span>
      // Test merging value types and interfaces
      @Test()
      public MyInterface test13(int state) {
          MyInterface res = null;
          if (state == 0) {
<span class="line-modified">!             res = new MyObject(rI);</span>
          } else if (state == 1) {
              res = MyValue1.createWithFieldsInline(rI, rL);
          } else if (state == 2) {
              res = MyValue1.createWithFieldsDontInline(rI, rL);
          } else if (state == 3) {
<span class="line-new-header">--- 452,11 ---</span>
      // Test merging value types and interfaces
      @Test()
      public MyInterface test13(int state) {
          MyInterface res = null;
          if (state == 0) {
<span class="line-modified">!             res = new MyObject1(rI);</span>
          } else if (state == 1) {
              res = MyValue1.createWithFieldsInline(rI, rL);
          } else if (state == 2) {
              res = MyValue1.createWithFieldsDontInline(rI, rL);
          } else if (state == 3) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,11 ***</span>
      @DontCompile
      public void test13_verifier(boolean warmup) {
          objectField1 = valueField1;
          MyInterface result = null;
          result = test13(0);
<span class="line-modified">!         Asserts.assertEQ(((MyObject)result).x, rI);</span>
          result = test13(1);
          Asserts.assertEQ(((MyValue1)result).hash(), hash());
          result = test13(2);
          Asserts.assertEQ(((MyValue1)result).hash(), hash());
          result = test13(3);
<span class="line-new-header">--- 472,11 ---</span>
      @DontCompile
      public void test13_verifier(boolean warmup) {
          objectField1 = valueField1;
          MyInterface result = null;
          result = test13(0);
<span class="line-modified">!         Asserts.assertEQ(((MyObject1)result).x, rI);</span>
          result = test13(1);
          Asserts.assertEQ(((MyValue1)result).hash(), hash());
          result = test13(2);
          Asserts.assertEQ(((MyValue1)result).hash(), hash());
          result = test13(3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,24 ***</span>
      }
  
      // Test merging value types and interfaces in loops
      @Test()
      public MyInterface test14(int iters) {
<span class="line-modified">!         MyInterface res = new MyObject(rI);</span>
          for (int i = 0; i &lt; iters; ++i) {
<span class="line-modified">!             if (res instanceof MyObject) {</span>
                  res = MyValue1.createWithFieldsInline(rI, rL);
              } else {
                  res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
              }
          }
          return res;
      }
  
      @DontCompile
      public void test14_verifier(boolean warmup) {
<span class="line-modified">!         MyObject result1 = (MyObject)test14(0);</span>
          Asserts.assertEQ(result1.x, rI);
          int iters = (Math.abs(rI) % 10) + 1;
          MyValue1 result2 = (MyValue1)test14(iters);
          MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
          Asserts.assertEQ(result2.hash(), vt.hash());
<span class="line-new-header">--- 488,24 ---</span>
      }
  
      // Test merging value types and interfaces in loops
      @Test()
      public MyInterface test14(int iters) {
<span class="line-modified">!         MyInterface res = new MyObject1(rI);</span>
          for (int i = 0; i &lt; iters; ++i) {
<span class="line-modified">!             if (res instanceof MyObject1) {</span>
                  res = MyValue1.createWithFieldsInline(rI, rL);
              } else {
                  res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
              }
          }
          return res;
      }
  
      @DontCompile
      public void test14_verifier(boolean warmup) {
<span class="line-modified">!         MyObject1 result1 = (MyObject1)test14(0);</span>
          Asserts.assertEQ(result1.x, rI);
          int iters = (Math.abs(rI) % 10) + 1;
          MyValue1 result2 = (MyValue1)test14(iters);
          MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
          Asserts.assertEQ(result2.hash(), vt.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,22 ***</span>
          Asserts.assertEQ(result.hash(), hash());
      }
  
      // Test load from (flattened) value type array disguised as interface array
      @Test()
<span class="line-modified">!     public Object test22(MyInterface[] ia, int index) {</span>
          return ia[index];
      }
  
      @DontCompile
<span class="line-modified">!     public void test22_verifier(boolean warmup) {</span>
<span class="line-modified">!         MyValue1 result = (MyValue1)test22(testValue1Array, Math.abs(rI) % 3);</span>
          Asserts.assertEQ(result.hash(), hash());
      }
  
<span class="line-modified">!     // Test value store to (flattened) value type array disguised as object array</span>
  
      @ForceInline
      public void test23_inline(Object[] oa, Object o, int index) {
          oa[index] = o;
      }
  
<span class="line-new-header">--- 642,33 ---</span>
          Asserts.assertEQ(result.hash(), hash());
      }
  
      // Test load from (flattened) value type array disguised as interface array
      @Test()
<span class="line-modified">!     public Object test22Interface(MyInterface[] ia, int index) {</span>
          return ia[index];
      }
  
      @DontCompile
<span class="line-modified">!     public void test22Interface_verifier(boolean warmup) {</span>
<span class="line-modified">!         MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);</span>
          Asserts.assertEQ(result.hash(), hash());
      }
  
<span class="line-modified">!     // Test load from (flattened) value type array disguised as abstract array</span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public Object test22Abstract(MyAbstract[] ia, int index) {</span>
<span class="line-added">+         return ia[index];</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test22Abstract_verifier(boolean warmup) {</span>
<span class="line-added">+         MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);</span>
<span class="line-added">+         Asserts.assertEQ(result.hash(), hash());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test value store to (flattened) value type array disguised as object array</span>
      @ForceInline
      public void test23_inline(Object[] oa, Object o, int index) {
          oa[index] = o;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 724,50 ***</span>
          }
      }
  
      // Test value store to (flattened) value type array disguised as interface array
      @ForceInline
<span class="line-modified">!     public void test26_inline(MyInterface[] ia, MyInterface i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test26(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified">!       test26_inline(ia, vt, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test26_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified">!         test26(testValue1Array, vt, index);</span>
          Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
          testValue1Array[index] = testValue1;
          try {
<span class="line-modified">!             test26(testValue2Array, vt, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
          Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
      }
  
      @ForceInline
<span class="line-modified">!     public void test27_inline(MyInterface[] ia, MyInterface i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test27(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified">!         test27_inline(ia, vt, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test27_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          try {
<span class="line-modified">!             test27(null, testValue1, index);</span>
              throw new RuntimeException(&quot;No NPE thrown&quot;);
          } catch (NullPointerException e) {
              // Expected
          }
      }
<span class="line-new-header">--- 735,98 ---</span>
          }
      }
  
      // Test value store to (flattened) value type array disguised as interface array
      @ForceInline
<span class="line-modified">!     public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         ia[index] = i;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-added">+       test26Interface_inline(ia, vt, index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test26Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         int index = Math.abs(rI) % 3;</span>
<span class="line-added">+         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
<span class="line-added">+         test26Interface(testValue1Array, vt, index);</span>
<span class="line-added">+         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());</span>
<span class="line-added">+         testValue1Array[index] = testValue1;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             test26Interface(testValue2Array, vt, index);</span>
<span class="line-added">+             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added">+         } catch (ArrayStoreException e) {</span>
<span class="line-added">+             // Expected</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         ia[index] = i;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-added">+         test27Interface_inline(ia, vt, index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test27Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         int index = Math.abs(rI) % 3;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             test27Interface(null, testValue1, index);</span>
<span class="line-added">+             throw new RuntimeException(&quot;No NPE thrown&quot;);</span>
<span class="line-added">+         } catch (NullPointerException e) {</span>
<span class="line-added">+             // Expected</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test value store to (flattened) value type array disguised as abstract array</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified">!       test26Abstract_inline(ia, vt, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test26Abstract_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified">!         test26Abstract(testValue1Array, vt, index);</span>
          Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
          testValue1Array[index] = testValue1;
          try {
<span class="line-modified">!             test26Abstract(testValue2Array, vt, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
          Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
      }
  
      @ForceInline
<span class="line-modified">!     public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified">!         test27Abstract_inline(ia, vt, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test27Abstract_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          try {
<span class="line-modified">!             test27Abstract(null, testValue1, index);</span>
              throw new RuntimeException(&quot;No NPE thrown&quot;);
          } catch (NullPointerException e) {
              // Expected
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,50 ***</span>
          }
      }
  
      // Test value store to (flattened) value type array disguised as interface array
      @ForceInline
<span class="line-modified">!     public void test31_inline(MyInterface[] ia, MyInterface i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test31(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-modified">!         test31_inline(ia, i, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test31_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified">!         test31(testValue1Array, vt1, index);</span>
          Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
          try {
<span class="line-modified">!             test31(testValue1Array, testValue2, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
          Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
          testValue1Array[index] = testValue1;
      }
  
      @ForceInline
<span class="line-modified">!     public void test32_inline(MyInterface[] ia, MyInterface i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test32(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-modified">!         test32_inline(ia, i, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test32_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          try {
<span class="line-modified">!             test32(testValue2Array, testValue1, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
      }
<span class="line-new-header">--- 901,98 ---</span>
          }
      }
  
      // Test value store to (flattened) value type array disguised as interface array
      @ForceInline
<span class="line-modified">!     public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         ia[index] = i;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public void test31Interface(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         test31Interface_inline(ia, i, index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test31Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         int index = Math.abs(rI) % 3;</span>
<span class="line-added">+         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
<span class="line-added">+         test31Interface(testValue1Array, vt1, index);</span>
<span class="line-added">+         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             test31Interface(testValue1Array, testValue2, index);</span>
<span class="line-added">+             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added">+         } catch (ArrayStoreException e) {</span>
<span class="line-added">+             // Expected</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());</span>
<span class="line-added">+         testValue1Array[index] = testValue1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         ia[index] = i;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public void test32Interface(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added">+         test32Interface_inline(ia, i, index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test32Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         int index = Math.abs(rI) % 3;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             test32Interface(testValue2Array, testValue1, index);</span>
<span class="line-added">+             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added">+         } catch (ArrayStoreException e) {</span>
<span class="line-added">+             // Expected</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test value store to (flattened) value type array disguised as abstract array</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {</span>
<span class="line-modified">!         test31Abstract_inline(ia, i, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test31Abstract_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified">!         test31Abstract(testValue1Array, vt1, index);</span>
          Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
          try {
<span class="line-modified">!             test31Abstract(testValue1Array, testValue2, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
          Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
          testValue1Array[index] = testValue1;
      }
  
      @ForceInline
<span class="line-modified">!     public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
          ia[index] = i;
      }
  
      @Test()
<span class="line-modified">!     public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {</span>
<span class="line-modified">!         test32Abstract_inline(ia, i, index);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test32Abstract_verifier(boolean warmup) {</span>
          int index = Math.abs(rI) % 3;
          try {
<span class="line-modified">!             test32Abstract(testValue2Array, testValue1, index);</span>
              throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
          } catch (ArrayStoreException e) {
              // Expected
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1699,22 ***</span>
          throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
      }
  
      // type system test with interface and value type
      @ForceInline
<span class="line-modified">!     public MyInterface test64_helper(MyValue1 vt) {</span>
          return vt;
      }
  
      @Test()
<span class="line-modified">!     public MyInterface test64(MyValue1 vt) {</span>
<span class="line-modified">!         return test64_helper(vt);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test64_verifier(boolean warmup) {</span>
<span class="line-modified">!         test64(testValue1);</span>
      }
  
      // Array store tests
      @Test()
      public void test65(Object[] array, MyValue1 vt) {
<span class="line-new-header">--- 1806,38 ---</span>
          throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
      }
  
      // type system test with interface and value type
      @ForceInline
<span class="line-modified">!     public MyInterface test64Interface_helper(MyValue1 vt) {</span>
<span class="line-added">+         return vt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public MyInterface test64Interface(MyValue1 vt) {</span>
<span class="line-added">+         return test64Interface_helper(vt);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test64Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         test64Interface(testValue1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // type system test with abstract and value type</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public MyAbstract test64Abstract_helper(MyValue1 vt) {</span>
          return vt;
      }
  
      @Test()
<span class="line-modified">!     public MyAbstract test64Abstract(MyValue1 vt) {</span>
<span class="line-modified">!         return test64Abstract_helper(vt);</span>
      }
  
      @DontCompile
<span class="line-modified">!     public void test64Abstract_verifier(boolean warmup) {</span>
<span class="line-modified">!         test64Abstract(testValue1);</span>
      }
  
      // Array store tests
      @Test()
      public void test65(Object[] array, MyValue1 vt) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1786,27 ***</span>
          Asserts.assertEQ(result, rI * testValue1Array.length);
      }
  
      // Same as test69 but with an Interface
      @ForceInline
<span class="line-modified">!     public MyInterface test70_sum(MyInterface a, MyInterface b) {</span>
          int sum = ((MyValue1)a).x + ((MyValue1)b).x;
          return MyValue1.setX(((MyValue1)a), sum);
      }
  
      @Test(failOn = ALLOC + STORE)
<span class="line-modified">!     public int test70(MyValue1[] array) {</span>
          MyValue1 result = MyValue1.createDefaultInline();
          for (int i = 0; i &lt; array.length; ++i) {
<span class="line-modified">!             result = (MyValue1)test70_sum(result, array[i]);</span>
          }
          return result.x;
      }
  
      @DontCompile
<span class="line-modified">!     public void test70_verifier(boolean warmup) {</span>
<span class="line-modified">!         int result = test70(testValue1Array);</span>
          Asserts.assertEQ(result, rI * testValue1Array.length);
      }
  
      // Test that allocated value type is not used in non-dominated path
      public MyValue1 test71_inline(Object obj) {
<span class="line-new-header">--- 1909,49 ---</span>
          Asserts.assertEQ(result, rI * testValue1Array.length);
      }
  
      // Same as test69 but with an Interface
      @ForceInline
<span class="line-modified">!     public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {</span>
<span class="line-added">+         int sum = ((MyValue1)a).x + ((MyValue1)b).x;</span>
<span class="line-added">+         return MyValue1.setX(((MyValue1)a), sum);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test(failOn = ALLOC + STORE)</span>
<span class="line-added">+     public int test70Interface(MyValue1[] array) {</span>
<span class="line-added">+         MyValue1 result = MyValue1.createDefaultInline();</span>
<span class="line-added">+         for (int i = 0; i &lt; array.length; ++i) {</span>
<span class="line-added">+             result = (MyValue1)test70Interface_sum(result, array[i]);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result.x;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test70Interface_verifier(boolean warmup) {</span>
<span class="line-added">+         int result = test70Interface(testValue1Array);</span>
<span class="line-added">+         Asserts.assertEQ(result, rI * testValue1Array.length);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Same as test69 but with an Abstract</span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {</span>
          int sum = ((MyValue1)a).x + ((MyValue1)b).x;
          return MyValue1.setX(((MyValue1)a), sum);
      }
  
      @Test(failOn = ALLOC + STORE)
<span class="line-modified">!     public int test70Abstract(MyValue1[] array) {</span>
          MyValue1 result = MyValue1.createDefaultInline();
          for (int i = 0; i &lt; array.length; ++i) {
<span class="line-modified">!             result = (MyValue1)test70Abstract_sum(result, array[i]);</span>
          }
          return result.x;
      }
  
      @DontCompile
<span class="line-modified">!     public void test70Abstract_verifier(boolean warmup) {</span>
<span class="line-modified">!         int result = test70Abstract(testValue1Array);</span>
          Asserts.assertEQ(result, rI * testValue1Array.length);
      }
  
      // Test that allocated value type is not used in non-dominated path
      public MyValue1 test71_inline(Object obj) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2388,6 ***</span>
<span class="line-new-header">--- 2533,328 ---</span>
          if (!warmup) {
              Asserts.assertTrue(test96(null, null));
              Asserts.assertFalse(test96(o1, null));
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     // Abstract class tests</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontInline</span>
<span class="line-added">+     public MyAbstract test97_dontinline1(MyAbstract o) {</span>
<span class="line-added">+         return o;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontInline</span>
<span class="line-added">+     public MyValue1 test97_dontinline2(MyAbstract o) {</span>
<span class="line-added">+         return (MyValue1)o;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public MyAbstract test97_inline1(MyAbstract o) {</span>
<span class="line-added">+         return o;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @ForceInline</span>
<span class="line-added">+     public MyValue1 test97_inline2(MyAbstract o) {</span>
<span class="line-added">+         return (MyValue1)o;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public MyValue1 test97() {</span>
<span class="line-added">+         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+         vt = (MyValue1)test97_dontinline1(vt);</span>
<span class="line-added">+         vt =           test97_dontinline2(vt);</span>
<span class="line-added">+         vt = (MyValue1)test97_inline1(vt);</span>
<span class="line-added">+         vt =           test97_inline2(vt);</span>
<span class="line-added">+         return vt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test97_verifier(boolean warmup) {</span>
<span class="line-added">+         Asserts.assertEQ(test97().hash(), hash());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test storing/loading value types to/from abstract and value type fields</span>
<span class="line-added">+     MyAbstract abstractField1 = null;</span>
<span class="line-added">+     MyAbstract abstractField2 = null;</span>
<span class="line-added">+     MyAbstract abstractField3 = null;</span>
<span class="line-added">+     MyAbstract abstractField4 = null;</span>
<span class="line-added">+     MyAbstract abstractField5 = null;</span>
<span class="line-added">+     MyAbstract abstractField6 = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontInline</span>
<span class="line-added">+     public MyAbstract readValueField5AsAbstract() {</span>
<span class="line-added">+         return (MyAbstract)valueField5;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontInline</span>
<span class="line-added">+     public MyAbstract readStaticValueField4AsAbstract() {</span>
<span class="line-added">+         return (MyAbstract)staticValueField4;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public long test98(MyValue1 vt1, MyAbstract vt2) {</span>
<span class="line-added">+         abstractField1 = vt1;</span>
<span class="line-added">+         abstractField2 = (MyValue1)vt2;</span>
<span class="line-added">+         abstractField3 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+         abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">+         abstractField5 = valueField1;</span>
<span class="line-added">+         abstractField6 = valueField3;</span>
<span class="line-added">+         valueField1 = (MyValue1)abstractField1;</span>
<span class="line-added">+         valueField2 = (MyValue1)vt2;</span>
<span class="line-added">+         valueField3 = (MyValue1)vt2;</span>
<span class="line-added">+         staticValueField1 = (MyValue1)abstractField1;</span>
<span class="line-added">+         staticValueField2 = (MyValue1)vt1;</span>
<span class="line-added">+         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization</span>
<span class="line-added">+         if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {</span>
<span class="line-added">+             throw new RuntimeException(&quot;Should be null&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +</span>
<span class="line-added">+                ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +</span>
<span class="line-added">+                ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +</span>
<span class="line-added">+                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +</span>
<span class="line-added">+                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test98_verifier(boolean warmup) {</span>
<span class="line-added">+         MyValue1 vt = testValue1;</span>
<span class="line-added">+         MyValue1 def = MyValue1.createDefaultDontInline();</span>
<span class="line-added">+         long result = test98(vt, vt);</span>
<span class="line-added">+         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class MyObject2 extends MyAbstract {</span>
<span class="line-added">+         public int x;</span>
<span class="line-added">+ </span>
<span class="line-added">+         public MyObject2(int x) {</span>
<span class="line-added">+             this.x = x;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @ForceInline</span>
<span class="line-added">+         public long hash() {</span>
<span class="line-added">+             return x;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test merging value types and abstract classes</span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public MyAbstract test99(int state) {</span>
<span class="line-added">+         MyAbstract res = null;</span>
<span class="line-added">+         if (state == 0) {</span>
<span class="line-added">+             res = new MyObject2(rI);</span>
<span class="line-added">+         } else if (state == 1) {</span>
<span class="line-added">+             res = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+         } else if (state == 2) {</span>
<span class="line-added">+             res = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">+         } else if (state == 3) {</span>
<span class="line-added">+             res = (MyValue1)objectField1;</span>
<span class="line-added">+         } else if (state == 4) {</span>
<span class="line-added">+             res = valueField1;</span>
<span class="line-added">+         } else if (state == 5) {</span>
<span class="line-added">+             res = null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return res;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test99_verifier(boolean warmup) {</span>
<span class="line-added">+         objectField1 = valueField1;</span>
<span class="line-added">+         MyAbstract result = null;</span>
<span class="line-added">+         result = test99(0);</span>
<span class="line-added">+         Asserts.assertEQ(((MyObject2)result).x, rI);</span>
<span class="line-added">+         result = test99(1);</span>
<span class="line-added">+         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">+         result = test99(2);</span>
<span class="line-added">+         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">+         result = test99(3);</span>
<span class="line-added">+         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">+         result = test99(4);</span>
<span class="line-added">+         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">+         result = test99(5);</span>
<span class="line-added">+         Asserts.assertEQ(result, null);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test merging value types and abstract classes in loops</span>
<span class="line-added">+     @Test()</span>
<span class="line-added">+     public MyAbstract test100(int iters) {</span>
<span class="line-added">+         MyAbstract res = new MyObject2(rI);</span>
<span class="line-added">+         for (int i = 0; i &lt; iters; ++i) {</span>
<span class="line-added">+             if (res instanceof MyObject2) {</span>
<span class="line-added">+                 res = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return res;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test100_verifier(boolean warmup) {</span>
<span class="line-added">+         MyObject2 result1 = (MyObject2)test100(0);</span>
<span class="line-added">+         Asserts.assertEQ(result1.x, rI);</span>
<span class="line-added">+         int iters = (Math.abs(rI) % 10) + 1;</span>
<span class="line-added">+         MyValue1 result2 = (MyValue1)test100(iters);</span>
<span class="line-added">+         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);</span>
<span class="line-added">+         Asserts.assertEQ(result2.hash(), vt.hash());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test value types in abstract class variables that are live at safepoint</span>
<span class="line-added">+     @Test(failOn = ALLOC + STORE + LOOP)</span>
<span class="line-added">+     public long test101(MyValue1 arg, boolean deopt) {</span>
<span class="line-added">+         MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+         MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">+         MyAbstract vt3 = arg;</span>
<span class="line-added">+         MyAbstract vt4 = valueField1;</span>
<span class="line-added">+         if (deopt) {</span>
<span class="line-added">+             // uncommon trap</span>
<span class="line-added">+             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test101&quot;));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +</span>
<span class="line-added">+                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test101_verifier(boolean warmup) {</span>
<span class="line-added">+         long result = test101(valueField1, !warmup);</span>
<span class="line-added">+         Asserts.assertEQ(result, 4*hash());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Test comparing value types with abstract classes</span>
<span class="line-added">+     @Test(failOn = LOAD + LOOP)</span>
<span class="line-added">+     public boolean test102(Object arg) {</span>
<span class="line-added">+         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">+         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||</span>
<span class="line-added">+             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test102_verifier(boolean warmup) {</span>
<span class="line-added">+         boolean result = test102(null);</span>
<span class="line-added">+         Asserts.assertFalse(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // An abstract class with a non-static field can never be implemented by a value type</span>
<span class="line-added">+     abstract class NoValueImplementors1 {</span>
<span class="line-added">+         int field = 42;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class MyObject3 extends NoValueImplementors1 {</span>
<span class="line-added">+ </span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class MyObject4 extends NoValueImplementors1 {</span>
<span class="line-added">+ </span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field</span>
<span class="line-added">+     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">+     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {</span>
<span class="line-added">+         return array[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test103_verifier(boolean warmup) {</span>
<span class="line-added">+         NoValueImplementors1[] array1 = new NoValueImplementors1[3];</span>
<span class="line-added">+         MyObject3[] array2 = new MyObject3[3];</span>
<span class="line-added">+         MyObject4[] array3 = new MyObject4[3];</span>
<span class="line-added">+         NoValueImplementors1 result = test103(array1, 0);</span>
<span class="line-added">+         Asserts.assertEquals(result, array1[0]);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test103(array2, 1);</span>
<span class="line-added">+         Asserts.assertEquals(result, array1[1]);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test103(array3, 2);</span>
<span class="line-added">+         Asserts.assertEquals(result, array1[2]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field</span>
<span class="line-added">+     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">+     public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {</span>
<span class="line-added">+         array[0] = v;</span>
<span class="line-added">+         array[1] = array[0];</span>
<span class="line-added">+         array[2] = o;</span>
<span class="line-added">+         return array[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test104_verifier(boolean warmup) {</span>
<span class="line-added">+         MyObject4 v = new MyObject4();</span>
<span class="line-added">+         MyObject3 o = new MyObject3();</span>
<span class="line-added">+         NoValueImplementors1[] array1 = new NoValueImplementors1[3];</span>
<span class="line-added">+         MyObject3[] array2 = new MyObject3[3];</span>
<span class="line-added">+         MyObject4[] array3 = new MyObject4[3];</span>
<span class="line-added">+         NoValueImplementors1 result = test104(array1, v, o, 0);</span>
<span class="line-added">+         Asserts.assertEquals(array1[0], v);</span>
<span class="line-added">+         Asserts.assertEquals(array1[1], v);</span>
<span class="line-added">+         Asserts.assertEquals(array1[2], o);</span>
<span class="line-added">+         Asserts.assertEquals(result, v);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test104(array2, o, o, 1);</span>
<span class="line-added">+         Asserts.assertEquals(array2[0], o);</span>
<span class="line-added">+         Asserts.assertEquals(array2[1], o);</span>
<span class="line-added">+         Asserts.assertEquals(array2[2], o);</span>
<span class="line-added">+         Asserts.assertEquals(result, o);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test104(array3, v, null, 1);</span>
<span class="line-added">+         Asserts.assertEquals(array3[0], v);</span>
<span class="line-added">+         Asserts.assertEquals(array3[1], v);</span>
<span class="line-added">+         Asserts.assertEquals(array3[2], null);</span>
<span class="line-added">+         Asserts.assertEquals(result, v);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // An abstract class with a single, non-value implementor</span>
<span class="line-added">+     abstract class NoValueImplementors2 {</span>
<span class="line-added">+ </span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class MyObject5 extends NoValueImplementors2 {</span>
<span class="line-added">+ </span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor</span>
<span class="line-added">+     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">+     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {</span>
<span class="line-added">+         return array[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test105_verifier(boolean warmup) {</span>
<span class="line-added">+         NoValueImplementors2[] array1 = new NoValueImplementors2[3];</span>
<span class="line-added">+         MyObject5[] array2 = new MyObject5[3];</span>
<span class="line-added">+         NoValueImplementors2 result = test105(array1, 0);</span>
<span class="line-added">+         Asserts.assertEquals(result, array1[0]);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test105(array2, 1);</span>
<span class="line-added">+         Asserts.assertEquals(result, array1[1]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor</span>
<span class="line-added">+     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">+     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {</span>
<span class="line-added">+         array[0] = v;</span>
<span class="line-added">+         array[1] = array[0];</span>
<span class="line-added">+         array[2] = o;</span>
<span class="line-added">+         return array[i];</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @DontCompile</span>
<span class="line-added">+     public void test106_verifier(boolean warmup) {</span>
<span class="line-added">+         MyObject5 v = new MyObject5();</span>
<span class="line-added">+         NoValueImplementors2[] array1 = new NoValueImplementors2[3];</span>
<span class="line-added">+         MyObject5[] array2 = new MyObject5[3];</span>
<span class="line-added">+         NoValueImplementors2 result = test106(array1, v, null, 0);</span>
<span class="line-added">+         Asserts.assertEquals(array1[0], v);</span>
<span class="line-added">+         Asserts.assertEquals(array1[1], v);</span>
<span class="line-added">+         Asserts.assertEquals(array1[2], null);</span>
<span class="line-added">+         Asserts.assertEquals(result, v);</span>
<span class="line-added">+ </span>
<span class="line-added">+         result = test106(array2, v, v, 1);</span>
<span class="line-added">+         Asserts.assertEquals(array2[0], v);</span>
<span class="line-added">+         Asserts.assertEquals(array2[1], v);</span>
<span class="line-added">+         Asserts.assertEquals(array2[2], v);</span>
<span class="line-added">+         Asserts.assertEquals(result, v);</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="TestIntrinsics.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
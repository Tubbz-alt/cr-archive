diff a/src/hotspot/share/c1/c1_GraphBuilder.cpp b/src/hotspot/share/c1/c1_GraphBuilder.cpp
--- a/src/hotspot/share/c1/c1_GraphBuilder.cpp
+++ b/src/hotspot/share/c1/c1_GraphBuilder.cpp
@@ -1290,15 +1290,12 @@
       ciKlass* right_klass = y->as_loaded_klass_or_null();
 
       if (left_klass == NULL || right_klass == NULL) {
         // The klass is still unloaded, or came from a Phi node. Go slow case;
         subst_check = true;
-      } else if (left_klass->is_java_lang_Object() || left_klass->is_interface() ||
-                 right_klass->is_java_lang_Object() || right_klass->is_interface()) {
-        // Either operand may be a value object, but we're not sure.  Go slow case;
-        subst_check = true;
-      } else if (left_klass->is_valuetype() || right_klass->is_valuetype()) {
+      } else if (left_klass->can_be_value_klass() || right_klass->can_be_value_klass()) {
+        // Either operand may be a value object, but we're not sure. Go slow case;
         subst_check = true;
       } else {
         // No need to do substitutability check
       }
     }
diff a/src/hotspot/share/c1/c1_Instruction.cpp b/src/hotspot/share/c1/c1_Instruction.cpp
--- a/src/hotspot/share/c1/c1_Instruction.cpp
+++ b/src/hotspot/share/c1/c1_Instruction.cpp
@@ -142,23 +142,20 @@
 bool Instruction::maybe_flattened_array() {
   if (ValueArrayFlatten) {
     ciType* type = declared_type();
     if (type != NULL) {
       if (type->is_obj_array_klass()) {
-        // Check for array covariance. One of the following declared types may be a flattened array:
+        // Due to array covariance, the runtime type might be a flattened array.
         ciKlass* element_klass = type->as_obj_array_klass()->element_klass();
-        if (!element_klass->is_loaded() ||
-            element_klass->is_java_lang_Object() ||                                                // (ValueType[] <: Object[])
-            element_klass->is_interface() ||                                                       // (ValueType[] <: <any interface>[])
-            (element_klass->is_valuetype() && element_klass->as_value_klass()->flatten_array())) { // (ValueType[] <: ValueType?[])
+        if (element_klass->can_be_value_klass() && (!element_klass->is_valuetype() || element_klass->as_value_klass()->flatten_array())) {
           // We will add a runtime check for flat-ness.
           return true;
         }
       } else if (type->is_value_array_klass()) {
         ciKlass* element_klass = type->as_value_array_klass()->element_klass();
         if (!element_klass->is_loaded() ||
-            (element_klass->is_valuetype() && element_klass->as_value_klass()->flatten_array())) { // (ValueType[] <: ValueType?[])
+            (element_klass->is_valuetype() && element_klass->as_value_klass()->flatten_array())) {
           // We will add a runtime check for flat-ness.
           return true;
         }
       } else if (type->is_klass() && type->as_klass()->is_java_lang_Object()) {
         // This can happen as a parameter to System.arraycopy()
@@ -168,34 +165,29 @@
       // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
       // flattened array, so we should do a runtime check.
       return true;
     }
   }
-
   return false;
 }
 
 bool Instruction::maybe_null_free_array() {
   ciType* type = declared_type();
   if (type != NULL) {
     if (type->is_obj_array_klass()) {
-      // Check for array covariance. One of the following declared types may be a null-free array:
+      // Due to array covariance, the runtime type might be a null-free array.
       ciKlass* element_klass = type->as_obj_array_klass()->element_klass();
-      if (!element_klass->is_loaded() ||
-          element_klass->is_java_lang_Object() ||   // (ValueType[] <: Object[])
-          element_klass->is_interface() ||          // (ValueType[] <: <any interface>[])
-          element_klass->is_valuetype()) {          // (ValueType[] <: ValueType?[])
-          // We will add a runtime check for flat-ness.
+      if (element_klass->can_be_value_klass()) {
+          // We will add a runtime check for null-free-ness.
           return true;
       }
     }
   } else {
     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
-    // flattened array, so we should do a runtime check.
+    // null-free array, so we should do a runtime check.
     return true;
   }
-
   return false;
 }
 
 #ifndef PRODUCT
 void Instruction::check_state(ValueStack* state) {
diff a/src/hotspot/share/c1/c1_LIRGenerator.cpp b/src/hotspot/share/c1/c1_LIRGenerator.cpp
--- a/src/hotspot/share/c1/c1_LIRGenerator.cpp
+++ b/src/hotspot/share/c1/c1_LIRGenerator.cpp
@@ -1691,14 +1691,11 @@
 bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
   if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {
     ciType* type = x->value()->declared_type();
     if (type != NULL && type->is_klass()) {
       ciKlass* klass = type->as_klass();
-      if (klass->is_loaded() &&
-          !(klass->is_valuetype() && klass->as_value_klass()->flatten_array()) &&
-          !klass->is_java_lang_Object() &&
-          !klass->is_interface()) {
+      if (!klass->can_be_value_klass() || (klass->is_valuetype() && !klass->as_value_klass()->flatten_array())) {
         // This is known to be a non-flattenable object. If the array is flattened,
         // it will be caught by the code generated by array_store_check().
         return false;
       }
     }
diff a/src/hotspot/share/ci/ciInstanceKlass.hpp b/src/hotspot/share/ci/ciInstanceKlass.hpp
--- a/src/hotspot/share/ci/ciInstanceKlass.hpp
+++ b/src/hotspot/share/ci/ciInstanceKlass.hpp
@@ -257,10 +257,14 @@
     assert(is_loaded(), "must be loaded");
     ciInstanceKlass* impl = implementor();
     return (impl != this ? impl : NULL);
   }
 
+  virtual bool can_be_value_klass(bool is_exact = false) {
+    return EnableValhalla && (!is_loaded() || is_valuetype() || ((is_java_lang_Object() || is_interface() || (is_abstract() && !has_nonstatic_fields())) && !is_exact));
+  }
+
   // Is the defining class loader of this class the default loader?
   bool uses_default_loader() const;
 
   bool is_java_lang_Object() const;
 
diff a/src/hotspot/share/ci/ciKlass.hpp b/src/hotspot/share/ci/ciKlass.hpp
--- a/src/hotspot/share/ci/ciKlass.hpp
+++ b/src/hotspot/share/ci/ciKlass.hpp
@@ -108,11 +108,11 @@
   virtual bool is_leaf_type() {
     return false;
   }
 
   virtual bool can_be_value_klass(bool is_exact = false) {
-    return EnableValhalla && (!is_loaded() || is_valuetype() || ((is_java_lang_Object() || is_interface()) && !is_exact));
+    return false;
   }
 
   virtual bool can_be_value_array_klass() {
     return EnableValhalla && is_java_lang_Object();
   }
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -3820,11 +3820,11 @@
     assert(klass != NULL, "klass should not be NULL");
     bool    xklass = inst_klass->klass_is_exact();
     bool can_be_flattened = false;
     if (ValueArrayFlatten && klass->is_obj_array_klass()) {
       ciKlass* elem = klass->as_obj_array_klass()->element_klass();
-      can_be_flattened = elem->is_java_lang_Object() || elem->is_interface() || (elem->is_valuetype() && !klass->as_array_klass()->storage_properties().is_null_free());
+      can_be_flattened = elem->can_be_value_klass() && (!elem->is_valuetype() || elem->as_value_klass()->flatten_array());
     }
     if (xklass || (klass->is_array_klass() && !can_be_flattened)) {
       jint lhelper = klass->layout_helper();
       if (lhelper != Klass::_lh_neutral_value) {
         constant_value = lhelper;
diff a/src/hotspot/share/opto/parse2.cpp b/src/hotspot/share/opto/parse2.cpp
--- a/src/hotspot/share/opto/parse2.cpp
+++ b/src/hotspot/share/opto/parse2.cpp
@@ -89,13 +89,12 @@
     return;
   } else if (elemptr != NULL && elemptr->is_valuetypeptr() && !elemptr->maybe_null()) {
     // Load from non-flattened but flattenable value type array (elements can never be null)
     bt = T_VALUETYPE;
   } else if (!ary_t->is_not_flat()) {
-    assert(is_reference_type(bt), "");
     // Cannot statically determine if array is flattened, emit runtime check
-    assert(ValueArrayFlatten && elemptr->can_be_value_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&
+    assert(ValueArrayFlatten && is_reference_type(bt) && elemptr->can_be_value_type() && !ary_t->klass_is_exact() && !ary_t->is_not_null_free() &&
            (!elemptr->is_valuetypeptr() || elemptr->value_klass()->flatten_array()), "array can't be flattened");
     Node* ctl = control();
     IdealKit ideal(this);
     IdealVariable res(ideal);
     ideal.declarations_done();
@@ -182,16 +181,14 @@
         // fully initialized
         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
         alloc_obj->set_req(0, control());
         alloc_obj = _gvn.transform(alloc_obj);
 
-        const Type* unknown_value = TypeInstPtr::BOTTOM->cast_to_flat_array();
-
+        const Type* unknown_value = elemptr->is_instptr()->cast_to_flat_array();
         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 
         ideal.sync_kit(this);
-
         ideal.set(res, alloc_obj);
       }
     } ideal.else_(); {
       // non-flattened
       sync_kit(ideal);
diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -3480,20 +3480,25 @@
       }
     }
     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass->flatten_array());
   } else if (klass->is_obj_array_klass()) {
     // Element is an object or value array. Recursively call ourself.
-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), false, try_for_exact);
+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), /* klass_change= */ false, try_for_exact);
     bool null_free = klass->is_loaded() && klass->as_array_klass()->storage_properties().is_null_free();
     if (null_free) {
       assert(etype->is_valuetypeptr(), "must be a valuetypeptr");
       etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();
     }
     // [V? has a subtype: [V. So even though V is final, [V? is not exact.
     bool xk = etype->klass_is_exact() && (!etype->is_valuetypeptr() || null_free);
-    bool not_null_free = !etype->can_be_value_type() || xk;
-    bool not_flat = !ValueArrayFlatten || not_null_free || (etype->is_valuetypeptr() && !etype->value_klass()->flatten_array());
+
+    // Use exact element type to determine null-free/flattened properties
+    const TypeOopPtr* exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), /* klass_change= */ true, try_for_exact);
+    bool not_null_free = !exact_etype->can_be_value_type();
+    assert(!(not_null_free && null_free), "inconsistent null-free information");
+    bool not_flat = !ValueArrayFlatten || not_null_free || (exact_etype->is_valuetypeptr() && !exact_etype->value_klass()->flatten_array());
+
     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
     // We used to pass NotNull in here, asserting that the sub-arrays
     // are all not-null.  This is not true in generally, as code can
     // slam NULLs down in the subarrays.
     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyAbstract.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyAbstract.java
--- /dev/null
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyAbstract.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package compiler.valhalla.valuetypes;
+
+public abstract class MyAbstract implements MyInterface {
+
+}
+
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue1.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue1.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue1.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -21,11 +21,11 @@
  * questions.
  */
 
 package compiler.valhalla.valuetypes;
 
-public final inline class MyValue1 implements MyInterface {
+public final inline class MyValue1 extends MyAbstract {
     static int s;
     static final long sf = ValueTypeTest.rL;
     final int x;
     final long y;
     final short z;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue2.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue2.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue2.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue2.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -55,11 +55,11 @@
         v = MyValue2Inline.setC(v, c);
         return v;
     }
 }
 
-public final inline class MyValue2 implements MyInterface {
+public final inline class MyValue2 extends MyAbstract {
     final int x;
     final byte y;
     final MyValue2Inline v1;
 
     @ForceInline
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue3.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue3.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue3.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue3.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -60,11 +60,11 @@
     }
 }
 
 // Value type definition to stress test return of a value in registers
 // (uses all registers of calling convention on x86_64)
-public final inline class MyValue3 implements MyInterface {
+public final inline class MyValue3 extends MyAbstract {
     final char c;
     final byte bb;
     final short s;
     final int i;
     final long l;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue4.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue4.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue4.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/MyValue4.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -22,11 +22,11 @@
  */
 
 package compiler.valhalla.valuetypes;
 
 // Value type definition with too many fields to return in registers
-final inline class MyValue4 implements MyInterface {
+final inline class MyValue4 extends MyAbstract {
     final MyValue3 v1;
     final MyValue3 v2;
 
     @ForceInline
     public MyValue4(MyValue3 v1, MyValue3 v2) {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -2079,11 +2079,11 @@
                 // Expected
             }
         }
     }
 
-    // Additional correcntess tests to make sure we have the required null checks
+    // Additional correctness tests to make sure we have the required null checks
     @Test()
     public void test88(Object[] array, Integer v) {
         array[0] = v;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
@@ -105,21 +105,21 @@
         return cls.getSuperclass();
     }
 
     public void test3_verifier(boolean warmup) {
         Asserts.assertTrue(test3(Object.class) == null, "test3_1 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == Object.class, "test3_2 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == Object.class, "test3_3 failed");
+        Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == MyAbstract.class, "test3_2 failed");
+        Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == MyAbstract.class, "test3_3 failed");
         Asserts.assertTrue(test3(Class.class) == Object.class, "test3_4 failed");
     }
 
     // Verify that Class::getSuperclass checks with statically known classes are folded
     @Test(failOn = LOADK)
     public boolean test4() {
         boolean check1 = Object.class.getSuperclass() == null;
-        boolean check2 = MyValue1.class.asIndirectType().getSuperclass() == Object.class;
-        boolean check3 = MyValue1.class.asPrimaryType().getSuperclass() == Object.class;
+        boolean check2 = MyValue1.class.asIndirectType().getSuperclass() == MyAbstract.class;
+        boolean check3 = MyValue1.class.asPrimaryType().getSuperclass() == MyAbstract.class;
         boolean check4 = Class.class.getSuperclass() == Object.class;
         return check1 && check2 && check3 && check4;
     }
 
     public void test4_verifier(boolean warmup) {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -434,14 +434,14 @@
         MyValue1 def = MyValue1.createDefaultDontInline();
         long result = test12(vt, vt);
         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
     }
 
-    class MyObject implements MyInterface {
+    class MyObject1 implements MyInterface {
         public int x;
 
-        public MyObject(int x) {
+        public MyObject1(int x) {
             this.x = x;
         }
 
         @ForceInline
         public long hash() {
@@ -452,11 +452,11 @@
     // Test merging value types and interfaces
     @Test()
     public MyInterface test13(int state) {
         MyInterface res = null;
         if (state == 0) {
-            res = new MyObject(rI);
+            res = new MyObject1(rI);
         } else if (state == 1) {
             res = MyValue1.createWithFieldsInline(rI, rL);
         } else if (state == 2) {
             res = MyValue1.createWithFieldsDontInline(rI, rL);
         } else if (state == 3) {
@@ -472,11 +472,11 @@
     @DontCompile
     public void test13_verifier(boolean warmup) {
         objectField1 = valueField1;
         MyInterface result = null;
         result = test13(0);
-        Asserts.assertEQ(((MyObject)result).x, rI);
+        Asserts.assertEQ(((MyObject1)result).x, rI);
         result = test13(1);
         Asserts.assertEQ(((MyValue1)result).hash(), hash());
         result = test13(2);
         Asserts.assertEQ(((MyValue1)result).hash(), hash());
         result = test13(3);
@@ -488,24 +488,24 @@
     }
 
     // Test merging value types and interfaces in loops
     @Test()
     public MyInterface test14(int iters) {
-        MyInterface res = new MyObject(rI);
+        MyInterface res = new MyObject1(rI);
         for (int i = 0; i < iters; ++i) {
-            if (res instanceof MyObject) {
+            if (res instanceof MyObject1) {
                 res = MyValue1.createWithFieldsInline(rI, rL);
             } else {
                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
             }
         }
         return res;
     }
 
     @DontCompile
     public void test14_verifier(boolean warmup) {
-        MyObject result1 = (MyObject)test14(0);
+        MyObject1 result1 = (MyObject1)test14(0);
         Asserts.assertEQ(result1.x, rI);
         int iters = (Math.abs(rI) % 10) + 1;
         MyValue1 result2 = (MyValue1)test14(iters);
         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
         Asserts.assertEQ(result2.hash(), vt.hash());
@@ -642,22 +642,33 @@
         Asserts.assertEQ(result.hash(), hash());
     }
 
     // Test load from (flattened) value type array disguised as interface array
     @Test()
-    public Object test22(MyInterface[] ia, int index) {
+    public Object test22Interface(MyInterface[] ia, int index) {
         return ia[index];
     }
 
     @DontCompile
-    public void test22_verifier(boolean warmup) {
-        MyValue1 result = (MyValue1)test22(testValue1Array, Math.abs(rI) % 3);
+    public void test22Interface_verifier(boolean warmup) {
+        MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);
         Asserts.assertEQ(result.hash(), hash());
     }
 
-    // Test value store to (flattened) value type array disguised as object array
+    // Test load from (flattened) value type array disguised as abstract array
+    @Test()
+    public Object test22Abstract(MyAbstract[] ia, int index) {
+        return ia[index];
+    }
 
+    @DontCompile
+    public void test22Abstract_verifier(boolean warmup) {
+        MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);
+        Asserts.assertEQ(result.hash(), hash());
+    }
+
+    // Test value store to (flattened) value type array disguised as object array
     @ForceInline
     public void test23_inline(Object[] oa, Object o, int index) {
         oa[index] = o;
     }
 
@@ -724,50 +735,98 @@
         }
     }
 
     // Test value store to (flattened) value type array disguised as interface array
     @ForceInline
-    public void test26_inline(MyInterface[] ia, MyInterface i, int index) {
+    public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {
+        ia[index] = i;
+    }
+
+    @Test()
+    public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {
+      test26Interface_inline(ia, vt, index);
+    }
+
+    @DontCompile
+    public void test26Interface_verifier(boolean warmup) {
+        int index = Math.abs(rI) % 3;
+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
+        test26Interface(testValue1Array, vt, index);
+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
+        testValue1Array[index] = testValue1;
+        try {
+            test26Interface(testValue2Array, vt, index);
+            throw new RuntimeException("No ArrayStoreException thrown");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
+    }
+
+    @ForceInline
+    public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {
+        ia[index] = i;
+    }
+
+    @Test()
+    public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {
+        test27Interface_inline(ia, vt, index);
+    }
+
+    @DontCompile
+    public void test27Interface_verifier(boolean warmup) {
+        int index = Math.abs(rI) % 3;
+        try {
+            test27Interface(null, testValue1, index);
+            throw new RuntimeException("No NPE thrown");
+        } catch (NullPointerException e) {
+            // Expected
+        }
+    }
+
+    // Test value store to (flattened) value type array disguised as abstract array
+    @ForceInline
+    public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
         ia[index] = i;
     }
 
     @Test()
-    public void test26(MyInterface[] ia, MyValue1 vt, int index) {
-      test26_inline(ia, vt, index);
+    public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
+      test26Abstract_inline(ia, vt, index);
     }
 
     @DontCompile
-    public void test26_verifier(boolean warmup) {
+    public void test26Abstract_verifier(boolean warmup) {
         int index = Math.abs(rI) % 3;
         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
-        test26(testValue1Array, vt, index);
+        test26Abstract(testValue1Array, vt, index);
         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
         testValue1Array[index] = testValue1;
         try {
-            test26(testValue2Array, vt, index);
+            test26Abstract(testValue2Array, vt, index);
             throw new RuntimeException("No ArrayStoreException thrown");
         } catch (ArrayStoreException e) {
             // Expected
         }
         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
     }
 
     @ForceInline
-    public void test27_inline(MyInterface[] ia, MyInterface i, int index) {
+    public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
         ia[index] = i;
     }
 
     @Test()
-    public void test27(MyInterface[] ia, MyValue1 vt, int index) {
-        test27_inline(ia, vt, index);
+    public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {
+        test27Abstract_inline(ia, vt, index);
     }
 
     @DontCompile
-    public void test27_verifier(boolean warmup) {
+    public void test27Abstract_verifier(boolean warmup) {
         int index = Math.abs(rI) % 3;
         try {
-            test27(null, testValue1, index);
+            test27Abstract(null, testValue1, index);
             throw new RuntimeException("No NPE thrown");
         } catch (NullPointerException e) {
             // Expected
         }
     }
@@ -842,50 +901,98 @@
         }
     }
 
     // Test value store to (flattened) value type array disguised as interface array
     @ForceInline
-    public void test31_inline(MyInterface[] ia, MyInterface i, int index) {
+    public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {
+        ia[index] = i;
+    }
+
+    @Test()
+    public void test31Interface(MyInterface[] ia, MyInterface i, int index) {
+        test31Interface_inline(ia, i, index);
+    }
+
+    @DontCompile
+    public void test31Interface_verifier(boolean warmup) {
+        int index = Math.abs(rI) % 3;
+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
+        test31Interface(testValue1Array, vt1, index);
+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
+        try {
+            test31Interface(testValue1Array, testValue2, index);
+            throw new RuntimeException("No ArrayStoreException thrown");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
+        testValue1Array[index] = testValue1;
+    }
+
+    @ForceInline
+    public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {
+        ia[index] = i;
+    }
+
+    @Test()
+    public void test32Interface(MyInterface[] ia, MyInterface i, int index) {
+        test32Interface_inline(ia, i, index);
+    }
+
+    @DontCompile
+    public void test32Interface_verifier(boolean warmup) {
+        int index = Math.abs(rI) % 3;
+        try {
+            test32Interface(testValue2Array, testValue1, index);
+            throw new RuntimeException("No ArrayStoreException thrown");
+        } catch (ArrayStoreException e) {
+            // Expected
+        }
+    }
+
+    // Test value store to (flattened) value type array disguised as abstract array
+    @ForceInline
+    public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
         ia[index] = i;
     }
 
     @Test()
-    public void test31(MyInterface[] ia, MyInterface i, int index) {
-        test31_inline(ia, i, index);
+    public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {
+        test31Abstract_inline(ia, i, index);
     }
 
     @DontCompile
-    public void test31_verifier(boolean warmup) {
+    public void test31Abstract_verifier(boolean warmup) {
         int index = Math.abs(rI) % 3;
         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
-        test31(testValue1Array, vt1, index);
+        test31Abstract(testValue1Array, vt1, index);
         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
         try {
-            test31(testValue1Array, testValue2, index);
+            test31Abstract(testValue1Array, testValue2, index);
             throw new RuntimeException("No ArrayStoreException thrown");
         } catch (ArrayStoreException e) {
             // Expected
         }
         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
         testValue1Array[index] = testValue1;
     }
 
     @ForceInline
-    public void test32_inline(MyInterface[] ia, MyInterface i, int index) {
+    public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {
         ia[index] = i;
     }
 
     @Test()
-    public void test32(MyInterface[] ia, MyInterface i, int index) {
-        test32_inline(ia, i, index);
+    public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {
+        test32Abstract_inline(ia, i, index);
     }
 
     @DontCompile
-    public void test32_verifier(boolean warmup) {
+    public void test32Abstract_verifier(boolean warmup) {
         int index = Math.abs(rI) % 3;
         try {
-            test32(testValue2Array, testValue1, index);
+            test32Abstract(testValue2Array, testValue1, index);
             throw new RuntimeException("No ArrayStoreException thrown");
         } catch (ArrayStoreException e) {
             // Expected
         }
     }
@@ -1699,22 +1806,38 @@
         throw new RuntimeException("test63 failed: no exception thrown");
     }
 
     // type system test with interface and value type
     @ForceInline
-    public MyInterface test64_helper(MyValue1 vt) {
+    public MyInterface test64Interface_helper(MyValue1 vt) {
+        return vt;
+    }
+
+    @Test()
+    public MyInterface test64Interface(MyValue1 vt) {
+        return test64Interface_helper(vt);
+    }
+
+    @DontCompile
+    public void test64Interface_verifier(boolean warmup) {
+        test64Interface(testValue1);
+    }
+
+    // type system test with abstract and value type
+    @ForceInline
+    public MyAbstract test64Abstract_helper(MyValue1 vt) {
         return vt;
     }
 
     @Test()
-    public MyInterface test64(MyValue1 vt) {
-        return test64_helper(vt);
+    public MyAbstract test64Abstract(MyValue1 vt) {
+        return test64Abstract_helper(vt);
     }
 
     @DontCompile
-    public void test64_verifier(boolean warmup) {
-        test64(testValue1);
+    public void test64Abstract_verifier(boolean warmup) {
+        test64Abstract(testValue1);
     }
 
     // Array store tests
     @Test()
     public void test65(Object[] array, MyValue1 vt) {
@@ -1786,27 +1909,49 @@
         Asserts.assertEQ(result, rI * testValue1Array.length);
     }
 
     // Same as test69 but with an Interface
     @ForceInline
-    public MyInterface test70_sum(MyInterface a, MyInterface b) {
+    public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {
+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;
+        return MyValue1.setX(((MyValue1)a), sum);
+    }
+
+    @Test(failOn = ALLOC + STORE)
+    public int test70Interface(MyValue1[] array) {
+        MyValue1 result = MyValue1.createDefaultInline();
+        for (int i = 0; i < array.length; ++i) {
+            result = (MyValue1)test70Interface_sum(result, array[i]);
+        }
+        return result.x;
+    }
+
+    @DontCompile
+    public void test70Interface_verifier(boolean warmup) {
+        int result = test70Interface(testValue1Array);
+        Asserts.assertEQ(result, rI * testValue1Array.length);
+    }
+
+    // Same as test69 but with an Abstract
+    @ForceInline
+    public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {
         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
         return MyValue1.setX(((MyValue1)a), sum);
     }
 
     @Test(failOn = ALLOC + STORE)
-    public int test70(MyValue1[] array) {
+    public int test70Abstract(MyValue1[] array) {
         MyValue1 result = MyValue1.createDefaultInline();
         for (int i = 0; i < array.length; ++i) {
-            result = (MyValue1)test70_sum(result, array[i]);
+            result = (MyValue1)test70Abstract_sum(result, array[i]);
         }
         return result.x;
     }
 
     @DontCompile
-    public void test70_verifier(boolean warmup) {
-        int result = test70(testValue1Array);
+    public void test70Abstract_verifier(boolean warmup) {
+        int result = test70Abstract(testValue1Array);
         Asserts.assertEQ(result, rI * testValue1Array.length);
     }
 
     // Test that allocated value type is not used in non-dominated path
     public MyValue1 test71_inline(Object obj) {
@@ -2388,6 +2533,328 @@
         if (!warmup) {
             Asserts.assertTrue(test96(null, null));
             Asserts.assertFalse(test96(o1, null));
         }
     }
+
+    // Abstract class tests
+
+    @DontInline
+    public MyAbstract test97_dontinline1(MyAbstract o) {
+        return o;
+    }
+
+    @DontInline
+    public MyValue1 test97_dontinline2(MyAbstract o) {
+        return (MyValue1)o;
+    }
+
+    @ForceInline
+    public MyAbstract test97_inline1(MyAbstract o) {
+        return o;
+    }
+
+    @ForceInline
+    public MyValue1 test97_inline2(MyAbstract o) {
+        return (MyValue1)o;
+    }
+
+    @Test()
+    public MyValue1 test97() {
+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
+        vt = (MyValue1)test97_dontinline1(vt);
+        vt =           test97_dontinline2(vt);
+        vt = (MyValue1)test97_inline1(vt);
+        vt =           test97_inline2(vt);
+        return vt;
+    }
+
+    @DontCompile
+    public void test97_verifier(boolean warmup) {
+        Asserts.assertEQ(test97().hash(), hash());
+    }
+
+    // Test storing/loading value types to/from abstract and value type fields
+    MyAbstract abstractField1 = null;
+    MyAbstract abstractField2 = null;
+    MyAbstract abstractField3 = null;
+    MyAbstract abstractField4 = null;
+    MyAbstract abstractField5 = null;
+    MyAbstract abstractField6 = null;
+
+    @DontInline
+    public MyAbstract readValueField5AsAbstract() {
+        return (MyAbstract)valueField5;
+    }
+
+    @DontInline
+    public MyAbstract readStaticValueField4AsAbstract() {
+        return (MyAbstract)staticValueField4;
+    }
+
+    @Test()
+    public long test98(MyValue1 vt1, MyAbstract vt2) {
+        abstractField1 = vt1;
+        abstractField2 = (MyValue1)vt2;
+        abstractField3 = MyValue1.createWithFieldsInline(rI, rL);
+        abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);
+        abstractField5 = valueField1;
+        abstractField6 = valueField3;
+        valueField1 = (MyValue1)abstractField1;
+        valueField2 = (MyValue1)vt2;
+        valueField3 = (MyValue1)vt2;
+        staticValueField1 = (MyValue1)abstractField1;
+        staticValueField2 = (MyValue1)vt1;
+        // Don't inline these methods because reading NULL will trigger a deoptimization
+        if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {
+            throw new RuntimeException("Should be null");
+        }
+        return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +
+               ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +
+               ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +
+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
+    }
+
+    @DontCompile
+    public void test98_verifier(boolean warmup) {
+        MyValue1 vt = testValue1;
+        MyValue1 def = MyValue1.createDefaultDontInline();
+        long result = test98(vt, vt);
+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
+    }
+
+    class MyObject2 extends MyAbstract {
+        public int x;
+
+        public MyObject2(int x) {
+            this.x = x;
+        }
+
+        @ForceInline
+        public long hash() {
+            return x;
+        }
+    }
+
+    // Test merging value types and abstract classes
+    @Test()
+    public MyAbstract test99(int state) {
+        MyAbstract res = null;
+        if (state == 0) {
+            res = new MyObject2(rI);
+        } else if (state == 1) {
+            res = MyValue1.createWithFieldsInline(rI, rL);
+        } else if (state == 2) {
+            res = MyValue1.createWithFieldsDontInline(rI, rL);
+        } else if (state == 3) {
+            res = (MyValue1)objectField1;
+        } else if (state == 4) {
+            res = valueField1;
+        } else if (state == 5) {
+            res = null;
+        }
+        return res;
+    }
+
+    @DontCompile
+    public void test99_verifier(boolean warmup) {
+        objectField1 = valueField1;
+        MyAbstract result = null;
+        result = test99(0);
+        Asserts.assertEQ(((MyObject2)result).x, rI);
+        result = test99(1);
+        Asserts.assertEQ(((MyValue1)result).hash(), hash());
+        result = test99(2);
+        Asserts.assertEQ(((MyValue1)result).hash(), hash());
+        result = test99(3);
+        Asserts.assertEQ(((MyValue1)result).hash(), hash());
+        result = test99(4);
+        Asserts.assertEQ(((MyValue1)result).hash(), hash());
+        result = test99(5);
+        Asserts.assertEQ(result, null);
+    }
+
+    // Test merging value types and abstract classes in loops
+    @Test()
+    public MyAbstract test100(int iters) {
+        MyAbstract res = new MyObject2(rI);
+        for (int i = 0; i < iters; ++i) {
+            if (res instanceof MyObject2) {
+                res = MyValue1.createWithFieldsInline(rI, rL);
+            } else {
+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
+            }
+        }
+        return res;
+    }
+
+    @DontCompile
+    public void test100_verifier(boolean warmup) {
+        MyObject2 result1 = (MyObject2)test100(0);
+        Asserts.assertEQ(result1.x, rI);
+        int iters = (Math.abs(rI) % 10) + 1;
+        MyValue1 result2 = (MyValue1)test100(iters);
+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
+        Asserts.assertEQ(result2.hash(), vt.hash());
+    }
+
+    // Test value types in abstract class variables that are live at safepoint
+    @Test(failOn = ALLOC + STORE + LOOP)
+    public long test101(MyValue1 arg, boolean deopt) {
+        MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);
+        MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
+        MyAbstract vt3 = arg;
+        MyAbstract vt4 = valueField1;
+        if (deopt) {
+            // uncommon trap
+            WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + "::test101"));
+        }
+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
+    }
+
+    @DontCompile
+    public void test101_verifier(boolean warmup) {
+        long result = test101(valueField1, !warmup);
+        Asserts.assertEQ(result, 4*hash());
+    }
+
+    // Test comparing value types with abstract classes
+    @Test(failOn = LOAD + LOOP)
+    public boolean test102(Object arg) {
+        MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);
+        if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||
+            arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {
+            return true;
+        }
+        return false;
+    }
+
+    @DontCompile
+    public void test102_verifier(boolean warmup) {
+        boolean result = test102(null);
+        Asserts.assertFalse(result);
+    }
+
+    // An abstract class with a non-static field can never be implemented by a value type
+    abstract class NoValueImplementors1 {
+        int field = 42;
+    }
+
+    class MyObject3 extends NoValueImplementors1 {
+
+    }
+
+    class MyObject4 extends NoValueImplementors1 {
+
+    }
+
+    // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field
+    @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {
+        return array[i];
+    }
+
+    @DontCompile
+    public void test103_verifier(boolean warmup) {
+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];
+        MyObject3[] array2 = new MyObject3[3];
+        MyObject4[] array3 = new MyObject4[3];
+        NoValueImplementors1 result = test103(array1, 0);
+        Asserts.assertEquals(result, array1[0]);
+
+        result = test103(array2, 1);
+        Asserts.assertEquals(result, array1[1]);
+
+        result = test103(array3, 2);
+        Asserts.assertEquals(result, array1[2]);
+    }
+
+    // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field
+    @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {
+        array[0] = v;
+        array[1] = array[0];
+        array[2] = o;
+        return array[i];
+    }
+
+    @DontCompile
+    public void test104_verifier(boolean warmup) {
+        MyObject4 v = new MyObject4();
+        MyObject3 o = new MyObject3();
+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];
+        MyObject3[] array2 = new MyObject3[3];
+        MyObject4[] array3 = new MyObject4[3];
+        NoValueImplementors1 result = test104(array1, v, o, 0);
+        Asserts.assertEquals(array1[0], v);
+        Asserts.assertEquals(array1[1], v);
+        Asserts.assertEquals(array1[2], o);
+        Asserts.assertEquals(result, v);
+
+        result = test104(array2, o, o, 1);
+        Asserts.assertEquals(array2[0], o);
+        Asserts.assertEquals(array2[1], o);
+        Asserts.assertEquals(array2[2], o);
+        Asserts.assertEquals(result, o);
+
+        result = test104(array3, v, null, 1);
+        Asserts.assertEquals(array3[0], v);
+        Asserts.assertEquals(array3[1], v);
+        Asserts.assertEquals(array3[2], null);
+        Asserts.assertEquals(result, v);
+    }
+
+    // An abstract class with a single, non-value implementor
+    abstract class NoValueImplementors2 {
+
+    }
+
+    class MyObject5 extends NoValueImplementors2 {
+
+    }
+
+    // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor
+    @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {
+        return array[i];
+    }
+
+    @DontCompile
+    public void test105_verifier(boolean warmup) {
+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];
+        MyObject5[] array2 = new MyObject5[3];
+        NoValueImplementors2 result = test105(array1, 0);
+        Asserts.assertEquals(result, array1[0]);
+
+        result = test105(array2, 1);
+        Asserts.assertEquals(result, array1[1]);
+    }
+
+    // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor
+    @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {
+        array[0] = v;
+        array[1] = array[0];
+        array[2] = o;
+        return array[i];
+    }
+
+    @DontCompile
+    public void test106_verifier(boolean warmup) {
+        MyObject5 v = new MyObject5();
+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];
+        MyObject5[] array2 = new MyObject5[3];
+        NoValueImplementors2 result = test106(array1, v, null, 0);
+        Asserts.assertEquals(array1[0], v);
+        Asserts.assertEquals(array1[1], v);
+        Asserts.assertEquals(array1[2], null);
+        Asserts.assertEquals(result, v);
+
+        result = test106(array2, v, v, 1);
+        Asserts.assertEquals(array2[0], v);
+        Asserts.assertEquals(array2[1], v);
+        Asserts.assertEquals(array2[2], v);
+        Asserts.assertEquals(result, v);
+    }
 }
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
@@ -188,11 +188,11 @@
     }
 
     @Warmup(10000)
     @Test(valid = ArrayLoadStoreProfileOn, match = { CALL, CLASS_CHECK_TRAP, NULL_CHECK_TRAP, RANGE_CHECK_TRAP }, matchCount = { 3, 1, 1, 1 })
     @Test(valid = TypeProfileOn, match = { CALL, CLASS_CHECK_TRAP, NULL_CHECK_TRAP, RANGE_CHECK_TRAP }, matchCount = { 3, 1, 1, 1 })
-    @Test(match = { CALL, RANGE_CHECK_TRAP, NULL_CHECK_TRAP }, matchCount = { 3, 1, 1 })
+    @Test(match = { CALL, RANGE_CHECK_TRAP, NULL_CHECK_TRAP }, matchCount = { 5, 1, 1 })
     public Object test6(Number[] array) {
         Number v = array[0];
         test6_helper(array);
         return v;
     }
@@ -216,14 +216,14 @@
         if (arg instanceof Long) {
             test7_no_inline();
         }
     }
 
-
     @Warmup(10000)
     @Test(valid = ArrayLoadStoreProfileOn, match = { CALL, CLASS_CHECK_TRAP, NULL_CHECK_TRAP, RANGE_CHECK_TRAP }, matchCount = { 4, 1, 2, 1 })
-    @Test(match = { CALL, RANGE_CHECK_TRAP, NULL_CHECK_TRAP }, matchCount = { 4, 1, 2 })
+    @Test(valid = TypeProfileOn, match = { CALL, CLASS_CHECK_TRAP, NULL_CHECK_TRAP, RANGE_CHECK_TRAP }, matchCount = { 4, 1, 2, 1 })
+    @Test(match = { CALL, RANGE_CHECK_TRAP, NULL_CHECK_TRAP }, matchCount = { 6, 1, 2 })
     public Object test7(Number[] array) {
         Number v = array[0];
         test7_helper(v);
         return v;
     }
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNewAcmp.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNewAcmp.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNewAcmp.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNewAcmp.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -50,11 +50,16 @@
 
 interface MyInterface {
 
 }
 
-inline class MyValue1 implements MyInterface {
+abstract class MyAbstract implements MyInterface {
+
+
+}
+
+inline class MyValue1 extends MyAbstract {
     final int x;
 
     MyValue1(int x) {
         this.x = x;
     }
@@ -66,11 +71,11 @@
     static MyValue1 setX(MyValue1 v, int x) {
         return new MyValue1(x);
     }
 }
 
-inline class MyValue2 implements MyInterface {
+inline class MyValue2 extends MyAbstract {
     final int x;
 
     MyValue2(int x) {
         this.x = x;
     }
@@ -82,11 +87,11 @@
     static MyValue2 setX(MyValue2 v, int x) {
         return new MyValue2(x);
     }
 }
 
-class MyObject implements MyInterface {
+class MyObject extends MyAbstract {
     int x;
 }
 
 // Mark test methods that return false if the argument is null
 @Retention(RetentionPolicy.RUNTIME)
@@ -378,10 +383,37 @@
     @FalseIfNull
     public boolean testEq21_6(MyInterface u1, MyInterface u2) {
         return getNotNull(u1) == getNotNull(u2); // new acmp without null check
     }
 
+    public boolean testEq21_7(MyAbstract u1, MyAbstract u2) {
+        return get(u1) == u2; // new acmp
+    }
+
+    public boolean testEq21_8(MyAbstract u1, MyAbstract u2) {
+        return u1 == get(u2); // new acmp
+    }
+
+    public boolean testEq21_9(MyAbstract u1, MyAbstract u2) {
+        return get(u1) == get(u2); // new acmp
+    }
+
+    @FalseIfNull
+    public boolean testEq21_10(MyAbstract u1, MyAbstract u2) {
+        return getNotNull(u1) == u2; // new acmp without null check
+    }
+
+    @FalseIfNull
+    public boolean testEq21_11(MyAbstract u1, MyAbstract u2) {
+        return u1 == getNotNull(u2); // new acmp without null check
+    }
+
+    @FalseIfNull
+    public boolean testEq21_12(MyAbstract u1, MyAbstract u2) {
+        return getNotNull(u1) == getNotNull(u2); // new acmp without null check
+    }
+
     public boolean testEq22_1(MyValue1 v, MyInterface u) {
         return get(v) == u; // only true if both null
     }
 
     public boolean testEq22_2(MyValue1 v, MyInterface u) {
@@ -390,10 +422,22 @@
 
     public boolean testEq22_3(MyValue1 v, MyInterface u) {
         return get(v) == get(u); // only true if both null
     }
 
+    public boolean testEq22_4(MyValue1 v, MyAbstract u) {
+        return get(v) == u; // only true if both null
+    }
+
+    public boolean testEq22_5(MyValue1 v, MyAbstract u) {
+        return (Object)v == get(u); // only true if both null
+    }
+
+    public boolean testEq22_6(MyValue1 v, MyAbstract u) {
+        return get(v) == get(u); // only true if both null
+    }
+
     public boolean testEq23_1(MyInterface u, MyValue1 v) {
         return get(u) == (Object)v; // only true if both null
     }
 
     public boolean testEq23_2(MyInterface u, MyValue1 v) {
@@ -402,10 +446,22 @@
 
     public boolean testEq23_3(MyInterface u, MyValue1 v) {
         return get(u) == get(v); // only true if both null
     }
 
+    public boolean testEq23_4(MyAbstract u, MyValue1 v) {
+        return get(u) == (Object)v; // only true if both null
+    }
+
+    public boolean testEq23_5(MyAbstract u, MyValue1 v) {
+        return u == get(v); // only true if both null
+    }
+
+    public boolean testEq23_6(MyAbstract u, MyValue1 v) {
+        return get(u) == get(v); // only true if both null
+    }
+
     public boolean testEq24_1(MyValue1 v, MyInterface u) {
         return getNotNull(v) == u; // false
     }
 
     public boolean testEq24_2(MyValue1 v, MyInterface u) {
@@ -414,10 +470,22 @@
 
     public boolean testEq24_3(MyValue1 v, MyInterface u) {
         return getNotNull(v) == getNotNull(u); // false
     }
 
+    public boolean testEq24_4(MyValue1 v, MyAbstract u) {
+        return getNotNull(v) == u; // false
+    }
+
+    public boolean testEq24_5(MyValue1 v, MyAbstract u) {
+        return (Object)v == getNotNull(u); // false
+    }
+
+    public boolean testEq24_6(MyValue1 v, MyAbstract u) {
+        return getNotNull(v) == getNotNull(u); // false
+    }
+
     public boolean testEq25_1(MyInterface u, MyValue1 v) {
         return getNotNull(u) == (Object)v; // false
     }
 
     public boolean testEq25_2(MyInterface u, MyValue1 v) {
@@ -426,10 +494,22 @@
 
     public boolean testEq25_3(MyInterface u, MyValue1 v) {
         return getNotNull(u) == getNotNull(v); // false
     }
 
+    public boolean testEq25_4(MyAbstract u, MyValue1 v) {
+        return getNotNull(u) == (Object)v; // false
+    }
+
+    public boolean testEq25_5(MyAbstract u, MyValue1 v) {
+        return u == getNotNull(v); // false
+    }
+
+    public boolean testEq25_6(MyAbstract u, MyValue1 v) {
+        return getNotNull(u) == getNotNull(v); // false
+    }
+
     public boolean testEq26_1(MyInterface u, MyObject o) {
         return get(u) == o; // old acmp
     }
 
     public boolean testEq26_2(MyInterface u, MyObject o) {
@@ -438,10 +518,22 @@
 
     public boolean testEq26_3(MyInterface u, MyObject o) {
         return get(u) == get(o); // old acmp
     }
 
+    public boolean testEq26_4(MyAbstract u, MyObject o) {
+        return get(u) == o; // old acmp
+    }
+
+    public boolean testEq26_5(MyAbstract u, MyObject o) {
+        return u == get(o); // old acmp
+    }
+
+    public boolean testEq26_6(MyAbstract u, MyObject o) {
+        return get(u) == get(o); // old acmp
+    }
+
     public boolean testEq27_1(MyObject o, MyInterface u) {
         return get(o) == u; // old acmp
     }
 
     public boolean testEq27_2(MyObject o, MyInterface u) {
@@ -450,10 +542,22 @@
 
     public boolean testEq27_3(MyObject o, MyInterface u) {
         return get(o) == get(u); // old acmp
     }
 
+    public boolean testEq27_4(MyObject o, MyAbstract u) {
+        return get(o) == u; // old acmp
+    }
+
+    public boolean testEq27_5(MyObject o, MyAbstract u) {
+        return o == get(u); // old acmp
+    }
+
+    public boolean testEq27_6(MyObject o, MyAbstract u) {
+        return get(o) == get(u); // old acmp
+    }
+
     public boolean testEq28_1(MyInterface[] a, MyInterface u) {
         return get(a) == u; // old acmp
     }
 
     public boolean testEq28_2(MyInterface[] a, MyInterface u) {
@@ -462,10 +566,22 @@
 
     public boolean testEq28_3(MyInterface[] a, MyInterface u) {
         return get(a) == get(u); // old acmp
     }
 
+    public boolean testEq28_4(MyAbstract[] a, MyAbstract u) {
+        return get(a) == u; // old acmp
+    }
+
+    public boolean testEq28_5(MyAbstract[] a, MyAbstract u) {
+        return a == get(u); // old acmp
+    }
+
+    public boolean testEq28_6(MyAbstract[] a, MyAbstract u) {
+        return get(a) == get(u); // old acmp
+    }
+
     public boolean testEq29_1(MyInterface u, MyInterface[] a) {
         return get(u) == a; // old acmp
     }
 
     public boolean testEq29_2(MyInterface u, MyInterface[] a) {
@@ -474,10 +590,22 @@
 
     public boolean testEq29_3(MyInterface u, MyInterface[] a) {
         return get(u) == get(a); // old acmp
     }
 
+    public boolean testEq29_4(MyAbstract u, MyAbstract[] a) {
+        return get(u) == a; // old acmp
+    }
+
+    public boolean testEq29_5(MyAbstract u, MyAbstract[] a) {
+        return u == get(a); // old acmp
+    }
+
+    public boolean testEq29_6(MyAbstract u, MyAbstract[] a) {
+        return get(u) == get(a); // old acmp
+    }
+
     public boolean testEq30_1(MyInterface[] a, MyValue1 v) {
         return get(a) == (Object)v; // only true if both null
     }
 
     public boolean testEq30_2(MyInterface[] a, MyValue1 v) {
@@ -486,10 +614,22 @@
 
     public boolean testEq30_3(MyInterface[] a, MyValue1 v) {
         return get(a) == get(v); // only true if both null
     }
 
+    public boolean testEq30_4(MyAbstract[] a, MyValue1 v) {
+        return get(a) == (Object)v; // only true if both null
+    }
+
+    public boolean testEq30_5(MyAbstract[] a, MyValue1 v) {
+        return a == get(v); // only true if both null
+    }
+
+    public boolean testEq30_6(MyAbstract[] a, MyValue1 v) {
+        return get(a) == get(v); // only true if both null
+    }
+
     public boolean testEq31_1(MyValue1 v, MyInterface[] a) {
         return get(v) == a; // only true if both null
     }
 
     public boolean testEq31_2(MyValue1 v, MyInterface[] a) {
@@ -498,10 +638,22 @@
 
     public boolean testEq31_3(MyValue1 v, MyInterface[] a) {
         return get(v) == get(a); // only true if both null
     }
 
+    public boolean testEq31_4(MyValue1 v, MyAbstract[] a) {
+        return get(v) == a; // only true if both null
+    }
+
+    public boolean testEq31_5(MyValue1 v, MyAbstract[] a) {
+        return (Object)v == get(a); // only true if both null
+    }
+
+    public boolean testEq31_6(MyValue1 v, MyAbstract[] a) {
+        return get(v) == get(a); // only true if both null
+    }
+
     public boolean testEq32_1(MyInterface[] a, MyValue1 v) {
         return getNotNull(a) == (Object)v; // false
     }
 
     public boolean testEq32_2(MyInterface[] a, MyValue1 v) {
@@ -510,10 +662,22 @@
 
     public boolean testEq32_3(MyInterface[] a, MyValue1 v) {
         return getNotNull(a) == getNotNull(v); // false
     }
 
+    public boolean testEq32_4(MyAbstract[] a, MyValue1 v) {
+        return getNotNull(a) == (Object)v; // false
+    }
+
+    public boolean testEq32_5(MyAbstract[] a, MyValue1 v) {
+        return a == getNotNull(v); // false
+    }
+
+    public boolean testEq32_6(MyAbstract[] a, MyValue1 v) {
+        return getNotNull(a) == getNotNull(v); // false
+    }
+
     public boolean testEq33_1(MyValue1 v, MyInterface[] a) {
         return getNotNull(v) == a; // false
     }
 
     public boolean testEq33_2(MyValue1 v, MyInterface[] a) {
@@ -522,10 +686,22 @@
 
     public boolean testEq33_3(MyValue1 v, MyInterface[] a) {
         return getNotNull(v) == getNotNull(a); // false
     }
 
+    public boolean testEq33_4(MyValue1 v, MyAbstract[] a) {
+        return getNotNull(v) == a; // false
+    }
+
+    public boolean testEq33_5(MyValue1 v, MyAbstract[] a) {
+        return (Object)v == getNotNull(a); // false
+    }
+
+    public boolean testEq33_6(MyValue1 v, MyAbstract[] a) {
+        return getNotNull(v) == getNotNull(a); // false
+    }
+
 
     // Null tests
 
     public boolean testNull01_1(MyValue1 v) {
         return (Object)v == null; // old acmp
@@ -637,10 +813,26 @@
 
     public boolean testNull07_4(MyInterface u) {
         return get(u) == get((Object)null); // old acmp
     }
 
+    public boolean testNull07_5(MyAbstract u) {
+        return u == null; // old acmp
+    }
+
+    public boolean testNull07_6(MyAbstract u) {
+        return get(u) == null; // old acmp
+    }
+
+    public boolean testNull07_7(MyAbstract u) {
+        return u == get((Object)null); // old acmp
+    }
+
+    public boolean testNull07_8(MyAbstract u) {
+        return get(u) == get((Object)null); // old acmp
+    }
+
     public boolean testNull08_1(MyInterface u) {
         return null == u; // old acmp
     }
 
     public boolean testNull08_2(MyInterface u) {
@@ -653,10 +845,26 @@
 
     public boolean testNull08_4(MyInterface u) {
         return get((Object)null) == get(u); // old acmp
     }
 
+    public boolean testNull08_5(MyAbstract u) {
+        return null == u; // old acmp
+    }
+
+    public boolean testNull08_6(MyAbstract u) {
+        return get((Object)null) == u; // old acmp
+    }
+
+    public boolean testNull08_7(MyAbstract u) {
+        return null == get(u); // old acmp
+    }
+
+    public boolean testNull08_8(MyAbstract u) {
+        return get((Object)null) == get(u); // old acmp
+    }
+
     // Same tests as above but negated
 
     public boolean testNotEq01_1(Object u1, Object u2) {
         return get(u1) != u2; // new acmp
     }
@@ -937,10 +1145,37 @@
     @TrueIfNull
     public boolean testNotEq21_6(MyInterface u1, MyInterface u2) {
         return getNotNull(u1) != getNotNull(u2); // new acmp without null check
     }
 
+    public boolean testNotEq21_7(MyAbstract u1, MyAbstract u2) {
+        return get(u1) != u2; // new acmp
+    }
+
+    public boolean testNotEq21_8(MyAbstract u1, MyAbstract u2) {
+        return u1 != get(u2); // new acmp
+    }
+
+    public boolean testNotEq21_9(MyAbstract u1, MyAbstract u2) {
+        return get(u1) != get(u2); // new acmp
+    }
+
+    @TrueIfNull
+    public boolean testNotEq21_10(MyAbstract u1, MyAbstract u2) {
+        return getNotNull(u1) != u2; // new acmp without null check
+    }
+
+    @TrueIfNull
+    public boolean testNotEq21_11(MyAbstract u1, MyAbstract u2) {
+        return u1 != getNotNull(u2); // new acmp without null check
+    }
+
+    @TrueIfNull
+    public boolean testNotEq21_12(MyAbstract u1, MyAbstract u2) {
+        return getNotNull(u1) != getNotNull(u2); // new acmp without null check
+    }
+
     public boolean testNotEq22_1(MyValue1 v, MyInterface u) {
         return get(v) != u; // only false if both null
     }
 
     public boolean testNotEq22_2(MyValue1 v, MyInterface u) {
@@ -949,10 +1184,22 @@
 
     public boolean testNotEq22_3(MyValue1 v, MyInterface u) {
         return get(v) != get(u); // only false if both null
     }
 
+    public boolean testNotEq22_4(MyValue1 v, MyAbstract u) {
+        return get(v) != u; // only false if both null
+    }
+
+    public boolean testNotEq22_5(MyValue1 v, MyAbstract u) {
+        return (Object)v != get(u); // only false if both null
+    }
+
+    public boolean testNotEq22_6(MyValue1 v, MyAbstract u) {
+        return get(v) != get(u); // only false if both null
+    }
+
     public boolean testNotEq23_1(MyInterface u, MyValue1 v) {
         return get(u) != (Object)v; // only false if both null
     }
 
     public boolean testNotEq23_2(MyInterface u, MyValue1 v) {
@@ -961,10 +1208,22 @@
 
     public boolean testNotEq23_3(MyInterface u, MyValue1 v) {
         return get(u) != get(v); // only false if both null
     }
 
+    public boolean testNotEq23_4(MyAbstract u, MyValue1 v) {
+        return get(u) != (Object)v; // only false if both null
+    }
+
+    public boolean testNotEq23_5(MyAbstract u, MyValue1 v) {
+        return u != get(v); // only false if both null
+    }
+
+    public boolean testNotEq23_6(MyAbstract u, MyValue1 v) {
+        return get(u) != get(v); // only false if both null
+    }
+
     public boolean testNotEq24_1(MyValue1 v, MyInterface u) {
         return getNotNull(v) != u; // true
     }
 
     public boolean testNotEq24_2(MyValue1 v, MyInterface u) {
@@ -973,10 +1232,22 @@
 
     public boolean testNotEq24_3(MyValue1 v, MyInterface u) {
         return getNotNull(v) != getNotNull(u); // true
     }
 
+    public boolean testNotEq24_4(MyValue1 v, MyAbstract u) {
+        return getNotNull(v) != u; // true
+    }
+
+    public boolean testNotEq24_5(MyValue1 v, MyAbstract u) {
+        return (Object)v != getNotNull(u); // true
+    }
+
+    public boolean testNotEq24_6(MyValue1 v, MyAbstract u) {
+        return getNotNull(v) != getNotNull(u); // true
+    }
+
     public boolean testNotEq25_1(MyInterface u, MyValue1 v) {
         return getNotNull(u) != (Object)v; // true
     }
 
     public boolean testNotEq25_2(MyInterface u, MyValue1 v) {
@@ -985,10 +1256,22 @@
 
     public boolean testNotEq25_3(MyInterface u, MyValue1 v) {
         return getNotNull(u) != getNotNull(v); // true
     }
 
+    public boolean testNotEq25_4(MyAbstract u, MyValue1 v) {
+        return getNotNull(u) != (Object)v; // true
+    }
+
+    public boolean testNotEq25_5(MyAbstract u, MyValue1 v) {
+        return u != getNotNull(v); // true
+    }
+
+    public boolean testNotEq25_6(MyAbstract u, MyValue1 v) {
+        return getNotNull(u) != getNotNull(v); // true
+    }
+
     public boolean testNotEq26_1(MyInterface u, MyObject o) {
         return get(u) != o; // old acmp
     }
 
     public boolean testNotEq26_2(MyInterface u, MyObject o) {
@@ -997,10 +1280,22 @@
 
     public boolean testNotEq26_3(MyInterface u, MyObject o) {
         return get(u) != get(o); // old acmp
     }
 
+    public boolean testNotEq26_4(MyAbstract u, MyObject o) {
+        return get(u) != o; // old acmp
+    }
+
+    public boolean testNotEq26_5(MyAbstract u, MyObject o) {
+        return u != get(o); // old acmp
+    }
+
+    public boolean testNotEq26_6(MyAbstract u, MyObject o) {
+        return get(u) != get(o); // old acmp
+    }
+
     public boolean testNotEq27_1(MyObject o, MyInterface u) {
         return get(o) != u; // old acmp
     }
 
     public boolean testNotEq27_2(MyObject o, MyInterface u) {
@@ -1009,10 +1304,22 @@
 
     public boolean testNotEq27_3(MyObject o, MyInterface u) {
         return get(o) != get(u); // old acmp
     }
 
+    public boolean testNotEq27_4(MyObject o, MyAbstract u) {
+        return get(o) != u; // old acmp
+    }
+
+    public boolean testNotEq27_5(MyObject o, MyAbstract u) {
+        return o != get(u); // old acmp
+    }
+
+    public boolean testNotEq27_6(MyObject o, MyAbstract u) {
+        return get(o) != get(u); // old acmp
+    }
+
     public boolean testNotEq28_1(MyInterface[] a, MyInterface u) {
         return get(a) != u; // old acmp
     }
 
     public boolean testNotEq28_2(MyInterface[] a, MyInterface u) {
@@ -1021,10 +1328,22 @@
 
     public boolean testNotEq28_3(MyInterface[] a, MyInterface u) {
         return get(a) != get(u); // old acmp
     }
 
+    public boolean testNotEq28_4(MyAbstract[] a, MyAbstract u) {
+        return get(a) != u; // old acmp
+    }
+
+    public boolean testNotEq28_5(MyAbstract[] a, MyAbstract u) {
+        return a != get(u); // old acmp
+    }
+
+    public boolean testNotEq28_6(MyAbstract[] a, MyAbstract u) {
+        return get(a) != get(u); // old acmp
+    }
+
     public boolean testNotEq29_1(MyInterface u, MyInterface[] a) {
         return get(u) != a; // old acmp
     }
 
     public boolean testNotEq29_2(MyInterface u, MyInterface[] a) {
@@ -1033,10 +1352,22 @@
 
     public boolean testNotEq29_3(MyInterface u, MyInterface[] a) {
         return get(u) != get(a); // old acmp
     }
 
+    public boolean testNotEq29_4(MyAbstract u, MyAbstract[] a) {
+        return get(u) != a; // old acmp
+    }
+
+    public boolean testNotEq29_5(MyAbstract u, MyAbstract[] a) {
+        return u != get(a); // old acmp
+    }
+
+    public boolean testNotEq29_6(MyAbstract u, MyAbstract[] a) {
+        return get(u) != get(a); // old acmp
+    }
+
     public boolean testNotEq30_1(MyInterface[] a, MyValue1 v) {
         return get(a) != (Object)v; // only false if both null
     }
 
     public boolean testNotEq30_2(MyInterface[] a, MyValue1 v) {
@@ -1045,10 +1376,22 @@
 
     public boolean testNotEq30_3(MyInterface[] a, MyValue1 v) {
         return get(a) != get(v); // only false if both null
     }
 
+    public boolean testNotEq30_4(MyAbstract[] a, MyValue1 v) {
+        return get(a) != (Object)v; // only false if both null
+    }
+
+    public boolean testNotEq30_5(MyAbstract[] a, MyValue1 v) {
+        return a != get(v); // only false if both null
+    }
+
+    public boolean testNotEq30_6(MyAbstract[] a, MyValue1 v) {
+        return get(a) != get(v); // only false if both null
+    }
+
     public boolean testNotEq31_1(MyValue1 v, MyInterface[] a) {
         return get(v) != a; // only false if both null
     }
 
     public boolean testNotEq31_2(MyValue1 v, MyInterface[] a) {
@@ -1057,10 +1400,22 @@
 
     public boolean testNotEq31_3(MyValue1 v, MyInterface[] a) {
         return get(v) != get(a); // only false if both null
     }
 
+    public boolean testNotEq31_4(MyValue1 v, MyAbstract[] a) {
+        return get(v) != a; // only false if both null
+    }
+
+    public boolean testNotEq31_5(MyValue1 v, MyAbstract[] a) {
+        return (Object)v != get(a); // only false if both null
+    }
+
+    public boolean testNotEq31_6(MyValue1 v, MyAbstract[] a) {
+        return get(v) != get(a); // only false if both null
+    }
+
     public boolean testNotEq32_1(MyInterface[] a, MyValue1 v) {
         return getNotNull(a) != (Object)v; // true
     }
 
     public boolean testNotEq32_2(MyInterface[] a, MyValue1 v) {
@@ -1069,10 +1424,22 @@
 
     public boolean testNotEq32_3(MyInterface[] a, MyValue1 v) {
         return getNotNull(a) != getNotNull(v); // true
     }
 
+    public boolean testNotEq32_4(MyAbstract[] a, MyValue1 v) {
+        return getNotNull(a) != (Object)v; // true
+    }
+
+    public boolean testNotEq32_5(MyAbstract[] a, MyValue1 v) {
+        return a != getNotNull(v); // true
+    }
+
+    public boolean testNotEq32_6(MyAbstract[] a, MyValue1 v) {
+        return getNotNull(a) != getNotNull(v); // true
+    }
+
     public boolean testNotEq33_1(MyValue1 v, MyInterface[] a) {
         return getNotNull(v) != a; // true
     }
 
     public boolean testNotEq33_2(MyValue1 v, MyInterface[] a) {
@@ -1081,10 +1448,22 @@
 
     public boolean testNotEq33_3(MyValue1 v, MyInterface[] a) {
         return getNotNull(v) != getNotNull(a); // true
     }
 
+    public boolean testNotEq33_4(MyValue1 v, MyAbstract[] a) {
+        return getNotNull(v) != a; // true
+    }
+
+    public boolean testNotEq33_5(MyValue1 v, MyAbstract[] a) {
+        return (Object)v != getNotNull(a); // true
+    }
+
+    public boolean testNotEq33_6(MyValue1 v, MyAbstract[] a) {
+        return getNotNull(v) != getNotNull(a); // true
+    }
+
     // Null tests
 
     public boolean testNotNull01_1(MyValue1 v) {
         return (Object)v != null; // old acmp
     }
@@ -1195,10 +1574,26 @@
 
     public boolean testNotNull07_4(MyInterface u) {
         return get(u) != get((Object)null); // old acmp
     }
 
+    public boolean testNotNull07_5(MyAbstract u) {
+        return u != null; // old acmp
+    }
+
+    public boolean testNotNull07_6(MyAbstract u) {
+        return get(u) != null; // old acmp
+    }
+
+    public boolean testNotNull07_7(MyAbstract u) {
+        return u != get((Object)null); // old acmp
+    }
+
+    public boolean testNotNull07_8(MyAbstract u) {
+        return get(u) != get((Object)null); // old acmp
+    }
+
     public boolean testNotNull08_1(MyInterface u) {
         return null != u; // old acmp
     }
 
     public boolean testNotNull08_2(MyInterface u) {
@@ -1211,10 +1606,26 @@
 
     public boolean testNotNull08_4(MyInterface u) {
         return get((Object)null) != get(u); // old acmp
     }
 
+    public boolean testNotNull08_5(MyAbstract u) {
+        return null != u; // old acmp
+    }
+
+    public boolean testNotNull08_6(MyAbstract u) {
+        return get((Object)null) != u; // old acmp
+    }
+
+    public boolean testNotNull08_7(MyAbstract u) {
+        return null != get(u); // old acmp
+    }
+
+    public boolean testNotNull08_8(MyAbstract u) {
+        return get((Object)null) != get(u); // old acmp
+    }
+
     // The following methods are used with -XX:+AlwaysIncrementalInline to hide exact types during parsing
 
     public Object get(Object u) {
         return u;
     }

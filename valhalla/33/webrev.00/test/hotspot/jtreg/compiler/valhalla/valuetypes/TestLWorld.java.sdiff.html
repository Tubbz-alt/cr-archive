<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestIntrinsics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 419         staticValueField2 = (MyValue1)vt1;
 420         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 421         if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {
 422             throw new RuntimeException(&quot;Should be null&quot;);
 423         }
 424         return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +
 425                ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +
 426                ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +
 427                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 428                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 429     }
 430 
 431     @DontCompile
 432     public void test12_verifier(boolean warmup) {
 433         MyValue1 vt = testValue1;
 434         MyValue1 def = MyValue1.createDefaultDontInline();
 435         long result = test12(vt, vt);
 436         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 437     }
 438 
<span class="line-modified"> 439     class MyObject implements MyInterface {</span>
 440         public int x;
 441 
<span class="line-modified"> 442         public MyObject(int x) {</span>
 443             this.x = x;
 444         }
 445 
 446         @ForceInline
 447         public long hash() {
 448             return x;
 449         }
 450     }
 451 
 452     // Test merging value types and interfaces
 453     @Test()
 454     public MyInterface test13(int state) {
 455         MyInterface res = null;
 456         if (state == 0) {
<span class="line-modified"> 457             res = new MyObject(rI);</span>
 458         } else if (state == 1) {
 459             res = MyValue1.createWithFieldsInline(rI, rL);
 460         } else if (state == 2) {
 461             res = MyValue1.createWithFieldsDontInline(rI, rL);
 462         } else if (state == 3) {
 463             res = (MyValue1)objectField1;
 464         } else if (state == 4) {
 465             res = valueField1;
 466         } else if (state == 5) {
 467             res = null;
 468         }
 469         return res;
 470     }
 471 
 472     @DontCompile
 473     public void test13_verifier(boolean warmup) {
 474         objectField1 = valueField1;
 475         MyInterface result = null;
 476         result = test13(0);
<span class="line-modified"> 477         Asserts.assertEQ(((MyObject)result).x, rI);</span>
 478         result = test13(1);
 479         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 480         result = test13(2);
 481         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 482         result = test13(3);
 483         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 484         result = test13(4);
 485         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 486         result = test13(5);
 487         Asserts.assertEQ(result, null);
 488     }
 489 
 490     // Test merging value types and interfaces in loops
 491     @Test()
 492     public MyInterface test14(int iters) {
<span class="line-modified"> 493         MyInterface res = new MyObject(rI);</span>
 494         for (int i = 0; i &lt; iters; ++i) {
<span class="line-modified"> 495             if (res instanceof MyObject) {</span>
 496                 res = MyValue1.createWithFieldsInline(rI, rL);
 497             } else {
 498                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 499             }
 500         }
 501         return res;
 502     }
 503 
 504     @DontCompile
 505     public void test14_verifier(boolean warmup) {
<span class="line-modified"> 506         MyObject result1 = (MyObject)test14(0);</span>
 507         Asserts.assertEQ(result1.x, rI);
 508         int iters = (Math.abs(rI) % 10) + 1;
 509         MyValue1 result2 = (MyValue1)test14(iters);
 510         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 511         Asserts.assertEQ(result2.hash(), vt.hash());
 512     }
 513 
 514     // Test value types in interface variables that are live at safepoint
 515     @Test(failOn = ALLOC + STORE + LOOP)
 516     public long test15(MyValue1 arg, boolean deopt) {
 517         MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);
 518         MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 519         MyInterface vt3 = arg;
 520         MyInterface vt4 = valueField1;
 521         if (deopt) {
 522             // uncommon trap
 523             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test15&quot;));
 524         }
 525         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 526                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
</pre>
<hr />
<pre>
 627     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,
 628                                                                       testValue2,
 629                                                                       testValue2};
 630 
 631     private static final Integer[] testIntegerArray = new Integer[42];
 632 
 633     // Test load from (flattened) value type array disguised as object array
 634     @Test()
 635     public Object test21(Object[] oa, int index) {
 636         return oa[index];
 637     }
 638 
 639     @DontCompile
 640     public void test21_verifier(boolean warmup) {
 641         MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);
 642         Asserts.assertEQ(result.hash(), hash());
 643     }
 644 
 645     // Test load from (flattened) value type array disguised as interface array
 646     @Test()
<span class="line-modified"> 647     public Object test22(MyInterface[] ia, int index) {</span>
 648         return ia[index];
 649     }
 650 
 651     @DontCompile
<span class="line-modified"> 652     public void test22_verifier(boolean warmup) {</span>
<span class="line-modified"> 653         MyValue1 result = (MyValue1)test22(testValue1Array, Math.abs(rI) % 3);</span>
 654         Asserts.assertEQ(result.hash(), hash());
 655     }
 656 
<span class="line-modified"> 657     // Test value store to (flattened) value type array disguised as object array</span>




 658 







 659     @ForceInline
 660     public void test23_inline(Object[] oa, Object o, int index) {
 661         oa[index] = o;
 662     }
 663 
 664     @Test()
 665     public void test23(Object[] oa, MyValue1 vt, int index) {
 666         test23_inline(oa, vt, index);
 667     }
 668 
 669     @DontCompile
 670     public void test23_verifier(boolean warmup) {
 671         int index = Math.abs(rI) % 3;
 672         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 673         test23(testValue1Array, vt, index);
 674         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 675         testValue1Array[index] = testValue1;
 676         try {
 677             test23(testValue2Array, vt, index);
 678             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
</pre>
<hr />
<pre>
 709     }
 710 
 711     @Test()
 712     public void test25(Object[] oa, MyValue1 vt, int index) {
 713         test25_inline(oa, vt, index);
 714     }
 715 
 716     @DontCompile
 717     public void test25_verifier(boolean warmup) {
 718         int index = Math.abs(rI) % 3;
 719         try {
 720             test25(null, testValue1, index);
 721             throw new RuntimeException(&quot;No NPE thrown&quot;);
 722         } catch (NullPointerException e) {
 723             // Expected
 724         }
 725     }
 726 
 727     // Test value store to (flattened) value type array disguised as interface array
 728     @ForceInline
<span class="line-modified"> 729     public void test26_inline(MyInterface[] ia, MyInterface i, int index) {</span>
















































 730         ia[index] = i;
 731     }
 732 
 733     @Test()
<span class="line-modified"> 734     public void test26(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified"> 735       test26_inline(ia, vt, index);</span>
 736     }
 737 
 738     @DontCompile
<span class="line-modified"> 739     public void test26_verifier(boolean warmup) {</span>
 740         int index = Math.abs(rI) % 3;
 741         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified"> 742         test26(testValue1Array, vt, index);</span>
 743         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 744         testValue1Array[index] = testValue1;
 745         try {
<span class="line-modified"> 746             test26(testValue2Array, vt, index);</span>
 747             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 748         } catch (ArrayStoreException e) {
 749             // Expected
 750         }
 751         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 752     }
 753 
 754     @ForceInline
<span class="line-modified"> 755     public void test27_inline(MyInterface[] ia, MyInterface i, int index) {</span>
 756         ia[index] = i;
 757     }
 758 
 759     @Test()
<span class="line-modified"> 760     public void test27(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified"> 761         test27_inline(ia, vt, index);</span>
 762     }
 763 
 764     @DontCompile
<span class="line-modified"> 765     public void test27_verifier(boolean warmup) {</span>
 766         int index = Math.abs(rI) % 3;
 767         try {
<span class="line-modified"> 768             test27(null, testValue1, index);</span>
 769             throw new RuntimeException(&quot;No NPE thrown&quot;);
 770         } catch (NullPointerException e) {
 771             // Expected
 772         }
 773     }
 774 
 775     // Test object store to (flattened) value type array disguised as object array
 776     @ForceInline
 777     public void test28_inline(Object[] oa, Object o, int index) {
 778         oa[index] = o;
 779     }
 780 
 781     @Test()
 782     public void test28(Object[] oa, Object o, int index) {
 783         test28_inline(oa, o, index);
 784     }
 785 
 786     @DontCompile
 787     public void test28_verifier(boolean warmup) {
 788         int index = Math.abs(rI) % 3;
</pre>
<hr />
<pre>
 827     }
 828 
 829     @Test()
 830     public void test30(Object[] oa, Object o, int index) {
 831         test30_inline(oa, o, index);
 832     }
 833 
 834     @DontCompile
 835     public void test30_verifier(boolean warmup) {
 836         int index = Math.abs(rI) % 3;
 837         try {
 838             test30(testIntegerArray, testValue1, index);
 839             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 840         } catch (ArrayStoreException e) {
 841             // Expected
 842         }
 843     }
 844 
 845     // Test value store to (flattened) value type array disguised as interface array
 846     @ForceInline
<span class="line-modified"> 847     public void test31_inline(MyInterface[] ia, MyInterface i, int index) {</span>
















































 848         ia[index] = i;
 849     }
 850 
 851     @Test()
<span class="line-modified"> 852     public void test31(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-modified"> 853         test31_inline(ia, i, index);</span>
 854     }
 855 
 856     @DontCompile
<span class="line-modified"> 857     public void test31_verifier(boolean warmup) {</span>
 858         int index = Math.abs(rI) % 3;
 859         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified"> 860         test31(testValue1Array, vt1, index);</span>
 861         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 862         try {
<span class="line-modified"> 863             test31(testValue1Array, testValue2, index);</span>
 864             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 865         } catch (ArrayStoreException e) {
 866             // Expected
 867         }
 868         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 869         testValue1Array[index] = testValue1;
 870     }
 871 
 872     @ForceInline
<span class="line-modified"> 873     public void test32_inline(MyInterface[] ia, MyInterface i, int index) {</span>
 874         ia[index] = i;
 875     }
 876 
 877     @Test()
<span class="line-modified"> 878     public void test32(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-modified"> 879         test32_inline(ia, i, index);</span>
 880     }
 881 
 882     @DontCompile
<span class="line-modified"> 883     public void test32_verifier(boolean warmup) {</span>
 884         int index = Math.abs(rI) % 3;
 885         try {
<span class="line-modified"> 886             test32(testValue2Array, testValue1, index);</span>
 887             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 888         } catch (ArrayStoreException e) {
 889             // Expected
 890         }
 891     }
 892 
 893     // Test writing null to a (flattened) value type array disguised as object array
 894     @ForceInline
 895     public void test33_inline(Object[] oa, Object o, int index) {
 896         oa[index] = o;
 897     }
 898 
 899     @Test()
 900     public void test33(Object[] oa, Object o, int index) {
 901         test33_inline(oa, o, index);
 902     }
 903 
 904     @DontCompile
 905     public void test33_verifier(boolean warmup) {
 906         int index = Math.abs(rI) % 3;
</pre>
<hr />
<pre>
1684 
1685     // Test synchronization without any instructions in the synchronized block
1686     @Test()
1687     public void test63(Object o) {
1688         synchronized (o) { }
1689     }
1690 
1691     @DontCompile
1692     public void test63_verifier(boolean warmup) {
1693         try {
1694             test63(testValue1);
1695         } catch (IllegalMonitorStateException ex) {
1696             // Expected
1697             return;
1698         }
1699         throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
1700     }
1701 
1702     // type system test with interface and value type
1703     @ForceInline
<span class="line-modified">1704     public MyInterface test64_helper(MyValue1 vt) {</span>
















1705         return vt;
1706     }
1707 
1708     @Test()
<span class="line-modified">1709     public MyInterface test64(MyValue1 vt) {</span>
<span class="line-modified">1710         return test64_helper(vt);</span>
1711     }
1712 
1713     @DontCompile
<span class="line-modified">1714     public void test64_verifier(boolean warmup) {</span>
<span class="line-modified">1715         test64(testValue1);</span>
1716     }
1717 
1718     // Array store tests
1719     @Test()
1720     public void test65(Object[] array, MyValue1 vt) {
1721         array[0] = vt;
1722     }
1723 
1724     @DontCompile
1725     public void test65_verifier(boolean warmup) {
1726         Object[] array = new Object[1];
1727         test65(array, testValue1);
1728         Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());
1729     }
1730 
1731     @Test()
1732     public void test66(Object[] array, MyValue1 vt) {
1733         array[0] = vt;
1734     }
1735 
</pre>
<hr />
<pre>
1771         return MyValue1.setX(((MyValue1)a), sum);
1772     }
1773 
1774     @Test(failOn = ALLOC + STORE)
1775     public int test69(MyValue1[] array) {
1776         MyValue1 result = MyValue1.createDefaultInline();
1777         for (int i = 0; i &lt; array.length; ++i) {
1778             result = (MyValue1)test69_sum(result, array[i]);
1779         }
1780         return result.x;
1781     }
1782 
1783     @DontCompile
1784     public void test69_verifier(boolean warmup) {
1785         int result = test69(testValue1Array);
1786         Asserts.assertEQ(result, rI * testValue1Array.length);
1787     }
1788 
1789     // Same as test69 but with an Interface
1790     @ForceInline
<span class="line-modified">1791     public MyInterface test70_sum(MyInterface a, MyInterface b) {</span>






















1792         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1793         return MyValue1.setX(((MyValue1)a), sum);
1794     }
1795 
1796     @Test(failOn = ALLOC + STORE)
<span class="line-modified">1797     public int test70(MyValue1[] array) {</span>
1798         MyValue1 result = MyValue1.createDefaultInline();
1799         for (int i = 0; i &lt; array.length; ++i) {
<span class="line-modified">1800             result = (MyValue1)test70_sum(result, array[i]);</span>
1801         }
1802         return result.x;
1803     }
1804 
1805     @DontCompile
<span class="line-modified">1806     public void test70_verifier(boolean warmup) {</span>
<span class="line-modified">1807         int result = test70(testValue1Array);</span>
1808         Asserts.assertEQ(result, rI * testValue1Array.length);
1809     }
1810 
1811     // Test that allocated value type is not used in non-dominated path
1812     public MyValue1 test71_inline(Object obj) {
1813         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1814         try {
1815             vt = (MyValue1)obj;
1816             throw new RuntimeException(&quot;NullPointerException expected&quot;);
1817         } catch (NullPointerException e) {
1818             // Expected
1819         }
1820         return vt;
1821     }
1822 
1823     @Test
1824     public MyValue1 test71() {
1825         return test71_inline(null);
1826     }
1827 
</pre>
<hr />
<pre>
2373     }
2374 
2375     // Same as test95 but operands are never null
2376     @Warmup(10000)
2377     @Test(failOn = STORAGE_PROPERTY_CLEARING)
2378     public boolean test96(Object o1, Object o2) {
2379         return o1 == o2;
2380     }
2381 
2382     @DontCompile
2383     public void test96_verifier(boolean warmup) {
2384         Object o1 = new Object();
2385         Object o2 = new Object();
2386         Asserts.assertTrue(test96(o1, o1));
2387         Asserts.assertFalse(test96(o1, o2));
2388         if (!warmup) {
2389             Asserts.assertTrue(test96(null, null));
2390             Asserts.assertFalse(test96(o1, null));
2391         }
2392     }


































































































































































































































































































































2393 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 419         staticValueField2 = (MyValue1)vt1;
 420         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization
 421         if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {
 422             throw new RuntimeException(&quot;Should be null&quot;);
 423         }
 424         return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +
 425                ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +
 426                ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +
 427                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +
 428                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();
 429     }
 430 
 431     @DontCompile
 432     public void test12_verifier(boolean warmup) {
 433         MyValue1 vt = testValue1;
 434         MyValue1 def = MyValue1.createDefaultDontInline();
 435         long result = test12(vt, vt);
 436         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());
 437     }
 438 
<span class="line-modified"> 439     class MyObject1 implements MyInterface {</span>
 440         public int x;
 441 
<span class="line-modified"> 442         public MyObject1(int x) {</span>
 443             this.x = x;
 444         }
 445 
 446         @ForceInline
 447         public long hash() {
 448             return x;
 449         }
 450     }
 451 
 452     // Test merging value types and interfaces
 453     @Test()
 454     public MyInterface test13(int state) {
 455         MyInterface res = null;
 456         if (state == 0) {
<span class="line-modified"> 457             res = new MyObject1(rI);</span>
 458         } else if (state == 1) {
 459             res = MyValue1.createWithFieldsInline(rI, rL);
 460         } else if (state == 2) {
 461             res = MyValue1.createWithFieldsDontInline(rI, rL);
 462         } else if (state == 3) {
 463             res = (MyValue1)objectField1;
 464         } else if (state == 4) {
 465             res = valueField1;
 466         } else if (state == 5) {
 467             res = null;
 468         }
 469         return res;
 470     }
 471 
 472     @DontCompile
 473     public void test13_verifier(boolean warmup) {
 474         objectField1 = valueField1;
 475         MyInterface result = null;
 476         result = test13(0);
<span class="line-modified"> 477         Asserts.assertEQ(((MyObject1)result).x, rI);</span>
 478         result = test13(1);
 479         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 480         result = test13(2);
 481         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 482         result = test13(3);
 483         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 484         result = test13(4);
 485         Asserts.assertEQ(((MyValue1)result).hash(), hash());
 486         result = test13(5);
 487         Asserts.assertEQ(result, null);
 488     }
 489 
 490     // Test merging value types and interfaces in loops
 491     @Test()
 492     public MyInterface test14(int iters) {
<span class="line-modified"> 493         MyInterface res = new MyObject1(rI);</span>
 494         for (int i = 0; i &lt; iters; ++i) {
<span class="line-modified"> 495             if (res instanceof MyObject1) {</span>
 496                 res = MyValue1.createWithFieldsInline(rI, rL);
 497             } else {
 498                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);
 499             }
 500         }
 501         return res;
 502     }
 503 
 504     @DontCompile
 505     public void test14_verifier(boolean warmup) {
<span class="line-modified"> 506         MyObject1 result1 = (MyObject1)test14(0);</span>
 507         Asserts.assertEQ(result1.x, rI);
 508         int iters = (Math.abs(rI) % 10) + 1;
 509         MyValue1 result2 = (MyValue1)test14(iters);
 510         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);
 511         Asserts.assertEQ(result2.hash(), vt.hash());
 512     }
 513 
 514     // Test value types in interface variables that are live at safepoint
 515     @Test(failOn = ALLOC + STORE + LOOP)
 516     public long test15(MyValue1 arg, boolean deopt) {
 517         MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);
 518         MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);
 519         MyInterface vt3 = arg;
 520         MyInterface vt4 = valueField1;
 521         if (deopt) {
 522             // uncommon trap
 523             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test15&quot;));
 524         }
 525         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +
 526                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();
</pre>
<hr />
<pre>
 627     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2,
 628                                                                       testValue2,
 629                                                                       testValue2};
 630 
 631     private static final Integer[] testIntegerArray = new Integer[42];
 632 
 633     // Test load from (flattened) value type array disguised as object array
 634     @Test()
 635     public Object test21(Object[] oa, int index) {
 636         return oa[index];
 637     }
 638 
 639     @DontCompile
 640     public void test21_verifier(boolean warmup) {
 641         MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);
 642         Asserts.assertEQ(result.hash(), hash());
 643     }
 644 
 645     // Test load from (flattened) value type array disguised as interface array
 646     @Test()
<span class="line-modified"> 647     public Object test22Interface(MyInterface[] ia, int index) {</span>
 648         return ia[index];
 649     }
 650 
 651     @DontCompile
<span class="line-modified"> 652     public void test22Interface_verifier(boolean warmup) {</span>
<span class="line-modified"> 653         MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);</span>
 654         Asserts.assertEQ(result.hash(), hash());
 655     }
 656 
<span class="line-modified"> 657     // Test load from (flattened) value type array disguised as abstract array</span>
<span class="line-added"> 658     @Test()</span>
<span class="line-added"> 659     public Object test22Abstract(MyAbstract[] ia, int index) {</span>
<span class="line-added"> 660         return ia[index];</span>
<span class="line-added"> 661     }</span>
 662 
<span class="line-added"> 663     @DontCompile</span>
<span class="line-added"> 664     public void test22Abstract_verifier(boolean warmup) {</span>
<span class="line-added"> 665         MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);</span>
<span class="line-added"> 666         Asserts.assertEQ(result.hash(), hash());</span>
<span class="line-added"> 667     }</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669     // Test value store to (flattened) value type array disguised as object array</span>
 670     @ForceInline
 671     public void test23_inline(Object[] oa, Object o, int index) {
 672         oa[index] = o;
 673     }
 674 
 675     @Test()
 676     public void test23(Object[] oa, MyValue1 vt, int index) {
 677         test23_inline(oa, vt, index);
 678     }
 679 
 680     @DontCompile
 681     public void test23_verifier(boolean warmup) {
 682         int index = Math.abs(rI) % 3;
 683         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 684         test23(testValue1Array, vt, index);
 685         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 686         testValue1Array[index] = testValue1;
 687         try {
 688             test23(testValue2Array, vt, index);
 689             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
</pre>
<hr />
<pre>
 720     }
 721 
 722     @Test()
 723     public void test25(Object[] oa, MyValue1 vt, int index) {
 724         test25_inline(oa, vt, index);
 725     }
 726 
 727     @DontCompile
 728     public void test25_verifier(boolean warmup) {
 729         int index = Math.abs(rI) % 3;
 730         try {
 731             test25(null, testValue1, index);
 732             throw new RuntimeException(&quot;No NPE thrown&quot;);
 733         } catch (NullPointerException e) {
 734             // Expected
 735         }
 736     }
 737 
 738     // Test value store to (flattened) value type array disguised as interface array
 739     @ForceInline
<span class="line-modified"> 740     public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 741         ia[index] = i;</span>
<span class="line-added"> 742     }</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744     @Test()</span>
<span class="line-added"> 745     public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-added"> 746       test26Interface_inline(ia, vt, index);</span>
<span class="line-added"> 747     }</span>
<span class="line-added"> 748 </span>
<span class="line-added"> 749     @DontCompile</span>
<span class="line-added"> 750     public void test26Interface_verifier(boolean warmup) {</span>
<span class="line-added"> 751         int index = Math.abs(rI) % 3;</span>
<span class="line-added"> 752         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
<span class="line-added"> 753         test26Interface(testValue1Array, vt, index);</span>
<span class="line-added"> 754         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());</span>
<span class="line-added"> 755         testValue1Array[index] = testValue1;</span>
<span class="line-added"> 756         try {</span>
<span class="line-added"> 757             test26Interface(testValue2Array, vt, index);</span>
<span class="line-added"> 758             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added"> 759         } catch (ArrayStoreException e) {</span>
<span class="line-added"> 760             // Expected</span>
<span class="line-added"> 761         }</span>
<span class="line-added"> 762         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());</span>
<span class="line-added"> 763     }</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765     @ForceInline</span>
<span class="line-added"> 766     public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 767         ia[index] = i;</span>
<span class="line-added"> 768     }</span>
<span class="line-added"> 769 </span>
<span class="line-added"> 770     @Test()</span>
<span class="line-added"> 771     public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {</span>
<span class="line-added"> 772         test27Interface_inline(ia, vt, index);</span>
<span class="line-added"> 773     }</span>
<span class="line-added"> 774 </span>
<span class="line-added"> 775     @DontCompile</span>
<span class="line-added"> 776     public void test27Interface_verifier(boolean warmup) {</span>
<span class="line-added"> 777         int index = Math.abs(rI) % 3;</span>
<span class="line-added"> 778         try {</span>
<span class="line-added"> 779             test27Interface(null, testValue1, index);</span>
<span class="line-added"> 780             throw new RuntimeException(&quot;No NPE thrown&quot;);</span>
<span class="line-added"> 781         } catch (NullPointerException e) {</span>
<span class="line-added"> 782             // Expected</span>
<span class="line-added"> 783         }</span>
<span class="line-added"> 784     }</span>
<span class="line-added"> 785 </span>
<span class="line-added"> 786     // Test value store to (flattened) value type array disguised as abstract array</span>
<span class="line-added"> 787     @ForceInline</span>
<span class="line-added"> 788     public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
 789         ia[index] = i;
 790     }
 791 
 792     @Test()
<span class="line-modified"> 793     public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified"> 794       test26Abstract_inline(ia, vt, index);</span>
 795     }
 796 
 797     @DontCompile
<span class="line-modified"> 798     public void test26Abstract_verifier(boolean warmup) {</span>
 799         int index = Math.abs(rI) % 3;
 800         MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified"> 801         test26Abstract(testValue1Array, vt, index);</span>
 802         Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());
 803         testValue1Array[index] = testValue1;
 804         try {
<span class="line-modified"> 805             test26Abstract(testValue2Array, vt, index);</span>
 806             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 807         } catch (ArrayStoreException e) {
 808             // Expected
 809         }
 810         Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());
 811     }
 812 
 813     @ForceInline
<span class="line-modified"> 814     public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
 815         ia[index] = i;
 816     }
 817 
 818     @Test()
<span class="line-modified"> 819     public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {</span>
<span class="line-modified"> 820         test27Abstract_inline(ia, vt, index);</span>
 821     }
 822 
 823     @DontCompile
<span class="line-modified"> 824     public void test27Abstract_verifier(boolean warmup) {</span>
 825         int index = Math.abs(rI) % 3;
 826         try {
<span class="line-modified"> 827             test27Abstract(null, testValue1, index);</span>
 828             throw new RuntimeException(&quot;No NPE thrown&quot;);
 829         } catch (NullPointerException e) {
 830             // Expected
 831         }
 832     }
 833 
 834     // Test object store to (flattened) value type array disguised as object array
 835     @ForceInline
 836     public void test28_inline(Object[] oa, Object o, int index) {
 837         oa[index] = o;
 838     }
 839 
 840     @Test()
 841     public void test28(Object[] oa, Object o, int index) {
 842         test28_inline(oa, o, index);
 843     }
 844 
 845     @DontCompile
 846     public void test28_verifier(boolean warmup) {
 847         int index = Math.abs(rI) % 3;
</pre>
<hr />
<pre>
 886     }
 887 
 888     @Test()
 889     public void test30(Object[] oa, Object o, int index) {
 890         test30_inline(oa, o, index);
 891     }
 892 
 893     @DontCompile
 894     public void test30_verifier(boolean warmup) {
 895         int index = Math.abs(rI) % 3;
 896         try {
 897             test30(testIntegerArray, testValue1, index);
 898             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 899         } catch (ArrayStoreException e) {
 900             // Expected
 901         }
 902     }
 903 
 904     // Test value store to (flattened) value type array disguised as interface array
 905     @ForceInline
<span class="line-modified"> 906     public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 907         ia[index] = i;</span>
<span class="line-added"> 908     }</span>
<span class="line-added"> 909 </span>
<span class="line-added"> 910     @Test()</span>
<span class="line-added"> 911     public void test31Interface(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 912         test31Interface_inline(ia, i, index);</span>
<span class="line-added"> 913     }</span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915     @DontCompile</span>
<span class="line-added"> 916     public void test31Interface_verifier(boolean warmup) {</span>
<span class="line-added"> 917         int index = Math.abs(rI) % 3;</span>
<span class="line-added"> 918         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
<span class="line-added"> 919         test31Interface(testValue1Array, vt1, index);</span>
<span class="line-added"> 920         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());</span>
<span class="line-added"> 921         try {</span>
<span class="line-added"> 922             test31Interface(testValue1Array, testValue2, index);</span>
<span class="line-added"> 923             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added"> 924         } catch (ArrayStoreException e) {</span>
<span class="line-added"> 925             // Expected</span>
<span class="line-added"> 926         }</span>
<span class="line-added"> 927         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());</span>
<span class="line-added"> 928         testValue1Array[index] = testValue1;</span>
<span class="line-added"> 929     }</span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931     @ForceInline</span>
<span class="line-added"> 932     public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 933         ia[index] = i;</span>
<span class="line-added"> 934     }</span>
<span class="line-added"> 935 </span>
<span class="line-added"> 936     @Test()</span>
<span class="line-added"> 937     public void test32Interface(MyInterface[] ia, MyInterface i, int index) {</span>
<span class="line-added"> 938         test32Interface_inline(ia, i, index);</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940 </span>
<span class="line-added"> 941     @DontCompile</span>
<span class="line-added"> 942     public void test32Interface_verifier(boolean warmup) {</span>
<span class="line-added"> 943         int index = Math.abs(rI) % 3;</span>
<span class="line-added"> 944         try {</span>
<span class="line-added"> 945             test32Interface(testValue2Array, testValue1, index);</span>
<span class="line-added"> 946             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);</span>
<span class="line-added"> 947         } catch (ArrayStoreException e) {</span>
<span class="line-added"> 948             // Expected</span>
<span class="line-added"> 949         }</span>
<span class="line-added"> 950     }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952     // Test value store to (flattened) value type array disguised as abstract array</span>
<span class="line-added"> 953     @ForceInline</span>
<span class="line-added"> 954     public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
 955         ia[index] = i;
 956     }
 957 
 958     @Test()
<span class="line-modified"> 959     public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {</span>
<span class="line-modified"> 960         test31Abstract_inline(ia, i, index);</span>
 961     }
 962 
 963     @DontCompile
<span class="line-modified"> 964     public void test31Abstract_verifier(boolean warmup) {</span>
 965         int index = Math.abs(rI) % 3;
 966         MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
<span class="line-modified"> 967         test31Abstract(testValue1Array, vt1, index);</span>
 968         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 969         try {
<span class="line-modified"> 970             test31Abstract(testValue1Array, testValue2, index);</span>
 971             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 972         } catch (ArrayStoreException e) {
 973             // Expected
 974         }
 975         Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());
 976         testValue1Array[index] = testValue1;
 977     }
 978 
 979     @ForceInline
<span class="line-modified"> 980     public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {</span>
 981         ia[index] = i;
 982     }
 983 
 984     @Test()
<span class="line-modified"> 985     public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {</span>
<span class="line-modified"> 986         test32Abstract_inline(ia, i, index);</span>
 987     }
 988 
 989     @DontCompile
<span class="line-modified"> 990     public void test32Abstract_verifier(boolean warmup) {</span>
 991         int index = Math.abs(rI) % 3;
 992         try {
<span class="line-modified"> 993             test32Abstract(testValue2Array, testValue1, index);</span>
 994             throw new RuntimeException(&quot;No ArrayStoreException thrown&quot;);
 995         } catch (ArrayStoreException e) {
 996             // Expected
 997         }
 998     }
 999 
1000     // Test writing null to a (flattened) value type array disguised as object array
1001     @ForceInline
1002     public void test33_inline(Object[] oa, Object o, int index) {
1003         oa[index] = o;
1004     }
1005 
1006     @Test()
1007     public void test33(Object[] oa, Object o, int index) {
1008         test33_inline(oa, o, index);
1009     }
1010 
1011     @DontCompile
1012     public void test33_verifier(boolean warmup) {
1013         int index = Math.abs(rI) % 3;
</pre>
<hr />
<pre>
1791 
1792     // Test synchronization without any instructions in the synchronized block
1793     @Test()
1794     public void test63(Object o) {
1795         synchronized (o) { }
1796     }
1797 
1798     @DontCompile
1799     public void test63_verifier(boolean warmup) {
1800         try {
1801             test63(testValue1);
1802         } catch (IllegalMonitorStateException ex) {
1803             // Expected
1804             return;
1805         }
1806         throw new RuntimeException(&quot;test63 failed: no exception thrown&quot;);
1807     }
1808 
1809     // type system test with interface and value type
1810     @ForceInline
<span class="line-modified">1811     public MyInterface test64Interface_helper(MyValue1 vt) {</span>
<span class="line-added">1812         return vt;</span>
<span class="line-added">1813     }</span>
<span class="line-added">1814 </span>
<span class="line-added">1815     @Test()</span>
<span class="line-added">1816     public MyInterface test64Interface(MyValue1 vt) {</span>
<span class="line-added">1817         return test64Interface_helper(vt);</span>
<span class="line-added">1818     }</span>
<span class="line-added">1819 </span>
<span class="line-added">1820     @DontCompile</span>
<span class="line-added">1821     public void test64Interface_verifier(boolean warmup) {</span>
<span class="line-added">1822         test64Interface(testValue1);</span>
<span class="line-added">1823     }</span>
<span class="line-added">1824 </span>
<span class="line-added">1825     // type system test with abstract and value type</span>
<span class="line-added">1826     @ForceInline</span>
<span class="line-added">1827     public MyAbstract test64Abstract_helper(MyValue1 vt) {</span>
1828         return vt;
1829     }
1830 
1831     @Test()
<span class="line-modified">1832     public MyAbstract test64Abstract(MyValue1 vt) {</span>
<span class="line-modified">1833         return test64Abstract_helper(vt);</span>
1834     }
1835 
1836     @DontCompile
<span class="line-modified">1837     public void test64Abstract_verifier(boolean warmup) {</span>
<span class="line-modified">1838         test64Abstract(testValue1);</span>
1839     }
1840 
1841     // Array store tests
1842     @Test()
1843     public void test65(Object[] array, MyValue1 vt) {
1844         array[0] = vt;
1845     }
1846 
1847     @DontCompile
1848     public void test65_verifier(boolean warmup) {
1849         Object[] array = new Object[1];
1850         test65(array, testValue1);
1851         Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());
1852     }
1853 
1854     @Test()
1855     public void test66(Object[] array, MyValue1 vt) {
1856         array[0] = vt;
1857     }
1858 
</pre>
<hr />
<pre>
1894         return MyValue1.setX(((MyValue1)a), sum);
1895     }
1896 
1897     @Test(failOn = ALLOC + STORE)
1898     public int test69(MyValue1[] array) {
1899         MyValue1 result = MyValue1.createDefaultInline();
1900         for (int i = 0; i &lt; array.length; ++i) {
1901             result = (MyValue1)test69_sum(result, array[i]);
1902         }
1903         return result.x;
1904     }
1905 
1906     @DontCompile
1907     public void test69_verifier(boolean warmup) {
1908         int result = test69(testValue1Array);
1909         Asserts.assertEQ(result, rI * testValue1Array.length);
1910     }
1911 
1912     // Same as test69 but with an Interface
1913     @ForceInline
<span class="line-modified">1914     public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {</span>
<span class="line-added">1915         int sum = ((MyValue1)a).x + ((MyValue1)b).x;</span>
<span class="line-added">1916         return MyValue1.setX(((MyValue1)a), sum);</span>
<span class="line-added">1917     }</span>
<span class="line-added">1918 </span>
<span class="line-added">1919     @Test(failOn = ALLOC + STORE)</span>
<span class="line-added">1920     public int test70Interface(MyValue1[] array) {</span>
<span class="line-added">1921         MyValue1 result = MyValue1.createDefaultInline();</span>
<span class="line-added">1922         for (int i = 0; i &lt; array.length; ++i) {</span>
<span class="line-added">1923             result = (MyValue1)test70Interface_sum(result, array[i]);</span>
<span class="line-added">1924         }</span>
<span class="line-added">1925         return result.x;</span>
<span class="line-added">1926     }</span>
<span class="line-added">1927 </span>
<span class="line-added">1928     @DontCompile</span>
<span class="line-added">1929     public void test70Interface_verifier(boolean warmup) {</span>
<span class="line-added">1930         int result = test70Interface(testValue1Array);</span>
<span class="line-added">1931         Asserts.assertEQ(result, rI * testValue1Array.length);</span>
<span class="line-added">1932     }</span>
<span class="line-added">1933 </span>
<span class="line-added">1934     // Same as test69 but with an Abstract</span>
<span class="line-added">1935     @ForceInline</span>
<span class="line-added">1936     public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {</span>
1937         int sum = ((MyValue1)a).x + ((MyValue1)b).x;
1938         return MyValue1.setX(((MyValue1)a), sum);
1939     }
1940 
1941     @Test(failOn = ALLOC + STORE)
<span class="line-modified">1942     public int test70Abstract(MyValue1[] array) {</span>
1943         MyValue1 result = MyValue1.createDefaultInline();
1944         for (int i = 0; i &lt; array.length; ++i) {
<span class="line-modified">1945             result = (MyValue1)test70Abstract_sum(result, array[i]);</span>
1946         }
1947         return result.x;
1948     }
1949 
1950     @DontCompile
<span class="line-modified">1951     public void test70Abstract_verifier(boolean warmup) {</span>
<span class="line-modified">1952         int result = test70Abstract(testValue1Array);</span>
1953         Asserts.assertEQ(result, rI * testValue1Array.length);
1954     }
1955 
1956     // Test that allocated value type is not used in non-dominated path
1957     public MyValue1 test71_inline(Object obj) {
1958         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
1959         try {
1960             vt = (MyValue1)obj;
1961             throw new RuntimeException(&quot;NullPointerException expected&quot;);
1962         } catch (NullPointerException e) {
1963             // Expected
1964         }
1965         return vt;
1966     }
1967 
1968     @Test
1969     public MyValue1 test71() {
1970         return test71_inline(null);
1971     }
1972 
</pre>
<hr />
<pre>
2518     }
2519 
2520     // Same as test95 but operands are never null
2521     @Warmup(10000)
2522     @Test(failOn = STORAGE_PROPERTY_CLEARING)
2523     public boolean test96(Object o1, Object o2) {
2524         return o1 == o2;
2525     }
2526 
2527     @DontCompile
2528     public void test96_verifier(boolean warmup) {
2529         Object o1 = new Object();
2530         Object o2 = new Object();
2531         Asserts.assertTrue(test96(o1, o1));
2532         Asserts.assertFalse(test96(o1, o2));
2533         if (!warmup) {
2534             Asserts.assertTrue(test96(null, null));
2535             Asserts.assertFalse(test96(o1, null));
2536         }
2537     }
<span class="line-added">2538 </span>
<span class="line-added">2539     // Abstract class tests</span>
<span class="line-added">2540 </span>
<span class="line-added">2541     @DontInline</span>
<span class="line-added">2542     public MyAbstract test97_dontinline1(MyAbstract o) {</span>
<span class="line-added">2543         return o;</span>
<span class="line-added">2544     }</span>
<span class="line-added">2545 </span>
<span class="line-added">2546     @DontInline</span>
<span class="line-added">2547     public MyValue1 test97_dontinline2(MyAbstract o) {</span>
<span class="line-added">2548         return (MyValue1)o;</span>
<span class="line-added">2549     }</span>
<span class="line-added">2550 </span>
<span class="line-added">2551     @ForceInline</span>
<span class="line-added">2552     public MyAbstract test97_inline1(MyAbstract o) {</span>
<span class="line-added">2553         return o;</span>
<span class="line-added">2554     }</span>
<span class="line-added">2555 </span>
<span class="line-added">2556     @ForceInline</span>
<span class="line-added">2557     public MyValue1 test97_inline2(MyAbstract o) {</span>
<span class="line-added">2558         return (MyValue1)o;</span>
<span class="line-added">2559     }</span>
<span class="line-added">2560 </span>
<span class="line-added">2561     @Test()</span>
<span class="line-added">2562     public MyValue1 test97() {</span>
<span class="line-added">2563         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2564         vt = (MyValue1)test97_dontinline1(vt);</span>
<span class="line-added">2565         vt =           test97_dontinline2(vt);</span>
<span class="line-added">2566         vt = (MyValue1)test97_inline1(vt);</span>
<span class="line-added">2567         vt =           test97_inline2(vt);</span>
<span class="line-added">2568         return vt;</span>
<span class="line-added">2569     }</span>
<span class="line-added">2570 </span>
<span class="line-added">2571     @DontCompile</span>
<span class="line-added">2572     public void test97_verifier(boolean warmup) {</span>
<span class="line-added">2573         Asserts.assertEQ(test97().hash(), hash());</span>
<span class="line-added">2574     }</span>
<span class="line-added">2575 </span>
<span class="line-added">2576     // Test storing/loading value types to/from abstract and value type fields</span>
<span class="line-added">2577     MyAbstract abstractField1 = null;</span>
<span class="line-added">2578     MyAbstract abstractField2 = null;</span>
<span class="line-added">2579     MyAbstract abstractField3 = null;</span>
<span class="line-added">2580     MyAbstract abstractField4 = null;</span>
<span class="line-added">2581     MyAbstract abstractField5 = null;</span>
<span class="line-added">2582     MyAbstract abstractField6 = null;</span>
<span class="line-added">2583 </span>
<span class="line-added">2584     @DontInline</span>
<span class="line-added">2585     public MyAbstract readValueField5AsAbstract() {</span>
<span class="line-added">2586         return (MyAbstract)valueField5;</span>
<span class="line-added">2587     }</span>
<span class="line-added">2588 </span>
<span class="line-added">2589     @DontInline</span>
<span class="line-added">2590     public MyAbstract readStaticValueField4AsAbstract() {</span>
<span class="line-added">2591         return (MyAbstract)staticValueField4;</span>
<span class="line-added">2592     }</span>
<span class="line-added">2593 </span>
<span class="line-added">2594     @Test()</span>
<span class="line-added">2595     public long test98(MyValue1 vt1, MyAbstract vt2) {</span>
<span class="line-added">2596         abstractField1 = vt1;</span>
<span class="line-added">2597         abstractField2 = (MyValue1)vt2;</span>
<span class="line-added">2598         abstractField3 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2599         abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">2600         abstractField5 = valueField1;</span>
<span class="line-added">2601         abstractField6 = valueField3;</span>
<span class="line-added">2602         valueField1 = (MyValue1)abstractField1;</span>
<span class="line-added">2603         valueField2 = (MyValue1)vt2;</span>
<span class="line-added">2604         valueField3 = (MyValue1)vt2;</span>
<span class="line-added">2605         staticValueField1 = (MyValue1)abstractField1;</span>
<span class="line-added">2606         staticValueField2 = (MyValue1)vt1;</span>
<span class="line-added">2607         // Don&#39;t inline these methods because reading NULL will trigger a deoptimization</span>
<span class="line-added">2608         if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {</span>
<span class="line-added">2609             throw new RuntimeException(&quot;Should be null&quot;);</span>
<span class="line-added">2610         }</span>
<span class="line-added">2611         return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +</span>
<span class="line-added">2612                ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +</span>
<span class="line-added">2613                ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +</span>
<span class="line-added">2614                 valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +</span>
<span class="line-added">2615                 staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();</span>
<span class="line-added">2616     }</span>
<span class="line-added">2617 </span>
<span class="line-added">2618     @DontCompile</span>
<span class="line-added">2619     public void test98_verifier(boolean warmup) {</span>
<span class="line-added">2620         MyValue1 vt = testValue1;</span>
<span class="line-added">2621         MyValue1 def = MyValue1.createDefaultDontInline();</span>
<span class="line-added">2622         long result = test98(vt, vt);</span>
<span class="line-added">2623         Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());</span>
<span class="line-added">2624     }</span>
<span class="line-added">2625 </span>
<span class="line-added">2626     class MyObject2 extends MyAbstract {</span>
<span class="line-added">2627         public int x;</span>
<span class="line-added">2628 </span>
<span class="line-added">2629         public MyObject2(int x) {</span>
<span class="line-added">2630             this.x = x;</span>
<span class="line-added">2631         }</span>
<span class="line-added">2632 </span>
<span class="line-added">2633         @ForceInline</span>
<span class="line-added">2634         public long hash() {</span>
<span class="line-added">2635             return x;</span>
<span class="line-added">2636         }</span>
<span class="line-added">2637     }</span>
<span class="line-added">2638 </span>
<span class="line-added">2639     // Test merging value types and abstract classes</span>
<span class="line-added">2640     @Test()</span>
<span class="line-added">2641     public MyAbstract test99(int state) {</span>
<span class="line-added">2642         MyAbstract res = null;</span>
<span class="line-added">2643         if (state == 0) {</span>
<span class="line-added">2644             res = new MyObject2(rI);</span>
<span class="line-added">2645         } else if (state == 1) {</span>
<span class="line-added">2646             res = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2647         } else if (state == 2) {</span>
<span class="line-added">2648             res = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">2649         } else if (state == 3) {</span>
<span class="line-added">2650             res = (MyValue1)objectField1;</span>
<span class="line-added">2651         } else if (state == 4) {</span>
<span class="line-added">2652             res = valueField1;</span>
<span class="line-added">2653         } else if (state == 5) {</span>
<span class="line-added">2654             res = null;</span>
<span class="line-added">2655         }</span>
<span class="line-added">2656         return res;</span>
<span class="line-added">2657     }</span>
<span class="line-added">2658 </span>
<span class="line-added">2659     @DontCompile</span>
<span class="line-added">2660     public void test99_verifier(boolean warmup) {</span>
<span class="line-added">2661         objectField1 = valueField1;</span>
<span class="line-added">2662         MyAbstract result = null;</span>
<span class="line-added">2663         result = test99(0);</span>
<span class="line-added">2664         Asserts.assertEQ(((MyObject2)result).x, rI);</span>
<span class="line-added">2665         result = test99(1);</span>
<span class="line-added">2666         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">2667         result = test99(2);</span>
<span class="line-added">2668         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">2669         result = test99(3);</span>
<span class="line-added">2670         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">2671         result = test99(4);</span>
<span class="line-added">2672         Asserts.assertEQ(((MyValue1)result).hash(), hash());</span>
<span class="line-added">2673         result = test99(5);</span>
<span class="line-added">2674         Asserts.assertEQ(result, null);</span>
<span class="line-added">2675     }</span>
<span class="line-added">2676 </span>
<span class="line-added">2677     // Test merging value types and abstract classes in loops</span>
<span class="line-added">2678     @Test()</span>
<span class="line-added">2679     public MyAbstract test100(int iters) {</span>
<span class="line-added">2680         MyAbstract res = new MyObject2(rI);</span>
<span class="line-added">2681         for (int i = 0; i &lt; iters; ++i) {</span>
<span class="line-added">2682             if (res instanceof MyObject2) {</span>
<span class="line-added">2683                 res = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2684             } else {</span>
<span class="line-added">2685                 res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);</span>
<span class="line-added">2686             }</span>
<span class="line-added">2687         }</span>
<span class="line-added">2688         return res;</span>
<span class="line-added">2689     }</span>
<span class="line-added">2690 </span>
<span class="line-added">2691     @DontCompile</span>
<span class="line-added">2692     public void test100_verifier(boolean warmup) {</span>
<span class="line-added">2693         MyObject2 result1 = (MyObject2)test100(0);</span>
<span class="line-added">2694         Asserts.assertEQ(result1.x, rI);</span>
<span class="line-added">2695         int iters = (Math.abs(rI) % 10) + 1;</span>
<span class="line-added">2696         MyValue1 result2 = (MyValue1)test100(iters);</span>
<span class="line-added">2697         MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);</span>
<span class="line-added">2698         Asserts.assertEQ(result2.hash(), vt.hash());</span>
<span class="line-added">2699     }</span>
<span class="line-added">2700 </span>
<span class="line-added">2701     // Test value types in abstract class variables that are live at safepoint</span>
<span class="line-added">2702     @Test(failOn = ALLOC + STORE + LOOP)</span>
<span class="line-added">2703     public long test101(MyValue1 arg, boolean deopt) {</span>
<span class="line-added">2704         MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2705         MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-added">2706         MyAbstract vt3 = arg;</span>
<span class="line-added">2707         MyAbstract vt4 = valueField1;</span>
<span class="line-added">2708         if (deopt) {</span>
<span class="line-added">2709             // uncommon trap</span>
<span class="line-added">2710             WHITE_BOX.deoptimizeMethod(tests.get(getClass().getSimpleName() + &quot;::test101&quot;));</span>
<span class="line-added">2711         }</span>
<span class="line-added">2712         return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +</span>
<span class="line-added">2713                ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();</span>
<span class="line-added">2714     }</span>
<span class="line-added">2715 </span>
<span class="line-added">2716     @DontCompile</span>
<span class="line-added">2717     public void test101_verifier(boolean warmup) {</span>
<span class="line-added">2718         long result = test101(valueField1, !warmup);</span>
<span class="line-added">2719         Asserts.assertEQ(result, 4*hash());</span>
<span class="line-added">2720     }</span>
<span class="line-added">2721 </span>
<span class="line-added">2722     // Test comparing value types with abstract classes</span>
<span class="line-added">2723     @Test(failOn = LOAD + LOOP)</span>
<span class="line-added">2724     public boolean test102(Object arg) {</span>
<span class="line-added">2725         MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-added">2726         if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||</span>
<span class="line-added">2727             arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {</span>
<span class="line-added">2728             return true;</span>
<span class="line-added">2729         }</span>
<span class="line-added">2730         return false;</span>
<span class="line-added">2731     }</span>
<span class="line-added">2732 </span>
<span class="line-added">2733     @DontCompile</span>
<span class="line-added">2734     public void test102_verifier(boolean warmup) {</span>
<span class="line-added">2735         boolean result = test102(null);</span>
<span class="line-added">2736         Asserts.assertFalse(result);</span>
<span class="line-added">2737     }</span>
<span class="line-added">2738 </span>
<span class="line-added">2739     // An abstract class with a non-static field can never be implemented by a value type</span>
<span class="line-added">2740     abstract class NoValueImplementors1 {</span>
<span class="line-added">2741         int field = 42;</span>
<span class="line-added">2742     }</span>
<span class="line-added">2743 </span>
<span class="line-added">2744     class MyObject3 extends NoValueImplementors1 {</span>
<span class="line-added">2745 </span>
<span class="line-added">2746     }</span>
<span class="line-added">2747 </span>
<span class="line-added">2748     class MyObject4 extends NoValueImplementors1 {</span>
<span class="line-added">2749 </span>
<span class="line-added">2750     }</span>
<span class="line-added">2751 </span>
<span class="line-added">2752     // Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field</span>
<span class="line-added">2753     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">2754     public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {</span>
<span class="line-added">2755         return array[i];</span>
<span class="line-added">2756     }</span>
<span class="line-added">2757 </span>
<span class="line-added">2758     @DontCompile</span>
<span class="line-added">2759     public void test103_verifier(boolean warmup) {</span>
<span class="line-added">2760         NoValueImplementors1[] array1 = new NoValueImplementors1[3];</span>
<span class="line-added">2761         MyObject3[] array2 = new MyObject3[3];</span>
<span class="line-added">2762         MyObject4[] array3 = new MyObject4[3];</span>
<span class="line-added">2763         NoValueImplementors1 result = test103(array1, 0);</span>
<span class="line-added">2764         Asserts.assertEquals(result, array1[0]);</span>
<span class="line-added">2765 </span>
<span class="line-added">2766         result = test103(array2, 1);</span>
<span class="line-added">2767         Asserts.assertEquals(result, array1[1]);</span>
<span class="line-added">2768 </span>
<span class="line-added">2769         result = test103(array3, 2);</span>
<span class="line-added">2770         Asserts.assertEquals(result, array1[2]);</span>
<span class="line-added">2771     }</span>
<span class="line-added">2772 </span>
<span class="line-added">2773     // Storing to an abstract class array does not require a flatness/null check if the abstract class has a non-static field</span>
<span class="line-added">2774     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">2775     public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {</span>
<span class="line-added">2776         array[0] = v;</span>
<span class="line-added">2777         array[1] = array[0];</span>
<span class="line-added">2778         array[2] = o;</span>
<span class="line-added">2779         return array[i];</span>
<span class="line-added">2780     }</span>
<span class="line-added">2781 </span>
<span class="line-added">2782     @DontCompile</span>
<span class="line-added">2783     public void test104_verifier(boolean warmup) {</span>
<span class="line-added">2784         MyObject4 v = new MyObject4();</span>
<span class="line-added">2785         MyObject3 o = new MyObject3();</span>
<span class="line-added">2786         NoValueImplementors1[] array1 = new NoValueImplementors1[3];</span>
<span class="line-added">2787         MyObject3[] array2 = new MyObject3[3];</span>
<span class="line-added">2788         MyObject4[] array3 = new MyObject4[3];</span>
<span class="line-added">2789         NoValueImplementors1 result = test104(array1, v, o, 0);</span>
<span class="line-added">2790         Asserts.assertEquals(array1[0], v);</span>
<span class="line-added">2791         Asserts.assertEquals(array1[1], v);</span>
<span class="line-added">2792         Asserts.assertEquals(array1[2], o);</span>
<span class="line-added">2793         Asserts.assertEquals(result, v);</span>
<span class="line-added">2794 </span>
<span class="line-added">2795         result = test104(array2, o, o, 1);</span>
<span class="line-added">2796         Asserts.assertEquals(array2[0], o);</span>
<span class="line-added">2797         Asserts.assertEquals(array2[1], o);</span>
<span class="line-added">2798         Asserts.assertEquals(array2[2], o);</span>
<span class="line-added">2799         Asserts.assertEquals(result, o);</span>
<span class="line-added">2800 </span>
<span class="line-added">2801         result = test104(array3, v, null, 1);</span>
<span class="line-added">2802         Asserts.assertEquals(array3[0], v);</span>
<span class="line-added">2803         Asserts.assertEquals(array3[1], v);</span>
<span class="line-added">2804         Asserts.assertEquals(array3[2], null);</span>
<span class="line-added">2805         Asserts.assertEquals(result, v);</span>
<span class="line-added">2806     }</span>
<span class="line-added">2807 </span>
<span class="line-added">2808     // An abstract class with a single, non-value implementor</span>
<span class="line-added">2809     abstract class NoValueImplementors2 {</span>
<span class="line-added">2810 </span>
<span class="line-added">2811     }</span>
<span class="line-added">2812 </span>
<span class="line-added">2813     class MyObject5 extends NoValueImplementors2 {</span>
<span class="line-added">2814 </span>
<span class="line-added">2815     }</span>
<span class="line-added">2816 </span>
<span class="line-added">2817     // Loading from an abstract class array does not require a flatness check if the abstract class has no value implementor</span>
<span class="line-added">2818     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">2819     public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {</span>
<span class="line-added">2820         return array[i];</span>
<span class="line-added">2821     }</span>
<span class="line-added">2822 </span>
<span class="line-added">2823     @DontCompile</span>
<span class="line-added">2824     public void test105_verifier(boolean warmup) {</span>
<span class="line-added">2825         NoValueImplementors2[] array1 = new NoValueImplementors2[3];</span>
<span class="line-added">2826         MyObject5[] array2 = new MyObject5[3];</span>
<span class="line-added">2827         NoValueImplementors2 result = test105(array1, 0);</span>
<span class="line-added">2828         Asserts.assertEquals(result, array1[0]);</span>
<span class="line-added">2829 </span>
<span class="line-added">2830         result = test105(array2, 1);</span>
<span class="line-added">2831         Asserts.assertEquals(result, array1[1]);</span>
<span class="line-added">2832     }</span>
<span class="line-added">2833 </span>
<span class="line-added">2834     // Storing to an abstract class array does not require a flatness/null check if the abstract class has no value implementor</span>
<span class="line-added">2835     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)</span>
<span class="line-added">2836     public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {</span>
<span class="line-added">2837         array[0] = v;</span>
<span class="line-added">2838         array[1] = array[0];</span>
<span class="line-added">2839         array[2] = o;</span>
<span class="line-added">2840         return array[i];</span>
<span class="line-added">2841     }</span>
<span class="line-added">2842 </span>
<span class="line-added">2843     @DontCompile</span>
<span class="line-added">2844     public void test106_verifier(boolean warmup) {</span>
<span class="line-added">2845         MyObject5 v = new MyObject5();</span>
<span class="line-added">2846         NoValueImplementors2[] array1 = new NoValueImplementors2[3];</span>
<span class="line-added">2847         MyObject5[] array2 = new MyObject5[3];</span>
<span class="line-added">2848         NoValueImplementors2 result = test106(array1, v, null, 0);</span>
<span class="line-added">2849         Asserts.assertEquals(array1[0], v);</span>
<span class="line-added">2850         Asserts.assertEquals(array1[1], v);</span>
<span class="line-added">2851         Asserts.assertEquals(array1[2], null);</span>
<span class="line-added">2852         Asserts.assertEquals(result, v);</span>
<span class="line-added">2853 </span>
<span class="line-added">2854         result = test106(array2, v, v, 1);</span>
<span class="line-added">2855         Asserts.assertEquals(array2[0], v);</span>
<span class="line-added">2856         Asserts.assertEquals(array2[1], v);</span>
<span class="line-added">2857         Asserts.assertEquals(array2[2], v);</span>
<span class="line-added">2858         Asserts.assertEquals(result, v);</span>
<span class="line-added">2859     }</span>
2860 }
</pre>
</td>
</tr>
</table>
<center><a href="TestIntrinsics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
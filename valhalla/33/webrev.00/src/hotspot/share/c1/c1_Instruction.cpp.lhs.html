<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_Instruction.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_IR.hpp&quot;
  27 #include &quot;c1/c1_Instruction.hpp&quot;
  28 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  31 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  32 #include &quot;ci/ciValueArrayKlass.hpp&quot;
  33 #include &quot;ci/ciValueKlass.hpp&quot;
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 
  36 
  37 // Implementation of Instruction
  38 
  39 
  40 int Instruction::dominator_depth() {
  41   int result = -1;
  42   if (block()) {
  43     result = block()-&gt;dominator_depth();
  44   }
  45   assert(result != -1 || this-&gt;as_Local(), &quot;Only locals have dominator depth -1&quot;);
  46   return result;
  47 }
  48 
  49 Instruction::Condition Instruction::mirror(Condition cond) {
  50   switch (cond) {
  51     case eql: return eql;
  52     case neq: return neq;
  53     case lss: return gtr;
  54     case leq: return geq;
  55     case gtr: return lss;
  56     case geq: return leq;
  57     case aeq: return beq;
  58     case beq: return aeq;
  59   }
  60   ShouldNotReachHere();
  61   return eql;
  62 }
  63 
  64 
  65 Instruction::Condition Instruction::negate(Condition cond) {
  66   switch (cond) {
  67     case eql: return neq;
  68     case neq: return eql;
  69     case lss: return geq;
  70     case leq: return gtr;
  71     case gtr: return leq;
  72     case geq: return lss;
  73     case aeq: assert(false, &quot;Above equal cannot be negated&quot;);
  74     case beq: assert(false, &quot;Below equal cannot be negated&quot;);
  75   }
  76   ShouldNotReachHere();
  77   return eql;
  78 }
  79 
  80 void Instruction::update_exception_state(ValueStack* state) {
  81   if (state != NULL &amp;&amp; (state-&gt;kind() == ValueStack::EmptyExceptionState || state-&gt;kind() == ValueStack::ExceptionState)) {
  82     assert(state-&gt;kind() == ValueStack::EmptyExceptionState || Compilation::current()-&gt;env()-&gt;should_retain_local_variables(), &quot;unexpected state kind&quot;);
  83     _exception_state = state;
  84   } else {
  85     _exception_state = NULL;
  86   }
  87 }
  88 
  89 // Prev without need to have BlockBegin
  90 Instruction* Instruction::prev() {
  91   Instruction* p = NULL;
  92   Instruction* q = block();
  93   while (q != this) {
  94     assert(q != NULL, &quot;this is not in the block&#39;s instruction list&quot;);
  95     p = q; q = q-&gt;next();
  96   }
  97   return p;
  98 }
  99 
 100 
 101 void Instruction::state_values_do(ValueVisitor* f) {
 102   if (state_before() != NULL) {
 103     state_before()-&gt;values_do(f);
 104   }
 105   if (exception_state() != NULL){
 106     exception_state()-&gt;values_do(f);
 107   }
 108 }
 109 
 110 ciType* Instruction::exact_type() const {
 111   ciType* t =  declared_type();
 112   if (t != NULL &amp;&amp; t-&gt;is_klass()) {
 113     return t-&gt;as_klass()-&gt;exact_klass();
 114   }
 115   return NULL;
 116 }
 117 
 118 ciKlass* Instruction::as_loaded_klass_or_null() const {
 119   ciType* type = declared_type();
 120   if (type != NULL &amp;&amp; type-&gt;is_klass()) {
 121     ciKlass* klass = type-&gt;as_klass();
 122     if (klass-&gt;is_loaded()) {
 123       return klass;
 124     }
 125   }
 126   return NULL;
 127 }
 128 
 129 bool Instruction::is_loaded_flattened_array() const {
 130   if (ValueArrayFlatten) {
 131     ciType* type = declared_type();
 132     if (type != NULL &amp;&amp; type-&gt;is_value_array_klass()) {
 133       ciValueArrayKlass* vak = type-&gt;as_value_array_klass();
 134       ArrayStorageProperties props = vak-&gt;storage_properties();
 135       return (!props.is_empty() &amp;&amp; props.is_null_free() &amp;&amp; props.is_flattened());
 136     }
 137   }
 138 
 139   return false;
 140 }
 141 
 142 bool Instruction::maybe_flattened_array() {
 143   if (ValueArrayFlatten) {
 144     ciType* type = declared_type();
 145     if (type != NULL) {
 146       if (type-&gt;is_obj_array_klass()) {
<a name="1" id="anc1"></a><span class="line-modified"> 147         // Check for array covariance. One of the following declared types may be a flattened array:</span>
 148         ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
<a name="2" id="anc2"></a><span class="line-modified"> 149         if (!element_klass-&gt;is_loaded() ||</span>
<span class="line-removed"> 150             element_klass-&gt;is_java_lang_Object() ||                                                // (ValueType[] &lt;: Object[])</span>
<span class="line-removed"> 151             element_klass-&gt;is_interface() ||                                                       // (ValueType[] &lt;: &lt;any interface&gt;[])</span>
<span class="line-removed"> 152             (element_klass-&gt;is_valuetype() &amp;&amp; element_klass-&gt;as_value_klass()-&gt;flatten_array())) { // (ValueType[] &lt;: ValueType?[])</span>
 153           // We will add a runtime check for flat-ness.
 154           return true;
 155         }
 156       } else if (type-&gt;is_value_array_klass()) {
 157         ciKlass* element_klass = type-&gt;as_value_array_klass()-&gt;element_klass();
 158         if (!element_klass-&gt;is_loaded() ||
<a name="3" id="anc3"></a><span class="line-modified"> 159             (element_klass-&gt;is_valuetype() &amp;&amp; element_klass-&gt;as_value_klass()-&gt;flatten_array())) { // (ValueType[] &lt;: ValueType?[])</span>
 160           // We will add a runtime check for flat-ness.
 161           return true;
 162         }
 163       } else if (type-&gt;is_klass() &amp;&amp; type-&gt;as_klass()-&gt;is_java_lang_Object()) {
 164         // This can happen as a parameter to System.arraycopy()
 165         return true;
 166       }
 167     } else {
 168       // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
 169       // flattened array, so we should do a runtime check.
 170       return true;
 171     }
 172   }
<a name="4" id="anc4"></a><span class="line-removed"> 173 </span>
 174   return false;
 175 }
 176 
 177 bool Instruction::maybe_null_free_array() {
 178   ciType* type = declared_type();
 179   if (type != NULL) {
 180     if (type-&gt;is_obj_array_klass()) {
<a name="5" id="anc5"></a><span class="line-modified"> 181       // Check for array covariance. One of the following declared types may be a null-free array:</span>
 182       ciKlass* element_klass = type-&gt;as_obj_array_klass()-&gt;element_klass();
<a name="6" id="anc6"></a><span class="line-modified"> 183       if (!element_klass-&gt;is_loaded() ||</span>
<span class="line-modified"> 184           element_klass-&gt;is_java_lang_Object() ||   // (ValueType[] &lt;: Object[])</span>
<span class="line-removed"> 185           element_klass-&gt;is_interface() ||          // (ValueType[] &lt;: &lt;any interface&gt;[])</span>
<span class="line-removed"> 186           element_klass-&gt;is_valuetype()) {          // (ValueType[] &lt;: ValueType?[])</span>
<span class="line-removed"> 187           // We will add a runtime check for flat-ness.</span>
 188           return true;
 189       }
 190     }
 191   } else {
 192     // Type info gets lost during Phi merging (Phi, IfOp, etc), but we might be storing into a
<a name="7" id="anc7"></a><span class="line-modified"> 193     // flattened array, so we should do a runtime check.</span>
 194     return true;
 195   }
<a name="8" id="anc8"></a><span class="line-removed"> 196 </span>
 197   return false;
 198 }
 199 
 200 #ifndef PRODUCT
 201 void Instruction::check_state(ValueStack* state) {
 202   if (state != NULL) {
 203     state-&gt;verify();
 204   }
 205 }
 206 
 207 
 208 void Instruction::print() {
 209   InstructionPrinter ip;
 210   print(ip);
 211 }
 212 
 213 
 214 void Instruction::print_line() {
 215   InstructionPrinter ip;
 216   ip.print_line(this);
 217 }
 218 
 219 
 220 void Instruction::print(InstructionPrinter&amp; ip) {
 221   ip.print_head();
 222   ip.print_line(this);
 223   tty-&gt;cr();
 224 }
 225 #endif // PRODUCT
 226 
 227 
 228 // perform constant and interval tests on index value
 229 bool AccessIndexed::compute_needs_range_check() {
 230   if (length()) {
 231     Constant* clength = length()-&gt;as_Constant();
 232     Constant* cindex = index()-&gt;as_Constant();
 233     if (clength &amp;&amp; cindex) {
 234       IntConstant* l = clength-&gt;type()-&gt;as_IntConstant();
 235       IntConstant* i = cindex-&gt;type()-&gt;as_IntConstant();
 236       if (l &amp;&amp; i &amp;&amp; i-&gt;value() &lt; l-&gt;value() &amp;&amp; i-&gt;value() &gt;= 0) {
 237         return false;
 238       }
 239     }
 240   }
 241 
 242   if (!this-&gt;check_flag(NeedsRangeCheckFlag)) {
 243     return false;
 244   }
 245 
 246   return true;
 247 }
 248 
 249 
 250 ciType* Constant::exact_type() const {
 251   if (type()-&gt;is_object() &amp;&amp; type()-&gt;as_ObjectType()-&gt;is_loaded()) {
 252     return type()-&gt;as_ObjectType()-&gt;exact_type();
 253   }
 254   return NULL;
 255 }
 256 
 257 ciType* LoadIndexed::exact_type() const {
 258   ciType* array_type = array()-&gt;exact_type();
 259   if (array_type != NULL) {
 260     assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 261     ciArrayKlass* ak = (ciArrayKlass*)array_type;
 262 
 263     if (ak-&gt;element_type()-&gt;is_instance_klass()) {
 264       ciInstanceKlass* ik = (ciInstanceKlass*)ak-&gt;element_type();
 265       if (ik-&gt;is_loaded() &amp;&amp; ik-&gt;is_final()) {
 266         return ik;
 267       }
 268     }
 269   }
 270   return Instruction::exact_type();
 271 }
 272 
 273 
 274 ciType* LoadIndexed::declared_type() const {
 275   ciType* array_type = array()-&gt;declared_type();
 276   if (array_type == NULL || !array_type-&gt;is_loaded()) {
 277     return NULL;
 278   }
 279   assert(array_type-&gt;is_array_klass(), &quot;what else?&quot;);
 280   ciArrayKlass* ak = (ciArrayKlass*)array_type;
 281   return ak-&gt;element_type();
 282 }
 283 
 284 bool StoreIndexed::is_exact_flattened_array_store() const {
 285   if (array()-&gt;is_loaded_flattened_array() &amp;&amp; value()-&gt;as_Constant() == NULL &amp;&amp; value()-&gt;declared_type() != NULL) {
 286     ciKlass* element_klass = array()-&gt;declared_type()-&gt;as_value_array_klass()-&gt;element_klass();
 287     ciKlass* actual_klass = value()-&gt;declared_type()-&gt;as_klass();
 288 
 289     // The following check can fail with inlining:
 290     //     void test45_inline(Object[] oa, Object o, int index) { oa[index] = o; }
 291     //     void test45(MyValue1[] va, int index, MyValue2 v) { test45_inline(va, v, index); }
 292     if (element_klass == actual_klass) {
 293       return true;
 294     }
 295   }
 296   return false;
 297 }
 298 
 299 ciType* LoadField::declared_type() const {
 300   return field()-&gt;type();
 301 }
 302 
 303 
 304 ciType* NewTypeArray::exact_type() const {
 305   return ciTypeArrayKlass::make(elt_type());
 306 }
 307 
 308 ciType* NewObjectArray::exact_type() const {
 309   ciKlass* element_klass = klass();
 310   if (is_never_null() &amp;&amp; element_klass-&gt;is_valuetype()) {
 311     if (element_klass-&gt;as_value_klass()-&gt;flatten_array()) {
 312       return ciValueArrayKlass::make(element_klass);
 313     } else {
 314       return ciObjArrayKlass::make(element_klass, /*never_null =*/true);
 315     }
 316   } else {
 317     return ciObjArrayKlass::make(element_klass);
 318   }
 319 }
 320 
 321 ciType* NewMultiArray::exact_type() const {
 322   return _klass;
 323 }
 324 
 325 ciType* NewArray::declared_type() const {
 326   return exact_type();
 327 }
 328 
 329 ciType* NewInstance::exact_type() const {
 330   return klass();
 331 }
 332 
 333 ciType* NewInstance::declared_type() const {
 334   return exact_type();
 335 }
 336 
 337 Value NewValueTypeInstance::depends_on() {
 338   if (_depends_on != this) {
 339     if (_depends_on-&gt;as_NewValueTypeInstance() != NULL) {
 340       return _depends_on-&gt;as_NewValueTypeInstance()-&gt;depends_on();
 341     }
 342   }
 343   return _depends_on;
 344 }
 345 
 346 ciType* NewValueTypeInstance::exact_type() const {
 347   return klass();
 348 }
 349 
 350 ciType* NewValueTypeInstance::declared_type() const {
 351   return exact_type();
 352 }
 353 
 354 ciType* CheckCast::declared_type() const {
 355   return klass();
 356 }
 357 
 358 // Implementation of ArithmeticOp
 359 
 360 bool ArithmeticOp::is_commutative() const {
 361   switch (op()) {
 362     case Bytecodes::_iadd: // fall through
 363     case Bytecodes::_ladd: // fall through
 364     case Bytecodes::_fadd: // fall through
 365     case Bytecodes::_dadd: // fall through
 366     case Bytecodes::_imul: // fall through
 367     case Bytecodes::_lmul: // fall through
 368     case Bytecodes::_fmul: // fall through
 369     case Bytecodes::_dmul: return true;
 370     default              : return false;
 371   }
 372 }
 373 
 374 
 375 bool ArithmeticOp::can_trap() const {
 376   switch (op()) {
 377     case Bytecodes::_idiv: // fall through
 378     case Bytecodes::_ldiv: // fall through
 379     case Bytecodes::_irem: // fall through
 380     case Bytecodes::_lrem: return true;
 381     default              : return false;
 382   }
 383 }
 384 
 385 
 386 // Implementation of LogicOp
 387 
 388 bool LogicOp::is_commutative() const {
 389 #ifdef ASSERT
 390   switch (op()) {
 391     case Bytecodes::_iand: // fall through
 392     case Bytecodes::_land: // fall through
 393     case Bytecodes::_ior : // fall through
 394     case Bytecodes::_lor : // fall through
 395     case Bytecodes::_ixor: // fall through
 396     case Bytecodes::_lxor: break;
 397     default              : ShouldNotReachHere(); break;
 398   }
 399 #endif
 400   // all LogicOps are commutative
 401   return true;
 402 }
 403 
 404 
 405 // Implementation of IfOp
 406 
 407 bool IfOp::is_commutative() const {
 408   return cond() == eql || cond() == neq;
 409 }
 410 
 411 
 412 // Implementation of StateSplit
 413 
 414 void StateSplit::substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block) {
 415   NOT_PRODUCT(bool assigned = false;)
 416   for (int i = 0; i &lt; list.length(); i++) {
 417     BlockBegin** b = list.adr_at(i);
 418     if (*b == old_block) {
 419       *b = new_block;
 420       NOT_PRODUCT(assigned = true;)
 421     }
 422   }
 423   assert(assigned == true, &quot;should have assigned at least once&quot;);
 424 }
 425 
 426 
 427 IRScope* StateSplit::scope() const {
 428   return _state-&gt;scope();
 429 }
 430 
 431 
 432 void StateSplit::state_values_do(ValueVisitor* f) {
 433   Instruction::state_values_do(f);
 434   if (state() != NULL) state()-&gt;values_do(f);
 435 }
 436 
 437 
 438 void BlockBegin::state_values_do(ValueVisitor* f) {
 439   StateSplit::state_values_do(f);
 440 
 441   if (is_set(BlockBegin::exception_entry_flag)) {
 442     for (int i = 0; i &lt; number_of_exception_states(); i++) {
 443       exception_state_at(i)-&gt;values_do(f);
 444     }
 445   }
 446 }
 447 
 448 
 449 // Implementation of Invoke
 450 
 451 
 452 Invoke::Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
 453                int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null)
 454   : StateSplit(result_type, state_before)
 455   , _code(code)
 456   , _recv(recv)
 457   , _args(args)
 458   , _vtable_index(vtable_index)
 459   , _target(target)
 460 {
 461   set_flag(TargetIsLoadedFlag,   target-&gt;is_loaded());
 462   set_flag(TargetIsFinalFlag,    target_is_loaded() &amp;&amp; target-&gt;is_final_method());
 463   set_flag(TargetIsStrictfpFlag, target_is_loaded() &amp;&amp; target-&gt;is_strict());
 464   set_never_null(never_null);
 465 
 466   assert(args != NULL, &quot;args must exist&quot;);
 467 #ifdef ASSERT
 468   AssertValues assert_value;
 469   values_do(&amp;assert_value);
 470 #endif
 471 
 472   // provide an initial guess of signature size.
 473   _signature = new BasicTypeList(number_of_arguments() + (has_receiver() ? 1 : 0));
 474   if (has_receiver()) {
 475     _signature-&gt;append(as_BasicType(receiver()-&gt;type()));
 476   }
 477   for (int i = 0; i &lt; number_of_arguments(); i++) {
 478     ValueType* t = argument_at(i)-&gt;type();
 479     BasicType bt = as_BasicType(t);
 480     _signature-&gt;append(bt);
 481   }
 482 }
 483 
 484 
 485 void Invoke::state_values_do(ValueVisitor* f) {
 486   StateSplit::state_values_do(f);
 487   if (state_before() != NULL) state_before()-&gt;values_do(f);
 488   if (state()        != NULL) state()-&gt;values_do(f);
 489 }
 490 
 491 ciType* Invoke::declared_type() const {
 492   ciSignature* declared_signature = state()-&gt;scope()-&gt;method()-&gt;get_declared_signature_at_bci(state()-&gt;bci());
 493   ciType *t = declared_signature-&gt;return_type();
 494   assert(t-&gt;basic_type() != T_VOID, &quot;need return value of void method?&quot;);
 495   return t;
 496 }
 497 
 498 // Implementation of Contant
 499 intx Constant::hash() const {
 500   if (state_before() == NULL) {
 501     switch (type()-&gt;tag()) {
 502     case intTag:
 503       return HASH2(name(), type()-&gt;as_IntConstant()-&gt;value());
 504     case addressTag:
 505       return HASH2(name(), type()-&gt;as_AddressConstant()-&gt;value());
 506     case longTag:
 507       {
 508         jlong temp = type()-&gt;as_LongConstant()-&gt;value();
 509         return HASH3(name(), high(temp), low(temp));
 510       }
 511     case floatTag:
 512       return HASH2(name(), jint_cast(type()-&gt;as_FloatConstant()-&gt;value()));
 513     case doubleTag:
 514       {
 515         jlong temp = jlong_cast(type()-&gt;as_DoubleConstant()-&gt;value());
 516         return HASH3(name(), high(temp), low(temp));
 517       }
 518     case objectTag:
 519       assert(type()-&gt;as_ObjectType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 520       return HASH2(name(), type()-&gt;as_ObjectType()-&gt;constant_value());
 521     case metaDataTag:
 522       assert(type()-&gt;as_MetadataType()-&gt;is_loaded(), &quot;can&#39;t handle unloaded values&quot;);
 523       return HASH2(name(), type()-&gt;as_MetadataType()-&gt;constant_value());
 524     default:
 525       ShouldNotReachHere();
 526     }
 527   }
 528   return 0;
 529 }
 530 
 531 bool Constant::is_equal(Value v) const {
 532   if (v-&gt;as_Constant() == NULL) return false;
 533 
 534   switch (type()-&gt;tag()) {
 535     case intTag:
 536       {
 537         IntConstant* t1 =    type()-&gt;as_IntConstant();
 538         IntConstant* t2 = v-&gt;type()-&gt;as_IntConstant();
 539         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 540                 t1-&gt;value() == t2-&gt;value());
 541       }
 542     case longTag:
 543       {
 544         LongConstant* t1 =    type()-&gt;as_LongConstant();
 545         LongConstant* t2 = v-&gt;type()-&gt;as_LongConstant();
 546         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 547                 t1-&gt;value() == t2-&gt;value());
 548       }
 549     case floatTag:
 550       {
 551         FloatConstant* t1 =    type()-&gt;as_FloatConstant();
 552         FloatConstant* t2 = v-&gt;type()-&gt;as_FloatConstant();
 553         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 554                 jint_cast(t1-&gt;value()) == jint_cast(t2-&gt;value()));
 555       }
 556     case doubleTag:
 557       {
 558         DoubleConstant* t1 =    type()-&gt;as_DoubleConstant();
 559         DoubleConstant* t2 = v-&gt;type()-&gt;as_DoubleConstant();
 560         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 561                 jlong_cast(t1-&gt;value()) == jlong_cast(t2-&gt;value()));
 562       }
 563     case objectTag:
 564       {
 565         ObjectType* t1 =    type()-&gt;as_ObjectType();
 566         ObjectType* t2 = v-&gt;type()-&gt;as_ObjectType();
 567         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 568                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 569                 t1-&gt;constant_value() == t2-&gt;constant_value());
 570       }
 571     case metaDataTag:
 572       {
 573         MetadataType* t1 =    type()-&gt;as_MetadataType();
 574         MetadataType* t2 = v-&gt;type()-&gt;as_MetadataType();
 575         return (t1 != NULL &amp;&amp; t2 != NULL &amp;&amp;
 576                 t1-&gt;is_loaded() &amp;&amp; t2-&gt;is_loaded() &amp;&amp;
 577                 t1-&gt;constant_value() == t2-&gt;constant_value());
 578       }
 579     default:
 580       return false;
 581   }
 582 }
 583 
 584 Constant::CompareResult Constant::compare(Instruction::Condition cond, Value right) const {
 585   Constant* rc = right-&gt;as_Constant();
 586   // other is not a constant
 587   if (rc == NULL) return not_comparable;
 588 
 589   ValueType* lt = type();
 590   ValueType* rt = rc-&gt;type();
 591   // different types
 592   if (lt-&gt;base() != rt-&gt;base()) return not_comparable;
 593   switch (lt-&gt;tag()) {
 594   case intTag: {
 595     int x = lt-&gt;as_IntConstant()-&gt;value();
 596     int y = rt-&gt;as_IntConstant()-&gt;value();
 597     switch (cond) {
 598     case If::eql: return x == y ? cond_true : cond_false;
 599     case If::neq: return x != y ? cond_true : cond_false;
 600     case If::lss: return x &lt;  y ? cond_true : cond_false;
 601     case If::leq: return x &lt;= y ? cond_true : cond_false;
 602     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 603     case If::geq: return x &gt;= y ? cond_true : cond_false;
 604     default     : break;
 605     }
 606     break;
 607   }
 608   case longTag: {
 609     jlong x = lt-&gt;as_LongConstant()-&gt;value();
 610     jlong y = rt-&gt;as_LongConstant()-&gt;value();
 611     switch (cond) {
 612     case If::eql: return x == y ? cond_true : cond_false;
 613     case If::neq: return x != y ? cond_true : cond_false;
 614     case If::lss: return x &lt;  y ? cond_true : cond_false;
 615     case If::leq: return x &lt;= y ? cond_true : cond_false;
 616     case If::gtr: return x &gt;  y ? cond_true : cond_false;
 617     case If::geq: return x &gt;= y ? cond_true : cond_false;
 618     default     : break;
 619     }
 620     break;
 621   }
 622   case objectTag: {
 623     ciObject* xvalue = lt-&gt;as_ObjectType()-&gt;constant_value();
 624     ciObject* yvalue = rt-&gt;as_ObjectType()-&gt;constant_value();
 625     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 626     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 627       switch (cond) {
 628       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 629       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 630       default     : break;
 631       }
 632     }
 633     break;
 634   }
 635   case metaDataTag: {
 636     ciMetadata* xvalue = lt-&gt;as_MetadataType()-&gt;constant_value();
 637     ciMetadata* yvalue = rt-&gt;as_MetadataType()-&gt;constant_value();
 638     assert(xvalue != NULL &amp;&amp; yvalue != NULL, &quot;not constants&quot;);
 639     if (xvalue-&gt;is_loaded() &amp;&amp; yvalue-&gt;is_loaded()) {
 640       switch (cond) {
 641       case If::eql: return xvalue == yvalue ? cond_true : cond_false;
 642       case If::neq: return xvalue != yvalue ? cond_true : cond_false;
 643       default     : break;
 644       }
 645     }
 646     break;
 647   }
 648   default:
 649     break;
 650   }
 651   return not_comparable;
 652 }
 653 
 654 
 655 // Implementation of BlockBegin
 656 
 657 void BlockBegin::set_end(BlockEnd* end) {
 658   assert(end != NULL, &quot;should not reset block end to NULL&quot;);
 659   if (end == _end) {
 660     return;
 661   }
 662   clear_end();
 663 
 664   // Set the new end
 665   _end = end;
 666 
 667   _successors.clear();
 668   // Now reset successors list based on BlockEnd
 669   for (int i = 0; i &lt; end-&gt;number_of_sux(); i++) {
 670     BlockBegin* sux = end-&gt;sux_at(i);
 671     _successors.append(sux);
 672     sux-&gt;_predecessors.append(this);
 673   }
 674   _end-&gt;set_begin(this);
 675 }
 676 
 677 
 678 void BlockBegin::clear_end() {
 679   // Must make the predecessors/successors match up with the
 680   // BlockEnd&#39;s notion.
 681   if (_end != NULL) {
 682     // disconnect from the old end
 683     _end-&gt;set_begin(NULL);
 684 
 685     // disconnect this block from it&#39;s current successors
 686     for (int i = 0; i &lt; _successors.length(); i++) {
 687       _successors.at(i)-&gt;remove_predecessor(this);
 688     }
 689     _end = NULL;
 690   }
 691 }
 692 
 693 
 694 void BlockBegin::disconnect_edge(BlockBegin* from, BlockBegin* to) {
 695   // disconnect any edges between from and to
 696 #ifndef PRODUCT
 697   if (PrintIR &amp;&amp; Verbose) {
 698     tty-&gt;print_cr(&quot;Disconnected edge B%d -&gt; B%d&quot;, from-&gt;block_id(), to-&gt;block_id());
 699   }
 700 #endif
 701   for (int s = 0; s &lt; from-&gt;number_of_sux();) {
 702     BlockBegin* sux = from-&gt;sux_at(s);
 703     if (sux == to) {
 704       int index = sux-&gt;_predecessors.find(from);
 705       if (index &gt;= 0) {
 706         sux-&gt;_predecessors.remove_at(index);
 707       }
 708       from-&gt;_successors.remove_at(s);
 709     } else {
 710       s++;
 711     }
 712   }
 713 }
 714 
 715 
 716 void BlockBegin::disconnect_from_graph() {
 717   // disconnect this block from all other blocks
 718   for (int p = 0; p &lt; number_of_preds(); p++) {
 719     pred_at(p)-&gt;remove_successor(this);
 720   }
 721   for (int s = 0; s &lt; number_of_sux(); s++) {
 722     sux_at(s)-&gt;remove_predecessor(this);
 723   }
 724 }
 725 
 726 void BlockBegin::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
 727   // modify predecessors before substituting successors
 728   for (int i = 0; i &lt; number_of_sux(); i++) {
 729     if (sux_at(i) == old_sux) {
 730       // remove old predecessor before adding new predecessor
 731       // otherwise there is a dead predecessor in the list
 732       new_sux-&gt;remove_predecessor(old_sux);
 733       new_sux-&gt;add_predecessor(this);
 734     }
 735   }
 736   old_sux-&gt;remove_predecessor(this);
 737   end()-&gt;substitute_sux(old_sux, new_sux);
 738 }
 739 
 740 
 741 
 742 // In general it is not possible to calculate a value for the field &quot;depth_first_number&quot;
 743 // of the inserted block, without recomputing the values of the other blocks
 744 // in the CFG. Therefore the value of &quot;depth_first_number&quot; in BlockBegin becomes meaningless.
 745 BlockBegin* BlockBegin::insert_block_between(BlockBegin* sux) {
 746   int bci = sux-&gt;bci();
 747   // critical edge splitting may introduce a goto after a if and array
 748   // bound check elimination may insert a predicate between the if and
 749   // goto. The bci of the goto can&#39;t be the one of the if otherwise
 750   // the state and bci are inconsistent and a deoptimization triggered
 751   // by the predicate would lead to incorrect execution/a crash.
 752   BlockBegin* new_sux = new BlockBegin(bci);
 753 
 754   // mark this block (special treatment when block order is computed)
 755   new_sux-&gt;set(critical_edge_split_flag);
 756 
 757   // This goto is not a safepoint.
 758   Goto* e = new Goto(sux, false);
 759   new_sux-&gt;set_next(e, bci);
 760   new_sux-&gt;set_end(e);
 761   // setup states
 762   ValueStack* s = end()-&gt;state();
 763   new_sux-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 764   e-&gt;set_state(s-&gt;copy(s-&gt;kind(), bci));
 765   assert(new_sux-&gt;state()-&gt;locals_size() == s-&gt;locals_size(), &quot;local size mismatch!&quot;);
 766   assert(new_sux-&gt;state()-&gt;stack_size() == s-&gt;stack_size(), &quot;stack size mismatch!&quot;);
 767   assert(new_sux-&gt;state()-&gt;locks_size() == s-&gt;locks_size(), &quot;locks size mismatch!&quot;);
 768 
 769   // link predecessor to new block
 770   end()-&gt;substitute_sux(sux, new_sux);
 771 
 772   // The ordering needs to be the same, so remove the link that the
 773   // set_end call above added and substitute the new_sux for this
 774   // block.
 775   sux-&gt;remove_predecessor(new_sux);
 776 
 777   // the successor could be the target of a switch so it might have
 778   // multiple copies of this predecessor, so substitute the new_sux
 779   // for the first and delete the rest.
 780   bool assigned = false;
 781   BlockList&amp; list = sux-&gt;_predecessors;
 782   for (int i = 0; i &lt; list.length(); i++) {
 783     BlockBegin** b = list.adr_at(i);
 784     if (*b == this) {
 785       if (assigned) {
 786         list.remove_at(i);
 787         // reprocess this index
 788         i--;
 789       } else {
 790         assigned = true;
 791         *b = new_sux;
 792       }
 793       // link the new block back to it&#39;s predecessors.
 794       new_sux-&gt;add_predecessor(this);
 795     }
 796   }
 797   assert(assigned == true, &quot;should have assigned at least once&quot;);
 798   return new_sux;
 799 }
 800 
 801 
 802 void BlockBegin::remove_successor(BlockBegin* pred) {
 803   int idx;
 804   while ((idx = _successors.find(pred)) &gt;= 0) {
 805     _successors.remove_at(idx);
 806   }
 807 }
 808 
 809 
 810 void BlockBegin::add_predecessor(BlockBegin* pred) {
 811   _predecessors.append(pred);
 812 }
 813 
 814 
 815 void BlockBegin::remove_predecessor(BlockBegin* pred) {
 816   int idx;
 817   while ((idx = _predecessors.find(pred)) &gt;= 0) {
 818     _predecessors.remove_at(idx);
 819   }
 820 }
 821 
 822 
 823 void BlockBegin::add_exception_handler(BlockBegin* b) {
 824   assert(b != NULL &amp;&amp; (b-&gt;is_set(exception_entry_flag)), &quot;exception handler must exist&quot;);
 825   // add only if not in the list already
 826   if (!_exception_handlers.contains(b)) _exception_handlers.append(b);
 827 }
 828 
 829 int BlockBegin::add_exception_state(ValueStack* state) {
 830   assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;);
 831   if (_exception_states == NULL) {
 832     _exception_states = new ValueStackStack(4);
 833   }
 834   _exception_states-&gt;append(state);
 835   return _exception_states-&gt;length() - 1;
 836 }
 837 
 838 
 839 void BlockBegin::iterate_preorder(boolArray&amp; mark, BlockClosure* closure) {
 840   if (!mark.at(block_id())) {
 841     mark.at_put(block_id(), true);
 842     closure-&gt;block_do(this);
 843     BlockEnd* e = end(); // must do this after block_do because block_do may change it!
 844     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_preorder(mark, closure); }
 845     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_preorder(mark, closure); }
 846   }
 847 }
 848 
 849 
 850 void BlockBegin::iterate_postorder(boolArray&amp; mark, BlockClosure* closure) {
 851   if (!mark.at(block_id())) {
 852     mark.at_put(block_id(), true);
 853     BlockEnd* e = end();
 854     { for (int i = number_of_exception_handlers() - 1; i &gt;= 0; i--) exception_handler_at(i)-&gt;iterate_postorder(mark, closure); }
 855     { for (int i = e-&gt;number_of_sux            () - 1; i &gt;= 0; i--) e-&gt;sux_at           (i)-&gt;iterate_postorder(mark, closure); }
 856     closure-&gt;block_do(this);
 857   }
 858 }
 859 
 860 
 861 void BlockBegin::iterate_preorder(BlockClosure* closure) {
 862   int mark_len = number_of_blocks();
 863   boolArray mark(mark_len, mark_len, false);
 864   iterate_preorder(mark, closure);
 865 }
 866 
 867 
 868 void BlockBegin::iterate_postorder(BlockClosure* closure) {
 869   int mark_len = number_of_blocks();
 870   boolArray mark(mark_len, mark_len, false);
 871   iterate_postorder(mark, closure);
 872 }
 873 
 874 
 875 void BlockBegin::block_values_do(ValueVisitor* f) {
 876   for (Instruction* n = this; n != NULL; n = n-&gt;next()) n-&gt;values_do(f);
 877 }
 878 
 879 
 880 #ifndef PRODUCT
 881    #define TRACE_PHI(code) if (PrintPhiFunctions) { code; }
 882 #else
 883    #define TRACE_PHI(coce)
 884 #endif
 885 
 886 
 887 bool BlockBegin::try_merge(ValueStack* new_state) {
 888   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d&quot;, block_id()));
 889 
 890   // local variables used for state iteration
 891   int index;
 892   Value new_value, existing_value;
 893 
 894   ValueStack* existing_state = state();
 895   if (existing_state == NULL) {
 896     TRACE_PHI(tty-&gt;print_cr(&quot;first call of try_merge for this block&quot;));
 897 
 898     if (is_set(BlockBegin::was_visited_flag)) {
 899       // this actually happens for complicated jsr/ret structures
 900       return false; // BAILOUT in caller
 901     }
 902 
 903     // copy state because it is altered
 904     new_state = new_state-&gt;copy(ValueStack::BlockBeginState, bci());
 905 
 906     // Use method liveness to invalidate dead locals
 907     MethodLivenessResult liveness = new_state-&gt;scope()-&gt;method()-&gt;liveness_at_bci(bci());
 908     if (liveness.is_valid()) {
 909       assert((int)liveness.size() == new_state-&gt;locals_size(), &quot;error in use of liveness&quot;);
 910 
 911       for_each_local_value(new_state, index, new_value) {
 912         if (!liveness.at(index) || new_value-&gt;type()-&gt;is_illegal()) {
 913           new_state-&gt;invalidate_local(index);
 914           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating dead local %d&quot;, index));
 915         }
 916       }
 917     }
 918 
 919     if (is_set(BlockBegin::parser_loop_header_flag)) {
 920       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, initializing phi functions&quot;));
 921 
 922       for_each_stack_value(new_state, index, new_value) {
 923         new_state-&gt;setup_phi_for_stack(this, index);
 924         TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, new_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;stack_at(index)-&gt;id(), index));
 925       }
 926 
 927       BitMap&amp; requires_phi_function = new_state-&gt;scope()-&gt;requires_phi_function();
 928 
 929       for_each_local_value(new_state, index, new_value) {
 930         bool requires_phi = requires_phi_function.at(index) || (new_value-&gt;type()-&gt;is_double_word() &amp;&amp; requires_phi_function.at(index + 1));
 931         if (requires_phi || !SelectivePhiFunctions) {
 932           new_state-&gt;setup_phi_for_local(this, index);
 933           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, new_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), new_state-&gt;local_at(index)-&gt;id(), index));
 934         }
 935       }
 936     }
 937 
 938     // initialize state of block
 939     set_state(new_state);
 940 
 941   } else if (existing_state-&gt;is_same(new_state)) {
 942     TRACE_PHI(tty-&gt;print_cr(&quot;exisiting state found&quot;));
 943 
 944     assert(existing_state-&gt;scope() == new_state-&gt;scope(), &quot;not matching&quot;);
 945     assert(existing_state-&gt;locals_size() == new_state-&gt;locals_size(), &quot;not matching&quot;);
 946     assert(existing_state-&gt;stack_size() == new_state-&gt;stack_size(), &quot;not matching&quot;);
 947 
 948     if (is_set(BlockBegin::was_visited_flag)) {
 949       TRACE_PHI(tty-&gt;print_cr(&quot;loop header block, phis must be present&quot;));
 950 
 951       if (!is_set(BlockBegin::parser_loop_header_flag)) {
 952         // this actually happens for complicated jsr/ret structures
 953         return false; // BAILOUT in caller
 954       }
 955 
 956       for_each_local_value(existing_state, index, existing_value) {
 957         Value new_value = new_state-&gt;local_at(index);
 958         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
 959           Phi* existing_phi = existing_value-&gt;as_Phi();
 960           if (existing_phi == NULL) {
 961             return false; // BAILOUT in caller
 962           }
 963           // Invalidate the phi function here. This case is very rare except for
 964           // JVMTI capability &quot;can_access_local_variables&quot;.
 965           // In really rare cases we will bail out in LIRGenerator::move_to_phi.
 966           existing_phi-&gt;make_illegal();
 967           existing_state-&gt;invalidate_local(index);
 968           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
 969         }
 970       }
 971 
 972 #ifdef ASSERT
 973       // check that all necessary phi functions are present
 974       for_each_stack_value(existing_state, index, existing_value) {
 975         assert(existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;block() == this, &quot;phi function required&quot;);
 976       }
 977       for_each_local_value(existing_state, index, existing_value) {
 978         assert(existing_value == new_state-&gt;local_at(index) || (existing_value-&gt;as_Phi() != NULL &amp;&amp; existing_value-&gt;as_Phi()-&gt;as_Phi()-&gt;block() == this), &quot;phi function required&quot;);
 979       }
 980 #endif
 981 
 982     } else {
 983       TRACE_PHI(tty-&gt;print_cr(&quot;creating phi functions on demand&quot;));
 984 
 985       // create necessary phi functions for stack
 986       for_each_stack_value(existing_state, index, existing_value) {
 987         Value new_value = new_state-&gt;stack_at(index);
 988         Phi* existing_phi = existing_value-&gt;as_Phi();
 989 
 990         if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
 991           existing_state-&gt;setup_phi_for_stack(this, index);
 992           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for stack %d&quot;, existing_state-&gt;stack_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;stack_at(index)-&gt;id(), index));
 993         }
 994       }
 995 
 996       // create necessary phi functions for locals
 997       for_each_local_value(existing_state, index, existing_value) {
 998         Value new_value = new_state-&gt;local_at(index);
 999         Phi* existing_phi = existing_value-&gt;as_Phi();
1000 
1001         if (new_value == NULL || new_value-&gt;type()-&gt;tag() != existing_value-&gt;type()-&gt;tag()) {
1002           existing_state-&gt;invalidate_local(index);
1003           TRACE_PHI(tty-&gt;print_cr(&quot;invalidating local %d because of type mismatch&quot;, index));
1004         } else if (new_value != existing_value &amp;&amp; (existing_phi == NULL || existing_phi-&gt;block() != this)) {
1005           existing_state-&gt;setup_phi_for_local(this, index);
1006           TRACE_PHI(tty-&gt;print_cr(&quot;creating phi-function %c%d for local %d&quot;, existing_state-&gt;local_at(index)-&gt;type()-&gt;tchar(), existing_state-&gt;local_at(index)-&gt;id(), index));
1007         }
1008       }
1009     }
1010 
1011     assert(existing_state-&gt;caller_state() == new_state-&gt;caller_state(), &quot;caller states must be equal&quot;);
1012 
1013   } else {
1014     assert(false, &quot;stack or locks not matching (invalid bytecodes)&quot;);
1015     return false;
1016   }
1017 
1018   TRACE_PHI(tty-&gt;print_cr(&quot;********** try_merge for block B%d successful&quot;, block_id()));
1019 
1020   return true;
1021 }
1022 
1023 
1024 #ifndef PRODUCT
1025 void BlockBegin::print_block() {
1026   InstructionPrinter ip;
1027   print_block(ip, false);
1028 }
1029 
1030 
1031 void BlockBegin::print_block(InstructionPrinter&amp; ip, bool live_only) {
1032   ip.print_instr(this); tty-&gt;cr();
1033   ip.print_stack(this-&gt;state()); tty-&gt;cr();
1034   ip.print_inline_level(this);
1035   ip.print_head();
1036   for (Instruction* n = next(); n != NULL; n = n-&gt;next()) {
1037     if (!live_only || n-&gt;is_pinned() || n-&gt;use_count() &gt; 0) {
1038       ip.print_line(n);
1039     }
1040   }
1041   tty-&gt;cr();
1042 }
1043 #endif // PRODUCT
1044 
1045 
1046 // Implementation of BlockList
1047 
1048 void BlockList::iterate_forward (BlockClosure* closure) {
1049   const int l = length();
1050   for (int i = 0; i &lt; l; i++) closure-&gt;block_do(at(i));
1051 }
1052 
1053 
1054 void BlockList::iterate_backward(BlockClosure* closure) {
1055   for (int i = length() - 1; i &gt;= 0; i--) closure-&gt;block_do(at(i));
1056 }
1057 
1058 
1059 void BlockList::blocks_do(void f(BlockBegin*)) {
1060   for (int i = length() - 1; i &gt;= 0; i--) f(at(i));
1061 }
1062 
1063 
1064 void BlockList::values_do(ValueVisitor* f) {
1065   for (int i = length() - 1; i &gt;= 0; i--) at(i)-&gt;block_values_do(f);
1066 }
1067 
1068 
1069 #ifndef PRODUCT
1070 void BlockList::print(bool cfg_only, bool live_only) {
1071   InstructionPrinter ip;
1072   for (int i = 0; i &lt; length(); i++) {
1073     BlockBegin* block = at(i);
1074     if (cfg_only) {
1075       ip.print_instr(block); tty-&gt;cr();
1076     } else {
1077       block-&gt;print_block(ip, live_only);
1078     }
1079   }
1080 }
1081 #endif // PRODUCT
1082 
1083 
1084 // Implementation of BlockEnd
1085 
1086 void BlockEnd::set_begin(BlockBegin* begin) {
1087   BlockList* sux = NULL;
1088   if (begin != NULL) {
1089     sux = begin-&gt;successors();
1090   } else if (this-&gt;begin() != NULL) {
1091     // copy our sux list
1092     BlockList* sux = new BlockList(this-&gt;begin()-&gt;number_of_sux());
1093     for (int i = 0; i &lt; this-&gt;begin()-&gt;number_of_sux(); i++) {
1094       sux-&gt;append(this-&gt;begin()-&gt;sux_at(i));
1095     }
1096   }
1097   _sux = sux;
1098 }
1099 
1100 
1101 void BlockEnd::substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux) {
1102   substitute(*_sux, old_sux, new_sux);
1103 }
1104 
1105 
1106 // Implementation of Phi
1107 
1108 // Normal phi functions take their operands from the last instruction of the
1109 // predecessor. Special handling is needed for xhanlder entries because there
1110 // the state of arbitrary instructions are needed.
1111 
1112 Value Phi::operand_at(int i) const {
1113   ValueStack* state;
1114   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1115     state = _block-&gt;exception_state_at(i);
1116   } else {
1117     state = _block-&gt;pred_at(i)-&gt;end()-&gt;state();
1118   }
1119   assert(state != NULL, &quot;&quot;);
1120 
1121   if (is_local()) {
1122     return state-&gt;local_at(local_index());
1123   } else {
1124     return state-&gt;stack_at(stack_index());
1125   }
1126 }
1127 
1128 
1129 int Phi::operand_count() const {
1130   if (_block-&gt;is_set(BlockBegin::exception_entry_flag)) {
1131     return _block-&gt;number_of_exception_states();
1132   } else {
1133     return _block-&gt;number_of_preds();
1134   }
1135 }
1136 
1137 #ifdef ASSERT
1138 // Constructor of Assert
1139 Assert::Assert(Value x, Condition cond, bool unordered_is_true, Value y) : Instruction(illegalType)
1140   , _x(x)
1141   , _cond(cond)
1142   , _y(y)
1143 {
1144   set_flag(UnorderedIsTrueFlag, unordered_is_true);
1145   assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1146   pin();
1147 
1148   stringStream strStream;
1149   Compilation::current()-&gt;method()-&gt;print_name(&amp;strStream);
1150 
1151   stringStream strStream1;
1152   InstructionPrinter ip1(1, &amp;strStream1);
1153   ip1.print_instr(x);
1154 
1155   stringStream strStream2;
1156   InstructionPrinter ip2(1, &amp;strStream2);
1157   ip2.print_instr(y);
1158 
1159   stringStream ss;
1160   ss.print(&quot;Assertion %s %s %s in method %s&quot;, strStream1.as_string(), ip2.cond_name(cond), strStream2.as_string(), strStream.as_string());
1161 
1162   _message = ss.as_string();
1163 }
1164 #endif
1165 
1166 void RangeCheckPredicate::check_state() {
1167   assert(state()-&gt;kind() != ValueStack::EmptyExceptionState &amp;&amp; state()-&gt;kind() != ValueStack::ExceptionState, &quot;will deopt with empty state&quot;);
1168 }
1169 
1170 void ProfileInvoke::state_values_do(ValueVisitor* f) {
1171   if (state() != NULL) state()-&gt;values_do(f);
1172 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1676 
1677 void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {
1678   LIR_Opr tmp = new_register(T_METADATA);
1679   __ check_flattened_array(array, value, tmp, slow_path);
1680 }
1681 
1682 void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {
1683   LabelObj* L_end = new LabelObj();
1684   LIR_Opr tmp = new_register(T_METADATA);
1685   __ check_null_free_array(array.result(), tmp);
1686   __ branch(lir_cond_equal, T_ILLEGAL, L_end-&gt;label());
1687   __ null_check(value.result(), info);
1688   __ branch_destination(L_end-&gt;label());
1689 }
1690 
1691 bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
1692   if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {
1693     ciType* type = x-&gt;value()-&gt;declared_type();
1694     if (type != NULL &amp;&amp; type-&gt;is_klass()) {
1695       ciKlass* klass = type-&gt;as_klass();
<span class="line-modified">1696       if (klass-&gt;is_loaded() &amp;&amp;</span>
<span class="line-removed">1697           !(klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array()) &amp;&amp;</span>
<span class="line-removed">1698           !klass-&gt;is_java_lang_Object() &amp;&amp;</span>
<span class="line-removed">1699           !klass-&gt;is_interface()) {</span>
1700         // This is known to be a non-flattenable object. If the array is flattened,
1701         // it will be caught by the code generated by array_store_check().
1702         return false;
1703       }
1704     }
1705     // We&#39;re not 100% sure, so let&#39;s do the flattened_array_store_check.
1706     return true;
1707   }
1708   return false;
1709 }
1710 
1711 bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {
1712   return x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array();
1713 }
1714 
1715 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1716   assert(x-&gt;is_pinned(),&quot;&quot;);
1717   assert(x-&gt;elt_type() != T_ARRAY, &quot;never used&quot;);
1718   bool is_loaded_flattened_array = x-&gt;array()-&gt;is_loaded_flattened_array();
1719   bool needs_range_check = x-&gt;compute_needs_range_check();
</pre>
</td>
<td>
<hr />
<pre>
1676 
1677 void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {
1678   LIR_Opr tmp = new_register(T_METADATA);
1679   __ check_flattened_array(array, value, tmp, slow_path);
1680 }
1681 
1682 void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {
1683   LabelObj* L_end = new LabelObj();
1684   LIR_Opr tmp = new_register(T_METADATA);
1685   __ check_null_free_array(array.result(), tmp);
1686   __ branch(lir_cond_equal, T_ILLEGAL, L_end-&gt;label());
1687   __ null_check(value.result(), info);
1688   __ branch_destination(L_end-&gt;label());
1689 }
1690 
1691 bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
1692   if (x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_flattened_array()) {
1693     ciType* type = x-&gt;value()-&gt;declared_type();
1694     if (type != NULL &amp;&amp; type-&gt;is_klass()) {
1695       ciKlass* klass = type-&gt;as_klass();
<span class="line-modified">1696       if (!klass-&gt;can_be_value_klass() || (klass-&gt;is_valuetype() &amp;&amp; !klass-&gt;as_value_klass()-&gt;flatten_array())) {</span>



1697         // This is known to be a non-flattenable object. If the array is flattened,
1698         // it will be caught by the code generated by array_store_check().
1699         return false;
1700       }
1701     }
1702     // We&#39;re not 100% sure, so let&#39;s do the flattened_array_store_check.
1703     return true;
1704   }
1705   return false;
1706 }
1707 
1708 bool LIRGenerator::needs_null_free_array_store_check(StoreIndexed* x) {
1709   return x-&gt;elt_type() == T_OBJECT &amp;&amp; x-&gt;array()-&gt;maybe_null_free_array();
1710 }
1711 
1712 void LIRGenerator::do_StoreIndexed(StoreIndexed* x) {
1713   assert(x-&gt;is_pinned(),&quot;&quot;);
1714   assert(x-&gt;elt_type() != T_ARRAY, &quot;never used&quot;);
1715   bool is_loaded_flattened_array = x-&gt;array()-&gt;is_loaded_flattened_array();
1716   bool needs_range_check = x-&gt;compute_needs_range_check();
</pre>
</td>
</tr>
</table>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
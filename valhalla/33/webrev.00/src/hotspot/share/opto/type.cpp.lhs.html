<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciField.hpp&quot;
  27 #include &quot;ci/ciMethodData.hpp&quot;
  28 #include &quot;ci/ciTypeFlow.hpp&quot;
  29 #include &quot;ci/ciValueKlass.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;libadt/dict.hpp&quot;
  34 #include &quot;memory/oopFactory.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/instanceKlass.hpp&quot;
  37 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;oops/typeArrayKlass.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/node.hpp&quot;
  42 #include &quot;opto/opcodes.hpp&quot;
  43 #include &quot;opto/type.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 // Portions of code courtesy of Clifford Click
  47 
  48 // Optimization - Graph Style
  49 
  50 // Dictionary of types shared among compilations.
  51 Dict* Type::_shared_type_dict = NULL;
  52 const Type::Offset Type::Offset::top(Type::OffsetTop);
  53 const Type::Offset Type::Offset::bottom(Type::OffsetBot);
  54 
  55 const Type::Offset Type::Offset::meet(const Type::Offset other) const {
  56   // Either is &#39;TOP&#39; offset?  Return the other offset!
  57   int offset = other._offset;
  58   if (_offset == OffsetTop) return Offset(offset);
  59   if (offset == OffsetTop) return Offset(_offset);
  60   // If either is different, return &#39;BOTTOM&#39; offset
  61   if (_offset != offset) return bottom;
  62   return Offset(_offset);
  63 }
  64 
  65 const Type::Offset Type::Offset::dual() const {
  66   if (_offset == OffsetTop) return bottom;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
  67   if (_offset == OffsetBot) return top;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
  68   return Offset(_offset);               // Map everything else into self
  69 }
  70 
  71 const Type::Offset Type::Offset::add(intptr_t offset) const {
  72   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
  73   if (_offset == OffsetTop || offset == OffsetTop) return top;
  74   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
  75   if (_offset == OffsetBot || offset == OffsetBot) return bottom;
  76   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
  77   offset += (intptr_t)_offset;
  78   if (offset != (int)offset || offset == OffsetTop) return bottom;
  79 
  80   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
  81   // It is possible to construct a negative offset during PhaseCCP
  82 
  83   return Offset((int)offset);        // Sum valid offsets
  84 }
  85 
  86 void Type::Offset::dump2(outputStream *st) const {
  87   if (_offset == 0) {
  88     return;
  89   } else if (_offset == OffsetTop) {
  90     st-&gt;print(&quot;+top&quot;);
  91   }
  92   else if (_offset == OffsetBot) {
  93     st-&gt;print(&quot;+bot&quot;);
  94   } else if (_offset) {
  95     st-&gt;print(&quot;+%d&quot;, _offset);
  96   }
  97 }
  98 
  99 // Array which maps compiler types to Basic Types
 100 const Type::TypeInfo Type::_type_info[Type::lastype] = {
 101   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
 102   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
 103   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
 104   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
 105   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
 106   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
 107   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
 108   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
 109   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
 110   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
 111 
 112 #ifdef SPARC
 113   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 114   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
 115   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 116   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 117   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 118 #elif defined(PPC64)
 119   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 120   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 121   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 122   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 123   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 124 #elif defined(S390)
 125   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
 126   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
 127   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
 128   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
 129   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
 130 #else // all other
 131   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
 132   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
 133   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
 134   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
 135   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
 136 #endif
 137   { Bad,             T_VALUETYPE,  &quot;value:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // ValueType
 138   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
 139   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
 140   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
 141   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
 142   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
 143   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
 144   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
 145   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
 146   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
 147   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
 148   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 149   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 150   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 151   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 152   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 153   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 154   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 155   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 156 };
 157 
 158 // Map ideal registers (machine types) to ideal types
 159 const Type *Type::mreg2type[_last_machine_leaf];
 160 
 161 // Map basic types to canonical Type* pointers.
 162 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 163 
 164 // Map basic types to constant-zero Types.
 165 const Type* Type::            _zero_type[T_CONFLICT+1];
 166 
 167 // Map basic types to array-body alias types.
 168 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 169 
 170 //=============================================================================
 171 // Convenience common pre-built types.
 172 const Type *Type::ABIO;         // State-of-machine only
 173 const Type *Type::BOTTOM;       // All values
 174 const Type *Type::CONTROL;      // Control only
 175 const Type *Type::DOUBLE;       // All doubles
 176 const Type *Type::FLOAT;        // All floats
 177 const Type *Type::HALF;         // Placeholder half of doublewide type
 178 const Type *Type::MEMORY;       // Abstract store only
 179 const Type *Type::RETURN_ADDRESS;
 180 const Type *Type::TOP;          // No values in set
 181 
 182 //------------------------------get_const_type---------------------------
 183 const Type* Type::get_const_type(ciType* type) {
 184   if (type == NULL) {
 185     return NULL;
 186   } else if (type-&gt;is_primitive_type()) {
 187     return get_const_basic_type(type-&gt;basic_type());
 188   } else {
 189     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 190   }
 191 }
 192 
 193 //---------------------------array_element_basic_type---------------------------------
 194 // Mapping to the array element&#39;s basic type.
 195 BasicType Type::array_element_basic_type() const {
 196   BasicType bt = basic_type();
 197   if (bt == T_INT) {
 198     if (this == TypeInt::INT)   return T_INT;
 199     if (this == TypeInt::CHAR)  return T_CHAR;
 200     if (this == TypeInt::BYTE)  return T_BYTE;
 201     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 202     if (this == TypeInt::SHORT) return T_SHORT;
 203     return T_VOID;
 204   }
 205   return bt;
 206 }
 207 
 208 // For two instance arrays of same dimension, return the base element types.
 209 // Otherwise or if the arrays have different dimensions, return NULL.
 210 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 211                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 212 
 213   if (e1) *e1 = NULL;
 214   if (e2) *e2 = NULL;
 215   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 216   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 217 
 218   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 219     // Handle multidimensional arrays
 220     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 221     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 222     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 223       a1tap = a1tp-&gt;is_aryptr();
 224       a2tap = a2tp-&gt;is_aryptr();
 225       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 226       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 227     }
 228     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 229       if (e1) *e1 = a1tp-&gt;is_instptr();
 230       if (e2) *e2 = a2tp-&gt;is_instptr();
 231     }
 232   }
 233 }
 234 
 235 //---------------------------get_typeflow_type---------------------------------
 236 // Import a type produced by ciTypeFlow.
 237 const Type* Type::get_typeflow_type(ciType* type) {
 238   switch (type-&gt;basic_type()) {
 239 
 240   case ciTypeFlow::StateVector::T_BOTTOM:
 241     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 242     return Type::BOTTOM;
 243 
 244   case ciTypeFlow::StateVector::T_TOP:
 245     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 246     return Type::TOP;
 247 
 248   case ciTypeFlow::StateVector::T_NULL:
 249     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 250     return TypePtr::NULL_PTR;
 251 
 252   case ciTypeFlow::StateVector::T_LONG2:
 253     // The ciTypeFlow pass pushes a long, then the half.
 254     // We do the same.
 255     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 256     return TypeInt::TOP;
 257 
 258   case ciTypeFlow::StateVector::T_DOUBLE2:
 259     // The ciTypeFlow pass pushes double, then the half.
 260     // Our convention is the same.
 261     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 262     return Type::TOP;
 263 
 264   case T_ADDRESS:
 265     assert(type-&gt;is_return_address(), &quot;&quot;);
 266     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 267 
 268   case T_VALUETYPE: {
 269     bool is_never_null = type-&gt;is_never_null();
 270     ciValueKlass* vk = type-&gt;unwrap()-&gt;as_value_klass();
 271     if (vk-&gt;is_scalarizable() &amp;&amp; is_never_null) {
 272       return TypeValueType::make(vk);
 273     } else {
 274       return TypeOopPtr::make_from_klass(vk)-&gt;join_speculative(is_never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
 275     }
 276   }
 277 
 278   default:
 279     // make sure we did not mix up the cases:
 280     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 281     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 282     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 283     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 284     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 285     assert(!type-&gt;is_return_address(), &quot;&quot;);
 286 
 287     return Type::get_const_type(type);
 288   }
 289 }
 290 
 291 
 292 //-----------------------make_from_constant------------------------------------
 293 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 294                                      int stable_dimension, bool is_narrow_oop,
 295                                      bool is_autobox_cache) {
 296   switch (constant.basic_type()) {
 297     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 298     case T_CHAR:     return TypeInt::make(constant.as_char());
 299     case T_BYTE:     return TypeInt::make(constant.as_byte());
 300     case T_SHORT:    return TypeInt::make(constant.as_short());
 301     case T_INT:      return TypeInt::make(constant.as_int());
 302     case T_LONG:     return TypeLong::make(constant.as_long());
 303     case T_FLOAT:    return TypeF::make(constant.as_float());
 304     case T_DOUBLE:   return TypeD::make(constant.as_double());
 305     case T_ARRAY:
 306     case T_VALUETYPE:
 307     case T_OBJECT: {
 308         const Type* con_type = NULL;
 309         ciObject* oop_constant = constant.as_object();
 310         if (oop_constant-&gt;is_null_object()) {
 311           con_type = Type::get_zero_type(T_OBJECT);
 312         } else {
 313           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 314           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 315           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 316             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 317           }
 318           if (stable_dimension &gt; 0) {
 319             assert(FoldStableValues, &quot;sanity&quot;);
 320             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 321             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 322           }
 323         }
 324         if (is_narrow_oop) {
 325           con_type = con_type-&gt;make_narrowoop();
 326         }
 327         return con_type;
 328       }
 329     case T_ILLEGAL:
 330       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 331       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 332       return NULL;
 333     default:
 334       // Fall through to failure
 335       return NULL;
 336   }
 337 }
 338 
 339 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 340   BasicType conbt = con.basic_type();
 341   switch (conbt) {
 342     case T_BOOLEAN: conbt = T_BYTE;   break;
 343     case T_ARRAY:   conbt = T_OBJECT; break;
 344     case T_VALUETYPE: conbt = T_OBJECT; break;
 345     default:                          break;
 346   }
 347   switch (loadbt) {
 348     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 349     case T_NARROWOOP: loadbt = T_OBJECT; break;
 350     case T_ARRAY:     loadbt = T_OBJECT; break;
 351     case T_VALUETYPE: loadbt = T_OBJECT; break;
 352     case T_ADDRESS:   loadbt = T_OBJECT; break;
 353     default:                             break;
 354   }
 355   if (conbt == loadbt) {
 356     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 357       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 358       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 359     } else {
 360       return con;
 361     }
 362   }
 363   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 364     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 365     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 366   }
 367   return ciConstant(); // T_ILLEGAL
 368 }
 369 
 370 // Try to constant-fold a stable array element.
 371 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 372                                                    BasicType loadbt, bool is_unsigned_load) {
 373   // Decode the results of GraphKit::array_element_address.
 374   ciConstant element_value = array-&gt;element_value_by_offset(off);
 375   if (element_value.basic_type() == T_ILLEGAL) {
 376     return NULL; // wrong offset
 377   }
 378   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 379 
 380   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 381          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 382 
 383   if (con.is_valid() &amp;&amp;          // not a mismatched access
 384       !con.is_null_or_zero()) {  // not a default value
 385     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 386     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 387   }
 388   return NULL;
 389 }
 390 
 391 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 392   ciField* field;
 393   ciType* type = holder-&gt;java_mirror_type();
 394   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 395     // Static field
 396     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 397   } else {
 398     // Instance field
 399     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 400   }
 401   if (field == NULL) {
 402     return NULL; // Wrong offset
 403   }
 404   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 405 }
 406 
 407 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 408                                            BasicType loadbt, bool is_unsigned_load) {
 409   if (!field-&gt;is_constant()) {
 410     return NULL; // Non-constant field
 411   }
 412   ciConstant field_value;
 413   if (field-&gt;is_static()) {
 414     // final static field
 415     field_value = field-&gt;constant_value();
 416   } else if (holder != NULL) {
 417     // final or stable non-static field
 418     // Treat final non-static fields of trusted classes (classes in
 419     // java.lang.invoke and sun.invoke packages and subpackages) as
 420     // compile time constants.
 421     field_value = field-&gt;constant_value_of(holder);
 422   }
 423   if (!field_value.is_valid()) {
 424     return NULL; // Not a constant
 425   }
 426 
 427   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 428 
 429   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 430          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 431 
 432   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 433   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 434   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 435 
 436   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 437                                             stable_dimension, is_narrow_oop,
 438                                             field-&gt;is_autobox_cache());
 439   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 440     ciCallSite* call_site = holder-&gt;as_call_site();
 441     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 442       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 443       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 444     }
 445   }
 446   return con_type;
 447 }
 448 
 449 //------------------------------make-------------------------------------------
 450 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 451 // and look for an existing copy in the type dictionary.
 452 const Type *Type::make( enum TYPES t ) {
 453   return (new Type(t))-&gt;hashcons();
 454 }
 455 
 456 //------------------------------cmp--------------------------------------------
 457 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 458   if( t1-&gt;_base != t2-&gt;_base )
 459     return 1;                   // Missed badly
 460   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 461   return !t1-&gt;eq(t2);           // Return ZERO if equal
 462 }
 463 
 464 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 465   if (!include_speculative) {
 466     return remove_speculative();
 467   }
 468   return this;
 469 }
 470 
 471 //------------------------------hash-------------------------------------------
 472 int Type::uhash( const Type *const t ) {
 473   return t-&gt;hash();
 474 }
 475 
 476 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 477 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 478 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 479 
 480 //--------------------------Initialize_shared----------------------------------
 481 void Type::Initialize_shared(Compile* current) {
 482   // This method does not need to be locked because the first system
 483   // compilations (stub compilations) occur serially.  If they are
 484   // changed to proceed in parallel, then this section will need
 485   // locking.
 486 
 487   Arena* save = current-&gt;type_arena();
 488   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 489 
 490   current-&gt;set_type_arena(shared_type_arena);
 491   _shared_type_dict =
 492     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 493                                   shared_type_arena, 128 );
 494   current-&gt;set_type_dict(_shared_type_dict);
 495 
 496   // Make shared pre-built types.
 497   CONTROL = make(Control);      // Control only
 498   TOP     = make(Top);          // No values in set
 499   MEMORY  = make(Memory);       // Abstract store only
 500   ABIO    = make(Abio);         // State-of-machine only
 501   RETURN_ADDRESS=make(Return_Address);
 502   FLOAT   = make(FloatBot);     // All floats
 503   DOUBLE  = make(DoubleBot);    // All doubles
 504   BOTTOM  = make(Bottom);       // Everything
 505   HALF    = make(Half);         // Placeholder half of doublewide type
 506 
 507   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 508   TypeF::ONE  = TypeF::make(1.0); // Float 1
 509   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 510   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 511 
 512   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 513   TypeD::ONE  = TypeD::make(1.0); // Double 1
 514   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 515   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 516 
 517   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 518   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 519   TypeInt::ONE     = TypeInt::make( 1);  //  1
 520   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 521   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 522   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 523   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 524   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 525   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 526   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 527   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 528   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 529   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 530   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 531   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 532   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 533   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 534   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 535   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 536   // CmpL is overloaded both as the bytecode computation returning
 537   // a trinary (-1,0,+1) integer result AND as an efficient long
 538   // compare returning optimizer ideal-type flags.
 539   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 540   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 541   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 542   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 543   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 544 
 545   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 546   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 547   TypeLong::ONE     = TypeLong::make( 1);        //  1
 548   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 549   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 550   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 551   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 552   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 553 
 554   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 555   fboth[0] = Type::CONTROL;
 556   fboth[1] = Type::CONTROL;
 557   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 558 
 559   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 560   ffalse[0] = Type::CONTROL;
 561   ffalse[1] = Type::TOP;
 562   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 563 
 564   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 565   fneither[0] = Type::TOP;
 566   fneither[1] = Type::TOP;
 567   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 568 
 569   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 570   ftrue[0] = Type::TOP;
 571   ftrue[1] = Type::CONTROL;
 572   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 573 
 574   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 575   floop[0] = Type::CONTROL;
 576   floop[1] = TypeInt::INT;
 577   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 578 
 579   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, Offset(0));
 580   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, Offset::bottom);
 581   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, Offset::bottom);
 582 
 583   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 584   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 585 
 586   const Type **fmembar = TypeTuple::fields(0);
 587   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 588 
 589   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 590   fsc[0] = TypeInt::CC;
 591   fsc[1] = Type::MEMORY;
 592   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 593 
 594   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 595   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 596   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 597   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 598                                            false, 0, Offset(oopDesc::mark_offset_in_bytes()), false);
 599   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 600                                            false, 0, Offset(oopDesc::klass_offset_in_bytes()), false);
 601   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, Offset::bottom, TypeOopPtr::InstanceBot);
 602 
 603   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);
 604 
 605   TypeValueType::BOTTOM = TypeValueType::make(NULL);
 606 
 607   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 608   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 609 
 610   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 611 
 612   mreg2type[Op_Node] = Type::BOTTOM;
 613   mreg2type[Op_Set ] = 0;
 614   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 615   mreg2type[Op_RegI] = TypeInt::INT;
 616   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 617   mreg2type[Op_RegF] = Type::FLOAT;
 618   mreg2type[Op_RegD] = Type::DOUBLE;
 619   mreg2type[Op_RegL] = TypeLong::LONG;
 620   mreg2type[Op_RegFlags] = TypeInt::CC;
 621 
 622   TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, Offset(arrayOopDesc::length_offset_in_bytes()));
 623 
 624   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 625 
 626 #ifdef _LP64
 627   if (UseCompressedOops) {
 628     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 629     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 630   } else
 631 #endif
 632   {
 633     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 634     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Offset::bottom);
 635   }
 636   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Offset::bottom);
 637   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Offset::bottom);
 638   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Offset::bottom);
 639   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Offset::bottom);
 640   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Offset::bottom);
 641   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Offset::bottom);
 642   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Offset::bottom);
 643   TypeAryPtr::VALUES  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeValueType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);
 644 
 645   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 646   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 647   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 648   TypeAryPtr::_array_body_type[T_VALUETYPE] = TypeAryPtr::OOPS;
 649   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 650   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 651   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 652   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 653   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 654   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 655   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 656   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 657   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 658 
 659   TypeKlassPtr::OBJECT = TypeKlassPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 660   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make(TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), Offset(0), false);
 661 
 662   const Type **fi2c = TypeTuple::fields(2);
 663   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 664   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 665   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 666 
 667   const Type **intpair = TypeTuple::fields(2);
 668   intpair[0] = TypeInt::INT;
 669   intpair[1] = TypeInt::INT;
 670   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 671 
 672   const Type **longpair = TypeTuple::fields(2);
 673   longpair[0] = TypeLong::LONG;
 674   longpair[1] = TypeLong::LONG;
 675   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 676 
 677   const Type **intccpair = TypeTuple::fields(2);
 678   intccpair[0] = TypeInt::INT;
 679   intccpair[1] = TypeInt::CC;
 680   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 681 
 682   const Type **longccpair = TypeTuple::fields(2);
 683   longccpair[0] = TypeLong::LONG;
 684   longccpair[1] = TypeInt::CC;
 685   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 686 
 687   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 688   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 689   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 690   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 691   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 692   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 693   _const_basic_type[T_INT]         = TypeInt::INT;
 694   _const_basic_type[T_LONG]        = TypeLong::LONG;
 695   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 696   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 697   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 698   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 699   _const_basic_type[T_VALUETYPE]   = TypeInstPtr::BOTTOM;
 700   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 701   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 702   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 703 
 704   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 705   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 706   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 707   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 708   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 709   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 710   _zero_type[T_INT]         = TypeInt::ZERO;
 711   _zero_type[T_LONG]        = TypeLong::ZERO;
 712   _zero_type[T_FLOAT]       = TypeF::ZERO;
 713   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 714   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 715   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 716   _zero_type[T_VALUETYPE]   = TypePtr::NULL_PTR;
 717   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 718   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 719 
 720   // get_zero_type() should not happen for T_CONFLICT
 721   _zero_type[T_CONFLICT]= NULL;
 722 
 723   // Vector predefined types, it needs initialized _const_basic_type[].
 724   if (Matcher::vector_size_supported(T_BYTE,4)) {
 725     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 726   }
 727   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 728     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 729   }
 730   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 731     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 732   }
 733   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 734     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 735   }
 736   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 737     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 738   }
 739   mreg2type[Op_VecS] = TypeVect::VECTS;
 740   mreg2type[Op_VecD] = TypeVect::VECTD;
 741   mreg2type[Op_VecX] = TypeVect::VECTX;
 742   mreg2type[Op_VecY] = TypeVect::VECTY;
 743   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 744 
 745   // Restore working type arena.
 746   current-&gt;set_type_arena(save);
 747   current-&gt;set_type_dict(NULL);
 748 }
 749 
 750 //------------------------------Initialize-------------------------------------
 751 void Type::Initialize(Compile* current) {
 752   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 753 
 754   if (_shared_type_dict == NULL) {
 755     Initialize_shared(current);
 756   }
 757 
 758   Arena* type_arena = current-&gt;type_arena();
 759 
 760   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 761   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 762   current-&gt;set_type_dict(tdic);
 763 
 764   // Transfer the shared types.
 765   DictI i(_shared_type_dict);
 766   for( ; i.test(); ++i ) {
 767     Type* t = (Type*)i._value;
 768     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 769   }
 770 }
 771 
 772 //------------------------------hashcons---------------------------------------
 773 // Do the hash-cons trick.  If the Type already exists in the type table,
 774 // delete the current Type and return the existing Type.  Otherwise stick the
 775 // current Type in the Type table.
 776 const Type *Type::hashcons(void) {
 777   debug_only(base());           // Check the assertion in Type::base().
 778   // Look up the Type in the Type dictionary
 779   Dict *tdic = type_dict();
 780   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 781   if( old ) {                   // Pre-existing Type?
 782     if( old != this )           // Yes, this guy is not the pre-existing?
 783       delete this;              // Yes, Nuke this guy
 784     assert( old-&gt;_dual, &quot;&quot; );
 785     return old;                 // Return pre-existing
 786   }
 787 
 788   // Every type has a dual (to make my lattice symmetric).
 789   // Since we just discovered a new Type, compute its dual right now.
 790   assert( !_dual, &quot;&quot; );         // No dual yet
 791   _dual = xdual();              // Compute the dual
 792   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 793     if (_dual != this) {
 794       delete _dual;
 795       _dual = this;
 796     }
 797     return this;
 798   }
 799   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 800   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 801   // New Type, insert into Type table
 802   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 803   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 804 #ifdef ASSERT
 805   Type *dual_dual = (Type*)_dual-&gt;xdual();
 806   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 807   delete dual_dual;
 808 #endif
 809   return this;                  // Return new Type
 810 }
 811 
 812 //------------------------------eq---------------------------------------------
 813 // Structural equality check for Type representations
 814 bool Type::eq( const Type * ) const {
 815   return true;                  // Nothing else can go wrong
 816 }
 817 
 818 //------------------------------hash-------------------------------------------
 819 // Type-specific hashing function.
 820 int Type::hash(void) const {
 821   return _base;
 822 }
 823 
 824 //------------------------------is_finite--------------------------------------
 825 // Has a finite value
 826 bool Type::is_finite() const {
 827   return false;
 828 }
 829 
 830 //------------------------------is_nan-----------------------------------------
 831 // Is not a number (NaN)
 832 bool Type::is_nan()    const {
 833   return false;
 834 }
 835 
 836 //----------------------interface_vs_oop---------------------------------------
 837 #ifdef ASSERT
 838 bool Type::interface_vs_oop_helper(const Type *t) const {
 839   bool result = false;
 840 
 841   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 842   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 843   if( this_ptr == NULL || t_ptr == NULL )
 844     return result;
 845 
 846   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 847   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 848   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 849     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 850     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 851     result = this_interface ^ t_interface;
 852   }
 853 
 854   return result;
 855 }
 856 
 857 bool Type::interface_vs_oop(const Type *t) const {
 858   if (interface_vs_oop_helper(t)) {
 859     return true;
 860   }
 861   // Now check the speculative parts as well
 862   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 863   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 864   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 865     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 866       return true;
 867     }
 868     return false;
 869   }
 870   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 871     return true;
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
 881 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 882 #ifdef ASSERT
 883   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 884   const Type* dual_join = mt-&gt;_dual;
 885   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 886   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 887 
 888   // Interface meet Oop is Not Symmetric:
 889   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 890   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 891 
 892   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual)) {
 893     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 894     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 895     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 896     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 897 
 898     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 899     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 900     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 901 
 902     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 903     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 904 
 905     fatal(&quot;meet not symmetric&quot; );
 906   }
 907 #endif
 908 }
 909 
 910 //------------------------------meet-------------------------------------------
 911 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 912 // commutative and the lattice is symmetric.
 913 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 914   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 915     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 916     return result-&gt;make_narrowoop();
 917   }
 918   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 919     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 920     return result-&gt;make_narrowklass();
 921   }
 922 
 923   const Type *this_t = maybe_remove_speculative(include_speculative);
 924   t = t-&gt;maybe_remove_speculative(include_speculative);
 925 
 926   const Type *mt = this_t-&gt;xmeet(t);
 927 #ifdef ASSERT
 928   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 929   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 930   Compile* C = Compile::current();
 931   if (!C-&gt;_type_verify_symmetry) {
 932     return mt;
 933   }
 934   this_t-&gt;check_symmetrical(t, mt);
 935   // In the case of an array, computing the meet above, caused the
 936   // computation of the meet of the elements which at verification
 937   // time caused the computation of the meet of the dual of the
 938   // elements. Computing the meet of the dual of the arrays here
 939   // causes the meet of the dual of the elements to be computed which
 940   // would cause the meet of the dual of the dual of the elements,
 941   // that is the meet of the elements already computed above to be
 942   // computed. Avoid redundant computations by requesting no
 943   // verification.
 944   C-&gt;_type_verify_symmetry = false;
 945   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);
 946   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);
 947   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);
 948   C-&gt;_type_verify_symmetry = true;
 949 #endif
 950   return mt;
 951 }
 952 
 953 //------------------------------xmeet------------------------------------------
 954 // Compute the MEET of two types.  It returns a new Type object.
 955 const Type *Type::xmeet( const Type *t ) const {
 956   // Perform a fast test for common case; meeting the same types together.
 957   if( this == t ) return this;  // Meeting same type-rep?
 958 
 959   // Meeting TOP with anything?
 960   if( _base == Top ) return t;
 961 
 962   // Meeting BOTTOM with anything?
 963   if( _base == Bottom ) return BOTTOM;
 964 
 965   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 966   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 967   switch (t-&gt;base()) {  // Switch on original type
 968 
 969   // Cut in half the number of cases I must handle.  Only need cases for when
 970   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 971   case FloatCon:
 972   case DoubleCon:
 973   case Int:
 974   case Long:
 975     return t-&gt;xmeet(this);
 976 
 977   case OopPtr:
 978     return t-&gt;xmeet(this);
 979 
 980   case InstPtr:
 981     return t-&gt;xmeet(this);
 982 
 983   case MetadataPtr:
 984   case KlassPtr:
 985     return t-&gt;xmeet(this);
 986 
 987   case AryPtr:
 988     return t-&gt;xmeet(this);
 989 
 990   case NarrowOop:
 991     return t-&gt;xmeet(this);
 992 
 993   case NarrowKlass:
 994     return t-&gt;xmeet(this);
 995 
 996   case ValueType:
 997     return t-&gt;xmeet(this);
 998 
 999   case Bad:                     // Type check
1000   default:                      // Bogus type not in lattice
1001     typerr(t);
1002     return Type::BOTTOM;
1003 
1004   case Bottom:                  // Ye Olde Default
1005     return t;
1006 
1007   case FloatTop:
1008     if( _base == FloatTop ) return this;
1009   case FloatBot:                // Float
1010     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
1011     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
1012     typerr(t);
1013     return Type::BOTTOM;
1014 
1015   case DoubleTop:
1016     if( _base == DoubleTop ) return this;
1017   case DoubleBot:               // Double
1018     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
1019     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
1020     typerr(t);
1021     return Type::BOTTOM;
1022 
1023   // These next few cases must match exactly or it is a compile-time error.
1024   case Control:                 // Control of code
1025   case Abio:                    // State of world outside of program
1026   case Memory:
1027     if( _base == t-&gt;_base )  return this;
1028     typerr(t);
1029     return Type::BOTTOM;
1030 
1031   case Top:                     // Top of the lattice
1032     return this;
1033   }
1034 
1035   // The type is unchanged
1036   return this;
1037 }
1038 
1039 //-----------------------------filter------------------------------------------
1040 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
1041   const Type* ft = join_helper(kills, include_speculative);
1042   if (ft-&gt;empty())
1043     return Type::TOP;           // Canonical empty value
1044   return ft;
1045 }
1046 
1047 //------------------------------xdual------------------------------------------
1048 // Compute dual right now.
1049 const Type::TYPES Type::dual_type[Type::lastype] = {
1050   Bad,          // Bad
1051   Control,      // Control
1052   Bottom,       // Top
1053   Bad,          // Int - handled in v-call
1054   Bad,          // Long - handled in v-call
1055   Half,         // Half
1056   Bad,          // NarrowOop - handled in v-call
1057   Bad,          // NarrowKlass - handled in v-call
1058 
1059   Bad,          // Tuple - handled in v-call
1060   Bad,          // Array - handled in v-call
1061   Bad,          // VectorS - handled in v-call
1062   Bad,          // VectorD - handled in v-call
1063   Bad,          // VectorX - handled in v-call
1064   Bad,          // VectorY - handled in v-call
1065   Bad,          // VectorZ - handled in v-call
1066   Bad,          // ValueType - handled in v-call
1067 
1068   Bad,          // AnyPtr - handled in v-call
1069   Bad,          // RawPtr - handled in v-call
1070   Bad,          // OopPtr - handled in v-call
1071   Bad,          // InstPtr - handled in v-call
1072   Bad,          // AryPtr - handled in v-call
1073 
1074   Bad,          //  MetadataPtr - handled in v-call
1075   Bad,          // KlassPtr - handled in v-call
1076 
1077   Bad,          // Function - handled in v-call
1078   Abio,         // Abio
1079   Return_Address,// Return_Address
1080   Memory,       // Memory
1081   FloatBot,     // FloatTop
1082   FloatCon,     // FloatCon
1083   FloatTop,     // FloatBot
1084   DoubleBot,    // DoubleTop
1085   DoubleCon,    // DoubleCon
1086   DoubleTop,    // DoubleBot
1087   Top           // Bottom
1088 };
1089 
1090 const Type *Type::xdual() const {
1091   // Note: the base() accessor asserts the sanity of _base.
1092   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1093   return new Type(_type_info[_base].dual_type);
1094 }
1095 
1096 //------------------------------has_memory-------------------------------------
1097 bool Type::has_memory() const {
1098   Type::TYPES tx = base();
1099   if (tx == Memory) return true;
1100   if (tx == Tuple) {
1101     const TypeTuple *t = is_tuple();
1102     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1103       tx = t-&gt;field_at(i)-&gt;base();
1104       if (tx == Memory)  return true;
1105     }
1106   }
1107   return false;
1108 }
1109 
1110 #ifndef PRODUCT
1111 //------------------------------dump2------------------------------------------
1112 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1113   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1114 }
1115 
1116 //------------------------------dump-------------------------------------------
1117 void Type::dump_on(outputStream *st) const {
1118   ResourceMark rm;
1119   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1120   dump2(d,1, st);
1121   if (is_ptr_to_narrowoop()) {
1122     st-&gt;print(&quot; [narrow]&quot;);
1123   } else if (is_ptr_to_narrowklass()) {
1124     st-&gt;print(&quot; [narrowklass]&quot;);
1125   }
1126 }
1127 
1128 //-----------------------------------------------------------------------------
1129 const char* Type::str(const Type* t) {
1130   stringStream ss;
1131   t-&gt;dump_on(&amp;ss);
1132   return ss.as_string();
1133 }
1134 #endif
1135 
1136 //------------------------------singleton--------------------------------------
1137 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1138 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1139 bool Type::singleton(void) const {
1140   return _base == Top || _base == Half;
1141 }
1142 
1143 //------------------------------empty------------------------------------------
1144 // TRUE if Type is a type with no values, FALSE otherwise.
1145 bool Type::empty(void) const {
1146   switch (_base) {
1147   case DoubleTop:
1148   case FloatTop:
1149   case Top:
1150     return true;
1151 
1152   case Half:
1153   case Abio:
1154   case Return_Address:
1155   case Memory:
1156   case Bottom:
1157   case FloatBot:
1158   case DoubleBot:
1159     return false;  // never a singleton, therefore never empty
1160 
1161   default:
1162     ShouldNotReachHere();
1163     return false;
1164   }
1165 }
1166 
1167 //------------------------------dump_stats-------------------------------------
1168 // Dump collected statistics to stderr
1169 #ifndef PRODUCT
1170 void Type::dump_stats() {
1171   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1172 }
1173 #endif
1174 
1175 //------------------------------typerr-----------------------------------------
1176 void Type::typerr( const Type *t ) const {
1177 #ifndef PRODUCT
1178   tty-&gt;print(&quot;\nError mixing types: &quot;);
1179   dump();
1180   tty-&gt;print(&quot; and &quot;);
1181   t-&gt;dump();
1182   tty-&gt;print(&quot;\n&quot;);
1183 #endif
1184   ShouldNotReachHere();
1185 }
1186 
1187 
1188 //=============================================================================
1189 // Convenience common pre-built types.
1190 const TypeF *TypeF::ZERO;       // Floating point zero
1191 const TypeF *TypeF::ONE;        // Floating point one
1192 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1193 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1194 
1195 //------------------------------make-------------------------------------------
1196 // Create a float constant
1197 const TypeF *TypeF::make(float f) {
1198   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1199 }
1200 
1201 //------------------------------meet-------------------------------------------
1202 // Compute the MEET of two types.  It returns a new Type object.
1203 const Type *TypeF::xmeet( const Type *t ) const {
1204   // Perform a fast test for common case; meeting the same types together.
1205   if( this == t ) return this;  // Meeting same type-rep?
1206 
1207   // Current &quot;this-&gt;_base&quot; is FloatCon
1208   switch (t-&gt;base()) {          // Switch on original type
1209   case AnyPtr:                  // Mixing with oops happens when javac
1210   case RawPtr:                  // reuses local variables
1211   case OopPtr:
1212   case InstPtr:
1213   case AryPtr:
1214   case MetadataPtr:
1215   case KlassPtr:
1216   case NarrowOop:
1217   case NarrowKlass:
1218   case Int:
1219   case Long:
1220   case DoubleTop:
1221   case DoubleCon:
1222   case DoubleBot:
1223   case Bottom:                  // Ye Olde Default
1224     return Type::BOTTOM;
1225 
1226   case FloatBot:
1227     return t;
1228 
1229   default:                      // All else is a mistake
1230     typerr(t);
1231 
1232   case FloatCon:                // Float-constant vs Float-constant?
1233     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1234                                 // must compare bitwise as positive zero, negative zero and NaN have
1235                                 // all the same representation in C++
1236       return FLOAT;             // Return generic float
1237                                 // Equal constants
1238   case Top:
1239   case FloatTop:
1240     break;                      // Return the float constant
1241   }
1242   return this;                  // Return the float constant
1243 }
1244 
1245 //------------------------------xdual------------------------------------------
1246 // Dual: symmetric
1247 const Type *TypeF::xdual() const {
1248   return this;
1249 }
1250 
1251 //------------------------------eq---------------------------------------------
1252 // Structural equality check for Type representations
1253 bool TypeF::eq(const Type *t) const {
1254   // Bitwise comparison to distinguish between +/-0. These values must be treated
1255   // as different to be consistent with C1 and the interpreter.
1256   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1257 }
1258 
1259 //------------------------------hash-------------------------------------------
1260 // Type-specific hashing function.
1261 int TypeF::hash(void) const {
1262   return *(int*)(&amp;_f);
1263 }
1264 
1265 //------------------------------is_finite--------------------------------------
1266 // Has a finite value
1267 bool TypeF::is_finite() const {
1268   return g_isfinite(getf()) != 0;
1269 }
1270 
1271 //------------------------------is_nan-----------------------------------------
1272 // Is not a number (NaN)
1273 bool TypeF::is_nan()    const {
1274   return g_isnan(getf()) != 0;
1275 }
1276 
1277 //------------------------------dump2------------------------------------------
1278 // Dump float constant Type
1279 #ifndef PRODUCT
1280 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1281   Type::dump2(d,depth, st);
1282   st-&gt;print(&quot;%f&quot;, _f);
1283 }
1284 #endif
1285 
1286 //------------------------------singleton--------------------------------------
1287 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1288 // constants (Ldi nodes).  Singletons are integer, float or double constants
1289 // or a single symbol.
1290 bool TypeF::singleton(void) const {
1291   return true;                  // Always a singleton
1292 }
1293 
1294 bool TypeF::empty(void) const {
1295   return false;                 // always exactly a singleton
1296 }
1297 
1298 //=============================================================================
1299 // Convenience common pre-built types.
1300 const TypeD *TypeD::ZERO;       // Floating point zero
1301 const TypeD *TypeD::ONE;        // Floating point one
1302 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1303 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1304 
1305 //------------------------------make-------------------------------------------
1306 const TypeD *TypeD::make(double d) {
1307   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1308 }
1309 
1310 //------------------------------meet-------------------------------------------
1311 // Compute the MEET of two types.  It returns a new Type object.
1312 const Type *TypeD::xmeet( const Type *t ) const {
1313   // Perform a fast test for common case; meeting the same types together.
1314   if( this == t ) return this;  // Meeting same type-rep?
1315 
1316   // Current &quot;this-&gt;_base&quot; is DoubleCon
1317   switch (t-&gt;base()) {          // Switch on original type
1318   case AnyPtr:                  // Mixing with oops happens when javac
1319   case RawPtr:                  // reuses local variables
1320   case OopPtr:
1321   case InstPtr:
1322   case AryPtr:
1323   case MetadataPtr:
1324   case KlassPtr:
1325   case NarrowOop:
1326   case NarrowKlass:
1327   case Int:
1328   case Long:
1329   case FloatTop:
1330   case FloatCon:
1331   case FloatBot:
1332   case Bottom:                  // Ye Olde Default
1333     return Type::BOTTOM;
1334 
1335   case DoubleBot:
1336     return t;
1337 
1338   default:                      // All else is a mistake
1339     typerr(t);
1340 
1341   case DoubleCon:               // Double-constant vs Double-constant?
1342     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1343       return DOUBLE;            // Return generic double
1344   case Top:
1345   case DoubleTop:
1346     break;
1347   }
1348   return this;                  // Return the double constant
1349 }
1350 
1351 //------------------------------xdual------------------------------------------
1352 // Dual: symmetric
1353 const Type *TypeD::xdual() const {
1354   return this;
1355 }
1356 
1357 //------------------------------eq---------------------------------------------
1358 // Structural equality check for Type representations
1359 bool TypeD::eq(const Type *t) const {
1360   // Bitwise comparison to distinguish between +/-0. These values must be treated
1361   // as different to be consistent with C1 and the interpreter.
1362   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1363 }
1364 
1365 //------------------------------hash-------------------------------------------
1366 // Type-specific hashing function.
1367 int TypeD::hash(void) const {
1368   return *(int*)(&amp;_d);
1369 }
1370 
1371 //------------------------------is_finite--------------------------------------
1372 // Has a finite value
1373 bool TypeD::is_finite() const {
1374   return g_isfinite(getd()) != 0;
1375 }
1376 
1377 //------------------------------is_nan-----------------------------------------
1378 // Is not a number (NaN)
1379 bool TypeD::is_nan()    const {
1380   return g_isnan(getd()) != 0;
1381 }
1382 
1383 //------------------------------dump2------------------------------------------
1384 // Dump double constant Type
1385 #ifndef PRODUCT
1386 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1387   Type::dump2(d,depth,st);
1388   st-&gt;print(&quot;%f&quot;, _d);
1389 }
1390 #endif
1391 
1392 //------------------------------singleton--------------------------------------
1393 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1394 // constants (Ldi nodes).  Singletons are integer, float or double constants
1395 // or a single symbol.
1396 bool TypeD::singleton(void) const {
1397   return true;                  // Always a singleton
1398 }
1399 
1400 bool TypeD::empty(void) const {
1401   return false;                 // always exactly a singleton
1402 }
1403 
1404 //=============================================================================
1405 // Convience common pre-built types.
1406 const TypeInt *TypeInt::MINUS_1;// -1
1407 const TypeInt *TypeInt::ZERO;   // 0
1408 const TypeInt *TypeInt::ONE;    // 1
1409 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1410 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1411 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1412 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1413 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1414 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1415 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1416 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1417 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1418 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1419 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1420 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1421 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1422 const TypeInt *TypeInt::INT;    // 32-bit integers
1423 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1424 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1425 
1426 //------------------------------TypeInt----------------------------------------
1427 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1428 }
1429 
1430 //------------------------------make-------------------------------------------
1431 const TypeInt *TypeInt::make( jint lo ) {
1432   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1433 }
1434 
1435 static int normalize_int_widen( jint lo, jint hi, int w ) {
1436   // Certain normalizations keep us sane when comparing types.
1437   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1438   if (lo &lt;= hi) {
1439     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1440     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1441   } else {
1442     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1443     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1444   }
1445   return w;
1446 }
1447 
1448 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1449   w = normalize_int_widen(lo, hi, w);
1450   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1451 }
1452 
1453 //------------------------------meet-------------------------------------------
1454 // Compute the MEET of two types.  It returns a new Type representation object
1455 // with reference count equal to the number of Types pointing at it.
1456 // Caller should wrap a Types around it.
1457 const Type *TypeInt::xmeet( const Type *t ) const {
1458   // Perform a fast test for common case; meeting the same types together.
1459   if( this == t ) return this;  // Meeting same type?
1460 
1461   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1462   switch (t-&gt;base()) {          // Switch on original type
1463   case AnyPtr:                  // Mixing with oops happens when javac
1464   case RawPtr:                  // reuses local variables
1465   case OopPtr:
1466   case InstPtr:
1467   case AryPtr:
1468   case MetadataPtr:
1469   case KlassPtr:
1470   case NarrowOop:
1471   case NarrowKlass:
1472   case Long:
1473   case FloatTop:
1474   case FloatCon:
1475   case FloatBot:
1476   case DoubleTop:
1477   case DoubleCon:
1478   case DoubleBot:
1479   case Bottom:                  // Ye Olde Default
1480     return Type::BOTTOM;
1481   default:                      // All else is a mistake
1482     typerr(t);
1483   case Top:                     // No change
1484     return this;
1485   case Int:                     // Int vs Int?
1486     break;
1487   }
1488 
1489   // Expand covered set
1490   const TypeInt *r = t-&gt;is_int();
1491   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1492 }
1493 
1494 //------------------------------xdual------------------------------------------
1495 // Dual: reverse hi &amp; lo; flip widen
1496 const Type *TypeInt::xdual() const {
1497   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1498   return new TypeInt(_hi,_lo,w);
1499 }
1500 
1501 //------------------------------widen------------------------------------------
1502 // Only happens for optimistic top-down optimizations.
1503 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1504   // Coming from TOP or such; no widening
1505   if( old-&gt;base() != Int ) return this;
1506   const TypeInt *ot = old-&gt;is_int();
1507 
1508   // If new guy is equal to old guy, no widening
1509   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1510     return old;
1511 
1512   // If new guy contains old, then we widened
1513   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1514     // New contains old
1515     // If new guy is already wider than old, no widening
1516     if( _widen &gt; ot-&gt;_widen ) return this;
1517     // If old guy was a constant, do not bother
1518     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1519     // Now widen new guy.
1520     // Check for widening too far
1521     if (_widen == WidenMax) {
1522       int max = max_jint;
1523       int min = min_jint;
1524       if (limit-&gt;isa_int()) {
1525         max = limit-&gt;is_int()-&gt;_hi;
1526         min = limit-&gt;is_int()-&gt;_lo;
1527       }
1528       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1529         // If neither endpoint is extremal yet, push out the endpoint
1530         // which is closer to its respective limit.
1531         if (_lo &gt;= 0 ||                 // easy common case
1532             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1533           // Try to widen to an unsigned range type of 31 bits:
1534           return make(_lo, max, WidenMax);
1535         } else {
1536           return make(min, _hi, WidenMax);
1537         }
1538       }
1539       return TypeInt::INT;
1540     }
1541     // Returned widened new guy
1542     return make(_lo,_hi,_widen+1);
1543   }
1544 
1545   // If old guy contains new, then we probably widened too far &amp; dropped to
1546   // bottom.  Return the wider fellow.
1547   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1548     return old;
1549 
1550   //fatal(&quot;Integer value range is not subset&quot;);
1551   //return this;
1552   return TypeInt::INT;
1553 }
1554 
1555 //------------------------------narrow---------------------------------------
1556 // Only happens for pessimistic optimizations.
1557 const Type *TypeInt::narrow( const Type *old ) const {
1558   if (_lo &gt;= _hi)  return this;   // already narrow enough
1559   if (old == NULL)  return this;
1560   const TypeInt* ot = old-&gt;isa_int();
1561   if (ot == NULL)  return this;
1562   jint olo = ot-&gt;_lo;
1563   jint ohi = ot-&gt;_hi;
1564 
1565   // If new guy is equal to old guy, no narrowing
1566   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1567 
1568   // If old guy was maximum range, allow the narrowing
1569   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1570 
1571   if (_lo &lt; olo || _hi &gt; ohi)
1572     return this;                // doesn&#39;t narrow; pretty wierd
1573 
1574   // The new type narrows the old type, so look for a &quot;death march&quot;.
1575   // See comments on PhaseTransform::saturate.
1576   juint nrange = (juint)_hi - _lo;
1577   juint orange = (juint)ohi - olo;
1578   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1579     // Use the new type only if the range shrinks a lot.
1580     // We do not want the optimizer computing 2^31 point by point.
1581     return old;
1582   }
1583 
1584   return this;
1585 }
1586 
1587 //-----------------------------filter------------------------------------------
1588 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1589   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1590   if (ft == NULL || ft-&gt;empty())
1591     return Type::TOP;           // Canonical empty value
1592   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1593     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1594     // The widen bits must be allowed to run freely through the graph.
1595     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1596   }
1597   return ft;
1598 }
1599 
1600 //------------------------------eq---------------------------------------------
1601 // Structural equality check for Type representations
1602 bool TypeInt::eq( const Type *t ) const {
1603   const TypeInt *r = t-&gt;is_int(); // Handy access
1604   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1605 }
1606 
1607 //------------------------------hash-------------------------------------------
1608 // Type-specific hashing function.
1609 int TypeInt::hash(void) const {
1610   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1611 }
1612 
1613 //------------------------------is_finite--------------------------------------
1614 // Has a finite value
1615 bool TypeInt::is_finite() const {
1616   return true;
1617 }
1618 
1619 //------------------------------dump2------------------------------------------
1620 // Dump TypeInt
1621 #ifndef PRODUCT
1622 static const char* intname(char* buf, jint n) {
1623   if (n == min_jint)
1624     return &quot;min&quot;;
1625   else if (n &lt; min_jint + 10000)
1626     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1627   else if (n == max_jint)
1628     return &quot;max&quot;;
1629   else if (n &gt; max_jint - 10000)
1630     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1631   else
1632     sprintf(buf, INT32_FORMAT, n);
1633   return buf;
1634 }
1635 
1636 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1637   char buf[40], buf2[40];
1638   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1639     st-&gt;print(&quot;int&quot;);
1640   else if (is_con())
1641     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1642   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1643     st-&gt;print(&quot;bool&quot;);
1644   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1645     st-&gt;print(&quot;byte&quot;);
1646   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1647     st-&gt;print(&quot;char&quot;);
1648   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1649     st-&gt;print(&quot;short&quot;);
1650   else if (_hi == max_jint)
1651     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1652   else if (_lo == min_jint)
1653     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1654   else
1655     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1656 
1657   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1658     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1659 }
1660 #endif
1661 
1662 //------------------------------singleton--------------------------------------
1663 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1664 // constants.
1665 bool TypeInt::singleton(void) const {
1666   return _lo &gt;= _hi;
1667 }
1668 
1669 bool TypeInt::empty(void) const {
1670   return _lo &gt; _hi;
1671 }
1672 
1673 //=============================================================================
1674 // Convenience common pre-built types.
1675 const TypeLong *TypeLong::MINUS_1;// -1
1676 const TypeLong *TypeLong::ZERO; // 0
1677 const TypeLong *TypeLong::ONE;  // 1
1678 const TypeLong *TypeLong::POS;  // &gt;=0
1679 const TypeLong *TypeLong::LONG; // 64-bit integers
1680 const TypeLong *TypeLong::INT;  // 32-bit subrange
1681 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1682 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1683 
1684 //------------------------------TypeLong---------------------------------------
1685 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1686 }
1687 
1688 //------------------------------make-------------------------------------------
1689 const TypeLong *TypeLong::make( jlong lo ) {
1690   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1691 }
1692 
1693 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1694   // Certain normalizations keep us sane when comparing types.
1695   // The &#39;SMALLINT&#39; covers constants.
1696   if (lo &lt;= hi) {
1697     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1698     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1699   } else {
1700     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1701     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1702   }
1703   return w;
1704 }
1705 
1706 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1707   w = normalize_long_widen(lo, hi, w);
1708   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1709 }
1710 
1711 
1712 //------------------------------meet-------------------------------------------
1713 // Compute the MEET of two types.  It returns a new Type representation object
1714 // with reference count equal to the number of Types pointing at it.
1715 // Caller should wrap a Types around it.
1716 const Type *TypeLong::xmeet( const Type *t ) const {
1717   // Perform a fast test for common case; meeting the same types together.
1718   if( this == t ) return this;  // Meeting same type?
1719 
1720   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1721   switch (t-&gt;base()) {          // Switch on original type
1722   case AnyPtr:                  // Mixing with oops happens when javac
1723   case RawPtr:                  // reuses local variables
1724   case OopPtr:
1725   case InstPtr:
1726   case AryPtr:
1727   case MetadataPtr:
1728   case KlassPtr:
1729   case NarrowOop:
1730   case NarrowKlass:
1731   case Int:
1732   case FloatTop:
1733   case FloatCon:
1734   case FloatBot:
1735   case DoubleTop:
1736   case DoubleCon:
1737   case DoubleBot:
1738   case Bottom:                  // Ye Olde Default
1739     return Type::BOTTOM;
1740   default:                      // All else is a mistake
1741     typerr(t);
1742   case Top:                     // No change
1743     return this;
1744   case Long:                    // Long vs Long?
1745     break;
1746   }
1747 
1748   // Expand covered set
1749   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1750   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1751 }
1752 
1753 //------------------------------xdual------------------------------------------
1754 // Dual: reverse hi &amp; lo; flip widen
1755 const Type *TypeLong::xdual() const {
1756   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1757   return new TypeLong(_hi,_lo,w);
1758 }
1759 
1760 //------------------------------widen------------------------------------------
1761 // Only happens for optimistic top-down optimizations.
1762 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1763   // Coming from TOP or such; no widening
1764   if( old-&gt;base() != Long ) return this;
1765   const TypeLong *ot = old-&gt;is_long();
1766 
1767   // If new guy is equal to old guy, no widening
1768   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1769     return old;
1770 
1771   // If new guy contains old, then we widened
1772   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1773     // New contains old
1774     // If new guy is already wider than old, no widening
1775     if( _widen &gt; ot-&gt;_widen ) return this;
1776     // If old guy was a constant, do not bother
1777     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1778     // Now widen new guy.
1779     // Check for widening too far
1780     if (_widen == WidenMax) {
1781       jlong max = max_jlong;
1782       jlong min = min_jlong;
1783       if (limit-&gt;isa_long()) {
1784         max = limit-&gt;is_long()-&gt;_hi;
1785         min = limit-&gt;is_long()-&gt;_lo;
1786       }
1787       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1788         // If neither endpoint is extremal yet, push out the endpoint
1789         // which is closer to its respective limit.
1790         if (_lo &gt;= 0 ||                 // easy common case
1791             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1792           // Try to widen to an unsigned range type of 32/63 bits:
1793           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1794             return make(_lo, max_juint, WidenMax);
1795           else
1796             return make(_lo, max, WidenMax);
1797         } else {
1798           return make(min, _hi, WidenMax);
1799         }
1800       }
1801       return TypeLong::LONG;
1802     }
1803     // Returned widened new guy
1804     return make(_lo,_hi,_widen+1);
1805   }
1806 
1807   // If old guy contains new, then we probably widened too far &amp; dropped to
1808   // bottom.  Return the wider fellow.
1809   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1810     return old;
1811 
1812   //  fatal(&quot;Long value range is not subset&quot;);
1813   // return this;
1814   return TypeLong::LONG;
1815 }
1816 
1817 //------------------------------narrow----------------------------------------
1818 // Only happens for pessimistic optimizations.
1819 const Type *TypeLong::narrow( const Type *old ) const {
1820   if (_lo &gt;= _hi)  return this;   // already narrow enough
1821   if (old == NULL)  return this;
1822   const TypeLong* ot = old-&gt;isa_long();
1823   if (ot == NULL)  return this;
1824   jlong olo = ot-&gt;_lo;
1825   jlong ohi = ot-&gt;_hi;
1826 
1827   // If new guy is equal to old guy, no narrowing
1828   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1829 
1830   // If old guy was maximum range, allow the narrowing
1831   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1832 
1833   if (_lo &lt; olo || _hi &gt; ohi)
1834     return this;                // doesn&#39;t narrow; pretty wierd
1835 
1836   // The new type narrows the old type, so look for a &quot;death march&quot;.
1837   // See comments on PhaseTransform::saturate.
1838   julong nrange = _hi - _lo;
1839   julong orange = ohi - olo;
1840   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1841     // Use the new type only if the range shrinks a lot.
1842     // We do not want the optimizer computing 2^31 point by point.
1843     return old;
1844   }
1845 
1846   return this;
1847 }
1848 
1849 //-----------------------------filter------------------------------------------
1850 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1851   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1852   if (ft == NULL || ft-&gt;empty())
1853     return Type::TOP;           // Canonical empty value
1854   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1855     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1856     // The widen bits must be allowed to run freely through the graph.
1857     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1858   }
1859   return ft;
1860 }
1861 
1862 //------------------------------eq---------------------------------------------
1863 // Structural equality check for Type representations
1864 bool TypeLong::eq( const Type *t ) const {
1865   const TypeLong *r = t-&gt;is_long(); // Handy access
1866   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1867 }
1868 
1869 //------------------------------hash-------------------------------------------
1870 // Type-specific hashing function.
1871 int TypeLong::hash(void) const {
1872   return (int)(_lo+_hi+_widen+(int)Type::Long);
1873 }
1874 
1875 //------------------------------is_finite--------------------------------------
1876 // Has a finite value
1877 bool TypeLong::is_finite() const {
1878   return true;
1879 }
1880 
1881 //------------------------------dump2------------------------------------------
1882 // Dump TypeLong
1883 #ifndef PRODUCT
1884 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1885   if (n &gt; x) {
1886     if (n &gt;= x + 10000)  return NULL;
1887     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1888   } else if (n &lt; x) {
1889     if (n &lt;= x - 10000)  return NULL;
1890     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1891   } else {
1892     return xname;
1893   }
1894   return buf;
1895 }
1896 
1897 static const char* longname(char* buf, jlong n) {
1898   const char* str;
1899   if (n == min_jlong)
1900     return &quot;min&quot;;
1901   else if (n &lt; min_jlong + 10000)
1902     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1903   else if (n == max_jlong)
1904     return &quot;max&quot;;
1905   else if (n &gt; max_jlong - 10000)
1906     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1907   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1908     return str;
1909   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1910     return str;
1911   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1912     return str;
1913   else
1914     sprintf(buf, JLONG_FORMAT, n);
1915   return buf;
1916 }
1917 
1918 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1919   char buf[80], buf2[80];
1920   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1921     st-&gt;print(&quot;long&quot;);
1922   else if (is_con())
1923     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1924   else if (_hi == max_jlong)
1925     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1926   else if (_lo == min_jlong)
1927     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1928   else
1929     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1930 
1931   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1932     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1933 }
1934 #endif
1935 
1936 //------------------------------singleton--------------------------------------
1937 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1938 // constants
1939 bool TypeLong::singleton(void) const {
1940   return _lo &gt;= _hi;
1941 }
1942 
1943 bool TypeLong::empty(void) const {
1944   return _lo &gt; _hi;
1945 }
1946 
1947 //=============================================================================
1948 // Convenience common pre-built types.
1949 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1950 const TypeTuple *TypeTuple::IFFALSE;
1951 const TypeTuple *TypeTuple::IFTRUE;
1952 const TypeTuple *TypeTuple::IFNEITHER;
1953 const TypeTuple *TypeTuple::LOOPBODY;
1954 const TypeTuple *TypeTuple::MEMBAR;
1955 const TypeTuple *TypeTuple::STORECONDITIONAL;
1956 const TypeTuple *TypeTuple::START_I2C;
1957 const TypeTuple *TypeTuple::INT_PAIR;
1958 const TypeTuple *TypeTuple::LONG_PAIR;
1959 const TypeTuple *TypeTuple::INT_CC_PAIR;
1960 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1961 
1962 static void collect_value_fields(ciValueKlass* vk, const Type** field_array, uint&amp; pos, ExtendedSignature&amp; sig_cc) {
1963   for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
1964     ciField* field = vk-&gt;nonstatic_field_at(j);
1965     BasicType bt = field-&gt;type()-&gt;basic_type();
1966     const Type* ft = Type::get_const_type(field-&gt;type());
1967     field_array[pos++] = ft;
1968     if (type2size[bt] == 2) {
1969       field_array[pos++] = Type::HALF;
1970     }
1971     // Skip reserved arguments
1972     while (SigEntry::next_is_reserved(sig_cc, bt)) {
1973       field_array[pos++] = Type::get_const_basic_type(bt);
1974       if (type2size[bt] == 2) {
1975         field_array[pos++] = Type::HALF;
1976       }
1977     }
1978   }
1979 }
1980 
1981 //------------------------------make-------------------------------------------
1982 // Make a TypeTuple from the range of a method signature
1983 const TypeTuple *TypeTuple::make_range(ciSignature* sig, bool ret_vt_fields) {
1984   ciType* return_type = sig-&gt;return_type();
1985   uint arg_cnt = return_type-&gt;size();
1986   if (ret_vt_fields) {
1987     arg_cnt = return_type-&gt;as_value_klass()-&gt;value_arg_slots() + 1;
1988   }
1989 
1990   const Type **field_array = fields(arg_cnt);
1991   switch (return_type-&gt;basic_type()) {
1992   case T_LONG:
1993     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1994     field_array[TypeFunc::Parms+1] = Type::HALF;
1995     break;
1996   case T_DOUBLE:
1997     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1998     field_array[TypeFunc::Parms+1] = Type::HALF;
1999     break;
2000   case T_OBJECT:
2001   case T_ARRAY:
2002   case T_BOOLEAN:
2003   case T_CHAR:
2004   case T_FLOAT:
2005   case T_BYTE:
2006   case T_SHORT:
2007   case T_INT:
2008     field_array[TypeFunc::Parms] = get_const_type(return_type);
2009     break;
2010   case T_VALUETYPE:
2011     if (ret_vt_fields) {
2012       uint pos = TypeFunc::Parms;
2013       field_array[pos] = TypePtr::BOTTOM;
2014       pos++;
2015       ExtendedSignature sig = ExtendedSignature(NULL, SigEntryFilter());
2016       collect_value_fields(return_type-&gt;as_value_klass(), field_array, pos, sig);
2017     } else {
2018       field_array[TypeFunc::Parms] = get_const_type(return_type)-&gt;join_speculative(sig-&gt;returns_never_null() ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2019     }
2020     break;
2021   case T_VOID:
2022     break;
2023   default:
2024     ShouldNotReachHere();
2025   }
2026   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2027 }
2028 
2029 // Make a TypeTuple from the domain of a method signature
2030 const TypeTuple *TypeTuple::make_domain(ciMethod* method, bool vt_fields_as_args) {
2031   ciSignature* sig = method-&gt;signature();
2032   ExtendedSignature sig_cc = ExtendedSignature(vt_fields_as_args ? method-&gt;get_sig_cc() : NULL, SigEntryFilter());
2033 
2034   uint arg_cnt = sig-&gt;size() + (method-&gt;is_static() ? 0 : 1);
2035   if (vt_fields_as_args) {
2036     for (arg_cnt = 0; !sig_cc.at_end(); ++sig_cc) {
2037       arg_cnt += type2size[(*sig_cc)._bt];
2038     }
2039     sig_cc = ExtendedSignature(method-&gt;get_sig_cc(), SigEntryFilter());
2040   }
2041 
2042   uint pos = TypeFunc::Parms;
2043   const Type** field_array = fields(arg_cnt);
2044   if (!method-&gt;is_static()) {
2045     ciInstanceKlass* recv = method-&gt;holder();
2046     if (vt_fields_as_args &amp;&amp; recv-&gt;is_valuetype() &amp;&amp; recv-&gt;as_value_klass()-&gt;is_scalarizable()) {
2047       collect_value_fields(recv-&gt;as_value_klass(), field_array, pos, sig_cc);
2048     } else {
2049       field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
2050       if (vt_fields_as_args) {
2051         ++sig_cc;
2052       }
2053     }
2054   }
2055 
2056   int i = 0;
2057   while (pos &lt; TypeFunc::Parms + arg_cnt) {
2058     ciType* type = sig-&gt;type_at(i);
2059     BasicType bt = type-&gt;basic_type();
2060     bool is_flattened = false;
2061 
2062     switch (bt) {
2063     case T_LONG:
2064       field_array[pos++] = TypeLong::LONG;
2065       field_array[pos++] = Type::HALF;
2066       break;
2067     case T_DOUBLE:
2068       field_array[pos++] = Type::DOUBLE;
2069       field_array[pos++] = Type::HALF;
2070       break;
2071     case T_OBJECT:
2072     case T_ARRAY:
2073     case T_FLOAT:
2074     case T_INT:
2075       field_array[pos++] = get_const_type(type);
2076       break;
2077     case T_BOOLEAN:
2078     case T_CHAR:
2079     case T_BYTE:
2080     case T_SHORT:
2081       field_array[pos++] = TypeInt::INT;
2082       break;
2083     case T_VALUETYPE: {
2084       bool never_null = sig-&gt;is_never_null_at(i);
2085       if (vt_fields_as_args &amp;&amp; type-&gt;as_value_klass()-&gt;is_scalarizable() &amp;&amp; never_null) {
2086         is_flattened = true;
2087         collect_value_fields(type-&gt;as_value_klass(), field_array, pos, sig_cc);
2088       } else {
2089         field_array[pos++] = get_const_type(type)-&gt;join_speculative(never_null ? TypePtr::NOTNULL : TypePtr::BOTTOM);
2090       }
2091       break;
2092     }
2093     default:
2094       ShouldNotReachHere();
2095     }
2096     // Skip reserved arguments
2097     while (!is_flattened &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt)) {
2098       field_array[pos++] = Type::get_const_basic_type(bt);
2099       if (type2size[bt] == 2) {
2100         field_array[pos++] = Type::HALF;
2101       }
2102     }
2103     i++;
2104   }
2105   assert(pos == TypeFunc::Parms + arg_cnt, &quot;wrong number of arguments&quot;);
2106 
2107   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
2108 }
2109 
2110 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
2111   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
2112 }
2113 
2114 //------------------------------fields-----------------------------------------
2115 // Subroutine call type with space allocated for argument types
2116 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
2117 const Type **TypeTuple::fields( uint arg_cnt ) {
2118   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
2119   flds[TypeFunc::Control  ] = Type::CONTROL;
2120   flds[TypeFunc::I_O      ] = Type::ABIO;
2121   flds[TypeFunc::Memory   ] = Type::MEMORY;
2122   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
2123   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
2124 
2125   return flds;
2126 }
2127 
2128 //------------------------------meet-------------------------------------------
2129 // Compute the MEET of two types.  It returns a new Type object.
2130 const Type *TypeTuple::xmeet( const Type *t ) const {
2131   // Perform a fast test for common case; meeting the same types together.
2132   if( this == t ) return this;  // Meeting same type-rep?
2133 
2134   // Current &quot;this-&gt;_base&quot; is Tuple
2135   switch (t-&gt;base()) {          // switch on original type
2136 
2137   case Bottom:                  // Ye Olde Default
2138     return t;
2139 
2140   default:                      // All else is a mistake
2141     typerr(t);
2142 
2143   case Tuple: {                 // Meeting 2 signatures?
2144     const TypeTuple *x = t-&gt;is_tuple();
2145     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2146     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2147     for( uint i=0; i&lt;_cnt; i++ )
2148       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2149     return TypeTuple::make(_cnt,fields);
2150   }
2151   case Top:
2152     break;
2153   }
2154   return this;                  // Return the double constant
2155 }
2156 
2157 //------------------------------xdual------------------------------------------
2158 // Dual: compute field-by-field dual
2159 const Type *TypeTuple::xdual() const {
2160   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2161   for( uint i=0; i&lt;_cnt; i++ )
2162     fields[i] = _fields[i]-&gt;dual();
2163   return new TypeTuple(_cnt,fields);
2164 }
2165 
2166 //------------------------------eq---------------------------------------------
2167 // Structural equality check for Type representations
2168 bool TypeTuple::eq( const Type *t ) const {
2169   const TypeTuple *s = (const TypeTuple *)t;
2170   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2171   for (uint i = 0; i &lt; _cnt; i++)
2172     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2173       return false;             // Missed
2174   return true;
2175 }
2176 
2177 //------------------------------hash-------------------------------------------
2178 // Type-specific hashing function.
2179 int TypeTuple::hash(void) const {
2180   intptr_t sum = _cnt;
2181   for( uint i=0; i&lt;_cnt; i++ )
2182     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2183   return sum;
2184 }
2185 
2186 //------------------------------dump2------------------------------------------
2187 // Dump signature Type
2188 #ifndef PRODUCT
2189 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2190   st-&gt;print(&quot;{&quot;);
2191   if( !depth || d[this] ) {     // Check for recursive print
2192     st-&gt;print(&quot;...}&quot;);
2193     return;
2194   }
2195   d.Insert((void*)this, (void*)this);   // Stop recursion
2196   if( _cnt ) {
2197     uint i;
2198     for( i=0; i&lt;_cnt-1; i++ ) {
2199       st-&gt;print(&quot;%d:&quot;, i);
2200       _fields[i]-&gt;dump2(d, depth-1, st);
2201       st-&gt;print(&quot;, &quot;);
2202     }
2203     st-&gt;print(&quot;%d:&quot;, i);
2204     _fields[i]-&gt;dump2(d, depth-1, st);
2205   }
2206   st-&gt;print(&quot;}&quot;);
2207 }
2208 #endif
2209 
2210 //------------------------------singleton--------------------------------------
2211 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2212 // constants (Ldi nodes).  Singletons are integer, float or double constants
2213 // or a single symbol.
2214 bool TypeTuple::singleton(void) const {
2215   return false;                 // Never a singleton
2216 }
2217 
2218 bool TypeTuple::empty(void) const {
2219   for( uint i=0; i&lt;_cnt; i++ ) {
2220     if (_fields[i]-&gt;empty())  return true;
2221   }
2222   return false;
2223 }
2224 
2225 //=============================================================================
2226 // Convenience common pre-built types.
2227 
2228 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2229   // Certain normalizations keep us sane when comparing types.
2230   // We do not want arrayOop variables to differ only by the wideness
2231   // of their index types.  Pick minimum wideness, since that is the
2232   // forced wideness of small ranges anyway.
2233   if (size-&gt;_widen != Type::WidenMin)
2234     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2235   else
2236     return size;
2237 }
2238 
2239 //------------------------------make-------------------------------------------
2240 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable,
2241                              bool not_flat, bool not_null_free) {
2242   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2243     elem = elem-&gt;make_narrowoop();
2244   }
2245   size = normalize_array_size(size);
2246   return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))-&gt;hashcons();
2247 }
2248 
2249 //------------------------------meet-------------------------------------------
2250 // Compute the MEET of two types.  It returns a new Type object.
2251 const Type *TypeAry::xmeet( const Type *t ) const {
2252   // Perform a fast test for common case; meeting the same types together.
2253   if( this == t ) return this;  // Meeting same type-rep?
2254 
2255   // Current &quot;this-&gt;_base&quot; is Ary
2256   switch (t-&gt;base()) {          // switch on original type
2257 
2258   case Bottom:                  // Ye Olde Default
2259     return t;
2260 
2261   default:                      // All else is a mistake
2262     typerr(t);
2263 
2264   case Array: {                 // Meeting 2 arrays?
2265     const TypeAry *a = t-&gt;is_ary();
2266     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2267                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2268                          _stable &amp;&amp; a-&gt;_stable,
2269                          _not_flat &amp;&amp; a-&gt;_not_flat,
2270                          _not_null_free &amp;&amp; a-&gt;_not_null_free);
2271   }
2272   case Top:
2273     break;
2274   }
2275   return this;                  // Return the double constant
2276 }
2277 
2278 //------------------------------xdual------------------------------------------
2279 // Dual: compute field-by-field dual
2280 const Type *TypeAry::xdual() const {
2281   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2282   size_dual = normalize_array_size(size_dual);
2283   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable, !_not_flat, !_not_null_free);
2284 }
2285 
2286 //------------------------------eq---------------------------------------------
2287 // Structural equality check for Type representations
2288 bool TypeAry::eq( const Type *t ) const {
2289   const TypeAry *a = (const TypeAry*)t;
2290   return _elem == a-&gt;_elem &amp;&amp;
2291     _stable == a-&gt;_stable &amp;&amp;
2292     _size == a-&gt;_size &amp;&amp;
2293     _not_flat == a-&gt;_not_flat &amp;&amp;
2294     _not_null_free == a-&gt;_not_null_free;
2295 
2296 }
2297 
2298 //------------------------------hash-------------------------------------------
2299 // Type-specific hashing function.
2300 int TypeAry::hash(void) const {
2301   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2302 }
2303 
2304 /**
2305  * Return same type without a speculative part in the element
2306  */
2307 const Type* TypeAry::remove_speculative() const {
2308   return make(_elem-&gt;remove_speculative(), _size, _stable, _not_flat, _not_null_free);
2309 }
2310 
2311 /**
2312  * Return same type with cleaned up speculative part of element
2313  */
2314 const Type* TypeAry::cleanup_speculative() const {
2315   return make(_elem-&gt;cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);
2316 }
2317 
2318 /**
2319  * Return same type but with a different inline depth (used for speculation)
2320  *
2321  * @param depth  depth to meet with
2322  */
2323 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2324   if (!UseInlineDepthForSpeculativeTypes) {
2325     return this;
2326   }
2327   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2328 }
2329 
2330 //----------------------interface_vs_oop---------------------------------------
2331 #ifdef ASSERT
2332 bool TypeAry::interface_vs_oop(const Type *t) const {
2333   const TypeAry* t_ary = t-&gt;is_ary();
2334   if (t_ary) {
2335     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2336     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2337     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2338       return this_ptr-&gt;interface_vs_oop(t_ptr);
2339     }
2340   }
2341   return false;
2342 }
2343 #endif
2344 
2345 //------------------------------dump2------------------------------------------
2346 #ifndef PRODUCT
2347 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2348   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2349   if (Verbose) {
2350     if (_not_flat) st-&gt;print(&quot;not flat:&quot;);
2351     if (_not_null_free) st-&gt;print(&quot;not null free:&quot;);
2352   }
2353   _elem-&gt;dump2(d, depth, st);
2354   st-&gt;print(&quot;[&quot;);
2355   _size-&gt;dump2(d, depth, st);
2356   st-&gt;print(&quot;]&quot;);
2357 }
2358 #endif
2359 
2360 //------------------------------singleton--------------------------------------
2361 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2362 // constants (Ldi nodes).  Singletons are integer, float or double constants
2363 // or a single symbol.
2364 bool TypeAry::singleton(void) const {
2365   return false;                 // Never a singleton
2366 }
2367 
2368 bool TypeAry::empty(void) const {
2369   return _elem-&gt;empty() || _size-&gt;empty();
2370 }
2371 
2372 //--------------------------ary_must_be_exact----------------------------------
2373 bool TypeAry::ary_must_be_exact() const {
2374   if (!UseExactTypes)       return false;
2375   // This logic looks at the element type of an array, and returns true
2376   // if the element type is either a primitive or a final instance class.
2377   // In such cases, an array built on this ary must have no subclasses.
2378   if (_elem == BOTTOM)      return false;  // general array not exact
2379   if (_elem == TOP   )      return false;  // inverted general array not exact
2380   const TypeOopPtr*  toop = NULL;
2381   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2382     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2383   } else {
2384     toop = _elem-&gt;isa_oopptr();
2385   }
2386   if (!toop)                return true;   // a primitive type, like int
2387   ciKlass* tklass = toop-&gt;klass();
2388   if (tklass == NULL)       return false;  // unloaded class
2389   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2390   const TypeInstPtr* tinst;
2391   if (_elem-&gt;isa_narrowoop())
2392     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2393   else
2394     tinst = _elem-&gt;isa_instptr();
2395   if (tinst) {
2396     // [V? has a subtype: [V. So even though V is final, [V? is not exact.
2397     if (tklass-&gt;as_instance_klass()-&gt;is_final()) {
2398       if (tinst-&gt;is_valuetypeptr() &amp;&amp; (tinst-&gt;ptr() == TypePtr::BotPTR || tinst-&gt;ptr() == TypePtr::TopPTR)) {
2399         return false;
2400       }
2401       return true;
2402     }
2403     return false;
2404   }
2405   const TypeAryPtr*  tap;
2406   if (_elem-&gt;isa_narrowoop())
2407     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2408   else
2409     tap = _elem-&gt;isa_aryptr();
2410   if (tap)
2411     return tap-&gt;ary()-&gt;ary_must_be_exact();
2412   return false;
2413 }
2414 
2415 //==============================TypeValueType=======================================
2416 
2417 const TypeValueType *TypeValueType::BOTTOM;
2418 
2419 //------------------------------make-------------------------------------------
2420 const TypeValueType* TypeValueType::make(ciValueKlass* vk, bool larval) {
2421   return (TypeValueType*)(new TypeValueType(vk, larval))-&gt;hashcons();
2422 }
2423 
2424 //------------------------------meet-------------------------------------------
2425 // Compute the MEET of two types.  It returns a new Type object.
2426 const Type* TypeValueType::xmeet(const Type* t) const {
2427   // Perform a fast test for common case; meeting the same types together.
2428   if(this == t) return this;  // Meeting same type-rep?
2429 
2430   // Current &quot;this-&gt;_base&quot; is ValueType
2431   switch (t-&gt;base()) {          // switch on original type
2432 
2433   case Int:
2434   case Long:
2435   case FloatTop:
2436   case FloatCon:
2437   case FloatBot:
2438   case DoubleTop:
2439   case DoubleCon:
2440   case DoubleBot:
2441   case NarrowKlass:
2442   case Bottom:
2443     return Type::BOTTOM;
2444 
2445   case OopPtr:
2446   case MetadataPtr:
2447   case KlassPtr:
2448   case RawPtr:
2449     return TypePtr::BOTTOM;
2450 
2451   case Top:
2452     return this;
2453 
2454   case NarrowOop: {
2455     const Type* res = t-&gt;make_ptr()-&gt;xmeet(this);
2456     if (res-&gt;isa_ptr()) {
2457       return res-&gt;make_narrowoop();
2458     }
2459     return res;
2460   }
2461 
2462   case AryPtr:
2463   case InstPtr: {
2464     return t-&gt;xmeet(this);
2465   }
2466 
2467   case ValueType: {
2468     // All value types inherit from Object
2469     const TypeValueType* other = t-&gt;is_valuetype();
2470     if (_vk == NULL) {
2471       return this;
2472     } else if (other-&gt;_vk == NULL) {
2473       return other;
2474     } else if (_vk == other-&gt;_vk) {
2475       if (_larval == other-&gt;_larval ||
2476           !_larval) {
2477         return this;
2478       } else {
2479         return t;
2480       }
2481     }
2482     return TypeInstPtr::NOTNULL;
2483   }
2484 
2485   default:                      // All else is a mistake
2486     typerr(t);
2487 
2488   }
2489   return this;
2490 }
2491 
2492 //------------------------------xdual------------------------------------------
2493 const Type* TypeValueType::xdual() const {
2494   return this;
2495 }
2496 
2497 //------------------------------eq---------------------------------------------
2498 // Structural equality check for Type representations
2499 bool TypeValueType::eq(const Type* t) const {
2500   const TypeValueType* vt = t-&gt;is_valuetype();
2501   return (_vk == vt-&gt;value_klass() &amp;&amp; _larval == vt-&gt;larval());
2502 }
2503 
2504 //------------------------------hash-------------------------------------------
2505 // Type-specific hashing function.
2506 int TypeValueType::hash(void) const {
2507   return (intptr_t)_vk;
2508 }
2509 
2510 //------------------------------singleton--------------------------------------
2511 // TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.
2512 bool TypeValueType::singleton(void) const {
2513   return false;
2514 }
2515 
2516 //------------------------------empty------------------------------------------
2517 // TRUE if Type is a type with no values, FALSE otherwise.
2518 bool TypeValueType::empty(void) const {
2519   return false;
2520 }
2521 
2522 //------------------------------dump2------------------------------------------
2523 #ifndef PRODUCT
2524 void TypeValueType::dump2(Dict &amp;d, uint depth, outputStream* st) const {
2525   if (_vk == NULL) {
2526     st-&gt;print(&quot;BOTTOM valuetype&quot;);
2527     return;
2528   }
2529   int count = _vk-&gt;nof_declared_nonstatic_fields();
2530   st-&gt;print(&quot;valuetype[%d]:{&quot;, count);
2531   st-&gt;print(&quot;%s&quot;, count != 0 ? _vk-&gt;declared_nonstatic_field_at(0)-&gt;type()-&gt;name() : &quot;empty&quot;);
2532   for (int i = 1; i &lt; count; ++i) {
2533     st-&gt;print(&quot;, %s&quot;, _vk-&gt;declared_nonstatic_field_at(i)-&gt;type()-&gt;name());
2534   }
2535   st-&gt;print(&quot;}%s&quot;, _larval?&quot; : larval&quot;:&quot;&quot;);
2536 }
2537 #endif
2538 
2539 //==============================TypeVect=======================================
2540 // Convenience common pre-built types.
2541 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2542 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2543 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2544 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2545 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2546 
2547 //------------------------------make-------------------------------------------
2548 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2549   BasicType elem_bt = elem-&gt;array_element_basic_type();
2550   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2551   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2552   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2553   int size = length * type2aelembytes(elem_bt);
2554   switch (Matcher::vector_ideal_reg(size)) {
2555   case Op_VecS:
2556     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2557   case Op_RegL:
2558   case Op_VecD:
2559   case Op_RegD:
2560     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2561   case Op_VecX:
2562     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2563   case Op_VecY:
2564     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2565   case Op_VecZ:
2566     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2567   }
2568  ShouldNotReachHere();
2569   return NULL;
2570 }
2571 
2572 //------------------------------meet-------------------------------------------
2573 // Compute the MEET of two types.  It returns a new Type object.
2574 const Type *TypeVect::xmeet( const Type *t ) const {
2575   // Perform a fast test for common case; meeting the same types together.
2576   if( this == t ) return this;  // Meeting same type-rep?
2577 
2578   // Current &quot;this-&gt;_base&quot; is Vector
2579   switch (t-&gt;base()) {          // switch on original type
2580 
2581   case Bottom:                  // Ye Olde Default
2582     return t;
2583 
2584   default:                      // All else is a mistake
2585     typerr(t);
2586 
2587   case VectorS:
2588   case VectorD:
2589   case VectorX:
2590   case VectorY:
2591   case VectorZ: {                // Meeting 2 vectors?
2592     const TypeVect* v = t-&gt;is_vect();
2593     assert(  base() == v-&gt;base(), &quot;&quot;);
2594     assert(length() == v-&gt;length(), &quot;&quot;);
2595     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2596     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2597   }
2598   case Top:
2599     break;
2600   }
2601   return this;
2602 }
2603 
2604 //------------------------------xdual------------------------------------------
2605 // Dual: compute field-by-field dual
2606 const Type *TypeVect::xdual() const {
2607   return new TypeVect(base(), _elem-&gt;dual(), _length);
2608 }
2609 
2610 //------------------------------eq---------------------------------------------
2611 // Structural equality check for Type representations
2612 bool TypeVect::eq(const Type *t) const {
2613   const TypeVect *v = t-&gt;is_vect();
2614   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2615 }
2616 
2617 //------------------------------hash-------------------------------------------
2618 // Type-specific hashing function.
2619 int TypeVect::hash(void) const {
2620   return (intptr_t)_elem + (intptr_t)_length;
2621 }
2622 
2623 //------------------------------singleton--------------------------------------
2624 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2625 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2626 // constant value (when vector is created with Replicate code).
2627 bool TypeVect::singleton(void) const {
2628 // There is no Con node for vectors yet.
2629 //  return _elem-&gt;singleton();
2630   return false;
2631 }
2632 
2633 bool TypeVect::empty(void) const {
2634   return _elem-&gt;empty();
2635 }
2636 
2637 //------------------------------dump2------------------------------------------
2638 #ifndef PRODUCT
2639 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2640   switch (base()) {
2641   case VectorS:
2642     st-&gt;print(&quot;vectors[&quot;); break;
2643   case VectorD:
2644     st-&gt;print(&quot;vectord[&quot;); break;
2645   case VectorX:
2646     st-&gt;print(&quot;vectorx[&quot;); break;
2647   case VectorY:
2648     st-&gt;print(&quot;vectory[&quot;); break;
2649   case VectorZ:
2650     st-&gt;print(&quot;vectorz[&quot;); break;
2651   default:
2652     ShouldNotReachHere();
2653   }
2654   st-&gt;print(&quot;%d]:{&quot;, _length);
2655   _elem-&gt;dump2(d, depth, st);
2656   st-&gt;print(&quot;}&quot;);
2657 }
2658 #endif
2659 
2660 
2661 //=============================================================================
2662 // Convenience common pre-built types.
2663 const TypePtr *TypePtr::NULL_PTR;
2664 const TypePtr *TypePtr::NOTNULL;
2665 const TypePtr *TypePtr::BOTTOM;
2666 
2667 //------------------------------meet-------------------------------------------
2668 // Meet over the PTR enum
2669 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2670   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2671   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2672   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2673   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2674   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2675   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2676   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2677 };
2678 
2679 //------------------------------make-------------------------------------------
2680 const TypePtr* TypePtr::make(TYPES t, enum PTR ptr, Offset offset, const TypePtr* speculative, int inline_depth) {
2681   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2682 }
2683 
2684 //------------------------------cast_to_ptr_type-------------------------------
2685 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2686   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2687   if( ptr == _ptr ) return this;
2688   return make(_base, ptr, _offset, _speculative, _inline_depth);
2689 }
2690 
2691 //------------------------------get_con----------------------------------------
2692 intptr_t TypePtr::get_con() const {
2693   assert( _ptr == Null, &quot;&quot; );
2694   return offset();
2695 }
2696 
2697 //------------------------------meet-------------------------------------------
2698 // Compute the MEET of two types.  It returns a new Type object.
2699 const Type *TypePtr::xmeet(const Type *t) const {
2700   const Type* res = xmeet_helper(t);
2701   if (res-&gt;isa_ptr() == NULL) {
2702     return res;
2703   }
2704 
2705   const TypePtr* res_ptr = res-&gt;is_ptr();
2706   if (res_ptr-&gt;speculative() != NULL) {
2707     // type-&gt;speculative() == NULL means that speculation is no better
2708     // than type, i.e. type-&gt;speculative() == type. So there are 2
2709     // ways to represent the fact that we have no useful speculative
2710     // data and we should use a single one to be able to test for
2711     // equality between types. Check whether type-&gt;speculative() ==
2712     // type and set speculative to NULL if it is the case.
2713     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2714       return res_ptr-&gt;remove_speculative();
2715     }
2716   }
2717 
2718   return res;
2719 }
2720 
2721 const Type *TypePtr::xmeet_helper(const Type *t) const {
2722   // Perform a fast test for common case; meeting the same types together.
2723   if( this == t ) return this;  // Meeting same type-rep?
2724 
2725   // Current &quot;this-&gt;_base&quot; is AnyPtr
2726   switch (t-&gt;base()) {          // switch on original type
2727   case Int:                     // Mixing ints &amp; oops happens when javac
2728   case Long:                    // reuses local variables
2729   case FloatTop:
2730   case FloatCon:
2731   case FloatBot:
2732   case DoubleTop:
2733   case DoubleCon:
2734   case DoubleBot:
2735   case NarrowOop:
2736   case NarrowKlass:
2737   case Bottom:                  // Ye Olde Default
2738     return Type::BOTTOM;
2739   case Top:
2740     return this;
2741 
2742   case AnyPtr: {                // Meeting to AnyPtrs
2743     const TypePtr *tp = t-&gt;is_ptr();
2744     const TypePtr* speculative = xmeet_speculative(tp);
2745     int depth = meet_inline_depth(tp-&gt;inline_depth());
2746     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2747   }
2748   case RawPtr:                  // For these, flip the call around to cut down
2749   case OopPtr:
2750   case InstPtr:                 // on the cases I have to handle.
2751   case AryPtr:
2752   case MetadataPtr:
2753   case KlassPtr:
2754     return t-&gt;xmeet(this);      // Call in reverse direction
2755   default:                      // All else is a mistake
2756     typerr(t);
2757 
2758   }
2759   return this;
2760 }
2761 
2762 //------------------------------meet_offset------------------------------------
2763 Type::Offset TypePtr::meet_offset(int offset) const {
2764   return _offset.meet(Offset(offset));
2765 }
2766 
2767 //------------------------------dual_offset------------------------------------
2768 Type::Offset TypePtr::dual_offset() const {
2769   return _offset.dual();
2770 }
2771 
2772 //------------------------------xdual------------------------------------------
2773 // Dual: compute field-by-field dual
2774 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2775   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2776 };
2777 const Type *TypePtr::xdual() const {
2778   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2779 }
2780 
2781 //------------------------------xadd_offset------------------------------------
2782 Type::Offset TypePtr::xadd_offset(intptr_t offset) const {
2783   return _offset.add(offset);
2784 }
2785 
2786 //------------------------------add_offset-------------------------------------
2787 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2788   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2789 }
2790 
2791 //------------------------------eq---------------------------------------------
2792 // Structural equality check for Type representations
2793 bool TypePtr::eq( const Type *t ) const {
2794   const TypePtr *a = (const TypePtr*)t;
2795   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;_offset &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2796 }
2797 
2798 //------------------------------hash-------------------------------------------
2799 // Type-specific hashing function.
2800 int TypePtr::hash(void) const {
2801   return java_add(java_add((jint)_ptr, (jint)offset()), java_add((jint)hash_speculative(), (jint)_inline_depth));
2802 ;
2803 }
2804 
2805 /**
2806  * Return same type without a speculative part
2807  */
2808 const Type* TypePtr::remove_speculative() const {
2809   if (_speculative == NULL) {
2810     return this;
2811   }
2812   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2813   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2814 }
2815 
2816 /**
2817  * Return same type but drop speculative part if we know we won&#39;t use
2818  * it
2819  */
2820 const Type* TypePtr::cleanup_speculative() const {
2821   if (speculative() == NULL) {
2822     return this;
2823   }
2824   const Type* no_spec = remove_speculative();
2825   // If this is NULL_PTR then we don&#39;t need the speculative type
2826   // (with_inline_depth in case the current type inline depth is
2827   // InlineDepthTop)
2828   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2829     return no_spec;
2830   }
2831   if (above_centerline(speculative()-&gt;ptr())) {
2832     return no_spec;
2833   }
2834   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2835   // If the speculative may be null and is an inexact klass then it
2836   // doesn&#39;t help
2837   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2838       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2839     return no_spec;
2840   }
2841   return this;
2842 }
2843 
2844 /**
2845  * dual of the speculative part of the type
2846  */
2847 const TypePtr* TypePtr::dual_speculative() const {
2848   if (_speculative == NULL) {
2849     return NULL;
2850   }
2851   return _speculative-&gt;dual()-&gt;is_ptr();
2852 }
2853 
2854 /**
2855  * meet of the speculative parts of 2 types
2856  *
2857  * @param other  type to meet with
2858  */
2859 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2860   bool this_has_spec = (_speculative != NULL);
2861   bool other_has_spec = (other-&gt;speculative() != NULL);
2862 
2863   if (!this_has_spec &amp;&amp; !other_has_spec) {
2864     return NULL;
2865   }
2866 
2867   // If we are at a point where control flow meets and one branch has
2868   // a speculative type and the other has not, we meet the speculative
2869   // type of one branch with the actual type of the other. If the
2870   // actual type is exact and the speculative is as well, then the
2871   // result is a speculative type which is exact and we can continue
2872   // speculation further.
2873   const TypePtr* this_spec = _speculative;
2874   const TypePtr* other_spec = other-&gt;speculative();
2875 
2876   if (!this_has_spec) {
2877     this_spec = this;
2878   }
2879 
2880   if (!other_has_spec) {
2881     other_spec = other;
2882   }
2883 
2884   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2885 }
2886 
2887 /**
2888  * dual of the inline depth for this type (used for speculation)
2889  */
2890 int TypePtr::dual_inline_depth() const {
2891   return -inline_depth();
2892 }
2893 
2894 /**
2895  * meet of 2 inline depths (used for speculation)
2896  *
2897  * @param depth  depth to meet with
2898  */
2899 int TypePtr::meet_inline_depth(int depth) const {
2900   return MAX2(inline_depth(), depth);
2901 }
2902 
2903 /**
2904  * Are the speculative parts of 2 types equal?
2905  *
2906  * @param other  type to compare this one to
2907  */
2908 bool TypePtr::eq_speculative(const TypePtr* other) const {
2909   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2910     return _speculative == other-&gt;speculative();
2911   }
2912 
2913   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2914     return false;
2915   }
2916 
2917   return _speculative-&gt;eq(other-&gt;speculative());
2918 }
2919 
2920 /**
2921  * Hash of the speculative part of the type
2922  */
2923 int TypePtr::hash_speculative() const {
2924   if (_speculative == NULL) {
2925     return 0;
2926   }
2927 
2928   return _speculative-&gt;hash();
2929 }
2930 
2931 /**
2932  * add offset to the speculative part of the type
2933  *
2934  * @param offset  offset to add
2935  */
2936 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2937   if (_speculative == NULL) {
2938     return NULL;
2939   }
2940   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2941 }
2942 
2943 /**
2944  * return exact klass from the speculative type if there&#39;s one
2945  */
2946 ciKlass* TypePtr::speculative_type() const {
2947   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2948     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2949     if (speculative-&gt;klass_is_exact()) {
2950       return speculative-&gt;klass();
2951     }
2952   }
2953   return NULL;
2954 }
2955 
2956 /**
2957  * return true if speculative type may be null
2958  */
2959 bool TypePtr::speculative_maybe_null() const {
2960   if (_speculative != NULL) {
2961     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2962     return speculative-&gt;maybe_null();
2963   }
2964   return true;
2965 }
2966 
2967 bool TypePtr::speculative_always_null() const {
2968   if (_speculative != NULL) {
2969     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2970     return speculative == TypePtr::NULL_PTR;
2971   }
2972   return false;
2973 }
2974 
2975 /**
2976  * Same as TypePtr::speculative_type() but return the klass only if
2977  * the speculative tells us is not null
2978  */
2979 ciKlass* TypePtr::speculative_type_not_null() const {
2980   if (speculative_maybe_null()) {
2981     return NULL;
2982   }
2983   return speculative_type();
2984 }
2985 
2986 /**
2987  * Check whether new profiling would improve speculative type
2988  *
2989  * @param   exact_kls    class from profiling
2990  * @param   inline_depth inlining depth of profile point
2991  *
2992  * @return  true if type profile is valuable
2993  */
2994 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2995   // no profiling?
2996   if (exact_kls == NULL) {
2997     return false;
2998   }
2999   if (speculative() == TypePtr::NULL_PTR) {
3000     return false;
3001   }
3002   // no speculative type or non exact speculative type?
3003   if (speculative_type() == NULL) {
3004     return true;
3005   }
3006   // If the node already has an exact speculative type keep it,
3007   // unless it was provided by profiling that is at a deeper
3008   // inlining level. Profiling at a higher inlining depth is
3009   // expected to be less accurate.
3010   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
3011     return false;
3012   }
3013   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
3014   return inline_depth &lt; _speculative-&gt;inline_depth();
3015 }
3016 
3017 /**
3018  * Check whether new profiling would improve ptr (= tells us it is non
3019  * null)
3020  *
3021  * @param   ptr_kind always null or not null?
3022  *
3023  * @return  true if ptr profile is valuable
3024  */
3025 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
3026   // profiling doesn&#39;t tell us anything useful
3027   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
3028     return false;
3029   }
3030   // We already know this is not null
3031   if (!this-&gt;maybe_null()) {
3032     return false;
3033   }
3034   // We already know the speculative type cannot be null
3035   if (!speculative_maybe_null()) {
3036     return false;
3037   }
3038   // We already know this is always null
3039   if (this == TypePtr::NULL_PTR) {
3040     return false;
3041   }
3042   // We already know the speculative type is always null
3043   if (speculative_always_null()) {
3044     return false;
3045   }
3046   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
3047     return false;
3048   }
3049   return true;
3050 }
3051 
3052 //------------------------------dump2------------------------------------------
3053 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
3054   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
3055 };
3056 
3057 #ifndef PRODUCT
3058 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3059   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
3060   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
3061   _offset.dump2(st);
3062   dump_inline_depth(st);
3063   dump_speculative(st);
3064 }
3065 
3066 /**
3067  *dump the speculative part of the type
3068  */
3069 void TypePtr::dump_speculative(outputStream *st) const {
3070   if (_speculative != NULL) {
3071     st-&gt;print(&quot; (speculative=&quot;);
3072     _speculative-&gt;dump_on(st);
3073     st-&gt;print(&quot;)&quot;);
3074   }
3075 }
3076 
3077 /**
3078  *dump the inline depth of the type
3079  */
3080 void TypePtr::dump_inline_depth(outputStream *st) const {
3081   if (_inline_depth != InlineDepthBottom) {
3082     if (_inline_depth == InlineDepthTop) {
3083       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
3084     } else {
3085       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
3086     }
3087   }
3088 }
3089 #endif
3090 
3091 //------------------------------singleton--------------------------------------
3092 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3093 // constants
3094 bool TypePtr::singleton(void) const {
3095   // TopPTR, Null, AnyNull, Constant are all singletons
3096   return (_offset != Offset::bottom) &amp;&amp; !below_centerline(_ptr);
3097 }
3098 
3099 bool TypePtr::empty(void) const {
3100   return (_offset == Offset::top) || above_centerline(_ptr);
3101 }
3102 
3103 //=============================================================================
3104 // Convenience common pre-built types.
3105 const TypeRawPtr *TypeRawPtr::BOTTOM;
3106 const TypeRawPtr *TypeRawPtr::NOTNULL;
3107 
3108 //------------------------------make-------------------------------------------
3109 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
3110   assert( ptr != Constant, &quot;what is the constant?&quot; );
3111   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3112   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
3113 }
3114 
3115 const TypeRawPtr *TypeRawPtr::make( address bits ) {
3116   assert( bits, &quot;Use TypePtr for NULL&quot; );
3117   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
3118 }
3119 
3120 //------------------------------cast_to_ptr_type-------------------------------
3121 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
3122   assert( ptr != Constant, &quot;what is the constant?&quot; );
3123   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
3124   assert( _bits==0, &quot;Why cast a constant address?&quot;);
3125   if( ptr == _ptr ) return this;
3126   return make(ptr);
3127 }
3128 
3129 //------------------------------get_con----------------------------------------
3130 intptr_t TypeRawPtr::get_con() const {
3131   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3132   return (intptr_t)_bits;
3133 }
3134 
3135 //------------------------------meet-------------------------------------------
3136 // Compute the MEET of two types.  It returns a new Type object.
3137 const Type *TypeRawPtr::xmeet( const Type *t ) const {
3138   // Perform a fast test for common case; meeting the same types together.
3139   if( this == t ) return this;  // Meeting same type-rep?
3140 
3141   // Current &quot;this-&gt;_base&quot; is RawPtr
3142   switch( t-&gt;base() ) {         // switch on original type
3143   case Bottom:                  // Ye Olde Default
3144     return t;
3145   case Top:
3146     return this;
3147   case AnyPtr:                  // Meeting to AnyPtrs
3148     break;
3149   case RawPtr: {                // might be top, bot, any/not or constant
3150     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
3151     enum PTR ptr = meet_ptr( tptr );
3152     if( ptr == Constant ) {     // Cannot be equal constants, so...
3153       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
3154       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
3155       ptr = NotNull;            // Fall down in lattice
3156     }
3157     return make( ptr );
3158   }
3159 
3160   case OopPtr:
3161   case InstPtr:
3162   case AryPtr:
3163   case MetadataPtr:
3164   case KlassPtr:
3165     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3166   default:                      // All else is a mistake
3167     typerr(t);
3168   }
3169 
3170   // Found an AnyPtr type vs self-RawPtr type
3171   const TypePtr *tp = t-&gt;is_ptr();
3172   switch (tp-&gt;ptr()) {
3173   case TypePtr::TopPTR:  return this;
3174   case TypePtr::BotPTR:  return t;
3175   case TypePtr::Null:
3176     if( _ptr == TypePtr::TopPTR ) return t;
3177     return TypeRawPtr::BOTTOM;
3178   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
3179   case TypePtr::AnyNull:
3180     if( _ptr == TypePtr::Constant) return this;
3181     return make( meet_ptr(TypePtr::AnyNull) );
3182   default: ShouldNotReachHere();
3183   }
3184   return this;
3185 }
3186 
3187 //------------------------------xdual------------------------------------------
3188 // Dual: compute field-by-field dual
3189 const Type *TypeRawPtr::xdual() const {
3190   return new TypeRawPtr( dual_ptr(), _bits );
3191 }
3192 
3193 //------------------------------add_offset-------------------------------------
3194 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
3195   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
3196   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
3197   if( offset == 0 ) return this; // No change
3198   switch (_ptr) {
3199   case TypePtr::TopPTR:
3200   case TypePtr::BotPTR:
3201   case TypePtr::NotNull:
3202     return this;
3203   case TypePtr::Null:
3204   case TypePtr::Constant: {
3205     address bits = _bits+offset;
3206     if ( bits == 0 ) return TypePtr::NULL_PTR;
3207     return make( bits );
3208   }
3209   default:  ShouldNotReachHere();
3210   }
3211   return NULL;                  // Lint noise
3212 }
3213 
3214 //------------------------------eq---------------------------------------------
3215 // Structural equality check for Type representations
3216 bool TypeRawPtr::eq( const Type *t ) const {
3217   const TypeRawPtr *a = (const TypeRawPtr*)t;
3218   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
3219 }
3220 
3221 //------------------------------hash-------------------------------------------
3222 // Type-specific hashing function.
3223 int TypeRawPtr::hash(void) const {
3224   return (intptr_t)_bits + TypePtr::hash();
3225 }
3226 
3227 //------------------------------dump2------------------------------------------
3228 #ifndef PRODUCT
3229 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3230   if( _ptr == Constant )
3231     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
3232   else
3233     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
3234 }
3235 #endif
3236 
3237 //=============================================================================
3238 // Convenience common pre-built type.
3239 const TypeOopPtr *TypeOopPtr::BOTTOM;
3240 
3241 //------------------------------TypeOopPtr-------------------------------------
3242 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
3243                        int instance_id, const TypePtr* speculative, int inline_depth)
3244   : TypePtr(t, ptr, offset, speculative, inline_depth),
3245     _const_oop(o), _klass(k),
3246     _klass_is_exact(xk),
3247     _is_ptr_to_narrowoop(false),
3248     _is_ptr_to_narrowklass(false),
3249     _is_ptr_to_boxed_value(false),
3250     _instance_id(instance_id) {
3251   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
3252       (offset.get() &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
3253     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset.get());
3254   }
3255 #ifdef _LP64
3256   if (this-&gt;offset() &gt; 0 || this-&gt;offset() == Type::OffsetTop || this-&gt;offset() == Type::OffsetBot) {
3257     if (this-&gt;offset() == oopDesc::klass_offset_in_bytes()) {
3258       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3259     } else if (klass() == NULL) {
3260       // Array with unknown body type
3261       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3262       _is_ptr_to_narrowoop = UseCompressedOops;
3263     } else if (UseCompressedOops &amp;&amp; this-&gt;isa_aryptr() &amp;&amp; this-&gt;offset() != arrayOopDesc::length_offset_in_bytes()) {
3264       if (klass()-&gt;is_obj_array_klass()) {
3265         _is_ptr_to_narrowoop = true;
3266       } else if (klass()-&gt;is_value_array_klass() &amp;&amp; field_offset != Offset::top &amp;&amp; field_offset != Offset::bottom) {
3267         // Check if the field of the value type array element contains oops
3268         ciValueKlass* vk = klass()-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3269         int foffset = field_offset.get() + vk-&gt;first_field_offset();
3270         ciField* field = vk-&gt;get_field_by_offset(foffset, false);
3271         assert(field != NULL, &quot;missing field&quot;);
3272         BasicType bt = field-&gt;layout_type();
3273         _is_ptr_to_narrowoop = (bt == T_OBJECT || bt == T_ARRAY || T_VALUETYPE);
3274       }
3275     } else if (klass()-&gt;is_instance_klass()) {
3276       if (this-&gt;isa_klassptr()) {
3277         // Perm objects don&#39;t use compressed references
3278       } else if (_offset == Offset::bottom || _offset == Offset::top) {
3279         // unsafe access
3280         _is_ptr_to_narrowoop = UseCompressedOops;
3281       } else { // exclude unsafe ops
3282         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3283         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3284             (this-&gt;offset() == java_lang_Class::klass_offset_in_bytes() ||
3285              this-&gt;offset() == java_lang_Class::array_klass_offset_in_bytes())) {
3286           // Special hidden fields from the Class.
3287           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3288           _is_ptr_to_narrowoop = false;
3289         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3290                    this-&gt;offset() &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3291           // Static fields
3292           assert(o != NULL, &quot;must be constant&quot;);
3293           ciInstanceKlass* ik = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3294           BasicType basic_elem_type;
3295           if (ik-&gt;is_valuetype() &amp;&amp; this-&gt;offset() == ik-&gt;as_value_klass()-&gt;default_value_offset()) {
3296             // Special hidden field that contains the oop of the default value type
3297             basic_elem_type = T_VALUETYPE;
3298           } else {
3299             ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), true);
3300             assert(field != NULL, &quot;missing field&quot;);
3301             basic_elem_type = field-&gt;layout_type();
3302           }
3303           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3304         } else {
3305           // Instance fields which contains a compressed oop references.
3306           ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3307           ciField* field = ik-&gt;get_field_by_offset(this-&gt;offset(), false);
3308           if (field != NULL) {
3309             BasicType basic_elem_type = field-&gt;layout_type();
3310             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3311           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3312             // Compile::find_alias_type() cast exactness on all types to verify
3313             // that it does not affect alias type.
3314             _is_ptr_to_narrowoop = UseCompressedOops;
3315           } else {
3316             // Type for the copy start in LibraryCallKit::inline_native_clone().
3317             _is_ptr_to_narrowoop = UseCompressedOops;
3318           }
3319         }
3320       }
3321     }
3322   }
3323 #endif
3324 }
3325 
3326 //------------------------------make-------------------------------------------
3327 const TypeOopPtr *TypeOopPtr::make(PTR ptr, Offset offset, int instance_id,
3328                                    const TypePtr* speculative, int inline_depth) {
3329   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3330   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3331   bool      xk = false;
3332   ciObject* o = NULL;
3333   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, Offset::bottom, instance_id, speculative, inline_depth))-&gt;hashcons();
3334 }
3335 
3336 
3337 //------------------------------cast_to_ptr_type-------------------------------
3338 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3339   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3340   if( ptr == _ptr ) return this;
3341   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3342 }
3343 
3344 //-----------------------------cast_to_instance_id----------------------------
3345 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3346   // There are no instances of a general oop.
3347   // Return self unchanged.
3348   return this;
3349 }
3350 
3351 //-----------------------------cast_to_exactness-------------------------------
3352 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3353   // There is no such thing as an exact general oop.
3354   // Return self unchanged.
3355   return this;
3356 }
3357 
3358 
3359 //------------------------------as_klass_type----------------------------------
3360 // Return the klass type corresponding to this instance or array type.
3361 // It is the type that is loaded from an object of this type.
3362 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3363   ciKlass* k = klass();
3364   bool    xk = klass_is_exact();
3365   if (k == NULL)
3366     return TypeKlassPtr::OBJECT;
3367   else
3368     return TypeKlassPtr::make(xk? Constant: NotNull, k, Offset(0), isa_instptr() &amp;&amp; is_instptr()-&gt;flat_array());
3369 }
3370 
3371 //------------------------------meet-------------------------------------------
3372 // Compute the MEET of two types.  It returns a new Type object.
3373 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3374   // Perform a fast test for common case; meeting the same types together.
3375   if( this == t ) return this;  // Meeting same type-rep?
3376 
3377   // Current &quot;this-&gt;_base&quot; is OopPtr
3378   switch (t-&gt;base()) {          // switch on original type
3379 
3380   case Int:                     // Mixing ints &amp; oops happens when javac
3381   case Long:                    // reuses local variables
3382   case FloatTop:
3383   case FloatCon:
3384   case FloatBot:
3385   case DoubleTop:
3386   case DoubleCon:
3387   case DoubleBot:
3388   case NarrowOop:
3389   case NarrowKlass:
3390   case Bottom:                  // Ye Olde Default
3391     return Type::BOTTOM;
3392   case Top:
3393     return this;
3394 
3395   default:                      // All else is a mistake
3396     typerr(t);
3397 
3398   case RawPtr:
3399   case MetadataPtr:
3400   case KlassPtr:
3401     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3402 
3403   case AnyPtr: {
3404     // Found an AnyPtr type vs self-OopPtr type
3405     const TypePtr *tp = t-&gt;is_ptr();
3406     Offset offset = meet_offset(tp-&gt;offset());
3407     PTR ptr = meet_ptr(tp-&gt;ptr());
3408     const TypePtr* speculative = xmeet_speculative(tp);
3409     int depth = meet_inline_depth(tp-&gt;inline_depth());
3410     switch (tp-&gt;ptr()) {
3411     case Null:
3412       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3413       // else fall through:
3414     case TopPTR:
3415     case AnyNull: {
3416       int instance_id = meet_instance_id(InstanceTop);
3417       return make(ptr, offset, instance_id, speculative, depth);
3418     }
3419     case BotPTR:
3420     case NotNull:
3421       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3422     default: typerr(t);
3423     }
3424   }
3425 
3426   case OopPtr: {                 // Meeting to other OopPtrs
3427     const TypeOopPtr *tp = t-&gt;is_oopptr();
3428     int instance_id = meet_instance_id(tp-&gt;instance_id());
3429     const TypePtr* speculative = xmeet_speculative(tp);
3430     int depth = meet_inline_depth(tp-&gt;inline_depth());
3431     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3432   }
3433 
3434   case InstPtr:                  // For these, flip the call around to cut down
3435   case AryPtr:
3436     return t-&gt;xmeet(this);      // Call in reverse direction
3437 
3438   } // End of switch
3439   return this;                  // Return the double constant
3440 }
3441 
3442 
3443 //------------------------------xdual------------------------------------------
3444 // Dual of a pure heap pointer.  No relevant klass or oop information.
3445 const Type *TypeOopPtr::xdual() const {
3446   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3447   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3448   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), Offset::bottom, dual_instance_id(), dual_speculative(), dual_inline_depth());
3449 }
3450 
3451 //--------------------------make_from_klass_common-----------------------------
3452 // Computes the element-type given a klass.
3453 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3454   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3455     Compile* C = Compile::current();
3456     Dependencies* deps = C-&gt;dependencies();
3457     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3458     // Element is an instance
3459     bool klass_is_exact = false;
3460     if (klass-&gt;is_loaded()) {
3461       // Try to set klass_is_exact.
3462       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3463       klass_is_exact = ik-&gt;is_final();
3464       if (!klass_is_exact &amp;&amp; klass_change
3465           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3466         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3467         if (sub != NULL) {
3468           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3469           klass = ik = sub;
3470           klass_is_exact = sub-&gt;is_final();
3471         }
3472       }
3473       if (!klass_is_exact &amp;&amp; try_for_exact
3474           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3475         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3476           // Add a dependence; if concrete subclass added we need to recompile
3477           deps-&gt;assert_leaf_type(ik);
3478           klass_is_exact = true;
3479         }
3480       }
3481     }
3482     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, Offset(0), klass-&gt;flatten_array());
3483   } else if (klass-&gt;is_obj_array_klass()) {
3484     // Element is an object or value array. Recursively call ourself.
<a name="1" id="anc1"></a><span class="line-modified">3485     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_array_klass()-&gt;element_klass(), false, try_for_exact);</span>
3486     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();
3487     if (null_free) {
3488       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);
3489       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3490     }
3491     // [V? has a subtype: [V. So even though V is final, [V? is not exact.
3492     bool xk = etype-&gt;klass_is_exact() &amp;&amp; (!etype-&gt;is_valuetypeptr() || null_free);
<a name="2" id="anc2"></a><span class="line-modified">3493     bool not_null_free = !etype-&gt;can_be_value_type() || xk;</span>
<span class="line-modified">3494     bool not_flat = !ValueArrayFlatten || not_null_free || (etype-&gt;is_valuetypeptr() &amp;&amp; !etype-&gt;value_klass()-&gt;flatten_array());</span>





3495     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);
3496     // We used to pass NotNull in here, asserting that the sub-arrays
3497     // are all not-null.  This is not true in generally, as code can
3498     // slam NULLs down in the subarrays.
3499     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, Offset(0));
3500     return arr;
3501   } else if (klass-&gt;is_type_array_klass()) {
3502     // Element is an typeArray
3503     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3504     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS,
3505                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3506     // We used to pass NotNull in here, asserting that the array pointer
3507     // is not-null. That was not true in general.
3508     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3509     return arr;
3510   } else if (klass-&gt;is_value_array_klass()) {
3511     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3512     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::POS);
3513     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));
3514     return arr;
3515   } else {
3516     ShouldNotReachHere();
3517     return NULL;
3518   }
3519 }
3520 
3521 //------------------------------make_from_constant-----------------------------
3522 // Make a java pointer from an oop constant
3523 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3524   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3525 
3526   const bool make_constant = require_constant || o-&gt;should_be_constant();
3527 
3528   ciKlass* klass = o-&gt;klass();
3529   if (klass-&gt;is_instance_klass() || klass-&gt;is_valuetype()) {
3530     // Element is an instance or value type
3531     if (make_constant) {
3532       return TypeInstPtr::make(o);
3533     } else {
3534       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0), klass-&gt;flatten_array());
3535     }
3536   } else if (klass-&gt;is_obj_array_klass()) {
3537     // Element is an object array. Recursively call ourself.
3538     const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass-&gt;as_array_klass()-&gt;element_klass());
3539     bool null_free = klass-&gt;is_loaded() &amp;&amp; klass-&gt;as_array_klass()-&gt;storage_properties().is_null_free();
3540     if (null_free) {
3541       assert(etype-&gt;is_valuetypeptr(), &quot;must be a valuetypeptr&quot;);
3542       etype = etype-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();
3543     }
3544     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3545                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ !null_free);
3546     // We used to pass NotNull in here, asserting that the sub-arrays
3547     // are all not-null.  This is not true in generally, as code can
3548     // slam NULLs down in the subarrays.
3549     if (make_constant) {
3550       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3551     } else {
3552       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3553     }
3554   } else if (klass-&gt;is_type_array_klass()) {
3555     // Element is an typeArray
3556     const Type* etype = (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3557     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()),
3558                                         /* stable= */ false, /* not_flat= */ true, /* not_null_free= */ true);
3559     // We used to pass NotNull in here, asserting that the array pointer
3560     // is not-null. That was not true in general.
3561     if (make_constant) {
3562       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3563     } else {
3564       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3565     }
3566   } else if (klass-&gt;is_value_array_klass()) {
3567     ciValueKlass* vk = klass-&gt;as_array_klass()-&gt;element_klass()-&gt;as_value_klass();
3568     const TypeAry* arr0 = TypeAry::make(TypeValueType::make(vk), TypeInt::make(o-&gt;as_array()-&gt;length()));
3569     // We used to pass NotNull in here, asserting that the sub-arrays
3570     // are all not-null.  This is not true in generally, as code can
3571     // slam NULLs down in the subarrays.
3572     if (make_constant) {
3573       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));
3574     } else {
3575       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));
3576     }
3577   }
3578 
3579   fatal(&quot;unhandled object type&quot;);
3580   return NULL;
3581 }
3582 
3583 //------------------------------get_con----------------------------------------
3584 intptr_t TypeOopPtr::get_con() const {
3585   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3586   assert(offset() &gt;= 0, &quot;&quot;);
3587 
3588   if (offset() != 0) {
3589     // After being ported to the compiler interface, the compiler no longer
3590     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3591     // to a handle at compile time.  This handle is embedded in the generated
3592     // code and dereferenced at the time the nmethod is made.  Until that time,
3593     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3594     // have access to the addresses!).  This does not seem to currently happen,
3595     // but this assertion here is to help prevent its occurence.
3596     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3597     ShouldNotReachHere();
3598   }
3599 
3600   return (intptr_t)const_oop()-&gt;constant_encoding();
3601 }
3602 
3603 
3604 //-----------------------------filter------------------------------------------
3605 // Do not allow interface-vs.-noninterface joins to collapse to top.
3606 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3607 
3608   const Type* ft = join_helper(kills, include_speculative);
3609   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3610   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3611 
3612   if (ft-&gt;empty()) {
3613     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3614     // interface.  This can happen because the bytecodes do not contain
3615     // enough type info to distinguish a Java-level interface variable
3616     // from a Java-level object variable.  If we meet 2 classes which
3617     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3618     // doesn&#39;t implement I, we have no way to tell if the result should
3619     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3620     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3621     // uplift the type.
3622     if (!empty()) {
3623       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3624         return kills;           // Uplift to interface
3625       }
3626       // Also check for evil cases of &#39;this&#39; being a class array
3627       // and &#39;kills&#39; expecting an array of interfaces.
3628       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3629       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3630         return kills;           // Uplift to array of interface
3631       }
3632     }
3633 
3634     return Type::TOP;           // Canonical empty value
3635   }
3636 
3637   // If we have an interface-typed Phi or cast and we narrow to a class type,
3638   // the join should report back the class.  However, if we have a J/L/Object
3639   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3640   // join report an interface back out.  This isn&#39;t possible but happens
3641   // because the type system doesn&#39;t interact well with interfaces.
3642   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3643       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3644       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3645     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3646     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3647   }
3648 
3649   return ft;
3650 }
3651 
3652 //------------------------------eq---------------------------------------------
3653 // Structural equality check for Type representations
3654 bool TypeOopPtr::eq( const Type *t ) const {
3655   const TypeOopPtr *a = (const TypeOopPtr*)t;
3656   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3657       _instance_id != a-&gt;_instance_id)  return false;
3658   ciObject* one = const_oop();
3659   ciObject* two = a-&gt;const_oop();
3660   if (one == NULL || two == NULL) {
3661     return (one == two) &amp;&amp; TypePtr::eq(t);
3662   } else {
3663     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3664   }
3665 }
3666 
3667 //------------------------------hash-------------------------------------------
3668 // Type-specific hashing function.
3669 int TypeOopPtr::hash(void) const {
3670   return
3671     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3672              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3673 }
3674 
3675 //------------------------------dump2------------------------------------------
3676 #ifndef PRODUCT
3677 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3678   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3679   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3680   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3681   _offset.dump2(st);
3682   if (_instance_id == InstanceTop)
3683     st-&gt;print(&quot;,iid=top&quot;);
3684   else if (_instance_id != InstanceBot)
3685     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3686 
3687   dump_inline_depth(st);
3688   dump_speculative(st);
3689 }
3690 #endif
3691 
3692 //------------------------------singleton--------------------------------------
3693 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3694 // constants
3695 bool TypeOopPtr::singleton(void) const {
3696   // detune optimizer to not generate constant oop + constant offset as a constant!
3697   // TopPTR, Null, AnyNull, Constant are all singletons
3698   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
3699 }
3700 
3701 //------------------------------add_offset-------------------------------------
3702 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3703   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3704 }
3705 
3706 /**
3707  * Return same type without a speculative part
3708  */
3709 const Type* TypeOopPtr::remove_speculative() const {
3710   if (_speculative == NULL) {
3711     return this;
3712   }
3713   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3714   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3715 }
3716 
3717 /**
3718  * Return same type but drop speculative part if we know we won&#39;t use
3719  * it
3720  */
3721 const Type* TypeOopPtr::cleanup_speculative() const {
3722   // If the klass is exact and the ptr is not null then there&#39;s
3723   // nothing that the speculative type can help us with
3724   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3725     return remove_speculative();
3726   }
3727   return TypePtr::cleanup_speculative();
3728 }
3729 
3730 /**
3731  * Return same type but with a different inline depth (used for speculation)
3732  *
3733  * @param depth  depth to meet with
3734  */
3735 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3736   if (!UseInlineDepthForSpeculativeTypes) {
3737     return this;
3738   }
3739   return make(_ptr, _offset, _instance_id, _speculative, depth);
3740 }
3741 
3742 //------------------------------with_instance_id--------------------------------
3743 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3744   assert(_instance_id != -1, &quot;should be known&quot;);
3745   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3746 }
3747 
3748 //------------------------------meet_instance_id--------------------------------
3749 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3750   // Either is &#39;TOP&#39; instance?  Return the other instance!
3751   if( _instance_id == InstanceTop ) return  instance_id;
3752   if(  instance_id == InstanceTop ) return _instance_id;
3753   // If either is different, return &#39;BOTTOM&#39; instance
3754   if( _instance_id != instance_id ) return InstanceBot;
3755   return _instance_id;
3756 }
3757 
3758 //------------------------------dual_instance_id--------------------------------
3759 int TypeOopPtr::dual_instance_id( ) const {
3760   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3761   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3762   return _instance_id;              // Map everything else into self
3763 }
3764 
3765 /**
3766  * Check whether new profiling would improve speculative type
3767  *
3768  * @param   exact_kls    class from profiling
3769  * @param   inline_depth inlining depth of profile point
3770  *
3771  * @return  true if type profile is valuable
3772  */
3773 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3774   // no way to improve an already exact type
3775   if (klass_is_exact()) {
3776     return false;
3777   }
3778   return TypePtr::would_improve_type(exact_kls, inline_depth);
3779 }
3780 
3781 //=============================================================================
3782 // Convenience common pre-built types.
3783 const TypeInstPtr *TypeInstPtr::NOTNULL;
3784 const TypeInstPtr *TypeInstPtr::BOTTOM;
3785 const TypeInstPtr *TypeInstPtr::MIRROR;
3786 const TypeInstPtr *TypeInstPtr::MARK;
3787 const TypeInstPtr *TypeInstPtr::KLASS;
3788 
3789 //------------------------------TypeInstPtr-------------------------------------
3790 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset off,
3791                          bool flat_array, int instance_id, const TypePtr* speculative,
3792                          int inline_depth)
3793   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, Offset::bottom, instance_id, speculative, inline_depth),
3794     _name(k-&gt;name()), _flat_array(flat_array) {
3795    assert(k != NULL &amp;&amp;
3796           (k-&gt;is_loaded() || o == NULL),
3797           &quot;cannot have constants with non-loaded klass&quot;);
3798    assert(!klass()-&gt;is_valuetype() || !klass()-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
3799    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
3800 };
3801 
3802 //------------------------------make-------------------------------------------
3803 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3804                                      ciKlass* k,
3805                                      bool xk,
3806                                      ciObject* o,
3807                                      Offset offset,
3808                                      bool flat_array,
3809                                      int instance_id,
3810                                      const TypePtr* speculative,
3811                                      int inline_depth) {
3812   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3813   // Either const_oop() is NULL or else ptr is Constant
3814   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3815           &quot;constant pointers must have a value supplied&quot; );
3816   // Ptr is never Null
3817   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3818 
3819   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3820   if (!UseExactTypes)  xk = false;
3821   if (ptr == Constant) {
3822     // Note:  This case includes meta-object constants, such as methods.
3823     xk = true;
3824   } else if (k-&gt;is_loaded()) {
3825     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3826     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3827     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3828   }
3829 
3830   // Now hash this baby
3831   TypeInstPtr *result =
3832     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, flat_array, instance_id, speculative, inline_depth))-&gt;hashcons();
3833 
3834   return result;
3835 }
3836 
3837 /**
3838  *  Create constant type for a constant boxed value
3839  */
3840 const Type* TypeInstPtr::get_const_boxed_value() const {
3841   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3842   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3843   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3844   BasicType bt = constant.basic_type();
3845   switch (bt) {
3846     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3847     case T_INT:      return TypeInt::make(constant.as_int());
3848     case T_CHAR:     return TypeInt::make(constant.as_char());
3849     case T_BYTE:     return TypeInt::make(constant.as_byte());
3850     case T_SHORT:    return TypeInt::make(constant.as_short());
3851     case T_FLOAT:    return TypeF::make(constant.as_float());
3852     case T_DOUBLE:   return TypeD::make(constant.as_double());
3853     case T_LONG:     return TypeLong::make(constant.as_long());
3854     default:         break;
3855   }
3856   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3857   return NULL;
3858 }
3859 
3860 //------------------------------cast_to_ptr_type-------------------------------
3861 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3862   if( ptr == _ptr ) return this;
3863   // Reconstruct _sig info here since not a problem with later lazy
3864   // construction, _sig will show up on demand.
3865   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3866 }
3867 
3868 
3869 //-----------------------------cast_to_exactness-------------------------------
3870 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3871   if( klass_is_exact == _klass_is_exact ) return this;
3872   if (!UseExactTypes)  return this;
3873   if (!_klass-&gt;is_loaded())  return this;
3874   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3875   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3876   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3877   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _flat_array, _instance_id, _speculative, _inline_depth);
3878 }
3879 
3880 //-----------------------------cast_to_instance_id----------------------------
3881 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3882   if( instance_id == _instance_id ) return this;
3883   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, _flat_array, instance_id, _speculative, _inline_depth);
3884 }
3885 
3886 //------------------------------xmeet_unloaded---------------------------------
3887 // Compute the MEET of two InstPtrs when at least one is unloaded.
3888 // Assume classes are different since called after check for same name/class-loader
3889 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3890     Offset off = meet_offset(tinst-&gt;offset());
3891     PTR ptr = meet_ptr(tinst-&gt;ptr());
3892     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3893     const TypePtr* speculative = xmeet_speculative(tinst);
3894     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3895 
3896     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3897     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3898     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3899       //
3900       // Meet unloaded class with java/lang/Object
3901       //
3902       // Meet
3903       //          |                     Unloaded Class
3904       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3905       //  ===================================================================
3906       //   TOP    | ..........................Unloaded......................|
3907       //  AnyNull |  U-AN    |................Unloaded......................|
3908       // Constant | ... O-NN .................................. |   O-BOT   |
3909       //  NotNull | ... O-NN .................................. |   O-BOT   |
3910       //  BOTTOM  | ........................Object-BOTTOM ..................|
3911       //
3912       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3913       //
3914       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3915       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, false, instance_id, speculative, depth); }
3916       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3917       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3918         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3919         else                                      { return TypeInstPtr::NOTNULL; }
3920       }
3921       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3922 
3923       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3924     }
3925 
3926     // Both are unloaded, not the same class, not Object
3927     // Or meet unloaded with a different loaded class, not java/lang/Object
3928     if( ptr != TypePtr::BotPTR ) {
3929       return TypeInstPtr::NOTNULL;
3930     }
3931     return TypeInstPtr::BOTTOM;
3932 }
3933 
3934 
3935 //------------------------------meet-------------------------------------------
3936 // Compute the MEET of two types.  It returns a new Type object.
3937 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3938   // Perform a fast test for common case; meeting the same types together.
3939   if( this == t ) return this;  // Meeting same type-rep?
3940 
3941   // Current &quot;this-&gt;_base&quot; is Pointer
3942   switch (t-&gt;base()) {          // switch on original type
3943 
3944   case Int:                     // Mixing ints &amp; oops happens when javac
3945   case Long:                    // reuses local variables
3946   case FloatTop:
3947   case FloatCon:
3948   case FloatBot:
3949   case DoubleTop:
3950   case DoubleCon:
3951   case DoubleBot:
3952   case NarrowOop:
3953   case NarrowKlass:
3954   case Bottom:                  // Ye Olde Default
3955     return Type::BOTTOM;
3956   case Top:
3957     return this;
3958 
3959   default:                      // All else is a mistake
3960     typerr(t);
3961 
3962   case MetadataPtr:
3963   case KlassPtr:
3964   case RawPtr: return TypePtr::BOTTOM;
3965 
3966   case AryPtr: {                // All arrays inherit from Object class
3967     const TypeAryPtr *tp = t-&gt;is_aryptr();
3968     Offset offset = meet_offset(tp-&gt;offset());
3969     PTR ptr = meet_ptr(tp-&gt;ptr());
3970     int instance_id = meet_instance_id(tp-&gt;instance_id());
3971     const TypePtr* speculative = xmeet_speculative(tp);
3972     int depth = meet_inline_depth(tp-&gt;inline_depth());
3973     switch (ptr) {
3974     case TopPTR:
3975     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3976       // For instances when a subclass meets a superclass we fall
3977       // below the centerline when the superclass is exact. We need to
3978       // do the same here.
3979       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3980         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
3981       } else {
3982         // cannot subclass, so the meet has to fall badly below the centerline
3983         ptr = NotNull;
3984         instance_id = InstanceBot;
3985         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
3986       }
3987     case Constant:
3988     case NotNull:
3989     case BotPTR:                // Fall down to object klass
3990       // LCA is object_klass, but if we subclass from the top we can do better
3991       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3992         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3993         // then we can subclass in the Java class hierarchy.
3994         // For instances when a subclass meets a superclass we fall
3995         // below the centerline when the superclass is exact. We need
3996         // to do the same here.
3997         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3998           // that is, tp&#39;s array type is a subtype of my klass
3999           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
4000                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, tp-&gt;field_offset(), instance_id, speculative, depth);
4001         }
4002       }
4003       // The other case cannot happen, since I cannot be a subtype of an array.
4004       // The meet falls down to Object class below centerline.
4005       if( ptr == Constant )
4006          ptr = NotNull;
4007       instance_id = InstanceBot;
4008       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4009     default: typerr(t);
4010     }
4011   }
4012 
4013   case OopPtr: {                // Meeting to OopPtrs
4014     // Found a OopPtr type vs self-InstPtr type
4015     const TypeOopPtr *tp = t-&gt;is_oopptr();
4016     Offset offset = meet_offset(tp-&gt;offset());
4017     PTR ptr = meet_ptr(tp-&gt;ptr());
4018     switch (tp-&gt;ptr()) {
4019     case TopPTR:
4020     case AnyNull: {
4021       int instance_id = meet_instance_id(InstanceTop);
4022       const TypePtr* speculative = xmeet_speculative(tp);
4023       int depth = meet_inline_depth(tp-&gt;inline_depth());
4024       return make(ptr, klass(), klass_is_exact(),
4025                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4026     }
4027     case NotNull:
4028     case BotPTR: {
4029       int instance_id = meet_instance_id(tp-&gt;instance_id());
4030       const TypePtr* speculative = xmeet_speculative(tp);
4031       int depth = meet_inline_depth(tp-&gt;inline_depth());
4032       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4033     }
4034     default: typerr(t);
4035     }
4036   }
4037 
4038   case AnyPtr: {                // Meeting to AnyPtrs
4039     // Found an AnyPtr type vs self-InstPtr type
4040     const TypePtr *tp = t-&gt;is_ptr();
4041     Offset offset = meet_offset(tp-&gt;offset());
4042     PTR ptr = meet_ptr(tp-&gt;ptr());
4043     int instance_id = meet_instance_id(InstanceTop);
4044     const TypePtr* speculative = xmeet_speculative(tp);
4045     int depth = meet_inline_depth(tp-&gt;inline_depth());
4046     switch (tp-&gt;ptr()) {
4047     case Null:
4048       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4049       // else fall through to AnyNull
4050     case TopPTR:
4051     case AnyNull: {
4052       return make(ptr, klass(), klass_is_exact(),
4053                   (ptr == Constant ? const_oop() : NULL), offset, flat_array(), instance_id, speculative, depth);
4054     }
4055     case NotNull:
4056     case BotPTR:
4057       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
4058     default: typerr(t);
4059     }
4060   }
4061 
4062   /*
4063                  A-top         }
4064                /   |   \       }  Tops
4065            B-top A-any C-top   }
4066               | /  |  \ |      }  Any-nulls
4067            B-any   |   C-any   }
4068               |    |    |
4069            B-con A-con C-con   } constants; not comparable across classes
4070               |    |    |
4071            B-not   |   C-not   }
4072               | \  |  / |      }  not-nulls
4073            B-bot A-not C-bot   }
4074                \   |   /       }  Bottoms
4075                  A-bot         }
4076   */
4077 
4078   case InstPtr: {                // Meeting 2 Oops?
4079     // Found an InstPtr sub-type vs self-InstPtr type
4080     const TypeInstPtr *tinst = t-&gt;is_instptr();
4081     Offset off = meet_offset( tinst-&gt;offset() );
4082     PTR ptr = meet_ptr( tinst-&gt;ptr() );
4083     int instance_id = meet_instance_id(tinst-&gt;instance_id());
4084     const TypePtr* speculative = xmeet_speculative(tinst);
4085     int depth = meet_inline_depth(tinst-&gt;inline_depth());
4086 
4087     // Check for easy case; klasses are equal (and perhaps not loaded!)
4088     // If we have constants, then we created oops so classes are loaded
4089     // and we can handle the constants further down.  This case handles
4090     // both-not-loaded or both-loaded classes
4091     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact() &amp;&amp;
4092         flat_array() == tinst-&gt;flat_array()) {
4093       return make(ptr, klass(), klass_is_exact(), NULL, off, flat_array(), instance_id, speculative, depth);
4094     }
4095 
4096     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
4097     ciKlass* tinst_klass = tinst-&gt;klass();
4098     ciKlass* this_klass  = this-&gt;klass();
4099     bool tinst_xk = tinst-&gt;klass_is_exact();
4100     bool this_xk  = this-&gt;klass_is_exact();
4101     bool tinst_flat_array = tinst-&gt;flat_array();
4102     bool this_flat_array  = this-&gt;flat_array();
4103     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
4104       // One of these classes has not been loaded
4105       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
4106 #ifndef PRODUCT
4107       if( PrintOpto &amp;&amp; Verbose ) {
4108         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
4109         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
4110         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
4111       }
4112 #endif
4113       return unloaded_meet;
4114     }
4115 
4116     // Handle mixing oops and interfaces first.
4117     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
4118                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
4119       ciKlass *tmp = tinst_klass; // Swap interface around
4120       tinst_klass = this_klass;
4121       this_klass = tmp;
4122       bool tmp2 = tinst_xk;
4123       tinst_xk = this_xk;
4124       this_xk = tmp2;
4125       tmp2 = tinst_flat_array;
4126       tinst_flat_array = this_flat_array;
4127       this_flat_array = tmp2;
4128     }
4129     if (tinst_klass-&gt;is_interface() &amp;&amp;
4130         !(this_klass-&gt;is_interface() ||
4131           // Treat java/lang/Object as an honorary interface,
4132           // because we need a bottom for the interface hierarchy.
4133           this_klass == ciEnv::current()-&gt;Object_klass())) {
4134       // Oop meets interface!
4135 
4136       // See if the oop subtypes (implements) interface.
4137       ciKlass *k;
4138       bool xk;
4139       bool flat_array;
4140       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
4141         // Oop indeed subtypes.  Now keep oop or interface depending
4142         // on whether we are both above the centerline or either is
4143         // below the centerline.  If we are on the centerline
4144         // (e.g., Constant vs. AnyNull interface), use the constant.
4145         k  = below_centerline(ptr) ? tinst_klass : this_klass;
4146         // If we are keeping this_klass, keep its exactness too.
4147         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
4148         flat_array = below_centerline(ptr) ? tinst_flat_array    : this_flat_array;
4149       } else {                  // Does not implement, fall to Object
4150         // Oop does not implement interface, so mixing falls to Object
4151         // just like the verifier does (if both are above the
4152         // centerline fall to interface)
4153         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
4154         xk = above_centerline(ptr) ? tinst_xk : false;
4155         flat_array = above_centerline(ptr) ? tinst_flat_array : false;
4156         // Watch out for Constant vs. AnyNull interface.
4157         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
4158         instance_id = InstanceBot;
4159       }
4160       ciObject* o = NULL;  // the Constant value, if any
4161       if (ptr == Constant) {
4162         // Find out which constant.
4163         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
4164       }
4165       return make(ptr, k, xk, o, off, flat_array, instance_id, speculative, depth);
4166     }
4167 
4168     // Either oop vs oop or interface vs interface or interface vs Object
4169 
4170     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
4171     // If we split one up &amp; one down AND they subtype, take the down man.
4172     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4173     // If both are up and they subtype, take the subtype class.
4174     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4175     // If both are down and they subtype, take the supertype class.
4176     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4177     // Constants treated as down.
4178 
4179     // Now, reorder the above list; observe that both-down+subtype is also
4180     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
4181     // If we split one up &amp; one down AND they subtype, take the down man.
4182     // If both are up and they subtype, take the subtype class.
4183 
4184     // If both are down and they subtype, &quot;fall hard&quot;.
4185     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
4186     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
4187     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
4188 
4189     // If a proper subtype is exact, and we return it, we return it exactly.
4190     // If a proper supertype is exact, there can be no subtyping relationship!
4191     // If both types are equal to the subtype, exactness is and-ed below the
4192     // centerline and or-ed above it.  (N.B. Constants are always exact.)
4193 
4194     // Check for subtyping:
4195     ciKlass *subtype = NULL;
4196     bool subtype_exact = false;
4197     bool flat_array = false;
4198     if (tinst_klass-&gt;equals(this_klass)) {
4199       subtype = this_klass;
4200       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
4201       flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tinst_flat_array) : (this_flat_array || tinst_flat_array);
4202     } else if(!tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of(tinst_klass) &amp;&amp; (!tinst_flat_array || this_flat_array)) {
4203       subtype = this_klass;     // Pick subtyping class
4204       subtype_exact = this_xk;
4205       flat_array = this_flat_array;
4206     } else if(!this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of(this_klass) &amp;&amp; (!this_flat_array || tinst_flat_array)) {
4207       subtype = tinst_klass;    // Pick subtyping class
4208       subtype_exact = tinst_xk;
4209       flat_array = tinst_flat_array;
4210     }
4211 
4212     if (subtype) {
4213       if (above_centerline(ptr)) { // both are up?
4214         this_klass = tinst_klass = subtype;
4215         this_xk = tinst_xk = subtype_exact;
4216         this_flat_array = tinst_flat_array = flat_array;
4217       } else if (above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr)) {
4218         this_klass = tinst_klass; // tinst is down; keep down man
4219         this_xk = tinst_xk;
4220         this_flat_array = tinst_flat_array;
4221       } else if (above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr)) {
4222         tinst_klass = this_klass; // this is down; keep down man
4223         tinst_xk = this_xk;
4224         tinst_flat_array = this_flat_array;
4225       } else {
4226         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
4227         this_flat_array = flat_array;
4228       }
4229     }
4230 
4231     // Check for classes now being equal
4232     if (tinst_klass-&gt;equals(this_klass)) {
4233       // If the klasses are equal, the constants may still differ.  Fall to
4234       // NotNull if they do (neither constant is NULL; that is a special case
4235       // handled elsewhere).
4236       ciObject* o = NULL;             // Assume not constant when done
4237       ciObject* this_oop  = const_oop();
4238       ciObject* tinst_oop = tinst-&gt;const_oop();
4239       if( ptr == Constant ) {
4240         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
4241             this_oop-&gt;equals(tinst_oop) )
4242           o = this_oop;
4243         else if (above_centerline(this -&gt;_ptr))
4244           o = tinst_oop;
4245         else if (above_centerline(tinst -&gt;_ptr))
4246           o = this_oop;
4247         else
4248           ptr = NotNull;
4249       }
4250       return make(ptr, this_klass, this_xk, o, off, this_flat_array, instance_id, speculative, depth);
4251     } // Else classes are not equal
4252 
4253     // Since klasses are different, we require a LCA in the Java
4254     // class hierarchy - which means we have to fall to at least NotNull.
4255     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
4256       ptr = NotNull;
4257 
4258     instance_id = InstanceBot;
4259 
4260     // Now we find the LCA of Java classes
4261     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
4262     return make(ptr, k, false, NULL, off, false, instance_id, speculative, depth);
4263   } // End of case InstPtr
4264 
4265   case ValueType: {
4266     const TypeValueType* tv = t-&gt;is_valuetype();
4267     if (above_centerline(ptr())) {
4268       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4269         return t;
4270       } else {
4271         return TypeInstPtr::NOTNULL;
4272       }
4273     } else {
4274       PTR ptr = this-&gt;_ptr;
4275       if (ptr == Constant) {
4276         ptr = NotNull;
4277       }
4278       if (tv-&gt;value_klass()-&gt;is_subtype_of(_klass)) {
4279         return TypeInstPtr::make(ptr, _klass);
4280       } else {
4281         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4282       }
4283     }
4284   }
4285 
4286   } // End of switch
4287   return this;                  // Return the double constant
4288 }
4289 
4290 
4291 //------------------------java_mirror_type--------------------------------------
4292 ciType* TypeInstPtr::java_mirror_type(bool* is_indirect_type) const {
4293   // must be a singleton type
4294   if( const_oop() == NULL )  return NULL;
4295 
4296   // must be of type java.lang.Class
4297   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
4298 
4299   return const_oop()-&gt;as_instance()-&gt;java_mirror_type(is_indirect_type);
4300 }
4301 
4302 
4303 //------------------------------xdual------------------------------------------
4304 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
4305 // inheritance mechanism.
4306 const Type *TypeInstPtr::xdual() const {
4307   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), flat_array(), dual_instance_id(), dual_speculative(), dual_inline_depth());
4308 }
4309 
4310 //------------------------------eq---------------------------------------------
4311 // Structural equality check for Type representations
4312 bool TypeInstPtr::eq( const Type *t ) const {
4313   const TypeInstPtr *p = t-&gt;is_instptr();
4314   return
4315     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4316     flat_array() == p-&gt;flat_array() &amp;&amp;
4317     TypeOopPtr::eq(p);          // Check sub-type stuff
4318 }
4319 
4320 //------------------------------hash-------------------------------------------
4321 // Type-specific hashing function.
4322 int TypeInstPtr::hash(void) const {
4323   int hash = java_add(java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash()), (jint)flat_array());
4324   return hash;
4325 }
4326 
4327 //------------------------------dump2------------------------------------------
4328 // Dump oop Type
4329 #ifndef PRODUCT
4330 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4331   // Print the name of the klass.
4332   klass()-&gt;print_name_on(st);
4333 
4334   switch( _ptr ) {
4335   case Constant:
4336     // TO DO: Make CI print the hex address of the underlying oop.
4337     if (WizardMode || Verbose) {
4338       const_oop()-&gt;print_oop(st);
4339     }
4340   case BotPTR:
4341     if (!WizardMode &amp;&amp; !Verbose) {
4342       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4343       break;
4344     }
4345   case TopPTR:
4346   case AnyNull:
4347   case NotNull:
4348     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4349     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4350     break;
4351   default:
4352     break;
4353   }
4354 
4355   _offset.dump2(st);
4356 
4357   st-&gt;print(&quot; *&quot;);
4358 
4359   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
4360     st-&gt;print(&quot; (flatten array)&quot;);
4361   }
4362 
4363   if (_instance_id == InstanceTop)
4364     st-&gt;print(&quot;,iid=top&quot;);
4365   else if (_instance_id != InstanceBot)
4366     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4367 
4368   dump_inline_depth(st);
4369   dump_speculative(st);
4370 }
4371 #endif
4372 
4373 //------------------------------add_offset-------------------------------------
4374 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4375   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset), flat_array(),
4376               _instance_id, add_offset_speculative(offset), _inline_depth);
4377 }
4378 
4379 const Type *TypeInstPtr::remove_speculative() const {
4380   if (_speculative == NULL) {
4381     return this;
4382   }
4383   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4384   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(),
4385               _instance_id, NULL, _inline_depth);
4386 }
4387 
4388 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4389   if (!UseInlineDepthForSpeculativeTypes) {
4390     return this;
4391   }
4392   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), _instance_id, _speculative, depth);
4393 }
4394 
4395 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4396   assert(is_known_instance(), &quot;should be known&quot;);
4397   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, flat_array(), instance_id, _speculative, _inline_depth);
4398 }
4399 
4400 const TypeInstPtr *TypeInstPtr::cast_to_flat_array() const {
4401   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, true, _instance_id, _speculative, _inline_depth);
4402 }
4403 
4404 
4405 //=============================================================================
4406 // Convenience common pre-built types.
4407 const TypeAryPtr *TypeAryPtr::RANGE;
4408 const TypeAryPtr *TypeAryPtr::OOPS;
4409 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4410 const TypeAryPtr *TypeAryPtr::BYTES;
4411 const TypeAryPtr *TypeAryPtr::SHORTS;
4412 const TypeAryPtr *TypeAryPtr::CHARS;
4413 const TypeAryPtr *TypeAryPtr::INTS;
4414 const TypeAryPtr *TypeAryPtr::LONGS;
4415 const TypeAryPtr *TypeAryPtr::FLOATS;
4416 const TypeAryPtr *TypeAryPtr::DOUBLES;
4417 const TypeAryPtr *TypeAryPtr::VALUES;
4418 
4419 //------------------------------make-------------------------------------------
4420 const TypeAryPtr* TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4421                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4422   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4423          &quot;integral arrays must be pre-equipped with a class&quot;);
4424   if (!xk) xk = ary-&gt;ary_must_be_exact();
4425   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4426   if (!UseExactTypes)  xk = (ptr == Constant);
4427   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4428 }
4429 
4430 //------------------------------make-------------------------------------------
4431 const TypeAryPtr* TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset, Offset field_offset,
4432                                    int instance_id, const TypePtr* speculative, int inline_depth,
4433                                    bool is_autobox_cache) {
4434   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4435          &quot;integral arrays must be pre-equipped with a class&quot;);
4436   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4437   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4438   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4439   if (!UseExactTypes)  xk = (ptr == Constant);
4440   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, field_offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4441 }
4442 
4443 //------------------------------cast_to_ptr_type-------------------------------
4444 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4445   if( ptr == _ptr ) return this;
4446   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4447 }
4448 
4449 
4450 //-----------------------------cast_to_exactness-------------------------------
4451 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4452   if( klass_is_exact == _klass_is_exact ) return this;
4453   if (!UseExactTypes)  return this;
4454   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4455 
4456   const TypeAry* new_ary = _ary;
4457   if (klass() != NULL &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp; klass_is_exact) {
4458     // An object array can&#39;t be flat or null-free if the klass is exact
4459     new_ary = TypeAry::make(elem(), size(), is_stable(), /* not_flat= */ true, /* not_null_free= */ true);
4460   }
4461   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4462 }
4463 
4464 //-----------------------------cast_to_instance_id----------------------------
4465 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4466   if( instance_id == _instance_id ) return this;
4467   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth, _is_autobox_cache);
4468 }
4469 
4470 
4471 //-----------------------------max_array_length-------------------------------
4472 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4473 jint TypeAryPtr::max_array_length(BasicType etype) {
4474   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4475     if (etype == T_NARROWOOP) {
4476       etype = T_OBJECT;
4477     } else if (etype == T_ILLEGAL) { // bottom[]
4478       etype = T_BYTE; // will produce conservatively high value
4479     } else {
4480       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4481     }
4482   }
4483   return arrayOopDesc::max_array_length(etype);
4484 }
4485 
4486 //-----------------------------narrow_size_type-------------------------------
4487 // Narrow the given size type to the index range for the given array base type.
4488 // Return NULL if the resulting int type becomes empty.
4489 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4490   jint hi = size-&gt;_hi;
4491   jint lo = size-&gt;_lo;
4492   jint min_lo = 0;
4493   jint max_hi = max_array_length(elem()-&gt;basic_type());
4494   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4495   bool chg = false;
4496   if (lo &lt; min_lo) {
4497     lo = min_lo;
4498     if (size-&gt;is_con()) {
4499       hi = lo;
4500     }
4501     chg = true;
4502   }
4503   if (hi &gt; max_hi) {
4504     hi = max_hi;
4505     if (size-&gt;is_con()) {
4506       lo = hi;
4507     }
4508     chg = true;
4509   }
4510   // Negative length arrays will produce weird intermediate dead fast-path code
4511   if (lo &gt; hi)
4512     return TypeInt::ZERO;
4513   if (!chg)
4514     return size;
4515   return TypeInt::make(lo, hi, Type::WidenMin);
4516 }
4517 
4518 //-------------------------------cast_to_size----------------------------------
4519 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4520   assert(new_size != NULL, &quot;&quot;);
4521   new_size = narrow_size_type(new_size);
4522   if (new_size == size())  return this;
4523   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());
4524   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4525 }
4526 
4527 //-------------------------------cast_to_not_flat------------------------------
4528 const TypeAryPtr* TypeAryPtr::cast_to_not_flat(bool not_flat) const {
4529   if (not_flat == is_not_flat()) {
4530     return this;
4531   }
4532   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());
4533   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4534 }
4535 
4536 //-------------------------------cast_to_not_null_free-------------------------
4537 const TypeAryPtr* TypeAryPtr::cast_to_not_null_free(bool not_null_free) const {
4538   if (not_null_free == is_not_null_free()) {
4539     return this;
4540   }
4541   // Not null free implies not flat
4542   const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);
4543   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4544 }
4545 
4546 //------------------------------cast_to_stable---------------------------------
4547 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4548   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4549     return this;
4550 
4551   const Type* elem = this-&gt;elem();
4552   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4553 
4554   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4555     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4556     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4557   }
4558 
4559   const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());
4560 
4561   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4562 }
4563 
4564 //-----------------------------stable_dimension--------------------------------
4565 int TypeAryPtr::stable_dimension() const {
4566   if (!is_stable())  return 0;
4567   int dim = 1;
4568   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4569   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4570     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4571   return dim;
4572 }
4573 
4574 //----------------------cast_to_autobox_cache-----------------------------------
4575 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4576   if (is_autobox_cache() == cache)  return this;
4577   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4578   if (etype == NULL)  return this;
4579   // The pointers in the autobox arrays are always non-null.
4580   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4581   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4582   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());
4583   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);
4584 }
4585 
4586 //------------------------------eq---------------------------------------------
4587 // Structural equality check for Type representations
4588 bool TypeAryPtr::eq( const Type *t ) const {
4589   const TypeAryPtr *p = t-&gt;is_aryptr();
4590   return
4591     _ary == p-&gt;_ary &amp;&amp;  // Check array
4592     TypeOopPtr::eq(p) &amp;&amp;// Check sub-parts
4593     _field_offset == p-&gt;_field_offset;
4594 }
4595 
4596 //------------------------------hash-------------------------------------------
4597 // Type-specific hashing function.
4598 int TypeAryPtr::hash(void) const {
4599   return (intptr_t)_ary + TypeOopPtr::hash() + _field_offset.get();
4600 }
4601 
4602 //------------------------------meet-------------------------------------------
4603 // Compute the MEET of two types.  It returns a new Type object.
4604 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4605   // Perform a fast test for common case; meeting the same types together.
4606   if( this == t ) return this;  // Meeting same type-rep?
4607   // Current &quot;this-&gt;_base&quot; is Pointer
4608   switch (t-&gt;base()) {          // switch on original type
4609 
4610   // Mixing ints &amp; oops happens when javac reuses local variables
4611   case Int:
4612   case Long:
4613   case FloatTop:
4614   case FloatCon:
4615   case FloatBot:
4616   case DoubleTop:
4617   case DoubleCon:
4618   case DoubleBot:
4619   case NarrowOop:
4620   case NarrowKlass:
4621   case Bottom:                  // Ye Olde Default
4622     return Type::BOTTOM;
4623   case Top:
4624     return this;
4625 
4626   default:                      // All else is a mistake
4627     typerr(t);
4628 
4629   case OopPtr: {                // Meeting to OopPtrs
4630     // Found a OopPtr type vs self-AryPtr type
4631     const TypeOopPtr *tp = t-&gt;is_oopptr();
4632     Offset offset = meet_offset(tp-&gt;offset());
4633     PTR ptr = meet_ptr(tp-&gt;ptr());
4634     int depth = meet_inline_depth(tp-&gt;inline_depth());
4635     const TypePtr* speculative = xmeet_speculative(tp);
4636     switch (tp-&gt;ptr()) {
4637     case TopPTR:
4638     case AnyNull: {
4639       int instance_id = meet_instance_id(InstanceTop);
4640       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4641                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4642     }
4643     case BotPTR:
4644     case NotNull: {
4645       int instance_id = meet_instance_id(tp-&gt;instance_id());
4646       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4647     }
4648     default: ShouldNotReachHere();
4649     }
4650   }
4651 
4652   case AnyPtr: {                // Meeting two AnyPtrs
4653     // Found an AnyPtr type vs self-AryPtr type
4654     const TypePtr *tp = t-&gt;is_ptr();
4655     Offset offset = meet_offset(tp-&gt;offset());
4656     PTR ptr = meet_ptr(tp-&gt;ptr());
4657     const TypePtr* speculative = xmeet_speculative(tp);
4658     int depth = meet_inline_depth(tp-&gt;inline_depth());
4659     switch (tp-&gt;ptr()) {
4660     case TopPTR:
4661       return this;
4662     case BotPTR:
4663     case NotNull:
4664       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4665     case Null:
4666       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4667       // else fall through to AnyNull
4668     case AnyNull: {
4669       int instance_id = meet_instance_id(InstanceTop);
4670       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4671                   _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4672     }
4673     default: ShouldNotReachHere();
4674     }
4675   }
4676 
4677   case MetadataPtr:
4678   case KlassPtr:
4679   case RawPtr: return TypePtr::BOTTOM;
4680 
4681   case AryPtr: {                // Meeting 2 references?
4682     const TypeAryPtr *tap = t-&gt;is_aryptr();
4683     Offset off = meet_offset(tap-&gt;offset());
4684     Offset field_off = meet_field_offset(tap-&gt;field_offset());
4685     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4686     PTR ptr = meet_ptr(tap-&gt;ptr());
4687     int instance_id = meet_instance_id(tap-&gt;instance_id());
4688     const TypePtr* speculative = xmeet_speculative(tap);
4689     int depth = meet_inline_depth(tap-&gt;inline_depth());
4690     ciKlass* lazy_klass = NULL;
4691     if (tary-&gt;_elem-&gt;isa_int()) {
4692       // Integral array element types have irrelevant lattice relations.
4693       // It is the klass that determines array layout, not the element type.
4694       if (_klass == NULL)
4695         lazy_klass = tap-&gt;_klass;
4696       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4697         lazy_klass = _klass;
4698       } else {
4699         // Something like byte[int+] meets char[int+].
4700         // This must fall to bottom, not (int[-128..65535])[int+].
4701         instance_id = InstanceBot;
4702         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4703       }
4704     } else // Non integral arrays.
4705       // Must fall to bottom if exact klasses in upper lattice
4706       // are not equal or super klass is exact.
4707       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4708           // meet with top[] and bottom[] are processed further down:
4709           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4710           // both are exact and not equal:
4711           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4712            // &#39;tap&#39; is exact and super or unrelated:
4713            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4714            // &#39;this&#39; is exact and super or unrelated:
4715            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4716       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4717         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4718       }
4719       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4720     } else if (klass() != NULL &amp;&amp; tap-&gt;klass() != NULL &amp;&amp;
4721                klass()-&gt;as_array_klass()-&gt;storage_properties().value() != tap-&gt;klass()-&gt;as_array_klass()-&gt;storage_properties().value()) {
4722       // Meeting value type arrays with conflicting storage properties
4723       if (tary-&gt;_elem-&gt;isa_valuetype()) {
4724         // Result is flattened
4725         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4726         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4727       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4728         // Result is non-flattened
4729         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4730         field_off = Offset::bottom;
4731       }
4732     }
4733 
4734     bool xk = false;
4735     switch (tap-&gt;ptr()) {
4736     case AnyNull:
4737     case TopPTR:
4738       // Compute new klass on demand, do not use tap-&gt;_klass
4739       if (below_centerline(this-&gt;_ptr)) {
4740         xk = this-&gt;_klass_is_exact;
4741       } else {
4742         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4743       }
4744       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4745     case Constant: {
4746       ciObject* o = const_oop();
4747       if( _ptr == Constant ) {
4748         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4749           xk = (klass() == tap-&gt;klass());
4750           ptr = NotNull;
4751           o = NULL;
4752           instance_id = InstanceBot;
4753         } else {
4754           xk = true;
4755         }
4756       } else if(above_centerline(_ptr)) {
4757         o = tap-&gt;const_oop();
4758         xk = true;
4759       } else {
4760         // Only precise for identical arrays
4761         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4762       }
4763       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4764     }
4765     case NotNull:
4766     case BotPTR:
4767       // Compute new klass on demand, do not use tap-&gt;_klass
4768       if (above_centerline(this-&gt;_ptr))
4769             xk = tap-&gt;_klass_is_exact;
4770       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4771               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4772       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4773     default: ShouldNotReachHere();
4774     }
4775   }
4776 
4777   // All arrays inherit from Object class
4778   case InstPtr: {
4779     const TypeInstPtr *tp = t-&gt;is_instptr();
4780     Offset offset = meet_offset(tp-&gt;offset());
4781     PTR ptr = meet_ptr(tp-&gt;ptr());
4782     int instance_id = meet_instance_id(tp-&gt;instance_id());
4783     const TypePtr* speculative = xmeet_speculative(tp);
4784     int depth = meet_inline_depth(tp-&gt;inline_depth());
4785     switch (ptr) {
4786     case TopPTR:
4787     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4788       // For instances when a subclass meets a superclass we fall
4789       // below the centerline when the superclass is exact. We need to
4790       // do the same here.
4791       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4792         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4793       } else {
4794         // cannot subclass, so the meet has to fall badly below the centerline
4795         ptr = NotNull;
4796         instance_id = InstanceBot;
4797         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4798       }
4799     case Constant:
4800     case NotNull:
4801     case BotPTR:                // Fall down to object klass
4802       // LCA is object_klass, but if we subclass from the top we can do better
4803       if (above_centerline(tp-&gt;ptr())) {
4804         // If &#39;tp&#39;  is above the centerline and it is Object class
4805         // then we can subclass in the Java class hierarchy.
4806         // For instances when a subclass meets a superclass we fall
4807         // below the centerline when the superclass is exact. We need
4808         // to do the same here.
4809         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4810           // that is, my array type is a subtype of &#39;tp&#39; klass
4811           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4812                       _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);
4813         }
4814       }
4815       // The other case cannot happen, since t cannot be a subtype of an array.
4816       // The meet falls down to Object class below centerline.
4817       if( ptr == Constant )
4818          ptr = NotNull;
4819       instance_id = InstanceBot;
4820       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);
4821     default: typerr(t);
4822     }
4823   }
4824 
4825   case ValueType: {
4826     const TypeValueType* tv = t-&gt;is_valuetype();
4827     if (above_centerline(ptr())) {
4828       return TypeInstPtr::NOTNULL;
4829     } else {
4830       PTR ptr = this-&gt;_ptr;
4831       if (ptr == Constant) {
4832         ptr = NotNull;
4833       }
4834       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass());
4835     }
4836   }
4837   }
4838   return this;                  // Lint noise
4839 }
4840 
4841 //------------------------------xdual------------------------------------------
4842 // Dual: compute field-by-field dual
4843 const Type *TypeAryPtr::xdual() const {
4844   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4845 }
4846 
4847 Type::Offset TypeAryPtr::meet_field_offset(const Type::Offset offset) const {
4848   return _field_offset.meet(offset);
4849 }
4850 
4851 //------------------------------dual_offset------------------------------------
4852 Type::Offset TypeAryPtr::dual_field_offset() const {
4853   return _field_offset.dual();
4854 }
4855 
4856 //----------------------interface_vs_oop---------------------------------------
4857 #ifdef ASSERT
4858 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4859   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4860   if (t_aryptr) {
4861     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4862   }
4863   return false;
4864 }
4865 #endif
4866 
4867 //------------------------------dump2------------------------------------------
4868 #ifndef PRODUCT
4869 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4870   _ary-&gt;dump2(d,depth,st);
4871   switch( _ptr ) {
4872   case Constant:
4873     const_oop()-&gt;print(st);
4874     break;
4875   case BotPTR:
4876     if (!WizardMode &amp;&amp; !Verbose) {
4877       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4878       break;
4879     }
4880   case TopPTR:
4881   case AnyNull:
4882   case NotNull:
4883     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4884     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4885     break;
4886   default:
4887     break;
4888   }
4889 
4890   if (elem()-&gt;isa_valuetype()) {
4891     st-&gt;print(&quot;(&quot;);
4892     _field_offset.dump2(st);
4893     st-&gt;print(&quot;)&quot;);
4894   }
4895   if (offset() != 0) {
4896     int header_size = objArrayOopDesc::header_size() * wordSize;
4897     if( _offset == Offset::top )       st-&gt;print(&quot;+undefined&quot;);
4898     else if( _offset == Offset::bottom )  st-&gt;print(&quot;+any&quot;);
4899     else if( offset() &lt; header_size ) st-&gt;print(&quot;+%d&quot;, offset());
4900     else {
4901       BasicType basic_elem_type = elem()-&gt;basic_type();
4902       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4903       int elem_size = type2aelembytes(basic_elem_type);
4904       st-&gt;print(&quot;[%d]&quot;, (offset() - array_base)/elem_size);
4905     }
4906   }
4907   st-&gt;print(&quot; *&quot;);
4908   if (_instance_id == InstanceTop)
4909     st-&gt;print(&quot;,iid=top&quot;);
4910   else if (_instance_id != InstanceBot)
4911     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4912 
4913   dump_inline_depth(st);
4914   dump_speculative(st);
4915 }
4916 #endif
4917 
4918 bool TypeAryPtr::empty(void) const {
4919   if (_ary-&gt;empty())       return true;
4920   return TypeOopPtr::empty();
4921 }
4922 
4923 //------------------------------add_offset-------------------------------------
4924 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4925   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _field_offset, _instance_id, add_offset_speculative(offset), _inline_depth, _is_autobox_cache);
4926 }
4927 
4928 const Type *TypeAryPtr::remove_speculative() const {
4929   if (_speculative == NULL) {
4930     return this;
4931   }
4932   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4933   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);
4934 }
4935 
4936 const Type* TypeAryPtr::cleanup_speculative() const {
4937   if (speculative() == NULL) {
4938     return this;
4939   }
4940   // Keep speculative part if it contains information about flat-/nullability
4941   const TypeAryPtr* spec_aryptr = speculative()-&gt;isa_aryptr();
4942   if (spec_aryptr != NULL &amp;&amp; (spec_aryptr-&gt;is_not_flat() || spec_aryptr-&gt;is_not_null_free())) {
4943     return this;
4944   }
4945   return TypeOopPtr::cleanup_speculative();
4946 }
4947 
4948 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4949   if (!UseInlineDepthForSpeculativeTypes) {
4950     return this;
4951   }
4952   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, _speculative, depth, _is_autobox_cache);
4953 }
4954 
4955 const TypeAryPtr* TypeAryPtr::with_field_offset(int offset) const {
4956   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, Offset(offset), _instance_id, _speculative, _inline_depth, _is_autobox_cache);
4957 }
4958 
4959 const TypePtr* TypeAryPtr::add_field_offset_and_offset(intptr_t offset) const {
4960   int adj = 0;
4961   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop) {
4962     const Type* elemtype = elem();
4963     if (elemtype-&gt;isa_valuetype()) {
4964       if (_offset.get() != OffsetBot &amp;&amp; _offset.get() != OffsetTop) {
4965         adj = _offset.get();
4966         offset += _offset.get();
4967       }
4968       uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
4969       if (_field_offset.get() != OffsetBot &amp;&amp; _field_offset.get() != OffsetTop) {
4970         offset += _field_offset.get();
4971         if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {
4972           offset += header;
4973         }
4974       }
4975       if (offset &gt;= (intptr_t)header || offset &lt; 0) {
4976         // Try to get the field of the value type array element we are pointing to
4977         ciKlass* arytype_klass = klass();
4978         ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();
4979         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
4980         int shift = vak-&gt;log2_element_size();
4981         int mask = (1 &lt;&lt; shift) - 1;
4982         intptr_t field_offset = ((offset - header) &amp; mask);
4983         ciField* field = vk-&gt;get_field_by_offset(field_offset + vk-&gt;first_field_offset(), false);
4984         if (field == NULL) {
4985           // This may happen with nested AddP(base, AddP(base, base, offset), longcon(16))
4986           return add_offset(offset);
4987         } else {
4988           return with_field_offset(field_offset)-&gt;add_offset(offset - field_offset - adj);
4989         }
4990       }
4991     }
4992   }
4993   return add_offset(offset - adj);
4994 }
4995 
4996 // Return offset incremented by field_offset for flattened value type arrays
4997 const int TypeAryPtr::flattened_offset() const {
4998   int offset = _offset.get();
4999   if (offset != Type::OffsetBot &amp;&amp; offset != Type::OffsetTop &amp;&amp;
5000       _field_offset != Offset::bottom &amp;&amp; _field_offset != Offset::top) {
5001     offset += _field_offset.get();
5002   }
5003   return offset;
5004 }
5005 
5006 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
5007   assert(is_known_instance(), &quot;should be known&quot;);
5008   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _field_offset, instance_id, _speculative, _inline_depth);
5009 }
5010 
5011 //=============================================================================
5012 
5013 
5014 //------------------------------hash-------------------------------------------
5015 // Type-specific hashing function.
5016 int TypeNarrowPtr::hash(void) const {
5017   return _ptrtype-&gt;hash() + 7;
5018 }
5019 
5020 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
5021   return _ptrtype-&gt;singleton();
5022 }
5023 
5024 bool TypeNarrowPtr::empty(void) const {
5025   return _ptrtype-&gt;empty();
5026 }
5027 
5028 intptr_t TypeNarrowPtr::get_con() const {
5029   return _ptrtype-&gt;get_con();
5030 }
5031 
5032 bool TypeNarrowPtr::eq( const Type *t ) const {
5033   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
5034   if (tc != NULL) {
5035     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
5036       return false;
5037     }
5038     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
5039   }
5040   return false;
5041 }
5042 
5043 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
5044   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
5045   return make_same_narrowptr(odual);
5046 }
5047 
5048 
5049 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
5050   if (isa_same_narrowptr(kills)) {
5051     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
5052     if (ft-&gt;empty())
5053       return Type::TOP;           // Canonical empty value
5054     if (ft-&gt;isa_ptr()) {
5055       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
5056     }
5057     return ft;
5058   } else if (kills-&gt;isa_ptr()) {
5059     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
5060     if (ft-&gt;empty())
5061       return Type::TOP;           // Canonical empty value
5062     return ft;
5063   } else {
5064     return Type::TOP;
5065   }
5066 }
5067 
5068 //------------------------------xmeet------------------------------------------
5069 // Compute the MEET of two types.  It returns a new Type object.
5070 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
5071   // Perform a fast test for common case; meeting the same types together.
5072   if( this == t ) return this;  // Meeting same type-rep?
5073 
5074   if (t-&gt;base() == base()) {
5075     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
5076     if (result-&gt;isa_ptr()) {
5077       return make_hash_same_narrowptr(result-&gt;is_ptr());
5078     }
5079     return result;
5080   }
5081 
5082   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
5083   switch (t-&gt;base()) {          // switch on original type
5084 
5085   case Int:                     // Mixing ints &amp; oops happens when javac
5086   case Long:                    // reuses local variables
5087   case FloatTop:
5088   case FloatCon:
5089   case FloatBot:
5090   case DoubleTop:
5091   case DoubleCon:
5092   case DoubleBot:
5093   case AnyPtr:
5094   case RawPtr:
5095   case OopPtr:
5096   case InstPtr:
5097   case AryPtr:
5098   case MetadataPtr:
5099   case KlassPtr:
5100   case NarrowOop:
5101   case NarrowKlass:
5102   case Bottom:                  // Ye Olde Default
5103     return Type::BOTTOM;
5104   case Top:
5105     return this;
5106 
5107   case ValueType:
5108     return t-&gt;xmeet(this);
5109 
5110   default:                      // All else is a mistake
5111     typerr(t);
5112 
5113   } // End of switch
5114 
5115   return this;
5116 }
5117 
5118 #ifndef PRODUCT
5119 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5120   _ptrtype-&gt;dump2(d, depth, st);
5121 }
5122 #endif
5123 
5124 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
5125 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
5126 
5127 
5128 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
5129   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
5130 }
5131 
5132 const Type* TypeNarrowOop::remove_speculative() const {
5133   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
5134 }
5135 
5136 const Type* TypeNarrowOop::cleanup_speculative() const {
5137   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
5138 }
5139 
5140 #ifndef PRODUCT
5141 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5142   st-&gt;print(&quot;narrowoop: &quot;);
5143   TypeNarrowPtr::dump2(d, depth, st);
5144 }
5145 #endif
5146 
5147 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
5148 
5149 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
5150   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
5151 }
5152 
5153 #ifndef PRODUCT
5154 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5155   st-&gt;print(&quot;narrowklass: &quot;);
5156   TypeNarrowPtr::dump2(d, depth, st);
5157 }
5158 #endif
5159 
5160 
5161 //------------------------------eq---------------------------------------------
5162 // Structural equality check for Type representations
5163 bool TypeMetadataPtr::eq( const Type *t ) const {
5164   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
5165   ciMetadata* one = metadata();
5166   ciMetadata* two = a-&gt;metadata();
5167   if (one == NULL || two == NULL) {
5168     return (one == two) &amp;&amp; TypePtr::eq(t);
5169   } else {
5170     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
5171   }
5172 }
5173 
5174 //------------------------------hash-------------------------------------------
5175 // Type-specific hashing function.
5176 int TypeMetadataPtr::hash(void) const {
5177   return
5178     (metadata() ? metadata()-&gt;hash() : 0) +
5179     TypePtr::hash();
5180 }
5181 
5182 //------------------------------singleton--------------------------------------
5183 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5184 // constants
5185 bool TypeMetadataPtr::singleton(void) const {
5186   // detune optimizer to not generate constant metadata + constant offset as a constant!
5187   // TopPTR, Null, AnyNull, Constant are all singletons
5188   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5189 }
5190 
5191 //------------------------------add_offset-------------------------------------
5192 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
5193   return make( _ptr, _metadata, xadd_offset(offset));
5194 }
5195 
5196 //-----------------------------filter------------------------------------------
5197 // Do not allow interface-vs.-noninterface joins to collapse to top.
5198 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
5199   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
5200   if (ft == NULL || ft-&gt;empty())
5201     return Type::TOP;           // Canonical empty value
5202   return ft;
5203 }
5204 
5205  //------------------------------get_con----------------------------------------
5206 intptr_t TypeMetadataPtr::get_con() const {
5207   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5208   assert(offset() &gt;= 0, &quot;&quot;);
5209 
5210   if (offset() != 0) {
5211     // After being ported to the compiler interface, the compiler no longer
5212     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5213     // to a handle at compile time.  This handle is embedded in the generated
5214     // code and dereferenced at the time the nmethod is made.  Until that time,
5215     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5216     // have access to the addresses!).  This does not seem to currently happen,
5217     // but this assertion here is to help prevent its occurence.
5218     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5219     ShouldNotReachHere();
5220   }
5221 
5222   return (intptr_t)metadata()-&gt;constant_encoding();
5223 }
5224 
5225 //------------------------------cast_to_ptr_type-------------------------------
5226 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
5227   if( ptr == _ptr ) return this;
5228   return make(ptr, metadata(), _offset);
5229 }
5230 
5231 //------------------------------meet-------------------------------------------
5232 // Compute the MEET of two types.  It returns a new Type object.
5233 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
5234   // Perform a fast test for common case; meeting the same types together.
5235   if( this == t ) return this;  // Meeting same type-rep?
5236 
5237   // Current &quot;this-&gt;_base&quot; is OopPtr
5238   switch (t-&gt;base()) {          // switch on original type
5239 
5240   case Int:                     // Mixing ints &amp; oops happens when javac
5241   case Long:                    // reuses local variables
5242   case FloatTop:
5243   case FloatCon:
5244   case FloatBot:
5245   case DoubleTop:
5246   case DoubleCon:
5247   case DoubleBot:
5248   case NarrowOop:
5249   case NarrowKlass:
5250   case Bottom:                  // Ye Olde Default
5251     return Type::BOTTOM;
5252   case Top:
5253     return this;
5254 
5255   default:                      // All else is a mistake
5256     typerr(t);
5257 
5258   case AnyPtr: {
5259     // Found an AnyPtr type vs self-OopPtr type
5260     const TypePtr *tp = t-&gt;is_ptr();
5261     Offset offset = meet_offset(tp-&gt;offset());
5262     PTR ptr = meet_ptr(tp-&gt;ptr());
5263     switch (tp-&gt;ptr()) {
5264     case Null:
5265       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5266       // else fall through:
5267     case TopPTR:
5268     case AnyNull: {
5269       return make(ptr, _metadata, offset);
5270     }
5271     case BotPTR:
5272     case NotNull:
5273       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5274     default: typerr(t);
5275     }
5276   }
5277 
5278   case RawPtr:
5279   case KlassPtr:
5280   case OopPtr:
5281   case InstPtr:
5282   case AryPtr:
5283     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
5284 
5285   case MetadataPtr: {
5286     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
5287     Offset offset = meet_offset(tp-&gt;offset());
5288     PTR tptr = tp-&gt;ptr();
5289     PTR ptr = meet_ptr(tptr);
5290     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
5291     if (tptr == TopPTR || _ptr == TopPTR ||
5292         metadata()-&gt;equals(tp-&gt;metadata())) {
5293       return make(ptr, md, offset);
5294     }
5295     // metadata is different
5296     if( ptr == Constant ) {  // Cannot be equal constants, so...
5297       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
5298       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
5299       ptr = NotNull;            // Fall down in lattice
5300     }
5301     return make(ptr, NULL, offset);
5302     break;
5303   }
5304   } // End of switch
5305   return this;                  // Return the double constant
5306 }
5307 
5308 
5309 //------------------------------xdual------------------------------------------
5310 // Dual of a pure metadata pointer.
5311 const Type *TypeMetadataPtr::xdual() const {
5312   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
5313 }
5314 
5315 //------------------------------dump2------------------------------------------
5316 #ifndef PRODUCT
5317 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5318   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
5319   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
5320   switch (offset()) {
5321   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
5322   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
5323   case         0: break;
5324   default:        st-&gt;print(&quot;+%d&quot;,offset()); break;
5325   }
5326 }
5327 #endif
5328 
5329 
5330 //=============================================================================
5331 // Convenience common pre-built type.
5332 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
5333 
5334 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset):
5335   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
5336 }
5337 
5338 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
5339   return make(Constant, m, Offset(0));
5340 }
5341 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
5342   return make(Constant, m, Offset(0));
5343 }
5344 
5345 //------------------------------make-------------------------------------------
5346 // Create a meta data constant
5347 const TypeMetadataPtr* TypeMetadataPtr::make(PTR ptr, ciMetadata* m, Offset offset) {
5348   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
5349   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
5350 }
5351 
5352 
5353 //=============================================================================
5354 // Convenience common pre-built types.
5355 
5356 // Not-null object klass or below
5357 const TypeKlassPtr *TypeKlassPtr::OBJECT;
5358 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
5359 
5360 //------------------------------TypeKlassPtr-----------------------------------
5361 TypeKlassPtr::TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array)
5362   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant), _flat_array(flat_array) {
5363    assert(!klass-&gt;is_valuetype() || !klass-&gt;flatten_array() || flat_array, &quot;incorrect flatten array bit&quot;);
5364    assert(!flat_array || can_be_value_type(), &quot;incorrect flatten array bit&quot;);
5365 }
5366 
5367 //------------------------------make-------------------------------------------
5368 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
5369 const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, bool flat_array) {
5370   assert(k == NULL || k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
5371   return (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset, flat_array))-&gt;hashcons();
5372 }
5373 
5374 //------------------------------eq---------------------------------------------
5375 // Structural equality check for Type representations
5376 bool TypeKlassPtr::eq( const Type *t ) const {
5377   const TypeKlassPtr *p = t-&gt;is_klassptr();
5378   return klass() == p-&gt;klass() &amp;&amp; TypePtr::eq(p) &amp;&amp; flat_array() == p-&gt;flat_array();
5379 }
5380 
5381 //------------------------------hash-------------------------------------------
5382 // Type-specific hashing function.
5383 int TypeKlassPtr::hash(void) const {
5384   return java_add(java_add(klass() != NULL ? klass()-&gt;hash() : (jint)0, (jint)TypePtr::hash()), (jint)flat_array());
5385 }
5386 
5387 //------------------------------singleton--------------------------------------
5388 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5389 // constants
5390 bool TypeKlassPtr::singleton(void) const {
5391   // detune optimizer to not generate constant klass + constant offset as a constant!
5392   // TopPTR, Null, AnyNull, Constant are all singletons
5393   return (offset() == 0) &amp;&amp; !below_centerline(_ptr);
5394 }
5395 
5396 // Do not allow interface-vs.-noninterface joins to collapse to top.
5397 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
5398   // logic here mirrors the one from TypeOopPtr::filter. See comments
5399   // there.
5400   const Type* ft = join_helper(kills, include_speculative);
5401   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
5402   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
5403 
5404   if (ft-&gt;empty()) {
5405     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
5406       return kills;             // Uplift to interface
5407 
5408     return Type::TOP;           // Canonical empty value
5409   }
5410 
5411   // Interface klass type could be exact in opposite to interface type,
5412   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
5413   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
5414       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
5415       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
5416       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
5417     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
5418   }
5419 
5420   return ft;
5421 }
5422 
5423 //----------------------compute_klass------------------------------------------
5424 // Compute the defining klass for this class
5425 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
5426   // Compute _klass based on element type.
5427   ciKlass* k_ary = NULL;
5428   const TypeAryPtr *tary;
5429   const Type* el = elem();
5430   if (el-&gt;isa_narrowoop()) {
5431     el = el-&gt;make_ptr();
5432   }
5433 
5434   // Get element klass
5435   if (el-&gt;isa_instptr()) {
5436     // Compute object array klass from element klass
5437     bool null_free = el-&gt;is_valuetypeptr() &amp;&amp; el-&gt;isa_instptr()-&gt;ptr() != TypePtr::TopPTR &amp;&amp; !el-&gt;isa_instptr()-&gt;maybe_null();
5438     k_ary = ciArrayKlass::make(el-&gt;is_oopptr()-&gt;klass(), null_free);
5439   } else if (el-&gt;isa_valuetype()) {
5440     if (el-&gt;value_klass() != NULL) {
5441       k_ary = ciArrayKlass::make(el-&gt;value_klass(), /* null_free */ true);
5442     }
5443   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
5444     // Compute array klass from element klass
5445     ciKlass* k_elem = tary-&gt;klass();
5446     // If element type is something like bottom[], k_elem will be null.
5447     if (k_elem != NULL)
5448       k_ary = ciObjArrayKlass::make(k_elem);
5449   } else if ((el-&gt;base() == Type::Top) ||
5450              (el-&gt;base() == Type::Bottom)) {
5451     // element type of Bottom occurs from meet of basic type
5452     // and object; Top occurs when doing join on Bottom.
5453     // Leave k_ary at NULL.
5454   } else {
5455     // Cannot compute array klass directly from basic type,
5456     // since subtypes of TypeInt all have basic type T_INT.
5457 #ifdef ASSERT
5458     if (verify &amp;&amp; el-&gt;isa_int()) {
5459       // Check simple cases when verifying klass.
5460       BasicType bt = T_ILLEGAL;
5461       if (el == TypeInt::BYTE) {
5462         bt = T_BYTE;
5463       } else if (el == TypeInt::SHORT) {
5464         bt = T_SHORT;
5465       } else if (el == TypeInt::CHAR) {
5466         bt = T_CHAR;
5467       } else if (el == TypeInt::INT) {
5468         bt = T_INT;
5469       } else {
5470         return _klass; // just return specified klass
5471       }
5472       return ciTypeArrayKlass::make(bt);
5473     }
5474 #endif
5475     assert(!el-&gt;isa_int(),
5476            &quot;integral arrays must be pre-equipped with a class&quot;);
5477     // Compute array klass directly from basic type
5478     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5479   }
5480   return k_ary;
5481 }
5482 
5483 //------------------------------klass------------------------------------------
5484 // Return the defining klass for this class
5485 ciKlass* TypeAryPtr::klass() const {
5486   if( _klass ) return _klass;   // Return cached value, if possible
5487 
5488   // Oops, need to compute _klass and cache it
5489   ciKlass* k_ary = compute_klass();
5490 
5491   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5492     // The _klass field acts as a cache of the underlying
5493     // ciKlass for this array type.  In order to set the field,
5494     // we need to cast away const-ness.
5495     //
5496     // IMPORTANT NOTE: we *never* set the _klass field for the
5497     // type TypeAryPtr::OOPS.  This Type is shared between all
5498     // active compilations.  However, the ciKlass which represents
5499     // this Type is *not* shared between compilations, so caching
5500     // this value would result in fetching a dangling pointer.
5501     //
5502     // Recomputing the underlying ciKlass for each request is
5503     // a bit less efficient than caching, but calls to
5504     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5505     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5506     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5507         offset() != 0 &amp;&amp; offset() != arrayOopDesc::length_offset_in_bytes()) {
5508       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5509     }
5510   }
5511   return k_ary;
5512 }
5513 
5514 
5515 //------------------------------add_offset-------------------------------------
5516 // Access internals of klass object
5517 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5518   return make(_ptr, klass(), xadd_offset(offset), flat_array());
5519 }
5520 
5521 //------------------------------cast_to_ptr_type-------------------------------
5522 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5523   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5524   if( ptr == _ptr ) return this;
5525   return make(ptr, _klass, _offset, _flat_array);
5526 }
5527 
5528 
5529 //-----------------------------cast_to_exactness-------------------------------
5530 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5531   if( klass_is_exact == _klass_is_exact ) return this;
5532   if (!UseExactTypes)  return this;
5533   return make(klass_is_exact ? Constant : NotNull, _klass, _offset, _flat_array);
5534 }
5535 
5536 
5537 //-----------------------------as_instance_type--------------------------------
5538 // Corresponding type for an instance of the given class.
5539 // It will be NotNull, and exact if and only if the klass type is exact.
5540 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5541   ciKlass* k = klass();
5542   assert(k != NULL, &quot;klass should not be NULL&quot;);
5543   bool    xk = klass_is_exact();
5544   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5545   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5546   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5547   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5548   if (flat_array() &amp;&amp; !klass()-&gt;is_valuetype()) {
5549     toop = toop-&gt;is_instptr()-&gt;cast_to_flat_array();
5550   }
5551   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5552 }
5553 
5554 
5555 //------------------------------xmeet------------------------------------------
5556 // Compute the MEET of two types, return a new Type object.
5557 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5558   // Perform a fast test for common case; meeting the same types together.
5559   if( this == t ) return this;  // Meeting same type-rep?
5560 
5561   // Current &quot;this-&gt;_base&quot; is Pointer
5562   switch (t-&gt;base()) {          // switch on original type
5563 
5564   case Int:                     // Mixing ints &amp; oops happens when javac
5565   case Long:                    // reuses local variables
5566   case FloatTop:
5567   case FloatCon:
5568   case FloatBot:
5569   case DoubleTop:
5570   case DoubleCon:
5571   case DoubleBot:
5572   case NarrowOop:
5573   case NarrowKlass:
5574   case Bottom:                  // Ye Olde Default
5575     return Type::BOTTOM;
5576   case Top:
5577     return this;
5578 
5579   default:                      // All else is a mistake
5580     typerr(t);
5581 
5582   case AnyPtr: {                // Meeting to AnyPtrs
5583     // Found an AnyPtr type vs self-KlassPtr type
5584     const TypePtr *tp = t-&gt;is_ptr();
5585     Offset offset = meet_offset(tp-&gt;offset());
5586     PTR ptr = meet_ptr(tp-&gt;ptr());
5587     switch (tp-&gt;ptr()) {
5588     case TopPTR:
5589       return this;
5590     case Null:
5591       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5592     case AnyNull:
5593       return make(ptr, klass(), offset, flat_array());
5594     case BotPTR:
5595     case NotNull:
5596       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5597     default: typerr(t);
5598     }
5599   }
5600 
5601   case RawPtr:
5602   case MetadataPtr:
5603   case OopPtr:
5604   case AryPtr:                  // Meet with AryPtr
5605   case InstPtr:                 // Meet with InstPtr
5606     return TypePtr::BOTTOM;
5607 
5608   //
5609   //             A-top         }
5610   //           /   |   \       }  Tops
5611   //       B-top A-any C-top   }
5612   //          | /  |  \ |      }  Any-nulls
5613   //       B-any   |   C-any   }
5614   //          |    |    |
5615   //       B-con A-con C-con   } constants; not comparable across classes
5616   //          |    |    |
5617   //       B-not   |   C-not   }
5618   //          | \  |  / |      }  not-nulls
5619   //       B-bot A-not C-bot   }
5620   //           \   |   /       }  Bottoms
5621   //             A-bot         }
5622   //
5623 
5624   case KlassPtr: {  // Meet two KlassPtr types
5625     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5626     Offset  off  = meet_offset(tkls-&gt;offset());
5627     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5628 
5629     if (klass() == NULL || tkls-&gt;klass() == NULL) {
5630       ciKlass* k = NULL;
5631       if (ptr == Constant) {
5632         k = (klass() == NULL) ? tkls-&gt;klass() : klass();
5633       }
5634       return make(ptr, k, off, false);
5635     }
5636 
5637     // Check for easy case; klasses are equal (and perhaps not loaded!)
5638     // If we have constants, then we created oops so classes are loaded
5639     // and we can handle the constants further down.  This case handles
5640     // not-loaded classes
5641     if (ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) &amp;&amp; flat_array() == tkls-&gt;flat_array()) {
5642       return make(ptr, klass(), off, flat_array());
5643     }
5644 
5645     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5646     ciKlass* tkls_klass = tkls-&gt;klass();
5647     ciKlass* this_klass = this-&gt;klass();
5648     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5649     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5650     bool tkls_flat_array = tkls-&gt;flat_array();
5651     bool this_flat_array  = this-&gt;flat_array();
5652     bool flat_array = below_centerline(ptr) ? (this_flat_array &amp;&amp; tkls_flat_array) : (this_flat_array || tkls_flat_array);
5653 
5654     // If &#39;this&#39; type is above the centerline and is a superclass of the
5655     // other, we can treat &#39;this&#39; as having the same type as the other.
5656     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5657         tkls_klass-&gt;is_subtype_of(this_klass)) {
5658       this_klass = tkls_klass;
5659     }
5660     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5661     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5662     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5663         this_klass-&gt;is_subtype_of(tkls_klass)) {
5664       tkls_klass = this_klass;
5665     }
5666 
5667     // Check for classes now being equal
5668     if (tkls_klass-&gt;equals(this_klass)) {
5669       // If the klasses are equal, the constants may still differ.  Fall to
5670       // NotNull if they do (neither constant is NULL; that is a special case
5671       // handled elsewhere).
5672       if( ptr == Constant ) {
5673         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5674             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5675         else if (above_centerline(this-&gt;ptr()));
5676         else if (above_centerline(tkls-&gt;ptr()));
5677         else
5678           ptr = NotNull;
5679       }
5680       return make(ptr, this_klass, off, flat_array);
5681     } // Else classes are not equal
5682 
5683     // Since klasses are different, we require the LCA in the Java
5684     // class hierarchy - which means we have to fall to at least NotNull.
5685     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5686       ptr = NotNull;
5687     // Now we find the LCA of Java classes
5688     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5689     return   make(ptr, k, off, k-&gt;is_valuetype() &amp;&amp; k-&gt;flatten_array());
5690   } // End of case KlassPtr
5691 
5692   } // End of switch
5693   return this;                  // Return the double constant
5694 }
5695 
5696 //------------------------------xdual------------------------------------------
5697 // Dual: compute field-by-field dual
5698 const Type    *TypeKlassPtr::xdual() const {
5699   return new TypeKlassPtr(dual_ptr(), klass(), dual_offset(), flat_array());
5700 }
5701 
5702 //------------------------------get_con----------------------------------------
5703 intptr_t TypeKlassPtr::get_con() const {
5704   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5705   assert(offset() &gt;= 0, &quot;&quot;);
5706 
5707   if (offset() != 0) {
5708     // After being ported to the compiler interface, the compiler no longer
5709     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5710     // to a handle at compile time.  This handle is embedded in the generated
5711     // code and dereferenced at the time the nmethod is made.  Until that time,
5712     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5713     // have access to the addresses!).  This does not seem to currently happen,
5714     // but this assertion here is to help prevent its occurence.
5715     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5716     ShouldNotReachHere();
5717   }
5718 
5719   return (intptr_t)klass()-&gt;constant_encoding();
5720 }
5721 //------------------------------dump2------------------------------------------
5722 // Dump Klass Type
5723 #ifndef PRODUCT
5724 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5725   switch( _ptr ) {
5726   case Constant:
5727     st-&gt;print(&quot;precise &quot;);
5728   case NotNull:
5729     {
5730       if (klass() != NULL) {
5731         const char* name = klass()-&gt;name()-&gt;as_utf8();
5732         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5733       } else {
5734         st-&gt;print(&quot;klass BOTTOM&quot;);
5735       }
5736     }
5737   case BotPTR:
5738     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5739   case TopPTR:
5740   case AnyNull:
5741     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5742     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5743     break;
5744   default:
5745     break;
5746   }
5747 
5748   _offset.dump2(st);
5749 
5750   st-&gt;print(&quot; *&quot;);
5751 }
5752 #endif
5753 
5754 
5755 
5756 //=============================================================================
5757 // Convenience common pre-built types.
5758 
5759 //------------------------------make-------------------------------------------
5760 const TypeFunc *TypeFunc::make(const TypeTuple *domain_sig, const TypeTuple* domain_cc,
5761                                const TypeTuple *range_sig, const TypeTuple *range_cc) {
5762   return (TypeFunc*)(new TypeFunc(domain_sig, domain_cc, range_sig, range_cc))-&gt;hashcons();
5763 }
5764 
5765 const TypeFunc *TypeFunc::make(const TypeTuple *domain, const TypeTuple *range) {
5766   return make(domain, domain, range, range);
5767 }
5768 
5769 //------------------------------osr_domain-----------------------------
5770 const TypeTuple* osr_domain() {
5771   const Type **fields = TypeTuple::fields(2);
5772   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
5773   return TypeTuple::make(TypeFunc::Parms+1, fields);
5774 }
5775 
5776 //------------------------------make-------------------------------------------
5777 const TypeFunc* TypeFunc::make(ciMethod* method, bool is_osr_compilation) {
5778   Compile* C = Compile::current();
5779   const TypeFunc* tf = NULL;
5780   if (!is_osr_compilation) {
5781     tf = C-&gt;last_tf(method); // check cache
5782     if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5783   }
5784   // Value types are not passed/returned by reference, instead each field of
5785   // the value type is passed/returned as an argument. We maintain two views of
5786   // the argument/return list here: one based on the signature (with a value
5787   // type argument/return as a single slot), one based on the actual calling
5788   // convention (with a value type argument/return as a list of its fields).
5789   bool has_scalar_args = method-&gt;has_scalarized_args() &amp;&amp; !is_osr_compilation;
5790   const TypeTuple* domain_sig = is_osr_compilation ? osr_domain() : TypeTuple::make_domain(method, false);
5791   const TypeTuple* domain_cc = has_scalar_args ? TypeTuple::make_domain(method, true) : domain_sig;
5792   ciSignature* sig = method-&gt;signature();
5793   bool has_scalar_ret = sig-&gt;returns_never_null() &amp;&amp; sig-&gt;return_type()-&gt;as_value_klass()-&gt;can_be_returned_as_fields();
5794   const TypeTuple* range_sig = TypeTuple::make_range(sig, false);
5795   const TypeTuple* range_cc = has_scalar_ret ? TypeTuple::make_range(sig, true) : range_sig;
5796   tf = TypeFunc::make(domain_sig, domain_cc, range_sig, range_cc);
5797   if (!is_osr_compilation) {
5798     C-&gt;set_last_tf(method, tf);  // fill cache
5799   }
5800   return tf;
5801 }
5802 
5803 //------------------------------meet-------------------------------------------
5804 // Compute the MEET of two types.  It returns a new Type object.
5805 const Type *TypeFunc::xmeet( const Type *t ) const {
5806   // Perform a fast test for common case; meeting the same types together.
5807   if( this == t ) return this;  // Meeting same type-rep?
5808 
5809   // Current &quot;this-&gt;_base&quot; is Func
5810   switch (t-&gt;base()) {          // switch on original type
5811 
5812   case Bottom:                  // Ye Olde Default
5813     return t;
5814 
5815   default:                      // All else is a mistake
5816     typerr(t);
5817 
5818   case Top:
5819     break;
5820   }
5821   return this;                  // Return the double constant
5822 }
5823 
5824 //------------------------------xdual------------------------------------------
5825 // Dual: compute field-by-field dual
5826 const Type *TypeFunc::xdual() const {
5827   return this;
5828 }
5829 
5830 //------------------------------eq---------------------------------------------
5831 // Structural equality check for Type representations
5832 bool TypeFunc::eq( const Type *t ) const {
5833   const TypeFunc *a = (const TypeFunc*)t;
5834   return _domain_sig == a-&gt;_domain_sig &amp;&amp;
5835     _domain_cc == a-&gt;_domain_cc &amp;&amp;
5836     _range_sig == a-&gt;_range_sig &amp;&amp;
5837     _range_cc == a-&gt;_range_cc;
5838 }
5839 
5840 //------------------------------hash-------------------------------------------
5841 // Type-specific hashing function.
5842 int TypeFunc::hash(void) const {
5843   return (intptr_t)_domain_sig + (intptr_t)_domain_cc + (intptr_t)_range_sig + (intptr_t)_range_cc;
5844 }
5845 
5846 //------------------------------dump2------------------------------------------
5847 // Dump Function Type
5848 #ifndef PRODUCT
5849 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5850   if( _range_sig-&gt;cnt() &lt;= Parms )
5851     st-&gt;print(&quot;void&quot;);
5852   else {
5853     uint i;
5854     for (i = Parms; i &lt; _range_sig-&gt;cnt()-1; i++) {
5855       _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5856       st-&gt;print(&quot;/&quot;);
5857     }
5858     _range_sig-&gt;field_at(i)-&gt;dump2(d,depth,st);
5859   }
5860   st-&gt;print(&quot; &quot;);
5861   st-&gt;print(&quot;( &quot;);
5862   if( !depth || d[this] ) {     // Check for recursive dump
5863     st-&gt;print(&quot;...)&quot;);
5864     return;
5865   }
5866   d.Insert((void*)this,(void*)this);    // Stop recursion
5867   if (Parms &lt; _domain_sig-&gt;cnt())
5868     _domain_sig-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5869   for (uint i = Parms+1; i &lt; _domain_sig-&gt;cnt(); i++) {
5870     st-&gt;print(&quot;, &quot;);
5871     _domain_sig-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5872   }
5873   st-&gt;print(&quot; )&quot;);
5874 }
5875 #endif
5876 
5877 //------------------------------singleton--------------------------------------
5878 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5879 // constants (Ldi nodes).  Singletons are integer, float or double constants
5880 // or a single symbol.
5881 bool TypeFunc::singleton(void) const {
5882   return false;                 // Never a singleton
5883 }
5884 
5885 bool TypeFunc::empty(void) const {
5886   return false;                 // Never empty
5887 }
5888 
5889 
5890 BasicType TypeFunc::return_type() const{
5891   if (range_sig()-&gt;cnt() == TypeFunc::Parms) {
5892     return T_VOID;
5893   }
5894   return range_sig()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5895 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
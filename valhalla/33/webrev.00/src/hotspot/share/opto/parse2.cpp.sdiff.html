<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  74   const Type* elemtype = Type::TOP;
  75   Node* adr = array_addressing(bt, 0, elemtype);
  76   if (stopped())  return;     // guaranteed null or range check
  77 
  78   Node* idx = pop();
  79   Node* ary = pop();
  80 
  81   // Handle value type arrays
  82   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
  83   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
  84   if (elemtype-&gt;isa_valuetype() != NULL) {
  85     C-&gt;set_flattened_accesses();
  86     // Load from flattened value type array
  87     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);
  88     push(vt);
  89     return;
  90   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {
  91     // Load from non-flattened but flattenable value type array (elements can never be null)
  92     bt = T_VALUETYPE;
  93   } else if (!ary_t-&gt;is_not_flat()) {
<span class="line-removed">  94     assert(is_reference_type(bt), &quot;&quot;);</span>
  95     // Cannot statically determine if array is flattened, emit runtime check
<span class="line-modified">  96     assert(ValueArrayFlatten &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
  97            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);
  98     Node* ctl = control();
  99     IdealKit ideal(this);
 100     IdealVariable res(ideal);
 101     ideal.declarations_done();
 102     Node* flattened = gen_flattened_array_test(ary);
 103     ideal.if_then(flattened, BoolTest::ne, zerocon(flattened-&gt;bottom_type()-&gt;basic_type())); {
 104       // flattened
 105       sync_kit(ideal);
 106       if (elemptr-&gt;is_valuetypeptr()) {
 107         // Element type is known, cast and load from flattened representation
 108         ciValueKlass* vk = elemptr-&gt;value_klass();
 109         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 110         ciArrayKlass* array_klass = ciArrayKlass::make(vk, /* never_null */ true);
 111         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 112         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
 113         Node* casted_adr = array_element_address(cast, idx, T_VALUETYPE, ary_t-&gt;size(), control());
 114         // Re-execute flattened array load if buffering triggers deoptimization
 115         PreserveReexecuteState preexecs(this);
 116         jvms()-&gt;set_should_reexecute(true);
</pre>
<hr />
<pre>
 167                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),
 168                                &quot;load_unknown_value&quot;,
 169                                ary, idx, alloc_obj);
 170           sync_kit(ideal);
 171         }
 172 
 173         // This makes sure no other thread sees a partially initialized buffered value
 174         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 175 
 176         // Same as MemBarCPUOrder above: keep this unknown flattened
 177         // array access correctly ordered with other flattened array
 178         // access
 179         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 180 
 181         // Prevent any use of the newly allocated value before it is
 182         // fully initialized
 183         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
 184         alloc_obj-&gt;set_req(0, control());
 185         alloc_obj = _gvn.transform(alloc_obj);
 186 
<span class="line-modified"> 187         const Type* unknown_value = TypeInstPtr::BOTTOM-&gt;cast_to_flat_array();</span>
<span class="line-removed"> 188 </span>
 189         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 190 
 191         ideal.sync_kit(this);
<span class="line-removed"> 192 </span>
 193         ideal.set(res, alloc_obj);
 194       }
 195     } ideal.else_(); {
 196       // non-flattened
 197       sync_kit(ideal);
 198       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 199       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,
 200                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD, ctl);
 201       ideal.sync_kit(this);
 202       ideal.set(res, ld);
 203     } ideal.end_if();
 204     sync_kit(ideal);
 205     Node* ld = _gvn.transform(ideal.value(res));
 206     ld = record_profile_for_speculation_at_array_load(ld);
 207     push_node(bt, ld);
 208     return;
 209   }
 210 
 211   if (elemtype == TypeInt::BOOL) {
 212     bt = T_BOOLEAN;
</pre>
</td>
<td>
<hr />
<pre>
  74   const Type* elemtype = Type::TOP;
  75   Node* adr = array_addressing(bt, 0, elemtype);
  76   if (stopped())  return;     // guaranteed null or range check
  77 
  78   Node* idx = pop();
  79   Node* ary = pop();
  80 
  81   // Handle value type arrays
  82   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
  83   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
  84   if (elemtype-&gt;isa_valuetype() != NULL) {
  85     C-&gt;set_flattened_accesses();
  86     // Load from flattened value type array
  87     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);
  88     push(vt);
  89     return;
  90   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {
  91     // Load from non-flattened but flattenable value type array (elements can never be null)
  92     bt = T_VALUETYPE;
  93   } else if (!ary_t-&gt;is_not_flat()) {

  94     // Cannot statically determine if array is flattened, emit runtime check
<span class="line-modified">  95     assert(ValueArrayFlatten &amp;&amp; is_reference_type(bt) &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
  96            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);
  97     Node* ctl = control();
  98     IdealKit ideal(this);
  99     IdealVariable res(ideal);
 100     ideal.declarations_done();
 101     Node* flattened = gen_flattened_array_test(ary);
 102     ideal.if_then(flattened, BoolTest::ne, zerocon(flattened-&gt;bottom_type()-&gt;basic_type())); {
 103       // flattened
 104       sync_kit(ideal);
 105       if (elemptr-&gt;is_valuetypeptr()) {
 106         // Element type is known, cast and load from flattened representation
 107         ciValueKlass* vk = elemptr-&gt;value_klass();
 108         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 109         ciArrayKlass* array_klass = ciArrayKlass::make(vk, /* never_null */ true);
 110         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 111         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
 112         Node* casted_adr = array_element_address(cast, idx, T_VALUETYPE, ary_t-&gt;size(), control());
 113         // Re-execute flattened array load if buffering triggers deoptimization
 114         PreserveReexecuteState preexecs(this);
 115         jvms()-&gt;set_should_reexecute(true);
</pre>
<hr />
<pre>
 166                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),
 167                                &quot;load_unknown_value&quot;,
 168                                ary, idx, alloc_obj);
 169           sync_kit(ideal);
 170         }
 171 
 172         // This makes sure no other thread sees a partially initialized buffered value
 173         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 174 
 175         // Same as MemBarCPUOrder above: keep this unknown flattened
 176         // array access correctly ordered with other flattened array
 177         // access
 178         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 179 
 180         // Prevent any use of the newly allocated value before it is
 181         // fully initialized
 182         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
 183         alloc_obj-&gt;set_req(0, control());
 184         alloc_obj = _gvn.transform(alloc_obj);
 185 
<span class="line-modified"> 186         const Type* unknown_value = elemptr-&gt;is_instptr()-&gt;cast_to_flat_array();</span>

 187         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 188 
 189         ideal.sync_kit(this);

 190         ideal.set(res, alloc_obj);
 191       }
 192     } ideal.else_(); {
 193       // non-flattened
 194       sync_kit(ideal);
 195       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 196       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,
 197                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD, ctl);
 198       ideal.sync_kit(this);
 199       ideal.set(res, ld);
 200     } ideal.end_if();
 201     sync_kit(ideal);
 202     Node* ld = _gvn.transform(ideal.value(res));
 203     ld = record_profile_for_speculation_at_array_load(ld);
 204     push_node(bt, ld);
 205     return;
 206   }
 207 
 208   if (elemtype == TypeInt::BOOL) {
 209     bt = T_BOOLEAN;
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/parse2.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compileLog.hpp&quot;
  30 #include &quot;interpreter/linkResolver.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;opto/addnode.hpp&quot;
  35 #include &quot;opto/castnode.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/divnode.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/idealKit.hpp&quot;
  40 #include &quot;opto/matcher.hpp&quot;
  41 #include &quot;opto/memnode.hpp&quot;
  42 #include &quot;opto/mulnode.hpp&quot;
  43 #include &quot;opto/opaquenode.hpp&quot;
  44 #include &quot;opto/parse.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/valuetypenode.hpp&quot;
  47 #include &quot;runtime/deoptimization.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 
  50 #ifndef PRODUCT
  51 extern int explicit_null_checks_inserted,
  52            explicit_null_checks_elided;
  53 #endif
  54 
  55 Node* Parse::record_profile_for_speculation_at_array_load(Node* ld) {
  56   // Feed unused profile data to type speculation
  57   if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
  58     ciKlass* array_type = NULL;
  59     ciKlass* element_type = NULL;
  60     ProfilePtrKind element_ptr = ProfileMaybeNull;
  61     bool flat_array = true;
  62     bool null_free_array = true;
  63     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
  64     if (element_type != NULL || element_ptr != ProfileMaybeNull) {
  65       ld = record_profile_for_speculation(ld, element_type, element_ptr);
  66     }
  67   }
  68   return ld;
  69 }
  70 
  71 
  72 //---------------------------------array_load----------------------------------
  73 void Parse::array_load(BasicType bt) {
  74   const Type* elemtype = Type::TOP;
  75   Node* adr = array_addressing(bt, 0, elemtype);
  76   if (stopped())  return;     // guaranteed null or range check
  77 
  78   Node* idx = pop();
  79   Node* ary = pop();
  80 
  81   // Handle value type arrays
  82   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
  83   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
  84   if (elemtype-&gt;isa_valuetype() != NULL) {
  85     C-&gt;set_flattened_accesses();
  86     // Load from flattened value type array
  87     Node* vt = ValueTypeNode::make_from_flattened(this, elemtype-&gt;value_klass(), ary, adr);
  88     push(vt);
  89     return;
  90   } else if (elemptr != NULL &amp;&amp; elemptr-&gt;is_valuetypeptr() &amp;&amp; !elemptr-&gt;maybe_null()) {
  91     // Load from non-flattened but flattenable value type array (elements can never be null)
  92     bt = T_VALUETYPE;
  93   } else if (!ary_t-&gt;is_not_flat()) {
<a name="1" id="anc1"></a><span class="line-removed">  94     assert(is_reference_type(bt), &quot;&quot;);</span>
  95     // Cannot statically determine if array is flattened, emit runtime check
<a name="2" id="anc2"></a><span class="line-modified">  96     assert(ValueArrayFlatten &amp;&amp; elemptr-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free() &amp;&amp;</span>
  97            (!elemptr-&gt;is_valuetypeptr() || elemptr-&gt;value_klass()-&gt;flatten_array()), &quot;array can&#39;t be flattened&quot;);
  98     Node* ctl = control();
  99     IdealKit ideal(this);
 100     IdealVariable res(ideal);
 101     ideal.declarations_done();
 102     Node* flattened = gen_flattened_array_test(ary);
 103     ideal.if_then(flattened, BoolTest::ne, zerocon(flattened-&gt;bottom_type()-&gt;basic_type())); {
 104       // flattened
 105       sync_kit(ideal);
 106       if (elemptr-&gt;is_valuetypeptr()) {
 107         // Element type is known, cast and load from flattened representation
 108         ciValueKlass* vk = elemptr-&gt;value_klass();
 109         assert(vk-&gt;flatten_array() &amp;&amp; elemptr-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 110         ciArrayKlass* array_klass = ciArrayKlass::make(vk, /* never_null */ true);
 111         const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 112         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));
 113         Node* casted_adr = array_element_address(cast, idx, T_VALUETYPE, ary_t-&gt;size(), control());
 114         // Re-execute flattened array load if buffering triggers deoptimization
 115         PreserveReexecuteState preexecs(this);
 116         jvms()-&gt;set_should_reexecute(true);
 117         inc_sp(2);
 118         Node* vt = ValueTypeNode::make_from_flattened(this, vk, cast, casted_adr)-&gt;allocate(this, false)-&gt;get_oop();
 119         ideal.set(res, vt);
 120         ideal.sync_kit(this);
 121       } else {
 122         Node* kls = load_object_klass(ary);
 123         // Element type is unknown, emit runtime call
 124         Node* k_adr = basic_plus_adr(kls, in_bytes(ArrayKlass::element_klass_offset()));
 125         Node* elem_klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));
 126         Node* obj_size  = NULL;
 127         kill_dead_locals();
 128         // Re-execute flattened array load if buffering triggers deoptimization
 129         PreserveReexecuteState preexecs(this);
 130         jvms()-&gt;set_bci(_bci);
 131         jvms()-&gt;set_should_reexecute(true);
 132         inc_sp(2);
 133         Node* alloc_obj = new_instance(elem_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
 134 
 135         AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
 136         assert(alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
 137         alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
 138 
 139         // This membar keeps this access to an unknown flattened array
 140         // correctly ordered with other unknown and known flattened
 141         // array accesses.
 142         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 143 
 144         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 145         // Unknown value type might contain reference fields
 146         if (false &amp;&amp; !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {
 147           // FIXME 8230656 also merge changes from 8238759 in
 148           int base_off = sizeof(instanceOopDesc);
 149           Node* dst_base = basic_plus_adr(alloc_obj, base_off);
 150           Node* countx = obj_size;
 151           countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
 152           countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
 153 
 154           assert(Klass::_lh_log2_element_size_shift == 0, &quot;use shift in place&quot;);
 155           Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));
 156           Node* elem_shift = make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);
 157           uint header = arrayOopDesc::base_offset_in_bytes(T_VALUETYPE);
 158           Node* base  = basic_plus_adr(ary, header);
 159           idx = Compile::conv_I2X_index(&amp;_gvn, idx, TypeInt::POS, control());
 160           Node* scale = _gvn.transform(new LShiftXNode(idx, elem_shift));
 161           Node* adr = basic_plus_adr(ary, base, scale);
 162 
 163           access_clone(adr, dst_base, countx, false);
 164         } else {
 165           ideal.sync_kit(this);
 166           ideal.make_leaf_call(OptoRuntime::load_unknown_value_Type(),
 167                                CAST_FROM_FN_PTR(address, OptoRuntime::load_unknown_value),
 168                                &quot;load_unknown_value&quot;,
 169                                ary, idx, alloc_obj);
 170           sync_kit(ideal);
 171         }
 172 
 173         // This makes sure no other thread sees a partially initialized buffered value
 174         insert_mem_bar_volatile(Op_MemBarStoreStore, Compile::AliasIdxRaw, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
 175 
 176         // Same as MemBarCPUOrder above: keep this unknown flattened
 177         // array access correctly ordered with other flattened array
 178         // access
 179         insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 180 
 181         // Prevent any use of the newly allocated value before it is
 182         // fully initialized
 183         alloc_obj = new CastPPNode(alloc_obj, _gvn.type(alloc_obj), true);
 184         alloc_obj-&gt;set_req(0, control());
 185         alloc_obj = _gvn.transform(alloc_obj);
 186 
<a name="3" id="anc3"></a><span class="line-modified"> 187         const Type* unknown_value = TypeInstPtr::BOTTOM-&gt;cast_to_flat_array();</span>
<span class="line-removed"> 188 </span>
 189         alloc_obj = _gvn.transform(new CheckCastPPNode(control(), alloc_obj, unknown_value));
 190 
 191         ideal.sync_kit(this);
<a name="4" id="anc4"></a><span class="line-removed"> 192 </span>
 193         ideal.set(res, alloc_obj);
 194       }
 195     } ideal.else_(); {
 196       // non-flattened
 197       sync_kit(ideal);
 198       const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 199       Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,
 200                                 IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD, ctl);
 201       ideal.sync_kit(this);
 202       ideal.set(res, ld);
 203     } ideal.end_if();
 204     sync_kit(ideal);
 205     Node* ld = _gvn.transform(ideal.value(res));
 206     ld = record_profile_for_speculation_at_array_load(ld);
 207     push_node(bt, ld);
 208     return;
 209   }
 210 
 211   if (elemtype == TypeInt::BOOL) {
 212     bt = T_BOOLEAN;
 213   }
 214   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 215   Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,
 216                             IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);
 217   if (bt == T_VALUETYPE) {
 218     // Loading a non-flattened (but flattenable) value type from an array
 219     assert(!gvn().type(ld)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);
 220     if (elemptr-&gt;value_klass()-&gt;is_scalarizable()) {
 221       ld = ValueTypeNode::make_from_oop(this, ld, elemptr-&gt;value_klass());
 222     }
 223   }
 224   if (!ld-&gt;is_ValueType()) {
 225     ld = record_profile_for_speculation_at_array_load(ld);
 226   }
 227 
 228   push_node(bt, ld);
 229 }
 230 
 231 
 232 //--------------------------------array_store----------------------------------
 233 void Parse::array_store(BasicType bt) {
 234   const Type* elemtype = Type::TOP;
 235   Node* adr = array_addressing(bt, type2size[bt], elemtype);
 236   if (stopped())  return;     // guaranteed null or range check
 237   Node* cast_val = NULL;
 238   if (bt == T_OBJECT) {
 239     cast_val = array_store_check();
 240     if (stopped()) return;
 241   }
 242   Node* val = pop_node(bt); // Value to store
 243   Node* idx = pop();        // Index in the array
 244   Node* ary = pop();        // The array itself
 245 
 246   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();
 247   const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);
 248 
 249   if (elemtype == TypeInt::BOOL) {
 250     bt = T_BOOLEAN;
 251   } else if (bt == T_OBJECT) {
 252     elemtype = elemtype-&gt;make_oopptr();
 253     const Type* tval = _gvn.type(cast_val);
 254     // We may have lost type information for &#39;val&#39; here due to the casts
 255     // emitted by the array_store_check code (see JDK-6312651)
 256     // TODO Remove this code once JDK-6312651 is in.
 257     const Type* tval_init = _gvn.type(val);
 258     bool can_be_value_type = tval-&gt;isa_valuetype() || (tval != TypePtr::NULL_PTR &amp;&amp; tval_init-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; tval-&gt;is_oopptr()-&gt;can_be_value_type());
 259     bool not_flattenable = !can_be_value_type || ((tval_init-&gt;is_valuetypeptr() || tval_init-&gt;isa_valuetype()) &amp;&amp; !tval_init-&gt;value_klass()-&gt;flatten_array());
 260 
 261     if (!ary_t-&gt;is_not_null_free() &amp;&amp; !can_be_value_type &amp;&amp; (!tval-&gt;maybe_null() || !tval_init-&gt;maybe_null())) {
 262       // Storing a non-inline-type, mark array as not null-free.
 263       // This is only legal for non-null stores because the array_store_check passes for null.
 264       ary_t = ary_t-&gt;cast_to_not_null_free();
 265       Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 266       replace_in_map(ary, cast);
 267       ary = cast;
 268     } else if (!ary_t-&gt;is_not_flat() &amp;&amp; not_flattenable) {
 269       // Storing a non-flattenable value, mark array as not flat.
 270       ary_t = ary_t-&gt;cast_to_not_flat();
 271       if (tval != TypePtr::NULL_PTR) {
 272         // For NULL, this transformation is only valid after the null guard below
 273         Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));
 274         replace_in_map(ary, cast);
 275         ary = cast;
 276       }
 277     }
 278 
 279     if (ary_t-&gt;elem()-&gt;isa_valuetype() != NULL) {
 280       // Store to flattened value type array
 281       C-&gt;set_flattened_accesses();
 282       if (!cast_val-&gt;is_ValueType()) {
 283         inc_sp(3);
 284         cast_val = null_check(cast_val);
 285         if (stopped()) return;
 286         dec_sp(3);
 287         cast_val = ValueTypeNode::make_from_oop(this, cast_val, ary_t-&gt;elem()-&gt;value_klass());
 288       }
 289       // Re-execute flattened array store if buffering triggers deoptimization
 290       PreserveReexecuteState preexecs(this);
 291       inc_sp(3);
 292       jvms()-&gt;set_should_reexecute(true);
 293       cast_val-&gt;as_ValueType()-&gt;store_flattened(this, ary, adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 294       return;
 295     } else if (elemtype-&gt;is_valuetypeptr() &amp;&amp; !elemtype-&gt;maybe_null()) {
 296       // Store to non-flattened but flattenable value type array (elements can never be null)
 297       if (!cast_val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {
 298         inc_sp(3);
 299         cast_val = null_check(cast_val);
 300         if (stopped()) return;
 301         dec_sp(3);
 302       }
 303     } else if (!ary_t-&gt;is_not_flat()) {
 304       // Array might be flattened, emit runtime checks
 305       assert(ValueArrayFlatten &amp;&amp; !not_flattenable &amp;&amp; elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp;
 306              !ary_t-&gt;klass_is_exact() &amp;&amp; !ary_t-&gt;is_not_null_free(), &quot;array can&#39;t be flattened&quot;);
 307       IdealKit ideal(this);
 308       Node* flattened = gen_flattened_array_test(ary);
 309       ideal.if_then(flattened, BoolTest::ne, zerocon(flattened-&gt;bottom_type()-&gt;basic_type())); {
 310         Node* val = cast_val;
 311         // flattened
 312         if (!val-&gt;is_ValueType() &amp;&amp; tval-&gt;maybe_null()) {
 313           // Add null check
 314           sync_kit(ideal);
 315           Node* null_ctl = top();
 316           val = null_check_oop(val, &amp;null_ctl);
 317           if (null_ctl != top()) {
 318             PreserveJVMState pjvms(this);
 319             inc_sp(3);
 320             set_control(null_ctl);
 321             uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);
 322             dec_sp(3);
 323           }
 324           ideal.sync_kit(this);
 325         }
 326         // Try to determine the value klass
 327         ciValueKlass* vk = NULL;
 328         if (tval-&gt;isa_valuetype() || tval-&gt;is_valuetypeptr()) {
 329           vk = tval-&gt;value_klass();
 330         } else if (tval_init-&gt;isa_valuetype() || tval_init-&gt;is_valuetypeptr()) {
 331           vk = tval_init-&gt;value_klass();
 332         } else if (elemtype-&gt;is_valuetypeptr()) {
 333           vk = elemtype-&gt;value_klass();
 334         }
 335         Node* casted_ary = ary;
 336         if (vk != NULL &amp;&amp; !stopped()) {
 337           // Element type is known, cast and store to flattened representation
 338           sync_kit(ideal);
 339           assert(vk-&gt;flatten_array() &amp;&amp; elemtype-&gt;maybe_null(), &quot;must be a flattenable and nullable array&quot;);
 340           ciArrayKlass* array_klass = ciArrayKlass::make(vk, /* never_null */ true);
 341           const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)-&gt;isa_aryptr();
 342           casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));
 343           Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype-&gt;size(), control());
 344           if (!val-&gt;is_ValueType()) {
 345             assert(!gvn().type(val)-&gt;maybe_null(), &quot;value type array elements should never be null&quot;);
 346             val = ValueTypeNode::make_from_oop(this, val, vk);
 347           }
 348           // Re-execute flattened array store if buffering triggers deoptimization
 349           PreserveReexecuteState preexecs(this);
 350           inc_sp(3);
 351           jvms()-&gt;set_should_reexecute(true);
 352           val-&gt;as_ValueType()-&gt;store_flattened(this, casted_ary, casted_adr, NULL, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 353           ideal.sync_kit(this);
 354         } else if (!ideal.ctrl()-&gt;is_top()) {
 355           // Element type is unknown, emit runtime call
 356           sync_kit(ideal);
 357 
 358           // This membar keeps this access to an unknown flattened
 359           // array correctly ordered with other unknown and known
 360           // flattened array accesses.
 361           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 362           ideal.sync_kit(this);
 363 
 364           ideal.make_leaf_call(OptoRuntime::store_unknown_value_Type(),
 365                                CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_value),
 366                                &quot;store_unknown_value&quot;,
 367                                val, casted_ary, idx);
 368 
 369           sync_kit(ideal);
 370           // Same as MemBarCPUOrder above: keep this unknown
 371           // flattened array access correctly ordered with other
 372           // flattened array accesses.
 373           insert_mem_bar_volatile(Op_MemBarCPUOrder, C-&gt;get_alias_index(TypeAryPtr::VALUES));
 374           ideal.sync_kit(this);
 375         }
 376       }
 377       ideal.else_();
 378       {
 379         // non-flattened
 380         sync_kit(ideal);
 381         gen_value_array_null_guard(ary, cast_val, 3);
 382         inc_sp(3);
 383         access_store_at(ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);
 384         dec_sp(3);
 385         ideal.sync_kit(this);
 386       }
 387       ideal.end_if();
 388       sync_kit(ideal);
 389       return;
 390     } else if (!ary_t-&gt;is_not_null_free()) {
 391       // Array is not flattened but may be null free
 392       assert(elemtype-&gt;is_oopptr()-&gt;can_be_value_type() &amp;&amp; !ary_t-&gt;klass_is_exact(), &quot;array can&#39;t be null free&quot;);
 393       ary = gen_value_array_null_guard(ary, cast_val, 3, true);
 394     }
 395   }
 396   inc_sp(3);
 397   access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);
 398   dec_sp(3);
 399 }
 400 
 401 
 402 //------------------------------array_addressing-------------------------------
 403 // Pull array and index from the stack.  Compute pointer-to-element.
 404 Node* Parse::array_addressing(BasicType type, int vals, const Type*&amp; elemtype) {
 405   Node *idx   = peek(0+vals);   // Get from stack without popping
 406   Node *ary   = peek(1+vals);   // in case of exception
 407 
 408   // Null check the array base, with correct stack contents
 409   ary = null_check(ary, T_ARRAY);
 410   // Compile-time detect of null-exception?
 411   if (stopped())  return top();
 412 
 413   const TypeAryPtr* arytype  = _gvn.type(ary)-&gt;is_aryptr();
 414   const TypeInt*    sizetype = arytype-&gt;size();
 415   elemtype = arytype-&gt;elem();
 416 
 417   if (UseUniqueSubclasses) {
 418     const Type* el = elemtype-&gt;make_ptr();
 419     if (el &amp;&amp; el-&gt;isa_instptr()) {
 420       const TypeInstPtr* toop = el-&gt;is_instptr();
 421       if (toop-&gt;klass()-&gt;as_instance_klass()-&gt;unique_concrete_subklass()) {
 422         // If we load from &quot;AbstractClass[]&quot; we must see &quot;ConcreteSubClass&quot;.
 423         const Type* subklass = Type::get_const_type(toop-&gt;klass());
 424         elemtype = subklass-&gt;join_speculative(el);
 425       }
 426     }
 427   }
 428 
 429   // Check for big class initializers with all constant offsets
 430   // feeding into a known-size array.
 431   const TypeInt* idxtype = _gvn.type(idx)-&gt;is_int();
 432   // See if the highest idx value is less than the lowest array bound,
 433   // and if the idx value cannot be negative:
 434   bool need_range_check = true;
 435   if (idxtype-&gt;_hi &lt; sizetype-&gt;_lo &amp;&amp; idxtype-&gt;_lo &gt;= 0) {
 436     need_range_check = false;
 437     if (C-&gt;log() != NULL)   C-&gt;log()-&gt;elem(&quot;observe that=&#39;!need_range_check&#39;&quot;);
 438   }
 439 
 440   ciKlass * arytype_klass = arytype-&gt;klass();
 441   if ((arytype_klass != NULL) &amp;&amp; (!arytype_klass-&gt;is_loaded())) {
 442     // Only fails for some -Xcomp runs
 443     // The class is unloaded.  We have to run this bytecode in the interpreter.
 444     uncommon_trap(Deoptimization::Reason_unloaded,
 445                   Deoptimization::Action_reinterpret,
 446                   arytype-&gt;klass(), &quot;!loaded array&quot;);
 447     return top();
 448   }
 449 
 450   // Do the range check
 451   if (GenerateRangeChecks &amp;&amp; need_range_check) {
 452     Node* tst;
 453     if (sizetype-&gt;_hi &lt;= 0) {
 454       // The greatest array bound is negative, so we can conclude that we&#39;re
 455       // compiling unreachable code, but the unsigned compare trick used below
 456       // only works with non-negative lengths.  Instead, hack &quot;tst&quot; to be zero so
 457       // the uncommon_trap path will always be taken.
 458       tst = _gvn.intcon(0);
 459     } else {
 460       // Range is constant in array-oop, so we can use the original state of mem
 461       Node* len = load_array_length(ary);
 462 
 463       // Test length vs index (standard trick using unsigned compare)
 464       Node* chk = _gvn.transform( new CmpUNode(idx, len) );
 465       BoolTest::mask btest = BoolTest::lt;
 466       tst = _gvn.transform( new BoolNode(chk, btest) );
 467     }
 468     RangeCheckNode* rc = new RangeCheckNode(control(), tst, PROB_MAX, COUNT_UNKNOWN);
 469     _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
 470     if (!tst-&gt;is_Con()) {
 471       record_for_igvn(rc);
 472     }
 473     set_control(_gvn.transform(new IfTrueNode(rc)));
 474     // Branch to failure if out of bounds
 475     {
 476       PreserveJVMState pjvms(this);
 477       set_control(_gvn.transform(new IfFalseNode(rc)));
 478       if (C-&gt;allow_range_check_smearing()) {
 479         // Do not use builtin_throw, since range checks are sometimes
 480         // made more stringent by an optimistic transformation.
 481         // This creates &quot;tentative&quot; range checks at this point,
 482         // which are not guaranteed to throw exceptions.
 483         // See IfNode::Ideal, is_range_check, adjust_check.
 484         uncommon_trap(Deoptimization::Reason_range_check,
 485                       Deoptimization::Action_make_not_entrant,
 486                       NULL, &quot;range_check&quot;);
 487       } else {
 488         // If we have already recompiled with the range-check-widening
 489         // heroic optimization turned off, then we must really be throwing
 490         // range check exceptions.
 491         builtin_throw(Deoptimization::Reason_range_check, idx);
 492       }
 493     }
 494   }
 495   // Check for always knowing you are throwing a range-check exception
 496   if (stopped())  return top();
 497 
 498   // This could be an access to a value array. We can&#39;t tell if it&#39;s
 499   // flat or not. Speculating it&#39;s not leads to a much simpler graph
 500   // shape. Check profiling.
 501   // For aastore, by the time we&#39;re here, the array store check should
 502   // have already taken advantage of profiling to cast the array to an
 503   // exact type reported by profiling
 504   const TypeOopPtr* elemptr = elemtype-&gt;make_oopptr();
 505   if (elemtype-&gt;isa_valuetype() == NULL &amp;&amp;
 506       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr() || elemptr-&gt;maybe_null()) &amp;&amp;
 507       !arytype-&gt;is_not_flat()) {
 508     assert(is_reference_type(type), &quot;Only references&quot;);
 509     // First check the speculative type
 510     Deoptimization::DeoptReason reason = Deoptimization::Reason_speculate_class_check;
 511     ciKlass* array_type = arytype-&gt;speculative_type();
 512     if (too_many_traps_or_recompiles(reason) || array_type == NULL) {
 513       // No speculative type, check profile data at this bci
 514       array_type = NULL;
 515       reason = Deoptimization::Reason_class_check;
 516       if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 517         ciKlass* element_type = NULL;
 518         ProfilePtrKind element_ptr = ProfileMaybeNull;
 519         bool flat_array = true;
 520         bool null_free_array = true;
 521         method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 522       }
 523     }
 524     if (array_type != NULL) {
 525       // Speculate that this array has the exact type reported by profile data
 526       Node* better_ary = NULL;
 527       Node* slow_ctl = type_check_receiver(ary, array_type, 1.0, &amp;better_ary);
 528       { PreserveJVMState pjvms(this);
 529         set_control(slow_ctl);
 530         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 531       }
 532       replace_in_map(ary, better_ary);
 533       ary = better_ary;
 534       arytype  = _gvn.type(ary)-&gt;is_aryptr();
 535       elemtype = arytype-&gt;elem();
 536     }
 537   } else if (UseTypeSpeculation &amp;&amp; UseArrayLoadStoreProfile) {
 538     // No need to speculate: feed profile data at this bci for the
 539     // array to type speculation
 540     ciKlass* array_type = NULL;
 541     ciKlass* element_type = NULL;
 542     ProfilePtrKind element_ptr = ProfileMaybeNull;
 543     bool flat_array = true;
 544     bool null_free_array = true;
 545     method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 546     if (array_type != NULL) {
 547       record_profile_for_speculation(ary, array_type, ProfileMaybeNull);
 548     }
 549   }
 550 
 551   // We have no exact array type from profile data. Check profile data
 552   // for a non null free or non flat array. Non null free implies non
 553   // flat so check this one first. Speculating on a non null free
 554   // array doesn&#39;t help aaload but could be profitable for a
 555   // subsequent aastore.
 556   elemptr = elemtype-&gt;make_oopptr();
 557   if (!arytype-&gt;is_not_null_free() &amp;&amp;
 558       elemtype-&gt;isa_valuetype() == NULL &amp;&amp;
 559       (elemptr == NULL || !elemptr-&gt;is_valuetypeptr()) &amp;&amp;
 560       UseArrayLoadStoreProfile) {
 561     assert(is_reference_type(type), &quot;&quot;);
 562     bool null_free_array = true;
 563     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 564     if (arytype-&gt;speculative() != NULL &amp;&amp;
 565         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_null_free() &amp;&amp;
 566         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 567       null_free_array = false;
 568       reason = Deoptimization::Reason_speculate_class_check;
 569     } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_class_check)) {
 570       ciKlass* array_type = NULL;
 571       ciKlass* element_type = NULL;
 572       ProfilePtrKind element_ptr = ProfileMaybeNull;
 573       bool flat_array = true;
 574       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 575       reason = Deoptimization::Reason_class_check;
 576     }
 577     if (!null_free_array) {
 578       Node* tst = gen_null_free_array_check(ary);
 579       {
 580         BuildCutout unless(this, tst, PROB_MAX);
 581         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 582       }
 583       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_null_free()));
 584       replace_in_map(ary, better_ary);
 585       ary = better_ary;
 586       arytype  = _gvn.type(ary)-&gt;is_aryptr();
 587     }
 588   }
 589 
 590   if (!arytype-&gt;is_not_flat() &amp;&amp; elemtype-&gt;isa_valuetype() == NULL) {
 591     assert(is_reference_type(type), &quot;&quot;);
 592     bool flat_array = true;
 593     Deoptimization::DeoptReason reason = Deoptimization::Reason_none;
 594     if (arytype-&gt;speculative() != NULL &amp;&amp;
 595         arytype-&gt;speculative()-&gt;is_aryptr()-&gt;is_not_flat() &amp;&amp;
 596         !too_many_traps_or_recompiles(Deoptimization::Reason_speculate_class_check)) {
 597       flat_array = false;
 598       reason = Deoptimization::Reason_speculate_class_check;
 599     } else if (UseArrayLoadStoreProfile &amp;&amp; !too_many_traps_or_recompiles(reason)) {
 600       ciKlass* array_type = NULL;
 601       ciKlass* element_type = NULL;
 602       ProfilePtrKind element_ptr = ProfileMaybeNull;
 603       bool null_free_array = true;
 604       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);
 605       reason = Deoptimization::Reason_class_check;
 606     }
 607     if (!flat_array) {
 608       Node* flattened = gen_flattened_array_test(ary);
 609       Node* chk = NULL;
 610       if (_gvn.type(flattened)-&gt;isa_int()) {
 611         chk = _gvn.transform(new CmpINode(flattened, intcon(0)));
 612       } else {
 613         assert(_gvn.type(flattened)-&gt;isa_long(), &quot;flattened property is int or long&quot;);
 614         chk = _gvn.transform(new CmpLNode(flattened, longcon(0)));
 615       }
 616       Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));
 617       {
 618         BuildCutout unless(this, tst, PROB_MAX);
 619         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
 620       }
 621       Node* better_ary = _gvn.transform(new CheckCastPPNode(control(), ary, arytype-&gt;cast_to_not_flat()));
 622       replace_in_map(ary, better_ary);
 623       ary = better_ary;
 624       arytype  = _gvn.type(ary)-&gt;is_aryptr();
 625     }
 626   }
 627 
 628   // Make array address computation control dependent to prevent it
 629   // from floating above the range check during loop optimizations.
 630   Node* ptr = array_element_address(ary, idx, type, sizetype, control());
 631   assert(ptr != top(), &quot;top should go hand-in-hand with stopped&quot;);
 632 
 633   return ptr;
 634 }
 635 
 636 
 637 // returns IfNode
 638 IfNode* Parse::jump_if_fork_int(Node* a, Node* b, BoolTest::mask mask, float prob, float cnt) {
 639   Node   *cmp = _gvn.transform(new CmpINode(a, b)); // two cases: shiftcount &gt; 32 and shiftcount &lt;= 32
 640   Node   *tst = _gvn.transform(new BoolNode(cmp, mask));
 641   IfNode *iff = create_and_map_if(control(), tst, prob, cnt);
 642   return iff;
 643 }
 644 
 645 // return Region node
 646 Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {
 647   Node *region  = new RegionNode(3); // 2 results
 648   record_for_igvn(region);
 649   region-&gt;init_req(1, iffalse);
 650   region-&gt;init_req(2, iftrue );
 651   _gvn.set_type(region, Type::CONTROL);
 652   region = _gvn.transform(region);
 653   set_control (region);
 654   return region;
 655 }
 656 
 657 // sentinel value for the target bci to mark never taken branches
 658 // (according to profiling)
 659 static const int never_reached = INT_MAX;
 660 
 661 //------------------------------helper for tableswitch-------------------------
 662 void Parse::jump_if_true_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 663   // True branch, use existing map info
 664   { PreserveJVMState pjvms(this);
 665     Node *iftrue  = _gvn.transform( new IfTrueNode (iff) );
 666     set_control( iftrue );
 667     if (unc) {
 668       repush_if_args();
 669       uncommon_trap(Deoptimization::Reason_unstable_if,
 670                     Deoptimization::Action_reinterpret,
 671                     NULL,
 672                     &quot;taken always&quot;);
 673     } else {
 674       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 675       profile_switch_case(prof_table_index);
 676       merge_new_path(dest_bci_if_true);
 677     }
 678   }
 679 
 680   // False branch
 681   Node *iffalse = _gvn.transform( new IfFalseNode(iff) );
 682   set_control( iffalse );
 683 }
 684 
 685 void Parse::jump_if_false_fork(IfNode *iff, int dest_bci_if_true, int prof_table_index, bool unc) {
 686   // True branch, use existing map info
 687   { PreserveJVMState pjvms(this);
 688     Node *iffalse  = _gvn.transform( new IfFalseNode (iff) );
 689     set_control( iffalse );
 690     if (unc) {
 691       repush_if_args();
 692       uncommon_trap(Deoptimization::Reason_unstable_if,
 693                     Deoptimization::Action_reinterpret,
 694                     NULL,
 695                     &quot;taken never&quot;);
 696     } else {
 697       assert(dest_bci_if_true != never_reached, &quot;inconsistent dest&quot;);
 698       profile_switch_case(prof_table_index);
 699       merge_new_path(dest_bci_if_true);
 700     }
 701   }
 702 
 703   // False branch
 704   Node *iftrue = _gvn.transform( new IfTrueNode(iff) );
 705   set_control( iftrue );
 706 }
 707 
 708 void Parse::jump_if_always_fork(int dest_bci, int prof_table_index, bool unc) {
 709   // False branch, use existing map and control()
 710   if (unc) {
 711     repush_if_args();
 712     uncommon_trap(Deoptimization::Reason_unstable_if,
 713                   Deoptimization::Action_reinterpret,
 714                   NULL,
 715                   &quot;taken never&quot;);
 716   } else {
 717     assert(dest_bci != never_reached, &quot;inconsistent dest&quot;);
 718     profile_switch_case(prof_table_index);
 719     merge_new_path(dest_bci);
 720   }
 721 }
 722 
 723 
 724 extern &quot;C&quot; {
 725   static int jint_cmp(const void *i, const void *j) {
 726     int a = *(jint *)i;
 727     int b = *(jint *)j;
 728     return a &gt; b ? 1 : a &lt; b ? -1 : 0;
 729   }
 730 }
 731 
 732 
 733 // Default value for methodData switch indexing. Must be a negative value to avoid
 734 // conflict with any legal switch index.
 735 #define NullTableIndex -1
 736 
 737 class SwitchRange : public StackObj {
 738   // a range of integers coupled with a bci destination
 739   jint _lo;                     // inclusive lower limit
 740   jint _hi;                     // inclusive upper limit
 741   int _dest;
 742   int _table_index;             // index into method data table
 743   float _cnt;                   // how many times this range was hit according to profiling
 744 
 745 public:
 746   jint lo() const              { return _lo;   }
 747   jint hi() const              { return _hi;   }
 748   int  dest() const            { return _dest; }
 749   int  table_index() const     { return _table_index; }
 750   bool is_singleton() const    { return _lo == _hi; }
 751   float cnt() const            { return _cnt; }
 752 
 753   void setRange(jint lo, jint hi, int dest, int table_index, float cnt) {
 754     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 755     _lo = lo, _hi = hi; _dest = dest; _table_index = table_index; _cnt = cnt;
 756     assert(_cnt &gt;= 0, &quot;&quot;);
 757   }
 758   bool adjoinRange(jint lo, jint hi, int dest, int table_index, float cnt, bool trim_ranges) {
 759     assert(lo &lt;= hi, &quot;must be a non-empty range&quot;);
 760     if (lo == _hi+1 &amp;&amp; table_index == _table_index) {
 761       // see merge_ranges() comment below
 762       if (trim_ranges) {
 763         if (cnt == 0) {
 764           if (_cnt != 0) {
 765             return false;
 766           }
 767           if (dest != _dest) {
 768             _dest = never_reached;
 769           }
 770         } else {
 771           if (_cnt == 0) {
 772             return false;
 773           }
 774           if (dest != _dest) {
 775             return false;
 776           }
 777         }
 778       } else {
 779         if (dest != _dest) {
 780           return false;
 781         }
 782       }
 783       _hi = hi;
 784       _cnt += cnt;
 785       return true;
 786     }
 787     return false;
 788   }
 789 
 790   void set (jint value, int dest, int table_index, float cnt) {
 791     setRange(value, value, dest, table_index, cnt);
 792   }
 793   bool adjoin(jint value, int dest, int table_index, float cnt, bool trim_ranges) {
 794     return adjoinRange(value, value, dest, table_index, cnt, trim_ranges);
 795   }
 796   bool adjoin(SwitchRange&amp; other) {
 797     return adjoinRange(other._lo, other._hi, other._dest, other._table_index, other._cnt, false);
 798   }
 799 
 800   void print() {
 801     if (is_singleton())
 802       tty-&gt;print(&quot; {%d}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 803     else if (lo() == min_jint)
 804       tty-&gt;print(&quot; {..%d}=&gt;%d (cnt=%f)&quot;, hi(), dest(), cnt());
 805     else if (hi() == max_jint)
 806       tty-&gt;print(&quot; {%d..}=&gt;%d (cnt=%f)&quot;, lo(), dest(), cnt());
 807     else
 808       tty-&gt;print(&quot; {%d..%d}=&gt;%d (cnt=%f)&quot;, lo(), hi(), dest(), cnt());
 809   }
 810 };
 811 
 812 // We try to minimize the number of ranges and the size of the taken
 813 // ones using profiling data. When ranges are created,
 814 // SwitchRange::adjoinRange() only allows 2 adjoining ranges to merge
 815 // if both were never hit or both were hit to build longer unreached
 816 // ranges. Here, we now merge adjoining ranges with the same
 817 // destination and finally set destination of unreached ranges to the
 818 // special value never_reached because it can help minimize the number
 819 // of tests that are necessary.
 820 //
 821 // For instance:
 822 // [0, 1] to target1 sometimes taken
 823 // [1, 2] to target1 never taken
 824 // [2, 3] to target2 never taken
 825 // would lead to:
 826 // [0, 1] to target1 sometimes taken
 827 // [1, 3] never taken
 828 //
 829 // (first 2 ranges to target1 are not merged)
 830 static void merge_ranges(SwitchRange* ranges, int&amp; rp) {
 831   if (rp == 0) {
 832     return;
 833   }
 834   int shift = 0;
 835   for (int j = 0; j &lt; rp; j++) {
 836     SwitchRange&amp; r1 = ranges[j-shift];
 837     SwitchRange&amp; r2 = ranges[j+1];
 838     if (r1.adjoin(r2)) {
 839       shift++;
 840     } else if (shift &gt; 0) {
 841       ranges[j+1-shift] = r2;
 842     }
 843   }
 844   rp -= shift;
 845   for (int j = 0; j &lt;= rp; j++) {
 846     SwitchRange&amp; r = ranges[j];
 847     if (r.cnt() == 0 &amp;&amp; r.dest() != never_reached) {
 848       r.setRange(r.lo(), r.hi(), never_reached, r.table_index(), r.cnt());
 849     }
 850   }
 851 }
 852 
 853 //-------------------------------do_tableswitch--------------------------------
 854 void Parse::do_tableswitch() {
 855   Node* lookup = pop();
 856   // Get information about tableswitch
 857   int default_dest = iter().get_dest_table(0);
 858   int lo_index     = iter().get_int_table(1);
 859   int hi_index     = iter().get_int_table(2);
 860   int len          = hi_index - lo_index + 1;
 861 
 862   if (len &lt; 1) {
 863     // If this is a backward branch, add safepoint
 864     maybe_add_safepoint(default_dest);
 865     merge(default_dest);
 866     return;
 867   }
 868 
 869   ciMethodData* methodData = method()-&gt;method_data();
 870   ciMultiBranchData* profile = NULL;
 871   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 872     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 873     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 874       profile = (ciMultiBranchData*)data;
 875     }
 876   }
 877   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 878 
 879   // generate decision tree, using trichotomy when possible
 880   int rnum = len+2;
 881   bool makes_backward_branch = false;
 882   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 883   int rp = -1;
 884   if (lo_index != min_jint) {
 885     uint cnt = 1;
 886     if (profile != NULL) {
 887       cnt = profile-&gt;default_count() / (hi_index != max_jint ? 2 : 1);
 888     }
 889     ranges[++rp].setRange(min_jint, lo_index-1, default_dest, NullTableIndex, cnt);
 890   }
 891   for (int j = 0; j &lt; len; j++) {
 892     jint match_int = lo_index+j;
 893     int  dest      = iter().get_dest_table(j+3);
 894     makes_backward_branch |= (dest &lt;= bci());
 895     int  table_index = method_data_update() ? j : NullTableIndex;
 896     uint cnt = 1;
 897     if (profile != NULL) {
 898       cnt = profile-&gt;count_at(j);
 899     }
 900     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 901       ranges[++rp].set(match_int, dest, table_index, cnt);
 902     }
 903   }
 904   jint highest = lo_index+(len-1);
 905   assert(ranges[rp].hi() == highest, &quot;&quot;);
 906   if (highest != max_jint) {
 907     uint cnt = 1;
 908     if (profile != NULL) {
 909       cnt = profile-&gt;default_count() / (lo_index != min_jint ? 2 : 1);
 910     }
 911     if (!ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, cnt, trim_ranges)) {
 912       ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, cnt);
 913     }
 914   }
 915   assert(rp &lt; len+2, &quot;not too many ranges&quot;);
 916 
 917   if (trim_ranges) {
 918     merge_ranges(ranges, rp);
 919   }
 920 
 921   // Safepoint in case if backward branch observed
 922   if( makes_backward_branch &amp;&amp; UseLoopSafepoints )
 923     add_safepoint();
 924 
 925   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
 926 }
 927 
 928 
 929 //------------------------------do_lookupswitch--------------------------------
 930 void Parse::do_lookupswitch() {
 931   Node *lookup = pop();         // lookup value
 932   // Get information about lookupswitch
 933   int default_dest = iter().get_dest_table(0);
 934   int len          = iter().get_int_table(1);
 935 
 936   if (len &lt; 1) {    // If this is a backward branch, add safepoint
 937     maybe_add_safepoint(default_dest);
 938     merge(default_dest);
 939     return;
 940   }
 941 
 942   ciMethodData* methodData = method()-&gt;method_data();
 943   ciMultiBranchData* profile = NULL;
 944   if (methodData-&gt;is_mature() &amp;&amp; UseSwitchProfiling) {
 945     ciProfileData* data = methodData-&gt;bci_to_data(bci());
 946     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
 947       profile = (ciMultiBranchData*)data;
 948     }
 949   }
 950   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
 951 
 952   // generate decision tree, using trichotomy when possible
 953   jint* table = NEW_RESOURCE_ARRAY(jint, len*3);
 954   {
 955     for (int j = 0; j &lt; len; j++) {
 956       table[3*j+0] = iter().get_int_table(2+2*j);
 957       table[3*j+1] = iter().get_dest_table(2+2*j+1);
 958       table[3*j+2] = profile == NULL ? 1 : profile-&gt;count_at(j);
 959     }
 960     qsort(table, len, 3*sizeof(table[0]), jint_cmp);
 961   }
 962 
 963   float defaults = 0;
 964   jint prev = min_jint;
 965   for (int j = 0; j &lt; len; j++) {
 966     jint match_int = table[3*j+0];
 967     if (match_int != prev) {
 968       defaults += (float)match_int - prev;
 969     }
 970     prev = match_int+1;
 971   }
 972   if (prev-1 != max_jint) {
 973     defaults += (float)max_jint - prev + 1;
 974   }
 975   float default_cnt = 1;
 976   if (profile != NULL) {
 977     default_cnt = profile-&gt;default_count()/defaults;
 978   }
 979 
 980   int rnum = len*2+1;
 981   bool makes_backward_branch = false;
 982   SwitchRange* ranges = NEW_RESOURCE_ARRAY(SwitchRange, rnum);
 983   int rp = -1;
 984   for (int j = 0; j &lt; len; j++) {
 985     jint match_int   = table[3*j+0];
 986     int  dest        = table[3*j+1];
 987     int  cnt         = table[3*j+2];
 988     int  next_lo     = rp &lt; 0 ? min_jint : ranges[rp].hi()+1;
 989     int  table_index = method_data_update() ? j : NullTableIndex;
 990     makes_backward_branch |= (dest &lt;= bci());
 991     float c = default_cnt * ((float)match_int - next_lo);
 992     if (match_int != next_lo &amp;&amp; (rp &lt; 0 || !ranges[rp].adjoinRange(next_lo, match_int-1, default_dest, NullTableIndex, c, trim_ranges))) {
 993       assert(default_dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 994       ranges[++rp].setRange(next_lo, match_int-1, default_dest, NullTableIndex, c);
 995     }
 996     if (rp &lt; 0 || !ranges[rp].adjoin(match_int, dest, table_index, cnt, trim_ranges)) {
 997       assert(dest != never_reached, &quot;sentinel value for dead destinations&quot;);
 998       ranges[++rp].set(match_int, dest, table_index, cnt);
 999     }
1000   }
1001   jint highest = table[3*(len-1)];
1002   assert(ranges[rp].hi() == highest, &quot;&quot;);
1003   if (highest != max_jint &amp;&amp;
1004       !ranges[rp].adjoinRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest), trim_ranges)) {
1005     ranges[++rp].setRange(highest+1, max_jint, default_dest, NullTableIndex, default_cnt * ((float)max_jint - highest));
1006   }
1007   assert(rp &lt; rnum, &quot;not too many ranges&quot;);
1008 
1009   if (trim_ranges) {
1010     merge_ranges(ranges, rp);
1011   }
1012 
1013   // Safepoint in case backward branch observed
1014   if (makes_backward_branch &amp;&amp; UseLoopSafepoints)
1015     add_safepoint();
1016 
1017   jump_switch_ranges(lookup, &amp;ranges[0], &amp;ranges[rp]);
1018 }
1019 
1020 static float if_prob(float taken_cnt, float total_cnt) {
1021   assert(taken_cnt &lt;= total_cnt, &quot;&quot;);
1022   if (total_cnt == 0) {
1023     return PROB_FAIR;
1024   }
1025   float p = taken_cnt / total_cnt;
1026   return clamp(p, PROB_MIN, PROB_MAX);
1027 }
1028 
1029 static float if_cnt(float cnt) {
1030   if (cnt == 0) {
1031     return COUNT_UNKNOWN;
1032   }
1033   return cnt;
1034 }
1035 
1036 static float sum_of_cnts(SwitchRange *lo, SwitchRange *hi) {
1037   float total_cnt = 0;
1038   for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1039     total_cnt += sr-&gt;cnt();
1040   }
1041   return total_cnt;
1042 }
1043 
1044 class SwitchRanges : public ResourceObj {
1045 public:
1046   SwitchRange* _lo;
1047   SwitchRange* _hi;
1048   SwitchRange* _mid;
1049   float _cost;
1050 
1051   enum {
1052     Start,
1053     LeftDone,
1054     RightDone,
1055     Done
1056   } _state;
1057 
1058   SwitchRanges(SwitchRange *lo, SwitchRange *hi)
1059     : _lo(lo), _hi(hi), _mid(NULL),
1060       _cost(0), _state(Start) {
1061   }
1062 
1063   SwitchRanges()
1064     : _lo(NULL), _hi(NULL), _mid(NULL),
1065       _cost(0), _state(Start) {}
1066 };
1067 
1068 // Estimate cost of performing a binary search on lo..hi
1069 static float compute_tree_cost(SwitchRange *lo, SwitchRange *hi, float total_cnt) {
1070   GrowableArray&lt;SwitchRanges&gt; tree;
1071   SwitchRanges root(lo, hi);
1072   tree.push(root);
1073 
1074   float cost = 0;
1075   do {
1076     SwitchRanges&amp; r = *tree.adr_at(tree.length()-1);
1077     if (r._hi != r._lo) {
1078       if (r._mid == NULL) {
1079         float r_cnt = sum_of_cnts(r._lo, r._hi);
1080 
1081         if (r_cnt == 0) {
1082           tree.pop();
1083           cost = 0;
1084           continue;
1085         }
1086 
1087         SwitchRange* mid = NULL;
1088         mid = r._lo;
1089         for (float cnt = 0; ; ) {
1090           assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1091           cnt += mid-&gt;cnt();
1092           if (cnt &gt; r_cnt / 2) {
1093             break;
1094           }
1095           mid++;
1096         }
1097         assert(mid &lt;= r._hi, &quot;out of bounds&quot;);
1098         r._mid = mid;
1099         r._cost = r_cnt / total_cnt;
1100       }
1101       r._cost += cost;
1102       if (r._state &lt; SwitchRanges::LeftDone &amp;&amp; r._mid &gt; r._lo) {
1103         cost = 0;
1104         r._state = SwitchRanges::LeftDone;
1105         tree.push(SwitchRanges(r._lo, r._mid-1));
1106       } else if (r._state &lt; SwitchRanges::RightDone) {
1107         cost = 0;
1108         r._state = SwitchRanges::RightDone;
1109         tree.push(SwitchRanges(r._mid == r._lo ? r._mid+1 : r._mid, r._hi));
1110       } else {
1111         tree.pop();
1112         cost = r._cost;
1113       }
1114     } else {
1115       tree.pop();
1116       cost = r._cost;
1117     }
1118   } while (tree.length() &gt; 0);
1119 
1120 
1121   return cost;
1122 }
1123 
1124 // It sometimes pays off to test most common ranges before the binary search
1125 void Parse::linear_search_switch_ranges(Node* key_val, SwitchRange*&amp; lo, SwitchRange*&amp; hi) {
1126   uint nr = hi - lo + 1;
1127   float total_cnt = sum_of_cnts(lo, hi);
1128 
1129   float min = compute_tree_cost(lo, hi, total_cnt);
1130   float extra = 1;
1131   float sub = 0;
1132 
1133   SwitchRange* array1 = lo;
1134   SwitchRange* array2 = NEW_RESOURCE_ARRAY(SwitchRange, nr);
1135 
1136   SwitchRange* ranges = NULL;
1137 
1138   while (nr &gt;= 2) {
1139     assert(lo == array1 || lo == array2, &quot;one the 2 already allocated arrays&quot;);
1140     ranges = (lo == array1) ? array2 : array1;
1141 
1142     // Find highest frequency range
1143     SwitchRange* candidate = lo;
1144     for (SwitchRange* sr = lo+1; sr &lt;= hi; sr++) {
1145       if (sr-&gt;cnt() &gt; candidate-&gt;cnt()) {
1146         candidate = sr;
1147       }
1148     }
1149     SwitchRange most_freq = *candidate;
1150     if (most_freq.cnt() == 0) {
1151       break;
1152     }
1153 
1154     // Copy remaining ranges into another array
1155     int shift = 0;
1156     for (uint i = 0; i &lt; nr; i++) {
1157       SwitchRange* sr = &amp;lo[i];
1158       if (sr != candidate) {
1159         ranges[i-shift] = *sr;
1160       } else {
1161         shift++;
1162         if (i &gt; 0 &amp;&amp; i &lt; nr-1) {
1163           SwitchRange prev = lo[i-1];
1164           prev.setRange(prev.lo(), sr-&gt;hi(), prev.dest(), prev.table_index(), prev.cnt());
1165           if (prev.adjoin(lo[i+1])) {
1166             shift++;
1167             i++;
1168           }
1169           ranges[i-shift] = prev;
1170         }
1171       }
1172     }
1173     nr -= shift;
1174 
1175     // Evaluate cost of testing the most common range and performing a
1176     // binary search on the other ranges
1177     float cost = extra + compute_tree_cost(&amp;ranges[0], &amp;ranges[nr-1], total_cnt);
1178     if (cost &gt;= min) {
1179       break;
1180     }
1181     // swap arrays
1182     lo = &amp;ranges[0];
1183     hi = &amp;ranges[nr-1];
1184 
1185     // It pays off: emit the test for the most common range
1186     assert(most_freq.cnt() &gt; 0, &quot;must be taken&quot;);
1187     Node* val = _gvn.transform(new SubINode(key_val, _gvn.intcon(most_freq.lo())));
1188     Node* cmp = _gvn.transform(new CmpUNode(val, _gvn.intcon(most_freq.hi() - most_freq.lo())));
1189     Node* tst = _gvn.transform(new BoolNode(cmp, BoolTest::le));
1190     IfNode* iff = create_and_map_if(control(), tst, if_prob(most_freq.cnt(), total_cnt), if_cnt(most_freq.cnt()));
1191     jump_if_true_fork(iff, most_freq.dest(), most_freq.table_index(), false);
1192 
1193     sub += most_freq.cnt() / total_cnt;
1194     extra += 1 - sub;
1195     min = cost;
1196   }
1197 }
1198 
1199 //----------------------------create_jump_tables-------------------------------
1200 bool Parse::create_jump_tables(Node* key_val, SwitchRange* lo, SwitchRange* hi) {
1201   // Are jumptables enabled
1202   if (!UseJumpTables)  return false;
1203 
1204   // Are jumptables supported
1205   if (!Matcher::has_match_rule(Op_Jump))  return false;
1206 
1207   // Don&#39;t make jump table if profiling
1208   if (method_data_update())  return false;
1209 
1210   bool trim_ranges = !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1211 
1212   // Decide if a guard is needed to lop off big ranges at either (or
1213   // both) end(s) of the input set. We&#39;ll call this the default target
1214   // even though we can&#39;t be sure that it is the true &quot;default&quot;.
1215 
1216   bool needs_guard = false;
1217   int default_dest;
1218   int64_t total_outlier_size = 0;
1219   int64_t hi_size = ((int64_t)hi-&gt;hi()) - ((int64_t)hi-&gt;lo()) + 1;
1220   int64_t lo_size = ((int64_t)lo-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1221 
1222   if (lo-&gt;dest() == hi-&gt;dest()) {
1223     total_outlier_size = hi_size + lo_size;
1224     default_dest = lo-&gt;dest();
1225   } else if (lo_size &gt; hi_size) {
1226     total_outlier_size = lo_size;
1227     default_dest = lo-&gt;dest();
1228   } else {
1229     total_outlier_size = hi_size;
1230     default_dest = hi-&gt;dest();
1231   }
1232 
1233   float total = sum_of_cnts(lo, hi);
1234   float cost = compute_tree_cost(lo, hi, total);
1235 
1236   // If a guard test will eliminate very sparse end ranges, then
1237   // it is worth the cost of an extra jump.
1238   float trimmed_cnt = 0;
1239   if (total_outlier_size &gt; (MaxJumpTableSparseness * 4)) {
1240     needs_guard = true;
1241     if (default_dest == lo-&gt;dest()) {
1242       trimmed_cnt += lo-&gt;cnt();
1243       lo++;
1244     }
1245     if (default_dest == hi-&gt;dest()) {
1246       trimmed_cnt += hi-&gt;cnt();
1247       hi--;
1248     }
1249   }
1250 
1251   // Find the total number of cases and ranges
1252   int64_t num_cases = ((int64_t)hi-&gt;hi()) - ((int64_t)lo-&gt;lo()) + 1;
1253   int num_range = hi - lo + 1;
1254 
1255   // Don&#39;t create table if: too large, too small, or too sparse.
1256   if (num_cases &gt; MaxJumpTableSize)
1257     return false;
1258   if (UseSwitchProfiling) {
1259     // MinJumpTableSize is set so with a well balanced binary tree,
1260     // when the number of ranges is MinJumpTableSize, it&#39;s cheaper to
1261     // go through a JumpNode that a tree of IfNodes. Average cost of a
1262     // tree of IfNodes with MinJumpTableSize is
1263     // log2f(MinJumpTableSize) comparisons. So if the cost computed
1264     // from profile data is less than log2f(MinJumpTableSize) then
1265     // going with the binary search is cheaper.
1266     if (cost &lt; log2f(MinJumpTableSize)) {
1267       return false;
1268     }
1269   } else {
1270     if (num_cases &lt; MinJumpTableSize)
1271       return false;
1272   }
1273   if (num_cases &gt; (MaxJumpTableSparseness * num_range))
1274     return false;
1275 
1276   // Normalize table lookups to zero
1277   int lowval = lo-&gt;lo();
1278   key_val = _gvn.transform( new SubINode(key_val, _gvn.intcon(lowval)) );
1279 
1280   // Generate a guard to protect against input keyvals that aren&#39;t
1281   // in the switch domain.
1282   if (needs_guard) {
1283     Node*   size = _gvn.intcon(num_cases);
1284     Node*   cmp = _gvn.transform(new CmpUNode(key_val, size));
1285     Node*   tst = _gvn.transform(new BoolNode(cmp, BoolTest::ge));
1286     IfNode* iff = create_and_map_if(control(), tst, if_prob(trimmed_cnt, total), if_cnt(trimmed_cnt));
1287     jump_if_true_fork(iff, default_dest, NullTableIndex, trim_ranges &amp;&amp; trimmed_cnt == 0);
1288 
1289     total -= trimmed_cnt;
1290   }
1291 
1292   // Create an ideal node JumpTable that has projections
1293   // of all possible ranges for a switch statement
1294   // The key_val input must be converted to a pointer offset and scaled.
1295   // Compare Parse::array_addressing above.
1296 
1297   // Clean the 32-bit int into a real 64-bit offset.
1298   // Otherwise, the jint value 0 might turn into an offset of 0x0800000000.
1299   const TypeInt* ikeytype = TypeInt::make(0, num_cases, Type::WidenMin);
1300   // Make I2L conversion control dependent to prevent it from
1301   // floating above the range check during loop optimizations.
1302   key_val = C-&gt;conv_I2X_index(&amp;_gvn, key_val, ikeytype, control());
1303 
1304   // Shift the value by wordsize so we have an index into the table, rather
1305   // than a switch value
1306   Node *shiftWord = _gvn.MakeConX(wordSize);
1307   key_val = _gvn.transform( new MulXNode( key_val, shiftWord));
1308 
1309   // Create the JumpNode
1310   Arena* arena = C-&gt;comp_arena();
1311   float* probs = (float*)arena-&gt;Amalloc(sizeof(float)*num_cases);
1312   int i = 0;
1313   if (total == 0) {
1314     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1315       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1316         probs[i] = 1.0F / num_cases;
1317       }
1318     }
1319   } else {
1320     for (SwitchRange* r = lo; r &lt;= hi; r++) {
1321       float prob = r-&gt;cnt()/total;
1322       for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1323         probs[i] = prob / (r-&gt;hi() - r-&gt;lo() + 1);
1324       }
1325     }
1326   }
1327 
1328   ciMethodData* methodData = method()-&gt;method_data();
1329   ciMultiBranchData* profile = NULL;
1330   if (methodData-&gt;is_mature()) {
1331     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1332     if (data != NULL &amp;&amp; data-&gt;is_MultiBranchData()) {
1333       profile = (ciMultiBranchData*)data;
1334     }
1335   }
1336 
1337   Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));
1338 
1339   // These are the switch destinations hanging off the jumpnode
1340   i = 0;
1341   for (SwitchRange* r = lo; r &lt;= hi; r++) {
1342     for (int64_t j = r-&gt;lo(); j &lt;= r-&gt;hi(); j++, i++) {
1343       Node* input = _gvn.transform(new JumpProjNode(jtn, i, r-&gt;dest(), (int)(j - lowval)));
1344       {
1345         PreserveJVMState pjvms(this);
1346         set_control(input);
1347         jump_if_always_fork(r-&gt;dest(), r-&gt;table_index(), trim_ranges &amp;&amp; r-&gt;cnt() == 0);
1348       }
1349     }
1350   }
1351   assert(i == num_cases, &quot;miscount of cases&quot;);
1352   stop_and_kill_map();  // no more uses for this JVMS
1353   return true;
1354 }
1355 
1356 //----------------------------jump_switch_ranges-------------------------------
1357 void Parse::jump_switch_ranges(Node* key_val, SwitchRange *lo, SwitchRange *hi, int switch_depth) {
1358   Block* switch_block = block();
1359   bool trim_ranges = !method_data_update() &amp;&amp; !C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);
1360 
1361   if (switch_depth == 0) {
1362     // Do special processing for the top-level call.
1363     assert(lo-&gt;lo() == min_jint, &quot;initial range must exhaust Type::INT&quot;);
1364     assert(hi-&gt;hi() == max_jint, &quot;initial range must exhaust Type::INT&quot;);
1365 
1366     // Decrement pred-numbers for the unique set of nodes.
1367 #ifdef ASSERT
1368     if (!trim_ranges) {
1369       // Ensure that the block&#39;s successors are a (duplicate-free) set.
1370       int successors_counted = 0;  // block occurrences in [hi..lo]
1371       int unique_successors = switch_block-&gt;num_successors();
1372       for (int i = 0; i &lt; unique_successors; i++) {
1373         Block* target = switch_block-&gt;successor_at(i);
1374 
1375         // Check that the set of successors is the same in both places.
1376         int successors_found = 0;
1377         for (SwitchRange* p = lo; p &lt;= hi; p++) {
1378           if (p-&gt;dest() == target-&gt;start())  successors_found++;
1379         }
1380         assert(successors_found &gt; 0, &quot;successor must be known&quot;);
1381         successors_counted += successors_found;
1382       }
1383       assert(successors_counted == (hi-lo)+1, &quot;no unexpected successors&quot;);
1384     }
1385 #endif
1386 
1387     // Maybe prune the inputs, based on the type of key_val.
1388     jint min_val = min_jint;
1389     jint max_val = max_jint;
1390     const TypeInt* ti = key_val-&gt;bottom_type()-&gt;isa_int();
1391     if (ti != NULL) {
1392       min_val = ti-&gt;_lo;
1393       max_val = ti-&gt;_hi;
1394       assert(min_val &lt;= max_val, &quot;invalid int type&quot;);
1395     }
1396     while (lo-&gt;hi() &lt; min_val) {
1397       lo++;
1398     }
1399     if (lo-&gt;lo() &lt; min_val)  {
1400       lo-&gt;setRange(min_val, lo-&gt;hi(), lo-&gt;dest(), lo-&gt;table_index(), lo-&gt;cnt());
1401     }
1402     while (hi-&gt;lo() &gt; max_val) {
1403       hi--;
1404     }
1405     if (hi-&gt;hi() &gt; max_val) {
1406       hi-&gt;setRange(hi-&gt;lo(), max_val, hi-&gt;dest(), hi-&gt;table_index(), hi-&gt;cnt());
1407     }
1408 
1409     linear_search_switch_ranges(key_val, lo, hi);
1410   }
1411 
1412 #ifndef PRODUCT
1413   if (switch_depth == 0) {
1414     _max_switch_depth = 0;
1415     _est_switch_depth = log2_intptr((hi-lo+1)-1)+1;
1416   }
1417 #endif
1418 
1419   assert(lo &lt;= hi, &quot;must be a non-empty set of ranges&quot;);
1420   if (lo == hi) {
1421     jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1422   } else {
1423     assert(lo-&gt;hi() == (lo+1)-&gt;lo()-1, &quot;contiguous ranges&quot;);
1424     assert(hi-&gt;lo() == (hi-1)-&gt;hi()+1, &quot;contiguous ranges&quot;);
1425 
1426     if (create_jump_tables(key_val, lo, hi)) return;
1427 
1428     SwitchRange* mid = NULL;
1429     float total_cnt = sum_of_cnts(lo, hi);
1430 
1431     int nr = hi - lo + 1;
1432     if (UseSwitchProfiling) {
1433       // Don&#39;t keep the binary search tree balanced: pick up mid point
1434       // that split frequencies in half.
1435       float cnt = 0;
1436       for (SwitchRange* sr = lo; sr &lt;= hi; sr++) {
1437         cnt += sr-&gt;cnt();
1438         if (cnt &gt;= total_cnt / 2) {
1439           mid = sr;
1440           break;
1441         }
1442       }
1443     } else {
1444       mid = lo + nr/2;
1445 
1446       // if there is an easy choice, pivot at a singleton:
1447       if (nr &gt; 3 &amp;&amp; !mid-&gt;is_singleton() &amp;&amp; (mid-1)-&gt;is_singleton())  mid--;
1448 
1449       assert(lo &lt; mid &amp;&amp; mid &lt;= hi, &quot;good pivot choice&quot;);
1450       assert(nr != 2 || mid == hi,   &quot;should pick higher of 2&quot;);
1451       assert(nr != 3 || mid == hi-1, &quot;should pick middle of 3&quot;);
1452     }
1453 
1454 
1455     Node *test_val = _gvn.intcon(mid == lo ? mid-&gt;hi() : mid-&gt;lo());
1456 
1457     if (mid-&gt;is_singleton()) {
1458       IfNode *iff_ne = jump_if_fork_int(key_val, test_val, BoolTest::ne, 1-if_prob(mid-&gt;cnt(), total_cnt), if_cnt(mid-&gt;cnt()));
1459       jump_if_false_fork(iff_ne, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; mid-&gt;cnt() == 0);
1460 
1461       // Special Case:  If there are exactly three ranges, and the high
1462       // and low range each go to the same place, omit the &quot;gt&quot; test,
1463       // since it will not discriminate anything.
1464       bool eq_test_only = (hi == lo+2 &amp;&amp; hi-&gt;dest() == lo-&gt;dest() &amp;&amp; mid == hi-1) || mid == lo;
1465 
1466       // if there is a higher range, test for it and process it:
1467       if (mid &lt; hi &amp;&amp; !eq_test_only) {
1468         // two comparisons of same values--should enable 1 test for 2 branches
1469         // Use BoolTest::lt instead of BoolTest::gt
1470         float cnt = sum_of_cnts(lo, mid-1);
1471         IfNode *iff_lt  = jump_if_fork_int(key_val, test_val, BoolTest::lt, if_prob(cnt, total_cnt), if_cnt(cnt));
1472         Node   *iftrue  = _gvn.transform( new IfTrueNode(iff_lt) );
1473         Node   *iffalse = _gvn.transform( new IfFalseNode(iff_lt) );
1474         { PreserveJVMState pjvms(this);
1475           set_control(iffalse);
1476           jump_switch_ranges(key_val, mid+1, hi, switch_depth+1);
1477         }
1478         set_control(iftrue);
1479       }
1480 
1481     } else {
1482       // mid is a range, not a singleton, so treat mid..hi as a unit
1483       float cnt = sum_of_cnts(mid == lo ? mid+1 : mid, hi);
1484       IfNode *iff_ge = jump_if_fork_int(key_val, test_val, mid == lo ? BoolTest::gt : BoolTest::ge, if_prob(cnt, total_cnt), if_cnt(cnt));
1485 
1486       // if there is a higher range, test for it and process it:
1487       if (mid == hi) {
1488         jump_if_true_fork(iff_ge, mid-&gt;dest(), mid-&gt;table_index(), trim_ranges &amp;&amp; cnt == 0);
1489       } else {
1490         Node *iftrue  = _gvn.transform( new IfTrueNode(iff_ge) );
1491         Node *iffalse = _gvn.transform( new IfFalseNode(iff_ge) );
1492         { PreserveJVMState pjvms(this);
1493           set_control(iftrue);
1494           jump_switch_ranges(key_val, mid == lo ? mid+1 : mid, hi, switch_depth+1);
1495         }
1496         set_control(iffalse);
1497       }
1498     }
1499 
1500     // in any case, process the lower range
1501     if (mid == lo) {
1502       if (mid-&gt;is_singleton()) {
1503         jump_switch_ranges(key_val, lo+1, hi, switch_depth+1);
1504       } else {
1505         jump_if_always_fork(lo-&gt;dest(), lo-&gt;table_index(), trim_ranges &amp;&amp; lo-&gt;cnt() == 0);
1506       }
1507     } else {
1508       jump_switch_ranges(key_val, lo, mid-1, switch_depth+1);
1509     }
1510   }
1511 
1512   // Decrease pred_count for each successor after all is done.
1513   if (switch_depth == 0) {
1514     int unique_successors = switch_block-&gt;num_successors();
1515     for (int i = 0; i &lt; unique_successors; i++) {
1516       Block* target = switch_block-&gt;successor_at(i);
1517       // Throw away the pre-allocated path for each unique successor.
1518       target-&gt;next_path_num();
1519     }
1520   }
1521 
1522 #ifndef PRODUCT
1523   _max_switch_depth = MAX2(switch_depth, _max_switch_depth);
1524   if (TraceOptoParse &amp;&amp; Verbose &amp;&amp; WizardMode &amp;&amp; switch_depth == 0) {
1525     SwitchRange* r;
1526     int nsing = 0;
1527     for( r = lo; r &lt;= hi; r++ ) {
1528       if( r-&gt;is_singleton() )  nsing++;
1529     }
1530     tty-&gt;print(&quot;&gt;&gt;&gt; &quot;);
1531     _method-&gt;print_short_name();
1532     tty-&gt;print_cr(&quot; switch decision tree&quot;);
1533     tty-&gt;print_cr(&quot;    %d ranges (%d singletons), max_depth=%d, est_depth=%d&quot;,
1534                   (int) (hi-lo+1), nsing, _max_switch_depth, _est_switch_depth);
1535     if (_max_switch_depth &gt; _est_switch_depth) {
1536       tty-&gt;print_cr(&quot;******** BAD SWITCH DEPTH ********&quot;);
1537     }
1538     tty-&gt;print(&quot;   &quot;);
1539     for( r = lo; r &lt;= hi; r++ ) {
1540       r-&gt;print();
1541     }
1542     tty-&gt;cr();
1543   }
1544 #endif
1545 }
1546 
1547 void Parse::modf() {
1548   Node *f2 = pop();
1549   Node *f1 = pop();
1550   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::modf_Type(),
1551                               CAST_FROM_FN_PTR(address, SharedRuntime::frem),
1552                               &quot;frem&quot;, NULL, //no memory effects
1553                               f1, f2);
1554   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1555 
1556   push(res);
1557 }
1558 
1559 void Parse::modd() {
1560   Node *d2 = pop_pair();
1561   Node *d1 = pop_pair();
1562   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(),
1563                               CAST_FROM_FN_PTR(address, SharedRuntime::drem),
1564                               &quot;drem&quot;, NULL, //no memory effects
1565                               d1, top(), d2, top());
1566   Node* res_d   = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1567 
1568 #ifdef ASSERT
1569   Node* res_top = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 1));
1570   assert(res_top == top(), &quot;second value must be top&quot;);
1571 #endif
1572 
1573   push_pair(res_d);
1574 }
1575 
1576 void Parse::l2f() {
1577   Node* f2 = pop();
1578   Node* f1 = pop();
1579   Node* c = make_runtime_call(RC_LEAF, OptoRuntime::l2f_Type(),
1580                               CAST_FROM_FN_PTR(address, SharedRuntime::l2f),
1581                               &quot;l2f&quot;, NULL, //no memory effects
1582                               f1, f2);
1583   Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));
1584 
1585   push(res);
1586 }
1587 
1588 void Parse::do_irem() {
1589   // Must keep both values on the expression-stack during null-check
1590   zero_check_int(peek());
1591   // Compile-time detect of null-exception?
1592   if (stopped())  return;
1593 
1594   Node* b = pop();
1595   Node* a = pop();
1596 
1597   const Type *t = _gvn.type(b);
1598   if (t != Type::TOP) {
1599     const TypeInt *ti = t-&gt;is_int();
1600     if (ti-&gt;is_con()) {
1601       int divisor = ti-&gt;get_con();
1602       // check for positive power of 2
1603       if (divisor &gt; 0 &amp;&amp;
1604           (divisor &amp; ~(divisor-1)) == divisor) {
1605         // yes !
1606         Node *mask = _gvn.intcon((divisor - 1));
1607         // Sigh, must handle negative dividends
1608         Node *zero = _gvn.intcon(0);
1609         IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);
1610         Node *iff = _gvn.transform( new IfFalseNode(ifff) );
1611         Node *ift = _gvn.transform( new IfTrueNode (ifff) );
1612         Node *reg = jump_if_join(ift, iff);
1613         Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);
1614         // Negative path; negate/and/negate
1615         Node *neg = _gvn.transform( new SubINode(zero, a) );
1616         Node *andn= _gvn.transform( new AndINode(neg, mask) );
1617         Node *negn= _gvn.transform( new SubINode(zero, andn) );
1618         phi-&gt;init_req(1, negn);
1619         // Fast positive case
1620         Node *andx = _gvn.transform( new AndINode(a, mask) );
1621         phi-&gt;init_req(2, andx);
1622         // Push the merge
1623         push( _gvn.transform(phi) );
1624         return;
1625       }
1626     }
1627   }
1628   // Default case
1629   push( _gvn.transform( new ModINode(control(),a,b) ) );
1630 }
1631 
1632 // Handle jsr and jsr_w bytecode
1633 void Parse::do_jsr() {
1634   assert(bc() == Bytecodes::_jsr || bc() == Bytecodes::_jsr_w, &quot;wrong bytecode&quot;);
1635 
1636   // Store information about current state, tagged with new _jsr_bci
1637   int return_bci = iter().next_bci();
1638   int jsr_bci    = (bc() == Bytecodes::_jsr) ? iter().get_dest() : iter().get_far_dest();
1639 
1640   // Update method data
1641   profile_taken_branch(jsr_bci);
1642 
1643   // The way we do things now, there is only one successor block
1644   // for the jsr, because the target code is cloned by ciTypeFlow.
1645   Block* target = successor_for_bci(jsr_bci);
1646 
1647   // What got pushed?
1648   const Type* ret_addr = target-&gt;peek();
1649   assert(ret_addr-&gt;singleton(), &quot;must be a constant (cloned jsr body)&quot;);
1650 
1651   // Effect on jsr on stack
1652   push(_gvn.makecon(ret_addr));
1653 
1654   // Flow to the jsr.
1655   merge(jsr_bci);
1656 }
1657 
1658 // Handle ret bytecode
1659 void Parse::do_ret() {
1660   // Find to whom we return.
1661   assert(block()-&gt;num_successors() == 1, &quot;a ret can only go one place now&quot;);
1662   Block* target = block()-&gt;successor_at(0);
1663   assert(!target-&gt;is_ready(), &quot;our arrival must be expected&quot;);
1664   profile_ret(target-&gt;flow()-&gt;start());
1665   int pnum = target-&gt;next_path_num();
1666   merge_common(target, pnum);
1667 }
1668 
1669 static bool has_injected_profile(BoolTest::mask btest, Node* test, int&amp; taken, int&amp; not_taken) {
1670   if (btest != BoolTest::eq &amp;&amp; btest != BoolTest::ne) {
1671     // Only ::eq and ::ne are supported for profile injection.
1672     return false;
1673   }
1674   if (test-&gt;is_Cmp() &amp;&amp;
1675       test-&gt;in(1)-&gt;Opcode() == Op_ProfileBoolean) {
1676     ProfileBooleanNode* profile = (ProfileBooleanNode*)test-&gt;in(1);
1677     int false_cnt = profile-&gt;false_count();
1678     int  true_cnt = profile-&gt;true_count();
1679 
1680     // Counts matching depends on the actual test operation (::eq or ::ne).
1681     // No need to scale the counts because profile injection was designed
1682     // to feed exact counts into VM.
1683     taken     = (btest == BoolTest::eq) ? false_cnt :  true_cnt;
1684     not_taken = (btest == BoolTest::eq) ?  true_cnt : false_cnt;
1685 
1686     profile-&gt;consume();
1687     return true;
1688   }
1689   return false;
1690 }
1691 //--------------------------dynamic_branch_prediction--------------------------
1692 // Try to gather dynamic branch prediction behavior.  Return a probability
1693 // of the branch being taken and set the &quot;cnt&quot; field.  Returns a -1.0
1694 // if we need to use static prediction for some reason.
1695 float Parse::dynamic_branch_prediction(float &amp;cnt, BoolTest::mask btest, Node* test) {
1696   ResourceMark rm;
1697 
1698   cnt  = COUNT_UNKNOWN;
1699 
1700   int     taken = 0;
1701   int not_taken = 0;
1702 
1703   bool use_mdo = !has_injected_profile(btest, test, taken, not_taken);
1704 
1705   if (use_mdo) {
1706     // Use MethodData information if it is available
1707     // FIXME: free the ProfileData structure
1708     ciMethodData* methodData = method()-&gt;method_data();
1709     if (!methodData-&gt;is_mature())  return PROB_UNKNOWN;
1710     ciProfileData* data = methodData-&gt;bci_to_data(bci());
1711     if (data == NULL) {
1712       return PROB_UNKNOWN;
1713     }
1714     if (!data-&gt;is_JumpData())  return PROB_UNKNOWN;
1715 
1716     // get taken and not taken values
1717     taken = data-&gt;as_JumpData()-&gt;taken();
1718     not_taken = 0;
1719     if (data-&gt;is_BranchData()) {
1720       not_taken = data-&gt;as_BranchData()-&gt;not_taken();
1721     }
1722 
1723     // scale the counts to be commensurate with invocation counts:
1724     taken = method()-&gt;scale_count(taken);
1725     not_taken = method()-&gt;scale_count(not_taken);
1726   }
1727 
1728   // Give up if too few (or too many, in which case the sum will overflow) counts to be meaningful.
1729   // We also check that individual counters are positive first, otherwise the sum can become positive.
1730   if (taken &lt; 0 || not_taken &lt; 0 || taken + not_taken &lt; 40) {
1731     if (C-&gt;log() != NULL) {
1732       C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39;&quot;, iter().get_dest(), taken, not_taken);
1733     }
1734     return PROB_UNKNOWN;
1735   }
1736 
1737   // Compute frequency that we arrive here
1738   float sum = taken + not_taken;
1739   // Adjust, if this block is a cloned private block but the
1740   // Jump counts are shared.  Taken the private counts for
1741   // just this path instead of the shared counts.
1742   if( block()-&gt;count() &gt; 0 )
1743     sum = block()-&gt;count();
1744   cnt = sum / FreqCountInvocations;
1745 
1746   // Pin probability to sane limits
1747   float prob;
1748   if( !taken )
1749     prob = (0+PROB_MIN) / 2;
1750   else if( !not_taken )
1751     prob = (1+PROB_MAX) / 2;
1752   else {                         // Compute probability of true path
1753     prob = (float)taken / (float)(taken + not_taken);
1754     if (prob &gt; PROB_MAX)  prob = PROB_MAX;
1755     if (prob &lt; PROB_MIN)   prob = PROB_MIN;
1756   }
1757 
1758   assert((cnt &gt; 0.0f) &amp;&amp; (prob &gt; 0.0f),
1759          &quot;Bad frequency assignment in if&quot;);
1760 
1761   if (C-&gt;log() != NULL) {
1762     const char* prob_str = NULL;
1763     if (prob &gt;= PROB_MAX)  prob_str = (prob == PROB_MAX) ? &quot;max&quot; : &quot;always&quot;;
1764     if (prob &lt;= PROB_MIN)  prob_str = (prob == PROB_MIN) ? &quot;min&quot; : &quot;never&quot;;
1765     char prob_str_buf[30];
1766     if (prob_str == NULL) {
1767       jio_snprintf(prob_str_buf, sizeof(prob_str_buf), &quot;%20.2f&quot;, prob);
1768       prob_str = prob_str_buf;
1769     }
1770     C-&gt;log()-&gt;elem(&quot;branch target_bci=&#39;%d&#39; taken=&#39;%d&#39; not_taken=&#39;%d&#39; cnt=&#39;%f&#39; prob=&#39;%s&#39;&quot;,
1771                    iter().get_dest(), taken, not_taken, cnt, prob_str);
1772   }
1773   return prob;
1774 }
1775 
1776 //-----------------------------branch_prediction-------------------------------
1777 float Parse::branch_prediction(float&amp; cnt,
1778                                BoolTest::mask btest,
1779                                int target_bci,
1780                                Node* test) {
1781   float prob = dynamic_branch_prediction(cnt, btest, test);
1782   // If prob is unknown, switch to static prediction
1783   if (prob != PROB_UNKNOWN)  return prob;
1784 
1785   prob = PROB_FAIR;                   // Set default value
1786   if (btest == BoolTest::eq)          // Exactly equal test?
1787     prob = PROB_STATIC_INFREQUENT;    // Assume its relatively infrequent
1788   else if (btest == BoolTest::ne)
1789     prob = PROB_STATIC_FREQUENT;      // Assume its relatively frequent
1790 
1791   // If this is a conditional test guarding a backwards branch,
1792   // assume its a loop-back edge.  Make it a likely taken branch.
1793   if (target_bci &lt; bci()) {
1794     if (is_osr_parse()) {    // Could be a hot OSR&#39;d loop; force deopt
1795       // Since it&#39;s an OSR, we probably have profile data, but since
1796       // branch_prediction returned PROB_UNKNOWN, the counts are too small.
1797       // Let&#39;s make a special check here for completely zero counts.
1798       ciMethodData* methodData = method()-&gt;method_data();
1799       if (!methodData-&gt;is_empty()) {
1800         ciProfileData* data = methodData-&gt;bci_to_data(bci());
1801         // Only stop for truly zero counts, which mean an unknown part
1802         // of the OSR-ed method, and we want to deopt to gather more stats.
1803         // If you have ANY counts, then this loop is simply &#39;cold&#39; relative
1804         // to the OSR loop.
1805         if (data == NULL ||
1806             (data-&gt;as_BranchData()-&gt;taken() +  data-&gt;as_BranchData()-&gt;not_taken() == 0)) {
1807           // This is the only way to return PROB_UNKNOWN:
1808           return PROB_UNKNOWN;
1809         }
1810       }
1811     }
1812     prob = PROB_STATIC_FREQUENT;     // Likely to take backwards branch
1813   }
1814 
1815   assert(prob != PROB_UNKNOWN, &quot;must have some guess at this point&quot;);
1816   return prob;
1817 }
1818 
1819 // The magic constants are chosen so as to match the output of
1820 // branch_prediction() when the profile reports a zero taken count.
1821 // It is important to distinguish zero counts unambiguously, because
1822 // some branches (e.g., _213_javac.Assembler.eliminate) validly produce
1823 // very small but nonzero probabilities, which if confused with zero
1824 // counts would keep the program recompiling indefinitely.
1825 bool Parse::seems_never_taken(float prob) const {
1826   return prob &lt; PROB_MIN;
1827 }
1828 
1829 // True if the comparison seems to be the kind that will not change its
1830 // statistics from true to false.  See comments in adjust_map_after_if.
1831 // This question is only asked along paths which are already
1832 // classifed as untaken (by seems_never_taken), so really,
1833 // if a path is never taken, its controlling comparison is
1834 // already acting in a stable fashion.  If the comparison
1835 // seems stable, we will put an expensive uncommon trap
1836 // on the untaken path.
1837 bool Parse::seems_stable_comparison() const {
1838   if (C-&gt;too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {
1839     return false;
1840   }
1841   return true;
1842 }
1843 
1844 //-------------------------------repush_if_args--------------------------------
1845 // Push arguments of an &quot;if&quot; bytecode back onto the stack by adjusting _sp.
1846 inline int Parse::repush_if_args() {
1847   if (PrintOpto &amp;&amp; WizardMode) {
1848     tty-&gt;print(&quot;defending against excessive implicit null exceptions on %s @%d in &quot;,
1849                Bytecodes::name(iter().cur_bc()), iter().cur_bci());
1850     method()-&gt;print_name(); tty-&gt;cr();
1851   }
1852   int bc_depth = - Bytecodes::depth(iter().cur_bc());
1853   assert(bc_depth == 1 || bc_depth == 2, &quot;only two kinds of branches&quot;);
1854   DEBUG_ONLY(sync_jvms());   // argument(n) requires a synced jvms
1855   assert(argument(0) != NULL, &quot;must exist&quot;);
1856   assert(bc_depth == 1 || argument(1) != NULL, &quot;two must exist&quot;);
1857   inc_sp(bc_depth);
1858   return bc_depth;
1859 }
1860 
1861 //----------------------------------do_ifnull----------------------------------
1862 void Parse::do_ifnull(BoolTest::mask btest, Node *c) {
1863   int target_bci = iter().get_dest();
1864 
1865   Block* branch_block = successor_for_bci(target_bci);
1866   Block* next_block   = successor_for_bci(iter().next_bci());
1867 
1868   float cnt;
1869   float prob = branch_prediction(cnt, btest, target_bci, c);
1870   if (prob == PROB_UNKNOWN) {
1871     // (An earlier version of do_ifnull omitted this trap for OSR methods.)
1872     if (PrintOpto &amp;&amp; Verbose) {
1873       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1874     }
1875     repush_if_args(); // to gather stats on loop
1876     // We need to mark this branch as taken so that if we recompile we will
1877     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1878     // do profiling and by the time we get to the lower tier from the interpreter
1879     // the path may be cold again. Make sure it doesn&#39;t look untaken
1880     profile_taken_branch(target_bci, !ProfileInterpreter);
1881     uncommon_trap(Deoptimization::Reason_unreached,
1882                   Deoptimization::Action_reinterpret,
1883                   NULL, &quot;cold&quot;);
1884     if (C-&gt;eliminate_boxing()) {
1885       // Mark the successor blocks as parsed
1886       branch_block-&gt;next_path_num();
1887       next_block-&gt;next_path_num();
1888     }
1889     return;
1890   }
1891 
1892   NOT_PRODUCT(explicit_null_checks_inserted++);
1893 
1894   // Generate real control flow
1895   Node   *tst = _gvn.transform( new BoolNode( c, btest ) );
1896 
1897   // Sanity check the probability value
1898   assert(prob &gt; 0.0f,&quot;Bad probability in Parser&quot;);
1899  // Need xform to put node in hash table
1900   IfNode *iff = create_and_xform_if( control(), tst, prob, cnt );
1901   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
1902   // True branch
1903   { PreserveJVMState pjvms(this);
1904     Node* iftrue  = _gvn.transform( new IfTrueNode (iff) );
1905     set_control(iftrue);
1906 
1907     if (stopped()) {            // Path is dead?
1908       NOT_PRODUCT(explicit_null_checks_elided++);
1909       if (C-&gt;eliminate_boxing()) {
1910         // Mark the successor block as parsed
1911         branch_block-&gt;next_path_num();
1912       }
1913     } else {                    // Path is live.
1914       // Update method data
1915       profile_taken_branch(target_bci);
1916       adjust_map_after_if(btest, c, prob, branch_block);
1917       if (!stopped()) {
1918         merge(target_bci);
1919       }
1920     }
1921   }
1922 
1923   // False branch
1924   Node* iffalse = _gvn.transform( new IfFalseNode(iff) );
1925   set_control(iffalse);
1926 
1927   if (stopped()) {              // Path is dead?
1928     NOT_PRODUCT(explicit_null_checks_elided++);
1929     if (C-&gt;eliminate_boxing()) {
1930       // Mark the successor block as parsed
1931       next_block-&gt;next_path_num();
1932     }
1933   } else  {                     // Path is live.
1934     // Update method data
1935     profile_not_taken_branch();
1936     adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);
1937   }
1938 }
1939 
1940 //------------------------------------do_if------------------------------------
1941 void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {
1942   int target_bci = iter().get_dest();
1943 
1944   Block* branch_block = successor_for_bci(target_bci);
1945   Block* next_block   = successor_for_bci(iter().next_bci());
1946 
1947   float cnt;
1948   float prob = branch_prediction(cnt, btest, target_bci, c);
1949   float untaken_prob = 1.0 - prob;
1950 
1951   if (prob == PROB_UNKNOWN) {
1952     if (PrintOpto &amp;&amp; Verbose) {
1953       tty-&gt;print_cr(&quot;Never-taken edge stops compilation at bci %d&quot;, bci());
1954     }
1955     repush_if_args(); // to gather stats on loop
1956     // We need to mark this branch as taken so that if we recompile we will
1957     // see that it is possible. In the tiered system the interpreter doesn&#39;t
1958     // do profiling and by the time we get to the lower tier from the interpreter
1959     // the path may be cold again. Make sure it doesn&#39;t look untaken
1960     profile_taken_branch(target_bci, !ProfileInterpreter);
1961     uncommon_trap(Deoptimization::Reason_unreached,
1962                   Deoptimization::Action_reinterpret,
1963                   NULL, &quot;cold&quot;);
1964     if (C-&gt;eliminate_boxing()) {
1965       // Mark the successor blocks as parsed
1966       branch_block-&gt;next_path_num();
1967       next_block-&gt;next_path_num();
1968     }
1969     return;
1970   }
1971 
1972   // Sanity check the probability value
1973   assert(0.0f &lt; prob &amp;&amp; prob &lt; 1.0f,&quot;Bad probability in Parser&quot;);
1974 
1975   bool taken_if_true = true;
1976   // Convert BoolTest to canonical form:
1977   if (!BoolTest(btest).is_canonical()) {
1978     btest         = BoolTest(btest).negate();
1979     taken_if_true = false;
1980     // prob is NOT updated here; it remains the probability of the taken
1981     // path (as opposed to the prob of the path guarded by an &#39;IfTrueNode&#39;).
1982   }
1983   assert(btest != BoolTest::eq, &quot;!= is the only canonical exact test&quot;);
1984 
1985   Node* tst0 = new BoolNode(c, btest);
1986   Node* tst = _gvn.transform(tst0);
1987   BoolTest::mask taken_btest   = BoolTest::illegal;
1988   BoolTest::mask untaken_btest = BoolTest::illegal;
1989 
1990   if (tst-&gt;is_Bool()) {
1991     // Refresh c from the transformed bool node, since it may be
1992     // simpler than the original c.  Also re-canonicalize btest.
1993     // This wins when (Bool ne (Conv2B p) 0) =&gt; (Bool ne (CmpP p NULL)).
1994     // That can arise from statements like: if (x instanceof C) ...
1995     if (tst != tst0) {
1996       // Canonicalize one more time since transform can change it.
1997       btest = tst-&gt;as_Bool()-&gt;_test._test;
1998       if (!BoolTest(btest).is_canonical()) {
1999         // Reverse edges one more time...
2000         tst   = _gvn.transform( tst-&gt;as_Bool()-&gt;negate(&amp;_gvn) );
2001         btest = tst-&gt;as_Bool()-&gt;_test._test;
2002         assert(BoolTest(btest).is_canonical(), &quot;sanity&quot;);
2003         taken_if_true = !taken_if_true;
2004       }
2005       c = tst-&gt;in(1);
2006     }
2007     BoolTest::mask neg_btest = BoolTest(btest).negate();
2008     taken_btest   = taken_if_true ?     btest : neg_btest;
2009     untaken_btest = taken_if_true ? neg_btest :     btest;
2010   }
2011 
2012   // Generate real control flow
2013   float true_prob = (taken_if_true ? prob : untaken_prob);
2014   IfNode* iff = create_and_map_if(control(), tst, true_prob, cnt);
2015   assert(iff-&gt;_prob &gt; 0.0f,&quot;Optimizer made bad probability in parser&quot;);
2016   Node* taken_branch   = new IfTrueNode(iff);
2017   Node* untaken_branch = new IfFalseNode(iff);
2018   if (!taken_if_true) {  // Finish conversion to canonical form
2019     Node* tmp      = taken_branch;
2020     taken_branch   = untaken_branch;
2021     untaken_branch = tmp;
2022   }
2023 
2024   // Branch is taken:
2025   { PreserveJVMState pjvms(this);
2026     taken_branch = _gvn.transform(taken_branch);
2027     set_control(taken_branch);
2028 
2029     if (stopped()) {
2030       if (C-&gt;eliminate_boxing() &amp;&amp; !new_path) {
2031         // Mark the successor block as parsed (if we haven&#39;t created a new path)
2032         branch_block-&gt;next_path_num();
2033       }
2034     } else {
2035       // Update method data
2036       profile_taken_branch(target_bci);
2037       adjust_map_after_if(taken_btest, c, prob, branch_block);
2038       if (!stopped()) {
2039         if (new_path) {
2040           // Merge by using a new path
2041           merge_new_path(target_bci);
2042         } else if (ctrl_taken != NULL) {
2043           // Don&#39;t merge but save taken branch to be wired by caller
2044           *ctrl_taken = control();
2045         } else {
2046           merge(target_bci);
2047         }
2048       }
2049     }
2050   }
2051 
2052   untaken_branch = _gvn.transform(untaken_branch);
2053   set_control(untaken_branch);
2054 
2055   // Branch not taken.
2056   if (stopped() &amp;&amp; ctrl_taken == NULL) {
2057     if (C-&gt;eliminate_boxing()) {
2058       // Mark the successor block as parsed (if caller does not re-wire control flow)
2059       next_block-&gt;next_path_num();
2060     }
2061   } else {
2062     // Update method data
2063     profile_not_taken_branch();
2064     adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);
2065   }
2066 }
2067 
2068 void Parse::do_acmp(BoolTest::mask btest, Node* a, Node* b) {
2069   ciMethod* subst_method = ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature());
2070   // If current method is ValueBootstrapMethods::isSubstitutable(),
2071   // compile the acmp as a regular pointer comparison otherwise we
2072   // could call ValueBootstrapMethods::isSubstitutable() back
2073   if (!EnableValhalla || (method() == subst_method)) {
2074     Node* cmp = CmpP(a, b);
2075     cmp = optimize_cmp_with_klass(cmp);
2076     do_if(btest, cmp);
2077     return;
2078   }
2079 
2080   // Allocate value type operands and re-execute on deoptimization
2081   if (a-&gt;is_ValueType()) {
2082     PreserveReexecuteState preexecs(this);
2083     inc_sp(2);
2084     jvms()-&gt;set_should_reexecute(true);
2085     a = a-&gt;as_ValueType()-&gt;allocate(this)-&gt;get_oop();
2086   }
2087   if (b-&gt;is_ValueType()) {
2088     PreserveReexecuteState preexecs(this);
2089     inc_sp(2);
2090     jvms()-&gt;set_should_reexecute(true);
2091     b = b-&gt;as_ValueType()-&gt;allocate(this)-&gt;get_oop();
2092   }
2093 
2094   // First, do a normal pointer comparison
2095   const TypeOopPtr* ta = _gvn.type(a)-&gt;isa_oopptr();
2096   const TypeOopPtr* tb = _gvn.type(b)-&gt;isa_oopptr();
2097   Node* cmp = CmpP(a, b);
2098   cmp = optimize_cmp_with_klass(cmp);
2099   if (ta == NULL || !ta-&gt;can_be_value_type() ||
2100       tb == NULL || !tb-&gt;can_be_value_type()) {
2101     // This is sufficient, if one of the operands can&#39;t be a value type
2102     do_if(btest, cmp);
2103     return;
2104   }
2105   Node* eq_region = NULL;
2106   if (btest == BoolTest::eq) {
2107     do_if(btest, cmp, true);
2108     if (stopped()) {
2109       return;
2110     }
2111   } else {
2112     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2113     Node* is_not_equal = NULL;
2114     eq_region = new RegionNode(3);
2115     {
2116       PreserveJVMState pjvms(this);
2117       do_if(btest, cmp, false, &amp;is_not_equal);
2118       if (!stopped()) {
2119         eq_region-&gt;init_req(1, control());
2120       }
2121     }
2122     if (is_not_equal == NULL || is_not_equal-&gt;is_top()) {
2123       record_for_igvn(eq_region);
2124       set_control(_gvn.transform(eq_region));
2125       return;
2126     }
2127     set_control(is_not_equal);
2128   }
2129 
2130   // Pointers are not equal, check if first operand is non-null
2131   Node* ne_region = new RegionNode(6);
2132   inc_sp(2);
2133   Node* null_ctl = top();
2134   Node* not_null_a = null_check_oop(a, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2135   dec_sp(2);
2136   ne_region-&gt;init_req(1, null_ctl);
2137   if (stopped()) {
2138     record_for_igvn(ne_region);
2139     set_control(_gvn.transform(ne_region));
2140     if (btest == BoolTest::ne) {
2141       {
2142         PreserveJVMState pjvms(this);
2143         int target_bci = iter().get_dest();
2144         merge(target_bci);
2145       }
2146       record_for_igvn(eq_region);
2147       set_control(_gvn.transform(eq_region));
2148     }
2149     return;
2150   }
2151 
2152   // First operand is non-null, check if it is a value type
2153   Node* is_value = is_always_locked(not_null_a);
2154   IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);
2155   Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));
2156   ne_region-&gt;init_req(2, not_value);
2157   set_control(_gvn.transform(new IfTrueNode(is_value_iff)));
2158 
2159   // The first operand is a value type, check if the second operand is non-null
2160   inc_sp(2);
2161   null_ctl = top();
2162   Node* not_null_b = null_check_oop(b, &amp;null_ctl, !too_many_traps(Deoptimization::Reason_null_check), false, false);
2163   dec_sp(2);
2164   ne_region-&gt;init_req(3, null_ctl);
2165   if (stopped()) {
2166     record_for_igvn(ne_region);
2167     set_control(_gvn.transform(ne_region));
2168     if (btest == BoolTest::ne) {
2169       {
2170         PreserveJVMState pjvms(this);
2171         int target_bci = iter().get_dest();
2172         merge(target_bci);
2173       }
2174       record_for_igvn(eq_region);
2175       set_control(_gvn.transform(eq_region));
2176     }
2177     return;
2178   }
2179 
2180   // Check if both operands are of the same class. We don&#39;t need to clear the array property
2181   // bits in the klass pointer for the cmp because we know that the first operand is a value type.
2182   Node* kls_a = load_object_klass(not_null_a, /* clear_prop_bits = */ false);
2183   Node* kls_b = load_object_klass(not_null_b, /* clear_prop_bits = */ false);
2184   Node* kls_cmp = CmpP(kls_a, kls_b);
2185   Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));
2186   IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);
2187   Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));
2188   set_control(_gvn.transform(new IfFalseNode(kls_iff)));
2189   ne_region-&gt;init_req(4, kls_ne);
2190 
2191   if (stopped()) {
2192     record_for_igvn(ne_region);
2193     set_control(_gvn.transform(ne_region));
2194     if (btest == BoolTest::ne) {
2195       {
2196         PreserveJVMState pjvms(this);
2197         int target_bci = iter().get_dest();
2198         merge(target_bci);
2199       }
2200       record_for_igvn(eq_region);
2201       set_control(_gvn.transform(eq_region));
2202     }
2203     return;
2204   }
2205 
2206   // Both operands are values types of the same class, we need to perform a
2207   // substitutability test. Delegate to ValueBootstrapMethods::isSubstitutable().
2208   Node* ne_io_phi = PhiNode::make(ne_region, i_o());
2209   Node* mem = reset_memory();
2210   Node* ne_mem_phi = PhiNode::make(ne_region, mem);
2211 
2212   Node* eq_io_phi = NULL;
2213   Node* eq_mem_phi = NULL;
2214   if (eq_region != NULL) {
2215     eq_io_phi = PhiNode::make(eq_region, i_o());
2216     eq_mem_phi = PhiNode::make(eq_region, mem);
2217   }
2218 
2219   set_all_memory(mem);
2220 
2221   kill_dead_locals();
2222   CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method, bci());
2223   call-&gt;set_override_symbolic_info(true);
2224   call-&gt;init_req(TypeFunc::Parms, not_null_a);
2225   call-&gt;init_req(TypeFunc::Parms+1, not_null_b);
2226   inc_sp(2);
2227   set_edges_for_java_call(call, false, false);
2228   Node* ret = set_results_for_java_call(call, false, true);
2229   dec_sp(2);
2230 
2231   // Test the return value of ValueBootstrapMethods::isSubstitutable()
2232   Node* subst_cmp = _gvn.transform(new CmpINode(ret, intcon(1)));
2233   Node* ctl = C-&gt;top();
2234   if (btest == BoolTest::eq) {
2235     PreserveJVMState pjvms(this);
2236     do_if(btest, subst_cmp);
2237     if (!stopped()) {
2238       ctl = control();
2239     }
2240   } else {
2241     assert(btest == BoolTest::ne, &quot;only eq or ne&quot;);
2242     PreserveJVMState pjvms(this);
2243     do_if(btest, subst_cmp, false, &amp;ctl);
2244     if (!stopped()) {
2245       eq_region-&gt;init_req(2, control());
2246       eq_io_phi-&gt;init_req(2, i_o());
2247       eq_mem_phi-&gt;init_req(2, reset_memory());
2248     }
2249   }
2250   ne_region-&gt;init_req(5, ctl);
2251   ne_io_phi-&gt;init_req(5, i_o());
2252   ne_mem_phi-&gt;init_req(5, reset_memory());
2253 
2254   record_for_igvn(ne_region);
2255   set_control(_gvn.transform(ne_region));
2256   set_i_o(_gvn.transform(ne_io_phi));
2257   set_all_memory(_gvn.transform(ne_mem_phi));
2258 
2259   if (btest == BoolTest::ne) {
2260     {
2261       PreserveJVMState pjvms(this);
2262       int target_bci = iter().get_dest();
2263       merge(target_bci);
2264     }
2265 
2266     record_for_igvn(eq_region);
2267     set_control(_gvn.transform(eq_region));
2268     set_i_o(_gvn.transform(eq_io_phi));
2269     set_all_memory(_gvn.transform(eq_mem_phi));
2270   }
2271 }
2272 
2273 bool Parse::path_is_suitable_for_uncommon_trap(float prob) const {
2274   // Don&#39;t want to speculate on uncommon traps when running with -Xcomp
2275   if (!UseInterpreter) {
2276     return false;
2277   }
2278   return (seems_never_taken(prob) &amp;&amp; seems_stable_comparison());
2279 }
2280 
2281 void Parse::maybe_add_predicate_after_if(Block* path) {
2282   if (path-&gt;is_SEL_head() &amp;&amp; path-&gt;preds_parsed() == 0) {
2283     // Add predicates at bci of if dominating the loop so traps can be
2284     // recorded on the if&#39;s profile data
2285     int bc_depth = repush_if_args();
2286     add_empty_predicates();
2287     dec_sp(bc_depth);
2288     path-&gt;set_has_predicates();
2289   }
2290 }
2291 
2292 
2293 //----------------------------adjust_map_after_if------------------------------
2294 // Adjust the JVM state to reflect the result of taking this path.
2295 // Basically, it means inspecting the CmpNode controlling this
2296 // branch, seeing how it constrains a tested value, and then
2297 // deciding if it&#39;s worth our while to encode this constraint
2298 // as graph nodes in the current abstract interpretation map.
2299 void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {
2300   if (!c-&gt;is_Cmp()) {
2301     maybe_add_predicate_after_if(path);
2302     return;
2303   }
2304 
2305   if (stopped() || btest == BoolTest::illegal) {
2306     return;                             // nothing to do
2307   }
2308 
2309   bool is_fallthrough = (path == successor_for_bci(iter().next_bci()));
2310 
2311   if (path_is_suitable_for_uncommon_trap(prob)) {
2312     repush_if_args();
2313     uncommon_trap(Deoptimization::Reason_unstable_if,
2314                   Deoptimization::Action_reinterpret,
2315                   NULL,
2316                   (is_fallthrough ? &quot;taken always&quot; : &quot;taken never&quot;));
2317     return;
2318   }
2319 
2320   Node* val = c-&gt;in(1);
2321   Node* con = c-&gt;in(2);
2322   const Type* tcon = _gvn.type(con);
2323   const Type* tval = _gvn.type(val);
2324   bool have_con = tcon-&gt;singleton();
2325   if (tval-&gt;singleton()) {
2326     if (!have_con) {
2327       // Swap, so constant is in con.
2328       con  = val;
2329       tcon = tval;
2330       val  = c-&gt;in(2);
2331       tval = _gvn.type(val);
2332       btest = BoolTest(btest).commute();
2333       have_con = true;
2334     } else {
2335       // Do we have two constants?  Then leave well enough alone.
2336       have_con = false;
2337     }
2338   }
2339   if (!have_con) {                        // remaining adjustments need a con
2340     maybe_add_predicate_after_if(path);
2341     return;
2342   }
2343 
2344   sharpen_type_after_if(btest, con, tcon, val, tval);
2345   maybe_add_predicate_after_if(path);
2346 }
2347 
2348 
2349 static Node* extract_obj_from_klass_load(PhaseGVN* gvn, Node* n) {
2350   Node* ldk;
2351   if (n-&gt;is_DecodeNKlass()) {
2352     if (n-&gt;in(1)-&gt;Opcode() != Op_LoadNKlass) {
2353       return NULL;
2354     } else {
2355       ldk = n-&gt;in(1);
2356     }
2357   } else if (n-&gt;Opcode() != Op_LoadKlass) {
2358     return NULL;
2359   } else {
2360     ldk = n;
2361   }
2362   assert(ldk != NULL &amp;&amp; ldk-&gt;is_Load(), &quot;should have found a LoadKlass or LoadNKlass node&quot;);
2363 
2364   Node* adr = ldk-&gt;in(MemNode::Address);
2365   intptr_t off = 0;
2366   Node* obj = AddPNode::Ideal_base_and_offset(adr, gvn, off);
2367   if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) // loading oopDesc::_klass?
2368     return NULL;
2369   const TypePtr* tp = gvn-&gt;type(obj)-&gt;is_ptr();
2370   if (tp == NULL || !(tp-&gt;isa_instptr() || tp-&gt;isa_aryptr())) // is obj a Java object ptr?
2371     return NULL;
2372 
2373   return obj;
2374 }
2375 
2376 void Parse::sharpen_type_after_if(BoolTest::mask btest,
2377                                   Node* con, const Type* tcon,
2378                                   Node* val, const Type* tval) {
2379   // Look for opportunities to sharpen the type of a node
2380   // whose klass is compared with a constant klass.
2381   if (btest == BoolTest::eq &amp;&amp; tcon-&gt;isa_klassptr()) {
2382     Node* obj = extract_obj_from_klass_load(&amp;_gvn, val);
2383     const TypeOopPtr* con_type = tcon-&gt;isa_klassptr()-&gt;as_instance_type();
2384     if (obj != NULL &amp;&amp; (con_type-&gt;isa_instptr() || con_type-&gt;isa_aryptr())) {
2385        // Found:
2386        //   Bool(CmpP(LoadKlass(obj._klass), ConP(Foo.klass)), [eq])
2387        // or the narrowOop equivalent.
2388        const Type* obj_type = _gvn.type(obj);
2389        const TypeOopPtr* tboth = obj_type-&gt;join_speculative(con_type)-&gt;isa_oopptr();
2390        if (tboth != NULL &amp;&amp; tboth-&gt;klass_is_exact() &amp;&amp; tboth != obj_type &amp;&amp;
2391            tboth-&gt;higher_equal(obj_type)) {
2392           // obj has to be of the exact type Foo if the CmpP succeeds.
2393           int obj_in_map = map()-&gt;find_edge(obj);
2394           JVMState* jvms = this-&gt;jvms();
2395           if (obj_in_map &gt;= 0 &amp;&amp;
2396               (jvms-&gt;is_loc(obj_in_map) || jvms-&gt;is_stk(obj_in_map))) {
2397             TypeNode* ccast = new CheckCastPPNode(control(), obj, tboth);
2398             const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2399             assert(tcc != obj_type &amp;&amp; tcc-&gt;higher_equal(obj_type), &quot;must improve&quot;);
2400             // Delay transform() call to allow recovery of pre-cast value
2401             // at the control merge.
2402             _gvn.set_type_bottom(ccast);
2403             record_for_igvn(ccast);
2404             // Here&#39;s the payoff.
2405             replace_in_map(obj, ccast);
2406           }
2407        }
2408     }
2409   }
2410 
2411   int val_in_map = map()-&gt;find_edge(val);
2412   if (val_in_map &lt; 0)  return;          // replace_in_map would be useless
2413   {
2414     JVMState* jvms = this-&gt;jvms();
2415     if (!(jvms-&gt;is_loc(val_in_map) ||
2416           jvms-&gt;is_stk(val_in_map)))
2417       return;                           // again, it would be useless
2418   }
2419 
2420   // Check for a comparison to a constant, and &quot;know&quot; that the compared
2421   // value is constrained on this path.
2422   assert(tcon-&gt;singleton(), &quot;&quot;);
2423   ConstraintCastNode* ccast = NULL;
2424   Node* cast = NULL;
2425 
2426   switch (btest) {
2427   case BoolTest::eq:                    // Constant test?
2428     {
2429       const Type* tboth = tcon-&gt;join_speculative(tval);
2430       if (tboth == tval)  break;        // Nothing to gain.
2431       if (tcon-&gt;isa_int()) {
2432         ccast = new CastIINode(val, tboth);
2433       } else if (tcon == TypePtr::NULL_PTR) {
2434         // Cast to null, but keep the pointer identity temporarily live.
2435         ccast = new CastPPNode(val, tboth);
2436       } else {
2437         const TypeF* tf = tcon-&gt;isa_float_constant();
2438         const TypeD* td = tcon-&gt;isa_double_constant();
2439         // Exclude tests vs float/double 0 as these could be
2440         // either +0 or -0.  Just because you are equal to +0
2441         // doesn&#39;t mean you ARE +0!
2442         // Note, following code also replaces Long and Oop values.
2443         if ((!tf || tf-&gt;_f != 0.0) &amp;&amp;
2444             (!td || td-&gt;_d != 0.0))
2445           cast = con;                   // Replace non-constant val by con.
2446       }
2447     }
2448     break;
2449 
2450   case BoolTest::ne:
2451     if (tcon == TypePtr::NULL_PTR) {
2452       cast = cast_not_null(val, false);
2453     }
2454     break;
2455 
2456   default:
2457     // (At this point we could record int range types with CastII.)
2458     break;
2459   }
2460 
2461   if (ccast != NULL) {
2462     const Type* tcc = ccast-&gt;as_Type()-&gt;type();
2463     assert(tcc != tval &amp;&amp; tcc-&gt;higher_equal(tval), &quot;must improve&quot;);
2464     // Delay transform() call to allow recovery of pre-cast value
2465     // at the control merge.
2466     ccast-&gt;set_req(0, control());
2467     _gvn.set_type_bottom(ccast);
2468     record_for_igvn(ccast);
2469     cast = ccast;
2470   }
2471 
2472   if (cast != NULL) {                   // Here&#39;s the payoff.
2473     replace_in_map(val, cast);
2474   }
2475 }
2476 
2477 /**
2478  * Use speculative type to optimize CmpP node: if comparison is
2479  * against the low level class, cast the object to the speculative
2480  * type if any. CmpP should then go away.
2481  *
2482  * @param c  expected CmpP node
2483  * @return   result of CmpP on object casted to speculative type
2484  *
2485  */
2486 Node* Parse::optimize_cmp_with_klass(Node* c) {
2487   // If this is transformed by the _gvn to a comparison with the low
2488   // level klass then we may be able to use speculation
2489   if (c-&gt;Opcode() == Op_CmpP &amp;&amp;
2490       (c-&gt;in(1)-&gt;Opcode() == Op_LoadKlass || c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) &amp;&amp;
2491       c-&gt;in(2)-&gt;is_Con()) {
2492     Node* load_klass = NULL;
2493     Node* decode = NULL;
2494     if (c-&gt;in(1)-&gt;Opcode() == Op_DecodeNKlass) {
2495       decode = c-&gt;in(1);
2496       load_klass = c-&gt;in(1)-&gt;in(1);
2497     } else {
2498       load_klass = c-&gt;in(1);
2499     }
2500     if (load_klass-&gt;in(2)-&gt;is_AddP()) {
2501       Node* addp = load_klass-&gt;in(2);
2502       Node* obj = addp-&gt;in(AddPNode::Address);
2503       const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
2504       if (obj_type-&gt;speculative_type_not_null() != NULL) {
2505         ciKlass* k = obj_type-&gt;speculative_type();
2506         inc_sp(2);
2507         obj = maybe_cast_profiled_obj(obj, k);
2508         dec_sp(2);
2509         if (obj-&gt;is_ValueType()) {
2510           assert(obj-&gt;as_ValueType()-&gt;is_allocated(&amp;_gvn), &quot;must be allocated&quot;);
2511           obj = obj-&gt;as_ValueType()-&gt;get_oop();
2512         }
2513         // Make the CmpP use the casted obj
2514         addp = basic_plus_adr(obj, addp-&gt;in(AddPNode::Offset));
2515         load_klass = load_klass-&gt;clone();
2516         load_klass-&gt;set_req(2, addp);
2517         load_klass = _gvn.transform(load_klass);
2518         if (decode != NULL) {
2519           decode = decode-&gt;clone();
2520           decode-&gt;set_req(1, load_klass);
2521           load_klass = _gvn.transform(decode);
2522         }
2523         c = c-&gt;clone();
2524         c-&gt;set_req(1, load_klass);
2525         c = _gvn.transform(c);
2526       }
2527     }
2528   }
2529   return c;
2530 }
2531 
2532 //------------------------------do_one_bytecode--------------------------------
2533 // Parse this bytecode, and alter the Parsers JVM-&gt;Node mapping
2534 void Parse::do_one_bytecode() {
2535   Node *a, *b, *c, *d;          // Handy temps
2536   BoolTest::mask btest;
2537   int i;
2538 
2539   assert(!has_exceptions(), &quot;bytecode entry state must be clear of throws&quot;);
2540 
2541   if (C-&gt;check_node_count(NodeLimitFudgeFactor * 5,
2542                           &quot;out of nodes parsing method&quot;)) {
2543     return;
2544   }
2545 
2546 #ifdef ASSERT
2547   // for setting breakpoints
2548   if (TraceOptoParse) {
2549     tty-&gt;print(&quot; @&quot;);
2550     dump_bci(bci());
2551     tty-&gt;cr();
2552   }
2553 #endif
2554 
2555   switch (bc()) {
2556   case Bytecodes::_nop:
2557     // do nothing
2558     break;
2559   case Bytecodes::_lconst_0:
2560     push_pair(longcon(0));
2561     break;
2562 
2563   case Bytecodes::_lconst_1:
2564     push_pair(longcon(1));
2565     break;
2566 
2567   case Bytecodes::_fconst_0:
2568     push(zerocon(T_FLOAT));
2569     break;
2570 
2571   case Bytecodes::_fconst_1:
2572     push(makecon(TypeF::ONE));
2573     break;
2574 
2575   case Bytecodes::_fconst_2:
2576     push(makecon(TypeF::make(2.0f)));
2577     break;
2578 
2579   case Bytecodes::_dconst_0:
2580     push_pair(zerocon(T_DOUBLE));
2581     break;
2582 
2583   case Bytecodes::_dconst_1:
2584     push_pair(makecon(TypeD::ONE));
2585     break;
2586 
2587   case Bytecodes::_iconst_m1:push(intcon(-1)); break;
2588   case Bytecodes::_iconst_0: push(intcon( 0)); break;
2589   case Bytecodes::_iconst_1: push(intcon( 1)); break;
2590   case Bytecodes::_iconst_2: push(intcon( 2)); break;
2591   case Bytecodes::_iconst_3: push(intcon( 3)); break;
2592   case Bytecodes::_iconst_4: push(intcon( 4)); break;
2593   case Bytecodes::_iconst_5: push(intcon( 5)); break;
2594   case Bytecodes::_bipush:   push(intcon(iter().get_constant_u1())); break;
2595   case Bytecodes::_sipush:   push(intcon(iter().get_constant_u2())); break;
2596   case Bytecodes::_aconst_null: push(null());  break;
2597   case Bytecodes::_ldc:
2598   case Bytecodes::_ldc_w:
2599   case Bytecodes::_ldc2_w:
2600     // If the constant is unresolved, run this BC once in the interpreter.
2601     {
2602       ciConstant constant = iter().get_constant();
2603       if (!constant.is_valid() ||
2604           (constant.basic_type() == T_OBJECT &amp;&amp;
2605            !constant.as_object()-&gt;is_loaded())) {
2606         int index = iter().get_constant_pool_index();
2607         constantTag tag = iter().get_constant_pool_tag(index);
2608         uncommon_trap(Deoptimization::make_trap_request
2609                       (Deoptimization::Reason_unloaded,
2610                        Deoptimization::Action_reinterpret,
2611                        index),
2612                       NULL, tag.internal_name());
2613         break;
2614       }
2615       assert(constant.basic_type() != T_OBJECT || constant.as_object()-&gt;is_instance(),
2616              &quot;must be java_mirror of klass&quot;);
2617       const Type* con_type = Type::make_from_constant(constant);
2618       if (con_type != NULL) {
2619         push_node(con_type-&gt;basic_type(), makecon(con_type));
2620       }
2621     }
2622 
2623     break;
2624 
2625   case Bytecodes::_aload_0:
2626     push( local(0) );
2627     break;
2628   case Bytecodes::_aload_1:
2629     push( local(1) );
2630     break;
2631   case Bytecodes::_aload_2:
2632     push( local(2) );
2633     break;
2634   case Bytecodes::_aload_3:
2635     push( local(3) );
2636     break;
2637   case Bytecodes::_aload:
2638     push( local(iter().get_index()) );
2639     break;
2640 
2641   case Bytecodes::_fload_0:
2642   case Bytecodes::_iload_0:
2643     push( local(0) );
2644     break;
2645   case Bytecodes::_fload_1:
2646   case Bytecodes::_iload_1:
2647     push( local(1) );
2648     break;
2649   case Bytecodes::_fload_2:
2650   case Bytecodes::_iload_2:
2651     push( local(2) );
2652     break;
2653   case Bytecodes::_fload_3:
2654   case Bytecodes::_iload_3:
2655     push( local(3) );
2656     break;
2657   case Bytecodes::_fload:
2658   case Bytecodes::_iload:
2659     push( local(iter().get_index()) );
2660     break;
2661   case Bytecodes::_lload_0:
2662     push_pair_local( 0 );
2663     break;
2664   case Bytecodes::_lload_1:
2665     push_pair_local( 1 );
2666     break;
2667   case Bytecodes::_lload_2:
2668     push_pair_local( 2 );
2669     break;
2670   case Bytecodes::_lload_3:
2671     push_pair_local( 3 );
2672     break;
2673   case Bytecodes::_lload:
2674     push_pair_local( iter().get_index() );
2675     break;
2676 
2677   case Bytecodes::_dload_0:
2678     push_pair_local(0);
2679     break;
2680   case Bytecodes::_dload_1:
2681     push_pair_local(1);
2682     break;
2683   case Bytecodes::_dload_2:
2684     push_pair_local(2);
2685     break;
2686   case Bytecodes::_dload_3:
2687     push_pair_local(3);
2688     break;
2689   case Bytecodes::_dload:
2690     push_pair_local(iter().get_index());
2691     break;
2692   case Bytecodes::_fstore_0:
2693   case Bytecodes::_istore_0:
2694   case Bytecodes::_astore_0:
2695     set_local( 0, pop() );
2696     break;
2697   case Bytecodes::_fstore_1:
2698   case Bytecodes::_istore_1:
2699   case Bytecodes::_astore_1:
2700     set_local( 1, pop() );
2701     break;
2702   case Bytecodes::_fstore_2:
2703   case Bytecodes::_istore_2:
2704   case Bytecodes::_astore_2:
2705     set_local( 2, pop() );
2706     break;
2707   case Bytecodes::_fstore_3:
2708   case Bytecodes::_istore_3:
2709   case Bytecodes::_astore_3:
2710     set_local( 3, pop() );
2711     break;
2712   case Bytecodes::_fstore:
2713   case Bytecodes::_istore:
2714   case Bytecodes::_astore:
2715     set_local( iter().get_index(), pop() );
2716     break;
2717   // long stores
2718   case Bytecodes::_lstore_0:
2719     set_pair_local( 0, pop_pair() );
2720     break;
2721   case Bytecodes::_lstore_1:
2722     set_pair_local( 1, pop_pair() );
2723     break;
2724   case Bytecodes::_lstore_2:
2725     set_pair_local( 2, pop_pair() );
2726     break;
2727   case Bytecodes::_lstore_3:
2728     set_pair_local( 3, pop_pair() );
2729     break;
2730   case Bytecodes::_lstore:
2731     set_pair_local( iter().get_index(), pop_pair() );
2732     break;
2733 
2734   // double stores
2735   case Bytecodes::_dstore_0:
2736     set_pair_local( 0, dstore_rounding(pop_pair()) );
2737     break;
2738   case Bytecodes::_dstore_1:
2739     set_pair_local( 1, dstore_rounding(pop_pair()) );
2740     break;
2741   case Bytecodes::_dstore_2:
2742     set_pair_local( 2, dstore_rounding(pop_pair()) );
2743     break;
2744   case Bytecodes::_dstore_3:
2745     set_pair_local( 3, dstore_rounding(pop_pair()) );
2746     break;
2747   case Bytecodes::_dstore:
2748     set_pair_local( iter().get_index(), dstore_rounding(pop_pair()) );
2749     break;
2750 
2751   case Bytecodes::_pop:  dec_sp(1);   break;
2752   case Bytecodes::_pop2: dec_sp(2);   break;
2753   case Bytecodes::_swap:
2754     a = pop();
2755     b = pop();
2756     push(a);
2757     push(b);
2758     break;
2759   case Bytecodes::_dup:
2760     a = pop();
2761     push(a);
2762     push(a);
2763     break;
2764   case Bytecodes::_dup_x1:
2765     a = pop();
2766     b = pop();
2767     push( a );
2768     push( b );
2769     push( a );
2770     break;
2771   case Bytecodes::_dup_x2:
2772     a = pop();
2773     b = pop();
2774     c = pop();
2775     push( a );
2776     push( c );
2777     push( b );
2778     push( a );
2779     break;
2780   case Bytecodes::_dup2:
2781     a = pop();
2782     b = pop();
2783     push( b );
2784     push( a );
2785     push( b );
2786     push( a );
2787     break;
2788 
2789   case Bytecodes::_dup2_x1:
2790     // before: .. c, b, a
2791     // after:  .. b, a, c, b, a
2792     // not tested
2793     a = pop();
2794     b = pop();
2795     c = pop();
2796     push( b );
2797     push( a );
2798     push( c );
2799     push( b );
2800     push( a );
2801     break;
2802   case Bytecodes::_dup2_x2:
2803     // before: .. d, c, b, a
2804     // after:  .. b, a, d, c, b, a
2805     // not tested
2806     a = pop();
2807     b = pop();
2808     c = pop();
2809     d = pop();
2810     push( b );
2811     push( a );
2812     push( d );
2813     push( c );
2814     push( b );
2815     push( a );
2816     break;
2817 
2818   case Bytecodes::_arraylength: {
2819     // Must do null-check with value on expression stack
2820     Node *ary = null_check(peek(), T_ARRAY);
2821     // Compile-time detect of null-exception?
2822     if (stopped())  return;
2823     a = pop();
2824     push(load_array_length(a));
2825     break;
2826   }
2827 
2828   case Bytecodes::_baload:  array_load(T_BYTE);    break;
2829   case Bytecodes::_caload:  array_load(T_CHAR);    break;
2830   case Bytecodes::_iaload:  array_load(T_INT);     break;
2831   case Bytecodes::_saload:  array_load(T_SHORT);   break;
2832   case Bytecodes::_faload:  array_load(T_FLOAT);   break;
2833   case Bytecodes::_aaload:  array_load(T_OBJECT);  break;
2834   case Bytecodes::_laload:  array_load(T_LONG);    break;
2835   case Bytecodes::_daload:  array_load(T_DOUBLE);  break;
2836   case Bytecodes::_bastore: array_store(T_BYTE);   break;
2837   case Bytecodes::_castore: array_store(T_CHAR);   break;
2838   case Bytecodes::_iastore: array_store(T_INT);    break;
2839   case Bytecodes::_sastore: array_store(T_SHORT);  break;
2840   case Bytecodes::_fastore: array_store(T_FLOAT);  break;
2841   case Bytecodes::_aastore: array_store(T_OBJECT); break;
2842   case Bytecodes::_lastore: array_store(T_LONG);   break;
2843   case Bytecodes::_dastore: array_store(T_DOUBLE); break;
2844 
2845   case Bytecodes::_getfield:
2846     do_getfield();
2847     break;
2848 
2849   case Bytecodes::_getstatic:
2850     do_getstatic();
2851     break;
2852 
2853   case Bytecodes::_putfield:
2854     do_putfield();
2855     break;
2856 
2857   case Bytecodes::_putstatic:
2858     do_putstatic();
2859     break;
2860 
2861   case Bytecodes::_irem:
2862     do_irem();
2863     break;
2864   case Bytecodes::_idiv:
2865     // Must keep both values on the expression-stack during null-check
2866     zero_check_int(peek());
2867     // Compile-time detect of null-exception?
2868     if (stopped())  return;
2869     b = pop();
2870     a = pop();
2871     push( _gvn.transform( new DivINode(control(),a,b) ) );
2872     break;
2873   case Bytecodes::_imul:
2874     b = pop(); a = pop();
2875     push( _gvn.transform( new MulINode(a,b) ) );
2876     break;
2877   case Bytecodes::_iadd:
2878     b = pop(); a = pop();
2879     push( _gvn.transform( new AddINode(a,b) ) );
2880     break;
2881   case Bytecodes::_ineg:
2882     a = pop();
2883     push( _gvn.transform( new SubINode(_gvn.intcon(0),a)) );
2884     break;
2885   case Bytecodes::_isub:
2886     b = pop(); a = pop();
2887     push( _gvn.transform( new SubINode(a,b) ) );
2888     break;
2889   case Bytecodes::_iand:
2890     b = pop(); a = pop();
2891     push( _gvn.transform( new AndINode(a,b) ) );
2892     break;
2893   case Bytecodes::_ior:
2894     b = pop(); a = pop();
2895     push( _gvn.transform( new OrINode(a,b) ) );
2896     break;
2897   case Bytecodes::_ixor:
2898     b = pop(); a = pop();
2899     push( _gvn.transform( new XorINode(a,b) ) );
2900     break;
2901   case Bytecodes::_ishl:
2902     b = pop(); a = pop();
2903     push( _gvn.transform( new LShiftINode(a,b) ) );
2904     break;
2905   case Bytecodes::_ishr:
2906     b = pop(); a = pop();
2907     push( _gvn.transform( new RShiftINode(a,b) ) );
2908     break;
2909   case Bytecodes::_iushr:
2910     b = pop(); a = pop();
2911     push( _gvn.transform( new URShiftINode(a,b) ) );
2912     break;
2913 
2914   case Bytecodes::_fneg:
2915     a = pop();
2916     b = _gvn.transform(new NegFNode (a));
2917     push(b);
2918     break;
2919 
2920   case Bytecodes::_fsub:
2921     b = pop();
2922     a = pop();
2923     c = _gvn.transform( new SubFNode(a,b) );
2924     d = precision_rounding(c);
2925     push( d );
2926     break;
2927 
2928   case Bytecodes::_fadd:
2929     b = pop();
2930     a = pop();
2931     c = _gvn.transform( new AddFNode(a,b) );
2932     d = precision_rounding(c);
2933     push( d );
2934     break;
2935 
2936   case Bytecodes::_fmul:
2937     b = pop();
2938     a = pop();
2939     c = _gvn.transform( new MulFNode(a,b) );
2940     d = precision_rounding(c);
2941     push( d );
2942     break;
2943 
2944   case Bytecodes::_fdiv:
2945     b = pop();
2946     a = pop();
2947     c = _gvn.transform( new DivFNode(0,a,b) );
2948     d = precision_rounding(c);
2949     push( d );
2950     break;
2951 
2952   case Bytecodes::_frem:
2953     if (Matcher::has_match_rule(Op_ModF)) {
2954       // Generate a ModF node.
2955       b = pop();
2956       a = pop();
2957       c = _gvn.transform( new ModFNode(0,a,b) );
2958       d = precision_rounding(c);
2959       push( d );
2960     }
2961     else {
2962       // Generate a call.
2963       modf();
2964     }
2965     break;
2966 
2967   case Bytecodes::_fcmpl:
2968     b = pop();
2969     a = pop();
2970     c = _gvn.transform( new CmpF3Node( a, b));
2971     push(c);
2972     break;
2973   case Bytecodes::_fcmpg:
2974     b = pop();
2975     a = pop();
2976 
2977     // Same as fcmpl but need to flip the unordered case.  Swap the inputs,
2978     // which negates the result sign except for unordered.  Flip the unordered
2979     // as well by using CmpF3 which implements unordered-lesser instead of
2980     // unordered-greater semantics.  Finally, commute the result bits.  Result
2981     // is same as using a CmpF3Greater except we did it with CmpF3 alone.
2982     c = _gvn.transform( new CmpF3Node( b, a));
2983     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
2984     push(c);
2985     break;
2986 
2987   case Bytecodes::_f2i:
2988     a = pop();
2989     push(_gvn.transform(new ConvF2INode(a)));
2990     break;
2991 
2992   case Bytecodes::_d2i:
2993     a = pop_pair();
2994     b = _gvn.transform(new ConvD2INode(a));
2995     push( b );
2996     break;
2997 
2998   case Bytecodes::_f2d:
2999     a = pop();
3000     b = _gvn.transform( new ConvF2DNode(a));
3001     push_pair( b );
3002     break;
3003 
3004   case Bytecodes::_d2f:
3005     a = pop_pair();
3006     b = _gvn.transform( new ConvD2FNode(a));
3007     // This breaks _227_mtrt (speed &amp; correctness) and _222_mpegaudio (speed)
3008     //b = _gvn.transform(new RoundFloatNode(0, b) );
3009     push( b );
3010     break;
3011 
3012   case Bytecodes::_l2f:
3013     if (Matcher::convL2FSupported()) {
3014       a = pop_pair();
3015       b = _gvn.transform( new ConvL2FNode(a));
3016       // For i486.ad, FILD doesn&#39;t restrict precision to 24 or 53 bits.
3017       // Rather than storing the result into an FP register then pushing
3018       // out to memory to round, the machine instruction that implements
3019       // ConvL2D is responsible for rounding.
3020       // c = precision_rounding(b);
3021       c = _gvn.transform(b);
3022       push(c);
3023     } else {
3024       l2f();
3025     }
3026     break;
3027 
3028   case Bytecodes::_l2d:
3029     a = pop_pair();
3030     b = _gvn.transform( new ConvL2DNode(a));
3031     // For i486.ad, rounding is always necessary (see _l2f above).
3032     // c = dprecision_rounding(b);
3033     c = _gvn.transform(b);
3034     push_pair(c);
3035     break;
3036 
3037   case Bytecodes::_f2l:
3038     a = pop();
3039     b = _gvn.transform( new ConvF2LNode(a));
3040     push_pair(b);
3041     break;
3042 
3043   case Bytecodes::_d2l:
3044     a = pop_pair();
3045     b = _gvn.transform( new ConvD2LNode(a));
3046     push_pair(b);
3047     break;
3048 
3049   case Bytecodes::_dsub:
3050     b = pop_pair();
3051     a = pop_pair();
3052     c = _gvn.transform( new SubDNode(a,b) );
3053     d = dprecision_rounding(c);
3054     push_pair( d );
3055     break;
3056 
3057   case Bytecodes::_dadd:
3058     b = pop_pair();
3059     a = pop_pair();
3060     c = _gvn.transform( new AddDNode(a,b) );
3061     d = dprecision_rounding(c);
3062     push_pair( d );
3063     break;
3064 
3065   case Bytecodes::_dmul:
3066     b = pop_pair();
3067     a = pop_pair();
3068     c = _gvn.transform( new MulDNode(a,b) );
3069     d = dprecision_rounding(c);
3070     push_pair( d );
3071     break;
3072 
3073   case Bytecodes::_ddiv:
3074     b = pop_pair();
3075     a = pop_pair();
3076     c = _gvn.transform( new DivDNode(0,a,b) );
3077     d = dprecision_rounding(c);
3078     push_pair( d );
3079     break;
3080 
3081   case Bytecodes::_dneg:
3082     a = pop_pair();
3083     b = _gvn.transform(new NegDNode (a));
3084     push_pair(b);
3085     break;
3086 
3087   case Bytecodes::_drem:
3088     if (Matcher::has_match_rule(Op_ModD)) {
3089       // Generate a ModD node.
3090       b = pop_pair();
3091       a = pop_pair();
3092       // a % b
3093 
3094       c = _gvn.transform( new ModDNode(0,a,b) );
3095       d = dprecision_rounding(c);
3096       push_pair( d );
3097     }
3098     else {
3099       // Generate a call.
3100       modd();
3101     }
3102     break;
3103 
3104   case Bytecodes::_dcmpl:
3105     b = pop_pair();
3106     a = pop_pair();
3107     c = _gvn.transform( new CmpD3Node( a, b));
3108     push(c);
3109     break;
3110 
3111   case Bytecodes::_dcmpg:
3112     b = pop_pair();
3113     a = pop_pair();
3114     // Same as dcmpl but need to flip the unordered case.
3115     // Commute the inputs, which negates the result sign except for unordered.
3116     // Flip the unordered as well by using CmpD3 which implements
3117     // unordered-lesser instead of unordered-greater semantics.
3118     // Finally, negate the result bits.  Result is same as using a
3119     // CmpD3Greater except we did it with CmpD3 alone.
3120     c = _gvn.transform( new CmpD3Node( b, a));
3121     c = _gvn.transform( new SubINode(_gvn.intcon(0),c) );
3122     push(c);
3123     break;
3124 
3125 
3126     // Note for longs -&gt; lo word is on TOS, hi word is on TOS - 1
3127   case Bytecodes::_land:
3128     b = pop_pair();
3129     a = pop_pair();
3130     c = _gvn.transform( new AndLNode(a,b) );
3131     push_pair(c);
3132     break;
3133   case Bytecodes::_lor:
3134     b = pop_pair();
3135     a = pop_pair();
3136     c = _gvn.transform( new OrLNode(a,b) );
3137     push_pair(c);
3138     break;
3139   case Bytecodes::_lxor:
3140     b = pop_pair();
3141     a = pop_pair();
3142     c = _gvn.transform( new XorLNode(a,b) );
3143     push_pair(c);
3144     break;
3145 
3146   case Bytecodes::_lshl:
3147     b = pop();                  // the shift count
3148     a = pop_pair();             // value to be shifted
3149     c = _gvn.transform( new LShiftLNode(a,b) );
3150     push_pair(c);
3151     break;
3152   case Bytecodes::_lshr:
3153     b = pop();                  // the shift count
3154     a = pop_pair();             // value to be shifted
3155     c = _gvn.transform( new RShiftLNode(a,b) );
3156     push_pair(c);
3157     break;
3158   case Bytecodes::_lushr:
3159     b = pop();                  // the shift count
3160     a = pop_pair();             // value to be shifted
3161     c = _gvn.transform( new URShiftLNode(a,b) );
3162     push_pair(c);
3163     break;
3164   case Bytecodes::_lmul:
3165     b = pop_pair();
3166     a = pop_pair();
3167     c = _gvn.transform( new MulLNode(a,b) );
3168     push_pair(c);
3169     break;
3170 
3171   case Bytecodes::_lrem:
3172     // Must keep both values on the expression-stack during null-check
3173     assert(peek(0) == top(), &quot;long word order&quot;);
3174     zero_check_long(peek(1));
3175     // Compile-time detect of null-exception?
3176     if (stopped())  return;
3177     b = pop_pair();
3178     a = pop_pair();
3179     c = _gvn.transform( new ModLNode(control(),a,b) );
3180     push_pair(c);
3181     break;
3182 
3183   case Bytecodes::_ldiv:
3184     // Must keep both values on the expression-stack during null-check
3185     assert(peek(0) == top(), &quot;long word order&quot;);
3186     zero_check_long(peek(1));
3187     // Compile-time detect of null-exception?
3188     if (stopped())  return;
3189     b = pop_pair();
3190     a = pop_pair();
3191     c = _gvn.transform( new DivLNode(control(),a,b) );
3192     push_pair(c);
3193     break;
3194 
3195   case Bytecodes::_ladd:
3196     b = pop_pair();
3197     a = pop_pair();
3198     c = _gvn.transform( new AddLNode(a,b) );
3199     push_pair(c);
3200     break;
3201   case Bytecodes::_lsub:
3202     b = pop_pair();
3203     a = pop_pair();
3204     c = _gvn.transform( new SubLNode(a,b) );
3205     push_pair(c);
3206     break;
3207   case Bytecodes::_lcmp:
3208     // Safepoints are now inserted _before_ branches.  The long-compare
3209     // bytecode painfully produces a 3-way value (-1,0,+1) which requires a
3210     // slew of control flow.  These are usually followed by a CmpI vs zero and
3211     // a branch; this pattern then optimizes to the obvious long-compare and
3212     // branch.  However, if the branch is backwards there&#39;s a Safepoint
3213     // inserted.  The inserted Safepoint captures the JVM state at the
3214     // pre-branch point, i.e. it captures the 3-way value.  Thus if a
3215     // long-compare is used to control a loop the debug info will force
3216     // computation of the 3-way value, even though the generated code uses a
3217     // long-compare and branch.  We try to rectify the situation by inserting
3218     // a SafePoint here and have it dominate and kill the safepoint added at a
3219     // following backwards branch.  At this point the JVM state merely holds 2
3220     // longs but not the 3-way value.
3221     if( UseLoopSafepoints ) {
3222       switch( iter().next_bc() ) {
3223       case Bytecodes::_ifgt:
3224       case Bytecodes::_iflt:
3225       case Bytecodes::_ifge:
3226       case Bytecodes::_ifle:
3227       case Bytecodes::_ifne:
3228       case Bytecodes::_ifeq:
3229         // If this is a backwards branch in the bytecodes, add Safepoint
3230         maybe_add_safepoint(iter().next_get_dest());
3231       default:
3232         break;
3233       }
3234     }
3235     b = pop_pair();
3236     a = pop_pair();
3237     c = _gvn.transform( new CmpL3Node( a, b ));
3238     push(c);
3239     break;
3240 
3241   case Bytecodes::_lneg:
3242     a = pop_pair();
3243     b = _gvn.transform( new SubLNode(longcon(0),a));
3244     push_pair(b);
3245     break;
3246   case Bytecodes::_l2i:
3247     a = pop_pair();
3248     push( _gvn.transform( new ConvL2INode(a)));
3249     break;
3250   case Bytecodes::_i2l:
3251     a = pop();
3252     b = _gvn.transform( new ConvI2LNode(a));
3253     push_pair(b);
3254     break;
3255   case Bytecodes::_i2b:
3256     // Sign extend
3257     a = pop();
3258     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(24)) );
3259     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(24)) );
3260     push( a );
3261     break;
3262   case Bytecodes::_i2s:
3263     a = pop();
3264     a = _gvn.transform( new LShiftINode(a,_gvn.intcon(16)) );
3265     a = _gvn.transform( new RShiftINode(a,_gvn.intcon(16)) );
3266     push( a );
3267     break;
3268   case Bytecodes::_i2c:
3269     a = pop();
3270     push( _gvn.transform( new AndINode(a,_gvn.intcon(0xFFFF)) ) );
3271     break;
3272 
3273   case Bytecodes::_i2f:
3274     a = pop();
3275     b = _gvn.transform( new ConvI2FNode(a) ) ;
3276     c = precision_rounding(b);
3277     push (b);
3278     break;
3279 
3280   case Bytecodes::_i2d:
3281     a = pop();
3282     b = _gvn.transform( new ConvI2DNode(a));
3283     push_pair(b);
3284     break;
3285 
3286   case Bytecodes::_iinc:        // Increment local
3287     i = iter().get_index();     // Get local index
3288     set_local( i, _gvn.transform( new AddINode( _gvn.intcon(iter().get_iinc_con()), local(i) ) ) );
3289     break;
3290 
3291   // Exit points of synchronized methods must have an unlock node
3292   case Bytecodes::_return:
3293     return_current(NULL);
3294     break;
3295 
3296   case Bytecodes::_ireturn:
3297   case Bytecodes::_areturn:
3298   case Bytecodes::_freturn:
3299     return_current(pop());
3300     break;
3301   case Bytecodes::_lreturn:
3302     return_current(pop_pair());
3303     break;
3304   case Bytecodes::_dreturn:
3305     return_current(pop_pair());
3306     break;
3307 
3308   case Bytecodes::_athrow:
3309     // null exception oop throws NULL pointer exception
3310     null_check(peek());
3311     if (stopped())  return;
3312     // Hook the thrown exception directly to subsequent handlers.
3313     if (BailoutToInterpreterForThrows) {
3314       // Keep method interpreted from now on.
3315       uncommon_trap(Deoptimization::Reason_unhandled,
3316                     Deoptimization::Action_make_not_compilable);
3317       return;
3318     }
3319     if (env()-&gt;jvmti_can_post_on_exceptions()) {
3320       // check if we must post exception events, take uncommon trap if so (with must_throw = false)
3321       uncommon_trap_if_should_post_on_exceptions(Deoptimization::Reason_unhandled, false);
3322     }
3323     // Here if either can_post_on_exceptions or should_post_on_exceptions is false
3324     add_exception_state(make_exception_state(peek()));
3325     break;
3326 
3327   case Bytecodes::_goto:   // fall through
3328   case Bytecodes::_goto_w: {
3329     int target_bci = (bc() == Bytecodes::_goto) ? iter().get_dest() : iter().get_far_dest();
3330 
3331     // If this is a backwards branch in the bytecodes, add Safepoint
3332     maybe_add_safepoint(target_bci);
3333 
3334     // Update method data
3335     profile_taken_branch(target_bci);
3336 
3337     // Merge the current control into the target basic block
3338     merge(target_bci);
3339 
3340     // See if we can get some profile data and hand it off to the next block
3341     Block *target_block = block()-&gt;successor_for_bci(target_bci);
3342     if (target_block-&gt;pred_count() != 1)  break;
3343     ciMethodData* methodData = method()-&gt;method_data();
3344     if (!methodData-&gt;is_mature())  break;
3345     ciProfileData* data = methodData-&gt;bci_to_data(bci());
3346     assert(data != NULL &amp;&amp; data-&gt;is_JumpData(), &quot;need JumpData for taken branch&quot;);
3347     int taken = ((ciJumpData*)data)-&gt;taken();
3348     taken = method()-&gt;scale_count(taken);
3349     target_block-&gt;set_count(taken);
3350     break;
3351   }
3352 
3353   case Bytecodes::_ifnull:    btest = BoolTest::eq; goto handle_if_null;
3354   case Bytecodes::_ifnonnull: btest = BoolTest::ne; goto handle_if_null;
3355   handle_if_null:
3356     // If this is a backwards branch in the bytecodes, add Safepoint
3357     maybe_add_safepoint(iter().get_dest());
3358     a = null();
3359     b = pop();
3360     if (b-&gt;is_ValueType()) {
3361       // Return constant false because &#39;b&#39; is always non-null
3362       c = _gvn.makecon(TypeInt::CC_GT);
3363     } else {
3364       if (!_gvn.type(b)-&gt;speculative_maybe_null() &amp;&amp;
3365           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
3366         inc_sp(1);
3367         Node* null_ctl = top();
3368         b = null_check_oop(b, &amp;null_ctl, true, true, true);
3369         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
3370         dec_sp(1);
3371       } else if (_gvn.type(b)-&gt;speculative_always_null() &amp;&amp;
3372                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
3373         inc_sp(1);
3374         b = null_assert(b);
3375         dec_sp(1);
3376       }
3377       c = _gvn.transform( new CmpPNode(b, a) );
3378     }
3379     do_ifnull(btest, c);
3380     break;
3381 
3382   case Bytecodes::_if_acmpeq: btest = BoolTest::eq; goto handle_if_acmp;
3383   case Bytecodes::_if_acmpne: btest = BoolTest::ne; goto handle_if_acmp;
3384   handle_if_acmp:
3385     // If this is a backwards branch in the bytecodes, add Safepoint
3386     maybe_add_safepoint(iter().get_dest());
3387     a = pop();
3388     b = pop();
3389     do_acmp(btest, a, b);
3390     break;
3391 
3392   case Bytecodes::_ifeq: btest = BoolTest::eq; goto handle_ifxx;
3393   case Bytecodes::_ifne: btest = BoolTest::ne; goto handle_ifxx;
3394   case Bytecodes::_iflt: btest = BoolTest::lt; goto handle_ifxx;
3395   case Bytecodes::_ifle: btest = BoolTest::le; goto handle_ifxx;
3396   case Bytecodes::_ifgt: btest = BoolTest::gt; goto handle_ifxx;
3397   case Bytecodes::_ifge: btest = BoolTest::ge; goto handle_ifxx;
3398   handle_ifxx:
3399     // If this is a backwards branch in the bytecodes, add Safepoint
3400     maybe_add_safepoint(iter().get_dest());
3401     a = _gvn.intcon(0);
3402     b = pop();
3403     c = _gvn.transform( new CmpINode(b, a) );
3404     do_if(btest, c);
3405     break;
3406 
3407   case Bytecodes::_if_icmpeq: btest = BoolTest::eq; goto handle_if_icmp;
3408   case Bytecodes::_if_icmpne: btest = BoolTest::ne; goto handle_if_icmp;
3409   case Bytecodes::_if_icmplt: btest = BoolTest::lt; goto handle_if_icmp;
3410   case Bytecodes::_if_icmple: btest = BoolTest::le; goto handle_if_icmp;
3411   case Bytecodes::_if_icmpgt: btest = BoolTest::gt; goto handle_if_icmp;
3412   case Bytecodes::_if_icmpge: btest = BoolTest::ge; goto handle_if_icmp;
3413   handle_if_icmp:
3414     // If this is a backwards branch in the bytecodes, add Safepoint
3415     maybe_add_safepoint(iter().get_dest());
3416     a = pop();
3417     b = pop();
3418     c = _gvn.transform( new CmpINode( b, a ) );
3419     do_if(btest, c);
3420     break;
3421 
3422   case Bytecodes::_tableswitch:
3423     do_tableswitch();
3424     break;
3425 
3426   case Bytecodes::_lookupswitch:
3427     do_lookupswitch();
3428     break;
3429 
3430   case Bytecodes::_invokestatic:
3431   case Bytecodes::_invokedynamic:
3432   case Bytecodes::_invokespecial:
3433   case Bytecodes::_invokevirtual:
3434   case Bytecodes::_invokeinterface:
3435     do_call();
3436     break;
3437   case Bytecodes::_checkcast:
3438     do_checkcast();
3439     break;
3440   case Bytecodes::_instanceof:
3441     do_instanceof();
3442     break;
3443   case Bytecodes::_anewarray:
3444     do_newarray();
3445     break;
3446   case Bytecodes::_newarray:
3447     do_newarray((BasicType)iter().get_index());
3448     break;
3449   case Bytecodes::_multianewarray:
3450     do_multianewarray();
3451     break;
3452   case Bytecodes::_new:
3453     do_new();
3454     break;
3455   case Bytecodes::_defaultvalue:
3456     do_defaultvalue();
3457     break;
3458   case Bytecodes::_withfield:
3459     do_withfield();
3460     break;
3461 
3462   case Bytecodes::_jsr:
3463   case Bytecodes::_jsr_w:
3464     do_jsr();
3465     break;
3466 
3467   case Bytecodes::_ret:
3468     do_ret();
3469     break;
3470 
3471 
3472   case Bytecodes::_monitorenter:
3473     do_monitor_enter();
3474     break;
3475 
3476   case Bytecodes::_monitorexit:
3477     do_monitor_exit();
3478     break;
3479 
3480   case Bytecodes::_breakpoint:
3481     // Breakpoint set concurrently to compile
3482     // %%% use an uncommon trap?
3483     C-&gt;record_failure(&quot;breakpoint in method&quot;);
3484     return;
3485 
3486   default:
3487 #ifndef PRODUCT
3488     map()-&gt;dump(99);
3489 #endif
3490     tty-&gt;print(&quot;\nUnhandled bytecode %s\n&quot;, Bytecodes::name(bc()) );
3491     ShouldNotReachHere();
3492   }
3493 
3494 #ifndef PRODUCT
3495   IdealGraphPrinter *printer = C-&gt;printer();
3496   if (printer &amp;&amp; printer-&gt;should_print(1)) {
3497     char buffer[256];
3498     jio_snprintf(buffer, sizeof(buffer), &quot;Bytecode %d: %s&quot;, bci(), Bytecodes::name(bc()));
3499     bool old = printer-&gt;traverse_outs();
3500     printer-&gt;set_traverse_outs(true);
3501     printer-&gt;print_method(buffer, 4);
3502     printer-&gt;set_traverse_outs(old);
3503   }
3504 #endif
3505 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
diff a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp
@@ -1401,18 +1401,12 @@
     }
   } else if (type == T_ADDRESS && addr->disp() == oopDesc::klass_offset_in_bytes()) {
     // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore
 #ifdef _LP64
     if (UseCompressedClassPointers) {
-      __ andl(dest->as_register(), oopDesc::compressed_klass_mask());
       __ decode_klass_not_null(dest->as_register());
-    } else {
-      __ shlq(dest->as_register(), oopDesc::storage_props_nof_bits);
-      __ shrq(dest->as_register(), oopDesc::storage_props_nof_bits);
     }
-#else
-    __ andl(dest->as_register(), oopDesc::wide_klass_mask());
 #endif
   }
 }
 
 
diff a/src/hotspot/cpu/x86/macroAssembler_x86.cpp b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/macroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
@@ -4615,25 +4615,17 @@
   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
 }
 
 void MacroAssembler::load_klass(Register dst, Register src) {
-  load_metadata(dst, src);
 #ifdef _LP64
   if (UseCompressedClassPointers) {
-    andl(dst, oopDesc::compressed_klass_mask());
+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
     decode_klass_not_null(dst);
   } else
 #endif
-  {
-#ifdef _LP64
-    shlq(dst, oopDesc::storage_props_nof_bits);
-    shrq(dst, oopDesc::storage_props_nof_bits);
-#else
-    andl(dst, oopDesc::wide_klass_mask());
-#endif
-  }
+  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
 }
 
 void MacroAssembler::load_prototype_header(Register dst, Register src) {
   load_klass(dst, src);
   movptr(dst, Address(dst, Klass::prototype_header_offset()));
diff a/src/hotspot/share/gc/shared/memAllocator.cpp b/src/hotspot/share/gc/shared/memAllocator.cpp
--- a/src/hotspot/share/gc/shared/memAllocator.cpp
+++ b/src/hotspot/share/gc/shared/memAllocator.cpp
@@ -388,16 +388,10 @@
   // concurrent collectors.
   oopDesc::release_set_klass(mem, _klass);
   return oop(mem);
 }
 
-oop MemAllocator::finish_with_properties(HeapWord* mem, ArrayStorageProperties storage_props) const {
-  oop res = finish(mem); // finish() returns on purpose (can be overloaded, clearing memory might safepoint)
-  oopDesc::release_set_metadata(cast_from_oop<HeapWord*>(res), storage_props, _klass);
-  return res;
-}
-
 oop ObjAllocator::initialize(HeapWord* mem) const {
   mem_clear(mem);
   return finish(mem);
 }
 
@@ -423,13 +417,11 @@
   assert(_length >= 0, "length should be non-negative");
   if (_do_zero) {
     mem_clear(mem);
   }
   arrayOopDesc::set_length(mem, _length);
-  assert(ArrayKlass::cast(_klass)->storage_properties().is_empty() ||
-      ArrayKlass::cast(_klass)->dimension() == 1, "Multidim should have no storage props");
-  return finish_with_properties(mem, ArrayKlass::cast(_klass)->storage_properties());
+  return finish(mem);
 }
 
 oop ClassAllocator::initialize(HeapWord* mem) const {
   // Set oop_size field before setting the _klass field because a
   // non-NULL _klass field indicates that the object is parsable by
diff a/src/hotspot/share/gc/shared/memAllocator.hpp b/src/hotspot/share/gc/shared/memAllocator.hpp
--- a/src/hotspot/share/gc/shared/memAllocator.hpp
+++ b/src/hotspot/share/gc/shared/memAllocator.hpp
@@ -58,12 +58,10 @@
   void mem_clear(HeapWord* mem) const;
   // This finish constructing an oop by installing the mark word and the Klass* pointer
   // last. At the point when the Klass pointer is initialized, this is a constructed object
   // that must be parseable as an oop by concurrent collectors.
   virtual oop finish(HeapWord* mem) const;
-  // Encode any extra metadata properties for arrays
-  oop finish_with_properties(HeapWord* mem, ArrayStorageProperties storage_props) const;
 
   // Raw memory allocation. This will try to do a TLAB allocation, and otherwise fall
   // back to calling CollectedHeap::mem_allocate().
   HeapWord* mem_allocate(Allocation& allocation) const;
 
diff a/src/hotspot/share/memory/metaspace.cpp b/src/hotspot/share/memory/metaspace.cpp
--- a/src/hotspot/share/memory/metaspace.cpp
+++ b/src/hotspot/share/memory/metaspace.cpp
@@ -971,11 +971,11 @@
 bool Metaspace::_initialized = false;
 
 #define VIRTUALSPACEMULTIPLIER 2
 
 #ifdef _LP64
-static uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
+static const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 
 void Metaspace::set_narrow_klass_base_and_shift(ReservedSpace metaspace_rs, address cds_base) {
   assert(!DumpSharedSpaces, "narrow_klass is set by MetaspaceShared class.");
   // Figure out the narrow_klass_base and the narrow_klass_shift.  The
   // narrow_klass_base is the lower of the metaspace base and the cds base
@@ -985,12 +985,12 @@
   address higher_address = (address)metaspace_rs.end();
   if (cds_base != NULL) {
     assert(UseSharedSpaces, "must be");
     lower_base = MIN2(lower_base, cds_base);
   } else {
+    uint64_t klass_encoding_max = UnscaledClassSpaceMax << LogKlassAlignmentInBytes;
     // Using oopDesc::_metadata high bits so LogKlassAlignmentInBytes shift is no longer possible
-    uint64_t klass_encoding_max = UnscaledClassSpaceMax;
     // If compressed class space fits in lower 32G, we don't need a base.
     if (higher_address <= (address)klass_encoding_max) {
       lower_base = 0; // Effectively lower base is zero.
     }
   }
@@ -1228,15 +1228,10 @@
 }
 
 void Metaspace::global_initialize() {
   MetaspaceGC::initialize();
   bool class_space_inited = false;
-#ifdef _LP64
-  if (EnableValhalla) {
-    UnscaledClassSpaceMax >>= oopDesc::storage_props_nof_bits;
-  }
-#endif
 #if INCLUDE_CDS
   if (DumpSharedSpaces) {
     MetaspaceShared::initialize_dumptime_shared_and_meta_spaces();
     class_space_inited = true;
   } else if (UseSharedSpaces) {
diff a/src/hotspot/share/memory/oopFactory.cpp b/src/hotspot/share/memory/oopFactory.cpp
--- a/src/hotspot/share/memory/oopFactory.cpp
+++ b/src/hotspot/share/memory/oopFactory.cpp
@@ -143,11 +143,11 @@
   if (array_klass->is_valueArray_klass()) {
     oop = (arrayOop) ValueArrayKlass::cast(array_klass)->allocate(length, THREAD);
   } else {
     oop = (arrayOop) ObjArrayKlass::cast(array_klass)->allocate(length, THREAD);
   }
-  assert(oop == NULL || oop->array_storage_properties().is_null_free(), "Bad array storage encoding");
+  assert(oop == NULL || oop->klass()->is_null_free_array_klass(), "Bad array storage encoding");
   return oop;
 }
 
 objArrayHandle oopFactory::copy_valueArray_to_objArray(valueArrayHandle array, TRAPS) {
   int len = array->length();
diff a/src/hotspot/share/oops/arrayKlass.hpp b/src/hotspot/share/oops/arrayKlass.hpp
--- a/src/hotspot/share/oops/arrayKlass.hpp
+++ b/src/hotspot/share/oops/arrayKlass.hpp
@@ -24,11 +24,10 @@
 
 #ifndef SHARE_OOPS_ARRAYKLASS_HPP
 #define SHARE_OOPS_ARRAYKLASS_HPP
 
 #include "oops/klass.hpp"
-#include "oops/arrayStorageProperties.hpp"
 
 class fieldDescriptor;
 class klassVtable;
 
 // ArrayKlass is the abstract baseclass for all array classes
@@ -65,13 +64,10 @@
   virtual void set_element_klass(Klass* k)  { _element_klass = k; }
 
   // Compiler/Interpreter offset
   static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ArrayKlass, _element_klass)); }
 
-  // Presented with an ArrayKlass, which storage_properties should be encoded into arrayOop
-  virtual ArrayStorageProperties storage_properties() { return ArrayStorageProperties::empty; }
-
   // Are loads and stores to this concrete array type atomic?
   // Note that Object[] is naturally atomic, but its subtypes may not be.
   virtual bool element_access_is_atomic() { return true; }
 
   // Testing operation
diff a/src/hotspot/share/oops/arrayStorageProperties.cpp b/src/hotspot/share/oops/arrayStorageProperties.cpp
--- a/src/hotspot/share/oops/arrayStorageProperties.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#include "precompiled.hpp"
-#include "oops/arrayStorageProperties.hpp"
-#include "oops/oop.hpp"
-#include "utilities/debug.hpp"
-
-STATIC_ASSERT((int)ArrayStorageProperties::nof_oop_properties <= (int)oopDesc::storage_props_nof_bits);
-
-const ArrayStorageProperties ArrayStorageProperties::empty     = ArrayStorageProperties(empty_value);
-const ArrayStorageProperties ArrayStorageProperties::null_free = ArrayStorageProperties(null_free_value);
-const ArrayStorageProperties ArrayStorageProperties::flattened_and_null_free =
-        ArrayStorageProperties(flattened_value | null_free_value);
-
diff a/src/hotspot/share/oops/arrayStorageProperties.hpp b/src/hotspot/share/oops/arrayStorageProperties.hpp
--- a/src/hotspot/share/oops/arrayStorageProperties.hpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- *
- */
-
-#ifndef SHARE_OOPS_ARRAYSTORAGEPROPERTIES_HPP
-#define SHARE_OOPS_ARRAYSTORAGEPROPERTIES_HPP
-
-#include "oops/symbol.hpp"
-#include "runtime/globals.hpp"
-
-class ArrayStorageProperties {
- private:
-  uint8_t _flags;
-
-  void clear_flags_bits(uint8_t value) { _flags &= (~value); }
-  void set_flags_bits(uint8_t value) { _flags |= value; }
-  bool test_flags_bit(int idx) const { return (_flags & (1 << idx)) != 0; }
- public:
-
-  enum {
-    empty_value           = 0,
-    flattened_bit         = 0,
-    flattened_value       = 1 <<  flattened_bit,
-    null_free_bit = flattened_bit + 1,
-    null_free_value = 1 << null_free_bit,
-    nof_oop_properties = null_free_bit + 1
-  };
-
-  ArrayStorageProperties() : _flags(empty_value) {};
-  ArrayStorageProperties(uint8_t flags): _flags(flags) {};
-
-  bool is_empty() const { return _flags == empty_value; }
-
-  bool is_flattened() const { return test_flags_bit(flattened_bit); }
-
-  bool is_null_free() const { return test_flags_bit(null_free_bit); }
-
-  uint8_t value() const { return _flags; }
-  template <typename T> T encode(int shift) const { return static_cast<T>(_flags) << shift; }
-
-  // Well-known constants...
-  static const ArrayStorageProperties empty;
-  static const ArrayStorageProperties null_free;
-  static const ArrayStorageProperties flattened_and_null_free;
-
-};
-
-
-#endif //SHARE_OOPS_ARRAYSTORAGEPROPERTIES_HPP
diff a/src/hotspot/share/oops/objArrayKlass.cpp b/src/hotspot/share/oops/objArrayKlass.cpp
--- a/src/hotspot/share/oops/objArrayKlass.cpp
+++ b/src/hotspot/share/oops/objArrayKlass.cpp
@@ -154,11 +154,11 @@
 }
 
 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
   int size = objArrayOopDesc::object_size(length);
-  bool populate_null_free = storage_properties().is_null_free();
+  bool populate_null_free = is_null_free_array_klass();
   objArrayOop array =  (objArrayOop)Universe::heap()->array_allocate(this, size, length,
                                                        /* do_zero */ true, THREAD);
   if (populate_null_free) {
     assert(dimension() == 1, "Can only populate the final dimension");
     assert(element_klass()->is_value(), "Unexpected");
@@ -176,11 +176,11 @@
 }
 
 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
   int length = *sizes;
   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
-    if ((!element_klass()->is_array_klass()) && storage_properties().is_null_free()) {
+    if (element_klass()->is_value()) {
       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
     } else {
       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
     }
   }
@@ -209,14 +209,10 @@
     }
   }
   return h_array();
 }
 
-ArrayStorageProperties ObjArrayKlass::storage_properties() {
-  return name()->is_Q_singledim_array_signature() ? ArrayStorageProperties::null_free : ArrayStorageProperties::empty;
-}
-
 // Either oop or narrowOop depending on UseCompressedOops.
 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
                             arrayOop d, size_t dst_offset, int length, TRAPS) {
   if (s == d) {
     // since source and destination are equal we do not need conversion checks.
diff a/src/hotspot/share/oops/objArrayKlass.hpp b/src/hotspot/share/oops/objArrayKlass.hpp
--- a/src/hotspot/share/oops/objArrayKlass.hpp
+++ b/src/hotspot/share/oops/objArrayKlass.hpp
@@ -48,14 +48,10 @@
   static ObjArrayKlass* allocate(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);
  public:
   // For dummy objects
   ObjArrayKlass() {}
 
-  // if ObjArrayKlass is used to represent an LWorld "Q-type" value type array, the only thing we can give null-free (i.e. not flattened)
-  // ArrayStorageProperties::empty meaning nothing special, array of references (possibly even to value types)
-  ArrayStorageProperties storage_properties();
-
   Klass* bottom_klass() const       { return _bottom_klass; }
   void set_bottom_klass(Klass* k)   { _bottom_klass = k; }
   Klass** bottom_klass_addr()       { return &_bottom_klass; }
 
   ModuleEntry* module() const;
diff a/src/hotspot/share/oops/oop.hpp b/src/hotspot/share/oops/oop.hpp
--- a/src/hotspot/share/oops/oop.hpp
+++ b/src/hotspot/share/oops/oop.hpp
@@ -26,11 +26,10 @@
 #define SHARE_OOPS_OOP_HPP
 
 #include "memory/iterator.hpp"
 #include "memory/memRegion.hpp"
 #include "oops/access.hpp"
-#include "oops/arrayStorageProperties.hpp"
 #include "oops/markWord.hpp"
 #include "oops/metadata.hpp"
 #include "runtime/atomic.hpp"
 #include "utilities/macros.hpp"
 
@@ -41,42 +40,16 @@
 //
 // no virtual functions allowed
 //
 // oopDesc::_mark - the "oop mark word" encoding to be found separately in markWord.hpp
 //
-// oopDesc::_metadata - encodes both the object's klass pointer and potentially
-//                      "storage properties" (currently confined to arrays in the form of
-//                      ArrayStorageProperties). Storage properties are peculiar to the
-//                      *instance*, and not necessarily the "type".
+// oopDesc::_metadata - encodes the object's klass pointer, as a raw pointer in "_klass"
+//                      or compressed pointer in "_compressed_klass"
 //
 // The overall size of the _metadata field is dependent on "UseCompressedClassPointers",
 // hence the terms "narrow" (32 bits) vs "wide" (64 bits).
 //
-// "Wide" encoding of _metadata:
-// bit number          |63             0|
-// bit length          |--3|-----61-----|
-// --------------------------------------
-// _klass              [xxx| Klass*     ]
-// _wide_storage_props [ sp|            ]
-// --------------------------------------
-// with:
-//    xxx = klass_mask(), Klass* = Klass pointer to be masked
-//    sp = storage properties, bit number: wide_storage_props_shift
-//
-// "Narrow" encoding of _metadata:
-// bit number            |31             0|
-// bit length            |--3|-----29-----|
-// ----------------------------------------
-// _compressed_klass     [xxx| narrowKlass]
-// _narrow_storage_props [ sp|            ]
-// ----------------------------------------
-// with:
-//   xxx = compressed_klass_mask(), narrowKlass = compressed Klass pointer to be masked
-//         narrowKlass may be further decoded (Klass::decode_klass()) to produce Klass*
-//   sp = storage properties, bit number: narrow_storage_props_shift
-//
-// Storage properties encodings are current confined to arrayStorageProperties.hpp
 
 
 // Forward declarations.
 class OopClosure;
 class ScanClosure;
@@ -92,12 +65,10 @@
  private:
   volatile markWord _mark;
   union _metadata {
     Klass*      _klass;
     narrowKlass _compressed_klass;
-    uintptr_t   _wide_storage_props;
-    uint32_t   _narrow_storage_props;
   } _metadata;
 
  public:
   inline markWord  mark()          const;
   inline markWord  mark_raw()      const;
@@ -114,21 +85,10 @@
   // Used only to re-initialize the mark word (e.g., of promoted
   // objects during a GC) -- requires a valid klass pointer
   inline void init_mark();
   inline void init_mark_raw();
 
-  enum {
-    storage_props_nof_bits     = LogKlassAlignmentInBytes, // This alignment gives us some "free bits"
-    narrow_storage_props_shift = (sizeof(narrowKlass) << 3) - storage_props_nof_bits,
-    wide_storage_props_shift   = (sizeof(Klass*) << 3) - storage_props_nof_bits
-  };
-
-  static inline narrowKlass compressed_klass_mask();
-  static inline narrowKlass compressed_klass_masked(narrowKlass raw);
-  static inline uintptr_t   klass_mask();
-  static inline Klass*      klass_masked(uintptr_t raw);
-
   inline Klass* klass() const;
   inline Klass* klass_or_null() const volatile;
   inline Klass* klass_or_null_acquire() const volatile;
   static inline Klass** klass_addr(HeapWord* mem);
   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
@@ -136,17 +96,10 @@
   inline narrowKlass* compressed_klass_addr();
 
   inline void set_klass(Klass* k);
   static inline void release_set_klass(HeapWord* mem, Klass* klass);
 
-  // Extra container metadata specific to arrays (encoded into high bits of _metadata)
-  static inline uintptr_t* wide_metadata_addr(HeapWord* mem);
-  inline ArrayStorageProperties array_storage_properties() const;
-  inline void set_metadata(ArrayStorageProperties storage_props, Klass* k);
-  static inline void release_set_metadata(HeapWord* mem, ArrayStorageProperties storage_props, Klass* klass);
-
-
   // For klass field compression
   inline int klass_gap() const;
   inline void set_klass_gap(int z);
   static inline void set_klass_gap(HeapWord* mem, int z);
 
diff a/src/hotspot/share/oops/oop.inline.hpp b/src/hotspot/share/oops/oop.inline.hpp
--- a/src/hotspot/share/oops/oop.inline.hpp
+++ b/src/hotspot/share/oops/oop.inline.hpp
@@ -86,41 +86,34 @@
 
 void oopDesc::init_mark_raw() {
   set_mark_raw(markWord::prototype_for_klass(klass()));
 }
 
-narrowKlass oopDesc::compressed_klass_mask() { return ((narrowKlass) 1 << narrow_storage_props_shift) - 1; }
-uintptr_t   oopDesc::klass_mask()   { return ((uintptr_t) 1 << wide_storage_props_shift) - 1; }
-
-narrowKlass oopDesc::compressed_klass_masked(narrowKlass raw) { return raw & compressed_klass_mask(); }
-Klass*      oopDesc::klass_masked(uintptr_t raw)     { return reinterpret_cast<Klass*>(raw & klass_mask()); }
-
-
 Klass* oopDesc::klass() const {
   if (UseCompressedClassPointers) {
-    return CompressedKlassPointers::decode_not_null(compressed_klass_masked(_metadata._compressed_klass));
+    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);
   } else {
-    return klass_masked(_metadata._wide_storage_props);
+    return _metadata._klass;
   }
 }
 
 Klass* oopDesc::klass_or_null() const volatile {
   if (UseCompressedClassPointers) {
-    return CompressedKlassPointers::decode(compressed_klass_masked(_metadata._compressed_klass));
+    return CompressedKlassPointers::decode(_metadata._compressed_klass);
   } else {
-    return klass_masked(_metadata._wide_storage_props);
+    return _metadata._klass;
   }
 }
 
 Klass* oopDesc::klass_or_null_acquire() const volatile {
   if (UseCompressedClassPointers) {
     // Workaround for non-const load_acquire parameter.
     const volatile narrowKlass* addr = &_metadata._compressed_klass;
     volatile narrowKlass* xaddr = const_cast<volatile narrowKlass*>(addr);
-    return CompressedKlassPointers::decode(compressed_klass_masked(Atomic::load_acquire(xaddr)));
+    return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));
   } else {
-    return klass_masked(Atomic::load_acquire(&_metadata._wide_storage_props));
+    return Atomic::load_acquire(&_metadata._klass);
   }
 }
 
 Klass** oopDesc::klass_addr(HeapWord* mem) {
   // Only used internally and with CMS and will not work with
@@ -128,16 +121,10 @@
   assert(!UseCompressedClassPointers, "only supported with uncompressed klass pointers");
   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
   return (Klass**) (((char*)mem) + in_bytes(offset));
 }
 
-uintptr_t* oopDesc::wide_metadata_addr(HeapWord* mem) {
-  assert(!UseCompressedClassPointers, "only supported with uncompressed klass pointers");
-  ByteSize offset = byte_offset_of(oopDesc, _metadata._wide_storage_props);
-  return (uintptr_t*) (((char*)mem) + in_bytes(offset));
-}
-
 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
   assert(UseCompressedClassPointers, "only called by compressed klass pointers");
   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
 }
@@ -152,12 +139,10 @@
 
 #define CHECK_SET_KLASS(k)                                                \
   do {                                                                    \
     assert(Universe::is_bootstrapping() || k != NULL, "NULL Klass");      \
     assert(Universe::is_bootstrapping() || k->is_klass(), "not a Klass"); \
-    assert(((reinterpret_cast<uintptr_t>(k) & (~ oopDesc::klass_mask())) == 0), \
-      "No room for storage props "); \
   } while (0)
 
 void oopDesc::set_klass(Klass* k) {
   CHECK_SET_KLASS(k);
   if (UseCompressedClassPointers) {
@@ -176,41 +161,12 @@
     Atomic::release_store(klass_addr(mem), klass);
   }
   assert(((oopDesc*)mem)->klass() == klass, "failed oopDesc::klass() encode/decode");
 }
 
-void oopDesc::set_metadata(ArrayStorageProperties storage_props, Klass* klass) {
-  CHECK_SET_KLASS(klass);
-  if (UseCompressedClassPointers) {
-    *compressed_klass_addr() = (CompressedKlassPointers::encode_not_null(klass) | storage_props.encode<narrowKlass>(narrow_storage_props_shift));
-  } else {
-    *wide_metadata_addr((HeapWord*)this) = (reinterpret_cast<uintptr_t>(klass) | storage_props.encode<uintptr_t>(wide_storage_props_shift));
-  }
-}
-
-void oopDesc::release_set_metadata(HeapWord* mem, ArrayStorageProperties storage_props, Klass* klass) {
-  CHECK_SET_KLASS(klass);
-  if (UseCompressedClassPointers) {
-    Atomic::release_store(oopDesc::compressed_klass_addr(mem),
-                               CompressedKlassPointers::encode_not_null(klass) | storage_props.encode<narrowKlass>(narrow_storage_props_shift));
-  } else {
-    Atomic::release_store(oopDesc::wide_metadata_addr(mem),
-                               (reinterpret_cast<uintptr_t>(klass) | storage_props.encode<uintptr_t>(wide_storage_props_shift)));
-  }
-}
 #undef CHECK_SET_KLASS
 
-
-ArrayStorageProperties oopDesc::array_storage_properties() const {
-  if (UseCompressedClassPointers) {
-    return ArrayStorageProperties(_metadata._narrow_storage_props >> narrow_storage_props_shift);
-  } else {
-    return ArrayStorageProperties(_metadata._wide_storage_props >> wide_storage_props_shift);
-  }
-}
-
-
 int oopDesc::klass_gap() const {
   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
 }
 
 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
diff a/src/hotspot/share/oops/valueArrayKlass.hpp b/src/hotspot/share/oops/valueArrayKlass.hpp
--- a/src/hotspot/share/oops/valueArrayKlass.hpp
+++ b/src/hotspot/share/oops/valueArrayKlass.hpp
@@ -52,13 +52,10 @@
 
  public:
 
   ValueArrayKlass() {}
 
-  // Properties of an LWorld (LW2) flattened array
-  ArrayStorageProperties storage_properties() { return ArrayStorageProperties::flattened_and_null_free; }
-
   virtual ValueKlass* element_klass() const;
   virtual void set_element_klass(Klass* k);
 
   // Casting from Klass*
   static ValueArrayKlass* cast(Klass* k) {
diff a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -3385,52 +3385,10 @@
       // Check to see if address types have grounded out somehow.
       const TypeInstPtr *tp = mem->in(MemNode::Address)->bottom_type()->isa_instptr();
       assert( !tp || oop_offset_is_sane(tp), "" );
     }
 #endif
-    // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore
-    if (EnableValhalla &&
-        ((nop == Op_LoadKlass && ((LoadKlassNode*)n)->clear_prop_bits()) ||
-         (nop == Op_LoadNKlass && ((LoadNKlassNode*)n)->clear_prop_bits()))) {
-      const TypeKlassPtr* tk = n->bottom_type()->make_ptr()->is_klassptr();
-      assert(!tk->klass_is_exact(), "should have been folded");
-      assert(n->as_Mem()->adr_type()->offset() == oopDesc::klass_offset_in_bytes(), "unexpected LoadKlass");
-      if (tk->klass()->can_be_value_array_klass()) {
-        // Array load klass needs to filter out property bits
-        uint last = unique();
-        Node* pointer = NULL;
-        if (nop == Op_LoadKlass) {
-          Node* cast = new CastP2XNode(NULL, n);
-          Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
-          masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));
-          pointer = new CastX2PNode(masked);
-          pointer = new CheckCastPPNode(NULL, pointer, n->bottom_type());
-        } else {
-          Node* cast = new CastN2INode(n);
-          Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));
-          pointer = new CastI2NNode(masked, n->bottom_type());
-        }
-        for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {
-          Node* u = n->fast_out(i);
-          if (u->_idx < last) {
-            // If user is a comparison with a klass that can't be a value type
-            // array klass, we don't need to clear the storage property bits.
-            Node* cmp = (u->is_DecodeNKlass() && u->outcnt() == 1) ? u->unique_out() : u;
-            if (cmp->is_Cmp()) {
-              const TypeKlassPtr* kp1 = cmp->in(1)->bottom_type()->make_ptr()->isa_klassptr();
-              const TypeKlassPtr* kp2 = cmp->in(2)->bottom_type()->make_ptr()->isa_klassptr();
-              if ((kp1 != NULL && !kp1->klass()->can_be_value_array_klass()) ||
-                  (kp2 != NULL && !kp2->klass()->can_be_value_array_klass())) {
-                continue;
-              }
-            }
-            int nb = u->replace_edge(n, pointer);
-            --i, imax -= nb;
-          }
-        }
-      }
-    }
     break;
   }
 
   case Op_AddP: {               // Assert sane base pointers
     Node *addp = n->in(AddPNode::Address);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/valueArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3370   case Op_LoadUS:
3371   case Op_LoadI:
3372   case Op_LoadKlass:
3373   case Op_LoadNKlass:
3374   case Op_LoadL:
3375   case Op_LoadL_unaligned:
3376   case Op_LoadPLocked:
3377   case Op_LoadP:
3378   case Op_LoadN:
3379   case Op_LoadRange:
3380   case Op_LoadS: {
3381   handle_mem:
3382 #ifdef ASSERT
3383     if( VerifyOptoOopOffsets ) {
3384       MemNode* mem  = n-&gt;as_Mem();
3385       // Check to see if address types have grounded out somehow.
3386       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3387       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3388     }
3389 #endif
<span class="line-removed">3390     // TODO remove clear_prop_bits bits stuff once the runtime does not set it anymore</span>
<span class="line-removed">3391     if (EnableValhalla &amp;&amp;</span>
<span class="line-removed">3392         ((nop == Op_LoadKlass &amp;&amp; ((LoadKlassNode*)n)-&gt;clear_prop_bits()) ||</span>
<span class="line-removed">3393          (nop == Op_LoadNKlass &amp;&amp; ((LoadNKlassNode*)n)-&gt;clear_prop_bits()))) {</span>
<span class="line-removed">3394       const TypeKlassPtr* tk = n-&gt;bottom_type()-&gt;make_ptr()-&gt;is_klassptr();</span>
<span class="line-removed">3395       assert(!tk-&gt;klass_is_exact(), &quot;should have been folded&quot;);</span>
<span class="line-removed">3396       assert(n-&gt;as_Mem()-&gt;adr_type()-&gt;offset() == oopDesc::klass_offset_in_bytes(), &quot;unexpected LoadKlass&quot;);</span>
<span class="line-removed">3397       if (tk-&gt;klass()-&gt;can_be_value_array_klass()) {</span>
<span class="line-removed">3398         // Array load klass needs to filter out property bits</span>
<span class="line-removed">3399         uint last = unique();</span>
<span class="line-removed">3400         Node* pointer = NULL;</span>
<span class="line-removed">3401         if (nop == Op_LoadKlass) {</span>
<span class="line-removed">3402           Node* cast = new CastP2XNode(NULL, n);</span>
<span class="line-removed">3403           Node* masked = new LShiftXNode(cast, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));</span>
<span class="line-removed">3404           masked = new RShiftXNode(masked, new ConINode(TypeInt::make(oopDesc::storage_props_nof_bits)));</span>
<span class="line-removed">3405           pointer = new CastX2PNode(masked);</span>
<span class="line-removed">3406           pointer = new CheckCastPPNode(NULL, pointer, n-&gt;bottom_type());</span>
<span class="line-removed">3407         } else {</span>
<span class="line-removed">3408           Node* cast = new CastN2INode(n);</span>
<span class="line-removed">3409           Node* masked = new AndINode(cast, new ConINode(TypeInt::make(oopDesc::compressed_klass_mask())));</span>
<span class="line-removed">3410           pointer = new CastI2NNode(masked, n-&gt;bottom_type());</span>
<span class="line-removed">3411         }</span>
<span class="line-removed">3412         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">3413           Node* u = n-&gt;fast_out(i);</span>
<span class="line-removed">3414           if (u-&gt;_idx &lt; last) {</span>
<span class="line-removed">3415             // If user is a comparison with a klass that can&#39;t be a value type</span>
<span class="line-removed">3416             // array klass, we don&#39;t need to clear the storage property bits.</span>
<span class="line-removed">3417             Node* cmp = (u-&gt;is_DecodeNKlass() &amp;&amp; u-&gt;outcnt() == 1) ? u-&gt;unique_out() : u;</span>
<span class="line-removed">3418             if (cmp-&gt;is_Cmp()) {</span>
<span class="line-removed">3419               const TypeKlassPtr* kp1 = cmp-&gt;in(1)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();</span>
<span class="line-removed">3420               const TypeKlassPtr* kp2 = cmp-&gt;in(2)-&gt;bottom_type()-&gt;make_ptr()-&gt;isa_klassptr();</span>
<span class="line-removed">3421               if ((kp1 != NULL &amp;&amp; !kp1-&gt;klass()-&gt;can_be_value_array_klass()) ||</span>
<span class="line-removed">3422                   (kp2 != NULL &amp;&amp; !kp2-&gt;klass()-&gt;can_be_value_array_klass())) {</span>
<span class="line-removed">3423                 continue;</span>
<span class="line-removed">3424               }</span>
<span class="line-removed">3425             }</span>
<span class="line-removed">3426             int nb = u-&gt;replace_edge(n, pointer);</span>
<span class="line-removed">3427             --i, imax -= nb;</span>
<span class="line-removed">3428           }</span>
<span class="line-removed">3429         }</span>
<span class="line-removed">3430       }</span>
<span class="line-removed">3431     }</span>
3432     break;
3433   }
3434 
3435   case Op_AddP: {               // Assert sane base pointers
3436     Node *addp = n-&gt;in(AddPNode::Address);
3437     assert( !addp-&gt;is_AddP() ||
3438             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3439             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3440             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3441 #ifdef _LP64
3442     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3443         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3444         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3445         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3446       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3447       // on the platform and on the compressed oops mode.
3448       // Use addressing with narrow klass to load with offset on x86.
3449       // Some platforms can use the constant pool to load ConP.
3450       // Do this transformation here since IGVN will convert ConN back to ConP.
3451       const Type* t = addp-&gt;bottom_type();
</pre>
</td>
<td>
<hr />
<pre>
3370   case Op_LoadUS:
3371   case Op_LoadI:
3372   case Op_LoadKlass:
3373   case Op_LoadNKlass:
3374   case Op_LoadL:
3375   case Op_LoadL_unaligned:
3376   case Op_LoadPLocked:
3377   case Op_LoadP:
3378   case Op_LoadN:
3379   case Op_LoadRange:
3380   case Op_LoadS: {
3381   handle_mem:
3382 #ifdef ASSERT
3383     if( VerifyOptoOopOffsets ) {
3384       MemNode* mem  = n-&gt;as_Mem();
3385       // Check to see if address types have grounded out somehow.
3386       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3387       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3388     }
3389 #endif










































3390     break;
3391   }
3392 
3393   case Op_AddP: {               // Assert sane base pointers
3394     Node *addp = n-&gt;in(AddPNode::Address);
3395     assert( !addp-&gt;is_AddP() ||
3396             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3397             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3398             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3399 #ifdef _LP64
3400     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3401         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3402         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3403         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3404       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3405       // on the platform and on the compressed oops mode.
3406       // Use addressing with narrow klass to load with offset on x86.
3407       // Some platforms can use the constant pool to load ConP.
3408       // Do this transformation here since IGVN will convert ConN back to ConP.
3409       const Type* t = addp-&gt;bottom_type();
</pre>
</td>
</tr>
</table>
<center><a href="../oops/valueArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
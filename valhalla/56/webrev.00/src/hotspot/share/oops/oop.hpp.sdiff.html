<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="objArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_HPP
 26 #define SHARE_OOPS_OOP_HPP
 27 
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;
<span class="line-removed"> 31 #include &quot;oops/arrayStorageProperties.hpp&quot;</span>
 32 #include &quot;oops/markWord.hpp&quot;
 33 #include &quot;oops/metadata.hpp&quot;
 34 #include &quot;runtime/atomic.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 
 37 // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
 38 // the format of Java objects so the fields can be accessed from C++.
 39 // oopDesc is abstract.
 40 // (see oopHierarchy for complete oop class hierarchy)
 41 //
 42 // no virtual functions allowed
 43 //
 44 // oopDesc::_mark - the &quot;oop mark word&quot; encoding to be found separately in markWord.hpp
 45 //
<span class="line-modified"> 46 // oopDesc::_metadata - encodes both the object&#39;s klass pointer and potentially</span>
<span class="line-modified"> 47 //                      &quot;storage properties&quot; (currently confined to arrays in the form of</span>
<span class="line-removed"> 48 //                      ArrayStorageProperties). Storage properties are peculiar to the</span>
<span class="line-removed"> 49 //                      *instance*, and not necessarily the &quot;type&quot;.</span>
 50 //
 51 // The overall size of the _metadata field is dependent on &quot;UseCompressedClassPointers&quot;,
 52 // hence the terms &quot;narrow&quot; (32 bits) vs &quot;wide&quot; (64 bits).
 53 //
<span class="line-removed"> 54 // &quot;Wide&quot; encoding of _metadata:</span>
<span class="line-removed"> 55 // bit number          |63             0|</span>
<span class="line-removed"> 56 // bit length          |--3|-----61-----|</span>
<span class="line-removed"> 57 // --------------------------------------</span>
<span class="line-removed"> 58 // _klass              [xxx| Klass*     ]</span>
<span class="line-removed"> 59 // _wide_storage_props [ sp|            ]</span>
<span class="line-removed"> 60 // --------------------------------------</span>
<span class="line-removed"> 61 // with:</span>
<span class="line-removed"> 62 //    xxx = klass_mask(), Klass* = Klass pointer to be masked</span>
<span class="line-removed"> 63 //    sp = storage properties, bit number: wide_storage_props_shift</span>
<span class="line-removed"> 64 //</span>
<span class="line-removed"> 65 // &quot;Narrow&quot; encoding of _metadata:</span>
<span class="line-removed"> 66 // bit number            |31             0|</span>
<span class="line-removed"> 67 // bit length            |--3|-----29-----|</span>
<span class="line-removed"> 68 // ----------------------------------------</span>
<span class="line-removed"> 69 // _compressed_klass     [xxx| narrowKlass]</span>
<span class="line-removed"> 70 // _narrow_storage_props [ sp|            ]</span>
<span class="line-removed"> 71 // ----------------------------------------</span>
<span class="line-removed"> 72 // with:</span>
<span class="line-removed"> 73 //   xxx = compressed_klass_mask(), narrowKlass = compressed Klass pointer to be masked</span>
<span class="line-removed"> 74 //         narrowKlass may be further decoded (Klass::decode_klass()) to produce Klass*</span>
<span class="line-removed"> 75 //   sp = storage properties, bit number: narrow_storage_props_shift</span>
<span class="line-removed"> 76 //</span>
<span class="line-removed"> 77 // Storage properties encodings are current confined to arrayStorageProperties.hpp</span>
 78 
 79 
 80 // Forward declarations.
 81 class OopClosure;
 82 class ScanClosure;
 83 class FastScanClosure;
 84 class FilteringClosure;
 85 
 86 class PSPromotionManager;
 87 class ParCompactionManager;
 88 
 89 class oopDesc {
 90   friend class VMStructs;
 91   friend class JVMCIVMStructs;
 92  private:
 93   volatile markWord _mark;
 94   union _metadata {
 95     Klass*      _klass;
 96     narrowKlass _compressed_klass;
<span class="line-removed"> 97     uintptr_t   _wide_storage_props;</span>
<span class="line-removed"> 98     uint32_t   _narrow_storage_props;</span>
 99   } _metadata;
100 
101  public:
102   inline markWord  mark()          const;
103   inline markWord  mark_raw()      const;
104   inline markWord* mark_addr_raw() const;
105 
106   inline void set_mark(volatile markWord m);
107   inline void set_mark_raw(volatile markWord m);
108   static inline void set_mark_raw(HeapWord* mem, markWord m);
109 
110   inline void release_set_mark(markWord m);
111   inline markWord cas_set_mark(markWord new_mark, markWord old_mark);
112   inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);
113 
114   // Used only to re-initialize the mark word (e.g., of promoted
115   // objects during a GC) -- requires a valid klass pointer
116   inline void init_mark();
117   inline void init_mark_raw();
118 
<span class="line-removed">119   enum {</span>
<span class="line-removed">120     storage_props_nof_bits     = LogKlassAlignmentInBytes, // This alignment gives us some &quot;free bits&quot;</span>
<span class="line-removed">121     narrow_storage_props_shift = (sizeof(narrowKlass) &lt;&lt; 3) - storage_props_nof_bits,</span>
<span class="line-removed">122     wide_storage_props_shift   = (sizeof(Klass*) &lt;&lt; 3) - storage_props_nof_bits</span>
<span class="line-removed">123   };</span>
<span class="line-removed">124 </span>
<span class="line-removed">125   static inline narrowKlass compressed_klass_mask();</span>
<span class="line-removed">126   static inline narrowKlass compressed_klass_masked(narrowKlass raw);</span>
<span class="line-removed">127   static inline uintptr_t   klass_mask();</span>
<span class="line-removed">128   static inline Klass*      klass_masked(uintptr_t raw);</span>
<span class="line-removed">129 </span>
130   inline Klass* klass() const;
131   inline Klass* klass_or_null() const volatile;
132   inline Klass* klass_or_null_acquire() const volatile;
133   static inline Klass** klass_addr(HeapWord* mem);
134   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
135   inline Klass** klass_addr();
136   inline narrowKlass* compressed_klass_addr();
137 
138   inline void set_klass(Klass* k);
139   static inline void release_set_klass(HeapWord* mem, Klass* klass);
140 
<span class="line-removed">141   // Extra container metadata specific to arrays (encoded into high bits of _metadata)</span>
<span class="line-removed">142   static inline uintptr_t* wide_metadata_addr(HeapWord* mem);</span>
<span class="line-removed">143   inline ArrayStorageProperties array_storage_properties() const;</span>
<span class="line-removed">144   inline void set_metadata(ArrayStorageProperties storage_props, Klass* k);</span>
<span class="line-removed">145   static inline void release_set_metadata(HeapWord* mem, ArrayStorageProperties storage_props, Klass* klass);</span>
<span class="line-removed">146 </span>
<span class="line-removed">147 </span>
148   // For klass field compression
149   inline int klass_gap() const;
150   inline void set_klass_gap(int z);
151   static inline void set_klass_gap(HeapWord* mem, int z);
152 
153   // size of object header, aligned to platform wordSize
154   static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
155 
156   // Returns whether this is an instance of k or an instance of a subclass of k
157   inline bool is_a(Klass* k) const;
158 
159   // Returns the actual oop size of the object
160   inline int size();
161 
162   // Sometimes (for complicated concurrency-related reasons), it is useful
163   // to be able to figure out the size of an object knowing its klass.
164   inline int size_given_klass(Klass* klass);
165 
166   // type test operations (inlined in oop.inline.hpp)
167   inline bool is_instance()            const;
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_OOPS_OOP_HPP
 26 #define SHARE_OOPS_OOP_HPP
 27 
 28 #include &quot;memory/iterator.hpp&quot;
 29 #include &quot;memory/memRegion.hpp&quot;
 30 #include &quot;oops/access.hpp&quot;

 31 #include &quot;oops/markWord.hpp&quot;
 32 #include &quot;oops/metadata.hpp&quot;
 33 #include &quot;runtime/atomic.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 // oopDesc is the top baseclass for objects classes. The {name}Desc classes describe
 37 // the format of Java objects so the fields can be accessed from C++.
 38 // oopDesc is abstract.
 39 // (see oopHierarchy for complete oop class hierarchy)
 40 //
 41 // no virtual functions allowed
 42 //
 43 // oopDesc::_mark - the &quot;oop mark word&quot; encoding to be found separately in markWord.hpp
 44 //
<span class="line-modified"> 45 // oopDesc::_metadata - encodes the object&#39;s klass pointer, as a raw pointer in &quot;_klass&quot;</span>
<span class="line-modified"> 46 //                      or compressed pointer in &quot;_compressed_klass&quot;</span>


 47 //
 48 // The overall size of the _metadata field is dependent on &quot;UseCompressedClassPointers&quot;,
 49 // hence the terms &quot;narrow&quot; (32 bits) vs &quot;wide&quot; (64 bits).
 50 //
























 51 
 52 
 53 // Forward declarations.
 54 class OopClosure;
 55 class ScanClosure;
 56 class FastScanClosure;
 57 class FilteringClosure;
 58 
 59 class PSPromotionManager;
 60 class ParCompactionManager;
 61 
 62 class oopDesc {
 63   friend class VMStructs;
 64   friend class JVMCIVMStructs;
 65  private:
 66   volatile markWord _mark;
 67   union _metadata {
 68     Klass*      _klass;
 69     narrowKlass _compressed_klass;


 70   } _metadata;
 71 
 72  public:
 73   inline markWord  mark()          const;
 74   inline markWord  mark_raw()      const;
 75   inline markWord* mark_addr_raw() const;
 76 
 77   inline void set_mark(volatile markWord m);
 78   inline void set_mark_raw(volatile markWord m);
 79   static inline void set_mark_raw(HeapWord* mem, markWord m);
 80 
 81   inline void release_set_mark(markWord m);
 82   inline markWord cas_set_mark(markWord new_mark, markWord old_mark);
 83   inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);
 84 
 85   // Used only to re-initialize the mark word (e.g., of promoted
 86   // objects during a GC) -- requires a valid klass pointer
 87   inline void init_mark();
 88   inline void init_mark_raw();
 89 











 90   inline Klass* klass() const;
 91   inline Klass* klass_or_null() const volatile;
 92   inline Klass* klass_or_null_acquire() const volatile;
 93   static inline Klass** klass_addr(HeapWord* mem);
 94   static inline narrowKlass* compressed_klass_addr(HeapWord* mem);
 95   inline Klass** klass_addr();
 96   inline narrowKlass* compressed_klass_addr();
 97 
 98   inline void set_klass(Klass* k);
 99   static inline void release_set_klass(HeapWord* mem, Klass* klass);
100 







101   // For klass field compression
102   inline int klass_gap() const;
103   inline void set_klass_gap(int z);
104   static inline void set_klass_gap(HeapWord* mem, int z);
105 
106   // size of object header, aligned to platform wordSize
107   static int header_size() { return sizeof(oopDesc)/HeapWordSize; }
108 
109   // Returns whether this is an instance of k or an instance of a subclass of k
110   inline bool is_a(Klass* k) const;
111 
112   // Returns the actual oop size of the object
113   inline int size();
114 
115   // Sometimes (for complicated concurrency-related reasons), it is useful
116   // to be able to figure out the size of an object knowing its klass.
117   inline int size_given_klass(Klass* klass);
118 
119   // type test operations (inlined in oop.inline.hpp)
120   inline bool is_instance()            const;
</pre>
</td>
</tr>
</table>
<center><a href="objArrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oop.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
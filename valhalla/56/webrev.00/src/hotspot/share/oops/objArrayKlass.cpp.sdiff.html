<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
139   this-&gt;set_bottom_klass(bk);
140   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
141 
142   jint lh = array_layout_helper(T_OBJECT);
143   if (element_klass-&gt;is_value()) {
144     lh = layout_helper_set_null_free(lh);
145   }
146   this-&gt;set_layout_helper(lh);
147   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
148   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
149 }
150 
151 int ObjArrayKlass::oop_size(oop obj) const {
152   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
153   return objArrayOop(obj)-&gt;object_size();
154 }
155 
156 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
157   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
158   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">159   bool populate_null_free = storage_properties().is_null_free();</span>
160   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
161                                                        /* do_zero */ true, THREAD);
162   if (populate_null_free) {
163     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
164     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
165     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
166     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
167     element_klass()-&gt;initialize(CHECK_NULL);
168     // Populate default values...
169     objArrayHandle array_h(THREAD, array);
170     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
171     for (int i = 0; i &lt; length; i++) {
172       array_h-&gt;obj_at_put(i, value);
173     }
174   }
175   return array;
176 }
177 
178 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
179   int length = *sizes;
180   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
<span class="line-modified">181     if ((!element_klass()-&gt;is_array_klass()) &amp;&amp; storage_properties().is_null_free()) {</span>
182       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
183     } else {
184       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
185     }
186   }
187   guarantee(rank &gt; 1, &quot;Rank below 1&quot;);
188   // Call to lower_dimension uses this pointer, so most be called before a
189   // possible GC
190   Klass* ld_klass = lower_dimension();
191   // If length &lt; 0 allocate will throw an exception.
192   objArrayOop array = allocate(length, CHECK_NULL);
193   objArrayHandle h_array (THREAD, array);
194   if (length != 0) {
195     for (int index = 0; index &lt; length; index++) {
196       ArrayKlass* ak = ArrayKlass::cast(ld_klass);
197       oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);
198       h_array-&gt;obj_at_put(index, sub_array);
199     }
200   } else {
201     // Since this array dimension has zero length, nothing will be
202     // allocated, however the lower dimension values must be checked
203     // for illegal values.
204     for (int i = 0; i &lt; rank - 1; ++i) {
205       sizes += 1;
206       if (*sizes &lt; 0) {
207         THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));
208       }
209     }
210   }
211   return h_array();
212 }
213 
<span class="line-removed">214 ArrayStorageProperties ObjArrayKlass::storage_properties() {</span>
<span class="line-removed">215   return name()-&gt;is_Q_singledim_array_signature() ? ArrayStorageProperties::null_free : ArrayStorageProperties::empty;</span>
<span class="line-removed">216 }</span>
<span class="line-removed">217 </span>
218 // Either oop or narrowOop depending on UseCompressedOops.
219 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
220                             arrayOop d, size_t dst_offset, int length, TRAPS) {
221   if (s == d) {
222     // since source and destination are equal we do not need conversion checks.
223     assert(length &gt; 0, &quot;sanity check&quot;);
224     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
225   } else {
226     // We have to make sure all elements conform to the destination array
227     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
228     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
229     // Perform null check if dst is null-free but src has no such guarantee
230     bool null_check = ((!s-&gt;klass()-&gt;is_null_free_array_klass()) &amp;&amp;
231         d-&gt;klass()-&gt;is_null_free_array_klass());
232     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
233       if (null_check) {
234         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
235       } else {
236         ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
237       }
</pre>
</td>
<td>
<hr />
<pre>
139   this-&gt;set_bottom_klass(bk);
140   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
141 
142   jint lh = array_layout_helper(T_OBJECT);
143   if (element_klass-&gt;is_value()) {
144     lh = layout_helper_set_null_free(lh);
145   }
146   this-&gt;set_layout_helper(lh);
147   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
148   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
149 }
150 
151 int ObjArrayKlass::oop_size(oop obj) const {
152   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
153   return objArrayOop(obj)-&gt;object_size();
154 }
155 
156 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
157   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);
158   int size = objArrayOopDesc::object_size(length);
<span class="line-modified">159   bool populate_null_free = is_null_free_array_klass();</span>
160   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
161                                                        /* do_zero */ true, THREAD);
162   if (populate_null_free) {
163     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
164     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
165     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
166     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
167     element_klass()-&gt;initialize(CHECK_NULL);
168     // Populate default values...
169     objArrayHandle array_h(THREAD, array);
170     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
171     for (int i = 0; i &lt; length; i++) {
172       array_h-&gt;obj_at_put(i, value);
173     }
174   }
175   return array;
176 }
177 
178 oop ObjArrayKlass::multi_allocate(int rank, jint* sizes, TRAPS) {
179   int length = *sizes;
180   if (rank == 1) { // last dim may be valueArray, check if we have any special storage requirements
<span class="line-modified">181     if (element_klass()-&gt;is_value()) {</span>
182       return oopFactory::new_valueArray(element_klass(), length, CHECK_NULL);
183     } else {
184       return oopFactory::new_objArray(element_klass(), length, CHECK_NULL);
185     }
186   }
187   guarantee(rank &gt; 1, &quot;Rank below 1&quot;);
188   // Call to lower_dimension uses this pointer, so most be called before a
189   // possible GC
190   Klass* ld_klass = lower_dimension();
191   // If length &lt; 0 allocate will throw an exception.
192   objArrayOop array = allocate(length, CHECK_NULL);
193   objArrayHandle h_array (THREAD, array);
194   if (length != 0) {
195     for (int index = 0; index &lt; length; index++) {
196       ArrayKlass* ak = ArrayKlass::cast(ld_klass);
197       oop sub_array = ak-&gt;multi_allocate(rank-1, &amp;sizes[1], CHECK_NULL);
198       h_array-&gt;obj_at_put(index, sub_array);
199     }
200   } else {
201     // Since this array dimension has zero length, nothing will be
202     // allocated, however the lower dimension values must be checked
203     // for illegal values.
204     for (int i = 0; i &lt; rank - 1; ++i) {
205       sizes += 1;
206       if (*sizes &lt; 0) {
207         THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, *sizes));
208       }
209     }
210   }
211   return h_array();
212 }
213 




214 // Either oop or narrowOop depending on UseCompressedOops.
215 void ObjArrayKlass::do_copy(arrayOop s, size_t src_offset,
216                             arrayOop d, size_t dst_offset, int length, TRAPS) {
217   if (s == d) {
218     // since source and destination are equal we do not need conversion checks.
219     assert(length &gt; 0, &quot;sanity check&quot;);
220     ArrayAccess&lt;&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
221   } else {
222     // We have to make sure all elements conform to the destination array
223     Klass* bound = ObjArrayKlass::cast(d-&gt;klass())-&gt;element_klass();
224     Klass* stype = ObjArrayKlass::cast(s-&gt;klass())-&gt;element_klass();
225     // Perform null check if dst is null-free but src has no such guarantee
226     bool null_check = ((!s-&gt;klass()-&gt;is_null_free_array_klass()) &amp;&amp;
227         d-&gt;klass()-&gt;is_null_free_array_klass());
228     if (stype == bound || stype-&gt;is_subtype_of(bound)) {
229       if (null_check) {
230         ArrayAccess&lt;ARRAYCOPY_DISJOINT | ARRAYCOPY_NOTNULL&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
231       } else {
232         ArrayAccess&lt;ARRAYCOPY_DISJOINT&gt;::oop_arraycopy(s, src_offset, d, dst_offset, length);
233       }
</pre>
</td>
</tr>
</table>
<center><a href="arrayKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
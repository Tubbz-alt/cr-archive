<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());
 72 }
 73 
 74 markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {
 75   uintptr_t v = HeapAccess&lt;&gt;::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());
 76   return markWord(v);
 77 }
 78 
 79 markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {
 80   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);
 81 }
 82 
 83 void oopDesc::init_mark() {
 84   set_mark(markWord::prototype_for_klass(klass()));
 85 }
 86 
 87 void oopDesc::init_mark_raw() {
 88   set_mark_raw(markWord::prototype_for_klass(klass()));
 89 }
 90 
<span class="line-removed"> 91 narrowKlass oopDesc::compressed_klass_mask() { return ((narrowKlass) 1 &lt;&lt; narrow_storage_props_shift) - 1; }</span>
<span class="line-removed"> 92 uintptr_t   oopDesc::klass_mask()   { return ((uintptr_t) 1 &lt;&lt; wide_storage_props_shift) - 1; }</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94 narrowKlass oopDesc::compressed_klass_masked(narrowKlass raw) { return raw &amp; compressed_klass_mask(); }</span>
<span class="line-removed"> 95 Klass*      oopDesc::klass_masked(uintptr_t raw)     { return reinterpret_cast&lt;Klass*&gt;(raw &amp; klass_mask()); }</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 </span>
 98 Klass* oopDesc::klass() const {
 99   if (UseCompressedClassPointers) {
<span class="line-modified">100     return CompressedKlassPointers::decode_not_null(compressed_klass_masked(_metadata._compressed_klass));</span>
101   } else {
<span class="line-modified">102     return klass_masked(_metadata._wide_storage_props);</span>
103   }
104 }
105 
106 Klass* oopDesc::klass_or_null() const volatile {
107   if (UseCompressedClassPointers) {
<span class="line-modified">108     return CompressedKlassPointers::decode(compressed_klass_masked(_metadata._compressed_klass));</span>
109   } else {
<span class="line-modified">110     return klass_masked(_metadata._wide_storage_props);</span>
111   }
112 }
113 
114 Klass* oopDesc::klass_or_null_acquire() const volatile {
115   if (UseCompressedClassPointers) {
116     // Workaround for non-const load_acquire parameter.
117     const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
118     volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">119     return CompressedKlassPointers::decode(compressed_klass_masked(Atomic::load_acquire(xaddr)));</span>
120   } else {
<span class="line-modified">121     return klass_masked(Atomic::load_acquire(&amp;_metadata._wide_storage_props));</span>
122   }
123 }
124 
125 Klass** oopDesc::klass_addr(HeapWord* mem) {
126   // Only used internally and with CMS and will not work with
127   // UseCompressedOops
128   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
129   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
130   return (Klass**) (((char*)mem) + in_bytes(offset));
131 }
132 
<span class="line-removed">133 uintptr_t* oopDesc::wide_metadata_addr(HeapWord* mem) {</span>
<span class="line-removed">134   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);</span>
<span class="line-removed">135   ByteSize offset = byte_offset_of(oopDesc, _metadata._wide_storage_props);</span>
<span class="line-removed">136   return (uintptr_t*) (((char*)mem) + in_bytes(offset));</span>
<span class="line-removed">137 }</span>
<span class="line-removed">138 </span>
139 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
140   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
141   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
142   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
143 }
144 
145 Klass** oopDesc::klass_addr() {
146   return klass_addr((HeapWord*)this);
147 }
148 
149 narrowKlass* oopDesc::compressed_klass_addr() {
150   return compressed_klass_addr((HeapWord*)this);
151 }
152 
153 #define CHECK_SET_KLASS(k)                                                \
154   do {                                                                    \
155     assert(Universe::is_bootstrapping() || k != NULL, &quot;NULL Klass&quot;);      \
156     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \
<span class="line-removed">157     assert(((reinterpret_cast&lt;uintptr_t&gt;(k) &amp; (~ oopDesc::klass_mask())) == 0), \</span>
<span class="line-removed">158       &quot;No room for storage props &quot;); \</span>
159   } while (0)
160 
161 void oopDesc::set_klass(Klass* k) {
162   CHECK_SET_KLASS(k);
163   if (UseCompressedClassPointers) {
164     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);
165   } else {
166     *klass_addr() = k;
167   }
168 }
169 
170 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
171   CHECK_SET_KLASS(klass);
172   if (UseCompressedClassPointers) {
173     Atomic::release_store(compressed_klass_addr(mem),
174                           CompressedKlassPointers::encode_not_null(klass));
175   } else {
176     Atomic::release_store(klass_addr(mem), klass);
177   }
178   assert(((oopDesc*)mem)-&gt;klass() == klass, &quot;failed oopDesc::klass() encode/decode&quot;);
179 }
180 
<span class="line-removed">181 void oopDesc::set_metadata(ArrayStorageProperties storage_props, Klass* klass) {</span>
<span class="line-removed">182   CHECK_SET_KLASS(klass);</span>
<span class="line-removed">183   if (UseCompressedClassPointers) {</span>
<span class="line-removed">184     *compressed_klass_addr() = (CompressedKlassPointers::encode_not_null(klass) | storage_props.encode&lt;narrowKlass&gt;(narrow_storage_props_shift));</span>
<span class="line-removed">185   } else {</span>
<span class="line-removed">186     *wide_metadata_addr((HeapWord*)this) = (reinterpret_cast&lt;uintptr_t&gt;(klass) | storage_props.encode&lt;uintptr_t&gt;(wide_storage_props_shift));</span>
<span class="line-removed">187   }</span>
<span class="line-removed">188 }</span>
<span class="line-removed">189 </span>
<span class="line-removed">190 void oopDesc::release_set_metadata(HeapWord* mem, ArrayStorageProperties storage_props, Klass* klass) {</span>
<span class="line-removed">191   CHECK_SET_KLASS(klass);</span>
<span class="line-removed">192   if (UseCompressedClassPointers) {</span>
<span class="line-removed">193     Atomic::release_store(oopDesc::compressed_klass_addr(mem),</span>
<span class="line-removed">194                                CompressedKlassPointers::encode_not_null(klass) | storage_props.encode&lt;narrowKlass&gt;(narrow_storage_props_shift));</span>
<span class="line-removed">195   } else {</span>
<span class="line-removed">196     Atomic::release_store(oopDesc::wide_metadata_addr(mem),</span>
<span class="line-removed">197                                (reinterpret_cast&lt;uintptr_t&gt;(klass) | storage_props.encode&lt;uintptr_t&gt;(wide_storage_props_shift)));</span>
<span class="line-removed">198   }</span>
<span class="line-removed">199 }</span>
200 #undef CHECK_SET_KLASS
201 
<span class="line-removed">202 </span>
<span class="line-removed">203 ArrayStorageProperties oopDesc::array_storage_properties() const {</span>
<span class="line-removed">204   if (UseCompressedClassPointers) {</span>
<span class="line-removed">205     return ArrayStorageProperties(_metadata._narrow_storage_props &gt;&gt; narrow_storage_props_shift);</span>
<span class="line-removed">206   } else {</span>
<span class="line-removed">207     return ArrayStorageProperties(_metadata._wide_storage_props &gt;&gt; wide_storage_props_shift);</span>
<span class="line-removed">208   }</span>
<span class="line-removed">209 }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211 </span>
212 int oopDesc::klass_gap() const {
213   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
214 }
215 
216 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
217   if (UseCompressedClassPointers) {
218     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
219   }
220 }
221 
222 void oopDesc::set_klass_gap(int v) {
223   set_klass_gap((HeapWord*)this, v);
224 }
225 
226 bool oopDesc::is_a(Klass* k) const {
227   return klass()-&gt;is_subtype_of(k);
228 }
229 
230 int oopDesc::size()  {
231   return size_given_klass(klass());
</pre>
</td>
<td>
<hr />
<pre>
 71   HeapAccess&lt;MO_RELEASE&gt;::store_at(as_oop(), mark_offset_in_bytes(), m.value());
 72 }
 73 
 74 markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {
 75   uintptr_t v = HeapAccess&lt;&gt;::atomic_cmpxchg_at(as_oop(), mark_offset_in_bytes(), old_mark.value(), new_mark.value());
 76   return markWord(v);
 77 }
 78 
 79 markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {
 80   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);
 81 }
 82 
 83 void oopDesc::init_mark() {
 84   set_mark(markWord::prototype_for_klass(klass()));
 85 }
 86 
 87 void oopDesc::init_mark_raw() {
 88   set_mark_raw(markWord::prototype_for_klass(klass()));
 89 }
 90 







 91 Klass* oopDesc::klass() const {
 92   if (UseCompressedClassPointers) {
<span class="line-modified"> 93     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);</span>
 94   } else {
<span class="line-modified"> 95     return _metadata._klass;</span>
 96   }
 97 }
 98 
 99 Klass* oopDesc::klass_or_null() const volatile {
100   if (UseCompressedClassPointers) {
<span class="line-modified">101     return CompressedKlassPointers::decode(_metadata._compressed_klass);</span>
102   } else {
<span class="line-modified">103     return _metadata._klass;</span>
104   }
105 }
106 
107 Klass* oopDesc::klass_or_null_acquire() const volatile {
108   if (UseCompressedClassPointers) {
109     // Workaround for non-const load_acquire parameter.
110     const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;
111     volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);
<span class="line-modified">112     return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));</span>
113   } else {
<span class="line-modified">114     return Atomic::load_acquire(&amp;_metadata._klass);</span>
115   }
116 }
117 
118 Klass** oopDesc::klass_addr(HeapWord* mem) {
119   // Only used internally and with CMS and will not work with
120   // UseCompressedOops
121   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
122   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
123   return (Klass**) (((char*)mem) + in_bytes(offset));
124 }
125 






126 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
127   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
128   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
129   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
130 }
131 
132 Klass** oopDesc::klass_addr() {
133   return klass_addr((HeapWord*)this);
134 }
135 
136 narrowKlass* oopDesc::compressed_klass_addr() {
137   return compressed_klass_addr((HeapWord*)this);
138 }
139 
140 #define CHECK_SET_KLASS(k)                                                \
141   do {                                                                    \
142     assert(Universe::is_bootstrapping() || k != NULL, &quot;NULL Klass&quot;);      \
143     assert(Universe::is_bootstrapping() || k-&gt;is_klass(), &quot;not a Klass&quot;); \


144   } while (0)
145 
146 void oopDesc::set_klass(Klass* k) {
147   CHECK_SET_KLASS(k);
148   if (UseCompressedClassPointers) {
149     *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);
150   } else {
151     *klass_addr() = k;
152   }
153 }
154 
155 void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {
156   CHECK_SET_KLASS(klass);
157   if (UseCompressedClassPointers) {
158     Atomic::release_store(compressed_klass_addr(mem),
159                           CompressedKlassPointers::encode_not_null(klass));
160   } else {
161     Atomic::release_store(klass_addr(mem), klass);
162   }
163   assert(((oopDesc*)mem)-&gt;klass() == klass, &quot;failed oopDesc::klass() encode/decode&quot;);
164 }
165 



















166 #undef CHECK_SET_KLASS
167 










168 int oopDesc::klass_gap() const {
169   return *(int*)(((intptr_t)this) + klass_gap_offset_in_bytes());
170 }
171 
172 void oopDesc::set_klass_gap(HeapWord* mem, int v) {
173   if (UseCompressedClassPointers) {
174     *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;
175   }
176 }
177 
178 void oopDesc::set_klass_gap(int v) {
179   set_klass_gap((HeapWord*)this, v);
180 }
181 
182 bool oopDesc::is_a(Klass* k) const {
183   return klass()-&gt;is_subtype_of(k);
184 }
185 
186 int oopDesc::size()  {
187   return size_given_klass(klass());
</pre>
</td>
</tr>
</table>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="valueArrayKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
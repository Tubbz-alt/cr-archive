<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/memAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../cpu/x86/macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/memAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
373 }
374 
375 void MemAllocator::mem_clear(HeapWord* mem) const {
376   assert(mem != NULL, &quot;cannot initialize NULL object&quot;);
377   const size_t hs = oopDesc::header_size();
378   assert(_word_size &gt;= hs, &quot;unexpected object size&quot;);
379   oopDesc::set_klass_gap(mem, 0);
380   Copy::fill_to_aligned_words(mem + hs, _word_size - hs);
381 }
382 
383 oop MemAllocator::finish(HeapWord* mem) const {
384   assert(mem != NULL, &quot;NULL object pointer&quot;);
385   oopDesc::set_mark_raw(mem, Klass::default_prototype_header(_klass));
386   // Need a release store to ensure array/class length, mark word, and
387   // object zeroing are visible before setting the klass non-NULL, for
388   // concurrent collectors.
389   oopDesc::release_set_klass(mem, _klass);
390   return oop(mem);
391 }
392 
<span class="line-removed">393 oop MemAllocator::finish_with_properties(HeapWord* mem, ArrayStorageProperties storage_props) const {</span>
<span class="line-removed">394   oop res = finish(mem); // finish() returns on purpose (can be overloaded, clearing memory might safepoint)</span>
<span class="line-removed">395   oopDesc::release_set_metadata(cast_from_oop&lt;HeapWord*&gt;(res), storage_props, _klass);</span>
<span class="line-removed">396   return res;</span>
<span class="line-removed">397 }</span>
<span class="line-removed">398 </span>
399 oop ObjAllocator::initialize(HeapWord* mem) const {
400   mem_clear(mem);
401   return finish(mem);
402 }
403 
404 oop ObjBufferAllocator::initialize(HeapWord* mem) const {
405   oopDesc::set_klass_gap(mem, 0);
406   return finish(mem);
407 }
408 
409 
410 MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {
411   if (_do_zero) {
412     return MemAllocator::obj_memory_range(obj);
413   }
414   ArrayKlass* array_klass = ArrayKlass::cast(_klass);
415   const size_t hs = arrayOopDesc::header_size(array_klass-&gt;element_type());
416   return MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj) + hs, _word_size - hs);
417 }
418 
419 oop ObjArrayAllocator::initialize(HeapWord* mem) const {
420   // Set array length before setting the _klass field because a
421   // non-NULL klass field indicates that the object is parsable by
422   // concurrent GC.
423   assert(_length &gt;= 0, &quot;length should be non-negative&quot;);
424   if (_do_zero) {
425     mem_clear(mem);
426   }
427   arrayOopDesc::set_length(mem, _length);
<span class="line-modified">428   assert(ArrayKlass::cast(_klass)-&gt;storage_properties().is_empty() ||</span>
<span class="line-removed">429       ArrayKlass::cast(_klass)-&gt;dimension() == 1, &quot;Multidim should have no storage props&quot;);</span>
<span class="line-removed">430   return finish_with_properties(mem, ArrayKlass::cast(_klass)-&gt;storage_properties());</span>
431 }
432 
433 oop ClassAllocator::initialize(HeapWord* mem) const {
434   // Set oop_size field before setting the _klass field because a
435   // non-NULL _klass field indicates that the object is parsable by
436   // concurrent GC.
437   assert(_word_size &gt; 0, &quot;oop_size must be positive.&quot;);
438   mem_clear(mem);
439   java_lang_Class::set_oop_size(mem, (int)_word_size);
440   return finish(mem);
441 }
</pre>
</td>
<td>
<hr />
<pre>
373 }
374 
375 void MemAllocator::mem_clear(HeapWord* mem) const {
376   assert(mem != NULL, &quot;cannot initialize NULL object&quot;);
377   const size_t hs = oopDesc::header_size();
378   assert(_word_size &gt;= hs, &quot;unexpected object size&quot;);
379   oopDesc::set_klass_gap(mem, 0);
380   Copy::fill_to_aligned_words(mem + hs, _word_size - hs);
381 }
382 
383 oop MemAllocator::finish(HeapWord* mem) const {
384   assert(mem != NULL, &quot;NULL object pointer&quot;);
385   oopDesc::set_mark_raw(mem, Klass::default_prototype_header(_klass));
386   // Need a release store to ensure array/class length, mark word, and
387   // object zeroing are visible before setting the klass non-NULL, for
388   // concurrent collectors.
389   oopDesc::release_set_klass(mem, _klass);
390   return oop(mem);
391 }
392 






393 oop ObjAllocator::initialize(HeapWord* mem) const {
394   mem_clear(mem);
395   return finish(mem);
396 }
397 
398 oop ObjBufferAllocator::initialize(HeapWord* mem) const {
399   oopDesc::set_klass_gap(mem, 0);
400   return finish(mem);
401 }
402 
403 
404 MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {
405   if (_do_zero) {
406     return MemAllocator::obj_memory_range(obj);
407   }
408   ArrayKlass* array_klass = ArrayKlass::cast(_klass);
409   const size_t hs = arrayOopDesc::header_size(array_klass-&gt;element_type());
410   return MemRegion(cast_from_oop&lt;HeapWord*&gt;(obj) + hs, _word_size - hs);
411 }
412 
413 oop ObjArrayAllocator::initialize(HeapWord* mem) const {
414   // Set array length before setting the _klass field because a
415   // non-NULL klass field indicates that the object is parsable by
416   // concurrent GC.
417   assert(_length &gt;= 0, &quot;length should be non-negative&quot;);
418   if (_do_zero) {
419     mem_clear(mem);
420   }
421   arrayOopDesc::set_length(mem, _length);
<span class="line-modified">422   return finish(mem);</span>


423 }
424 
425 oop ClassAllocator::initialize(HeapWord* mem) const {
426   // Set oop_size field before setting the _klass field because a
427   // non-NULL _klass field indicates that the object is parsable by
428   // concurrent GC.
429   assert(_word_size &gt; 0, &quot;oop_size must be positive.&quot;);
430   mem_clear(mem);
431   java_lang_Class::set_oop_size(mem, (int)_word_size);
432   return finish(mem);
433 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../cpu/x86/macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
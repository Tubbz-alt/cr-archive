<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestC2CCalls.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestCallingConventionC1.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
423     public MyValue3 test21_inlined() {
424         throw new RuntimeException();
425     }
426 
427     @Test
428     public MyValue3 test21() {
429         try {
430             return test21_inlined();
431         } catch (RuntimeException ex) {
432             return test21_vt;
433         }
434     }
435 
436     @DontCompile
437     public void test21_verifier(boolean warmup) {
438         MyValue3 vt = test21();
439         test21_vt.verify(vt);
440     }
441 
442     // Test returning a non-flattened value type as fields
<span class="line-modified">443     MyValue3? test22_vt = MyValue3.create();</span>
444 
445     @Test
446     public MyValue3 test22() {
447         return (MyValue3) test22_vt;
448     }
449 
450     @DontCompile
451     public void test22_verifier(boolean warmup) {
452         MyValue3 vt = test22();
453         test22_vt.verify(vt);
454     }
455 
456     // Test calling a method that has circular register/stack dependencies when unpacking value type arguments
457     inline class TestValue23 {
458         final double f1;
459         TestValue23(double val) {
460             f1 = val;
461         }
462     }
463 
</pre>
<hr />
<pre>
475                             v1, v2, v3, v4, v5, v6, v7, v8,
476                             d1, d2, d3, d4, d5, d6, d7, d8);
477     }
478 
479     @DontCompile
480     public void test23_verifier(boolean warmup) {
481         TestValue23 vt = new TestValue23(rI);
482         double res1 = test23(rI, rI, rI, rI, rI, rI,
483                             vt, vt, vt, vt, vt, vt, vt, vt,
484                             rI, rI, rI, rI, rI, rI, rI, rI);
485         double res2 = test23Callee(rI, rI, rI, rI, rI, rI,
486                                    vt, vt, vt, vt, vt, vt, vt, vt,
487                                    rI, rI, rI, rI, rI, rI, rI, rI);
488         double res3 = 6*rI + 8*rI + 8*rI;
489         Asserts.assertEQ(res1, res2);
490         Asserts.assertEQ(res2, res3);
491     }
492 
493     // Should not return a nullable value type as fields
494     @Test
<span class="line-modified">495     public MyValue2? test24() {</span>
496         return null;
497     }
498 
499     @DontCompile
500     public void test24_verifier(boolean warmup) {
<span class="line-modified">501         MyValue2? vt = test24();</span>
502         Asserts.assertEQ(vt, null);
503     }
504 
505     // Same as test24 but with control flow and inlining
506     @ForceInline
<span class="line-modified">507     public MyValue2? test26_callee(boolean b) {</span>
508         if (b) {
509             return null;
510         } else {
511             return MyValue2.createWithFieldsInline(rI, true);
512         }
513     }
514 
515     @Test
<span class="line-modified">516     public MyValue2? test26(boolean b) {</span>
517         return test26_callee(b);
518     }
519 
520     @DontCompile
521     public void test26_verifier(boolean warmup) {
<span class="line-modified">522         MyValue2? vt = test26(true);</span>
523         Asserts.assertEQ(vt, null);
524         vt = test26(false);
525         Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, true).hash());
526     }
527 
528     // Test calling convention with deep hierarchy of flattened fields
529     final inline class Test27Value1 {
530         final Test27Value2 valueField;
531 
532         private Test27Value1(Test27Value2 val2) {
533             valueField = val2;
534         }
535 
536         @DontInline
537         public int test(Test27Value1 val1) {
538             return valueField.test(valueField) + val1.valueField.test(valueField);
539         }
540     }
541 
542     final inline class Test27Value2 {
</pre>
<hr />
<pre>
562         @DontInline
563         public int test(Test27Value3 val3) {
564             return x + val3.x;
565         }
566     }
567 
568     @Test
569     public int test27(Test27Value1 val) {
570         return val.test(val);
571     }
572 
573     @DontCompile
574     public void test27_verifier(boolean warmup) {
575         Test27Value3 val3 = new Test27Value3(rI);
576         Test27Value2 val2 = new Test27Value2(val3);
577         Test27Value1 val1 = new Test27Value1(val2);
578         int result = test27(val1);
579         Asserts.assertEQ(result, 8*rI);
580     }
581 
<span class="line-modified">582     static final MyValue1? test28Val = MyValue1.createWithFieldsDontInline(rI, rL);</span>
583 
584     @Test
585     @Warmup(0)
586     public String test28() {
587         return test28Val.toString();
588     }
589 
590     @DontCompile
591     public void test28_verifier(boolean warmup) {
592         String result = test28();
593     }
594 
595     // Test calling a method returning a value type as fields via reflection
596     MyValue3 test29_vt = MyValue3.create();
597 
598     @Test
599     public MyValue3 test29() {
600         return test29_vt;
601     }
602 
</pre>
</td>
<td>
<hr />
<pre>
423     public MyValue3 test21_inlined() {
424         throw new RuntimeException();
425     }
426 
427     @Test
428     public MyValue3 test21() {
429         try {
430             return test21_inlined();
431         } catch (RuntimeException ex) {
432             return test21_vt;
433         }
434     }
435 
436     @DontCompile
437     public void test21_verifier(boolean warmup) {
438         MyValue3 vt = test21();
439         test21_vt.verify(vt);
440     }
441 
442     // Test returning a non-flattened value type as fields
<span class="line-modified">443     MyValue3.ref test22_vt = MyValue3.create();</span>
444 
445     @Test
446     public MyValue3 test22() {
447         return (MyValue3) test22_vt;
448     }
449 
450     @DontCompile
451     public void test22_verifier(boolean warmup) {
452         MyValue3 vt = test22();
453         test22_vt.verify(vt);
454     }
455 
456     // Test calling a method that has circular register/stack dependencies when unpacking value type arguments
457     inline class TestValue23 {
458         final double f1;
459         TestValue23(double val) {
460             f1 = val;
461         }
462     }
463 
</pre>
<hr />
<pre>
475                             v1, v2, v3, v4, v5, v6, v7, v8,
476                             d1, d2, d3, d4, d5, d6, d7, d8);
477     }
478 
479     @DontCompile
480     public void test23_verifier(boolean warmup) {
481         TestValue23 vt = new TestValue23(rI);
482         double res1 = test23(rI, rI, rI, rI, rI, rI,
483                             vt, vt, vt, vt, vt, vt, vt, vt,
484                             rI, rI, rI, rI, rI, rI, rI, rI);
485         double res2 = test23Callee(rI, rI, rI, rI, rI, rI,
486                                    vt, vt, vt, vt, vt, vt, vt, vt,
487                                    rI, rI, rI, rI, rI, rI, rI, rI);
488         double res3 = 6*rI + 8*rI + 8*rI;
489         Asserts.assertEQ(res1, res2);
490         Asserts.assertEQ(res2, res3);
491     }
492 
493     // Should not return a nullable value type as fields
494     @Test
<span class="line-modified">495     public MyValue2.ref test24() {</span>
496         return null;
497     }
498 
499     @DontCompile
500     public void test24_verifier(boolean warmup) {
<span class="line-modified">501         MyValue2.ref vt = test24();</span>
502         Asserts.assertEQ(vt, null);
503     }
504 
505     // Same as test24 but with control flow and inlining
506     @ForceInline
<span class="line-modified">507     public MyValue2.ref test26_callee(boolean b) {</span>
508         if (b) {
509             return null;
510         } else {
511             return MyValue2.createWithFieldsInline(rI, true);
512         }
513     }
514 
515     @Test
<span class="line-modified">516     public MyValue2.ref test26(boolean b) {</span>
517         return test26_callee(b);
518     }
519 
520     @DontCompile
521     public void test26_verifier(boolean warmup) {
<span class="line-modified">522         MyValue2.ref vt = test26(true);</span>
523         Asserts.assertEQ(vt, null);
524         vt = test26(false);
525         Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, true).hash());
526     }
527 
528     // Test calling convention with deep hierarchy of flattened fields
529     final inline class Test27Value1 {
530         final Test27Value2 valueField;
531 
532         private Test27Value1(Test27Value2 val2) {
533             valueField = val2;
534         }
535 
536         @DontInline
537         public int test(Test27Value1 val1) {
538             return valueField.test(valueField) + val1.valueField.test(valueField);
539         }
540     }
541 
542     final inline class Test27Value2 {
</pre>
<hr />
<pre>
562         @DontInline
563         public int test(Test27Value3 val3) {
564             return x + val3.x;
565         }
566     }
567 
568     @Test
569     public int test27(Test27Value1 val) {
570         return val.test(val);
571     }
572 
573     @DontCompile
574     public void test27_verifier(boolean warmup) {
575         Test27Value3 val3 = new Test27Value3(rI);
576         Test27Value2 val2 = new Test27Value2(val3);
577         Test27Value1 val1 = new Test27Value1(val2);
578         int result = test27(val1);
579         Asserts.assertEQ(result, 8*rI);
580     }
581 
<span class="line-modified">582     static final MyValue1.ref test28Val = MyValue1.createWithFieldsDontInline(rI, rL);</span>
583 
584     @Test
585     @Warmup(0)
586     public String test28() {
587         return test28Val.toString();
588     }
589 
590     @DontCompile
591     public void test28_verifier(boolean warmup) {
592         String result = test28();
593     }
594 
595     // Test calling a method returning a value type as fields via reflection
596     MyValue3 test29_vt = MyValue3.create();
597 
598     @Test
599     public MyValue3 test29() {
600         return test29_vt;
601     }
602 
</pre>
</td>
</tr>
</table>
<center><a href="TestC2CCalls.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestCallingConventionC1.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
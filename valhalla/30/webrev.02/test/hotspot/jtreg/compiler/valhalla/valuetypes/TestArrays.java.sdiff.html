<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestArrayAccessDeopt.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestBufferTearing.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1234 
1235     @DontCompile
1236     public void test50_verifier(boolean warmup) {
1237         Object[] src = new Object[8];
1238         Object[] dst = new Object[8];
1239         for (int i = 0; i &lt; 8; ++i) {
1240             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1241         }
1242         test50(src, dst);
1243         verify(src, dst);
1244         if (!warmup) {
1245             Method m = tests.get(&quot;TestArrays::test50&quot;);
1246             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1247                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1248             }
1249         }
1250     }
1251 
1252     @Test
1253     public MyValue1[] test51(MyValue1[] va) {
<span class="line-modified">1254         return Arrays.copyOf(va, va.length, MyValue1[].class);</span>

1255     }
1256 
1257     @DontCompile
1258     public void test51_verifier(boolean warmup) {
1259         int len = Math.abs(rI) % 10;
1260         MyValue1[] va = new MyValue1[len];
1261         for (int i = 0; i &lt; len; ++i) {
1262             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1263         }
1264         MyValue1[] result = test51(va);
1265         verify(va, result);
1266     }
1267 
1268     static final MyValue1[] test52_va = new MyValue1[8];
1269 
1270     @Test
1271     public MyValue1[] test52() {
<span class="line-modified">1272         return Arrays.copyOf(test52_va, 8, MyValue1[].class);</span>

1273     }
1274 
1275     @DontCompile
1276     public void test52_verifier(boolean warmup) {
1277         for (int i = 0; i &lt; 8; ++i) {
1278             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1279         }
1280         MyValue1[] result = test52();
1281         verify(test52_va, result);
1282     }
1283 
1284     @Test
1285     public MyValue1[] test53(Object[] va) {
<span class="line-modified">1286         return Arrays.copyOf(va, va.length, MyValue1[].class);</span>

1287     }
1288 
1289     @DontCompile
1290     public void test53_verifier(boolean warmup) {
1291         int len = Math.abs(rI) % 10;
1292         MyValue1[] va = new MyValue1[len];
1293         for (int i = 0; i &lt; len; ++i) {
1294             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1295         }
1296         MyValue1[] result = test53(va);
1297         verify(result, va);
1298     }
1299 
1300     @Test
1301     public Object[] test54(MyValue1[] va) {
1302         return Arrays.copyOf(va, va.length, Object[].class);
1303     }
1304 
1305     @DontCompile
1306     public void test54_verifier(boolean warmup) {
</pre>
<hr />
<pre>
1314     }
1315 
1316     @Test
1317     public Object[] test55(Object[] va) {
1318         return Arrays.copyOf(va, va.length, Object[].class);
1319     }
1320 
1321     @DontCompile
1322     public void test55_verifier(boolean warmup) {
1323         int len = Math.abs(rI) % 10;
1324         MyValue1[] va = new MyValue1[len];
1325         for (int i = 0; i &lt; len; ++i) {
1326             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1327         }
1328         Object[] result = test55(va);
1329         verify(va, result);
1330     }
1331 
1332     @Test
1333     public MyValue1[] test56(Object[] va) {
<span class="line-modified">1334         return Arrays.copyOf(va, va.length, MyValue1[].class);</span>

1335     }
1336 
1337     @DontCompile
1338     public void test56_verifier(boolean warmup) {
1339         int len = Math.abs(rI) % 10;
1340         Object[] va = new Object[len];
1341         for (int i = 0; i &lt; len; ++i) {
1342             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1343         }
1344         MyValue1[] result = test56(va);
1345         verify(result, va);
1346     }
1347 
1348    @Test
1349     public Object[] test57(Object[] va, Class klass) {
1350         return Arrays.copyOf(va, va.length, klass);
1351     }
1352 
1353     @DontCompile
1354     public void test57_verifier(boolean warmup) {
</pre>
<hr />
<pre>
1950     public void test83_verifier(boolean warmup) {
1951         Integer i = new Integer(rI);
1952         Integer[] array1 = new Integer[2];
1953         Object[] array2 = new Object[2];
1954         test83(array1, i);
1955         Asserts.assertEquals(array1[1], i);
1956         test83(array2, null);
1957         Asserts.assertEquals(array2[1], null);
1958     }
1959 
1960     // Verify that writing constant null into an array marks the array as not-null-free and not-flat
1961     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 1 })
1962     public Object test84(Object[] array, int i) {
1963         array[0] = null;
1964         array[1] = null;
1965         return array[i];
1966     }
1967 
1968     @DontCompile
1969     public void test84_verifier(boolean warmup) {
<span class="line-modified">1970         NotFlattenable?[] array1 = new NotFlattenable?[2];</span>
1971         Object[] array2 = new Object[2];
1972         Object result = test84(array1, 0);
1973         Asserts.assertEquals(array1[0], null);
1974         Asserts.assertEquals(result, null);
1975         result = test84(array2, 1);
1976         Asserts.assertEquals(array2[0], null);
1977         Asserts.assertEquals(result, null);
1978         if (!warmup) {
1979             NotFlattenable[] array3 = new NotFlattenable[2];
1980             try {
1981                 test84(array3, 1);
1982                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1983             } catch (NullPointerException e) {
1984                 // Expected
1985             }
1986         }
1987     }
1988 
1989     // Same as test84 but with branches
1990     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
</pre>
<hr />
<pre>
2006         Asserts.assertEquals(array1[1], i);
2007         test85(array1, null, false);
2008         Asserts.assertEquals(array1[1], null);
2009         test85(array2, i, true);
2010         Asserts.assertEquals(array2[1], i);
2011         test85(array2, null, false);
2012         Asserts.assertEquals(array2[1], null);
2013         if (!warmup) {
2014             NotFlattenable[] array3 = new NotFlattenable[2];
2015             try {
2016                 test85(array3, null, true);
2017                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2018             } catch (NullPointerException e) {
2019                 // Expected
2020             }
2021         }
2022     }
2023 
2024     // Same as test85 but with not-flattenable inline type array
2025     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
<span class="line-modified">2026     public void test86(NotFlattenable?[] array, NotFlattenable? o, boolean b) {</span>
2027         if (b) {
2028             array[0] = null;
2029         } else {
2030             array[1] = null;
2031         }
2032         array[1] = o;
2033     }
2034 
2035     @DontCompile
2036     public void test86_verifier(boolean warmup) {
2037         NotFlattenable vt = new NotFlattenable();
<span class="line-modified">2038         NotFlattenable?[] array1 = new NotFlattenable?[2];</span>
2039         test86(array1, vt, true);
2040         Asserts.assertEquals(array1[1], vt);
2041         test86(array1, null, false);
2042         Asserts.assertEquals(array1[1], null);
2043         if (!warmup) {
2044             NotFlattenable[] array2 = new NotFlattenable[2];
2045             try {
2046                 test86(array2, null, true);
2047                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2048             } catch (NullPointerException e) {
2049                 // Expected
2050             }
2051         }
2052     }
2053 
2054     // Same as test85 but with inline type array
2055     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
<span class="line-modified">2056     public void test87(MyValue1?[] array, MyValue1? o, boolean b) {</span>
2057         if (b) {
2058             array[0] = null;
2059         } else {
2060             array[1] = null;
2061         }
2062         array[1] = o;
2063     }
2064 
2065     @DontCompile
2066     public void test87_verifier(boolean warmup) {
2067         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified">2068         MyValue1?[] array1 = new MyValue1?[2];</span>
2069         test87(array1, vt, true);
2070         Asserts.assertEquals(array1[1], vt);
2071         test87(array1, null, false);
2072         Asserts.assertEquals(array1[1], null);
2073         if (!warmup) {
2074             MyValue1[] array2 = new MyValue1[2];
2075             try {
2076                 test87(array2, null, true);
2077                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2078             } catch (NullPointerException e) {
2079                 // Expected
2080             }
2081         }
2082     }
2083 
2084     // Additional correctness tests to make sure we have the required null checks
2085     @Test()
2086     public void test88(Object[] array, Integer v) {
2087         array[0] = v;
2088     }
</pre>
<hr />
<pre>
2090     @DontCompile
2091     public void test88_verifier(boolean warmup) {
2092         Integer[] array1 = new Integer[1];
2093         Object[] array2 = new Object[1];
2094         test88(array1, null);
2095         Asserts.assertEquals(array1[0], null);
2096         test88(array2, null);
2097         Asserts.assertEquals(array2[0], null);
2098         if (!warmup) {
2099             MyValue1[] array3 = new MyValue1[1];
2100             try {
2101                 test88(array3, null);
2102                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2103             } catch (NullPointerException e) {
2104                 // Expected
2105             }
2106         }
2107     }
2108 
2109     @Test()
<span class="line-modified">2110     public void test89(MyValue1?[] array, Integer v) {</span>
2111         Object o = v;
<span class="line-modified">2112         array[0] = (MyValue1?)o;</span>
2113     }
2114 
2115     @DontCompile
2116     public void test89_verifier(boolean warmup) {
<span class="line-modified">2117         MyValue1?[] array1 = new MyValue1?[1];</span>
2118         test89(array1, null);
2119         Asserts.assertEquals(array1[0], null);
2120         if (!warmup) {
2121             MyValue1[] array2 = new MyValue1[1];
2122             try {
2123                 test89(array2, null);
2124                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2125             } catch (NullPointerException e) {
2126                 // Expected
2127             }
2128         }
2129     }
2130 
2131     @Test
2132     public boolean test90() {
2133         boolean b = true;
2134 
2135         MyValue1[] qArray = new MyValue1[0];
<span class="line-modified">2136         MyValue1?[] lArray = new MyValue1?[0];</span>
2137 
2138         b = b &amp;&amp; (qArray instanceof MyValue1[]);
<span class="line-modified">2139         b = b &amp;&amp; (lArray instanceof MyValue1?[]);</span>
2140 
2141         MyValue1[][] qArray2 = new MyValue1[0][0];
<span class="line-modified">2142         MyValue1?[][] lArray2 = new MyValue1?[0][0];</span>
2143 
2144         b = b &amp;&amp; (qArray2 instanceof MyValue1[][]);
<span class="line-modified">2145         b = b &amp;&amp; (lArray2 instanceof MyValue1?[][]);</span>
2146 
2147         return b;
2148     }
2149 
2150     @DontCompile
2151     public void test90_verifier(boolean warmup) {
2152         Asserts.assertEQ(test90(), true);
2153     }
2154 
2155     inline static final class Test91Value {
2156         public final int f0;
2157         public final int f1;
2158         public final int f2;
2159         public final int f3;
2160         public final int f4;
2161         public final int f5;
2162 
2163         public Test91Value(int i) {
2164             this.f0 = i;
2165             this.f1 = i;
</pre>
</td>
<td>
<hr />
<pre>
1234 
1235     @DontCompile
1236     public void test50_verifier(boolean warmup) {
1237         Object[] src = new Object[8];
1238         Object[] dst = new Object[8];
1239         for (int i = 0; i &lt; 8; ++i) {
1240             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
1241         }
1242         test50(src, dst);
1243         verify(src, dst);
1244         if (!warmup) {
1245             Method m = tests.get(&quot;TestArrays::test50&quot;);
1246             if (USE_COMPILER &amp;&amp; !WHITE_BOX.isMethodCompiled(m, false) &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {
1247                 throw new RuntimeException(&quot;unexpected deoptimization&quot;);
1248             }
1249         }
1250     }
1251 
1252     @Test
1253     public MyValue1[] test51(MyValue1[] va) {
<span class="line-modified">1254         // TODO Remove cast as workaround once javac is fixed</span>
<span class="line-added">1255         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);</span>
1256     }
1257 
1258     @DontCompile
1259     public void test51_verifier(boolean warmup) {
1260         int len = Math.abs(rI) % 10;
1261         MyValue1[] va = new MyValue1[len];
1262         for (int i = 0; i &lt; len; ++i) {
1263             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1264         }
1265         MyValue1[] result = test51(va);
1266         verify(va, result);
1267     }
1268 
1269     static final MyValue1[] test52_va = new MyValue1[8];
1270 
1271     @Test
1272     public MyValue1[] test52() {
<span class="line-modified">1273         // TODO Remove cast as workaround once javac is fixed</span>
<span class="line-added">1274         return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);</span>
1275     }
1276 
1277     @DontCompile
1278     public void test52_verifier(boolean warmup) {
1279         for (int i = 0; i &lt; 8; ++i) {
1280             test52_va[i] = MyValue1.createWithFieldsInline(rI, rL);
1281         }
1282         MyValue1[] result = test52();
1283         verify(test52_va, result);
1284     }
1285 
1286     @Test
1287     public MyValue1[] test53(Object[] va) {
<span class="line-modified">1288         // TODO Remove cast as workaround once javac is fixed</span>
<span class="line-added">1289         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);</span>
1290     }
1291 
1292     @DontCompile
1293     public void test53_verifier(boolean warmup) {
1294         int len = Math.abs(rI) % 10;
1295         MyValue1[] va = new MyValue1[len];
1296         for (int i = 0; i &lt; len; ++i) {
1297             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1298         }
1299         MyValue1[] result = test53(va);
1300         verify(result, va);
1301     }
1302 
1303     @Test
1304     public Object[] test54(MyValue1[] va) {
1305         return Arrays.copyOf(va, va.length, Object[].class);
1306     }
1307 
1308     @DontCompile
1309     public void test54_verifier(boolean warmup) {
</pre>
<hr />
<pre>
1317     }
1318 
1319     @Test
1320     public Object[] test55(Object[] va) {
1321         return Arrays.copyOf(va, va.length, Object[].class);
1322     }
1323 
1324     @DontCompile
1325     public void test55_verifier(boolean warmup) {
1326         int len = Math.abs(rI) % 10;
1327         MyValue1[] va = new MyValue1[len];
1328         for (int i = 0; i &lt; len; ++i) {
1329             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1330         }
1331         Object[] result = test55(va);
1332         verify(va, result);
1333     }
1334 
1335     @Test
1336     public MyValue1[] test56(Object[] va) {
<span class="line-modified">1337         // TODO Remove cast as workaround once javac is fixed</span>
<span class="line-added">1338         return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);</span>
1339     }
1340 
1341     @DontCompile
1342     public void test56_verifier(boolean warmup) {
1343         int len = Math.abs(rI) % 10;
1344         Object[] va = new Object[len];
1345         for (int i = 0; i &lt; len; ++i) {
1346             va[i] = MyValue1.createWithFieldsInline(rI, rL);
1347         }
1348         MyValue1[] result = test56(va);
1349         verify(result, va);
1350     }
1351 
1352    @Test
1353     public Object[] test57(Object[] va, Class klass) {
1354         return Arrays.copyOf(va, va.length, klass);
1355     }
1356 
1357     @DontCompile
1358     public void test57_verifier(boolean warmup) {
</pre>
<hr />
<pre>
1954     public void test83_verifier(boolean warmup) {
1955         Integer i = new Integer(rI);
1956         Integer[] array1 = new Integer[2];
1957         Object[] array2 = new Object[2];
1958         test83(array1, i);
1959         Asserts.assertEquals(array1[1], i);
1960         test83(array2, null);
1961         Asserts.assertEquals(array2[1], null);
1962     }
1963 
1964     // Verify that writing constant null into an array marks the array as not-null-free and not-flat
1965     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 1 })
1966     public Object test84(Object[] array, int i) {
1967         array[0] = null;
1968         array[1] = null;
1969         return array[i];
1970     }
1971 
1972     @DontCompile
1973     public void test84_verifier(boolean warmup) {
<span class="line-modified">1974         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];</span>
1975         Object[] array2 = new Object[2];
1976         Object result = test84(array1, 0);
1977         Asserts.assertEquals(array1[0], null);
1978         Asserts.assertEquals(result, null);
1979         result = test84(array2, 1);
1980         Asserts.assertEquals(array2[0], null);
1981         Asserts.assertEquals(result, null);
1982         if (!warmup) {
1983             NotFlattenable[] array3 = new NotFlattenable[2];
1984             try {
1985                 test84(array3, 1);
1986                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
1987             } catch (NullPointerException e) {
1988                 // Expected
1989             }
1990         }
1991     }
1992 
1993     // Same as test84 but with branches
1994     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
</pre>
<hr />
<pre>
2010         Asserts.assertEquals(array1[1], i);
2011         test85(array1, null, false);
2012         Asserts.assertEquals(array1[1], null);
2013         test85(array2, i, true);
2014         Asserts.assertEquals(array2[1], i);
2015         test85(array2, null, false);
2016         Asserts.assertEquals(array2[1], null);
2017         if (!warmup) {
2018             NotFlattenable[] array3 = new NotFlattenable[2];
2019             try {
2020                 test85(array3, null, true);
2021                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2022             } catch (NullPointerException e) {
2023                 // Expected
2024             }
2025         }
2026     }
2027 
2028     // Same as test85 but with not-flattenable inline type array
2029     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
<span class="line-modified">2030     public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {</span>
2031         if (b) {
2032             array[0] = null;
2033         } else {
2034             array[1] = null;
2035         }
2036         array[1] = o;
2037     }
2038 
2039     @DontCompile
2040     public void test86_verifier(boolean warmup) {
2041         NotFlattenable vt = new NotFlattenable();
<span class="line-modified">2042         NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];</span>
2043         test86(array1, vt, true);
2044         Asserts.assertEquals(array1[1], vt);
2045         test86(array1, null, false);
2046         Asserts.assertEquals(array1[1], null);
2047         if (!warmup) {
2048             NotFlattenable[] array2 = new NotFlattenable[2];
2049             try {
2050                 test86(array2, null, true);
2051                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2052             } catch (NullPointerException e) {
2053                 // Expected
2054             }
2055         }
2056     }
2057 
2058     // Same as test85 but with inline type array
2059     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
<span class="line-modified">2060     public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {</span>
2061         if (b) {
2062             array[0] = null;
2063         } else {
2064             array[1] = null;
2065         }
2066         array[1] = o;
2067     }
2068 
2069     @DontCompile
2070     public void test87_verifier(boolean warmup) {
2071         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
<span class="line-modified">2072         MyValue1.ref[] array1 = new MyValue1.ref[2];</span>
2073         test87(array1, vt, true);
2074         Asserts.assertEquals(array1[1], vt);
2075         test87(array1, null, false);
2076         Asserts.assertEquals(array1[1], null);
2077         if (!warmup) {
2078             MyValue1[] array2 = new MyValue1[2];
2079             try {
2080                 test87(array2, null, true);
2081                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2082             } catch (NullPointerException e) {
2083                 // Expected
2084             }
2085         }
2086     }
2087 
2088     // Additional correctness tests to make sure we have the required null checks
2089     @Test()
2090     public void test88(Object[] array, Integer v) {
2091         array[0] = v;
2092     }
</pre>
<hr />
<pre>
2094     @DontCompile
2095     public void test88_verifier(boolean warmup) {
2096         Integer[] array1 = new Integer[1];
2097         Object[] array2 = new Object[1];
2098         test88(array1, null);
2099         Asserts.assertEquals(array1[0], null);
2100         test88(array2, null);
2101         Asserts.assertEquals(array2[0], null);
2102         if (!warmup) {
2103             MyValue1[] array3 = new MyValue1[1];
2104             try {
2105                 test88(array3, null);
2106                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2107             } catch (NullPointerException e) {
2108                 // Expected
2109             }
2110         }
2111     }
2112 
2113     @Test()
<span class="line-modified">2114     public void test89(MyValue1.ref[] array, Integer v) {</span>
2115         Object o = v;
<span class="line-modified">2116         array[0] = (MyValue1.ref)o;</span>
2117     }
2118 
2119     @DontCompile
2120     public void test89_verifier(boolean warmup) {
<span class="line-modified">2121         MyValue1.ref[] array1 = new MyValue1.ref[1];</span>
2122         test89(array1, null);
2123         Asserts.assertEquals(array1[0], null);
2124         if (!warmup) {
2125             MyValue1[] array2 = new MyValue1[1];
2126             try {
2127                 test89(array2, null);
2128                 throw new RuntimeException(&quot;Should throw NullPointerException&quot;);
2129             } catch (NullPointerException e) {
2130                 // Expected
2131             }
2132         }
2133     }
2134 
2135     @Test
2136     public boolean test90() {
2137         boolean b = true;
2138 
2139         MyValue1[] qArray = new MyValue1[0];
<span class="line-modified">2140         MyValue1.ref[] lArray = new MyValue1.ref[0];</span>
2141 
2142         b = b &amp;&amp; (qArray instanceof MyValue1[]);
<span class="line-modified">2143         b = b &amp;&amp; (lArray instanceof MyValue1.ref[]);</span>
2144 
2145         MyValue1[][] qArray2 = new MyValue1[0][0];
<span class="line-modified">2146         MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];</span>
2147 
2148         b = b &amp;&amp; (qArray2 instanceof MyValue1[][]);
<span class="line-modified">2149         b = b &amp;&amp; (lArray2 instanceof MyValue1.ref[][]);</span>
2150 
2151         return b;
2152     }
2153 
2154     @DontCompile
2155     public void test90_verifier(boolean warmup) {
2156         Asserts.assertEQ(test90(), true);
2157     }
2158 
2159     inline static final class Test91Value {
2160         public final int f0;
2161         public final int f1;
2162         public final int f2;
2163         public final int f3;
2164         public final int f4;
2165         public final int f5;
2166 
2167         public Test91Value(int i) {
2168             this.f0 = i;
2169             this.f1 = i;
</pre>
</td>
</tr>
</table>
<center><a href="TestArrayAccessDeopt.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestBufferTearing.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
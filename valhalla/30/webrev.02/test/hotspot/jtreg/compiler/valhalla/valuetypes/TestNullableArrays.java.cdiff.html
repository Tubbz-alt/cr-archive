<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestLWorldProfiling.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableValueTypes.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,12 ***</span>
      private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  
      // Test nullable value type array creation and initialization
      @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
      @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
<span class="line-modified">!     public MyValue1?[] test1(int len) {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          if (len &gt; 0) {
              va[0] = null;
          }
          for (int i = 1; i &lt; len; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
<span class="line-new-header">--- 78,12 ---</span>
      private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  
      // Test nullable value type array creation and initialization
      @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
      @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
<span class="line-modified">!     public MyValue1.ref[] test1(int len) {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          if (len &gt; 0) {
              va[0] = null;
          }
          for (int i = 1; i &lt; len; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
      }
  
      @DontCompile
      public void test1_verifier(boolean warmup) {
          int len = Math.abs(rI % 10);
<span class="line-modified">!         MyValue1?[] va = test1(len);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(va[0], null);
          }
          for (int i = 1; i &lt; len; ++i) {
              Asserts.assertEQ(va[i].hash(), hash());
<span class="line-new-header">--- 92,11 ---</span>
      }
  
      @DontCompile
      public void test1_verifier(boolean warmup) {
          int len = Math.abs(rI % 10);
<span class="line-modified">!         MyValue1.ref[] va = test1(len);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(va[0], null);
          }
          for (int i = 1; i &lt; len; ++i) {
              Asserts.assertEQ(va[i].hash(), hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,11 ***</span>
      // Test creation of a value type array and element access
      @Test
      // TODO 8227588
      // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public long test2() {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
          va[0] = MyValue1.createWithFieldsInline(rI, rL);
          return va[0].hash();
      }
  
      @DontCompile
<span class="line-new-header">--- 106,11 ---</span>
      // Test creation of a value type array and element access
      @Test
      // TODO 8227588
      // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public long test2() {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
          va[0] = MyValue1.createWithFieldsInline(rI, rL);
          return va[0].hash();
      }
  
      @DontCompile
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,11 ***</span>
      }
  
      // Test receiving a value type array from the interpreter,
      // updating its elements in a loop and computing a hash.
      @Test(failOn = ALLOCA)
<span class="line-modified">!     public long test3(MyValue1?[] va) {</span>
          long result = 0;
          for (int i = 0; i &lt; 10; ++i) {
              if (va[i] != null) {
                  result += va[i].hash();
              }
<span class="line-new-header">--- 120,11 ---</span>
      }
  
      // Test receiving a value type array from the interpreter,
      // updating its elements in a loop and computing a hash.
      @Test(failOn = ALLOCA)
<span class="line-modified">!     public long test3(MyValue1.ref[] va) {</span>
          long result = 0;
          for (int i = 0; i &lt; 10; ++i) {
              if (va[i] != null) {
                  result += va[i].hash();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,11 ***</span>
          return result;
      }
  
      @DontCompile
      public void test3_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[10];</span>
          long expected = 0;
          for (int i = 1; i &lt; 10; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
              expected += va[i].hash();
          }
<span class="line-new-header">--- 134,11 ---</span>
          return result;
      }
  
      @DontCompile
      public void test3_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[10];</span>
          long expected = 0;
          for (int i = 1; i &lt; 10; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
              expected += va[i].hash();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,17 ***</span>
          }
      }
  
      // Test returning a value type array received from the interpreter
      @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
<span class="line-modified">!     public MyValue1?[] test4(MyValue1?[] va) {</span>
          return va;
      }
  
      @DontCompile
      public void test4_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
          }
          va = test4(va);
          for (int i = 0; i &lt; 10; ++i) {
<span class="line-new-header">--- 152,17 ---</span>
          }
      }
  
      // Test returning a value type array received from the interpreter
      @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
<span class="line-modified">!     public MyValue1.ref[] test4(MyValue1.ref[] va) {</span>
          return va;
      }
  
      @DontCompile
      public void test4_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
          }
          va = test4(va);
          for (int i = 0; i &lt; 10; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,20 ***</span>
          }
      }
  
      // Merge value type arrays created from two branches
      @Test
<span class="line-modified">!     public MyValue1?[] test5(boolean b) {</span>
<span class="line-modified">!         MyValue1?[] va;</span>
          if (b) {
<span class="line-modified">!             va = new MyValue1?[5];</span>
              for (int i = 0; i &lt; 5; ++i) {
                  va[i] = MyValue1.createWithFieldsInline(rI, rL);
              }
              va[4] = null;
          } else {
<span class="line-modified">!             va = new MyValue1?[10];</span>
              for (int i = 0; i &lt; 10; ++i) {
                  va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
              }
              va[9] = null;
          }
<span class="line-new-header">--- 170,20 ---</span>
          }
      }
  
      // Merge value type arrays created from two branches
      @Test
<span class="line-modified">!     public MyValue1.ref[] test5(boolean b) {</span>
<span class="line-modified">!         MyValue1.ref[] va;</span>
          if (b) {
<span class="line-modified">!             va = new MyValue1.ref[5];</span>
              for (int i = 0; i &lt; 5; ++i) {
                  va[i] = MyValue1.createWithFieldsInline(rI, rL);
              }
              va[4] = null;
          } else {
<span class="line-modified">!             va = new MyValue1.ref[10];</span>
              for (int i = 0; i &lt; 10; ++i) {
                  va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
              }
              va[9] = null;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,11 ***</span>
          return va;
      }
  
      @DontCompile
      public void test5_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = test5(true);</span>
          Asserts.assertEQ(va.length, 5);
          Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
          for (int i = 1; i &lt; 4; ++i) {
              Asserts.assertEQ(va[i].hash(), hash());
          }
<span class="line-new-header">--- 196,11 ---</span>
          return va;
      }
  
      @DontCompile
      public void test5_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = test5(true);</span>
          Asserts.assertEQ(va.length, 5);
          Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
          for (int i = 1; i &lt; 4; ++i) {
              Asserts.assertEQ(va[i].hash(), hash());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,70 ***</span>
          Asserts.assertEQ(va[9], null);
      }
  
      // Test creation of value type array with single element
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public MyValue1? test6() {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
          return va[0];
      }
  
      @DontCompile
      public void test6_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
<span class="line-modified">!         MyValue1? v = test6();</span>
          Asserts.assertEQ(v, null);
      }
  
      // Test default initialization of value type arrays
      @Test(failOn = LOAD)
<span class="line-modified">!     public MyValue1?[] test7(int len) {</span>
<span class="line-modified">!         return new MyValue1?[len];</span>
      }
  
      @DontCompile
      public void test7_verifier(boolean warmup) {
          int len = Math.abs(rI % 10);
<span class="line-modified">!         MyValue1?[] va = test7(len);</span>
          for (int i = 0; i &lt; len; ++i) {
              Asserts.assertEQ(va[i], null);
              va[i] = null;
          }
      }
  
      // Test creation of value type array with zero length
      @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
<span class="line-modified">!     public MyValue1?[] test8() {</span>
<span class="line-modified">!         return new MyValue1?[0];</span>
      }
  
      @DontCompile
      public void test8_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = test8();</span>
          Asserts.assertEQ(va.length, 0);
      }
  
<span class="line-modified">!     static MyValue1?[] test9_va;</span>
  
      // Test that value type array loaded from field has correct type
      @Test(failOn = LOOP)
      public long test9() {
          return test9_va[0].hash();
      }
  
      @DontCompile
      public void test9_verifier(boolean warmup) {
<span class="line-modified">!         test9_va = new MyValue1?[1];</span>
          test9_va[0] = testValue1;
          long result = test9();
          Asserts.assertEQ(result, hash());
      }
  
      // Multi-dimensional arrays
      @Test
<span class="line-modified">!     public MyValue1?[][][] test10(int len1, int len2, int len3) {</span>
<span class="line-modified">!         MyValue1?[][][] arr = new MyValue1?[len1][len2][len3];</span>
          for (int i = 0; i &lt; len1; i++) {
              for (int j = 0; j &lt; len2; j++) {
                  for (int k = 0; k &lt; len3; k++) {
                      arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
                      if (k == 0) {
<span class="line-new-header">--- 214,70 ---</span>
          Asserts.assertEQ(va[9], null);
      }
  
      // Test creation of value type array with single element
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public MyValue1.ref test6() {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
          return va[0];
      }
  
      @DontCompile
      public void test6_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
<span class="line-modified">!         MyValue1.ref v = test6();</span>
          Asserts.assertEQ(v, null);
      }
  
      // Test default initialization of value type arrays
      @Test(failOn = LOAD)
<span class="line-modified">!     public MyValue1.ref[] test7(int len) {</span>
<span class="line-modified">!         return new MyValue1.ref[len];</span>
      }
  
      @DontCompile
      public void test7_verifier(boolean warmup) {
          int len = Math.abs(rI % 10);
<span class="line-modified">!         MyValue1.ref[] va = test7(len);</span>
          for (int i = 0; i &lt; len; ++i) {
              Asserts.assertEQ(va[i], null);
              va[i] = null;
          }
      }
  
      // Test creation of value type array with zero length
      @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
<span class="line-modified">!     public MyValue1.ref[] test8() {</span>
<span class="line-modified">!         return new MyValue1.ref[0];</span>
      }
  
      @DontCompile
      public void test8_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = test8();</span>
          Asserts.assertEQ(va.length, 0);
      }
  
<span class="line-modified">!     static MyValue1.ref[] test9_va;</span>
  
      // Test that value type array loaded from field has correct type
      @Test(failOn = LOOP)
      public long test9() {
          return test9_va[0].hash();
      }
  
      @DontCompile
      public void test9_verifier(boolean warmup) {
<span class="line-modified">!         test9_va = new MyValue1.ref[1];</span>
          test9_va[0] = testValue1;
          long result = test9();
          Asserts.assertEQ(result, hash());
      }
  
      // Multi-dimensional arrays
      @Test
<span class="line-modified">!     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {</span>
<span class="line-modified">!         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];</span>
          for (int i = 0; i &lt; len1; i++) {
              for (int j = 0; j &lt; len2; j++) {
                  for (int k = 0; k &lt; len3; k++) {
                      arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
                      if (k == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,11 ***</span>
          return arr;
      }
  
      @DontCompile
      public void test10_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[][][] arr = test10(2, 3, 4);</span>
          for (int i = 0; i &lt; 2; i++) {
              for (int j = 0; j &lt; 3; j++) {
                  for (int k = 0; k &lt; 4; k++) {
                      if (k == 0) {
                          Asserts.assertEQ(arr[i][j][k], null);
<span class="line-new-header">--- 289,11 ---</span>
          return arr;
      }
  
      @DontCompile
      public void test10_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[][][] arr = test10(2, 3, 4);</span>
          for (int i = 0; i &lt; 2; i++) {
              for (int j = 0; j &lt; 3; j++) {
                  for (int k = 0; k &lt; 4; k++) {
                      if (k == 0) {
                          Asserts.assertEQ(arr[i][j][k], null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test11(MyValue1?[][][] arr, long[] res) {</span>
          int l = 0;
          for (int i = 0; i &lt; arr.length; i++) {
              for (int j = 0; j &lt; arr[i].length; j++) {
                  for (int k = 0; k &lt; arr[i][j].length; k++) {
                      if (arr[i][j][k] != null) {
<span class="line-new-header">--- 305,11 ---</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test11(MyValue1.ref[][][] arr, long[] res) {</span>
          int l = 0;
          for (int i = 0; i &lt; arr.length; i++) {
              for (int j = 0; j &lt; arr[i].length; j++) {
                  for (int k = 0; k &lt; arr[i][j].length; k++) {
                      if (arr[i][j][k] != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,11 ***</span>
          }
      }
  
      @DontCompile
      public void test11_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[][][] arr = new MyValue1?[2][3][4];</span>
          long[] res = new long[2*3*4];
          long[] verif = new long[2*3*4];
          int l = 0;
          for (int i = 0; i &lt; 2; i++) {
              for (int j = 0; j &lt; 3; j++) {
<span class="line-new-header">--- 322,11 ---</span>
          }
      }
  
      @DontCompile
      public void test11_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];</span>
          long[] res = new long[2*3*4];
          long[] verif = new long[2*3*4];
          int l = 0;
          for (int i = 0; i &lt; 2; i++) {
              for (int j = 0; j &lt; 3; j++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,11 ***</span>
  
      // Array load out of bounds (upper bound) at compile time
      @Test
      public int test12() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
          }
  
<span class="line-new-header">--- 347,11 ---</span>
  
      // Array load out of bounds (upper bound) at compile time
      @Test
      public int test12() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,11 ***</span>
  
      // Array load  out of bounds (lower bound) at compile time
      @Test
      public int test13() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
          }
  
<span class="line-new-header">--- 368,11 ---</span>
  
      // Array load  out of bounds (lower bound) at compile time
      @Test
      public int test13() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,17 ***</span>
          Asserts.assertEQ(test13(), rI);
      }
  
      // Array load out of bound not known to compiler (both lower and upper bound)
      @Test
<span class="line-modified">!     public int test14(MyValue1?[] va, int index)  {</span>
          return va[index].x;
      }
  
      public void test14_verifier(boolean warmup) {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
          }
  
<span class="line-new-header">--- 387,17 ---</span>
          Asserts.assertEQ(test13(), rI);
      }
  
      // Array load out of bound not known to compiler (both lower and upper bound)
      @Test
<span class="line-modified">!     public int test14(MyValue1.ref[] va, int index)  {</span>
          return va[index].x;
      }
  
      public void test14_verifier(boolean warmup) {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,11 ***</span>
  
      // Array store out of bounds (upper bound) at compile time
      @Test
      public int test15() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          try {
              for (int i = 0; i &lt;= arraySize; i++) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
              }
<span class="line-new-header">--- 414,11 ---</span>
  
      // Array store out of bounds (upper bound) at compile time
      @Test
      public int test15() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          try {
              for (int i = 0; i &lt;= arraySize; i++) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,11 ***</span>
  
      // Array store out of bounds (lower bound) at compile time
      @Test
      public int test16() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          try {
              for (int i = -1; i &lt;= arraySize; i++) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
              }
<span class="line-new-header">--- 434,11 ---</span>
  
      // Array store out of bounds (lower bound) at compile time
      @Test
      public int test16() {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          try {
              for (int i = -1; i &lt;= arraySize; i++) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,19 ***</span>
          Asserts.assertEQ(test16(), rI);
      }
  
      // Array store out of bound not known to compiler (both lower and upper bound)
      @Test
<span class="line-modified">!     public int test17(MyValue1?[] va, int index, MyValue1 vt)  {</span>
          va[index] = vt;
          return va[index].x;
      }
  
      @DontCompile
      public void test17_verifier(boolean warmup) {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
          }
  
<span class="line-new-header">--- 452,19 ---</span>
          Asserts.assertEQ(test16(), rI);
      }
  
      // Array store out of bound not known to compiler (both lower and upper bound)
      @Test
<span class="line-modified">!     public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {</span>
          va[index] = vt;
          return va[index].x;
      }
  
      @DontCompile
      public void test17_verifier(boolean warmup) {
          int arraySize = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[arraySize];</span>
  
          for (int i = 0; i &lt; arraySize; i++) {
              va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,86 ***</span>
          }
      }
  
      // clone() as stub call
      @Test
<span class="line-modified">!     public MyValue1?[] test18(MyValue1?[] va) {</span>
          return va.clone();
      }
  
      @DontCompile
      public void test18_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va1 = new MyValue1?[len];</span>
          MyValue1[]  va2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              va1[i] = testValue1;
              va2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result1 = test18(va1);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(result1[0], null);
          }
          for (int i = 1; i &lt; len; ++i) {
              Asserts.assertEQ(result1[i].hash(), va1[i].hash());
          }
          // make sure we do deopt: GraphKit::new_array assumes an
          // array of references
          for (int j = 0; j &lt; 10; j++) {
<span class="line-modified">!             MyValue1?[] result2 = test18(va2);</span>
  
              for (int i = 0; i &lt; len; ++i) {
                  Asserts.assertEQ(result2[i].hash(), va2[i].hash());
              }
          }
          if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
<span class="line-modified">!             MyValue1?[] result2 = test18(va2);</span>
              for (int i = 0; i &lt; len; ++i) {
                  Asserts.assertEQ(result2[i].hash(), va2[i].hash());
              }
          }
      }
  
      // clone() as series of loads/stores
<span class="line-modified">!     static MyValue1?[] test19_orig = null;</span>
  
      @Test
<span class="line-modified">!     public MyValue1?[] test19() {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[8];</span>
          for (int i = 1; i &lt; va.length; ++i) {
              va[i] = MyValue1.createWithFieldsInline(rI, rL);
          }
          test19_orig = va;
  
          return va.clone();
      }
  
      @DontCompile
      public void test19_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] result = test19();</span>
          Asserts.assertEQ(result[0], null);
          for (int i = 1; i &lt; test19_orig.length; ++i) {
              Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
          }
      }
  
      // arraycopy() of value type array with oop fields
      @Test
<span class="line-modified">!     public void test20(MyValue1?[] src, MyValue1?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test20_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] src2 = new MyValue1?[len];</span>
          MyValue1[]  src3 = new MyValue1[len];
          MyValue1[]  src4 = new MyValue1[len];
<span class="line-modified">!         MyValue1?[] dst1 = new MyValue1?[len];</span>
          MyValue1[]  dst2 = new MyValue1[len];
<span class="line-modified">!         MyValue1?[] dst3 = new MyValue1?[len];</span>
          MyValue1[]  dst4 = new MyValue1[len];
          if (len &gt; 0) {
              src2[0] = testValue1;
          }
          for (int i = 1; i &lt; len; ++i) {
<span class="line-new-header">--- 484,86 ---</span>
          }
      }
  
      // clone() as stub call
      @Test
<span class="line-modified">!     public MyValue1.ref[] test18(MyValue1.ref[] va) {</span>
          return va.clone();
      }
  
      @DontCompile
      public void test18_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va1 = new MyValue1.ref[len];</span>
          MyValue1[]  va2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              va1[i] = testValue1;
              va2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result1 = test18(va1);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(result1[0], null);
          }
          for (int i = 1; i &lt; len; ++i) {
              Asserts.assertEQ(result1[i].hash(), va1[i].hash());
          }
          // make sure we do deopt: GraphKit::new_array assumes an
          // array of references
          for (int j = 0; j &lt; 10; j++) {
<span class="line-modified">!             MyValue1.ref[] result2 = test18(va2);</span>
  
              for (int i = 0; i &lt; len; ++i) {
                  Asserts.assertEQ(result2[i].hash(), va2[i].hash());
              }
          }
          if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test18&quot;)) {
<span class="line-modified">!             MyValue1.ref[] result2 = test18(va2);</span>
              for (int i = 0; i &lt; len; ++i) {
                  Asserts.assertEQ(result2[i].hash(), va2[i].hash());
              }
          }
      }
  
      // clone() as series of loads/stores
<span class="line-modified">!     static MyValue1.ref[] test19_orig = null;</span>
  
      @Test
<span class="line-modified">!     public MyValue1.ref[] test19() {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[8];</span>
          for (int i = 1; i &lt; va.length; ++i) {
              va[i] = MyValue1.createWithFieldsInline(rI, rL);
          }
          test19_orig = va;
  
          return va.clone();
      }
  
      @DontCompile
      public void test19_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] result = test19();</span>
          Asserts.assertEQ(result[0], null);
          for (int i = 1; i &lt; test19_orig.length; ++i) {
              Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
          }
      }
  
      // arraycopy() of value type array with oop fields
      @Test
<span class="line-modified">!     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test20_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] src2 = new MyValue1.ref[len];</span>
          MyValue1[]  src3 = new MyValue1[len];
          MyValue1[]  src4 = new MyValue1[len];
<span class="line-modified">!         MyValue1.ref[] dst1 = new MyValue1.ref[len];</span>
          MyValue1[]  dst2 = new MyValue1[len];
<span class="line-modified">!         MyValue1.ref[] dst3 = new MyValue1.ref[len];</span>
          MyValue1[]  dst4 = new MyValue1[len];
          if (len &gt; 0) {
              src2[0] = testValue1;
          }
          for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,24 ***</span>
          }
      }
  
      // arraycopy() of value type array with no oop field
      @Test
<span class="line-modified">!     public void test21(MyValue2?[] src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test21_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2?[] src1 = new MyValue2?[len];</span>
<span class="line-modified">!         MyValue2?[] src2 = new MyValue2?[len];</span>
          MyValue2[]  src3 = new MyValue2[len];
          MyValue2[]  src4 = new MyValue2[len];
<span class="line-modified">!         MyValue2?[] dst1 = new MyValue2?[len];</span>
          MyValue2[]  dst2 = new MyValue2[len];
<span class="line-modified">!         MyValue2?[] dst3 = new MyValue2?[len];</span>
          MyValue2[]  dst4 = new MyValue2[len];
          if (len &gt; 0) {
              src2[0] = MyValue2.createWithFieldsInline(rI, true);
          }
          for (int i = 1; i &lt; len; ++i) {
<span class="line-new-header">--- 590,24 ---</span>
          }
      }
  
      // arraycopy() of value type array with no oop field
      @Test
<span class="line-modified">!     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test21_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2.ref[] src1 = new MyValue2.ref[len];</span>
<span class="line-modified">!         MyValue2.ref[] src2 = new MyValue2.ref[len];</span>
          MyValue2[]  src3 = new MyValue2[len];
          MyValue2[]  src4 = new MyValue2[len];
<span class="line-modified">!         MyValue2.ref[] dst1 = new MyValue2.ref[len];</span>
          MyValue2[]  dst2 = new MyValue2[len];
<span class="line-modified">!         MyValue2.ref[] dst3 = new MyValue2.ref[len];</span>
          MyValue2[]  dst4 = new MyValue2[len];
          if (len &gt; 0) {
              src2[0] = MyValue2.createWithFieldsInline(rI, true);
          }
          for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,27 ***</span>
      }
  
      // arraycopy() of value type array with oop field and tightly
      // coupled allocation as dest
      @Test
<span class="line-modified">!     public MyValue1?[] test22(MyValue1?[] src) {</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[src.length];</span>
          System.arraycopy(src, 0, dst, 0, src.length);
          return dst;
      }
  
      @DontCompile
      public void test22_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[len];</span>
          MyValue1[]  src2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] dst1 = test22(src1);</span>
<span class="line-modified">!         MyValue1?[] dst2 = test22(src2);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(dst1[0], null);
              Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
          }
          for (int i = 1; i &lt; len; ++i) {
<span class="line-new-header">--- 635,27 ---</span>
      }
  
      // arraycopy() of value type array with oop field and tightly
      // coupled allocation as dest
      @Test
<span class="line-modified">!     public MyValue1.ref[] test22(MyValue1.ref[] src) {</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[src.length];</span>
          System.arraycopy(src, 0, dst, 0, src.length);
          return dst;
      }
  
      @DontCompile
      public void test22_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[len];</span>
          MyValue1[]  src2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] dst1 = test22(src1);</span>
<span class="line-modified">!         MyValue1.ref[] dst2 = test22(src2);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(dst1[0], null);
              Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
          }
          for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,27 ***</span>
      }
  
      // arraycopy() of value type array with oop fields and tightly
      // coupled allocation as dest
      @Test
<span class="line-modified">!     public MyValue1?[] test23(MyValue1?[] src) {</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[src.length + 10];</span>
          System.arraycopy(src, 0, dst, 5, src.length);
          return dst;
      }
  
      @DontCompile
      public void test23_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[len];</span>
          MyValue1[] src2 = new MyValue1[len];
          for (int i = 0; i &lt; len; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] dst1 = test23(src1);</span>
<span class="line-modified">!         MyValue1?[] dst2 = test23(src2);</span>
          for (int i = 0; i &lt; 5; ++i) {
              Asserts.assertEQ(dst1[i], null);
              Asserts.assertEQ(dst2[i], null);
          }
          for (int i = 5; i &lt; len; ++i) {
<span class="line-new-header">--- 665,27 ---</span>
      }
  
      // arraycopy() of value type array with oop fields and tightly
      // coupled allocation as dest
      @Test
<span class="line-modified">!     public MyValue1.ref[] test23(MyValue1.ref[] src) {</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];</span>
          System.arraycopy(src, 0, dst, 5, src.length);
          return dst;
      }
  
      @DontCompile
      public void test23_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[len];</span>
          MyValue1[] src2 = new MyValue1[len];
          for (int i = 0; i &lt; len; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] dst1 = test23(src1);</span>
<span class="line-modified">!         MyValue1.ref[] dst2 = test23(src2);</span>
          for (int i = 0; i &lt; 5; ++i) {
              Asserts.assertEQ(dst1[i], null);
              Asserts.assertEQ(dst2[i], null);
          }
          for (int i = 5; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,24 ***</span>
          }
      }
  
      // arraycopy() of value type array passed as Object
      @Test
<span class="line-modified">!     public void test24(MyValue1?[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test24_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] src2 = new MyValue1?[len];</span>
          MyValue1[]  src3 = new MyValue1[len];
          MyValue1[]  src4 = new MyValue1[len];
<span class="line-modified">!         MyValue1?[] dst1 = new MyValue1?[len];</span>
          MyValue1[]  dst2 = new MyValue1[len];
<span class="line-modified">!         MyValue1?[] dst3 = new MyValue1?[len];</span>
          MyValue1[]  dst4 = new MyValue1[len];
          if (len &gt; 0) {
              src2[0] = testValue1;
          }
          for (int i = 1; i &lt; len; ++i) {
<span class="line-new-header">--- 694,24 ---</span>
          }
      }
  
      // arraycopy() of value type array passed as Object
      @Test
<span class="line-modified">!     public void test24(MyValue1.ref[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test24_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] src2 = new MyValue1.ref[len];</span>
          MyValue1[]  src3 = new MyValue1[len];
          MyValue1[]  src4 = new MyValue1[len];
<span class="line-modified">!         MyValue1.ref[] dst1 = new MyValue1.ref[len];</span>
          MyValue1[]  dst2 = new MyValue1[len];
<span class="line-modified">!         MyValue1.ref[] dst3 = new MyValue1.ref[len];</span>
          MyValue1[]  dst4 = new MyValue1[len];
          if (len &gt; 0) {
              src2[0] = testValue1;
          }
          for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,23 ***</span>
          }
      }
  
      // short arraycopy() with no oop field
      @Test
<span class="line-modified">!     public void test25(MyValue2?[] src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test25_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src1 = new MyValue2?[8];</span>
<span class="line-modified">!         MyValue2?[] src2 = new MyValue2?[8];</span>
          MyValue2[]  src3 = new MyValue2[8];
          MyValue2[]  src4 = new MyValue2[8];
<span class="line-modified">!         MyValue2?[] dst1 = new MyValue2?[8];</span>
          MyValue2[]  dst2 = new MyValue2[8];
<span class="line-modified">!         MyValue2?[] dst3 = new MyValue2?[8];</span>
          MyValue2[]  dst4 = new MyValue2[8];
          src2[0] = MyValue2.createWithFieldsInline(rI, true);
          for (int i = 1; i &lt; 8; ++i) {
              src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
              src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
<span class="line-new-header">--- 738,23 ---</span>
          }
      }
  
      // short arraycopy() with no oop field
      @Test
<span class="line-modified">!     public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test25_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src1 = new MyValue2.ref[8];</span>
<span class="line-modified">!         MyValue2.ref[] src2 = new MyValue2.ref[8];</span>
          MyValue2[]  src3 = new MyValue2[8];
          MyValue2[]  src4 = new MyValue2[8];
<span class="line-modified">!         MyValue2.ref[] dst1 = new MyValue2.ref[8];</span>
          MyValue2[]  dst2 = new MyValue2[8];
<span class="line-modified">!         MyValue2.ref[] dst3 = new MyValue2.ref[8];</span>
          MyValue2[]  dst4 = new MyValue2[8];
          src2[0] = MyValue2.createWithFieldsInline(rI, true);
          for (int i = 1; i &lt; 8; ++i) {
              src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
              src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 777,23 ***</span>
          }
      }
  
      // short arraycopy() with oop fields
      @Test
<span class="line-modified">!     public void test26(MyValue1?[] src, MyValue1?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test26_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[8];</span>
<span class="line-modified">!         MyValue1?[] src2 = new MyValue1?[8];</span>
          MyValue1[]  src3 = new MyValue1[8];
          MyValue1[]  src4 = new MyValue1[8];
<span class="line-modified">!         MyValue1?[] dst1 = new MyValue1?[8];</span>
          MyValue1[]  dst2 = new MyValue1[8];
<span class="line-modified">!         MyValue1?[] dst3 = new MyValue1?[8];</span>
          MyValue1[]  dst4 = new MyValue1[8];
          src2[0] = testValue1;
          for (int i = 1; i &lt; 8 ; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
<span class="line-new-header">--- 777,23 ---</span>
          }
      }
  
      // short arraycopy() with oop fields
      @Test
<span class="line-modified">!     public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test26_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[8];</span>
<span class="line-modified">!         MyValue1.ref[] src2 = new MyValue1.ref[8];</span>
          MyValue1[]  src3 = new MyValue1[8];
          MyValue1[]  src4 = new MyValue1[8];
<span class="line-modified">!         MyValue1.ref[] dst1 = new MyValue1.ref[8];</span>
          MyValue1[]  dst2 = new MyValue1[8];
<span class="line-modified">!         MyValue1.ref[] dst3 = new MyValue1.ref[8];</span>
          MyValue1[]  dst4 = new MyValue1[8];
          src2[0] = testValue1;
          for (int i = 1; i &lt; 8 ; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 816,23 ***</span>
          }
      }
  
      // short arraycopy() with oop fields and offsets
      @Test
<span class="line-modified">!     public void test27(MyValue1?[] src, MyValue1?[] dst) {</span>
          System.arraycopy(src, 1, dst, 2, 6);
      }
  
      @DontCompile
      public void test27_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] src1 = new MyValue1?[8];</span>
<span class="line-modified">!         MyValue1?[] src2 = new MyValue1?[8];</span>
          MyValue1[]  src3 = new MyValue1[8];
          MyValue1[]  src4 = new MyValue1[8];
<span class="line-modified">!         MyValue1?[] dst1 = new MyValue1?[8];</span>
          MyValue1[]  dst2 = new MyValue1[8];
<span class="line-modified">!         MyValue1?[] dst3 = new MyValue1?[8];</span>
          MyValue1[]  dst4 = new MyValue1[8];
          for (int i = 1; i &lt; 8; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
              src3[i] = testValue1;
<span class="line-new-header">--- 816,23 ---</span>
          }
      }
  
      // short arraycopy() with oop fields and offsets
      @Test
<span class="line-modified">!     public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {</span>
          System.arraycopy(src, 1, dst, 2, 6);
      }
  
      @DontCompile
      public void test27_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] src1 = new MyValue1.ref[8];</span>
<span class="line-modified">!         MyValue1.ref[] src2 = new MyValue1.ref[8];</span>
          MyValue1[]  src3 = new MyValue1[8];
          MyValue1[]  src4 = new MyValue1[8];
<span class="line-modified">!         MyValue1.ref[] dst1 = new MyValue1.ref[8];</span>
          MyValue1[]  dst2 = new MyValue1[8];
<span class="line-modified">!         MyValue1.ref[] dst3 = new MyValue1.ref[8];</span>
          MyValue1[]  dst4 = new MyValue1[8];
          for (int i = 1; i &lt; 8; ++i) {
              src1[i] = testValue1;
              src2[i] = testValue1;
              src3[i] = testValue1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 858,70 ***</span>
  
      // non escaping allocations
      // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
      @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      @Test(valid = ZGCOn)
<span class="line-modified">!     public MyValue2? test28() {</span>
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[10];</span>
          src[0] = null;
<span class="line-modified">!         MyValue2?[] dst = (MyValue2?[])src.clone();</span>
          return dst[0];
      }
  
      @DontCompile
      public void test28_verifier(boolean warmup) {
          MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
<span class="line-modified">!         MyValue2? result = test28();</span>
          Asserts.assertEQ(result, null);
      }
  
      // non escaping allocations
      // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
      @Test(failOn = ALLOCA + LOOP + TRAP)
<span class="line-modified">!     public MyValue2? test29(MyValue2?[] src) {</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[10];</span>
          System.arraycopy(src, 0, dst, 0, 10);
          return dst[0];
      }
  
      @DontCompile
      public void test29_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
<span class="line-modified">!         MyValue2? v = test29(src);</span>
          Asserts.assertEQ(src[0].hash(), v.hash());
      }
  
      // non escaping allocation with uncommon trap that needs
      // eliminated value type array element as debug info
      @Test
      @Warmup(10000)
<span class="line-modified">!     public MyValue2? test30(MyValue2?[] src, boolean flag) {</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[10];</span>
          System.arraycopy(src, 0, dst, 0, 10);
          if (flag) { }
          return dst[0];
      }
  
      @DontCompile
      public void test30_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
<span class="line-modified">!         MyValue2? v = test30(src, !warmup);</span>
          Asserts.assertEQ(src[0].hash(), v.hash());
      }
  
      // non escaping allocation with memory phi
      @Test()
      // TODO 8227588
      // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public long test31(boolean b, boolean deopt) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[1];</span>
          if (b) {
              src[0] = MyValue2.createWithFieldsInline(rI, true);
          } else {
              src[0] = MyValue2.createWithFieldsInline(rI, false);
          }
<span class="line-new-header">--- 858,70 ---</span>
  
      // non escaping allocations
      // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
      @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      @Test(valid = ZGCOn)
<span class="line-modified">!     public MyValue2.ref test28() {</span>
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[10];</span>
          src[0] = null;
<span class="line-modified">!         MyValue2.ref[] dst = (MyValue2.ref[])src.clone();</span>
          return dst[0];
      }
  
      @DontCompile
      public void test28_verifier(boolean warmup) {
          MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
<span class="line-modified">!         MyValue2.ref result = test28();</span>
          Asserts.assertEQ(result, null);
      }
  
      // non escaping allocations
      // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
      @Test(failOn = ALLOCA + LOOP + TRAP)
<span class="line-modified">!     public MyValue2.ref test29(MyValue2.ref[] src) {</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[10];</span>
          System.arraycopy(src, 0, dst, 0, 10);
          return dst[0];
      }
  
      @DontCompile
      public void test29_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
<span class="line-modified">!         MyValue2.ref v = test29(src);</span>
          Asserts.assertEQ(src[0].hash(), v.hash());
      }
  
      // non escaping allocation with uncommon trap that needs
      // eliminated value type array element as debug info
      @Test
      @Warmup(10000)
<span class="line-modified">!     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[10];</span>
          System.arraycopy(src, 0, dst, 0, 10);
          if (flag) { }
          return dst[0];
      }
  
      @DontCompile
      public void test30_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[10];</span>
          for (int i = 0; i &lt; 10; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
<span class="line-modified">!         MyValue2.ref v = test30(src, !warmup);</span>
          Asserts.assertEQ(src[0].hash(), v.hash());
      }
  
      // non escaping allocation with memory phi
      @Test()
      // TODO 8227588
      // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public long test31(boolean b, boolean deopt) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[1];</span>
          if (b) {
              src[0] = MyValue2.createWithFieldsInline(rI, true);
          } else {
              src[0] = MyValue2.createWithFieldsInline(rI, false);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 950,18 ***</span>
      }
  
      @DontCompile
      public void test32_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va1 = new MyValue1?[len];</span>
          MyValue1[] va2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              va1[i] = testValue1;
              va2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result1 = (MyValue1?[])test32(va1);</span>
<span class="line-modified">!         MyValue1?[] result2 = (MyValue1?[])test32(va2);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(result1[0], null);
              Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
          }
          for (int i = 1; i &lt; len; ++i) {
<span class="line-new-header">--- 950,18 ---</span>
      }
  
      @DontCompile
      public void test32_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va1 = new MyValue1.ref[len];</span>
          MyValue1[] va2 = new MyValue1[len];
          for (int i = 1; i &lt; len; ++i) {
              va1[i] = testValue1;
              va2[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);</span>
<span class="line-modified">!         MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);</span>
          if (len &gt; 0) {
              Asserts.assertEQ(result1[0], null);
              Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
          }
          for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,11 ***</span>
  
      @ForceInline
      public Object[] test34_helper(boolean flag) {
          Object[] va = null;
          if (flag) {
<span class="line-modified">!             va = new MyValue1?[8];</span>
              for (int i = 0; i &lt; va.length; ++i) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
              }
          } else {
              va = new Object[8];
<span class="line-new-header">--- 993,11 ---</span>
  
      @ForceInline
      public Object[] test34_helper(boolean flag) {
          Object[] va = null;
          if (flag) {
<span class="line-modified">!             va = new MyValue1.ref[8];</span>
              for (int i = 0; i &lt; va.length; ++i) {
                  va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
              }
          } else {
              va = new Object[8];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1033,41 ***</span>
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue1?[] src, MyValue1?[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), dst[i].hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue1?[] src, Object[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue2?[] src, MyValue2?[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), dst[i].hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue2?[] src, Object[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
<span class="line-new-header">--- 1033,41 ---</span>
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), dst[i].hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue1.ref[] src, Object[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), dst[i].hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
              }
          }
      }
  
<span class="line-modified">!     static void verify(MyValue2.ref[] src, Object[] dst) {</span>
          for (int i = 0; i &lt; src.length; ++i) {
              if (src[i] != null) {
                  Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
              } else {
                  Asserts.assertEQ(dst[i], null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1096,12 ***</span>
      }
  
      @DontCompile
      public void test35_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] src = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = testValue1;
          }
          test35(src, dst, src.length);
          verify(src, dst);
<span class="line-new-header">--- 1096,12 ---</span>
      }
  
      @DontCompile
      public void test35_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] src = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = testValue1;
          }
          test35(src, dst, src.length);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1110,19 ***</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test36(Object src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, dst.length);
      }
  
      @DontCompile
      public void test36_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[len];</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test36(src, dst);
          verify(src, dst);
<span class="line-new-header">--- 1110,19 ---</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test36(Object src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, dst.length);
      }
  
      @DontCompile
      public void test36_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[len];</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test36(src, dst);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1131,19 ***</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test37(MyValue2?[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test37_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[len];</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test37(src, dst);
          verify(src, dst);
<span class="line-new-header">--- 1131,19 ---</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test37(MyValue2.ref[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test37_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[len];</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test37(src, dst);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,19 ***</span>
          }
      }
  
      @Test
      @Warmup(1) // Avoid early compilation
<span class="line-modified">!     public void test38(Object src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, dst.length);
      }
  
      @DontCompile
      public void test38_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] src = new Object[len];
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test38(src, dst);
          verify(dst, src);
<span class="line-new-header">--- 1153,19 ---</span>
          }
      }
  
      @Test
      @Warmup(1) // Avoid early compilation
<span class="line-modified">!     public void test38(Object src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, dst.length);
      }
  
      @DontCompile
      public void test38_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] src = new Object[len];
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test38(src, dst);
          verify(dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1180,18 ***</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test39(MyValue2?[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test39_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[len];</span>
          Object[] dst = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test39(src, dst);
<span class="line-new-header">--- 1180,18 ---</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test39(MyValue2.ref[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, src.length);
      }
  
      @DontCompile
      public void test39_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[len];</span>
          Object[] dst = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test39(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1210,11 ***</span>
  
      @DontCompile
      public void test40_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] src = new Object[len];
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test40(src, dst);
          verify(dst, src);
<span class="line-new-header">--- 1210,11 ---</span>
  
      @DontCompile
      public void test40_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] src = new Object[len];
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test40(src, dst);
          verify(dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,11 ***</span>
      }
  
      @DontCompile
      public void test41_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[len];</span>
          Object[] dst = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test41(src, dst);
<span class="line-new-header">--- 1236,11 ---</span>
      }
  
      @DontCompile
      public void test41_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[len];</span>
          Object[] dst = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test41(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1280,12 ***</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test43_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] src = new MyValue1?[8];</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = testValue1;
          }
          test43(src, dst);
          verify(src, dst);
<span class="line-new-header">--- 1280,12 ---</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test43_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] src = new MyValue1.ref[8];</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = testValue1;
          }
          test43(src, dst);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1294,18 ***</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test44(Object src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test44_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[8];</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test44(src, dst);
          verify(src, dst);
<span class="line-new-header">--- 1294,18 ---</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test44(Object src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test44_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[8];</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test44(src, dst);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1314,18 ***</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test45(MyValue2?[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test45_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[8];</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test45(src, dst);
          verify(src, dst);
<span class="line-new-header">--- 1314,18 ---</span>
              verify(src, dst);
          }
      }
  
      @Test
<span class="line-modified">!     public void test45(MyValue2.ref[] src, Object dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test45_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[8];</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test45(src, dst);
          verify(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1335,18 ***</span>
          }
      }
  
      @Test
      @Warmup(1) // Avoid early compilation
<span class="line-modified">!     public void test46(Object[] src, MyValue2?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test46_verifier(boolean warmup) {
          Object[] src = new Object[8];
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test46(src, dst);
          verify(dst, src);
<span class="line-new-header">--- 1335,18 ---</span>
          }
      }
  
      @Test
      @Warmup(1) // Avoid early compilation
<span class="line-modified">!     public void test46(Object[] src, MyValue2.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test46_verifier(boolean warmup) {
          Object[] src = new Object[8];
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test46(src, dst);
          verify(dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1361,17 ***</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test47(MyValue2?[] src, Object[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test47_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[8];</span>
          Object[] dst = new Object[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test47(src, dst);
<span class="line-new-header">--- 1361,17 ---</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public void test47(MyValue2.ref[] src, Object[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test47_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[8];</span>
          Object[] dst = new Object[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test47(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1389,11 ***</span>
      }
  
      @DontCompile
      public void test48_verifier(boolean warmup) {
          Object[] src = new Object[8];
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test48(src, dst);
          verify(dst, src);
<span class="line-new-header">--- 1389,11 ---</span>
      }
  
      @DontCompile
      public void test48_verifier(boolean warmup) {
          Object[] src = new Object[8];
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[8];</span>
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test48(src, dst);
          verify(dst, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1414,11 ***</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test49_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[8];</span>
          Object[] dst = new Object[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test49(src, dst);
<span class="line-new-header">--- 1414,11 ---</span>
          System.arraycopy(src, 0, dst, 0, 8);
      }
  
      @DontCompile
      public void test49_verifier(boolean warmup) {
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[8];</span>
          Object[] dst = new Object[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
          }
          test49(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1450,66 ***</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public MyValue1?[] test51(MyValue1?[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1?[].class);</span>
      }
  
      @DontCompile
      public void test51_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result = test51(va);</span>
          verify(va, result);
      }
  
<span class="line-modified">!     static final MyValue1?[] test52_va = new MyValue1?[8];</span>
  
      @Test
<span class="line-modified">!     public MyValue1?[] test52() {</span>
<span class="line-modified">!         return Arrays.copyOf(test52_va, 8, MyValue1?[].class);</span>
      }
  
      @DontCompile
      public void test52_verifier(boolean warmup) {
          for (int i = 1; i &lt; 8; ++i) {
              test52_va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result = test52();</span>
          verify(test52_va, result);
      }
  
      @Test
<span class="line-modified">!     public MyValue1?[] test53(Object[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1?[].class);</span>
      }
  
      @DontCompile
      public void test53_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result = test53(va);</span>
          verify(result, va);
      }
  
      @Test
<span class="line-modified">!     public Object[] test54(MyValue1?[] va) {</span>
          return Arrays.copyOf(va, va.length, Object[].class);
      }
  
      @DontCompile
      public void test54_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          Object[] result = test54(va);
          verify(va, result);
<span class="line-new-header">--- 1450,66 ---</span>
              }
          }
      }
  
      @Test
<span class="line-modified">!     public MyValue1.ref[] test51(MyValue1.ref[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);</span>
      }
  
      @DontCompile
      public void test51_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result = test51(va);</span>
          verify(va, result);
      }
  
<span class="line-modified">!     static final MyValue1.ref[] test52_va = new MyValue1.ref[8];</span>
  
      @Test
<span class="line-modified">!     public MyValue1.ref[] test52() {</span>
<span class="line-modified">!         return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);</span>
      }
  
      @DontCompile
      public void test52_verifier(boolean warmup) {
          for (int i = 1; i &lt; 8; ++i) {
              test52_va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result = test52();</span>
          verify(test52_va, result);
      }
  
      @Test
<span class="line-modified">!     public MyValue1.ref[] test53(Object[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);</span>
      }
  
      @DontCompile
      public void test53_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result = test53(va);</span>
          verify(result, va);
      }
  
      @Test
<span class="line-modified">!     public Object[] test54(MyValue1.ref[] va) {</span>
          return Arrays.copyOf(va, va.length, Object[].class);
      }
  
      @DontCompile
      public void test54_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          Object[] result = test54(va);
          verify(va, result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1521,31 ***</span>
      }
  
      @DontCompile
      public void test55_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          Object[] result = test55(va);
          verify(va, result);
      }
  
      @Test
<span class="line-modified">!     public MyValue1?[] test56(Object[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1?[].class);</span>
      }
  
      @DontCompile
      public void test56_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] va = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1?[] result = test56(va);</span>
          verify(result, va);
      }
  
     @Test
      public Object[] test57(Object[] va, Class klass) {
<span class="line-new-header">--- 1521,31 ---</span>
      }
  
      @DontCompile
      public void test55_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          Object[] result = test55(va);
          verify(va, result);
      }
  
      @Test
<span class="line-modified">!     public MyValue1.ref[] test56(Object[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length, MyValue1.ref[].class);</span>
      }
  
      @DontCompile
      public void test56_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
          Object[] va = new Object[len];
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         MyValue1.ref[] result = test56(va);</span>
          verify(result, va);
      }
  
     @Test
      public Object[] test57(Object[] va, Class klass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1553,50 ***</span>
      }
  
      @DontCompile
      public void test57_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         Object[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         Object[] result = test57(va, MyValue1?[].class);</span>
          verify(va, result);
      }
  
      @Test
<span class="line-modified">!     public Object[] test58(MyValue1?[] va, Class klass) {</span>
          return Arrays.copyOf(va, va.length, klass);
      }
  
      @DontCompile
      public void test58_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          for (int i = 1; i &lt; 10; i++) {
<span class="line-modified">!             Object[] result = test58(va, MyValue1?[].class);</span>
              verify(va, result);
          }
          if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
<span class="line-modified">!             Object[] result = test58(va, MyValue1?[].class);</span>
              verify(va, result);
          }
      }
  
      @Test
<span class="line-modified">!     public Object[] test59(MyValue1?[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length+1, MyValue1?[].class);</span>
      }
  
      @DontCompile
      public void test59_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] verif = new MyValue1?[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Object[] result = test59(va);
<span class="line-new-header">--- 1553,50 ---</span>
      }
  
      @DontCompile
      public void test57_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         Object[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
<span class="line-modified">!         Object[] result = test57(va, MyValue1.ref[].class);</span>
          verify(va, result);
      }
  
      @Test
<span class="line-modified">!     public Object[] test58(MyValue1.ref[] va, Class klass) {</span>
          return Arrays.copyOf(va, va.length, klass);
      }
  
      @DontCompile
      public void test58_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
          }
          for (int i = 1; i &lt; 10; i++) {
<span class="line-modified">!             Object[] result = test58(va, MyValue1.ref[].class);</span>
              verify(va, result);
          }
          if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test58&quot;)) {
<span class="line-modified">!             Object[] result = test58(va, MyValue1.ref[].class);</span>
              verify(va, result);
          }
      }
  
      @Test
<span class="line-modified">!     public Object[] test59(MyValue1.ref[] va) {</span>
<span class="line-modified">!         return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);</span>
      }
  
      @DontCompile
      public void test59_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] verif = new MyValue1.ref[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Object[] result = test59(va);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1609,17 ***</span>
      }
  
      @DontCompile
      public void test60_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] verif = new MyValue1?[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = (MyValue1)va[i];
          }
<span class="line-modified">!         Object[] result = test60(va, MyValue1?[].class);</span>
          verify(verif, result);
      }
  
      @Test
      public Object[] test61(Object[] va, Class klass) {
<span class="line-new-header">--- 1609,17 ---</span>
      }
  
      @DontCompile
      public void test60_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] verif = new MyValue1.ref[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = (MyValue1)va[i];
          }
<span class="line-modified">!         Object[] result = test60(va, MyValue1.ref[].class);</span>
          verify(verif, result);
      }
  
      @Test
      public Object[] test61(Object[] va, Class klass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1638,22 ***</span>
              Asserts.assertEQ(va[i], result[i]);
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test62_helper(int i, MyValue1?[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = oa;
          } else {
              arr = va;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test62(MyValue1?[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test62_helper(i, va, oa);
  
<span class="line-new-header">--- 1638,22 ---</span>
              Asserts.assertEQ(va[i], result[i]);
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = oa;
          } else {
              arr = va;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test62(MyValue1.ref[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test62_helper(i, va, oa);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1661,11 ***</span>
      }
  
      @DontCompile
      public void test62_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          Integer[] oa = new Integer[len];
          for (int i = 1; i &lt; len; ++i) {
              oa[i] = new Integer(rI);
          }
          test62_helper(42, va, oa);
<span class="line-new-header">--- 1661,11 ---</span>
      }
  
      @DontCompile
      public void test62_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          Integer[] oa = new Integer[len];
          for (int i = 1; i &lt; len; ++i) {
              oa[i] = new Integer(rI);
          }
          test62_helper(42, va, oa);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1674,22 ***</span>
              Asserts.assertEQ(oa[i], result[i]);
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test63_helper(int i, MyValue1?[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = va;
          } else {
              arr = oa;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test63(MyValue1?[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test63_helper(i, va, oa);
  
<span class="line-new-header">--- 1674,22 ---</span>
              Asserts.assertEQ(oa[i], result[i]);
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = va;
          } else {
              arr = oa;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test63(MyValue1.ref[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test63_helper(i, va, oa);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1697,12 ***</span>
      }
  
      @DontCompile
      public void test63_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] verif = new MyValue1?[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Integer[] oa = new Integer[len];
<span class="line-new-header">--- 1697,12 ---</span>
      }
  
      @DontCompile
      public void test63_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] verif = new MyValue1.ref[len+1];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Integer[] oa = new Integer[len];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1711,131 ***</span>
          verify(verif, result);
      }
  
      // Test default initialization of value type arrays: small array
      @Test
<span class="line-modified">!     public MyValue1?[] test64() {</span>
<span class="line-modified">!         return new MyValue1?[8];</span>
      }
  
      @DontCompile
      public void test64_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = test64();</span>
          for (int i = 0; i &lt; 8; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Test default initialization of value type arrays: large array
      @Test
<span class="line-modified">!     public MyValue1?[] test65() {</span>
<span class="line-modified">!         return new MyValue1?[32];</span>
      }
  
      @DontCompile
      public void test65_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = test65();</span>
          for (int i = 0; i &lt; 32; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Check init store elimination
      @Test(match = { ALLOCA }, matchCount = { 1 })
<span class="line-modified">!     public MyValue1?[] test66(MyValue1? vt) {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
          va[0] = vt;
          return va;
      }
  
      @DontCompile
      public void test66_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1? vt = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1?[] va = test66(vt);</span>
          Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
      }
  
      // Zeroing elimination and arraycopy
      @Test
<span class="line-modified">!     public MyValue1?[] test67(MyValue1?[] src) {</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[16];</span>
          System.arraycopy(src, 0, dst, 0, 13);
          return dst;
      }
  
      @DontCompile
      public void test67_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[16];</span>
<span class="line-modified">!         MyValue1?[] var = test67(va);</span>
          for (int i = 0; i &lt; 16; ++i) {
              Asserts.assertEQ(var[i], null);
          }
      }
  
      // A store with a default value can be eliminated
      @Test
<span class="line-modified">!     public MyValue1?[] test68() {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[2];</span>
          va[0] = va[1];
          return va;
      }
  
      @DontCompile
      public void test68_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = test68();</span>
          for (int i = 0; i &lt; 2; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Requires individual stores to init array
      @Test
<span class="line-modified">!     public MyValue1?[] test69(MyValue1? vt) {</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[4];</span>
          va[0] = vt;
          va[3] = vt;
          return va;
      }
  
      @DontCompile
      public void test69_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1? vt = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[4];</span>
          va[0] = vt;
          va[3] = vt;
<span class="line-modified">!         MyValue1?[] var = test69(vt);</span>
          for (int i = 0; i &lt; va.length; ++i) {
              Asserts.assertEQ(va[i], var[i]);
          }
      }
  
      // A store with a default value can be eliminated: same as test68
      // but store is farther away from allocation
      @Test
<span class="line-modified">!     public MyValue1?[] test70(MyValue1?[] other) {</span>
          other[1] = other[0];
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[2];</span>
          other[0] = va[1];
          va[0] = va[1];
          return va;
      }
  
      @DontCompile
      public void test70_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[2];</span>
<span class="line-modified">!         MyValue1?[] var = test70(va);</span>
          for (int i = 0; i &lt; 2; ++i) {
              Asserts.assertEQ(va[i], var[i]);
          }
      }
  
      // EA needs to consider oop fields in flattened arrays
      @Test
      public void test71() {
          int len = 10;
<span class="line-modified">!         MyValue2?[] src = new MyValue2?[len];</span>
<span class="line-modified">!         MyValue2?[] dst = new MyValue2?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
          }
          System.arraycopy(src, 0, dst, 0, src.length);
          for (int i = 0; i &lt; len; ++i) {
<span class="line-new-header">--- 1711,131 ---</span>
          verify(verif, result);
      }
  
      // Test default initialization of value type arrays: small array
      @Test
<span class="line-modified">!     public MyValue1.ref[] test64() {</span>
<span class="line-modified">!         return new MyValue1.ref[8];</span>
      }
  
      @DontCompile
      public void test64_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = test64();</span>
          for (int i = 0; i &lt; 8; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Test default initialization of value type arrays: large array
      @Test
<span class="line-modified">!     public MyValue1.ref[] test65() {</span>
<span class="line-modified">!         return new MyValue1.ref[32];</span>
      }
  
      @DontCompile
      public void test65_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = test65();</span>
          for (int i = 0; i &lt; 32; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Check init store elimination
      @Test(match = { ALLOCA }, matchCount = { 1 })
<span class="line-modified">!     public MyValue1.ref[] test66(MyValue1.ref vt) {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
          va[0] = vt;
          return va;
      }
  
      @DontCompile
      public void test66_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1.ref[] va = test66(vt);</span>
          Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
      }
  
      // Zeroing elimination and arraycopy
      @Test
<span class="line-modified">!     public MyValue1.ref[] test67(MyValue1.ref[] src) {</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[16];</span>
          System.arraycopy(src, 0, dst, 0, 13);
          return dst;
      }
  
      @DontCompile
      public void test67_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[16];</span>
<span class="line-modified">!         MyValue1.ref[] var = test67(va);</span>
          for (int i = 0; i &lt; 16; ++i) {
              Asserts.assertEQ(var[i], null);
          }
      }
  
      // A store with a default value can be eliminated
      @Test
<span class="line-modified">!     public MyValue1.ref[] test68() {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[2];</span>
          va[0] = va[1];
          return va;
      }
  
      @DontCompile
      public void test68_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = test68();</span>
          for (int i = 0; i &lt; 2; ++i) {
              Asserts.assertEQ(va[i], null);
          }
      }
  
      // Requires individual stores to init array
      @Test
<span class="line-modified">!     public MyValue1.ref[] test69(MyValue1.ref vt) {</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[4];</span>
          va[0] = vt;
          va[3] = vt;
          return va;
      }
  
      @DontCompile
      public void test69_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[4];</span>
          va[0] = vt;
          va[3] = vt;
<span class="line-modified">!         MyValue1.ref[] var = test69(vt);</span>
          for (int i = 0; i &lt; va.length; ++i) {
              Asserts.assertEQ(va[i], var[i]);
          }
      }
  
      // A store with a default value can be eliminated: same as test68
      // but store is farther away from allocation
      @Test
<span class="line-modified">!     public MyValue1.ref[] test70(MyValue1.ref[] other) {</span>
          other[1] = other[0];
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[2];</span>
          other[0] = va[1];
          va[0] = va[1];
          return va;
      }
  
      @DontCompile
      public void test70_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[2];</span>
<span class="line-modified">!         MyValue1.ref[] var = test70(va);</span>
          for (int i = 0; i &lt; 2; ++i) {
              Asserts.assertEQ(va[i], var[i]);
          }
      }
  
      // EA needs to consider oop fields in flattened arrays
      @Test
      public void test71() {
          int len = 10;
<span class="line-modified">!         MyValue2.ref[] src = new MyValue2.ref[len];</span>
<span class="line-modified">!         MyValue2.ref[] dst = new MyValue2.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
          }
          System.arraycopy(src, 0, dst, 0, src.length);
          for (int i = 0; i &lt; len; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1871,11 ***</span>
          test72(arr, true, elem);
          test72(arr, false, elem);
      }
  
      @Test
<span class="line-modified">!     public void test73(Object[] oa, MyValue1? v, Object o) {</span>
          // TestLWorld.test38 use a C1 Phi node for the array. This test
          // adds the case where the stored value is a C1 Phi node.
          Object o2 = (o == null) ? v : o;
          oa[0] = v;  // The stored value is known to be flattenable
          oa[1] = o;  // The stored value may be flattenable
<span class="line-new-header">--- 1871,11 ---</span>
          test72(arr, true, elem);
          test72(arr, false, elem);
      }
  
      @Test
<span class="line-modified">!     public void test73(Object[] oa, MyValue1.ref v, Object o) {</span>
          // TestLWorld.test38 use a C1 Phi node for the array. This test
          // adds the case where the stored value is a C1 Phi node.
          Object o2 = (o == null) ? v : o;
          oa[0] = v;  // The stored value is known to be flattenable
          oa[1] = o;  // The stored value may be flattenable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1883,13 ***</span>
          oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
      }
  
      @DontCompile
      public void test73_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1? v0 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1? v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);</span>
<span class="line-modified">!         MyValue1?[] arr = new MyValue1?[3];</span>
          try {
              test73(arr, v0, v1);
              throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
          } catch (ArrayStoreException t) {
              // expected
<span class="line-new-header">--- 1883,13 ---</span>
          oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
      }
  
      @DontCompile
      public void test73_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);</span>
<span class="line-modified">!         MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);</span>
<span class="line-modified">!         MyValue1.ref[] arr = new MyValue1.ref[3];</span>
          try {
              test73(arr, v0, v1);
              throw new RuntimeException(&quot;ArrayStoreException expected&quot;);
          } catch (ArrayStoreException t) {
              // expected
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1899,33 ***</span>
          Asserts.assertEQ(arr[2].hash(), v1.hash());
      }
  
      // Some more array clone tests
      @ForceInline
<span class="line-modified">!     public Object[] test74_helper(int i, MyValue1?[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = oa;
          } else {
              arr = va;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test74(MyValue1?[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test74_helper(i, va, oa);
          return arr.clone();
      }
  
      @DontCompile
      public void test74_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
          Integer[] oa = new Integer[len];
          for (int i = 1; i &lt; len; ++i) {
              oa[i] = new Integer(rI);
          }
          test74_helper(42, va, oa);
<span class="line-new-header">--- 1899,33 ---</span>
          Asserts.assertEQ(arr[2].hash(), v1.hash());
      }
  
      // Some more array clone tests
      @ForceInline
<span class="line-modified">!     public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = oa;
          } else {
              arr = va;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test74(MyValue1.ref[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test74_helper(i, va, oa);
          return arr.clone();
      }
  
      @DontCompile
      public void test74_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
          Integer[] oa = new Integer[len];
          for (int i = 1; i &lt; len; ++i) {
              oa[i] = new Integer(rI);
          }
          test74_helper(42, va, oa);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1937,34 ***</span>
              result[i] = null;
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test75_helper(int i, MyValue1?[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = va;
          } else {
              arr = oa;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test75(MyValue1?[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test75_helper(i, va, oa);
          return arr.clone();
      }
  
      @DontCompile
      public void test75_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[len];</span>
<span class="line-modified">!         MyValue1?[] verif = new MyValue1?[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Integer[] oa = new Integer[len];
<span class="line-new-header">--- 1937,34 ---</span>
              result[i] = null;
          }
      }
  
      @ForceInline
<span class="line-modified">!     public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {</span>
          Object[] arr = null;
          if (i == 10) {
              arr = va;
          } else {
              arr = oa;
          }
          return arr;
      }
  
      @Test
<span class="line-modified">!     public Object[] test75(MyValue1.ref[] va, Integer[] oa) {</span>
          int i = 0;
          for (; i &lt; 10; i++);
  
          Object[] arr = test75_helper(i, va, oa);
          return arr.clone();
      }
  
      @DontCompile
      public void test75_verifier(boolean warmup) {
          int len = Math.abs(rI) % 10;
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[len];</span>
<span class="line-modified">!         MyValue1.ref[] verif = new MyValue1.ref[len];</span>
          for (int i = 1; i &lt; len; ++i) {
              va[i] = testValue1;
              verif[i] = va[i];
          }
          Integer[] oa = new Integer[len];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1977,20 ***</span>
          }
      }
  
      // Test mixing nullable and non-nullable arrays
      @Test
<span class="line-modified">!     public Object[] test76(MyValue1[] vva, MyValue1?[] vba, MyValue1 vt, Object[] out, int n) {</span>
          Object[] result = null;
          if (n == 0) {
              result = vva;
          } else if (n == 1) {
              result = vba;
          } else if (n == 2) {
              result = new MyValue1[42];
          } else if (n == 3) {
<span class="line-modified">!             result = new MyValue1?[42];</span>
          }
          result[0] = vt;
          out[0] = result[1];
          return result;
      }
<span class="line-new-header">--- 1977,20 ---</span>
          }
      }
  
      // Test mixing nullable and non-nullable arrays
      @Test
<span class="line-modified">!     public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {</span>
          Object[] result = null;
          if (n == 0) {
              result = vva;
          } else if (n == 1) {
              result = vba;
          } else if (n == 2) {
              result = new MyValue1[42];
          } else if (n == 3) {
<span class="line-modified">!             result = new MyValue1.ref[42];</span>
          }
          result[0] = vt;
          out[0] = result[1];
          return result;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2000,12 ***</span>
          MyValue1 vt = testValue1;
          Object[] out = new Object[1];
          MyValue1[] vva = new MyValue1[42];
          MyValue1[] vva_r = new MyValue1[42];
          vva_r[0] = vt;
<span class="line-modified">!         MyValue1?[] vba = new MyValue1?[42];</span>
<span class="line-modified">!         MyValue1?[] vba_r = new MyValue1?[42];</span>
          vba_r[0] = vt;
          Object[] result = test76(vva, vba, vt, out, 0);
          verify(result, vva_r);
          Asserts.assertEQ(out[0], vva_r[1]);
          result = test76(vva, vba, vt, out, 1);
<span class="line-new-header">--- 2000,12 ---</span>
          MyValue1 vt = testValue1;
          Object[] out = new Object[1];
          MyValue1[] vva = new MyValue1[42];
          MyValue1[] vva_r = new MyValue1[42];
          vva_r[0] = vt;
<span class="line-modified">!         MyValue1.ref[] vba = new MyValue1.ref[42];</span>
<span class="line-modified">!         MyValue1.ref[] vba_r = new MyValue1.ref[42];</span>
          vba_r[0] = vt;
          Object[] result = test76(vva, vba, vt, out, 0);
          verify(result, vva_r);
          Asserts.assertEQ(out[0], vva_r[1]);
          result = test76(vva, vba, vt, out, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2021,11 ***</span>
  
      @Test
      public Object[] test77(boolean b) {
          Object[] va;
          if (b) {
<span class="line-modified">!             va = new MyValue1?[5];</span>
              for (int i = 0; i &lt; 5; ++i) {
                  va[i] = testValue1;
              }
          } else {
              va = new MyValue1[10];
<span class="line-new-header">--- 2021,11 ---</span>
  
      @Test
      public Object[] test77(boolean b) {
          Object[] va;
          if (b) {
<span class="line-modified">!             va = new MyValue1.ref[5];</span>
              for (int i = 0; i &lt; 5; ++i) {
                  va[i] = testValue1;
              }
          } else {
              va = new MyValue1[10];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2058,20 ***</span>
          }
      }
  
      // Same as test76 but with non value type array cases
      @Test
<span class="line-modified">!     public Object[] test78(MyValue1[] vva, MyValue1?[] vba, Object val, Object[] out, int n) {</span>
          Object[] result = null;
          if (n == 0) {
              result = vva;
          } else if (n == 1) {
              result = vba;
          } else if (n == 2) {
              result = new MyValue1[42];
          } else if (n == 3) {
<span class="line-modified">!             result = new MyValue1?[42];</span>
          } else if (n == 4) {
              result = new Integer[42];
          }
          result[0] = val;
          out[0] = result[1];
<span class="line-new-header">--- 2058,20 ---</span>
          }
      }
  
      // Same as test76 but with non value type array cases
      @Test
<span class="line-modified">!     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {</span>
          Object[] result = null;
          if (n == 0) {
              result = vva;
          } else if (n == 1) {
              result = vba;
          } else if (n == 2) {
              result = new MyValue1[42];
          } else if (n == 3) {
<span class="line-modified">!             result = new MyValue1.ref[42];</span>
          } else if (n == 4) {
              result = new Integer[42];
          }
          result[0] = val;
          out[0] = result[1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2084,12 ***</span>
          Integer i = new Integer(42);
          Object[] out = new Object[1];
          MyValue1[] vva = new MyValue1[42];
          MyValue1[] vva_r = new MyValue1[42];
          vva_r[0] = vt;
<span class="line-modified">!         MyValue1?[] vba = new MyValue1?[42];</span>
<span class="line-modified">!         MyValue1?[] vba_r = new MyValue1?[42];</span>
          vba_r[0] = vt;
          Object[] result = test78(vva, vba, vt, out, 0);
          verify(result, vva_r);
          Asserts.assertEQ(out[0], vva_r[1]);
          result = test78(vva, vba, vt, out, 1);
<span class="line-new-header">--- 2084,12 ---</span>
          Integer i = new Integer(42);
          Object[] out = new Object[1];
          MyValue1[] vva = new MyValue1[42];
          MyValue1[] vva_r = new MyValue1[42];
          vva_r[0] = vt;
<span class="line-modified">!         MyValue1.ref[] vba = new MyValue1.ref[42];</span>
<span class="line-modified">!         MyValue1.ref[] vba_r = new MyValue1.ref[42];</span>
          vba_r[0] = vt;
          Object[] result = test78(vva, vba, vt, out, 0);
          verify(result, vva_r);
          Asserts.assertEQ(out[0], vva_r[1]);
          result = test78(vva, vba, vt, out, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,19 ***</span>
          Asserts.assertEQ(out[0], null);
      }
  
      // Test widening conversions from [Q to [L
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public static MyValue1?[] test79(MyValue1[] va) {</span>
          return va;
      }
  
      @DontCompile
      public void test79_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
          va[0] = testValue1;
<span class="line-modified">!         MyValue1?[] res = test79(va);</span>
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          try {
              res[0] = null;
              throw new RuntimeException(&quot;NullPointerException expected&quot;);
          } catch (NullPointerException npe) {
<span class="line-new-header">--- 2106,19 ---</span>
          Asserts.assertEQ(out[0], null);
      }
  
      // Test widening conversions from [Q to [L
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public static MyValue1.ref[] test79(MyValue1[] va) {</span>
          return va;
      }
  
      @DontCompile
      public void test79_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
          va[0] = testValue1;
<span class="line-modified">!         MyValue1.ref[] res = test79(va);</span>
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          try {
              res[0] = null;
              throw new RuntimeException(&quot;NullPointerException expected&quot;);
          } catch (NullPointerException npe) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2129,11 ***</span>
      }
  
      // Same as test79 but with explicit cast and Object return
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public static Object[] test80(MyValue1[] va) {
<span class="line-modified">!         return (MyValue1?[])va;</span>
      }
  
      @DontCompile
      public void test80_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
<span class="line-new-header">--- 2129,11 ---</span>
      }
  
      // Same as test79 but with explicit cast and Object return
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
      public static Object[] test80(MyValue1[] va) {
<span class="line-modified">!         return (MyValue1.ref[])va;</span>
      }
  
      @DontCompile
      public void test80_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2150,12 ***</span>
          test80(null); // Should not throw NPE
      }
  
      // Test mixing widened and boxed array type
      @Test()
<span class="line-modified">!     public static long test81(MyValue1[] va1, MyValue1?[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {</span>
<span class="line-modified">!         MyValue1?[] result = b ? va1 : va2;</span>
          try {
              result[0] = vt;
          } catch (NullPointerException npe) {
              // Ignored
          }
<span class="line-new-header">--- 2150,12 ---</span>
          test80(null); // Should not throw NPE
      }
  
      // Test mixing widened and boxed array type
      @Test()
<span class="line-modified">!     public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {</span>
<span class="line-modified">!         MyValue1.ref[] result = b ? va1 : va2;</span>
          try {
              result[0] = vt;
          } catch (NullPointerException npe) {
              // Ignored
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2163,11 ***</span>
      }
  
      @DontCompile
      public void test81_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vaB = new MyValue1?[2];</span>
          va[1] = testValue1;
          vaB[1] = testValue1;
          long res = test81(va, vaB, testValue1, true, true);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res, testValue1.hash());
<span class="line-new-header">--- 2163,11 ---</span>
      }
  
      @DontCompile
      public void test81_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vaB = new MyValue1.ref[2];</span>
          va[1] = testValue1;
          vaB[1] = testValue1;
          long res = test81(va, vaB, testValue1, true, true);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res, testValue1.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2179,18 ***</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      // Same as test81 but more cases and null writes
      @Test()
<span class="line-modified">!     public static long test82(MyValue1[] va1, MyValue1?[] va2, MyValue1 vt1, MyValue1? vt2, int i, boolean shouldThrow) {</span>
<span class="line-modified">!         MyValue1?[] result = null;</span>
          if (i == 0) {
              result = va1;
          } else if (i == 1) {
              result = va2;
          } else if (i == 2) {
<span class="line-modified">!             result = new MyValue1?[2];</span>
              result[1] = vt1;
          } else if (i == 3) {
              result = new MyValue1[2];
              result[1] = vt1;
          }
<span class="line-new-header">--- 2179,18 ---</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      // Same as test81 but more cases and null writes
      @Test()
<span class="line-modified">!     public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {</span>
<span class="line-modified">!         MyValue1.ref[] result = null;</span>
          if (i == 0) {
              result = va1;
          } else if (i == 1) {
              result = va2;
          } else if (i == 2) {
<span class="line-modified">!             result = new MyValue1.ref[2];</span>
              result[1] = vt1;
          } else if (i == 3) {
              result = new MyValue1[2];
              result[1] = vt1;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2207,11 ***</span>
      }
  
      @DontCompile
      public void test82_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vaB = new MyValue1?[2];</span>
          va[1] = testValue1;
          vaB[1] = testValue1;
          long res = test82(va, vaB, testValue1, testValue1, 0, true);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res, testValue1.hash());
<span class="line-new-header">--- 2207,11 ---</span>
      }
  
      @DontCompile
      public void test82_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vaB = new MyValue1.ref[2];</span>
          va[1] = testValue1;
          vaB[1] = testValue1;
          long res = test82(va, vaB, testValue1, testValue1, 0, true);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res, testValue1.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2229,11 ***</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      @Test(failOn = ALLOC + ALLOCA + STORE)
      public static long test83(MyValue1[] va) {
<span class="line-modified">!         MyValue1?[] result = va;</span>
          return result[0].hash();
      }
  
      @DontCompile
      public void test83_verifier(boolean warmup) {
<span class="line-new-header">--- 2229,11 ---</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      @Test(failOn = ALLOC + ALLOCA + STORE)
      public static long test83(MyValue1[] va) {
<span class="line-modified">!         MyValue1.ref[] result = va;</span>
          return result[0].hash();
      }
  
      @DontCompile
      public void test83_verifier(boolean warmup) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2243,20 ***</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
      @Test(valid = ValueTypeArrayFlattenOff)
<span class="line-modified">!     public static MyValue1?[] test84(MyValue1 vt1, MyValue1? vt2) {</span>
<span class="line-modified">!         MyValue1?[] result = new MyValue1[2];</span>
          result[0] = vt1;
          result[1] = vt2;
          return result;
      }
  
      @DontCompile
      public void test84_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] res = test84(testValue1, testValue1);</span>
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          Asserts.assertEquals(res[1].hash(), testValue1.hash());
          try {
              test84(testValue1, null);
              throw new RuntimeException(&quot;NullPointerException expected&quot;);
<span class="line-new-header">--- 2243,20 ---</span>
          Asserts.assertEquals(res, testValue1.hash());
      }
  
      @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
      @Test(valid = ValueTypeArrayFlattenOff)
<span class="line-modified">!     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {</span>
<span class="line-modified">!         MyValue1.ref[] result = new MyValue1[2];</span>
          result[0] = vt1;
          result[1] = vt2;
          return result;
      }
  
      @DontCompile
      public void test84_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] res = test84(testValue1, testValue1);</span>
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          Asserts.assertEquals(res[1].hash(), testValue1.hash());
          try {
              test84(testValue1, null);
              throw new RuntimeException(&quot;NullPointerException expected&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2264,19 ***</span>
              // Expected
          }
      }
  
      @Test()
<span class="line-modified">!     public static long test85(MyValue1?[] va, MyValue1 val) {</span>
          va[0] = val;
          return va[1].hash();
      }
  
      @DontCompile
      public void test85_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[2];</span>
          va[1] = testValue1;
          vab[1] = testValue1;
          long res = test85(va, testValue1);
          Asserts.assertEquals(res, testValue1.hash());
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
<span class="line-new-header">--- 2264,19 ---</span>
              // Expected
          }
      }
  
      @Test()
<span class="line-modified">!     public static long test85(MyValue1.ref[] va, MyValue1 val) {</span>
          va[0] = val;
          return va[1].hash();
      }
  
      @DontCompile
      public void test85_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[2];</span>
          va[1] = testValue1;
          vab[1] = testValue1;
          long res = test85(va, testValue1);
          Asserts.assertEquals(res, testValue1.hash());
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2285,19 ***</span>
          Asserts.assertEquals(vab[0].hash(), testValue1.hash());
      }
  
      // Same as test85 but with box value
      @Test()
<span class="line-modified">!     public static long test86(MyValue1?[] va, MyValue1? val) {</span>
          va[0] = val;
          return va[1].hash();
      }
  
      @DontCompile
      public void test86_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[2];</span>
          va[1] = testValue1;
          vab[1] = testValue1;
          long res = test86(va, testValue1);
          Asserts.assertEquals(res, testValue1.hash());
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
<span class="line-new-header">--- 2285,19 ---</span>
          Asserts.assertEquals(vab[0].hash(), testValue1.hash());
      }
  
      // Same as test85 but with box value
      @Test()
<span class="line-modified">!     public static long test86(MyValue1.ref[] va, MyValue1.ref val) {</span>
          va[0] = val;
          return va[1].hash();
      }
  
      @DontCompile
      public void test86_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[2];</span>
          va[1] = testValue1;
          vab[1] = testValue1;
          long res = test86(va, testValue1);
          Asserts.assertEquals(res, testValue1.hash());
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2316,11 ***</span>
      }
  
      // Test initialization of nullable array with constant
      @Test()
      public long test87() {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
          va[0] = testValue1;
          return va[0].hash();
      }
  
      @DontCompile
<span class="line-new-header">--- 2316,11 ---</span>
      }
  
      // Test initialization of nullable array with constant
      @Test()
      public long test87() {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
          va[0] = testValue1;
          return va[0].hash();
      }
  
      @DontCompile
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2329,11 ***</span>
          Asserts.assertEQ(result, hash());
      }
  
      // Test narrowing conversion from [L to [Q
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public static MyValue1[] test88(MyValue1?[] va) {</span>
          return (MyValue1[])va;
      }
  
      @DontCompile
      public void test88_verifier(boolean warmup) {
<span class="line-new-header">--- 2329,11 ---</span>
          Asserts.assertEQ(result, hash());
      }
  
      // Test narrowing conversion from [L to [Q
      @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
<span class="line-modified">!     public static MyValue1[] test88(MyValue1.ref[] va) {</span>
          return (MyValue1[])va;
      }
  
      @DontCompile
      public void test88_verifier(boolean warmup) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2342,11 ***</span>
          MyValue1[] res = test88(va);
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          res[0] = testValue1;
          test88(null); // Should not throw NPE
          try {
<span class="line-modified">!             test88(new MyValue1?[1]);</span>
              throw new RuntimeException(&quot;ClassCastException expected&quot;);
          } catch (ClassCastException cce) {
              // Expected
          }
      }
<span class="line-new-header">--- 2342,11 ---</span>
          MyValue1[] res = test88(va);
          Asserts.assertEquals(res[0].hash(), testValue1.hash());
          res[0] = testValue1;
          test88(null); // Should not throw NPE
          try {
<span class="line-modified">!             test88(new MyValue1.ref[1]);</span>
              throw new RuntimeException(&quot;ClassCastException expected&quot;);
          } catch (ClassCastException cce) {
              // Expected
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2364,27 ***</span>
          MyValue1[] res = test89(va);
          Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
          res[0] = testValue1;
          test89(null); // Should not throw NPE
          try {
<span class="line-modified">!             test89(new MyValue1?[1]);</span>
              throw new RuntimeException(&quot;ClassCastException expected&quot;);
          } catch (ClassCastException cce) {
              // Expected
          }
      }
  
      // More cast tests
      @Test()
<span class="line-modified">!     public static MyValue1?[] test90(Object va) {</span>
<span class="line-modified">!         return (MyValue1?[])va;</span>
      }
  
      @DontCompile
      public void test90_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[1];</span>
          try {
            // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
            test90(new Integer[0]);
          } catch (ClassCastException cce) {
            // Expected
<span class="line-new-header">--- 2364,27 ---</span>
          MyValue1[] res = test89(va);
          Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
          res[0] = testValue1;
          test89(null); // Should not throw NPE
          try {
<span class="line-modified">!             test89(new MyValue1.ref[1]);</span>
              throw new RuntimeException(&quot;ClassCastException expected&quot;);
          } catch (ClassCastException cce) {
              // Expected
          }
      }
  
      // More cast tests
      @Test()
<span class="line-modified">!     public static MyValue1.ref[] test90(Object va) {</span>
<span class="line-modified">!         return (MyValue1.ref[])va;</span>
      }
  
      @DontCompile
      public void test90_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[1];</span>
          try {
            // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
            test90(new Integer[0]);
          } catch (ClassCastException cce) {
            // Expected
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2393,18 ***</span>
          test90(vab);
          test90(null);
      }
  
      @Test()
<span class="line-modified">!     public static MyValue1?[] test91(Object[] va) {</span>
<span class="line-modified">!         return (MyValue1?[])va;</span>
      }
  
      @DontCompile
      public void test91_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[1];</span>
          try {
            // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
            test91(new Integer[0]);
          } catch (ClassCastException cce) {
            // Expected
<span class="line-new-header">--- 2393,18 ---</span>
          test90(vab);
          test90(null);
      }
  
      @Test()
<span class="line-modified">!     public static MyValue1.ref[] test91(Object[] va) {</span>
<span class="line-modified">!         return (MyValue1.ref[])va;</span>
      }
  
      @DontCompile
      public void test91_verifier(boolean warmup) {
          MyValue1[] va = new MyValue1[1];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[1];</span>
          try {
            // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
            test91(new Integer[0]);
          } catch (ClassCastException cce) {
            // Expected
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2414,34 ***</span>
          test91(null);
      }
  
      // Test if arraycopy intrinsic correctly checks for flattened source array
      @Test()
<span class="line-modified">!     public static void test92(MyValue1?[] src, MyValue1?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 2);
      }
  
      @DontCompile
      public void test92_verifier(boolean warmup) {
          MyValue1[]  va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[2];</span>
          va[0] = testValue1;
          vab[0] = testValue1;
          test92(va, vab);
          Asserts.assertEquals(va[0], vab[0]);
          Asserts.assertEquals(va[1], vab[1]);
      }
  
      @Test()
<span class="line-modified">!     public static void test93(Object src, MyValue1?[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 2);
      }
  
      @DontCompile
      public void test93_verifier(boolean warmup) {
          MyValue1[]  va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] vab = new MyValue1?[2];</span>
          va[0] = testValue1;
          vab[0] = testValue1;
          test93(va, vab);
          Asserts.assertEquals(va[0], vab[0]);
          Asserts.assertEquals(va[1], vab[1]);
<span class="line-new-header">--- 2414,34 ---</span>
          test91(null);
      }
  
      // Test if arraycopy intrinsic correctly checks for flattened source array
      @Test()
<span class="line-modified">!     public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 2);
      }
  
      @DontCompile
      public void test92_verifier(boolean warmup) {
          MyValue1[]  va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[2];</span>
          va[0] = testValue1;
          vab[0] = testValue1;
          test92(va, vab);
          Asserts.assertEquals(va[0], vab[0]);
          Asserts.assertEquals(va[1], vab[1]);
      }
  
      @Test()
<span class="line-modified">!     public static void test93(Object src, MyValue1.ref[] dst) {</span>
          System.arraycopy(src, 0, dst, 0, 2);
      }
  
      @DontCompile
      public void test93_verifier(boolean warmup) {
          MyValue1[]  va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] vab = new MyValue1.ref[2];</span>
          va[0] = testValue1;
          vab[0] = testValue1;
          test93(va, vab);
          Asserts.assertEquals(va[0], vab[0]);
          Asserts.assertEquals(va[1], vab[1]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2449,11 ***</span>
  
      // Test non-escaping allocation with arraycopy
      // that does not modify loaded array element.
      @Test()
      public static long test94() {
<span class="line-modified">!         MyValue1?[] src = new MyValue1?[8];</span>
          MyValue1[]  dst = new MyValue1[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = testValue1;
          }
          System.arraycopy(src, 1, dst, 2, 6);
<span class="line-new-header">--- 2449,11 ---</span>
  
      // Test non-escaping allocation with arraycopy
      // that does not modify loaded array element.
      @Test()
      public static long test94() {
<span class="line-modified">!         MyValue1.ref[] src = new MyValue1.ref[8];</span>
          MyValue1[]  dst = new MyValue1[8];
          for (int i = 1; i &lt; 8; ++i) {
              src[i] = testValue1;
          }
          System.arraycopy(src, 1, dst, 2, 6);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2467,11 ***</span>
      }
  
      // Test meeting constant TypeInstPtr with ValueTypeNode
      @ForceInline
      public long test95_callee() {
<span class="line-modified">!         MyValue1?[] va = new MyValue1?[1];</span>
          va[0] = testValue1;
          return va[0].hashInterpreted();
      }
  
      @Test()
<span class="line-new-header">--- 2467,11 ---</span>
      }
  
      // Test meeting constant TypeInstPtr with ValueTypeNode
      @ForceInline
      public long test95_callee() {
<span class="line-modified">!         MyValue1.ref[] va = new MyValue1.ref[1];</span>
          va[0] = testValue1;
          return va[0].hashInterpreted();
      }
  
      @Test()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2505,27 ***</span>
                                 this.re * that.im + this.im * that.re);
          }
      }
  
      @Test()
<span class="line-modified">!     public Complex?[][] test96(Complex?[][] A, Complex?[][] B) {</span>
          int size = A.length;
<span class="line-modified">!         Complex?[][] R = new Complex?[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex? aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
          return R;
      }
  
<span class="line-modified">!     static Complex?[][] test96_A = new Complex?[10][10];</span>
<span class="line-modified">!     static Complex?[][] test96_B = new Complex?[10][10];</span>
<span class="line-modified">!     static Complex?[][] test96_R;</span>
  
      static {
          for (int i = 0; i &lt; 10; i++) {
              for (int j = 0; j &lt; 10; j++) {
                  test96_A[i][j] = new Complex(rI, rI);
<span class="line-new-header">--- 2505,27 ---</span>
                                 this.re * that.im + this.im * that.re);
          }
      }
  
      @Test()
<span class="line-modified">!     public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {</span>
          int size = A.length;
<span class="line-modified">!         Complex.ref[][] R = new Complex.ref[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex.ref aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
          return R;
      }
  
<span class="line-modified">!     static Complex.ref[][] test96_A = new Complex.ref[10][10];</span>
<span class="line-modified">!     static Complex.ref[][] test96_B = new Complex.ref[10][10];</span>
<span class="line-modified">!     static Complex.ref[][] test96_R;</span>
  
      static {
          for (int i = 0; i &lt; 10; i++) {
              for (int j = 0; j &lt; 10; j++) {
                  test96_A[i][j] = new Complex(rI, rI);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2534,11 ***</span>
          }
      }
  
      @DontCompile
      public void test96_verifier(boolean warmup) {
<span class="line-modified">!         Complex?[][] result = test96(test96_A, test96_B);</span>
          if (test96_R == null) {
              test96_R = result;
          }
          for (int i = 0; i &lt; 10; i++) {
              for (int j = 0; j &lt; 10; j++) {
<span class="line-new-header">--- 2534,11 ---</span>
          }
      }
  
      @DontCompile
      public void test96_verifier(boolean warmup) {
<span class="line-modified">!         Complex.ref[][] result = test96(test96_A, test96_B);</span>
          if (test96_R == null) {
              test96_R = result;
          }
          for (int i = 0; i &lt; 10; i++) {
              for (int j = 0; j &lt; 10; j++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2578,11 ***</span>
          myInt[0] = rI;
          result = test98((Object[])myInt);
          Asserts.assertEquals(result, rI);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1?[] vab = new MyValue1?[1];</span>
              result = test98((Object[])va);
              Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
              result = test98((Object[])vab);
              Asserts.assertEquals(result, null);
          }
<span class="line-new-header">--- 2578,11 ---</span>
          myInt[0] = rI;
          result = test98((Object[])myInt);
          Asserts.assertEquals(result, rI);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1.ref[] vab = new MyValue1.ref[1];</span>
              result = test98((Object[])va);
              Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
              result = test98((Object[])vab);
              Asserts.assertEquals(result, null);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2667,11 ***</span>
          Asserts.assertEquals(myInt[0], rI);
          test102(null, (Object[])myInt);
          Asserts.assertEquals(myInt[0], null);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1?[] vab = new MyValue1?[1];</span>
              test102(testValue1, (Object[])va);
              Asserts.assertEquals(va[0].hash(), testValue1.hash());
              test102(testValue1, (Object[])vab);
              Asserts.assertEquals(vab[0].hash(), testValue1.hash());
              test102(null, (Object[])vab);
<span class="line-new-header">--- 2667,11 ---</span>
          Asserts.assertEquals(myInt[0], rI);
          test102(null, (Object[])myInt);
          Asserts.assertEquals(myInt[0], null);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1.ref[] vab = new MyValue1.ref[1];</span>
              test102(testValue1, (Object[])va);
              Asserts.assertEquals(va[0].hash(), testValue1.hash());
              test102(testValue1, (Object[])vab);
              Asserts.assertEquals(vab[0].hash(), testValue1.hash());
              test102(null, (Object[])vab);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2777,30 ***</span>
          myInt[0] = rI;
          result = test106(myInt, (Object[])myInt);
          Asserts.assertEquals(result[0], rI);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1?[] vab = new MyValue1?[1];</span>
              result = test106(va, (Object[])va);
              Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
              result = test106(vab, (Object[])vab);
              Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
          }
      }
  
      // Test that allocation is not replaced by non-dominating allocation
<span class="line-modified">!     public long test107_helper(MyValue1?[] va, MyValue1 vt) {</span>
          try {
              va[0] = vt;
          } catch (NullPointerException npe) { }
          return va[1].hash();
      }
  
      @Test()
      public void test107() {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1?[] tmp = new MyValue1?[2];</span>
          long res1 = test107_helper(va, testValue1);
          long res2 = test107_helper(va, testValue1);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res1, MyValue1.default.hash());
          Asserts.assertEquals(res2, MyValue1.default.hash());
<span class="line-new-header">--- 2777,30 ---</span>
          myInt[0] = rI;
          result = test106(myInt, (Object[])myInt);
          Asserts.assertEquals(result[0], rI);
          if (!warmup) {
              MyValue1[] va = new MyValue1[1];
<span class="line-modified">!             MyValue1.ref[] vab = new MyValue1.ref[1];</span>
              result = test106(va, (Object[])va);
              Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
              result = test106(vab, (Object[])vab);
              Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
          }
      }
  
      // Test that allocation is not replaced by non-dominating allocation
<span class="line-modified">!     public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {</span>
          try {
              va[0] = vt;
          } catch (NullPointerException npe) { }
          return va[1].hash();
      }
  
      @Test()
      public void test107() {
          MyValue1[] va = new MyValue1[2];
<span class="line-modified">!         MyValue1.ref[] tmp = new MyValue1.ref[2];</span>
          long res1 = test107_helper(va, testValue1);
          long res2 = test107_helper(va, testValue1);
          Asserts.assertEquals(va[0].hash(), testValue1.hash());
          Asserts.assertEquals(res1, MyValue1.default.hash());
          Asserts.assertEquals(res2, MyValue1.default.hash());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2812,19 ***</span>
      }
  
  
      @Test
      @Warmup(10000)
<span class="line-modified">!     public Object test108(MyValue1?[] src, boolean flag) {</span>
<span class="line-modified">!         MyValue1?[] dst = new MyValue1?[8];</span>
          System.arraycopy(src, 1, dst, 2, 6);
          if (flag) {} // uncommon trap
          return dst[2];
      }
  
      @DontCompile
      public void test108_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1?[] src = new MyValue1?[8];</span>
          test108(src, !warmup);
      }
  
  }
<span class="line-new-header">--- 2812,19 ---</span>
      }
  
  
      @Test
      @Warmup(10000)
<span class="line-modified">!     public Object test108(MyValue1.ref[] src, boolean flag) {</span>
<span class="line-modified">!         MyValue1.ref[] dst = new MyValue1.ref[8];</span>
          System.arraycopy(src, 1, dst, 2, 6);
          if (flag) {} // uncommon trap
          return dst[2];
      }
  
      @DontCompile
      public void test108_verifier(boolean warmup) {
<span class="line-modified">!         MyValue1.ref[] src = new MyValue1.ref[8];</span>
          test108(src, !warmup);
      }
  
  }
</pre>
<center><a href="TestLWorldProfiling.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestNullableValueTypes.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
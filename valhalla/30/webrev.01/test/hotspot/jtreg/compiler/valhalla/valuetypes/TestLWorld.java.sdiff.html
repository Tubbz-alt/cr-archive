<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestIntrinsics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 100         vt = (MyValue1)test1_inline1(vt);
 101         vt =           test1_inline2(vt);
 102         return vt;
 103     }
 104 
 105     @DontCompile
 106     public void test1_verifier(boolean warmup) {
 107         Asserts.assertEQ(test1().hash(), hash());
 108     }
 109 
 110     // Test storing/loading value types to/from Object and value type fields
 111     Object objectField1 = null;
 112     Object objectField2 = null;
 113     Object objectField3 = null;
 114     Object objectField4 = null;
 115     Object objectField5 = null;
 116     Object objectField6 = null;
 117 
 118     MyValue1 valueField1 = testValue1;
 119     MyValue1 valueField2 = testValue1;
<span class="line-modified"> 120     MyValue1? valueField3 = testValue1;</span>
 121     MyValue1 valueField4;
<span class="line-modified"> 122     MyValue1? valueField5;</span>
 123 
<span class="line-modified"> 124     static MyValue1? staticValueField1 = testValue1;</span>
 125     static MyValue1 staticValueField2 = testValue1;
 126     static MyValue1 staticValueField3;
<span class="line-modified"> 127     static MyValue1? staticValueField4;</span>
 128 
 129     @DontInline
 130     public Object readValueField5() {
 131         return (Object)valueField5;
 132     }
 133 
 134     @DontInline
 135     public Object readStaticValueField4() {
 136         return (Object)staticValueField4;
 137     }
 138 
 139     @Test()
 140     public long test2(MyValue1 vt1, Object vt2) {
 141         objectField1 = vt1;
 142         objectField2 = (MyValue1)vt2;
 143         objectField3 = testValue1;
 144         objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 145         objectField5 = valueField1;
 146         objectField6 = valueField3;
 147         valueField1 = (MyValue1)objectField1;
</pre>
<hr />
<pre>
1216 
1217     // Test for bug in Escape Analysis
1218     @DontInline
1219     public void test41_dontinline(Object o) {
1220         Asserts.assertEQ(o, rI);
1221     }
1222 
1223     @Test()
1224     public void test41() {
1225         MyValue1[] vals = new MyValue1[] {testValue1};
1226         test41_dontinline(vals[0].oa[0]);
1227         test41_dontinline(vals[0].oa[0]);
1228     }
1229 
1230     @DontCompile
1231     public void test41_verifier(boolean warmup) {
1232         test41();
1233     }
1234 
1235     // Test for bug in Escape Analysis
<span class="line-modified">1236     private static final MyValue1? test42VT1 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-modified">1237     private static final MyValue1? test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
1238 
1239     @Test()
1240     public void test42() {
1241         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1242         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1243         Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1244     }
1245 
1246     @DontCompile
1247     public void test42_verifier(boolean warmup) {
1248         if (!warmup) test42(); // We need -Xcomp behavior
1249     }
1250 
1251     // Test for bug in Escape Analysis
1252     @Test()
1253     public long test43(boolean deopt) {
1254         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1255 
1256         if (deopt) {
1257             // uncommon trap
</pre>
<hr />
<pre>
1377         return obj instanceof MyValue1;
1378     }
1379 
1380     @DontCompile
1381     public void test50_verifier(boolean warmup) {
1382         boolean result = test49(new Integer(42));
1383         Asserts.assertFalse(result);
1384     }
1385 
1386     // Value type with some non-flattened fields
1387     final inline class Test51Value {
1388         final Object objectField1;
1389         final Object objectField2;
1390         final Object objectField3;
1391         final Object objectField4;
1392         final Object objectField5;
1393         final Object objectField6;
1394 
1395         final MyValue1 valueField1;
1396         final MyValue1 valueField2;
<span class="line-modified">1397         final MyValue1? valueField3;</span>
1398         final MyValue1 valueField4;
<span class="line-modified">1399         final MyValue1? valueField5;</span>
1400 
1401         public Test51Value() {
1402             objectField1 = null;
1403             objectField2 = null;
1404             objectField3 = null;
1405             objectField4 = null;
1406             objectField5 = null;
1407             objectField6 = null;
1408             valueField1 = testValue1;
1409             valueField2 = testValue1;
1410             valueField3 = testValue1;
1411             valueField4 = MyValue1.createDefaultDontInline();
1412             valueField5 = MyValue1.createDefaultDontInline();
1413         }
1414 
1415         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
<span class="line-modified">1416                            MyValue1 vt1, MyValue1 vt2, MyValue1? vt3, MyValue1 vt4, MyValue1? vt5) {</span>
1417             objectField1 = o1;
1418             objectField2 = o2;
1419             objectField3 = o3;
1420             objectField4 = o4;
1421             objectField5 = o5;
1422             objectField6 = o6;
1423             valueField1 = vt1;
1424             valueField2 = vt2;
1425             valueField3 = vt3;
1426             valueField4 = vt4;
1427             valueField5 = vt5;
1428         }
1429 
1430         @ForceInline
1431         public long test(Test51Value holder, MyValue1 vt1, Object vt2) {
1432             holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1433                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1434             holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1435                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1436             holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,
</pre>
<hr />
<pre>
1929 
1930     @Test
1931     public MyValue1 test77(Integer i) throws Throwable {
1932         return test77_helper(i);
1933     }
1934 
1935     @DontCompile
1936     public void test77_verifier(boolean warmup) throws Throwable {
1937         try {
1938             test77(new Integer(42));
1939             throw new RuntimeException(&quot;ClassCastException expected&quot;);
1940         } catch (ClassCastException e) {
1941             // Expected
1942         } catch (Exception e) {
1943             throw new RuntimeException(&quot;test77 failed: unexpected exception&quot;, e);
1944         }
1945     }
1946 
1947     // Casting a null Integer to a nullable value type should not throw
1948     @ForceInline
<span class="line-modified">1949     public MyValue1? test78_helper(Object o) {</span>
<span class="line-modified">1950         return (MyValue1?)o;</span>
1951     }
1952 
1953     @Test
<span class="line-modified">1954     public MyValue1? test78(Integer i) throws Throwable {</span>
1955         return test78_helper(i);
1956     }
1957 
1958     @DontCompile
1959     public void test78_verifier(boolean warmup) throws Throwable {
1960         try {
1961             test78(null); // Should not throw
1962         } catch (Exception e) {
1963             throw new RuntimeException(&quot;test78 failed: unexpected exception&quot;, e);
1964         }
1965     }
1966 
1967     // Casting an Integer to a nullable value type should throw a ClassCastException
1968     @ForceInline
<span class="line-modified">1969     public MyValue1? test79_helper(Object o) {</span>
<span class="line-modified">1970         return (MyValue1?)o;</span>
1971     }
1972 
1973     @Test
<span class="line-modified">1974     public MyValue1? test79(Integer i) throws Throwable {</span>
1975         return test79_helper(i);
1976     }
1977 
1978     @DontCompile
1979     public void test79_verifier(boolean warmup) throws Throwable {
1980         try {
1981             test79(new Integer(42));
1982             throw new RuntimeException(&quot;ClassCastException expected&quot;);
1983         } catch (ClassCastException e) {
1984             // Expected
1985         } catch (Exception e) {
1986             throw new RuntimeException(&quot;test79 failed: unexpected exception&quot;, e);
1987         }
1988     }
1989 
1990     // Test flattened field with non-flattenend (but flattenable) value type field
1991     static inline class Small {
1992         final int i;
1993         final Big big; // Too big to be flattened
1994 
</pre>
</td>
<td>
<hr />
<pre>
 100         vt = (MyValue1)test1_inline1(vt);
 101         vt =           test1_inline2(vt);
 102         return vt;
 103     }
 104 
 105     @DontCompile
 106     public void test1_verifier(boolean warmup) {
 107         Asserts.assertEQ(test1().hash(), hash());
 108     }
 109 
 110     // Test storing/loading value types to/from Object and value type fields
 111     Object objectField1 = null;
 112     Object objectField2 = null;
 113     Object objectField3 = null;
 114     Object objectField4 = null;
 115     Object objectField5 = null;
 116     Object objectField6 = null;
 117 
 118     MyValue1 valueField1 = testValue1;
 119     MyValue1 valueField2 = testValue1;
<span class="line-modified"> 120     MyValue1.ref valueField3 = testValue1;</span>
 121     MyValue1 valueField4;
<span class="line-modified"> 122     MyValue1.ref valueField5;</span>
 123 
<span class="line-modified"> 124     static MyValue1.ref staticValueField1 = testValue1;</span>
 125     static MyValue1 staticValueField2 = testValue1;
 126     static MyValue1 staticValueField3;
<span class="line-modified"> 127     static MyValue1.ref staticValueField4;</span>
 128 
 129     @DontInline
 130     public Object readValueField5() {
 131         return (Object)valueField5;
 132     }
 133 
 134     @DontInline
 135     public Object readStaticValueField4() {
 136         return (Object)staticValueField4;
 137     }
 138 
 139     @Test()
 140     public long test2(MyValue1 vt1, Object vt2) {
 141         objectField1 = vt1;
 142         objectField2 = (MyValue1)vt2;
 143         objectField3 = testValue1;
 144         objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);
 145         objectField5 = valueField1;
 146         objectField6 = valueField3;
 147         valueField1 = (MyValue1)objectField1;
</pre>
<hr />
<pre>
1216 
1217     // Test for bug in Escape Analysis
1218     @DontInline
1219     public void test41_dontinline(Object o) {
1220         Asserts.assertEQ(o, rI);
1221     }
1222 
1223     @Test()
1224     public void test41() {
1225         MyValue1[] vals = new MyValue1[] {testValue1};
1226         test41_dontinline(vals[0].oa[0]);
1227         test41_dontinline(vals[0].oa[0]);
1228     }
1229 
1230     @DontCompile
1231     public void test41_verifier(boolean warmup) {
1232         test41();
1233     }
1234 
1235     // Test for bug in Escape Analysis
<span class="line-modified">1236     private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);</span>
<span class="line-modified">1237     private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);</span>
1238 
1239     @Test()
1240     public void test42() {
1241         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1242         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
1243         Asserts.assertEQ(vals[1].hash(), test42VT2.hash());
1244     }
1245 
1246     @DontCompile
1247     public void test42_verifier(boolean warmup) {
1248         if (!warmup) test42(); // We need -Xcomp behavior
1249     }
1250 
1251     // Test for bug in Escape Analysis
1252     @Test()
1253     public long test43(boolean deopt) {
1254         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
1255 
1256         if (deopt) {
1257             // uncommon trap
</pre>
<hr />
<pre>
1377         return obj instanceof MyValue1;
1378     }
1379 
1380     @DontCompile
1381     public void test50_verifier(boolean warmup) {
1382         boolean result = test49(new Integer(42));
1383         Asserts.assertFalse(result);
1384     }
1385 
1386     // Value type with some non-flattened fields
1387     final inline class Test51Value {
1388         final Object objectField1;
1389         final Object objectField2;
1390         final Object objectField3;
1391         final Object objectField4;
1392         final Object objectField5;
1393         final Object objectField6;
1394 
1395         final MyValue1 valueField1;
1396         final MyValue1 valueField2;
<span class="line-modified">1397         final MyValue1.ref valueField3;</span>
1398         final MyValue1 valueField4;
<span class="line-modified">1399         final MyValue1.ref valueField5;</span>
1400 
1401         public Test51Value() {
1402             objectField1 = null;
1403             objectField2 = null;
1404             objectField3 = null;
1405             objectField4 = null;
1406             objectField5 = null;
1407             objectField6 = null;
1408             valueField1 = testValue1;
1409             valueField2 = testValue1;
1410             valueField3 = testValue1;
1411             valueField4 = MyValue1.createDefaultDontInline();
1412             valueField5 = MyValue1.createDefaultDontInline();
1413         }
1414 
1415         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
<span class="line-modified">1416                            MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {</span>
1417             objectField1 = o1;
1418             objectField2 = o2;
1419             objectField3 = o3;
1420             objectField4 = o4;
1421             objectField5 = o5;
1422             objectField6 = o6;
1423             valueField1 = vt1;
1424             valueField2 = vt2;
1425             valueField3 = vt3;
1426             valueField4 = vt4;
1427             valueField5 = vt5;
1428         }
1429 
1430         @ForceInline
1431         public long test(Test51Value holder, MyValue1 vt1, Object vt2) {
1432             holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1433                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1434             holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,
1435                                      holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);
1436             holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,
</pre>
<hr />
<pre>
1929 
1930     @Test
1931     public MyValue1 test77(Integer i) throws Throwable {
1932         return test77_helper(i);
1933     }
1934 
1935     @DontCompile
1936     public void test77_verifier(boolean warmup) throws Throwable {
1937         try {
1938             test77(new Integer(42));
1939             throw new RuntimeException(&quot;ClassCastException expected&quot;);
1940         } catch (ClassCastException e) {
1941             // Expected
1942         } catch (Exception e) {
1943             throw new RuntimeException(&quot;test77 failed: unexpected exception&quot;, e);
1944         }
1945     }
1946 
1947     // Casting a null Integer to a nullable value type should not throw
1948     @ForceInline
<span class="line-modified">1949     public MyValue1.ref test78_helper(Object o) {</span>
<span class="line-modified">1950         return (MyValue1.ref)o;</span>
1951     }
1952 
1953     @Test
<span class="line-modified">1954     public MyValue1.ref test78(Integer i) throws Throwable {</span>
1955         return test78_helper(i);
1956     }
1957 
1958     @DontCompile
1959     public void test78_verifier(boolean warmup) throws Throwable {
1960         try {
1961             test78(null); // Should not throw
1962         } catch (Exception e) {
1963             throw new RuntimeException(&quot;test78 failed: unexpected exception&quot;, e);
1964         }
1965     }
1966 
1967     // Casting an Integer to a nullable value type should throw a ClassCastException
1968     @ForceInline
<span class="line-modified">1969     public MyValue1.ref test79_helper(Object o) {</span>
<span class="line-modified">1970         return (MyValue1.ref)o;</span>
1971     }
1972 
1973     @Test
<span class="line-modified">1974     public MyValue1.ref test79(Integer i) throws Throwable {</span>
1975         return test79_helper(i);
1976     }
1977 
1978     @DontCompile
1979     public void test79_verifier(boolean warmup) throws Throwable {
1980         try {
1981             test79(new Integer(42));
1982             throw new RuntimeException(&quot;ClassCastException expected&quot;);
1983         } catch (ClassCastException e) {
1984             // Expected
1985         } catch (Exception e) {
1986             throw new RuntimeException(&quot;test79 failed: unexpected exception&quot;, e);
1987         }
1988     }
1989 
1990     // Test flattened field with non-flattenend (but flattenable) value type field
1991     static inline class Small {
1992         final int i;
1993         final Big big; // Too big to be flattened
1994 
</pre>
</td>
</tr>
</table>
<center><a href="TestIntrinsics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TestLWorldProfiling.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
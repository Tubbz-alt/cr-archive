diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrayAccessDeopt.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrayAccessDeopt.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrayAccessDeopt.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrayAccessDeopt.java
@@ -41,19 +41,19 @@
 
     public static void test1(Object[] va, Object vt) {
         va[0] = vt;
     }
 
-    public static void test2(Object[] va, MyValue1? vt) {
+    public static void test2(Object[] va, MyValue1.ref vt) {
         va[0] = vt;
     }
 
-    public static void test3(MyValue1?[] va, Object vt) {
-        va[0] = (MyValue1?)vt;
+    public static void test3(MyValue1.ref[] va, Object vt) {
+        va[0] = (MyValue1.ref)vt;
     }
 
-    public static void test4(MyValue1?[] va, MyValue1? vt) {
+    public static void test4(MyValue1.ref[] va, MyValue1.ref vt) {
         va[0] = vt;
     }
 
     public static void test5(Object[] va, MyValue1 vt) {
         va[0] = vt;
@@ -65,23 +65,23 @@
 
     public static void test7(MyValue1[] va, MyValue1 vt) {
         va[0] = vt;
     }
 
-    public static void test8(MyValue1?[] va, MyValue1 vt) {
+    public static void test8(MyValue1.ref[] va, MyValue1 vt) {
         va[0] = vt;
     }
 
-    public static void test9(MyValue1[] va, MyValue1? vt) {
+    public static void test9(MyValue1[] va, MyValue1.ref vt) {
         va[0] = (MyValue1)vt;
     }
 
     public static void test10(Object[] va) {
         va[0] = null;
     }
 
-    public static void test11(MyValue1?[] va) {
+    public static void test11(MyValue1.ref[] va) {
         va[0] = null;
     }
 
     static public void main(String[] args) throws Exception {
         if (args.length == 0) {
@@ -91,11 +91,11 @@
             OutputAnalyzer oa = ProcessTools.executeTestJvm(arg);
             String output = oa.getOutput();
             oa.shouldNotContain("Uncommon trap occurred");
         } else {
             MyValue1[] va = new MyValue1[1];
-            MyValue1?[] vaB = new MyValue1?[1];
+            MyValue1.ref[] vaB = new MyValue1.ref[1];
             MyValue1 vt = new MyValue1();
             for (int i = 0; i < 10_000; ++i) {
                 test1(va, vt);
                 test1(vaB, vt);
                 test1(vaB, null);
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
@@ -1249,11 +1249,12 @@
         }
     }
 
     @Test
     public MyValue1[] test51(MyValue1[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1[].class);
+        // TODO Remove cast as workaround once javac is fixed
+        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test51_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
@@ -1267,11 +1268,12 @@
 
     static final MyValue1[] test52_va = new MyValue1[8];
 
     @Test
     public MyValue1[] test52() {
-        return Arrays.copyOf(test52_va, 8, MyValue1[].class);
+        // TODO Remove cast as workaround once javac is fixed
+        return (MyValue1[])Arrays.copyOf(test52_va, 8, MyValue1[].class);
     }
 
     @DontCompile
     public void test52_verifier(boolean warmup) {
         for (int i = 0; i < 8; ++i) {
@@ -1281,11 +1283,12 @@
         verify(test52_va, result);
     }
 
     @Test
     public MyValue1[] test53(Object[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1[].class);
+        // TODO Remove cast as workaround once javac is fixed
+        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test53_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
@@ -1329,11 +1332,12 @@
         verify(va, result);
     }
 
     @Test
     public MyValue1[] test56(Object[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1[].class);
+        // TODO Remove cast as workaround once javac is fixed
+        return (MyValue1[])Arrays.copyOf(va, va.length, MyValue1[].class);
     }
 
     @DontCompile
     public void test56_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
@@ -1965,11 +1969,11 @@
         return array[i];
     }
 
     @DontCompile
     public void test84_verifier(boolean warmup) {
-        NotFlattenable?[] array1 = new NotFlattenable?[2];
+        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
         Object[] array2 = new Object[2];
         Object result = test84(array1, 0);
         Asserts.assertEquals(array1[0], null);
         Asserts.assertEquals(result, null);
         result = test84(array2, 1);
@@ -2021,11 +2025,11 @@
         }
     }
 
     // Same as test85 but with not-flattenable inline type array
     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
-    public void test86(NotFlattenable?[] array, NotFlattenable? o, boolean b) {
+    public void test86(NotFlattenable.ref[] array, NotFlattenable.ref o, boolean b) {
         if (b) {
             array[0] = null;
         } else {
             array[1] = null;
         }
@@ -2033,11 +2037,11 @@
     }
 
     @DontCompile
     public void test86_verifier(boolean warmup) {
         NotFlattenable vt = new NotFlattenable();
-        NotFlattenable?[] array1 = new NotFlattenable?[2];
+        NotFlattenable.ref[] array1 = new NotFlattenable.ref[2];
         test86(array1, vt, true);
         Asserts.assertEquals(array1[1], vt);
         test86(array1, null, false);
         Asserts.assertEquals(array1[1], null);
         if (!warmup) {
@@ -2051,11 +2055,11 @@
         }
     }
 
     // Same as test85 but with inline type array
     @Test(failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE, match = { VALUE_ARRAY_NULL_GUARD }, matchCount = { 2 })
-    public void test87(MyValue1?[] array, MyValue1? o, boolean b) {
+    public void test87(MyValue1.ref[] array, MyValue1.ref o, boolean b) {
         if (b) {
             array[0] = null;
         } else {
             array[1] = null;
         }
@@ -2063,11 +2067,11 @@
     }
 
     @DontCompile
     public void test87_verifier(boolean warmup) {
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
-        MyValue1?[] array1 = new MyValue1?[2];
+        MyValue1.ref[] array1 = new MyValue1.ref[2];
         test87(array1, vt, true);
         Asserts.assertEquals(array1[1], vt);
         test87(array1, null, false);
         Asserts.assertEquals(array1[1], null);
         if (!warmup) {
@@ -2105,18 +2109,18 @@
             }
         }
     }
 
     @Test()
-    public void test89(MyValue1?[] array, Integer v) {
+    public void test89(MyValue1.ref[] array, Integer v) {
         Object o = v;
-        array[0] = (MyValue1?)o;
+        array[0] = (MyValue1.ref)o;
     }
 
     @DontCompile
     public void test89_verifier(boolean warmup) {
-        MyValue1?[] array1 = new MyValue1?[1];
+        MyValue1.ref[] array1 = new MyValue1.ref[1];
         test89(array1, null);
         Asserts.assertEquals(array1[0], null);
         if (!warmup) {
             MyValue1[] array2 = new MyValue1[1];
             try {
@@ -2131,20 +2135,20 @@
     @Test
     public boolean test90() {
         boolean b = true;
 
         MyValue1[] qArray = new MyValue1[0];
-        MyValue1?[] lArray = new MyValue1?[0];
+        MyValue1.ref[] lArray = new MyValue1.ref[0];
 
         b = b && (qArray instanceof MyValue1[]);
-        b = b && (lArray instanceof MyValue1?[]);
+        b = b && (lArray instanceof MyValue1.ref[]);
 
         MyValue1[][] qArray2 = new MyValue1[0][0];
-        MyValue1?[][] lArray2 = new MyValue1?[0][0];
+        MyValue1.ref[][] lArray2 = new MyValue1.ref[0][0];
 
         b = b && (qArray2 instanceof MyValue1[][]);
-        b = b && (lArray2 instanceof MyValue1?[][]);
+        b = b && (lArray2 instanceof MyValue1.ref[][]);
 
         return b;
     }
 
     @DontCompile
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestBufferTearing.java
@@ -34,22 +34,24 @@
  * @test TestBufferTearing
  * @summary Detect tearing on value type buffer writes due to missing barriers.
  * @library /testlibrary /test/lib /compiler/whitebox /
  * @modules java.base/jdk.internal.misc
  * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
- *                   -XX:+StressGCM -XX:+StressLCM
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   compiler.valhalla.valuetypes.TestBufferTearing
  * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
- *                   -XX:+StressGCM -XX:+StressLCM -XX:+AlwaysIncrementalInline
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline
  *                   compiler.valhalla.valuetypes.TestBufferTearing
  * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*
- *                   -XX:+StressGCM -XX:+StressLCM
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
  *                   compiler.valhalla.valuetypes.TestBufferTearing
  * @run main/othervm -XX:ValueFieldMaxFlatSize=0 -XX:ValueArrayElemMaxFlatSize=0
  *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*
- *                   -XX:+StressGCM -XX:+StressLCM -XX:+AlwaysIncrementalInline
+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM
+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline
  *                   compiler.valhalla.valuetypes.TestBufferTearing
  */
 
 inline class MyValue {
     int x;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestC2CCalls.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestC2CCalls.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestC2CCalls.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestC2CCalls.java
@@ -73,14 +73,14 @@
         }
     }
 
     static interface MyInterface1 {
         public MyInterface1 test1(OtherVal other, int y);
-        public MyInterface1 test2(OtherVal other1, OtherVal? other2, int y);
-        public MyInterface1 test3(OtherVal other1, OtherVal? other2, int y, boolean deopt);
-        public MyInterface1 test4(OtherVal other1, OtherVal? other2, int y);
-        public MyInterface1 test5(OtherVal other1, OtherVal? other2, int y);
+        public MyInterface1 test2(OtherVal other1, OtherVal.ref other2, int y);
+        public MyInterface1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt);
+        public MyInterface1 test4(OtherVal other1, OtherVal.ref other2, int y);
+        public MyInterface1 test5(OtherVal other1, OtherVal.ref other2, int y);
         public MyInterface1 test6();
         public MyInterface1 test7(int i1, int i2, int i3, int i4, int i5, int i6);
         public MyInterface1 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7);
         public MyInterface1 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6);
         public MyInterface1 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6);
@@ -104,31 +104,31 @@
         public MyValue1 test1(OtherVal other, int y) {
             return new MyValue1(x + other.x + y);
         }
 
         @Override
-        public MyValue1 test2(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue1 test2(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue1(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyValue1 test3(OtherVal other1, OtherVal? other2, int y, boolean deopt) {
+        public MyValue1 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {
             if (!deopt) {
               return new MyValue1(x + other1.x + other2.x + y);
             } else {
               // Uncommon trap
               return test1(other1, y);
             }
         }
 
         @Override
-        public MyValue1 test4(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue1 test4(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue1(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyValue1 test5(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue1 test5(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue1(x + other1.x + other2.x + y);
         }
 
         @Override
         public MyValue1 test6() {
@@ -170,31 +170,31 @@
         public MyValue2 test1(OtherVal other, int y) {
             return new MyValue2(x + other.x + y);
         }
 
         @Override
-        public MyValue2 test2(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue2 test2(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue2(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyValue2 test3(OtherVal other1, OtherVal? other2, int y, boolean deopt) {
+        public MyValue2 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {
             if (!deopt) {
               return new MyValue2(x + other1.x + other2.x + y);
             } else {
               // Uncommon trap
               return test1(other1, y);
             }
         }
 
         @Override
-        public MyValue2 test4(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue2 test4(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue2(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyValue2 test5(OtherVal other1, OtherVal? other2, int y) {
+        public MyValue2 test5(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyValue2(x + other1.x + other2.x + y);
         }
 
         @Override
         public MyValue2 test6() {
@@ -239,17 +239,17 @@
         }
 
         @Override
         public MyValue3 test1(OtherVal other, int y) { return MyValue3.default; }
         @Override
-        public MyValue3 test2(OtherVal other1, OtherVal? other2, int y)  { return MyValue3.default; }
+        public MyValue3 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }
         @Override
-        public MyValue3 test3(OtherVal other1, OtherVal? other2, int y, boolean deopt)  { return MyValue3.default; }
+        public MyValue3 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue3.default; }
         @Override
-        public MyValue3 test4(OtherVal other1, OtherVal? other2, int y)  { return MyValue3.default; }
+        public MyValue3 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }
         @Override
-        public MyValue3 test5(OtherVal other1, OtherVal? other2, int y)  { return MyValue3.default; }
+        public MyValue3 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue3.default; }
         @Override
         public MyValue3 test6()  { return MyValue3.default; }
 
         @Override
         public MyValue3 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {
@@ -289,17 +289,17 @@
         }
 
         @Override
         public MyValue4 test1(OtherVal other, int y) { return MyValue4.default; }
         @Override
-        public MyValue4 test2(OtherVal other1, OtherVal? other2, int y)  { return MyValue4.default; }
+        public MyValue4 test2(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }
         @Override
-        public MyValue4 test3(OtherVal other1, OtherVal? other2, int y, boolean deopt)  { return MyValue4.default; }
+        public MyValue4 test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt)  { return MyValue4.default; }
         @Override
-        public MyValue4 test4(OtherVal other1, OtherVal? other2, int y)  { return MyValue4.default; }
+        public MyValue4 test4(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }
         @Override
-        public MyValue4 test5(OtherVal other1, OtherVal? other2, int y)  { return MyValue4.default; }
+        public MyValue4 test5(OtherVal other1, OtherVal.ref other2, int y)  { return MyValue4.default; }
         @Override
         public MyValue4 test6()  { return MyValue4.default; }
 
         @Override
         public MyValue4 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {
@@ -336,31 +336,31 @@
         public MyObject test1(OtherVal other, int y) {
             return new MyObject(x + other.x + y);
         }
 
         @Override
-        public MyObject test2(OtherVal other1, OtherVal? other2, int y) {
+        public MyObject test2(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyObject(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyObject test3(OtherVal other1, OtherVal? other2, int y, boolean deopt) {
+        public MyObject test3(OtherVal other1, OtherVal.ref other2, int y, boolean deopt) {
             if (!deopt) {
               return new MyObject(x + other1.x + other2.x + y);
             } else {
               // Uncommon trap
               return test1(other1, y);
             }
         }
 
         @Override
-        public MyObject test4(OtherVal other1, OtherVal? other2, int y) {
+        public MyObject test4(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyObject(x + other1.x + other2.x + y);
         }
 
         @Override
-        public MyObject test5(OtherVal other1, OtherVal? other2, int y) {
+        public MyObject test5(OtherVal other1, OtherVal.ref other2, int y) {
             return new MyObject(x + other1.x + other2.x + y);
         }
 
         @Override
         public MyObject test6() {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConvention.java
@@ -438,11 +438,11 @@
         MyValue3 vt = test21();
         test21_vt.verify(vt);
     }
 
     // Test returning a non-flattened value type as fields
-    MyValue3? test22_vt = MyValue3.create();
+    MyValue3.ref test22_vt = MyValue3.create();
 
     @Test
     public MyValue3 test22() {
         return (MyValue3) test22_vt;
     }
@@ -490,38 +490,38 @@
         Asserts.assertEQ(res2, res3);
     }
 
     // Should not return a nullable value type as fields
     @Test
-    public MyValue2? test24() {
+    public MyValue2.ref test24() {
         return null;
     }
 
     @DontCompile
     public void test24_verifier(boolean warmup) {
-        MyValue2? vt = test24();
+        MyValue2.ref vt = test24();
         Asserts.assertEQ(vt, null);
     }
 
     // Same as test24 but with control flow and inlining
     @ForceInline
-    public MyValue2? test26_callee(boolean b) {
+    public MyValue2.ref test26_callee(boolean b) {
         if (b) {
             return null;
         } else {
             return MyValue2.createWithFieldsInline(rI, true);
         }
     }
 
     @Test
-    public MyValue2? test26(boolean b) {
+    public MyValue2.ref test26(boolean b) {
         return test26_callee(b);
     }
 
     @DontCompile
     public void test26_verifier(boolean warmup) {
-        MyValue2? vt = test26(true);
+        MyValue2.ref vt = test26(true);
         Asserts.assertEQ(vt, null);
         vt = test26(false);
         Asserts.assertEQ(vt.hash(), MyValue2.createWithFieldsInline(rI, true).hash());
     }
 
@@ -577,11 +577,11 @@
         Test27Value1 val1 = new Test27Value1(val2);
         int result = test27(val1);
         Asserts.assertEQ(result, 8*rI);
     }
 
-    static final MyValue1? test28Val = MyValue1.createWithFieldsDontInline(rI, rL);
+    static final MyValue1.ref test28Val = MyValue1.createWithFieldsDontInline(rI, rL);
 
     @Test
     @Warmup(0)
     public String test28() {
         return test28Val.toString();
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestCallingConventionC1.java
@@ -1761,55 +1761,55 @@
 
     //-------------------------------------------------------------------------------
     // Tests for how C1 handles ValueTypeReturnedAsFields in both calls and returns (RefPoint?)
     //-------------------------------------------------------------------------------
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint?)
+    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref)
     @Test(compLevel = C2)
-    public RefPoint? test87(RefPoint? p) {
+    public RefPoint.ref test87(RefPoint.ref p) {
         return test87_helper(p);
     }
 
     @DontInline
     @ForceCompile(compLevel = C1)
-    private static RefPoint? test87_helper(RefPoint? p) {
+    private static RefPoint.ref test87_helper(RefPoint.ref p) {
         return p;
     }
 
     @DontCompile
     public void test87_verifier(boolean warmup) {
         Object result = test87(null);
         Asserts.assertEQ(result, null);
     }
 
-    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint? with constant null)
+    // C2->C1 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref with constant null)
     @Test(compLevel = C2)
-    public RefPoint? test88() {
+    public RefPoint.ref test88() {
         return test88_helper();
     }
 
     @DontInline
     @ForceCompile(compLevel = C1)
-    private static RefPoint? test88_helper() {
+    private static RefPoint.ref test88_helper() {
         return null;
     }
 
     @DontCompile
     public void test88_verifier(boolean warmup) {
         Object result = test88();
         Asserts.assertEQ(result, null);
     }
 
-    // C1->C2 invokestatic with ValueTypeReturnedAsFields (RefPoint?)
+    // C1->C2 invokestatic with ValueTypeReturnedAsFields (RefPoint.ref)
     @Test(compLevel = C1)
-    public RefPoint? test89(RefPoint? p) {
+    public RefPoint.ref test89(RefPoint.ref p) {
         return test89_helper(p);
     }
 
     @DontInline
     @ForceCompile(compLevel = C2)
-    private static RefPoint? test89_helper(RefPoint? p) {
+    private static RefPoint.ref test89_helper(RefPoint.ref p) {
         return p;
     }
 
     @DontCompile
     public void test89_verifier(boolean warmup) {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestDeoptimizationWhenBuffering.java
@@ -76,11 +76,11 @@
 
 final inline class MyValue1 {
     static int cnt = 0;
     final int x;
     final MyValue2 vtField1;
-    final MyValue2? vtField2;
+    final MyValue2.ref vtField2;
 
     public MyValue1() {
         this.x = ++cnt;
         this.vtField1 = new MyValue2();
         this.vtField2 = new MyValue2();
@@ -160,11 +160,11 @@
 
     Object test7(Object[] obj) {
         return obj[0];
     }
 
-    MyValue1? test8(MyValue1?[] obj) {
+    MyValue1.ref test8(MyValue1.ref[] obj) {
         return obj[0];
     }
 
     static final MethodHandle test9_mh;
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestFlatArrayThreshold.java
@@ -47,32 +47,32 @@
     public static MyValue1 test1(MyValue1[] va, MyValue1 vt) {
         va[0] = vt;
         return va[1];
     }
 
-    public static MyValue1? test2(MyValue1?[] va, MyValue1? vt) {
+    public static MyValue1.ref test2(MyValue1.ref[] va, MyValue1.ref vt) {
         va[0] = vt;
         return va[1];
     }
 
     public static Object test3(Object[] va, MyValue1 vt) {
         va[0] = vt;
         return va[1];
     }
 
-    public static Object test4(Object[] va, MyValue1? vt) {
+    public static Object test4(Object[] va, MyValue1.ref vt) {
         va[0] = vt;
         return va[1];
     }
 
     public static MyValue1 test5(MyValue1[] va, Object vt) {
         va[0] = (MyValue1)vt;
         return va[1];
     }
 
-    public static MyValue1? test6(MyValue1?[] va, Object vt) {
-        va[0] = (MyValue1?)vt;
+    public static MyValue1.ref test6(MyValue1.ref[] va, Object vt) {
+        va[0] = (MyValue1.ref)vt;
         return va[1];
     }
 
     public static Object test7(Object[] va, Object vt) {
         va[0] = vt;
@@ -80,49 +80,49 @@
     }
 
     static public void main(String[] args) {
         MyValue1 vt = new MyValue1();
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] vaB = new MyValue1?[2];
+        MyValue1.ref[] vaB = new MyValue1.ref[2];
         va[1] = vt;
         for (int i = 0; i < 10_000; ++i) {
             MyValue1 result1 = test1(va, vt);
             Asserts.assertEQ(result1.o1, 42);
             Asserts.assertEQ(result1.o2, 43);
 
-            MyValue1? result2 = test2(va, vt);
+            MyValue1.ref result2 = test2(va, vt);
             Asserts.assertEQ(result2.o1, 42);
             Asserts.assertEQ(result2.o2, 43);
             result2 = test2(vaB, null);
             Asserts.assertEQ(result2, null);
 
-            MyValue1? result3 = (MyValue1?)test3(va, vt);
+            MyValue1.ref result3 = (MyValue1.ref)test3(va, vt);
             Asserts.assertEQ(result3.o1, 42);
             Asserts.assertEQ(result3.o2, 43);
-            result3 = (MyValue1?)test3(vaB, vt);
+            result3 = (MyValue1.ref)test3(vaB, vt);
             Asserts.assertEQ(result3, null);
 
-            MyValue1? result4 = (MyValue1?)test4(va, vt);
+            MyValue1.ref result4 = (MyValue1.ref)test4(va, vt);
             Asserts.assertEQ(result4.o1, 42);
             Asserts.assertEQ(result4.o2, 43);
-            result4 = (MyValue1?)test4(vaB, null);
+            result4 = (MyValue1.ref)test4(vaB, null);
             Asserts.assertEQ(result4, null);
 
             MyValue1 result5 = test5(va, vt);
             Asserts.assertEQ(result5.o1, 42);
             Asserts.assertEQ(result5.o2, 43);
 
-            MyValue1? result6 = test6(va, vt);
+            MyValue1.ref result6 = test6(va, vt);
             Asserts.assertEQ(result6.o1, 42);
             Asserts.assertEQ(result6.o2, 43);
             result6 = test6(vaB, null);
             Asserts.assertEQ(result6, null);
 
-            MyValue1? result7 = (MyValue1?)test7(va, vt);
+            MyValue1.ref result7 = (MyValue1.ref)test7(va, vt);
             Asserts.assertEQ(result7.o1, 42);
             Asserts.assertEQ(result7.o2, 43);
-            result7 = (MyValue1?)test7(vaB, null);
+            result7 = (MyValue1.ref)test7(vaB, null);
             Asserts.assertEQ(result7, null);
         }
         try {
             test2(va, null);
             throw new RuntimeException("NullPointerException expected");
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestIntrinsics.java
@@ -105,21 +105,23 @@
         return cls.getSuperclass();
     }
 
     public void test3_verifier(boolean warmup) {
         Asserts.assertTrue(test3(Object.class) == null, "test3_1 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == Object.class, "test3_2 failed");
-        Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == Object.class, "test3_3 failed");
+        Asserts.assertTrue(test3(MyValue1.class.asIndirectType()) == MyValue1.ref.class, "test3_2 failed");
+        Asserts.assertTrue(test3(MyValue1.class.asPrimaryType()) == MyValue1.ref.class, "test3_3 failed");
         Asserts.assertTrue(test3(Class.class) == Object.class, "test3_4 failed");
     }
 
     // Verify that Class::getSuperclass checks with statically known classes are folded
     @Test(failOn = LOADK)
     public boolean test4() {
         boolean check1 = Object.class.getSuperclass() == null;
-        boolean check2 = MyValue1.class.asIndirectType().getSuperclass() == Object.class;
-        boolean check3 = MyValue1.class.asPrimaryType().getSuperclass() == Object.class;
+        // TODO Remove cast as workaround once javac is fixed
+        boolean check2 = (Class<?>)MyValue1.class.asIndirectType().getSuperclass() == MyValue1.ref.class;
+        // TODO Remove cast as workaround once javac is fixed
+        boolean check3 = (Class<?>)MyValue1.class.asPrimaryType().getSuperclass() == MyValue1.ref.class;
         boolean check4 = Class.class.getSuperclass() == Object.class;
         return check1 && check2 && check3 && check4;
     }
 
     public void test4_verifier(boolean warmup) {
@@ -432,11 +434,12 @@
 
     final Test25Value[] test25Array = new Test25Value[10];
 
     @Test
     public Test25Value[] test25(Test25Value element) {
-        Test25Value[] newArray = Arrays.copyOf(test25Array, test25Array.length + 1);
+        // TODO Remove cast as workaround once javac is fixed
+        Test25Value[] newArray = (Test25Value[])Arrays.copyOf(test25Array, test25Array.length + 1);
         newArray[test25Array.length] = element;
         return newArray;
     }
 
     @DontCompile
@@ -460,11 +463,11 @@
         Object[] res = (Object[])test26();
         Asserts.assertEQ(((MyValue1)res[0]).hashPrimitive(), MyValue1.createDefaultInline().hashPrimitive());
     }
 
     // Load non-flattenable value type field with unsafe
-    MyValue1? test27_vt = MyValue1.createWithFieldsInline(rI, rL);
+    MyValue1.ref test27_vt = MyValue1.createWithFieldsInline(rI, rL);
     private static final long TEST27_OFFSET;
     static {
         try {
             Field field = TestIntrinsics.class.getDeclaredField("test27_vt");
             TEST27_OFFSET = U.objectFieldOffset(field);
@@ -745,122 +748,122 @@
         }
     }
 
     // Class.isInstance
     @Test()
-    public boolean test41(Class c, MyValue1? vt) {
+    public boolean test41(Class c, MyValue1.ref vt) {
         return c.isInstance(vt);
     }
 
     @DontCompile
     public void test41_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         boolean result = test41(MyValue1.class.asIndirectType(), vt);
         Asserts.assertTrue(result);
         result = test41(MyValue1.class, vt);
         Asserts.assertTrue(result);
     }
 
     @Test()
-    public boolean test42(Class c, MyValue1? vt) {
+    public boolean test42(Class c, MyValue1.ref vt) {
         return c.isInstance(vt);
     }
 
     @DontCompile
     public void test42_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         boolean result = test42(MyValue2.class.asIndirectType(), vt);
         Asserts.assertFalse(result);
         result = test42(MyValue2.class, vt);
         Asserts.assertFalse(result);
     }
 
     // Class.cast
     @Test()
-    public Object test43(Class c, MyValue1? vt) {
+    public Object test43(Class c, MyValue1.ref vt) {
         return c.cast(vt);
     }
 
     @DontCompile
     public void test43_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         Object result = test43(MyValue1.class.asIndirectType(), vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         result = test43(MyValue1.class.asIndirectType(), null);
         Asserts.assertEQ(result, null);
     }
 
     @Test()
-    public Object test44(Class c, MyValue1? vt) {
+    public Object test44(Class c, MyValue1.ref vt) {
         return c.cast(vt);
     }
 
     @DontCompile
     public void test44_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         try {
             test44(MyValue2.class.asIndirectType(), vt);
             throw new RuntimeException("should have thrown");
         } catch (ClassCastException cce) {
         }
     }
 
     @Test()
-    public Object test45(MyValue1? vt) {
+    public Object test45(MyValue1.ref vt) {
         return MyValue1.class.asIndirectType().cast(vt);
     }
 
     @DontCompile
     public void test45_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         Object result = test45(vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         result = test45(null);
         Asserts.assertEQ(result, null);
     }
 
     @Test()
-    public Object test46(MyValue1? vt) {
+    public Object test46(MyValue1.ref vt) {
         return MyValue2.class.asIndirectType().cast(vt);
     }
 
     @DontCompile
     public void test46_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         test46(null);
         try {
             test46(vt);
             throw new RuntimeException("should have thrown");
         } catch (ClassCastException cce) {
         }
     }
 
     @Test()
-    public Object test47(MyValue1? vt) {
+    public Object test47(MyValue1.ref vt) {
         return MyValue1.class.asPrimaryType().cast(vt);
     }
 
     @DontCompile
     public void test47_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         Object result = test47(vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         try {
             test47(null);
             throw new RuntimeException("should have thrown");
         } catch (NullPointerException npe) {
         }
     }
 
     @Test()
-    public Object test48(Class c, MyValue1? vt) {
+    public Object test48(Class c, MyValue1.ref vt) {
         return c.cast(vt);
     }
 
     @DontCompile
     public void test48_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsInline(rI, rL);
+        MyValue1.ref vt = MyValue1.createWithFieldsInline(rI, rL);
         Object result = test48(MyValue1.class, vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         try {
             test48(MyValue1.class, null);
             throw new RuntimeException("should have thrown");
@@ -887,20 +890,20 @@
 
     @DontCompile
     public void test50_verifier(boolean warmup) {
         MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);
         MyValue1[] va  = new MyValue1[42];
-        MyValue1?[] vba = new MyValue1?[42];
+        MyValue1.ref[] vba = new MyValue1.ref[42];
         Object result = test50(MyValue1.class, vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         result = test50(MyValue1.class.asIndirectType(), vt);
         Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());
         result = test50(MyValue1[].class, va);
         Asserts.assertEQ(result, va);
-        result = test50(MyValue1?[].class, vba);
+        result = test50(MyValue1.ref[].class, vba);
         Asserts.assertEQ(result, vba);
-        result = test50(MyValue1?[].class, va);
+        result = test50(MyValue1.ref[].class, va);
         Asserts.assertEQ(result, va);
         try {
             test50(MyValue1.class, null);
             throw new RuntimeException("should have thrown");
         } catch (NullPointerException npe) {
@@ -929,17 +932,17 @@
 
     // multidimensional value type array creation via reflection
     @Test()
     public Object[][] test52(int len, int val) {
         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
-        MyValue1?[][] va2 = (MyValue1?[][])Array.newInstance(MyValue1?[].class, len);
+        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
         Object[][] result;
         if (val == 1) {
             va1[0] = new MyValue1[1];
             result = va1;
         } else {
-            va2[0] = new MyValue1?[1];
+            va2[0] = new MyValue1.ref[1];
             result = va2;
         }
         if (val == 1) {
             Asserts.assertEQ(va1[0][0].hash(), ((MyValue1)result[0][0]).hash());
         } else {
@@ -956,22 +959,22 @@
     }
 
     @Test()
     public Object[][] test53(Class<?> c1, Class<?> c2, int len, int val) {
         MyValue1[][] va1 = (MyValue1[][])Array.newInstance(MyValue1[].class, len);
-        MyValue1?[][] va2 = (MyValue1?[][])Array.newInstance(MyValue1?[].class, len);
+        MyValue1.ref[][] va2 = (MyValue1.ref[][])Array.newInstance(MyValue1.ref[].class, len);
         Object[][] va3 = (Object[][])Array.newInstance(c1, len);
         Object[][] va4 = (Object[][])Array.newInstance(c2, len);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(va1[i], null);
             Asserts.assertEQ(va2[i], null);
             Asserts.assertEQ(va3[i], null);
             Asserts.assertEQ(va4[i], null);
             va1[i] = new MyValue1[1];
-            va2[i] = new MyValue1?[1];
+            va2[i] = new MyValue1.ref[1];
             va3[i] = new MyValue1[1];
-            va4[i] = new MyValue1?[1];
+            va4[i] = new MyValue1.ref[1];
             Asserts.assertEQ(va1[i][0].hash(), ((MyValue1)va3[i][0]).hash());
             Asserts.assertEQ(va2[i][0], null);
             Asserts.assertEQ(va4[i][0], null);
         }
         Object[][] result;
@@ -994,14 +997,14 @@
     }
 
     @DontCompile
     public void test53_verifier(boolean warmup) {
         int len = Math.abs(rI) % 42;
-        test53(MyValue1[].class, MyValue1?[].class, len, 1);
-        test53(MyValue1[].class, MyValue1?[].class, len, 2);
-        test53(MyValue1[].class, MyValue1?[].class, len, 3);
-        test53(MyValue1[].class, MyValue1?[].class, len, 4);
+        test53(MyValue1[].class, MyValue1.ref[].class, len, 1);
+        test53(MyValue1[].class, MyValue1.ref[].class, len, 2);
+        test53(MyValue1[].class, MyValue1.ref[].class, len, 3);
+        test53(MyValue1[].class, MyValue1.ref[].class, len, 4);
     }
 
     // Test asIndirectType intrinsic with non-value mirror
     @Test()
     public Class<?> test54(Class<?> c) {
@@ -1032,11 +1035,11 @@
         Asserts.assertEQ(result, Integer.class);
     }
 
     // Same as test39 but Unsafe.putInt to buffer is not intrinsified/compiled
     @DontCompile
-    public void test56_callee(MyValue1? v) { // Use ? here to make sure the argument is not scalarized (otherwise larval information is lost)
+    public void test56_callee(MyValue1.ref v) { // Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)
         U.putInt(v, X_OFFSET, rI);
     }
 
     @Test()
     @Warmup(10000) // Fill up the TLAB to trigger slow path allocation
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorld.java
@@ -115,18 +115,18 @@
     Object objectField5 = null;
     Object objectField6 = null;
 
     MyValue1 valueField1 = testValue1;
     MyValue1 valueField2 = testValue1;
-    MyValue1? valueField3 = testValue1;
+    MyValue1.ref valueField3 = testValue1;
     MyValue1 valueField4;
-    MyValue1? valueField5;
+    MyValue1.ref valueField5;
 
-    static MyValue1? staticValueField1 = testValue1;
+    static MyValue1.ref staticValueField1 = testValue1;
     static MyValue1 staticValueField2 = testValue1;
     static MyValue1 staticValueField3;
-    static MyValue1? staticValueField4;
+    static MyValue1.ref staticValueField4;
 
     @DontInline
     public Object readValueField5() {
         return (Object)valueField5;
     }
@@ -1231,12 +1231,12 @@
     public void test41_verifier(boolean warmup) {
         test41();
     }
 
     // Test for bug in Escape Analysis
-    private static final MyValue1? test42VT1 = MyValue1.createWithFieldsInline(rI, rL);
-    private static final MyValue1? test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
+    private static final MyValue1.ref test42VT1 = MyValue1.createWithFieldsInline(rI, rL);
+    private static final MyValue1.ref test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 
     @Test()
     public void test42() {
         MyValue1[] vals = new MyValue1[] {(MyValue1) test42VT1, (MyValue1) test42VT2};
         Asserts.assertEQ(vals[0].hash(), test42VT1.hash());
@@ -1392,13 +1392,13 @@
         final Object objectField5;
         final Object objectField6;
 
         final MyValue1 valueField1;
         final MyValue1 valueField2;
-        final MyValue1? valueField3;
+        final MyValue1.ref valueField3;
         final MyValue1 valueField4;
-        final MyValue1? valueField5;
+        final MyValue1.ref valueField5;
 
         public Test51Value() {
             objectField1 = null;
             objectField2 = null;
             objectField3 = null;
@@ -1411,11 +1411,11 @@
             valueField4 = MyValue1.createDefaultDontInline();
             valueField5 = MyValue1.createDefaultDontInline();
         }
 
         public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,
-                           MyValue1 vt1, MyValue1 vt2, MyValue1? vt3, MyValue1 vt4, MyValue1? vt5) {
+                           MyValue1 vt1, MyValue1 vt2, MyValue1.ref vt3, MyValue1 vt4, MyValue1.ref vt5) {
             objectField1 = o1;
             objectField2 = o2;
             objectField3 = o3;
             objectField4 = o4;
             objectField5 = o5;
@@ -1944,16 +1944,16 @@
         }
     }
 
     // Casting a null Integer to a nullable value type should not throw
     @ForceInline
-    public MyValue1? test78_helper(Object o) {
-        return (MyValue1?)o;
+    public MyValue1.ref test78_helper(Object o) {
+        return (MyValue1.ref)o;
     }
 
     @Test
-    public MyValue1? test78(Integer i) throws Throwable {
+    public MyValue1.ref test78(Integer i) throws Throwable {
         return test78_helper(i);
     }
 
     @DontCompile
     public void test78_verifier(boolean warmup) throws Throwable {
@@ -1964,16 +1964,16 @@
         }
     }
 
     // Casting an Integer to a nullable value type should throw a ClassCastException
     @ForceInline
-    public MyValue1? test79_helper(Object o) {
-        return (MyValue1?)o;
+    public MyValue1.ref test79_helper(Object o) {
+        return (MyValue1.ref)o;
     }
 
     @Test
-    public MyValue1? test79(Integer i) throws Throwable {
+    public MyValue1.ref test79(Integer i) throws Throwable {
         return test79_helper(i);
     }
 
     @DontCompile
     public void test79_verifier(boolean warmup) throws Throwable {
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestLWorldProfiling.java
@@ -81,11 +81,11 @@
     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1};
     private static final MyValue2[] testValue2Array = new MyValue2[] {testValue2};
     private static final Integer[] testIntegerArray = new Integer[] {42};
     private static final Long[] testLongArray = new Long[] {42L};
     private static final Double[] testDoubleArray = new Double[] {42.0D};
-    private static final MyValue1?[] testValue1NotFlatArray = new MyValue1?[] {testValue1};
+    private static final MyValue1.ref[] testValue1NotFlatArray = new MyValue1.ref[] {testValue1};
     private static final MyValue1[][] testValue1ArrayArray = new MyValue1[][] {testValue1Array};
 
     // aaload
 
     @Warmup(10000)
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
@@ -78,12 +78,12 @@
     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
 
     // Test nullable value type array creation and initialization
     @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
     @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
-    public MyValue1?[] test1(int len) {
-        MyValue1?[] va = new MyValue1?[len];
+    public MyValue1.ref[] test1(int len) {
+        MyValue1.ref[] va = new MyValue1.ref[len];
         if (len > 0) {
             va[0] = null;
         }
         for (int i = 1; i < len; ++i) {
             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
@@ -92,11 +92,11 @@
     }
 
     @DontCompile
     public void test1_verifier(boolean warmup) {
         int len = Math.abs(rI % 10);
-        MyValue1?[] va = test1(len);
+        MyValue1.ref[] va = test1(len);
         if (len > 0) {
             Asserts.assertEQ(va[0], null);
         }
         for (int i = 1; i < len; ++i) {
             Asserts.assertEQ(va[i].hash(), hash());
@@ -106,11 +106,11 @@
     // Test creation of a value type array and element access
     @Test
     // TODO 8227588
     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test2() {
-        MyValue1?[] va = new MyValue1?[1];
+        MyValue1.ref[] va = new MyValue1.ref[1];
         va[0] = MyValue1.createWithFieldsInline(rI, rL);
         return va[0].hash();
     }
 
     @DontCompile
@@ -120,11 +120,11 @@
     }
 
     // Test receiving a value type array from the interpreter,
     // updating its elements in a loop and computing a hash.
     @Test(failOn = ALLOCA)
-    public long test3(MyValue1?[] va) {
+    public long test3(MyValue1.ref[] va) {
         long result = 0;
         for (int i = 0; i < 10; ++i) {
             if (va[i] != null) {
                 result += va[i].hash();
             }
@@ -134,11 +134,11 @@
         return result;
     }
 
     @DontCompile
     public void test3_verifier(boolean warmup) {
-        MyValue1?[] va = new MyValue1?[10];
+        MyValue1.ref[] va = new MyValue1.ref[10];
         long expected = 0;
         for (int i = 1; i < 10; ++i) {
             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
             expected += va[i].hash();
         }
@@ -152,17 +152,17 @@
         }
     }
 
     // Test returning a value type array received from the interpreter
     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
-    public MyValue1?[] test4(MyValue1?[] va) {
+    public MyValue1.ref[] test4(MyValue1.ref[] va) {
         return va;
     }
 
     @DontCompile
     public void test4_verifier(boolean warmup) {
-        MyValue1?[] va = new MyValue1?[10];
+        MyValue1.ref[] va = new MyValue1.ref[10];
         for (int i = 0; i < 10; ++i) {
             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
         }
         va = test4(va);
         for (int i = 0; i < 10; ++i) {
@@ -170,20 +170,20 @@
         }
     }
 
     // Merge value type arrays created from two branches
     @Test
-    public MyValue1?[] test5(boolean b) {
-        MyValue1?[] va;
+    public MyValue1.ref[] test5(boolean b) {
+        MyValue1.ref[] va;
         if (b) {
-            va = new MyValue1?[5];
+            va = new MyValue1.ref[5];
             for (int i = 0; i < 5; ++i) {
                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
             }
             va[4] = null;
         } else {
-            va = new MyValue1?[10];
+            va = new MyValue1.ref[10];
             for (int i = 0; i < 10; ++i) {
                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
             }
             va[9] = null;
         }
@@ -196,11 +196,11 @@
         return va;
     }
 
     @DontCompile
     public void test5_verifier(boolean warmup) {
-        MyValue1?[] va = test5(true);
+        MyValue1.ref[] va = test5(true);
         Asserts.assertEQ(va.length, 5);
         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
         for (int i = 1; i < 4; ++i) {
             Asserts.assertEQ(va[i].hash(), hash());
         }
@@ -214,70 +214,70 @@
         Asserts.assertEQ(va[9], null);
     }
 
     // Test creation of value type array with single element
     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    public MyValue1? test6() {
-        MyValue1?[] va = new MyValue1?[1];
+    public MyValue1.ref test6() {
+        MyValue1.ref[] va = new MyValue1.ref[1];
         return va[0];
     }
 
     @DontCompile
     public void test6_verifier(boolean warmup) {
-        MyValue1?[] va = new MyValue1?[1];
-        MyValue1? v = test6();
+        MyValue1.ref[] va = new MyValue1.ref[1];
+        MyValue1.ref v = test6();
         Asserts.assertEQ(v, null);
     }
 
     // Test default initialization of value type arrays
     @Test(failOn = LOAD)
-    public MyValue1?[] test7(int len) {
-        return new MyValue1?[len];
+    public MyValue1.ref[] test7(int len) {
+        return new MyValue1.ref[len];
     }
 
     @DontCompile
     public void test7_verifier(boolean warmup) {
         int len = Math.abs(rI % 10);
-        MyValue1?[] va = test7(len);
+        MyValue1.ref[] va = test7(len);
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(va[i], null);
             va[i] = null;
         }
     }
 
     // Test creation of value type array with zero length
     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
-    public MyValue1?[] test8() {
-        return new MyValue1?[0];
+    public MyValue1.ref[] test8() {
+        return new MyValue1.ref[0];
     }
 
     @DontCompile
     public void test8_verifier(boolean warmup) {
-        MyValue1?[] va = test8();
+        MyValue1.ref[] va = test8();
         Asserts.assertEQ(va.length, 0);
     }
 
-    static MyValue1?[] test9_va;
+    static MyValue1.ref[] test9_va;
 
     // Test that value type array loaded from field has correct type
     @Test(failOn = LOOP)
     public long test9() {
         return test9_va[0].hash();
     }
 
     @DontCompile
     public void test9_verifier(boolean warmup) {
-        test9_va = new MyValue1?[1];
+        test9_va = new MyValue1.ref[1];
         test9_va[0] = testValue1;
         long result = test9();
         Asserts.assertEQ(result, hash());
     }
 
     // Multi-dimensional arrays
     @Test
-    public MyValue1?[][][] test10(int len1, int len2, int len3) {
-        MyValue1?[][][] arr = new MyValue1?[len1][len2][len3];
+    public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
+        MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
         for (int i = 0; i < len1; i++) {
             for (int j = 0; j < len2; j++) {
                 for (int k = 0; k < len3; k++) {
                     arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);
                     if (k == 0) {
@@ -289,11 +289,11 @@
         return arr;
     }
 
     @DontCompile
     public void test10_verifier(boolean warmup) {
-        MyValue1?[][][] arr = test10(2, 3, 4);
+        MyValue1.ref[][][] arr = test10(2, 3, 4);
         for (int i = 0; i < 2; i++) {
             for (int j = 0; j < 3; j++) {
                 for (int k = 0; k < 4; k++) {
                     if (k == 0) {
                         Asserts.assertEQ(arr[i][j][k], null);
@@ -305,11 +305,11 @@
             }
         }
     }
 
     @Test
-    public void test11(MyValue1?[][][] arr, long[] res) {
+    public void test11(MyValue1.ref[][][] arr, long[] res) {
         int l = 0;
         for (int i = 0; i < arr.length; i++) {
             for (int j = 0; j < arr[i].length; j++) {
                 for (int k = 0; k < arr[i][j].length; k++) {
                     if (arr[i][j][k] != null) {
@@ -322,11 +322,11 @@
         }
     }
 
     @DontCompile
     public void test11_verifier(boolean warmup) {
-        MyValue1?[][][] arr = new MyValue1?[2][3][4];
+        MyValue1.ref[][][] arr = new MyValue1.ref[2][3][4];
         long[] res = new long[2*3*4];
         long[] verif = new long[2*3*4];
         int l = 0;
         for (int i = 0; i < 2; i++) {
             for (int j = 0; j < 3; j++) {
@@ -347,11 +347,11 @@
 
     // Array load out of bounds (upper bound) at compile time
     @Test
     public int test12() {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         for (int i = 0; i < arraySize; i++) {
             va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
         }
 
@@ -368,11 +368,11 @@
 
     // Array load  out of bounds (lower bound) at compile time
     @Test
     public int test13() {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         for (int i = 0; i < arraySize; i++) {
             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);
         }
 
@@ -387,17 +387,17 @@
         Asserts.assertEQ(test13(), rI);
     }
 
     // Array load out of bound not known to compiler (both lower and upper bound)
     @Test
-    public int test14(MyValue1?[] va, int index)  {
+    public int test14(MyValue1.ref[] va, int index)  {
         return va[index].x;
     }
 
     public void test14_verifier(boolean warmup) {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         for (int i = 0; i < arraySize; i++) {
             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
         }
 
@@ -414,11 +414,11 @@
 
     // Array store out of bounds (upper bound) at compile time
     @Test
     public int test15() {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         try {
             for (int i = 0; i <= arraySize; i++) {
                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
             }
@@ -434,11 +434,11 @@
 
     // Array store out of bounds (lower bound) at compile time
     @Test
     public int test16() {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         try {
             for (int i = -1; i <= arraySize; i++) {
                 va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);
             }
@@ -452,19 +452,19 @@
         Asserts.assertEQ(test16(), rI);
     }
 
     // Array store out of bound not known to compiler (both lower and upper bound)
     @Test
-    public int test17(MyValue1?[] va, int index, MyValue1 vt)  {
+    public int test17(MyValue1.ref[] va, int index, MyValue1 vt)  {
         va[index] = vt;
         return va[index].x;
     }
 
     @DontCompile
     public void test17_verifier(boolean warmup) {
         int arraySize = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[arraySize];
+        MyValue1.ref[] va = new MyValue1.ref[arraySize];
 
         for (int i = 0; i < arraySize; i++) {
             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
         }
 
@@ -484,86 +484,86 @@
         }
     }
 
     // clone() as stub call
     @Test
-    public MyValue1?[] test18(MyValue1?[] va) {
+    public MyValue1.ref[] test18(MyValue1.ref[] va) {
         return va.clone();
     }
 
     @DontCompile
     public void test18_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va1 = new MyValue1?[len];
+        MyValue1.ref[] va1 = new MyValue1.ref[len];
         MyValue1[]  va2 = new MyValue1[len];
         for (int i = 1; i < len; ++i) {
             va1[i] = testValue1;
             va2[i] = testValue1;
         }
-        MyValue1?[] result1 = test18(va1);
+        MyValue1.ref[] result1 = test18(va1);
         if (len > 0) {
             Asserts.assertEQ(result1[0], null);
         }
         for (int i = 1; i < len; ++i) {
             Asserts.assertEQ(result1[i].hash(), va1[i].hash());
         }
         // make sure we do deopt: GraphKit::new_array assumes an
         // array of references
         for (int j = 0; j < 10; j++) {
-            MyValue1?[] result2 = test18(va2);
+            MyValue1.ref[] result2 = test18(va2);
 
             for (int i = 0; i < len; ++i) {
                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
             }
         }
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test18")) {
-            MyValue1?[] result2 = test18(va2);
+            MyValue1.ref[] result2 = test18(va2);
             for (int i = 0; i < len; ++i) {
                 Asserts.assertEQ(result2[i].hash(), va2[i].hash());
             }
         }
     }
 
     // clone() as series of loads/stores
-    static MyValue1?[] test19_orig = null;
+    static MyValue1.ref[] test19_orig = null;
 
     @Test
-    public MyValue1?[] test19() {
-        MyValue1?[] va = new MyValue1?[8];
+    public MyValue1.ref[] test19() {
+        MyValue1.ref[] va = new MyValue1.ref[8];
         for (int i = 1; i < va.length; ++i) {
             va[i] = MyValue1.createWithFieldsInline(rI, rL);
         }
         test19_orig = va;
 
         return va.clone();
     }
 
     @DontCompile
     public void test19_verifier(boolean warmup) {
-        MyValue1?[] result = test19();
+        MyValue1.ref[] result = test19();
         Asserts.assertEQ(result[0], null);
         for (int i = 1; i < test19_orig.length; ++i) {
             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
         }
     }
 
     // arraycopy() of value type array with oop fields
     @Test
-    public void test20(MyValue1?[] src, MyValue1?[] dst) {
+    public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
     @DontCompile
     public void test20_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] src1 = new MyValue1?[len];
-        MyValue1?[] src2 = new MyValue1?[len];
+        MyValue1.ref[] src1 = new MyValue1.ref[len];
+        MyValue1.ref[] src2 = new MyValue1.ref[len];
         MyValue1[]  src3 = new MyValue1[len];
         MyValue1[]  src4 = new MyValue1[len];
-        MyValue1?[] dst1 = new MyValue1?[len];
+        MyValue1.ref[] dst1 = new MyValue1.ref[len];
         MyValue1[]  dst2 = new MyValue1[len];
-        MyValue1?[] dst3 = new MyValue1?[len];
+        MyValue1.ref[] dst3 = new MyValue1.ref[len];
         MyValue1[]  dst4 = new MyValue1[len];
         if (len > 0) {
             src2[0] = testValue1;
         }
         for (int i = 1; i < len; ++i) {
@@ -590,24 +590,24 @@
         }
     }
 
     // arraycopy() of value type array with no oop field
     @Test
-    public void test21(MyValue2?[] src, MyValue2?[] dst) {
+    public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
     @DontCompile
     public void test21_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue2?[] src1 = new MyValue2?[len];
-        MyValue2?[] src2 = new MyValue2?[len];
+        MyValue2.ref[] src1 = new MyValue2.ref[len];
+        MyValue2.ref[] src2 = new MyValue2.ref[len];
         MyValue2[]  src3 = new MyValue2[len];
         MyValue2[]  src4 = new MyValue2[len];
-        MyValue2?[] dst1 = new MyValue2?[len];
+        MyValue2.ref[] dst1 = new MyValue2.ref[len];
         MyValue2[]  dst2 = new MyValue2[len];
-        MyValue2?[] dst3 = new MyValue2?[len];
+        MyValue2.ref[] dst3 = new MyValue2.ref[len];
         MyValue2[]  dst4 = new MyValue2[len];
         if (len > 0) {
             src2[0] = MyValue2.createWithFieldsInline(rI, true);
         }
         for (int i = 1; i < len; ++i) {
@@ -635,27 +635,27 @@
     }
 
     // arraycopy() of value type array with oop field and tightly
     // coupled allocation as dest
     @Test
-    public MyValue1?[] test22(MyValue1?[] src) {
-        MyValue1?[] dst = new MyValue1?[src.length];
+    public MyValue1.ref[] test22(MyValue1.ref[] src) {
+        MyValue1.ref[] dst = new MyValue1.ref[src.length];
         System.arraycopy(src, 0, dst, 0, src.length);
         return dst;
     }
 
     @DontCompile
     public void test22_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] src1 = new MyValue1?[len];
+        MyValue1.ref[] src1 = new MyValue1.ref[len];
         MyValue1[]  src2 = new MyValue1[len];
         for (int i = 1; i < len; ++i) {
             src1[i] = testValue1;
             src2[i] = testValue1;
         }
-        MyValue1?[] dst1 = test22(src1);
-        MyValue1?[] dst2 = test22(src2);
+        MyValue1.ref[] dst1 = test22(src1);
+        MyValue1.ref[] dst2 = test22(src2);
         if (len > 0) {
             Asserts.assertEQ(dst1[0], null);
             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
         }
         for (int i = 1; i < len; ++i) {
@@ -665,27 +665,27 @@
     }
 
     // arraycopy() of value type array with oop fields and tightly
     // coupled allocation as dest
     @Test
-    public MyValue1?[] test23(MyValue1?[] src) {
-        MyValue1?[] dst = new MyValue1?[src.length + 10];
+    public MyValue1.ref[] test23(MyValue1.ref[] src) {
+        MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
         System.arraycopy(src, 0, dst, 5, src.length);
         return dst;
     }
 
     @DontCompile
     public void test23_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] src1 = new MyValue1?[len];
+        MyValue1.ref[] src1 = new MyValue1.ref[len];
         MyValue1[] src2 = new MyValue1[len];
         for (int i = 0; i < len; ++i) {
             src1[i] = testValue1;
             src2[i] = testValue1;
         }
-        MyValue1?[] dst1 = test23(src1);
-        MyValue1?[] dst2 = test23(src2);
+        MyValue1.ref[] dst1 = test23(src1);
+        MyValue1.ref[] dst2 = test23(src2);
         for (int i = 0; i < 5; ++i) {
             Asserts.assertEQ(dst1[i], null);
             Asserts.assertEQ(dst2[i], null);
         }
         for (int i = 5; i < len; ++i) {
@@ -694,24 +694,24 @@
         }
     }
 
     // arraycopy() of value type array passed as Object
     @Test
-    public void test24(MyValue1?[] src, Object dst) {
+    public void test24(MyValue1.ref[] src, Object dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
     @DontCompile
     public void test24_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] src1 = new MyValue1?[len];
-        MyValue1?[] src2 = new MyValue1?[len];
+        MyValue1.ref[] src1 = new MyValue1.ref[len];
+        MyValue1.ref[] src2 = new MyValue1.ref[len];
         MyValue1[]  src3 = new MyValue1[len];
         MyValue1[]  src4 = new MyValue1[len];
-        MyValue1?[] dst1 = new MyValue1?[len];
+        MyValue1.ref[] dst1 = new MyValue1.ref[len];
         MyValue1[]  dst2 = new MyValue1[len];
-        MyValue1?[] dst3 = new MyValue1?[len];
+        MyValue1.ref[] dst3 = new MyValue1.ref[len];
         MyValue1[]  dst4 = new MyValue1[len];
         if (len > 0) {
             src2[0] = testValue1;
         }
         for (int i = 1; i < len; ++i) {
@@ -738,23 +738,23 @@
         }
     }
 
     // short arraycopy() with no oop field
     @Test
-    public void test25(MyValue2?[] src, MyValue2?[] dst) {
+    public void test25(MyValue2.ref[] src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test25_verifier(boolean warmup) {
-        MyValue2?[] src1 = new MyValue2?[8];
-        MyValue2?[] src2 = new MyValue2?[8];
+        MyValue2.ref[] src1 = new MyValue2.ref[8];
+        MyValue2.ref[] src2 = new MyValue2.ref[8];
         MyValue2[]  src3 = new MyValue2[8];
         MyValue2[]  src4 = new MyValue2[8];
-        MyValue2?[] dst1 = new MyValue2?[8];
+        MyValue2.ref[] dst1 = new MyValue2.ref[8];
         MyValue2[]  dst2 = new MyValue2[8];
-        MyValue2?[] dst3 = new MyValue2?[8];
+        MyValue2.ref[] dst3 = new MyValue2.ref[8];
         MyValue2[]  dst4 = new MyValue2[8];
         src2[0] = MyValue2.createWithFieldsInline(rI, true);
         for (int i = 1; i < 8; ++i) {
             src1[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
             src2[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
@@ -777,23 +777,23 @@
         }
     }
 
     // short arraycopy() with oop fields
     @Test
-    public void test26(MyValue1?[] src, MyValue1?[] dst) {
+    public void test26(MyValue1.ref[] src, MyValue1.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test26_verifier(boolean warmup) {
-        MyValue1?[] src1 = new MyValue1?[8];
-        MyValue1?[] src2 = new MyValue1?[8];
+        MyValue1.ref[] src1 = new MyValue1.ref[8];
+        MyValue1.ref[] src2 = new MyValue1.ref[8];
         MyValue1[]  src3 = new MyValue1[8];
         MyValue1[]  src4 = new MyValue1[8];
-        MyValue1?[] dst1 = new MyValue1?[8];
+        MyValue1.ref[] dst1 = new MyValue1.ref[8];
         MyValue1[]  dst2 = new MyValue1[8];
-        MyValue1?[] dst3 = new MyValue1?[8];
+        MyValue1.ref[] dst3 = new MyValue1.ref[8];
         MyValue1[]  dst4 = new MyValue1[8];
         src2[0] = testValue1;
         for (int i = 1; i < 8 ; ++i) {
             src1[i] = testValue1;
             src2[i] = testValue1;
@@ -816,23 +816,23 @@
         }
     }
 
     // short arraycopy() with oop fields and offsets
     @Test
-    public void test27(MyValue1?[] src, MyValue1?[] dst) {
+    public void test27(MyValue1.ref[] src, MyValue1.ref[] dst) {
         System.arraycopy(src, 1, dst, 2, 6);
     }
 
     @DontCompile
     public void test27_verifier(boolean warmup) {
-        MyValue1?[] src1 = new MyValue1?[8];
-        MyValue1?[] src2 = new MyValue1?[8];
+        MyValue1.ref[] src1 = new MyValue1.ref[8];
+        MyValue1.ref[] src2 = new MyValue1.ref[8];
         MyValue1[]  src3 = new MyValue1[8];
         MyValue1[]  src4 = new MyValue1[8];
-        MyValue1?[] dst1 = new MyValue1?[8];
+        MyValue1.ref[] dst1 = new MyValue1.ref[8];
         MyValue1[]  dst2 = new MyValue1[8];
-        MyValue1?[] dst3 = new MyValue1?[8];
+        MyValue1.ref[] dst3 = new MyValue1.ref[8];
         MyValue1[]  dst4 = new MyValue1[8];
         for (int i = 1; i < 8; ++i) {
             src1[i] = testValue1;
             src2[i] = testValue1;
             src3[i] = testValue1;
@@ -858,70 +858,70 @@
 
     // non escaping allocations
     // TODO ZGC does not support the clone intrinsic, remove this once JDK-8232896 is fixed
     @Test(valid = ZGCOff, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     @Test(valid = ZGCOn)
-    public MyValue2? test28() {
-        MyValue2?[] src = new MyValue2?[10];
+    public MyValue2.ref test28() {
+        MyValue2.ref[] src = new MyValue2.ref[10];
         src[0] = null;
-        MyValue2?[] dst = (MyValue2?[])src.clone();
+        MyValue2.ref[] dst = (MyValue2.ref[])src.clone();
         return dst[0];
     }
 
     @DontCompile
     public void test28_verifier(boolean warmup) {
         MyValue2 v = MyValue2.createWithFieldsInline(rI, false);
-        MyValue2? result = test28();
+        MyValue2.ref result = test28();
         Asserts.assertEQ(result, null);
     }
 
     // non escaping allocations
     // TODO 8227588: shouldn't this have the same IR matching rules as test6?
     @Test(failOn = ALLOCA + LOOP + TRAP)
-    public MyValue2? test29(MyValue2?[] src) {
-        MyValue2?[] dst = new MyValue2?[10];
+    public MyValue2.ref test29(MyValue2.ref[] src) {
+        MyValue2.ref[] dst = new MyValue2.ref[10];
         System.arraycopy(src, 0, dst, 0, 10);
         return dst[0];
     }
 
     @DontCompile
     public void test29_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[10];
+        MyValue2.ref[] src = new MyValue2.ref[10];
         for (int i = 0; i < 10; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
-        MyValue2? v = test29(src);
+        MyValue2.ref v = test29(src);
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
     // non escaping allocation with uncommon trap that needs
     // eliminated value type array element as debug info
     @Test
     @Warmup(10000)
-    public MyValue2? test30(MyValue2?[] src, boolean flag) {
-        MyValue2?[] dst = new MyValue2?[10];
+    public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
+        MyValue2.ref[] dst = new MyValue2.ref[10];
         System.arraycopy(src, 0, dst, 0, 10);
         if (flag) { }
         return dst[0];
     }
 
     @DontCompile
     public void test30_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[10];
+        MyValue2.ref[] src = new MyValue2.ref[10];
         for (int i = 0; i < 10; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
-        MyValue2? v = test30(src, !warmup);
+        MyValue2.ref v = test30(src, !warmup);
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
     // non escaping allocation with memory phi
     @Test()
     // TODO 8227588
     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test31(boolean b, boolean deopt) {
-        MyValue2?[] src = new MyValue2?[1];
+        MyValue2.ref[] src = new MyValue2.ref[1];
         if (b) {
             src[0] = MyValue2.createWithFieldsInline(rI, true);
         } else {
             src[0] = MyValue2.createWithFieldsInline(rI, false);
         }
@@ -950,18 +950,18 @@
     }
 
     @DontCompile
     public void test32_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va1 = new MyValue1?[len];
+        MyValue1.ref[] va1 = new MyValue1.ref[len];
         MyValue1[] va2 = new MyValue1[len];
         for (int i = 1; i < len; ++i) {
             va1[i] = testValue1;
             va2[i] = testValue1;
         }
-        MyValue1?[] result1 = (MyValue1?[])test32(va1);
-        MyValue1?[] result2 = (MyValue1?[])test32(va2);
+        MyValue1.ref[] result1 = (MyValue1.ref[])test32(va1);
+        MyValue1.ref[] result2 = (MyValue1.ref[])test32(va2);
         if (len > 0) {
             Asserts.assertEQ(result1[0], null);
             Asserts.assertEQ(result2[0].hash(), MyValue1.default.hash());
         }
         for (int i = 1; i < len; ++i) {
@@ -993,11 +993,11 @@
 
     @ForceInline
     public Object[] test34_helper(boolean flag) {
         Object[] va = null;
         if (flag) {
-            va = new MyValue1?[8];
+            va = new MyValue1.ref[8];
             for (int i = 0; i < va.length; ++i) {
                 va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
             }
         } else {
             va = new Object[8];
@@ -1033,41 +1033,41 @@
                 Asserts.assertEQ(dst[i], null);
             }
         }
     }
 
-    static void verify(MyValue1?[] src, MyValue1?[] dst) {
+    static void verify(MyValue1.ref[] src, MyValue1.ref[] dst) {
         for (int i = 0; i < src.length; ++i) {
             if (src[i] != null) {
                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
             } else {
                 Asserts.assertEQ(dst[i], null);
             }
         }
     }
 
-    static void verify(MyValue1?[] src, Object[] dst) {
+    static void verify(MyValue1.ref[] src, Object[] dst) {
         for (int i = 0; i < src.length; ++i) {
             if (src[i] != null) {
                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
             } else {
                 Asserts.assertEQ(dst[i], null);
             }
         }
     }
 
-    static void verify(MyValue2?[] src, MyValue2?[] dst) {
+    static void verify(MyValue2.ref[] src, MyValue2.ref[] dst) {
         for (int i = 0; i < src.length; ++i) {
             if (src[i] != null) {
                 Asserts.assertEQ(src[i].hash(), dst[i].hash());
             } else {
                 Asserts.assertEQ(dst[i], null);
             }
         }
     }
 
-    static void verify(MyValue2?[] src, Object[] dst) {
+    static void verify(MyValue2.ref[] src, Object[] dst) {
         for (int i = 0; i < src.length; ++i) {
             if (src[i] != null) {
                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
             } else {
                 Asserts.assertEQ(dst[i], null);
@@ -1096,12 +1096,12 @@
     }
 
     @DontCompile
     public void test35_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] src = new MyValue1?[len];
-        MyValue1?[] dst = new MyValue1?[len];
+        MyValue1.ref[] src = new MyValue1.ref[len];
+        MyValue1.ref[] dst = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = testValue1;
         }
         test35(src, dst, src.length);
         verify(src, dst);
@@ -1110,19 +1110,19 @@
             verify(src, dst);
         }
     }
 
     @Test
-    public void test36(Object src, MyValue2?[] dst) {
+    public void test36(Object src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, dst.length);
     }
 
     @DontCompile
     public void test36_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue2?[] src = new MyValue2?[len];
-        MyValue2?[] dst = new MyValue2?[len];
+        MyValue2.ref[] src = new MyValue2.ref[len];
+        MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test36(src, dst);
         verify(src, dst);
@@ -1131,19 +1131,19 @@
             verify(src, dst);
         }
     }
 
     @Test
-    public void test37(MyValue2?[] src, Object dst) {
+    public void test37(MyValue2.ref[] src, Object dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
     @DontCompile
     public void test37_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue2?[] src = new MyValue2?[len];
-        MyValue2?[] dst = new MyValue2?[len];
+        MyValue2.ref[] src = new MyValue2.ref[len];
+        MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test37(src, dst);
         verify(src, dst);
@@ -1153,19 +1153,19 @@
         }
     }
 
     @Test
     @Warmup(1) // Avoid early compilation
-    public void test38(Object src, MyValue2?[] dst) {
+    public void test38(Object src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, dst.length);
     }
 
     @DontCompile
     public void test38_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
-        MyValue2?[] dst = new MyValue2?[len];
+        MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test38(src, dst);
         verify(dst, src);
@@ -1180,18 +1180,18 @@
             }
         }
     }
 
     @Test
-    public void test39(MyValue2?[] src, Object dst) {
+    public void test39(MyValue2.ref[] src, Object dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
     @DontCompile
     public void test39_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue2?[] src = new MyValue2?[len];
+        MyValue2.ref[] src = new MyValue2.ref[len];
         Object[] dst = new Object[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test39(src, dst);
@@ -1210,11 +1210,11 @@
 
     @DontCompile
     public void test40_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] src = new Object[len];
-        MyValue2?[] dst = new MyValue2?[len];
+        MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test40(src, dst);
         verify(dst, src);
@@ -1236,11 +1236,11 @@
     }
 
     @DontCompile
     public void test41_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue2?[] src = new MyValue2?[len];
+        MyValue2.ref[] src = new MyValue2.ref[len];
         Object[] dst = new Object[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test41(src, dst);
@@ -1280,12 +1280,12 @@
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test43_verifier(boolean warmup) {
-        MyValue1?[] src = new MyValue1?[8];
-        MyValue1?[] dst = new MyValue1?[8];
+        MyValue1.ref[] src = new MyValue1.ref[8];
+        MyValue1.ref[] dst = new MyValue1.ref[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = testValue1;
         }
         test43(src, dst);
         verify(src, dst);
@@ -1294,18 +1294,18 @@
             verify(src, dst);
         }
     }
 
     @Test
-    public void test44(Object src, MyValue2?[] dst) {
+    public void test44(Object src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test44_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[8];
-        MyValue2?[] dst = new MyValue2?[8];
+        MyValue2.ref[] src = new MyValue2.ref[8];
+        MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test44(src, dst);
         verify(src, dst);
@@ -1314,18 +1314,18 @@
             verify(src, dst);
         }
     }
 
     @Test
-    public void test45(MyValue2?[] src, Object dst) {
+    public void test45(MyValue2.ref[] src, Object dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test45_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[8];
-        MyValue2?[] dst = new MyValue2?[8];
+        MyValue2.ref[] src = new MyValue2.ref[8];
+        MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test45(src, dst);
         verify(src, dst);
@@ -1335,18 +1335,18 @@
         }
     }
 
     @Test
     @Warmup(1) // Avoid early compilation
-    public void test46(Object[] src, MyValue2?[] dst) {
+    public void test46(Object[] src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test46_verifier(boolean warmup) {
         Object[] src = new Object[8];
-        MyValue2?[] dst = new MyValue2?[8];
+        MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test46(src, dst);
         verify(dst, src);
@@ -1361,17 +1361,17 @@
             }
         }
     }
 
     @Test
-    public void test47(MyValue2?[] src, Object[] dst) {
+    public void test47(MyValue2.ref[] src, Object[] dst) {
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test47_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[8];
+        MyValue2.ref[] src = new MyValue2.ref[8];
         Object[] dst = new Object[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test47(src, dst);
@@ -1389,11 +1389,11 @@
     }
 
     @DontCompile
     public void test48_verifier(boolean warmup) {
         Object[] src = new Object[8];
-        MyValue2?[] dst = new MyValue2?[8];
+        MyValue2.ref[] dst = new MyValue2.ref[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test48(src, dst);
         verify(dst, src);
@@ -1414,11 +1414,11 @@
         System.arraycopy(src, 0, dst, 0, 8);
     }
 
     @DontCompile
     public void test49_verifier(boolean warmup) {
-        MyValue2?[] src = new MyValue2?[8];
+        MyValue2.ref[] src = new MyValue2.ref[8];
         Object[] dst = new Object[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
         }
         test49(src, dst);
@@ -1450,66 +1450,66 @@
             }
         }
     }
 
     @Test
-    public MyValue1?[] test51(MyValue1?[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1?[].class);
+    public MyValue1.ref[] test51(MyValue1.ref[] va) {
+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
     }
 
     @DontCompile
     public void test51_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
-        MyValue1?[] result = test51(va);
+        MyValue1.ref[] result = test51(va);
         verify(va, result);
     }
 
-    static final MyValue1?[] test52_va = new MyValue1?[8];
+    static final MyValue1.ref[] test52_va = new MyValue1.ref[8];
 
     @Test
-    public MyValue1?[] test52() {
-        return Arrays.copyOf(test52_va, 8, MyValue1?[].class);
+    public MyValue1.ref[] test52() {
+        return Arrays.copyOf(test52_va, 8, MyValue1.ref[].class);
     }
 
     @DontCompile
     public void test52_verifier(boolean warmup) {
         for (int i = 1; i < 8; ++i) {
             test52_va[i] = testValue1;
         }
-        MyValue1?[] result = test52();
+        MyValue1.ref[] result = test52();
         verify(test52_va, result);
     }
 
     @Test
-    public MyValue1?[] test53(Object[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1?[].class);
+    public MyValue1.ref[] test53(Object[] va) {
+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
     }
 
     @DontCompile
     public void test53_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
-        MyValue1?[] result = test53(va);
+        MyValue1.ref[] result = test53(va);
         verify(result, va);
     }
 
     @Test
-    public Object[] test54(MyValue1?[] va) {
+    public Object[] test54(MyValue1.ref[] va) {
         return Arrays.copyOf(va, va.length, Object[].class);
     }
 
     @DontCompile
     public void test54_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
         Object[] result = test54(va);
         verify(va, result);
@@ -1521,31 +1521,31 @@
     }
 
     @DontCompile
     public void test55_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
         Object[] result = test55(va);
         verify(va, result);
     }
 
     @Test
-    public MyValue1?[] test56(Object[] va) {
-        return Arrays.copyOf(va, va.length, MyValue1?[].class);
+    public MyValue1.ref[] test56(Object[] va) {
+        return Arrays.copyOf(va, va.length, MyValue1.ref[].class);
     }
 
     @DontCompile
     public void test56_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
         Object[] va = new Object[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
-        MyValue1?[] result = test56(va);
+        MyValue1.ref[] result = test56(va);
         verify(result, va);
     }
 
    @Test
     public Object[] test57(Object[] va, Class klass) {
@@ -1553,50 +1553,50 @@
     }
 
     @DontCompile
     public void test57_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        Object[] va = new MyValue1?[len];
+        Object[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
-        Object[] result = test57(va, MyValue1?[].class);
+        Object[] result = test57(va, MyValue1.ref[].class);
         verify(va, result);
     }
 
     @Test
-    public Object[] test58(MyValue1?[] va, Class klass) {
+    public Object[] test58(MyValue1.ref[] va, Class klass) {
         return Arrays.copyOf(va, va.length, klass);
     }
 
     @DontCompile
     public void test58_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
         }
         for (int i = 1; i < 10; i++) {
-            Object[] result = test58(va, MyValue1?[].class);
+            Object[] result = test58(va, MyValue1.ref[].class);
             verify(va, result);
         }
         if (compile_and_run_again_if_deoptimized(warmup, "TestNullableArrays::test58")) {
-            Object[] result = test58(va, MyValue1?[].class);
+            Object[] result = test58(va, MyValue1.ref[].class);
             verify(va, result);
         }
     }
 
     @Test
-    public Object[] test59(MyValue1?[] va) {
-        return Arrays.copyOf(va, va.length+1, MyValue1?[].class);
+    public Object[] test59(MyValue1.ref[] va) {
+        return Arrays.copyOf(va, va.length+1, MyValue1.ref[].class);
     }
 
     @DontCompile
     public void test59_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
-        MyValue1?[] verif = new MyValue1?[len+1];
+        MyValue1.ref[] va = new MyValue1.ref[len];
+        MyValue1.ref[] verif = new MyValue1.ref[len+1];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
             verif[i] = va[i];
         }
         Object[] result = test59(va);
@@ -1609,17 +1609,17 @@
     }
 
     @DontCompile
     public void test60_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
-        MyValue1?[] verif = new MyValue1?[len+1];
+        MyValue1.ref[] va = new MyValue1.ref[len];
+        MyValue1.ref[] verif = new MyValue1.ref[len+1];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
             verif[i] = (MyValue1)va[i];
         }
-        Object[] result = test60(va, MyValue1?[].class);
+        Object[] result = test60(va, MyValue1.ref[].class);
         verify(verif, result);
     }
 
     @Test
     public Object[] test61(Object[] va, Class klass) {
@@ -1638,22 +1638,22 @@
             Asserts.assertEQ(va[i], result[i]);
         }
     }
 
     @ForceInline
-    public Object[] test62_helper(int i, MyValue1?[] va, Integer[] oa) {
+    public Object[] test62_helper(int i, MyValue1.ref[] va, Integer[] oa) {
         Object[] arr = null;
         if (i == 10) {
             arr = oa;
         } else {
             arr = va;
         }
         return arr;
     }
 
     @Test
-    public Object[] test62(MyValue1?[] va, Integer[] oa) {
+    public Object[] test62(MyValue1.ref[] va, Integer[] oa) {
         int i = 0;
         for (; i < 10; i++);
 
         Object[] arr = test62_helper(i, va, oa);
 
@@ -1661,11 +1661,11 @@
     }
 
     @DontCompile
     public void test62_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         Integer[] oa = new Integer[len];
         for (int i = 1; i < len; ++i) {
             oa[i] = new Integer(rI);
         }
         test62_helper(42, va, oa);
@@ -1674,22 +1674,22 @@
             Asserts.assertEQ(oa[i], result[i]);
         }
     }
 
     @ForceInline
-    public Object[] test63_helper(int i, MyValue1?[] va, Integer[] oa) {
+    public Object[] test63_helper(int i, MyValue1.ref[] va, Integer[] oa) {
         Object[] arr = null;
         if (i == 10) {
             arr = va;
         } else {
             arr = oa;
         }
         return arr;
     }
 
     @Test
-    public Object[] test63(MyValue1?[] va, Integer[] oa) {
+    public Object[] test63(MyValue1.ref[] va, Integer[] oa) {
         int i = 0;
         for (; i < 10; i++);
 
         Object[] arr = test63_helper(i, va, oa);
 
@@ -1697,12 +1697,12 @@
     }
 
     @DontCompile
     public void test63_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
-        MyValue1?[] verif = new MyValue1?[len+1];
+        MyValue1.ref[] va = new MyValue1.ref[len];
+        MyValue1.ref[] verif = new MyValue1.ref[len+1];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
             verif[i] = va[i];
         }
         Integer[] oa = new Integer[len];
@@ -1711,131 +1711,131 @@
         verify(verif, result);
     }
 
     // Test default initialization of value type arrays: small array
     @Test
-    public MyValue1?[] test64() {
-        return new MyValue1?[8];
+    public MyValue1.ref[] test64() {
+        return new MyValue1.ref[8];
     }
 
     @DontCompile
     public void test64_verifier(boolean warmup) {
-        MyValue1?[] va = test64();
+        MyValue1.ref[] va = test64();
         for (int i = 0; i < 8; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
     // Test default initialization of value type arrays: large array
     @Test
-    public MyValue1?[] test65() {
-        return new MyValue1?[32];
+    public MyValue1.ref[] test65() {
+        return new MyValue1.ref[32];
     }
 
     @DontCompile
     public void test65_verifier(boolean warmup) {
-        MyValue1?[] va = test65();
+        MyValue1.ref[] va = test65();
         for (int i = 0; i < 32; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
     // Check init store elimination
     @Test(match = { ALLOCA }, matchCount = { 1 })
-    public MyValue1?[] test66(MyValue1? vt) {
-        MyValue1?[] va = new MyValue1?[1];
+    public MyValue1.ref[] test66(MyValue1.ref vt) {
+        MyValue1.ref[] va = new MyValue1.ref[1];
         va[0] = vt;
         return va;
     }
 
     @DontCompile
     public void test66_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsDontInline(rI, rL);
-        MyValue1?[] va = test66(vt);
+        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
+        MyValue1.ref[] va = test66(vt);
         Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());
     }
 
     // Zeroing elimination and arraycopy
     @Test
-    public MyValue1?[] test67(MyValue1?[] src) {
-        MyValue1?[] dst = new MyValue1?[16];
+    public MyValue1.ref[] test67(MyValue1.ref[] src) {
+        MyValue1.ref[] dst = new MyValue1.ref[16];
         System.arraycopy(src, 0, dst, 0, 13);
         return dst;
     }
 
     @DontCompile
     public void test67_verifier(boolean warmup) {
-        MyValue1?[] va = new MyValue1?[16];
-        MyValue1?[] var = test67(va);
+        MyValue1.ref[] va = new MyValue1.ref[16];
+        MyValue1.ref[] var = test67(va);
         for (int i = 0; i < 16; ++i) {
             Asserts.assertEQ(var[i], null);
         }
     }
 
     // A store with a default value can be eliminated
     @Test
-    public MyValue1?[] test68() {
-        MyValue1?[] va = new MyValue1?[2];
+    public MyValue1.ref[] test68() {
+        MyValue1.ref[] va = new MyValue1.ref[2];
         va[0] = va[1];
         return va;
     }
 
     @DontCompile
     public void test68_verifier(boolean warmup) {
-        MyValue1?[] va = test68();
+        MyValue1.ref[] va = test68();
         for (int i = 0; i < 2; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
     // Requires individual stores to init array
     @Test
-    public MyValue1?[] test69(MyValue1? vt) {
-        MyValue1?[] va = new MyValue1?[4];
+    public MyValue1.ref[] test69(MyValue1.ref vt) {
+        MyValue1.ref[] va = new MyValue1.ref[4];
         va[0] = vt;
         va[3] = vt;
         return va;
     }
 
     @DontCompile
     public void test69_verifier(boolean warmup) {
-        MyValue1? vt = MyValue1.createWithFieldsDontInline(rI, rL);
-        MyValue1?[] va = new MyValue1?[4];
+        MyValue1.ref vt = MyValue1.createWithFieldsDontInline(rI, rL);
+        MyValue1.ref[] va = new MyValue1.ref[4];
         va[0] = vt;
         va[3] = vt;
-        MyValue1?[] var = test69(vt);
+        MyValue1.ref[] var = test69(vt);
         for (int i = 0; i < va.length; ++i) {
             Asserts.assertEQ(va[i], var[i]);
         }
     }
 
     // A store with a default value can be eliminated: same as test68
     // but store is farther away from allocation
     @Test
-    public MyValue1?[] test70(MyValue1?[] other) {
+    public MyValue1.ref[] test70(MyValue1.ref[] other) {
         other[1] = other[0];
-        MyValue1?[] va = new MyValue1?[2];
+        MyValue1.ref[] va = new MyValue1.ref[2];
         other[0] = va[1];
         va[0] = va[1];
         return va;
     }
 
     @DontCompile
     public void test70_verifier(boolean warmup) {
-        MyValue1?[] va = new MyValue1?[2];
-        MyValue1?[] var = test70(va);
+        MyValue1.ref[] va = new MyValue1.ref[2];
+        MyValue1.ref[] var = test70(va);
         for (int i = 0; i < 2; ++i) {
             Asserts.assertEQ(va[i], var[i]);
         }
     }
 
     // EA needs to consider oop fields in flattened arrays
     @Test
     public void test71() {
         int len = 10;
-        MyValue2?[] src = new MyValue2?[len];
-        MyValue2?[] dst = new MyValue2?[len];
+        MyValue2.ref[] src = new MyValue2.ref[len];
+        MyValue2.ref[] dst = new MyValue2.ref[len];
         for (int i = 1; i < len; ++i) {
             src[i] = MyValue2.createWithFieldsDontInline(rI, (i % 2) == 0);
         }
         System.arraycopy(src, 0, dst, 0, src.length);
         for (int i = 0; i < len; ++i) {
@@ -1871,11 +1871,11 @@
         test72(arr, true, elem);
         test72(arr, false, elem);
     }
 
     @Test
-    public void test73(Object[] oa, MyValue1? v, Object o) {
+    public void test73(Object[] oa, MyValue1.ref v, Object o) {
         // TestLWorld.test38 use a C1 Phi node for the array. This test
         // adds the case where the stored value is a C1 Phi node.
         Object o2 = (o == null) ? v : o;
         oa[0] = v;  // The stored value is known to be flattenable
         oa[1] = o;  // The stored value may be flattenable
@@ -1883,13 +1883,13 @@
         oa[0] = oa; // The stored value is known to be not flattenable (an Object[])
     }
 
     @DontCompile
     public void test73_verifier(boolean warmup) {
-        MyValue1? v0 = MyValue1.createWithFieldsDontInline(rI, rL);
-        MyValue1? v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
-        MyValue1?[] arr = new MyValue1?[3];
+        MyValue1.ref v0 = MyValue1.createWithFieldsDontInline(rI, rL);
+        MyValue1.ref v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);
+        MyValue1.ref[] arr = new MyValue1.ref[3];
         try {
             test73(arr, v0, v1);
             throw new RuntimeException("ArrayStoreException expected");
         } catch (ArrayStoreException t) {
             // expected
@@ -1899,33 +1899,33 @@
         Asserts.assertEQ(arr[2].hash(), v1.hash());
     }
 
     // Some more array clone tests
     @ForceInline
-    public Object[] test74_helper(int i, MyValue1?[] va, Integer[] oa) {
+    public Object[] test74_helper(int i, MyValue1.ref[] va, Integer[] oa) {
         Object[] arr = null;
         if (i == 10) {
             arr = oa;
         } else {
             arr = va;
         }
         return arr;
     }
 
     @Test
-    public Object[] test74(MyValue1?[] va, Integer[] oa) {
+    public Object[] test74(MyValue1.ref[] va, Integer[] oa) {
         int i = 0;
         for (; i < 10; i++);
 
         Object[] arr = test74_helper(i, va, oa);
         return arr.clone();
     }
 
     @DontCompile
     public void test74_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
         Integer[] oa = new Integer[len];
         for (int i = 1; i < len; ++i) {
             oa[i] = new Integer(rI);
         }
         test74_helper(42, va, oa);
@@ -1937,34 +1937,34 @@
             result[i] = null;
         }
     }
 
     @ForceInline
-    public Object[] test75_helper(int i, MyValue1?[] va, Integer[] oa) {
+    public Object[] test75_helper(int i, MyValue1.ref[] va, Integer[] oa) {
         Object[] arr = null;
         if (i == 10) {
             arr = va;
         } else {
             arr = oa;
         }
         return arr;
     }
 
     @Test
-    public Object[] test75(MyValue1?[] va, Integer[] oa) {
+    public Object[] test75(MyValue1.ref[] va, Integer[] oa) {
         int i = 0;
         for (; i < 10; i++);
 
         Object[] arr = test75_helper(i, va, oa);
         return arr.clone();
     }
 
     @DontCompile
     public void test75_verifier(boolean warmup) {
         int len = Math.abs(rI) % 10;
-        MyValue1?[] va = new MyValue1?[len];
-        MyValue1?[] verif = new MyValue1?[len];
+        MyValue1.ref[] va = new MyValue1.ref[len];
+        MyValue1.ref[] verif = new MyValue1.ref[len];
         for (int i = 1; i < len; ++i) {
             va[i] = testValue1;
             verif[i] = va[i];
         }
         Integer[] oa = new Integer[len];
@@ -1977,20 +1977,20 @@
         }
     }
 
     // Test mixing nullable and non-nullable arrays
     @Test
-    public Object[] test76(MyValue1[] vva, MyValue1?[] vba, MyValue1 vt, Object[] out, int n) {
+    public Object[] test76(MyValue1[] vva, MyValue1.ref[] vba, MyValue1 vt, Object[] out, int n) {
         Object[] result = null;
         if (n == 0) {
             result = vva;
         } else if (n == 1) {
             result = vba;
         } else if (n == 2) {
             result = new MyValue1[42];
         } else if (n == 3) {
-            result = new MyValue1?[42];
+            result = new MyValue1.ref[42];
         }
         result[0] = vt;
         out[0] = result[1];
         return result;
     }
@@ -2000,12 +2000,12 @@
         MyValue1 vt = testValue1;
         Object[] out = new Object[1];
         MyValue1[] vva = new MyValue1[42];
         MyValue1[] vva_r = new MyValue1[42];
         vva_r[0] = vt;
-        MyValue1?[] vba = new MyValue1?[42];
-        MyValue1?[] vba_r = new MyValue1?[42];
+        MyValue1.ref[] vba = new MyValue1.ref[42];
+        MyValue1.ref[] vba_r = new MyValue1.ref[42];
         vba_r[0] = vt;
         Object[] result = test76(vva, vba, vt, out, 0);
         verify(result, vva_r);
         Asserts.assertEQ(out[0], vva_r[1]);
         result = test76(vva, vba, vt, out, 1);
@@ -2021,11 +2021,11 @@
 
     @Test
     public Object[] test77(boolean b) {
         Object[] va;
         if (b) {
-            va = new MyValue1?[5];
+            va = new MyValue1.ref[5];
             for (int i = 0; i < 5; ++i) {
                 va[i] = testValue1;
             }
         } else {
             va = new MyValue1[10];
@@ -2058,20 +2058,20 @@
         }
     }
 
     // Same as test76 but with non value type array cases
     @Test
-    public Object[] test78(MyValue1[] vva, MyValue1?[] vba, Object val, Object[] out, int n) {
+    public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
         Object[] result = null;
         if (n == 0) {
             result = vva;
         } else if (n == 1) {
             result = vba;
         } else if (n == 2) {
             result = new MyValue1[42];
         } else if (n == 3) {
-            result = new MyValue1?[42];
+            result = new MyValue1.ref[42];
         } else if (n == 4) {
             result = new Integer[42];
         }
         result[0] = val;
         out[0] = result[1];
@@ -2084,12 +2084,12 @@
         Integer i = new Integer(42);
         Object[] out = new Object[1];
         MyValue1[] vva = new MyValue1[42];
         MyValue1[] vva_r = new MyValue1[42];
         vva_r[0] = vt;
-        MyValue1?[] vba = new MyValue1?[42];
-        MyValue1?[] vba_r = new MyValue1?[42];
+        MyValue1.ref[] vba = new MyValue1.ref[42];
+        MyValue1.ref[] vba_r = new MyValue1.ref[42];
         vba_r[0] = vt;
         Object[] result = test78(vva, vba, vt, out, 0);
         verify(result, vva_r);
         Asserts.assertEQ(out[0], vva_r[1]);
         result = test78(vva, vba, vt, out, 1);
@@ -2106,19 +2106,19 @@
         Asserts.assertEQ(out[0], null);
     }
 
     // Test widening conversions from [Q to [L
     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    public static MyValue1?[] test79(MyValue1[] va) {
+    public static MyValue1.ref[] test79(MyValue1[] va) {
         return va;
     }
 
     @DontCompile
     public void test79_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[1];
         va[0] = testValue1;
-        MyValue1?[] res = test79(va);
+        MyValue1.ref[] res = test79(va);
         Asserts.assertEquals(res[0].hash(), testValue1.hash());
         try {
             res[0] = null;
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException npe) {
@@ -2129,11 +2129,11 @@
     }
 
     // Same as test79 but with explicit cast and Object return
     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public static Object[] test80(MyValue1[] va) {
-        return (MyValue1?[])va;
+        return (MyValue1.ref[])va;
     }
 
     @DontCompile
     public void test80_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[1];
@@ -2150,12 +2150,12 @@
         test80(null); // Should not throw NPE
     }
 
     // Test mixing widened and boxed array type
     @Test()
-    public static long test81(MyValue1[] va1, MyValue1?[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
-        MyValue1?[] result = b ? va1 : va2;
+    public static long test81(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {
+        MyValue1.ref[] result = b ? va1 : va2;
         try {
             result[0] = vt;
         } catch (NullPointerException npe) {
             // Ignored
         }
@@ -2163,11 +2163,11 @@
     }
 
     @DontCompile
     public void test81_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] vaB = new MyValue1?[2];
+        MyValue1.ref[] vaB = new MyValue1.ref[2];
         va[1] = testValue1;
         vaB[1] = testValue1;
         long res = test81(va, vaB, testValue1, true, true);
         Asserts.assertEquals(va[0].hash(), testValue1.hash());
         Asserts.assertEquals(res, testValue1.hash());
@@ -2179,18 +2179,18 @@
         Asserts.assertEquals(res, testValue1.hash());
     }
 
     // Same as test81 but more cases and null writes
     @Test()
-    public static long test82(MyValue1[] va1, MyValue1?[] va2, MyValue1 vt1, MyValue1? vt2, int i, boolean shouldThrow) {
-        MyValue1?[] result = null;
+    public static long test82(MyValue1[] va1, MyValue1.ref[] va2, MyValue1 vt1, MyValue1.ref vt2, int i, boolean shouldThrow) {
+        MyValue1.ref[] result = null;
         if (i == 0) {
             result = va1;
         } else if (i == 1) {
             result = va2;
         } else if (i == 2) {
-            result = new MyValue1?[2];
+            result = new MyValue1.ref[2];
             result[1] = vt1;
         } else if (i == 3) {
             result = new MyValue1[2];
             result[1] = vt1;
         }
@@ -2207,11 +2207,11 @@
     }
 
     @DontCompile
     public void test82_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] vaB = new MyValue1?[2];
+        MyValue1.ref[] vaB = new MyValue1.ref[2];
         va[1] = testValue1;
         vaB[1] = testValue1;
         long res = test82(va, vaB, testValue1, testValue1, 0, true);
         Asserts.assertEquals(va[0].hash(), testValue1.hash());
         Asserts.assertEquals(res, testValue1.hash());
@@ -2229,11 +2229,11 @@
         Asserts.assertEquals(res, testValue1.hash());
     }
 
     @Test(failOn = ALLOC + ALLOCA + STORE)
     public static long test83(MyValue1[] va) {
-        MyValue1?[] result = va;
+        MyValue1.ref[] result = va;
         return result[0].hash();
     }
 
     @DontCompile
     public void test83_verifier(boolean warmup) {
@@ -2243,20 +2243,20 @@
         Asserts.assertEquals(res, testValue1.hash());
     }
 
     @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
     @Test(valid = ValueTypeArrayFlattenOff)
-    public static MyValue1?[] test84(MyValue1 vt1, MyValue1? vt2) {
-        MyValue1?[] result = new MyValue1[2];
+    public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
+        MyValue1.ref[] result = new MyValue1[2];
         result[0] = vt1;
         result[1] = vt2;
         return result;
     }
 
     @DontCompile
     public void test84_verifier(boolean warmup) {
-        MyValue1?[] res = test84(testValue1, testValue1);
+        MyValue1.ref[] res = test84(testValue1, testValue1);
         Asserts.assertEquals(res[0].hash(), testValue1.hash());
         Asserts.assertEquals(res[1].hash(), testValue1.hash());
         try {
             test84(testValue1, null);
             throw new RuntimeException("NullPointerException expected");
@@ -2264,19 +2264,19 @@
             // Expected
         }
     }
 
     @Test()
-    public static long test85(MyValue1?[] va, MyValue1 val) {
+    public static long test85(MyValue1.ref[] va, MyValue1 val) {
         va[0] = val;
         return va[1].hash();
     }
 
     @DontCompile
     public void test85_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] vab = new MyValue1?[2];
+        MyValue1.ref[] vab = new MyValue1.ref[2];
         va[1] = testValue1;
         vab[1] = testValue1;
         long res = test85(va, testValue1);
         Asserts.assertEquals(res, testValue1.hash());
         Asserts.assertEquals(va[0].hash(), testValue1.hash());
@@ -2285,19 +2285,19 @@
         Asserts.assertEquals(vab[0].hash(), testValue1.hash());
     }
 
     // Same as test85 but with box value
     @Test()
-    public static long test86(MyValue1?[] va, MyValue1? val) {
+    public static long test86(MyValue1.ref[] va, MyValue1.ref val) {
         va[0] = val;
         return va[1].hash();
     }
 
     @DontCompile
     public void test86_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] vab = new MyValue1?[2];
+        MyValue1.ref[] vab = new MyValue1.ref[2];
         va[1] = testValue1;
         vab[1] = testValue1;
         long res = test86(va, testValue1);
         Asserts.assertEquals(res, testValue1.hash());
         Asserts.assertEquals(va[0].hash(), testValue1.hash());
@@ -2316,11 +2316,11 @@
     }
 
     // Test initialization of nullable array with constant
     @Test()
     public long test87() {
-        MyValue1?[] va = new MyValue1?[1];
+        MyValue1.ref[] va = new MyValue1.ref[1];
         va[0] = testValue1;
         return va[0].hash();
     }
 
     @DontCompile
@@ -2329,11 +2329,11 @@
         Asserts.assertEQ(result, hash());
     }
 
     // Test narrowing conversion from [L to [Q
     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    public static MyValue1[] test88(MyValue1?[] va) {
+    public static MyValue1[] test88(MyValue1.ref[] va) {
         return (MyValue1[])va;
     }
 
     @DontCompile
     public void test88_verifier(boolean warmup) {
@@ -2342,11 +2342,11 @@
         MyValue1[] res = test88(va);
         Asserts.assertEquals(res[0].hash(), testValue1.hash());
         res[0] = testValue1;
         test88(null); // Should not throw NPE
         try {
-            test88(new MyValue1?[1]);
+            test88(new MyValue1.ref[1]);
             throw new RuntimeException("ClassCastException expected");
         } catch (ClassCastException cce) {
             // Expected
         }
     }
@@ -2364,27 +2364,27 @@
         MyValue1[] res = test89(va);
         Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());
         res[0] = testValue1;
         test89(null); // Should not throw NPE
         try {
-            test89(new MyValue1?[1]);
+            test89(new MyValue1.ref[1]);
             throw new RuntimeException("ClassCastException expected");
         } catch (ClassCastException cce) {
             // Expected
         }
     }
 
     // More cast tests
     @Test()
-    public static MyValue1?[] test90(Object va) {
-        return (MyValue1?[])va;
+    public static MyValue1.ref[] test90(Object va) {
+        return (MyValue1.ref[])va;
     }
 
     @DontCompile
     public void test90_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[1];
-        MyValue1?[] vab = new MyValue1?[1];
+        MyValue1.ref[] vab = new MyValue1.ref[1];
         try {
           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
           test90(new Integer[0]);
         } catch (ClassCastException cce) {
           // Expected
@@ -2393,18 +2393,18 @@
         test90(vab);
         test90(null);
     }
 
     @Test()
-    public static MyValue1?[] test91(Object[] va) {
-        return (MyValue1?[])va;
+    public static MyValue1.ref[] test91(Object[] va) {
+        return (MyValue1.ref[])va;
     }
 
     @DontCompile
     public void test91_verifier(boolean warmup) {
         MyValue1[] va = new MyValue1[1];
-        MyValue1?[] vab = new MyValue1?[1];
+        MyValue1.ref[] vab = new MyValue1.ref[1];
         try {
           // Trigger some ClassCastExceptions so C2 does not add an uncommon trap
           test91(new Integer[0]);
         } catch (ClassCastException cce) {
           // Expected
@@ -2414,34 +2414,34 @@
         test91(null);
     }
 
     // Test if arraycopy intrinsic correctly checks for flattened source array
     @Test()
-    public static void test92(MyValue1?[] src, MyValue1?[] dst) {
+    public static void test92(MyValue1.ref[] src, MyValue1.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 2);
     }
 
     @DontCompile
     public void test92_verifier(boolean warmup) {
         MyValue1[]  va = new MyValue1[2];
-        MyValue1?[] vab = new MyValue1?[2];
+        MyValue1.ref[] vab = new MyValue1.ref[2];
         va[0] = testValue1;
         vab[0] = testValue1;
         test92(va, vab);
         Asserts.assertEquals(va[0], vab[0]);
         Asserts.assertEquals(va[1], vab[1]);
     }
 
     @Test()
-    public static void test93(Object src, MyValue1?[] dst) {
+    public static void test93(Object src, MyValue1.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, 2);
     }
 
     @DontCompile
     public void test93_verifier(boolean warmup) {
         MyValue1[]  va = new MyValue1[2];
-        MyValue1?[] vab = new MyValue1?[2];
+        MyValue1.ref[] vab = new MyValue1.ref[2];
         va[0] = testValue1;
         vab[0] = testValue1;
         test93(va, vab);
         Asserts.assertEquals(va[0], vab[0]);
         Asserts.assertEquals(va[1], vab[1]);
@@ -2449,11 +2449,11 @@
 
     // Test non-escaping allocation with arraycopy
     // that does not modify loaded array element.
     @Test()
     public static long test94() {
-        MyValue1?[] src = new MyValue1?[8];
+        MyValue1.ref[] src = new MyValue1.ref[8];
         MyValue1[]  dst = new MyValue1[8];
         for (int i = 1; i < 8; ++i) {
             src[i] = testValue1;
         }
         System.arraycopy(src, 1, dst, 2, 6);
@@ -2467,11 +2467,11 @@
     }
 
     // Test meeting constant TypeInstPtr with ValueTypeNode
     @ForceInline
     public long test95_callee() {
-        MyValue1?[] va = new MyValue1?[1];
+        MyValue1.ref[] va = new MyValue1.ref[1];
         va[0] = testValue1;
         return va[0].hashInterpreted();
     }
 
     @Test()
@@ -2505,27 +2505,27 @@
                                this.re * that.im + this.im * that.re);
         }
     }
 
     @Test()
-    public Complex?[][] test96(Complex?[][] A, Complex?[][] B) {
+    public Complex.ref[][] test96(Complex.ref[][] A, Complex.ref[][] B) {
         int size = A.length;
-        Complex?[][] R = new Complex?[size][size];
+        Complex.ref[][] R = new Complex.ref[size][size];
         for (int i = 0; i < size; i++) {
             for (int k = 0; k < size; k++) {
-                Complex? aik = A[i][k];
+                Complex.ref aik = A[i][k];
                 for (int j = 0; j < size; j++) {
                     R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));
                 }
             }
         }
         return R;
     }
 
-    static Complex?[][] test96_A = new Complex?[10][10];
-    static Complex?[][] test96_B = new Complex?[10][10];
-    static Complex?[][] test96_R;
+    static Complex.ref[][] test96_A = new Complex.ref[10][10];
+    static Complex.ref[][] test96_B = new Complex.ref[10][10];
+    static Complex.ref[][] test96_R;
 
     static {
         for (int i = 0; i < 10; i++) {
             for (int j = 0; j < 10; j++) {
                 test96_A[i][j] = new Complex(rI, rI);
@@ -2534,11 +2534,11 @@
         }
     }
 
     @DontCompile
     public void test96_verifier(boolean warmup) {
-        Complex?[][] result = test96(test96_A, test96_B);
+        Complex.ref[][] result = test96(test96_A, test96_B);
         if (test96_R == null) {
             test96_R = result;
         }
         for (int i = 0; i < 10; i++) {
             for (int j = 0; j < 10; j++) {
@@ -2578,11 +2578,11 @@
         myInt[0] = rI;
         result = test98((Object[])myInt);
         Asserts.assertEquals(result, rI);
         if (!warmup) {
             MyValue1[] va = new MyValue1[1];
-            MyValue1?[] vab = new MyValue1?[1];
+            MyValue1.ref[] vab = new MyValue1.ref[1];
             result = test98((Object[])va);
             Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.default.hash());
             result = test98((Object[])vab);
             Asserts.assertEquals(result, null);
         }
@@ -2667,11 +2667,11 @@
         Asserts.assertEquals(myInt[0], rI);
         test102(null, (Object[])myInt);
         Asserts.assertEquals(myInt[0], null);
         if (!warmup) {
             MyValue1[] va = new MyValue1[1];
-            MyValue1?[] vab = new MyValue1?[1];
+            MyValue1.ref[] vab = new MyValue1.ref[1];
             test102(testValue1, (Object[])va);
             Asserts.assertEquals(va[0].hash(), testValue1.hash());
             test102(testValue1, (Object[])vab);
             Asserts.assertEquals(vab[0].hash(), testValue1.hash());
             test102(null, (Object[])vab);
@@ -2777,30 +2777,30 @@
         myInt[0] = rI;
         result = test106(myInt, (Object[])myInt);
         Asserts.assertEquals(result[0], rI);
         if (!warmup) {
             MyValue1[] va = new MyValue1[1];
-            MyValue1?[] vab = new MyValue1?[1];
+            MyValue1.ref[] vab = new MyValue1.ref[1];
             result = test106(va, (Object[])va);
             Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.default.hash());
             result = test106(vab, (Object[])vab);
             Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());
         }
     }
 
     // Test that allocation is not replaced by non-dominating allocation
-    public long test107_helper(MyValue1?[] va, MyValue1 vt) {
+    public long test107_helper(MyValue1.ref[] va, MyValue1 vt) {
         try {
             va[0] = vt;
         } catch (NullPointerException npe) { }
         return va[1].hash();
     }
 
     @Test()
     public void test107() {
         MyValue1[] va = new MyValue1[2];
-        MyValue1?[] tmp = new MyValue1?[2];
+        MyValue1.ref[] tmp = new MyValue1.ref[2];
         long res1 = test107_helper(va, testValue1);
         long res2 = test107_helper(va, testValue1);
         Asserts.assertEquals(va[0].hash(), testValue1.hash());
         Asserts.assertEquals(res1, MyValue1.default.hash());
         Asserts.assertEquals(res2, MyValue1.default.hash());
@@ -2812,19 +2812,19 @@
     }
 
 
     @Test
     @Warmup(10000)
-    public Object test108(MyValue1?[] src, boolean flag) {
-        MyValue1?[] dst = new MyValue1?[8];
+    public Object test108(MyValue1.ref[] src, boolean flag) {
+        MyValue1.ref[] dst = new MyValue1.ref[8];
         System.arraycopy(src, 1, dst, 2, 6);
         if (flag) {} // uncommon trap
         return dst[2];
     }
 
     @DontCompile
     public void test108_verifier(boolean warmup) {
-        MyValue1?[] src = new MyValue1?[8];
+        MyValue1.ref[] src = new MyValue1.ref[8];
         test108(src, !warmup);
     }
 
 }
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableValueTypes.java
@@ -61,15 +61,15 @@
     static {
         try {
             Class<?> clazz = TestNullableValueTypes.class;
             MethodHandles.Lookup lookup = MethodHandles.lookup();
 
-            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.class.asNullableType());
+            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.ref.class);
             test18_mh1 = lookup.findStatic(clazz, "test18_target1", test18_mt);
             test18_mh2 = lookup.findStatic(clazz, "test18_target2", test18_mt);
 
-            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.class.asNullableType());
+            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.ref.class);
             test19_mh1 = lookup.findStatic(clazz, "test19_target1", test19_mt);
             test19_mh2 = lookup.findStatic(clazz, "test19_target2", test19_mt);
         } catch (NoSuchMethodException | IllegalAccessException e) {
             e.printStackTrace();
             throw new RuntimeException("Method handle lookup failed");
@@ -79,15 +79,15 @@
     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
     private static final MyValue1[] testValue1Array = new MyValue1[] {testValue1,
                                                                       testValue1,
                                                                       testValue1};
 
-    MyValue1? nullField;
+    MyValue1.ref nullField;
     MyValue1 valueField1 = testValue1;
 
     @Test
-    public long test1(MyValue1? vt) {
+    public long test1(MyValue1.ref vt) {
         long result = 0;
         try {
             result = vt.hash();
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException e) {
@@ -101,11 +101,11 @@
         long result = test1(null);
         Asserts.assertEquals(result, 0L);
     }
 
     @Test
-    public long test2(MyValue1? vt) {
+    public long test2(MyValue1.ref vt) {
         long result = 0;
         try {
             result = vt.hashInterpreted();
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException e) {
@@ -155,11 +155,11 @@
     public void test4_verifier(boolean warmup) {
         test4();
     }
 
     @Test
-    public MyValue1? test5(MyValue1? vt) {
+    public MyValue1.ref test5(MyValue1.ref vt) {
         try {
             Object o = vt;
             vt = (MyValue1)o;
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException e) {
@@ -172,21 +172,21 @@
         return vt;
     }
 
     @DontCompile
     public void test5_verifier(boolean warmup) {
-        MyValue1? vt = test5(nullField);
+        MyValue1.ref vt = test5(nullField);
         Asserts.assertEquals((Object)vt, null);
     }
 
     @DontInline
-    public MyValue1? test5_dontinline(MyValue1? vt) {
+    public MyValue1.ref test5_dontinline(MyValue1.ref vt) {
         return vt;
     }
 
     @ForceInline
-    public MyValue1? test5_inline(MyValue1? vt) {
+    public MyValue1.ref test5_inline(MyValue1.ref vt) {
         return vt;
     }
 
     @Test
     public MyValue1 test6(Object obj) {
@@ -205,16 +205,16 @@
         MyValue1 vt = test6(null);
         Asserts.assertEquals(vt.hash(), testValue1.hash());
     }
 
     @ForceInline
-    public MyValue1? getNullInline() {
+    public MyValue1.ref getNullInline() {
         return null;
     }
 
     @DontInline
-    public MyValue1? getNullDontInline() {
+    public MyValue1.ref getNullDontInline() {
         return null;
     }
 
     @Test
     public void test7() throws Throwable {
@@ -278,11 +278,11 @@
     }
 
     // null constant
     @Test
     public void test10(boolean flag) throws Throwable {
-        MyValue1? val = flag ? valueField1 : null;
+        MyValue1.ref val = flag ? valueField1 : null;
         valueField1 = (MyValue1) val;
     }
 
     @DontCompile
     public void test10_verifier(boolean warmup) throws Throwable {
@@ -296,11 +296,11 @@
     }
 
     // null constant
     @Test
     public void test11(boolean flag) throws Throwable {
-        MyValue1? val = flag ? null : valueField1;
+        MyValue1.ref val = flag ? null : valueField1;
         valueField1 = (MyValue1) val;
     }
 
     @DontCompile
     public void test11_verifier(boolean warmup) throws Throwable {
@@ -315,11 +315,11 @@
 
     // null return
     int test12_cnt;
 
     @DontInline
-    public MyValue1? test12_helper() {
+    public MyValue1.ref test12_helper() {
         test12_cnt++;
         return nullField;
     }
 
     @Test
@@ -341,11 +341,11 @@
         }
     }
 
     // null return at virtual call
     class A {
-        public MyValue1? test13_helper() {
+        public MyValue1.ref test13_helper() {
             return nullField;
         }
     }
 
     class B extends A {
@@ -353,11 +353,11 @@
             return (MyValue1) nullField;
         }
     }
 
     class C extends A {
-        public MyValue1? test13_helper() {
+        public MyValue1.ref test13_helper() {
             return nullField;
         }
     }
 
     class D extends C {
@@ -425,11 +425,11 @@
         }
         Asserts.assertEQ(testValue1Array[index].hash(), testValue1.hash());
     }
 
     @DontInline
-    MyValue1? getNullField1() {
+    MyValue1.ref getNullField1() {
         return nullField;
     }
 
     @DontInline
     MyValue1 getNullField2() {
@@ -457,19 +457,19 @@
     public void test15_verifier(boolean warmup) {
         test15();
     }
 
     @DontInline
-    public boolean test16_dontinline(MyValue1? vt) {
+    public boolean test16_dontinline(MyValue1.ref vt) {
         return (Object)vt == null;
     }
 
     // Test c2c call passing null for a value type
     @Test
     @Warmup(10000) // Warmup to make sure 'test17_dontinline' is compiled
     public boolean test16(Object arg) throws Exception {
-        Method test16method = getClass().getMethod("test16_dontinline", MyValue1.class.asNullableType());
+        Method test16method = getClass().getMethod("test16_dontinline", MyValue1.ref.class);
         return (boolean)test16method.invoke(this, arg);
     }
 
     @DontCompile
     public void test16_verifier(boolean warmup) throws Exception {
@@ -477,14 +477,14 @@
         Asserts.assertTrue(res);
     }
 
     // Test scalarization of default value type with non-flattenable field
     final inline class Test17Value {
-        public final MyValue1? valueField;
+        public final MyValue1.ref valueField;
 
         @ForceInline
-        public Test17Value(MyValue1? valueField) {
+        public Test17Value(MyValue1.ref valueField) {
             this.valueField = valueField;
         }
     }
 
     @Test()
@@ -504,19 +504,19 @@
     }
 
     static final MethodHandle test18_mh1;
     static final MethodHandle test18_mh2;
 
-    static MyValue1? nullValue;
+    static MyValue1.ref nullValue;
 
     @DontInline
-    static void test18_target1(MyValue1? vt) {
+    static void test18_target1(MyValue1.ref vt) {
         nullValue = vt;
     }
 
     @ForceInline
-    static void test18_target2(MyValue1? vt) {
+    static void test18_target2(MyValue1.ref vt) {
         nullValue = vt;
     }
 
     // Test passing null for a value type
     @Test
@@ -537,16 +537,16 @@
 
     static MethodHandle test19_mh1;
     static MethodHandle test19_mh2;
 
     @DontInline
-    static void test19_target1(MyValue1? vt) {
+    static void test19_target1(MyValue1.ref vt) {
         nullValue = vt;
     }
 
     @ForceInline
-    static void test19_target2(MyValue1? vt) {
+    static void test19_target2(MyValue1.ref vt) {
         nullValue = vt;
     }
 
     // Same as test12 but with non-final mh
     @Test
@@ -584,16 +584,16 @@
         }
     }
 
     // Test writing null to a flattenable/non-flattenable value type field in a value type
     final inline class Test21Value {
-        final MyValue1? valueField1;
+        final MyValue1.ref valueField1;
         final MyValue1 valueField2;
-        final MyValue1? alwaysNull = null;
+        final MyValue1.ref alwaysNull = null;
 
         @ForceInline
-        public Test21Value(MyValue1? valueField1, MyValue1 valueField2) {
+        public Test21Value(MyValue1.ref valueField1, MyValue1 valueField2) {
             this.valueField1 = testValue1;
             this.valueField2 = testValue1;
         }
 
         @ForceInline
@@ -643,27 +643,27 @@
             // Expected
         }
     }
 
     @Test
-    public void test23(MyValue1[] arr, MyValue1? b) {
+    public void test23(MyValue1[] arr, MyValue1.ref b) {
         arr[0] = (MyValue1) b;
     }
 
     @DontCompile
     public void test23_verifier(boolean warmup) {
         MyValue1[] arr = new MyValue1[2];
-        MyValue1? b = null;
+        MyValue1.ref b = null;
         try {
             test23(arr, b);
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException e) {
             // Expected
         }
     }
 
-    static MyValue1? nullBox;
+    static MyValue1.ref nullBox;
 
     @Test
     public MyValue1 test24() {
         return (MyValue1) nullBox;
     }
@@ -682,11 +682,11 @@
     public void test25_callee(MyValue1 val) { }
 
     // Test that when checkcasting from null-ok to null-free and back to null-ok we
     // keep track of the information that the value can never be null.
     @Test(failOn = ALLOC + STORE)
-    public int test25(boolean b, MyValue1? vt1, MyValue1 vt2) {
+    public int test25(boolean b, MyValue1.ref vt1, MyValue1 vt2) {
         vt1 = (MyValue1)vt1;
         Object obj = b ? vt1 : vt2; // We should not allocate here
         test25_callee((MyValue1) vt1);
         return ((MyValue1)obj).x;
     }
@@ -700,23 +700,23 @@
     }
 
     // Test that chains of casts are folded and don't trigger an allocation
     @Test(failOn = ALLOC + STORE)
     public MyValue3 test26(MyValue3 vt) {
-        return ((MyValue3)((Object)((MyValue3?)(MyValue3)((MyValue3?)((Object)vt)))));
+        return ((MyValue3)((Object)((MyValue3.ref)(MyValue3)((MyValue3.ref)((Object)vt)))));
     }
 
     @DontCompile
     public void test26_verifier(boolean warmup) {
         MyValue3 vt = MyValue3.create();
         MyValue3 result = test26(vt);
         Asserts.assertEquals(result, vt);
     }
 
     @Test(failOn = ALLOC + STORE)
-    public MyValue3? test27(MyValue3? vt) {
-        return ((MyValue3?)((Object)((MyValue3)(MyValue3?)((MyValue3)((Object)vt)))));
+    public MyValue3.ref test27(MyValue3.ref vt) {
+        return ((MyValue3.ref)((Object)((MyValue3)(MyValue3.ref)((MyValue3)((Object)vt)))));
     }
 
     @DontCompile
     public void test27_verifier(boolean warmup) {
         MyValue3 vt = MyValue3.create();
@@ -724,45 +724,45 @@
         Asserts.assertEquals(result, vt);
     }
 
     // Some more casting tests
     @Test()
-    public MyValue1? test28(MyValue1 vt, MyValue1? vtBox, int i) {
-        MyValue1? result = null;
+    public MyValue1.ref test28(MyValue1 vt, MyValue1.ref vtBox, int i) {
+        MyValue1.ref result = null;
         if (i == 0) {
-            result = (MyValue1?)vt;
+            result = (MyValue1.ref)vt;
             result = null;
         } else if (i == 1) {
-            result = (MyValue1?)vt;
+            result = (MyValue1.ref)vt;
         } else if (i == 2) {
             result = vtBox;
         }
         return result;
     }
 
     @DontCompile
     public void test28_verifier(boolean warmup) {
-        MyValue1? result = test28(testValue1, null, 0);
+        MyValue1.ref result = test28(testValue1, null, 0);
         Asserts.assertEquals(result, null);
         result = test28(testValue1, testValue1, 1);
         Asserts.assertEquals(result, testValue1);
         result = test28(testValue1, null, 2);
         Asserts.assertEquals(result, null);
         result = test28(testValue1, testValue1, 2);
         Asserts.assertEquals(result, testValue1);
     }
 
     @Test()
-    public long test29(MyValue1 vt, MyValue1? vtBox) {
+    public long test29(MyValue1 vt, MyValue1.ref vtBox) {
         long result = 0;
         for (int i = 0; i < 100; ++i) {
-            MyValue1? box;
+            MyValue1.ref box;
             if (i == 0) {
-                box = (MyValue1?)vt;
+                box = (MyValue1.ref)vt;
                 box = null;
             } else if (i < 99) {
-                box = (MyValue1?)vt;
+                box = (MyValue1.ref)vt;
             } else {
                 box = vtBox;
             }
             if (box != null) {
                 result += box.hash();
@@ -778,11 +778,11 @@
         result = test29(testValue1, testValue1);
         Asserts.assertEquals(result, testValue1.hash()*99);
     }
 
     // Test null check of value type receiver with incremental inlining
-    public long test30_callee(MyValue1? vt) {
+    public long test30_callee(MyValue1.ref vt) {
         long result = 0;
         try {
             result = vt.hashInterpreted();
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException e) {
@@ -820,29 +820,29 @@
     @DontCompile
     public void test31_verifier(boolean warmup) {
         test31(null);
     }
 
-    private static final MyValue1? constNullField = null;
+    private static final MyValue1.ref constNullField = null;
 
     @Test
-    public MyValue1? test32() {
+    public MyValue1.ref test32() {
         return constNullField;
     }
 
     @DontCompile
     public void test32_verifier(boolean warmup) {
-        MyValue1? result = test32();
+        MyValue1.ref result = test32();
         Asserts.assertEquals(result, null);
     }
 
     static inline class Test33Value1 {
         int x = 0;
     }
 
     static inline class Test33Value2 {
-        Test33Value1? vt;
+        Test33Value1.ref vt;
 
         public Test33Value2() {
             vt = new Test33Value1();
         }
     }
@@ -860,11 +860,11 @@
         Asserts.assertEquals(result, test33Val);
     }
 
     // Verify that static nullable inline-type fields are not
     // treated as never-null by C2 when initialized at compile time.
-    private static MyValue1? test34Val;
+    private static MyValue1.ref test34Val;
 
     @Test
     public void test34(MyValue1 vt) {
         if (test34Val == null) {
             test34Val = vt;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestOnStackReplacement.java
@@ -156,15 +156,15 @@
         test4();
     }
 
     // OSR compilation with null value type local
 
-    MyValue1? nullField;
+    MyValue1.ref nullField;
 
     @Test() @Warmup(0) @OSRCompileOnly
     public void test5() {
-        MyValue1? vt = nullField;
+        MyValue1.ref vt = nullField;
         for (int i = 0; i < 50_000; i++) {
             if (vt != null) {
                 throw new RuntimeException("test5 failed: vt should be null");
             }
         }
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestUnloadedValueTypeArray.java
@@ -139,11 +139,11 @@
 
     public MyValue6Box(int n) {
         foo = n;
     }
 
-    public MyValue6Box(MyValue6Box v, MyValue6Box?[] dummy) {
+    public MyValue6Box(MyValue6Box v, MyValue6Box.ref[] dummy) {
         foo = v.foo + 1;
     }
 }
 
 final inline class MyValue7 {
@@ -194,12 +194,12 @@
 
     static void test1() {
         target1();
     }
 
-    static MyValue1Box?[] target1Box() {
-        return new MyValue1Box?[10];
+    static MyValue1Box.ref[] target1Box() {
+        return new MyValue1Box.ref[10];
     }
 
     static void test1Box() {
         target1Box();
     }
@@ -228,11 +228,11 @@
             m = test2(arr);
         }
         Asserts.assertEQ(m, 5678);
     }
 
-    static int test2Box(MyValue2Box?[] arr) {
+    static int test2Box(MyValue2Box.ref[] arr) {
         if (arr != null) {
             return arr[1].foo;
         } else {
             return 1234;
         }
@@ -245,11 +245,11 @@
         for (int i=0; i<n; i++) {
             m = test2Box(null);
         }
         Asserts.assertEQ(m, 1234);
 
-        MyValue2Box?[] arr = new MyValue2Box?[2];
+        MyValue2Box.ref[] arr = new MyValue2Box.ref[2];
         arr[1] = new MyValue2Box(5678);
         m = 9999;
         for (int i=0; i<n; i++) {
             m = test2Box(arr);
         }
@@ -274,11 +274,11 @@
             test3(arr);
         }
         Asserts.assertEQ(arr[1].foo, 2345);
     }
 
-    static void test3Box(MyValue3Box?[] arr) {
+    static void test3Box(MyValue3Box.ref[] arr) {
         if (arr != null) {
             arr[0] = null;
             arr[1] = new MyValue3Box(2345);
         }
     }
@@ -288,11 +288,11 @@
 
         for (int i=0; i<n; i++) {
             test3Box(null);
         }
 
-        MyValue3Box?[] arr = new MyValue3Box?[2];
+        MyValue3Box.ref[] arr = new MyValue3Box.ref[2];
         for (int i=0; i<n; i++) {
             test3Box(arr);
         }
         Asserts.assertEQ(arr[0], null);
         Asserts.assertEQ(arr[1].foo, 2345);
@@ -321,14 +321,14 @@
             arr = test4(true);
         }
         Asserts.assertEQ(arr[1].foo, 2345);
     }
 
-    static MyValue4Box?[] test4Box(boolean b) {
+    static MyValue4Box.ref[] test4Box(boolean b) {
         // range check elimination
         if (b) {
-            MyValue4Box?[] arr = new MyValue4Box?[10];
+            MyValue4Box.ref[] arr = new MyValue4Box.ref[10];
             arr[0] = null;
             arr[1] = new MyValue4Box(2345);
             return arr;
         } else {
             return null;
@@ -340,11 +340,11 @@
 
         for (int i=0; i<n; i++) {
             test4Box(false);
         }
 
-        MyValue4Box?[] arr = null;
+        MyValue4Box.ref[] arr = null;
         for (int i=0; i<n; i++) {
             arr = test4Box(true);
         }
         Asserts.assertEQ(arr[0], null);
         Asserts.assertEQ(arr[1].foo, 2345);
@@ -357,11 +357,11 @@
         } else if (n == 1) {
             MyValue5[] arr = new MyValue5[10];
             arr[1] = new MyValue5(12345);
             return arr;
         } else {
-            MyValue5?[] arr = new MyValue5?[10];
+            MyValue5.ref[] arr = new MyValue5.ref[10];
             arr[1] = new MyValue5(22345);
             return arr;
         }
     }
 
@@ -378,13 +378,13 @@
                 arr = (MyValue5[])test5(1);
             }
             Asserts.assertEQ(arr[1].foo, 12345);
         }
         {
-            MyValue5?[] arr = null;
+            MyValue5.ref[] arr = null;
             for (int i=0; i<n; i++) {
-                arr = (MyValue5?[])test5(2);
+                arr = (MyValue5.ref[])test5(2);
             }
             Asserts.assertEQ(arr[1].foo, 22345);
         }
     }
 
@@ -433,11 +433,11 @@
             m = test7(arr);
         }
         Asserts.assertEQ(m, 5678);
     }
 
-    static int test7Box(MyValue7Box?[][] arr) {
+    static int test7Box(MyValue7Box.ref[][] arr) {
         if (arr != null) {
             arr[0][0] = null;
             return arr[0][1].foo;
         } else {
             return 1234;
@@ -451,11 +451,11 @@
         for (int i=0; i<n; i++) {
             m = test7Box(null);
         }
         Asserts.assertEQ(m, 1234);
 
-        MyValue7Box?[][] arr = new MyValue7Box?[2][2];
+        MyValue7Box.ref[][] arr = new MyValue7Box.ref[2][2];
         Object[] oa = arr[1];
         Asserts.assertEQ(oa[0], null);
 
         arr[0][1] = new MyValue7Box(5678);
         m = 9999;
@@ -465,32 +465,32 @@
         Asserts.assertEQ(m, 5678);
         Asserts.assertEQ(arr[0][0], null);
     }
 
     static void test8() {
-        MyValue8? a[] = new MyValue8?[0];
+        MyValue8.ref a[] = new MyValue8.ref[0];
         Asserts.assertEQ(MyValue8_inited, false);
 
         MyValue8  b[] = new MyValue8 [0];
         Asserts.assertEQ(MyValue8_inited, true);
     }
 
     static void test9() {
-        MyValue9? a[][] = new MyValue9?[10][0];
+        MyValue9.ref a[][] = new MyValue9.ref[10][0];
         Asserts.assertEQ(MyValue9_inited, false);
 
         MyValue9  b[][] = new MyValue9 [10][0];
         Asserts.assertEQ(MyValue9_inited, true);
     }
 
-    static void test10(MyValue10? dummy) {
+    static void test10(MyValue10.ref dummy) {
         MyValue10[][] a = new MyValue10[1][1];
         if (a[0][0].equals(null)) throw new RuntimeException("test10 failed");
     }
 
-    static void test11(MyValue10? dummy) {
-        MyValue11?[][] a = new MyValue11?[1][1];
+    static void test11(MyValue10.ref dummy) {
+        MyValue11.ref[][] a = new MyValue11.ref[1][1];
         if (a[0][0] != null) throw new RuntimeException("test11 failed");
     }
 
     static public void main(String[] args) {
         test1();
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestWithfieldC1.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestWithfieldC1.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestWithfieldC1.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestWithfieldC1.java
@@ -86,13 +86,13 @@
             };
         }
         return null;
     }
 
-    static FooValue? foo_static;
-    static FooValue? foo_static_arr[] = new FooValue?[1];
-    FooValue? foo_instance;
+    static FooValue.ref foo_static;
+    static FooValue.ref foo_static_arr[] = new FooValue.ref[1];
+    FooValue.ref foo_instance;
 
     @DontInline
     static void set_foo_static_if_null(FooValue v) {
         if (foo_static == null) {
             foo_static = v;

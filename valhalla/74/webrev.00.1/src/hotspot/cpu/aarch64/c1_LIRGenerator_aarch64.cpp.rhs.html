<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_Instruction.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArray.hpp&quot;
  36 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  37 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  38 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;utilities/powerOfTwo.hpp&quot;
  42 #include &quot;vmreg_aarch64.inline.hpp&quot;
  43 
  44 #ifdef ASSERT
  45 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  46 #else
  47 #define __ gen()-&gt;lir()-&gt;
  48 #endif
  49 
  50 // Item will be loaded into a byte register; Intel only
  51 void LIRItem::load_byte_item() {
  52   load_item();
  53 }
  54 
  55 
  56 void LIRItem::load_nonconstant() {
  57   LIR_Opr r = value()-&gt;operand();
  58   if (r-&gt;is_constant()) {
  59     _result = r;
  60   } else {
  61     load_item();
  62   }
  63 }
  64 
  65 //--------------------------------------------------------------
  66 //               LIRGenerator
  67 //--------------------------------------------------------------
  68 
  69 
  70 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::r0_oop_opr; }
  71 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::r3_opr; }
  72 LIR_Opr LIRGenerator::divInOpr()        { Unimplemented(); return LIR_OprFact::illegalOpr; }
  73 LIR_Opr LIRGenerator::divOutOpr()       { Unimplemented(); return LIR_OprFact::illegalOpr; }
  74 LIR_Opr LIRGenerator::remOutOpr()       { Unimplemented(); return LIR_OprFact::illegalOpr; }
  75 LIR_Opr LIRGenerator::shiftCountOpr()   { Unimplemented(); return LIR_OprFact::illegalOpr; }
  76 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  77 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::r0_opr; }
  78 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  79 
  80 
  81 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  82   LIR_Opr opr;
  83   switch (type-&gt;tag()) {
  84     case intTag:     opr = FrameMap::r0_opr;          break;
  85     case objectTag:  opr = FrameMap::r0_oop_opr;      break;
  86     case longTag:    opr = FrameMap::long0_opr;        break;
  87     case floatTag:   opr = FrameMap::fpu0_float_opr;  break;
  88     case doubleTag:  opr = FrameMap::fpu0_double_opr;  break;
  89 
  90     case addressTag:
  91     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
  92   }
  93 
  94   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
  95   return opr;
  96 }
  97 
  98 
  99 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 100   LIR_Opr reg = new_register(T_INT);
 101   set_vreg_flag(reg, LIRGenerator::byte_reg);
 102   return reg;
 103 }
 104 
 105 
<a name="2" id="anc2"></a><span class="line-added"> 106 void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr&amp; tmp1, LIR_Opr&amp; tmp2) {</span>
<span class="line-added"> 107   tmp1 = new_register(T_INT);</span>
<span class="line-added"> 108   tmp2 = LIR_OprFact::illegalOpr;</span>
<span class="line-added"> 109 }</span>
<span class="line-added"> 110 </span>
<span class="line-added"> 111 </span>
 112 //--------- loading items into registers --------------------------------
 113 
 114 
 115 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 116   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 117     return v-&gt;type()-&gt;as_IntConstant()-&gt;value() == 0L;
 118   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 119     return v-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0L;
 120   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 121     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 122   } else {
 123     return false;
 124   }
 125 }
 126 
 127 bool LIRGenerator::can_inline_as_constant(Value v) const {
 128   // FIXME: Just a guess
 129   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 130     return Assembler::operand_valid_for_add_sub_immediate(v-&gt;type()-&gt;as_IntConstant()-&gt;value());
 131   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 132     return v-&gt;type()-&gt;as_LongConstant()-&gt;value() == 0L;
 133   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 134     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 135   } else {
 136     return false;
 137   }
 138 }
 139 
 140 
 141 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const { return false; }
 142 
 143 
 144 LIR_Opr LIRGenerator::safepoint_poll_register() {
 145   return LIR_OprFact::illegalOpr;
 146 }
 147 
 148 
 149 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 150                                             int shift, int disp, BasicType type) {
 151   assert(base-&gt;is_register(), &quot;must be&quot;);
 152   intx large_disp = disp;
 153 
 154   // accumulate fixed displacements
 155   if (index-&gt;is_constant()) {
 156     LIR_Const *constant = index-&gt;as_constant_ptr();
 157     if (constant-&gt;type() == T_INT) {
 158       large_disp += index-&gt;as_jint() &lt;&lt; shift;
 159     } else {
 160       assert(constant-&gt;type() == T_LONG, &quot;should be&quot;);
 161       jlong c = index-&gt;as_jlong() &lt;&lt; shift;
 162       if ((jlong)((jint)c) == c) {
 163         large_disp += c;
 164         index = LIR_OprFact::illegalOpr;
 165       } else {
 166         LIR_Opr tmp = new_register(T_LONG);
 167         __ move(index, tmp);
 168         index = tmp;
 169         // apply shift and displacement below
 170       }
 171     }
 172   }
 173 
 174   if (index-&gt;is_register()) {
 175     // apply the shift and accumulate the displacement
 176     if (shift &gt; 0) {
 177       LIR_Opr tmp = new_pointer_register();
 178       __ shift_left(index, shift, tmp);
 179       index = tmp;
 180     }
 181     if (large_disp != 0) {
 182       LIR_Opr tmp = new_pointer_register();
 183       if (Assembler::operand_valid_for_add_sub_immediate(large_disp)) {
 184         __ add(tmp, tmp, LIR_OprFact::intptrConst(large_disp));
 185         index = tmp;
 186       } else {
 187         __ move(tmp, LIR_OprFact::intptrConst(large_disp));
 188         __ add(tmp, index, tmp);
 189         index = tmp;
 190       }
 191       large_disp = 0;
 192     }
 193   } else if (large_disp != 0 &amp;&amp; !Address::offset_ok_for_immed(large_disp, shift)) {
 194     // index is illegal so replace it with the displacement loaded into a register
 195     index = new_pointer_register();
 196     __ move(LIR_OprFact::intptrConst(large_disp), index);
 197     large_disp = 0;
 198   }
 199 
 200   // at this point we either have base + index or base + displacement
 201   if (large_disp == 0) {
 202     return new LIR_Address(base, index, type);
 203   } else {
 204     assert(Address::offset_ok_for_immed(large_disp, 0), &quot;must be&quot;);
 205     return new LIR_Address(base, large_disp, type);
 206   }
 207 }
 208 
 209 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 210                                               BasicType type) {
 211   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 212   int elem_size = type2aelembytes(type);
 213   int shift = exact_log2(elem_size);
 214 
 215   LIR_Address* addr;
 216   if (index_opr-&gt;is_constant()) {
 217     addr = new LIR_Address(array_opr,
 218                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 219   } else {
 220     if (offset_in_bytes) {
 221       LIR_Opr tmp = new_pointer_register();
 222       __ add(array_opr, LIR_OprFact::intConst(offset_in_bytes), tmp);
 223       array_opr = tmp;
 224       offset_in_bytes = 0;
 225     }
 226     addr =  new LIR_Address(array_opr,
 227                             index_opr,
 228                             LIR_Address::scale(type),
 229                             offset_in_bytes, type);
 230   }
 231   return addr;
 232 }
 233 
 234 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 235   LIR_Opr r;
 236   if (type == T_LONG) {
 237     r = LIR_OprFact::longConst(x);
 238     if (!Assembler::operand_valid_for_logical_immediate(false, x)) {
 239       LIR_Opr tmp = new_register(type);
 240       __ move(r, tmp);
 241       return tmp;
 242     }
 243   } else if (type == T_INT) {
 244     r = LIR_OprFact::intConst(x);
 245     if (!Assembler::operand_valid_for_logical_immediate(true, x)) {
 246       // This is all rather nasty.  We don&#39;t know whether our constant
 247       // is required for a logical or an arithmetic operation, wo we
 248       // don&#39;t know what the range of valid values is!!
 249       LIR_Opr tmp = new_register(type);
 250       __ move(r, tmp);
 251       return tmp;
 252     }
 253   } else {
 254     ShouldNotReachHere();
 255     r = NULL;  // unreachable
 256   }
 257   return r;
 258 }
 259 
 260 
 261 
 262 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 263   LIR_Opr pointer = new_pointer_register();
 264   __ move(LIR_OprFact::intptrConst(counter), pointer);
 265   LIR_Address* addr = new LIR_Address(pointer, type);
 266   increment_counter(addr, step);
 267 }
 268 
 269 
 270 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 271   LIR_Opr imm = NULL;
 272   switch(addr-&gt;type()) {
 273   case T_INT:
 274     imm = LIR_OprFact::intConst(step);
 275     break;
 276   case T_LONG:
 277     imm = LIR_OprFact::longConst(step);
 278     break;
 279   default:
 280     ShouldNotReachHere();
 281   }
 282   LIR_Opr reg = new_register(addr-&gt;type());
 283   __ load(addr, reg);
 284   __ add(reg, imm, reg);
 285   __ store(reg, addr);
 286 }
 287 
 288 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 289   LIR_Opr reg = new_register(T_INT);
 290   __ load(generate_address(base, disp, T_INT), reg, info);
 291   __ cmp(condition, reg, LIR_OprFact::intConst(c));
 292 }
 293 
 294 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 295   LIR_Opr reg1 = new_register(T_INT);
 296   __ load(generate_address(base, disp, type), reg1, info);
 297   __ cmp(condition, reg, reg1);
 298 }
 299 
 300 
 301 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 302 
 303   if (is_power_of_2(c - 1)) {
 304     __ shift_left(left, exact_log2(c - 1), tmp);
 305     __ add(tmp, left, result);
 306     return true;
 307   } else if (is_power_of_2(c + 1)) {
 308     __ shift_left(left, exact_log2(c + 1), tmp);
 309     __ sub(tmp, left, result);
 310     return true;
 311   } else {
 312     return false;
 313   }
 314 }
 315 
 316 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 317   BasicType type = item-&gt;type();
 318   __ store(item, new LIR_Address(FrameMap::sp_opr, in_bytes(offset_from_sp), type));
 319 }
 320 
 321 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 322     LIR_Opr tmp1 = new_register(objectType);
 323     LIR_Opr tmp2 = new_register(objectType);
 324     LIR_Opr tmp3 = new_register(objectType);
 325     __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 326 }
 327 
 328 //----------------------------------------------------------------------
 329 //             visitor functions
 330 //----------------------------------------------------------------------
 331 
 332 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 333   assert(x-&gt;is_pinned(),&quot;&quot;);
 334   LIRItem obj(x-&gt;obj(), this);
 335   obj.load_item();
 336 
 337   set_no_result(x);
 338 
 339   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 340   LIR_Opr lock = new_register(T_INT);
 341   // Need a scratch register for biased locking
 342   LIR_Opr scratch = LIR_OprFact::illegalOpr;
<a name="3" id="anc3"></a><span class="line-modified"> 343   if (UseBiasedLocking || x-&gt;maybe_valuetype()) {</span>
 344     scratch = new_register(T_INT);
 345   }
 346 
 347   CodeEmitInfo* info_for_exception = NULL;
 348   if (x-&gt;needs_null_check()) {
 349     info_for_exception = state_for(x);
 350   }
<a name="4" id="anc4"></a><span class="line-added"> 351 </span>
<span class="line-added"> 352   CodeStub* throw_imse_stub =</span>
<span class="line-added"> 353       x-&gt;maybe_valuetype() ?</span>
<span class="line-added"> 354       new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id, LIR_OprFact::illegalOpr, state_for(x)) :</span>
<span class="line-added"> 355       NULL;</span>
<span class="line-added"> 356 </span>
 357   // this CodeEmitInfo must not have the xhandlers because here the
 358   // object is already locked (xhandlers expect object to be unlocked)
 359   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 360   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
<a name="5" id="anc5"></a><span class="line-modified"> 361                         x-&gt;monitor_no(), info_for_exception, info, throw_imse_stub);</span>
 362 }
 363 
 364 
 365 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 366   assert(x-&gt;is_pinned(),&quot;&quot;);
 367 
 368   LIRItem obj(x-&gt;obj(), this);
 369   obj.dont_load_item();
 370 
 371   LIR_Opr lock = new_register(T_INT);
 372   LIR_Opr obj_temp = new_register(T_INT);
 373   set_no_result(x);
 374   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 375 }
 376 
 377 
 378 void LIRGenerator::do_NegateOp(NegateOp* x) {
 379 
 380   LIRItem from(x-&gt;x(), this);
 381   from.load_item();
 382   LIR_Opr result = rlock_result(x);
 383   __ negate (from.result(), result);
 384 
 385 }
 386 
 387 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 388 //      _dadd, _dmul, _dsub, _ddiv, _drem
 389 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 390 
 391   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {
 392     // float remainder is implemented as a direct call into the runtime
 393     LIRItem right(x-&gt;x(), this);
 394     LIRItem left(x-&gt;y(), this);
 395 
 396     BasicTypeList signature(2);
 397     if (x-&gt;op() == Bytecodes::_frem) {
 398       signature.append(T_FLOAT);
 399       signature.append(T_FLOAT);
 400     } else {
 401       signature.append(T_DOUBLE);
 402       signature.append(T_DOUBLE);
 403     }
 404     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 405 
 406     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 407     left.load_item_force(cc-&gt;at(1));
 408     right.load_item();
 409 
 410     __ move(right.result(), cc-&gt;at(0));
 411 
 412     address entry;
 413     if (x-&gt;op() == Bytecodes::_frem) {
 414       entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 415     } else {
 416       entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 417     }
 418 
 419     LIR_Opr result = rlock_result(x);
 420     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 421     __ move(result_reg, result);
 422 
 423     return;
 424   }
 425 
 426   LIRItem left(x-&gt;x(),  this);
 427   LIRItem right(x-&gt;y(), this);
 428   LIRItem* left_arg  = &amp;left;
 429   LIRItem* right_arg = &amp;right;
 430 
 431   // Always load right hand side.
 432   right.load_item();
 433 
 434   if (!left.is_register())
 435     left.load_item();
 436 
 437   LIR_Opr reg = rlock(x);
 438   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 439   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 440     tmp = new_register(T_DOUBLE);
 441   }
 442 
 443   arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp());
 444 
 445   set_result(x, round_item(reg));
 446 }
 447 
 448 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 449 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 450 
 451   // missing test if instr is commutative and if we should swap
 452   LIRItem left(x-&gt;x(), this);
 453   LIRItem right(x-&gt;y(), this);
 454 
 455   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 456 
 457     left.load_item();
 458     bool need_zero_check = true;
 459     if (right.is_constant()) {
 460       jlong c = right.get_jlong_constant();
 461       // no need to do div-by-zero check if the divisor is a non-zero constant
 462       if (c != 0) need_zero_check = false;
 463       // do not load right if the divisor is a power-of-2 constant
 464       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 465         right.dont_load_item();
 466       } else {
 467         right.load_item();
 468       }
 469     } else {
 470       right.load_item();
 471     }
 472     if (need_zero_check) {
 473       CodeEmitInfo* info = state_for(x);
 474       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 475       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 476     }
 477 
 478     rlock_result(x);
 479     switch (x-&gt;op()) {
 480     case Bytecodes::_lrem:
 481       __ rem (left.result(), right.result(), x-&gt;operand());
 482       break;
 483     case Bytecodes::_ldiv:
 484       __ div (left.result(), right.result(), x-&gt;operand());
 485       break;
 486     default:
 487       ShouldNotReachHere();
 488       break;
 489     }
 490 
 491 
 492   } else {
 493     assert (x-&gt;op() == Bytecodes::_lmul || x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub,
 494             &quot;expect lmul, ladd or lsub&quot;);
 495     // add, sub, mul
 496     left.load_item();
 497     if (! right.is_register()) {
 498       if (x-&gt;op() == Bytecodes::_lmul
 499           || ! right.is_constant()
 500           || ! Assembler::operand_valid_for_add_sub_immediate(right.get_jlong_constant())) {
 501         right.load_item();
 502       } else { // add, sub
 503         assert (x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub, &quot;expect ladd or lsub&quot;);
 504         // don&#39;t load constants to save register
 505         right.load_nonconstant();
 506       }
 507     }
 508     rlock_result(x);
 509     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 510   }
 511 }
 512 
 513 // for: _iadd, _imul, _isub, _idiv, _irem
 514 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 515 
 516   // Test if instr is commutative and if we should swap
 517   LIRItem left(x-&gt;x(),  this);
 518   LIRItem right(x-&gt;y(), this);
 519   LIRItem* left_arg = &amp;left;
 520   LIRItem* right_arg = &amp;right;
 521   if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 522     // swap them if left is real stack (or cached) and right is real register(not cached)
 523     left_arg = &amp;right;
 524     right_arg = &amp;left;
 525   }
 526 
 527   left_arg-&gt;load_item();
 528 
 529   // do not need to load right, as we can handle stack and constants
 530   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 531 
 532     rlock_result(x);
 533     bool need_zero_check = true;
 534     if (right.is_constant()) {
 535       jint c = right.get_jint_constant();
 536       // no need to do div-by-zero check if the divisor is a non-zero constant
 537       if (c != 0) need_zero_check = false;
 538       // do not load right if the divisor is a power-of-2 constant
 539       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 540         right_arg-&gt;dont_load_item();
 541       } else {
 542         right_arg-&gt;load_item();
 543       }
 544     } else {
 545       right_arg-&gt;load_item();
 546     }
 547     if (need_zero_check) {
 548       CodeEmitInfo* info = state_for(x);
 549       __ cmp(lir_cond_equal, right_arg-&gt;result(), LIR_OprFact::longConst(0));
 550       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 551     }
 552 
 553     LIR_Opr ill = LIR_OprFact::illegalOpr;
 554     if (x-&gt;op() == Bytecodes::_irem) {
 555       __ irem(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 556     } else if (x-&gt;op() == Bytecodes::_idiv) {
 557       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 558     }
 559 
 560   } else if (x-&gt;op() == Bytecodes::_iadd || x-&gt;op() == Bytecodes::_isub) {
 561     if (right.is_constant()
 562         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(right.get_jint_constant())) {
 563       right.load_nonconstant();
 564     } else {
 565       right.load_item();
 566     }
 567     rlock_result(x);
 568     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), LIR_OprFact::illegalOpr);
 569   } else {
 570     assert (x-&gt;op() == Bytecodes::_imul, &quot;expect imul&quot;);
 571     if (right.is_constant()) {
 572       jint c = right.get_jint_constant();
 573       if (c &gt; 0 &amp;&amp; c &lt; max_jint &amp;&amp; (is_power_of_2(c) || is_power_of_2(c - 1) || is_power_of_2(c + 1))) {
 574         right_arg-&gt;dont_load_item();
 575       } else {
 576         // Cannot use constant op.
 577         right_arg-&gt;load_item();
 578       }
 579     } else {
 580       right.load_item();
 581     }
 582     rlock_result(x);
 583     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), new_register(T_INT));
 584   }
 585 }
 586 
 587 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 588   // when an operand with use count 1 is the left operand, then it is
 589   // likely that no move for 2-operand-LIR-form is necessary
 590   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 591     x-&gt;swap_operands();
 592   }
 593 
 594   ValueTag tag = x-&gt;type()-&gt;tag();
 595   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 596   switch (tag) {
 597     case floatTag:
 598     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 599     case longTag:    do_ArithmeticOp_Long(x); return;
 600     case intTag:     do_ArithmeticOp_Int(x);  return;
 601     default:         ShouldNotReachHere();    return;
 602   }
 603 }
 604 
 605 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 606 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 607 
 608   LIRItem left(x-&gt;x(),  this);
 609   LIRItem right(x-&gt;y(), this);
 610 
 611   left.load_item();
 612 
 613   rlock_result(x);
 614   if (right.is_constant()) {
 615     right.dont_load_item();
 616 
 617     switch (x-&gt;op()) {
 618     case Bytecodes::_ishl: {
 619       int c = right.get_jint_constant() &amp; 0x1f;
 620       __ shift_left(left.result(), c, x-&gt;operand());
 621       break;
 622     }
 623     case Bytecodes::_ishr: {
 624       int c = right.get_jint_constant() &amp; 0x1f;
 625       __ shift_right(left.result(), c, x-&gt;operand());
 626       break;
 627     }
 628     case Bytecodes::_iushr: {
 629       int c = right.get_jint_constant() &amp; 0x1f;
 630       __ unsigned_shift_right(left.result(), c, x-&gt;operand());
 631       break;
 632     }
 633     case Bytecodes::_lshl: {
 634       int c = right.get_jint_constant() &amp; 0x3f;
 635       __ shift_left(left.result(), c, x-&gt;operand());
 636       break;
 637     }
 638     case Bytecodes::_lshr: {
 639       int c = right.get_jint_constant() &amp; 0x3f;
 640       __ shift_right(left.result(), c, x-&gt;operand());
 641       break;
 642     }
 643     case Bytecodes::_lushr: {
 644       int c = right.get_jint_constant() &amp; 0x3f;
 645       __ unsigned_shift_right(left.result(), c, x-&gt;operand());
 646       break;
 647     }
 648     default:
 649       ShouldNotReachHere();
 650     }
 651   } else {
 652     right.load_item();
 653     LIR_Opr tmp = new_register(T_INT);
 654     switch (x-&gt;op()) {
 655     case Bytecodes::_ishl: {
 656       __ logical_and(right.result(), LIR_OprFact::intConst(0x1f), tmp);
 657       __ shift_left(left.result(), tmp, x-&gt;operand(), tmp);
 658       break;
 659     }
 660     case Bytecodes::_ishr: {
 661       __ logical_and(right.result(), LIR_OprFact::intConst(0x1f), tmp);
 662       __ shift_right(left.result(), tmp, x-&gt;operand(), tmp);
 663       break;
 664     }
 665     case Bytecodes::_iushr: {
 666       __ logical_and(right.result(), LIR_OprFact::intConst(0x1f), tmp);
 667       __ unsigned_shift_right(left.result(), tmp, x-&gt;operand(), tmp);
 668       break;
 669     }
 670     case Bytecodes::_lshl: {
 671       __ logical_and(right.result(), LIR_OprFact::intConst(0x3f), tmp);
 672       __ shift_left(left.result(), tmp, x-&gt;operand(), tmp);
 673       break;
 674     }
 675     case Bytecodes::_lshr: {
 676       __ logical_and(right.result(), LIR_OprFact::intConst(0x3f), tmp);
 677       __ shift_right(left.result(), tmp, x-&gt;operand(), tmp);
 678       break;
 679     }
 680     case Bytecodes::_lushr: {
 681       __ logical_and(right.result(), LIR_OprFact::intConst(0x3f), tmp);
 682       __ unsigned_shift_right(left.result(), tmp, x-&gt;operand(), tmp);
 683       break;
 684     }
 685     default:
 686       ShouldNotReachHere();
 687     }
 688   }
 689 }
 690 
 691 // _iand, _land, _ior, _lor, _ixor, _lxor
 692 void LIRGenerator::do_LogicOp(LogicOp* x) {
 693 
 694   LIRItem left(x-&gt;x(),  this);
 695   LIRItem right(x-&gt;y(), this);
 696 
 697   left.load_item();
 698 
 699   rlock_result(x);
 700   if (right.is_constant()
 701       &amp;&amp; ((right.type()-&gt;tag() == intTag
 702            &amp;&amp; Assembler::operand_valid_for_logical_immediate(true, right.get_jint_constant()))
 703           || (right.type()-&gt;tag() == longTag
 704               &amp;&amp; Assembler::operand_valid_for_logical_immediate(false, right.get_jlong_constant()))))  {
 705     right.dont_load_item();
 706   } else {
 707     right.load_item();
 708   }
 709   switch (x-&gt;op()) {
 710   case Bytecodes::_iand:
 711   case Bytecodes::_land:
 712     __ logical_and(left.result(), right.result(), x-&gt;operand()); break;
 713   case Bytecodes::_ior:
 714   case Bytecodes::_lor:
 715     __ logical_or (left.result(), right.result(), x-&gt;operand()); break;
 716   case Bytecodes::_ixor:
 717   case Bytecodes::_lxor:
 718     __ logical_xor(left.result(), right.result(), x-&gt;operand()); break;
 719   default: Unimplemented();
 720   }
 721 }
 722 
 723 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 724 void LIRGenerator::do_CompareOp(CompareOp* x) {
 725   LIRItem left(x-&gt;x(), this);
 726   LIRItem right(x-&gt;y(), this);
 727   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 728   if (tag == longTag) {
 729     left.set_destroys_register();
 730   }
 731   left.load_item();
 732   right.load_item();
 733   LIR_Opr reg = rlock_result(x);
 734 
 735   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 736     Bytecodes::Code code = x-&gt;op();
 737     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 738   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 739     __ lcmp2int(left.result(), right.result(), reg);
 740   } else {
 741     Unimplemented();
 742   }
 743 }
 744 
 745 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 746   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 747   new_value.load_item();
 748   cmp_value.load_item();
 749   LIR_Opr result = new_register(T_INT);
 750   if (is_reference_type(type)) {
 751     __ cas_obj(addr, cmp_value.result(), new_value.result(), new_register(T_INT), new_register(T_INT), result);
 752   } else if (type == T_INT) {
 753     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 754   } else if (type == T_LONG) {
 755     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 756   } else {
 757     ShouldNotReachHere();
 758     Unimplemented();
 759   }
 760   __ logical_xor(FrameMap::r8_opr, LIR_OprFact::intConst(1), result);
 761   return result;
 762 }
 763 
 764 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 765   bool is_oop = is_reference_type(type);
 766   LIR_Opr result = new_register(type);
 767   value.load_item();
 768   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 769   LIR_Opr tmp = new_register(T_INT);
 770   __ xchg(addr, value.result(), result, tmp);
 771   return result;
 772 }
 773 
 774 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 775   LIR_Opr result = new_register(type);
 776   value.load_item();
 777   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 778   LIR_Opr tmp = new_register(T_INT);
 779   __ xadd(addr, value.result(), result, tmp);
 780   return result;
 781 }
 782 
 783 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 784   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 785   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
 786       x-&gt;id() == vmIntrinsics::_dpow || x-&gt;id() == vmIntrinsics::_dcos ||
 787       x-&gt;id() == vmIntrinsics::_dsin || x-&gt;id() == vmIntrinsics::_dtan ||
 788       x-&gt;id() == vmIntrinsics::_dlog10) {
 789     do_LibmIntrinsic(x);
 790     return;
 791   }
 792   switch (x-&gt;id()) {
 793     case vmIntrinsics::_dabs:
 794     case vmIntrinsics::_dsqrt: {
 795       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 796       LIRItem value(x-&gt;argument_at(0), this);
 797       value.load_item();
 798       LIR_Opr dst = rlock_result(x);
 799 
 800       switch (x-&gt;id()) {
 801         case vmIntrinsics::_dsqrt: {
 802           __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);
 803           break;
 804         }
 805         case vmIntrinsics::_dabs: {
 806           __ abs(value.result(), dst, LIR_OprFact::illegalOpr);
 807           break;
 808         }
 809         default:
 810           ShouldNotReachHere();
 811       }
 812       break;
 813     }
 814     default:
 815       ShouldNotReachHere();
 816   }
 817 }
 818 
 819 void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {
 820   LIRItem value(x-&gt;argument_at(0), this);
 821   value.set_destroys_register();
 822 
 823   LIR_Opr calc_result = rlock_result(x);
 824   LIR_Opr result_reg = result_register_for(x-&gt;type());
 825 
 826   CallingConvention* cc = NULL;
 827 
 828   if (x-&gt;id() == vmIntrinsics::_dpow) {
 829     LIRItem value1(x-&gt;argument_at(1), this);
 830 
 831     value1.set_destroys_register();
 832 
 833     BasicTypeList signature(2);
 834     signature.append(T_DOUBLE);
 835     signature.append(T_DOUBLE);
 836     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 837     value.load_item_force(cc-&gt;at(0));
 838     value1.load_item_force(cc-&gt;at(1));
 839   } else {
 840     BasicTypeList signature(1);
 841     signature.append(T_DOUBLE);
 842     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 843     value.load_item_force(cc-&gt;at(0));
 844   }
 845 
 846   switch (x-&gt;id()) {
 847     case vmIntrinsics::_dexp:
 848       if (StubRoutines::dexp() != NULL) {
 849         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 850       } else {
 851         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 852       }
 853       break;
 854     case vmIntrinsics::_dlog:
 855       if (StubRoutines::dlog() != NULL) {
 856         __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 857       } else {
 858         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 859       }
 860       break;
 861     case vmIntrinsics::_dlog10:
 862       if (StubRoutines::dlog10() != NULL) {
 863         __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 864       } else {
 865         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 866       }
 867       break;
 868     case vmIntrinsics::_dpow:
 869       if (StubRoutines::dpow() != NULL) {
 870         __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 871       } else {
 872         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 873       }
 874       break;
 875     case vmIntrinsics::_dsin:
 876       if (StubRoutines::dsin() != NULL) {
 877         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 878       } else {
 879         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 880       }
 881       break;
 882     case vmIntrinsics::_dcos:
 883       if (StubRoutines::dcos() != NULL) {
 884         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 885       } else {
 886         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 887       }
 888       break;
 889     case vmIntrinsics::_dtan:
 890       if (StubRoutines::dtan() != NULL) {
 891         __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 892       } else {
 893         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 894       }
 895       break;
 896     default:  ShouldNotReachHere();
 897   }
 898   __ move(result_reg, calc_result);
 899 }
 900 
 901 
 902 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 903   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 904 
 905   // Make all state_for calls early since they can emit code
 906   CodeEmitInfo* info = state_for(x, x-&gt;state());
 907 
 908   LIRItem src(x-&gt;argument_at(0), this);
 909   LIRItem src_pos(x-&gt;argument_at(1), this);
 910   LIRItem dst(x-&gt;argument_at(2), this);
 911   LIRItem dst_pos(x-&gt;argument_at(3), this);
 912   LIRItem length(x-&gt;argument_at(4), this);
 913 
 914   // operands for arraycopy must use fixed registers, otherwise
 915   // LinearScan will fail allocation (because arraycopy always needs a
 916   // call)
 917 
 918   // The java calling convention will give us enough registers
 919   // so that on the stub side the args will be perfect already.
 920   // On the other slow/special case side we call C and the arg
 921   // positions are not similar enough to pick one as the best.
 922   // Also because the java calling convention is a &quot;shifted&quot; version
 923   // of the C convention we can process the java args trivially into C
 924   // args without worry of overwriting during the xfer
 925 
 926   src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));
 927   src_pos.load_item_force (FrameMap::as_opr(j_rarg1));
 928   dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));
 929   dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));
 930   length.load_item_force  (FrameMap::as_opr(j_rarg4));
 931 
 932   LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);
 933 
 934   set_no_result(x);
 935 
 936   int flags;
 937   ciArrayKlass* expected_type;
 938   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 939 
 940   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); // does add_safepoint
 941 }
 942 
 943 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
 944   assert(UseCRC32Intrinsics, &quot;why are we here?&quot;);
 945   // Make all state_for calls early since they can emit code
 946   LIR_Opr result = rlock_result(x);
 947   int flags = 0;
 948   switch (x-&gt;id()) {
 949     case vmIntrinsics::_updateCRC32: {
 950       LIRItem crc(x-&gt;argument_at(0), this);
 951       LIRItem val(x-&gt;argument_at(1), this);
 952       // val is destroyed by update_crc32
 953       val.set_destroys_register();
 954       crc.load_item();
 955       val.load_item();
 956       __ update_crc32(crc.result(), val.result(), result);
 957       break;
 958     }
 959     case vmIntrinsics::_updateBytesCRC32:
 960     case vmIntrinsics::_updateByteBufferCRC32: {
 961       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
 962 
 963       LIRItem crc(x-&gt;argument_at(0), this);
 964       LIRItem buf(x-&gt;argument_at(1), this);
 965       LIRItem off(x-&gt;argument_at(2), this);
 966       LIRItem len(x-&gt;argument_at(3), this);
 967       buf.load_item();
 968       off.load_nonconstant();
 969 
 970       LIR_Opr index = off.result();
 971       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
 972       if(off.result()-&gt;is_constant()) {
 973         index = LIR_OprFact::illegalOpr;
 974        offset += off.result()-&gt;as_jint();
 975       }
 976       LIR_Opr base_op = buf.result();
 977 
 978       if (index-&gt;is_valid()) {
 979         LIR_Opr tmp = new_register(T_LONG);
 980         __ convert(Bytecodes::_i2l, index, tmp);
 981         index = tmp;
 982       }
 983 
 984       if (is_updateBytes) {
 985         base_op = access_resolve(ACCESS_READ, base_op);
 986       }
 987 
 988       if (offset) {
 989         LIR_Opr tmp = new_pointer_register();
 990         __ add(base_op, LIR_OprFact::intConst(offset), tmp);
 991         base_op = tmp;
 992         offset = 0;
 993       }
 994 
 995       LIR_Address* a = new LIR_Address(base_op,
 996                                        index,
 997                                        offset,
 998                                        T_BYTE);
 999       BasicTypeList signature(3);
1000       signature.append(T_INT);
1001       signature.append(T_ADDRESS);
1002       signature.append(T_INT);
1003       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1004       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1005 
1006       LIR_Opr addr = new_pointer_register();
1007       __ leal(LIR_OprFact::address(a), addr);
1008 
1009       crc.load_item_force(cc-&gt;at(0));
1010       __ move(addr, cc-&gt;at(1));
1011       len.load_item_force(cc-&gt;at(2));
1012 
1013       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
1014       __ move(result_reg, result);
1015 
1016       break;
1017     }
1018     default: {
1019       ShouldNotReachHere();
1020     }
1021   }
1022 }
1023 
1024 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1025   assert(UseCRC32CIntrinsics, &quot;why are we here?&quot;);
1026   // Make all state_for calls early since they can emit code
1027   LIR_Opr result = rlock_result(x);
1028   int flags = 0;
1029   switch (x-&gt;id()) {
1030     case vmIntrinsics::_updateBytesCRC32C:
1031     case vmIntrinsics::_updateDirectByteBufferCRC32C: {
1032       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32C);
1033       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1034 
1035       LIRItem crc(x-&gt;argument_at(0), this);
1036       LIRItem buf(x-&gt;argument_at(1), this);
1037       LIRItem off(x-&gt;argument_at(2), this);
1038       LIRItem end(x-&gt;argument_at(3), this);
1039 
1040       buf.load_item();
1041       off.load_nonconstant();
1042       end.load_nonconstant();
1043 
1044       // len = end - off
1045       LIR_Opr len  = end.result();
1046       LIR_Opr tmpA = new_register(T_INT);
1047       LIR_Opr tmpB = new_register(T_INT);
1048       __ move(end.result(), tmpA);
1049       __ move(off.result(), tmpB);
1050       __ sub(tmpA, tmpB, tmpA);
1051       len = tmpA;
1052 
1053       LIR_Opr index = off.result();
1054       if(off.result()-&gt;is_constant()) {
1055         index = LIR_OprFact::illegalOpr;
1056         offset += off.result()-&gt;as_jint();
1057       }
1058       LIR_Opr base_op = buf.result();
1059 
1060       if (index-&gt;is_valid()) {
1061         LIR_Opr tmp = new_register(T_LONG);
1062         __ convert(Bytecodes::_i2l, index, tmp);
1063         index = tmp;
1064       }
1065 
1066       if (is_updateBytes) {
1067         base_op = access_resolve(ACCESS_READ, base_op);
1068       }
1069 
1070       if (offset) {
1071         LIR_Opr tmp = new_pointer_register();
1072         __ add(base_op, LIR_OprFact::intConst(offset), tmp);
1073         base_op = tmp;
1074         offset = 0;
1075       }
1076 
1077       LIR_Address* a = new LIR_Address(base_op,
1078                                        index,
1079                                        offset,
1080                                        T_BYTE);
1081       BasicTypeList signature(3);
1082       signature.append(T_INT);
1083       signature.append(T_ADDRESS);
1084       signature.append(T_INT);
1085       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1086       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1087 
1088       LIR_Opr addr = new_pointer_register();
1089       __ leal(LIR_OprFact::address(a), addr);
1090 
1091       crc.load_item_force(cc-&gt;at(0));
1092       __ move(addr, cc-&gt;at(1));
1093       __ move(len, cc-&gt;at(2));
1094 
1095       __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), getThreadTemp(), result_reg, cc-&gt;args());
1096       __ move(result_reg, result);
1097 
1098       break;
1099     }
1100     default: {
1101       ShouldNotReachHere();
1102     }
1103   }
1104 }
1105 
1106 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
1107   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
1108   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
1109   LIRItem value(x-&gt;argument_at(0), this);
1110   LIRItem value1(x-&gt;argument_at(1), this);
1111   LIRItem value2(x-&gt;argument_at(2), this);
1112 
1113   value.load_item();
1114   value1.load_item();
1115   value2.load_item();
1116 
1117   LIR_Opr calc_input = value.result();
1118   LIR_Opr calc_input1 = value1.result();
1119   LIR_Opr calc_input2 = value2.result();
1120   LIR_Opr calc_result = rlock_result(x);
1121 
1122   switch (x-&gt;id()) {
1123   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
1124   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
1125   default:                    ShouldNotReachHere();
1126   }
1127 }
1128 
1129 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1130   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
1131 }
1132 
1133 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1134 // _i2b, _i2c, _i2s
1135 void LIRGenerator::do_Convert(Convert* x) {
1136   LIRItem value(x-&gt;value(), this);
1137   value.load_item();
1138   LIR_Opr input = value.result();
1139   LIR_Opr result = rlock(x);
1140 
1141   // arguments of lir_convert
1142   LIR_Opr conv_input = input;
1143   LIR_Opr conv_result = result;
1144 
1145   __ convert(x-&gt;op(), conv_input, conv_result);
1146 
1147   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1148   set_result(x, result);
1149 }
1150 
1151 void LIRGenerator::do_NewInstance(NewInstance* x) {
1152 #ifndef PRODUCT
1153   if (PrintNotLoaded &amp;&amp; !x-&gt;klass()-&gt;is_loaded()) {
1154     tty-&gt;print_cr(&quot;   ###class not loaded at new bci %d&quot;, x-&gt;printable_bci());
1155   }
1156 #endif
1157   CodeEmitInfo* info = state_for(x, x-&gt;state());
1158   LIR_Opr reg = result_register_for(x-&gt;type());
1159   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1160                        FrameMap::r2_oop_opr,
1161                        FrameMap::r5_oop_opr,
1162                        FrameMap::r4_oop_opr,
1163                        LIR_OprFact::illegalOpr,
1164                        FrameMap::r3_metadata_opr, info);
1165   LIR_Opr result = rlock_result(x);
1166   __ move(reg, result);
1167 }
1168 
<a name="6" id="anc6"></a><span class="line-added">1169 void LIRGenerator::do_NewValueTypeInstance  (NewValueTypeInstance* x) {</span>
<span class="line-added">1170   // Mapping to do_NewInstance (same code)</span>
<span class="line-added">1171   CodeEmitInfo* info = state_for(x, x-&gt;state());</span>
<span class="line-added">1172   x-&gt;set_to_object_type();</span>
<span class="line-added">1173   LIR_Opr reg = result_register_for(x-&gt;type());</span>
<span class="line-added">1174   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),</span>
<span class="line-added">1175              FrameMap::r2_oop_opr,</span>
<span class="line-added">1176              FrameMap::r5_oop_opr,</span>
<span class="line-added">1177              FrameMap::r4_oop_opr,</span>
<span class="line-added">1178              LIR_OprFact::illegalOpr,</span>
<span class="line-added">1179              FrameMap::r3_metadata_opr, info);</span>
<span class="line-added">1180   LIR_Opr result = rlock_result(x);</span>
<span class="line-added">1181   __ move(reg, result);</span>
<span class="line-added">1182 </span>
<span class="line-added">1183 }</span>
<span class="line-added">1184 </span>
1185 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1186   CodeEmitInfo* info = state_for(x, x-&gt;state());
1187 
1188   LIRItem length(x-&gt;length(), this);
1189   length.load_item_force(FrameMap::r19_opr);
1190 
1191   LIR_Opr reg = result_register_for(x-&gt;type());
1192   LIR_Opr tmp1 = FrameMap::r2_oop_opr;
1193   LIR_Opr tmp2 = FrameMap::r4_oop_opr;
1194   LIR_Opr tmp3 = FrameMap::r5_oop_opr;
1195   LIR_Opr tmp4 = reg;
1196   LIR_Opr klass_reg = FrameMap::r3_metadata_opr;
1197   LIR_Opr len = length.result();
1198   BasicType elem_type = x-&gt;elt_type();
1199 
1200   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1201 
1202   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1203   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1204 
1205   LIR_Opr result = rlock_result(x);
1206   __ move(reg, result);
1207 }
1208 
1209 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1210   LIRItem length(x-&gt;length(), this);
1211   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1212   // and therefore provide the state before the parameters have been consumed
1213   CodeEmitInfo* patching_info = NULL;
1214   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1215     patching_info =  state_for(x, x-&gt;state_before());
1216   }
1217 
1218   CodeEmitInfo* info = state_for(x, x-&gt;state());
1219 
1220   LIR_Opr reg = result_register_for(x-&gt;type());
1221   LIR_Opr tmp1 = FrameMap::r2_oop_opr;
1222   LIR_Opr tmp2 = FrameMap::r4_oop_opr;
1223   LIR_Opr tmp3 = FrameMap::r5_oop_opr;
1224   LIR_Opr tmp4 = reg;
1225   LIR_Opr klass_reg = FrameMap::r3_metadata_opr;
1226 
1227   length.load_item_force(FrameMap::r19_opr);
1228   LIR_Opr len = length.result();
1229 
<a name="7" id="anc7"></a><span class="line-modified">1230   ciKlass* obj = (ciKlass*) x-&gt;exact_type();</span>
<span class="line-modified">1231   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_never_null());</span>
1232   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1233     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1234   }
<a name="8" id="anc8"></a><span class="line-added">1235 </span>
1236   klass2reg_with_patching(klass_reg, obj, patching_info);
<a name="9" id="anc9"></a><span class="line-modified">1237   if (x-&gt;is_never_null()) {</span>
<span class="line-added">1238     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_VALUETYPE, klass_reg, slow_path);</span>
<span class="line-added">1239   } else {</span>
<span class="line-added">1240     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);</span>
<span class="line-added">1241   }</span>
1242 
1243   LIR_Opr result = rlock_result(x);
1244   __ move(reg, result);
1245 }
1246 
1247 
1248 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1249   Values* dims = x-&gt;dims();
1250   int i = dims-&gt;length();
1251   LIRItemList* items = new LIRItemList(i, i, NULL);
1252   while (i-- &gt; 0) {
1253     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1254     items-&gt;at_put(i, size);
1255   }
1256 
1257   // Evaluate state_for early since it may emit code.
1258   CodeEmitInfo* patching_info = NULL;
1259   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1260     patching_info = state_for(x, x-&gt;state_before());
1261 
1262     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1263     // clone all handlers (NOTE: Usually this is handled transparently
1264     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1265     // is done explicitly here because a stub isn&#39;t being used).
1266     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1267   }
1268   CodeEmitInfo* info = state_for(x, x-&gt;state());
1269 
1270   i = dims-&gt;length();
1271   while (i-- &gt; 0) {
1272     LIRItem* size = items-&gt;at(i);
1273     size-&gt;load_item();
1274 
1275     store_stack_parameter(size-&gt;result(), in_ByteSize(i*4));
1276   }
1277 
1278   LIR_Opr klass_reg = FrameMap::r0_metadata_opr;
1279   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1280 
1281   LIR_Opr rank = FrameMap::r19_opr;
1282   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1283   LIR_Opr varargs = FrameMap::r2_opr;
1284   __ move(FrameMap::sp_opr, varargs);
1285   LIR_OprList* args = new LIR_OprList(3);
1286   args-&gt;append(klass_reg);
1287   args-&gt;append(rank);
1288   args-&gt;append(varargs);
1289   LIR_Opr reg = result_register_for(x-&gt;type());
1290   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1291                   LIR_OprFact::illegalOpr,
1292                   reg, args, info);
1293 
1294   LIR_Opr result = rlock_result(x);
1295   __ move(reg, result);
1296 }
1297 
1298 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1299   // nothing to do for now
1300 }
1301 
1302 void LIRGenerator::do_CheckCast(CheckCast* x) {
1303   LIRItem obj(x-&gt;obj(), this);
1304 
1305   CodeEmitInfo* patching_info = NULL;
1306   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1307     // must do this before locking the destination register as an oop register,
1308     // and before the obj is loaded (the latter is for deoptimization)
1309     patching_info = state_for(x, x-&gt;state_before());
1310   }
1311   obj.load_item();
1312 
1313   // info for exceptions
1314   CodeEmitInfo* info_for_exception =
1315       (x-&gt;needs_exception_state() ? state_for(x) :
1316                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
<a name="10" id="anc10"></a><span class="line-added">1317   if (x-&gt;is_never_null()) {</span>
<span class="line-added">1318     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));</span>
<span class="line-added">1319   }</span>
1320 
1321   CodeStub* stub;
1322   if (x-&gt;is_incompatible_class_change_check()) {
1323     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1324     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1325   } else if (x-&gt;is_invokespecial_receiver_check()) {
1326     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1327     stub = new DeoptimizeStub(info_for_exception,
1328                               Deoptimization::Reason_class_check,
1329                               Deoptimization::Action_none);
1330   } else {
1331     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1332   }
1333   LIR_Opr reg = rlock_result(x);
1334   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1335   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1336     tmp3 = new_register(objectType);
1337   }
<a name="11" id="anc11"></a><span class="line-added">1338 </span>
<span class="line-added">1339 </span>
1340   __ checkcast(reg, obj.result(), x-&gt;klass(),
1341                new_register(objectType), new_register(objectType), tmp3,
1342                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
<a name="12" id="anc12"></a><span class="line-modified">1343                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_never_null());</span>
<span class="line-added">1344 </span>
1345 }
1346 
1347 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1348   LIRItem obj(x-&gt;obj(), this);
1349 
1350   // result and test object may not be in same register
1351   LIR_Opr reg = rlock_result(x);
1352   CodeEmitInfo* patching_info = NULL;
1353   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1354     // must do this before locking the destination register as an oop register
1355     patching_info = state_for(x, x-&gt;state_before());
1356   }
1357   obj.load_item();
1358   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1359   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1360     tmp3 = new_register(objectType);
1361   }
1362   __ instanceof(reg, obj.result(), x-&gt;klass(),
1363                 new_register(objectType), new_register(objectType), tmp3,
1364                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1365 }
1366 
1367 void LIRGenerator::do_If(If* x) {
1368   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1369   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1370   bool is_safepoint = x-&gt;is_safepoint();
1371 
1372   If::Condition cond = x-&gt;cond();
1373 
1374   LIRItem xitem(x-&gt;x(), this);
1375   LIRItem yitem(x-&gt;y(), this);
1376   LIRItem* xin = &amp;xitem;
1377   LIRItem* yin = &amp;yitem;
1378 
1379   if (tag == longTag) {
1380     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1381     // mirror for other conditions
1382     if (cond == If::gtr || cond == If::leq) {
1383       cond = Instruction::mirror(cond);
1384       xin = &amp;yitem;
1385       yin = &amp;xitem;
1386     }
1387     xin-&gt;set_destroys_register();
1388   }
1389   xin-&gt;load_item();
1390 
1391   if (tag == longTag) {
1392     if (yin-&gt;is_constant()
1393         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(yin-&gt;get_jlong_constant())) {
1394       yin-&gt;dont_load_item();
1395     } else {
1396       yin-&gt;load_item();
1397     }
1398   } else if (tag == intTag) {
1399     if (yin-&gt;is_constant()
1400         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(yin-&gt;get_jint_constant()))  {
1401       yin-&gt;dont_load_item();
1402     } else {
1403       yin-&gt;load_item();
1404     }
1405   } else {
1406     yin-&gt;load_item();
1407   }
1408 
1409   set_no_result(x);
1410 
1411   LIR_Opr left = xin-&gt;result();
1412   LIR_Opr right = yin-&gt;result();
1413 
1414   // add safepoint before generating condition code so it can be recomputed
1415   if (x-&gt;is_safepoint()) {
1416     // increment backedge counter if needed
1417     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1418         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1419     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1420   }
1421 
1422   __ cmp(lir_cond(cond), left, right);
1423   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1424   profile_branch(x, cond);
1425   move_to_phi(x-&gt;state());
1426   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1427     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1428   } else {
1429     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1430   }
1431   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1432   __ jump(x-&gt;default_sux());
1433 }
1434 
1435 LIR_Opr LIRGenerator::getThreadPointer() {
1436    return FrameMap::as_pointer_opr(rthread);
1437 }
1438 
1439 void LIRGenerator::trace_block_entry(BlockBegin* block) { Unimplemented(); }
1440 
1441 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1442                                         CodeEmitInfo* info) {
1443   __ volatile_store_mem_reg(value, address, info);
1444 }
1445 
1446 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1447                                        CodeEmitInfo* info) {
1448   // 8179954: We need to make sure that the code generated for
1449   // volatile accesses forms a sequentially-consistent set of
1450   // operations when combined with STLR and LDAR.  Without a leading
1451   // membar it&#39;s possible for a simple Dekker test to fail if loads
1452   // use LD;DMB but stores use STLR.  This can happen if C2 compiles
1453   // the stores in one method and C1 compiles the loads in another.
1454   if (!is_c1_or_interpreter_only()) {
1455     __ membar();
1456   }
1457   __ volatile_load_mem_reg(address, result, info);
1458 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
  38 #include &quot;opto/block.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/locknode.hpp&quot;
  43 #include &quot;opto/machnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/optoreg.hpp&quot;
  46 #include &quot;opto/output.hpp&quot;
  47 #include &quot;opto/regalloc.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/type.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 #include &quot;utilities/powerOfTwo.hpp&quot;
  55 #include &quot;utilities/xmlstream.hpp&quot;
  56 
  57 #ifndef PRODUCT
  58 #define DEBUG_ARG(x) , x
  59 #else
  60 #define DEBUG_ARG(x)
  61 #endif
  62 
  63 //------------------------------Scheduling----------------------------------
  64 // This class contains all the information necessary to implement instruction
  65 // scheduling and bundling.
  66 class Scheduling {
  67 
  68 private:
  69   // Arena to use
  70   Arena *_arena;
  71 
  72   // Control-Flow Graph info
  73   PhaseCFG *_cfg;
  74 
  75   // Register Allocation info
  76   PhaseRegAlloc *_regalloc;
  77 
  78   // Number of nodes in the method
  79   uint _node_bundling_limit;
  80 
  81   // List of scheduled nodes. Generated in reverse order
  82   Node_List _scheduled;
  83 
  84   // List of nodes currently available for choosing for scheduling
  85   Node_List _available;
  86 
  87   // For each instruction beginning a bundle, the number of following
  88   // nodes to be bundled with it.
  89   Bundle *_node_bundling_base;
  90 
  91   // Mapping from register to Node
  92   Node_List _reg_node;
  93 
  94   // Free list for pinch nodes.
  95   Node_List _pinch_free_list;
  96 
  97   // Latency from the beginning of the containing basic block (base 1)
  98   // for each node.
  99   unsigned short *_node_latency;
 100 
 101   // Number of uses of this node within the containing basic block.
 102   short *_uses;
 103 
 104   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up
 105   // front, branch+proj at end.  Also skips Catch/CProj (same as
 106   // branch-at-end), plus just-prior exception-throwing call.
 107   uint _bb_start, _bb_end;
 108 
 109   // Latency from the end of the basic block as scheduled
 110   unsigned short *_current_latency;
 111 
 112   // Remember the next node
 113   Node *_next_node;
 114 
 115   // Use this for an unconditional branch delay slot
 116   Node *_unconditional_delay_slot;
 117 
 118   // Pointer to a Nop
 119   MachNopNode *_nop;
 120 
 121   // Length of the current bundle, in instructions
 122   uint _bundle_instr_count;
 123 
 124   // Current Cycle number, for computing latencies and bundling
 125   uint _bundle_cycle_number;
 126 
 127   // Bundle information
 128   Pipeline_Use_Element _bundle_use_elements[resource_count];
 129   Pipeline_Use         _bundle_use;
 130 
 131   // Dump the available list
 132   void dump_available() const;
 133 
 134 public:
 135   Scheduling(Arena *arena, Compile &amp;compile);
 136 
 137   // Destructor
 138   NOT_PRODUCT( ~Scheduling(); )
 139 
 140   // Step ahead &quot;i&quot; cycles
 141   void step(uint i);
 142 
 143   // Step ahead 1 cycle, and clear the bundle state (for example,
 144   // at a branch target)
 145   void step_and_clear();
 146 
 147   Bundle* node_bundling(const Node *n) {
 148     assert(valid_bundle_info(n), &quot;oob&quot;);
 149     return (&amp;_node_bundling_base[n-&gt;_idx]);
 150   }
 151 
 152   bool valid_bundle_info(const Node *n) const {
 153     return (_node_bundling_limit &gt; n-&gt;_idx);
 154   }
 155 
 156   bool starts_bundle(const Node *n) const {
 157     return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp; _node_bundling_base[n-&gt;_idx].starts_bundle());
 158   }
 159 
 160   // Do the scheduling
 161   void DoScheduling();
 162 
 163   // Compute the local latencies walking forward over the list of
 164   // nodes for a basic block
 165   void ComputeLocalLatenciesForward(const Block *bb);
 166 
 167   // Compute the register antidependencies within a basic block
 168   void ComputeRegisterAntidependencies(Block *bb);
 169   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );
 170   void verify_good_schedule( Block *b, const char *msg );
 171   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );
 172   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );
 173 
 174   // Add a node to the current bundle
 175   void AddNodeToBundle(Node *n, const Block *bb);
 176 
 177   // Add a node to the list of available nodes
 178   void AddNodeToAvailableList(Node *n);
 179 
 180   // Compute the local use count for the nodes in a block, and compute
 181   // the list of instructions with no uses in the block as available
 182   void ComputeUseCount(const Block *bb);
 183 
 184   // Choose an instruction from the available list to add to the bundle
 185   Node * ChooseNodeToBundle();
 186 
 187   // See if this Node fits into the currently accumulating bundle
 188   bool NodeFitsInBundle(Node *n);
 189 
 190   // Decrement the use count for a node
 191  void DecrementUseCounts(Node *n, const Block *bb);
 192 
 193   // Garbage collect pinch nodes for reuse by other blocks.
 194   void garbage_collect_pinch_nodes();
 195   // Clean up a pinch node for reuse (helper for above).
 196   void cleanup_pinch( Node *pinch );
 197 
 198   // Information for statistics gathering
 199 #ifndef PRODUCT
 200 private:
 201   // Gather information on size of nops relative to total
 202   uint _branches, _unconditional_delays;
 203 
 204   static uint _total_nop_size, _total_method_size;
 205   static uint _total_branches, _total_unconditional_delays;
 206   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
 207 
 208 public:
 209   static void print_statistics();
 210 
 211   static void increment_instructions_per_bundle(uint i) {
 212     _total_instructions_per_bundle[i]++;
 213   }
 214 
 215   static void increment_nop_size(uint s) {
 216     _total_nop_size += s;
 217   }
 218 
 219   static void increment_method_size(uint s) {
 220     _total_method_size += s;
 221   }
 222 #endif
 223 
 224 };
 225 
 226 
 227 PhaseOutput::PhaseOutput()
 228   : Phase(Phase::Output),
 229     _code_buffer(&quot;Compile::Fill_buffer&quot;),
 230     _first_block_size(0),
 231     _handler_table(),
 232     _inc_table(),
 233     _oop_map_set(NULL),
 234     _scratch_buffer_blob(NULL),
 235     _scratch_locs_memory(NULL),
 236     _scratch_const_size(-1),
 237     _in_scratch_emit_size(false),
 238     _frame_slots(0),
 239     _code_offsets(),
 240     _node_bundling_limit(0),
 241     _node_bundling_base(NULL),
 242     _orig_pc_slot(0),
 243     _orig_pc_slot_offset_in_bytes(0),
<a name="1" id="anc1"></a><span class="line-added"> 244     _sp_inc_slot(0),</span>
<span class="line-added"> 245     _sp_inc_slot_offset_in_bytes(0),</span>
 246     _buf_sizes(),
 247     _block(NULL),
 248     _index(0) {
 249   C-&gt;set_output(this);
 250   if (C-&gt;stub_name() == NULL) {
<a name="2" id="anc2"></a><span class="line-modified"> 251     int fixed_slots = C-&gt;fixed_slots();</span>
<span class="line-added"> 252     if (C-&gt;needs_stack_repair()) {</span>
<span class="line-added"> 253       fixed_slots -= 2;</span>
<span class="line-added"> 254       _sp_inc_slot = fixed_slots;</span>
<span class="line-added"> 255     }</span>
<span class="line-added"> 256     _orig_pc_slot = fixed_slots - (sizeof(address) / VMRegImpl::stack_slot_size);</span>
 257   }
 258 }
 259 
 260 PhaseOutput::~PhaseOutput() {
 261   C-&gt;set_output(NULL);
 262   if (_scratch_buffer_blob != NULL) {
 263     BufferBlob::free(_scratch_buffer_blob);
 264   }
 265 }
 266 
 267 void PhaseOutput::perform_mach_node_analysis() {
 268   // Late barrier analysis must be done after schedule and bundle
 269   // Otherwise liveness based spilling will fail
 270   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 271   bs-&gt;late_barrier_analysis();
 272 
 273   pd_perform_mach_node_analysis();
 274 }
 275 
 276 // Convert Nodes to instruction bits and pass off to the VM
 277 void PhaseOutput::Output() {
 278   // RootNode goes
 279   assert( C-&gt;cfg()-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );
 280 
 281   // The number of new nodes (mostly MachNop) is proportional to
 282   // the number of java calls and inner loops which are aligned.
 283   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
 284                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
 285                            &quot;out of nodes before code generation&quot; ) ) {
 286     return;
 287   }
 288   // Make sure I can find the Start Node
 289   Block *entry = C-&gt;cfg()-&gt;get_block(1);
 290   Block *broot = C-&gt;cfg()-&gt;get_root_block();
 291 
 292   const StartNode *start = entry-&gt;head()-&gt;as_Start();
 293 
 294   // Replace StartNode with prolog
<a name="3" id="anc3"></a><span class="line-modified"> 295   Label verified_entry;</span>
<span class="line-added"> 296   MachPrologNode* prolog = new MachPrologNode(&amp;verified_entry);</span>
 297   entry-&gt;map_node(prolog, 0);
 298   C-&gt;cfg()-&gt;map_node_to_block(prolog, entry);
 299   C-&gt;cfg()-&gt;unmap_node_from_block(start); // start is no longer in any block
 300 
 301   // Virtual methods need an unverified entry point
<a name="4" id="anc4"></a><span class="line-modified"> 302   if (C-&gt;is_osr_compilation()) {</span>
<span class="line-modified"> 303     if (PoisonOSREntry) {</span>

 304       // TODO: Should use a ShouldNotReachHereNode...
 305       C-&gt;cfg()-&gt;insert( broot, 0, new MachBreakpointNode() );
 306     }
 307   } else {
<a name="5" id="anc5"></a><span class="line-modified"> 308     if (C-&gt;method()) {</span>
<span class="line-modified"> 309       if (C-&gt;method()-&gt;has_scalarized_args()) {</span>
<span class="line-modified"> 310         // Add entry point to unpack all value type arguments</span>
<span class="line-added"> 311         C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true, /* receiver_only */ false));</span>
<span class="line-added"> 312         if (!C-&gt;method()-&gt;is_static()) {</span>
<span class="line-added"> 313           // Add verified/unverified entry points to only unpack value type receiver at interface calls</span>
<span class="line-added"> 314           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ false));</span>
<span class="line-added"> 315           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true,  /* receiver_only */ true));</span>
<span class="line-added"> 316           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ true));</span>
<span class="line-added"> 317         }</span>
<span class="line-added"> 318       } else if (!C-&gt;method()-&gt;is_static()) {</span>
<span class="line-added"> 319         // Insert unvalidated entry point</span>
<span class="line-added"> 320         C-&gt;cfg()-&gt;insert(broot, 0, new MachUEPNode());</span>
<span class="line-added"> 321       }</span>
 322     }
<a name="6" id="anc6"></a>
 323   }
 324 
 325   // Break before main entry point
 326   if ((C-&gt;method() &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||
 327       (OptoBreakpoint &amp;&amp; C-&gt;is_method_compilation())       ||
 328       (OptoBreakpointOSR &amp;&amp; C-&gt;is_osr_compilation())       ||
 329       (OptoBreakpointC2R &amp;&amp; !C-&gt;method())                   ) {
 330     // checking for C-&gt;method() means that OptoBreakpoint does not apply to
 331     // runtime stubs or frame converters
 332     C-&gt;cfg()-&gt;insert( entry, 1, new MachBreakpointNode() );
 333   }
 334 
 335   // Insert epilogs before every return
 336   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
 337     Block* block = C-&gt;cfg()-&gt;get_block(i);
 338     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == C-&gt;cfg()-&gt;get_root_block()) { // Found a program exit point?
 339       Node* m = block-&gt;end();
 340       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 341         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 342         block-&gt;add_inst(epilog);
 343         C-&gt;cfg()-&gt;map_node_to_block(epilog, block);
 344       }
 345     }
 346   }
 347 
 348   // Keeper of sizing aspects
 349   _buf_sizes = BufferSizingData();
 350 
 351   // Initialize code buffer
 352   estimate_buffer_size(_buf_sizes._const);
 353   if (C-&gt;failing()) return;
 354 
 355   // Pre-compute the length of blocks and replace
 356   // long branches with short if machine supports it.
 357   // Must be done before ScheduleAndBundle due to SPARC delay slots
 358   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C-&gt;cfg()-&gt;number_of_blocks() + 1);
 359   blk_starts[0] = 0;
 360   shorten_branches(blk_starts);
 361 
<a name="7" id="anc7"></a><span class="line-added"> 362   if (!C-&gt;is_osr_compilation() &amp;&amp; C-&gt;has_scalarized_args()) {</span>
<span class="line-added"> 363     // Compute the offsets of the entry points required by the value type calling convention</span>
<span class="line-added"> 364     if (!C-&gt;method()-&gt;is_static()) {</span>
<span class="line-added"> 365       // We have entries at the beginning of the method, implemented by the first 4 nodes.</span>
<span class="line-added"> 366       // Entry                     (unverified) @ offset 0</span>
<span class="line-added"> 367       // Verified_Value_Entry_RO</span>
<span class="line-added"> 368       // Value_Entry               (unverified)</span>
<span class="line-added"> 369       // Verified_Value_Entry</span>
<span class="line-added"> 370       uint offset = 0;</span>
<span class="line-added"> 371       _code_offsets.set_value(CodeOffsets::Entry, offset);</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373       offset += ((MachVEPNode*)broot-&gt;get_node(0))-&gt;size(C-&gt;regalloc());</span>
<span class="line-added"> 374       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, offset);</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376       offset += ((MachVEPNode*)broot-&gt;get_node(1))-&gt;size(C-&gt;regalloc());</span>
<span class="line-added"> 377       _code_offsets.set_value(CodeOffsets::Value_Entry, offset);</span>
<span class="line-added"> 378 </span>
<span class="line-added"> 379       offset += ((MachVEPNode*)broot-&gt;get_node(2))-&gt;size(C-&gt;regalloc());</span>
<span class="line-added"> 380       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, offset);</span>
<span class="line-added"> 381     } else {</span>
<span class="line-added"> 382       _code_offsets.set_value(CodeOffsets::Entry, -1); // will be patched later</span>
<span class="line-added"> 383       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, 0);</span>
<span class="line-added"> 384     }</span>
<span class="line-added"> 385   }</span>
<span class="line-added"> 386 </span>
 387   ScheduleAndBundle();
 388   if (C-&gt;failing()) {
 389     return;
 390   }
 391 
 392   perform_mach_node_analysis();
 393 
 394   // Complete sizing of codebuffer
 395   CodeBuffer* cb = init_buffer();
 396   if (cb == NULL || C-&gt;failing()) {
 397     return;
 398   }
 399 
 400   BuildOopMaps();
 401 
 402   if (C-&gt;failing())  {
 403     return;
 404   }
 405 
 406   fill_buffer(cb, blk_starts);
 407 }
 408 
 409 bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {
 410   // Determine if we need to generate a stack overflow check.
 411   // Do it if the method is not a stub function and
 412   // has java calls or has frame size &gt; vm_page_size/8.
 413   // The debug VM checks that deoptimization doesn&#39;t trigger an
 414   // unexpected stack overflow (compiled method stack banging should
 415   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 416   // a debug VM.
 417   return (UseStackBanging &amp;&amp; C-&gt;stub_function() == NULL &amp;&amp;
 418           (C-&gt;has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3
 419            DEBUG_ONLY(|| true)));
 420 }
 421 
 422 bool PhaseOutput::need_register_stack_bang() const {
 423   // Determine if we need to generate a register stack overflow check.
 424   // This is only used on architectures which have split register
 425   // and memory stacks (ie. IA64).
 426   // Bang if the method is not a stub function and has java calls
 427   return (C-&gt;stub_function() == NULL &amp;&amp; C-&gt;has_java_calls());
 428 }
 429 
 430 
 431 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 432 // of a loop. When aligning a loop we need to provide enough instructions
 433 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 434 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 435 // By default, the size is set to 999999 by Block&#39;s constructor so that
 436 // a loop will be aligned if the size is not reset here.
 437 //
 438 // Note: Mach instructions could contain several HW instructions
 439 // so the size is estimated only.
 440 //
 441 void PhaseOutput::compute_loop_first_inst_sizes() {
 442   // The next condition is used to gate the loop alignment optimization.
 443   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 444   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 445   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 446   // equal to 11 bytes which is the largest address NOP instruction.
 447   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
 448     uint last_block = C-&gt;cfg()-&gt;number_of_blocks() - 1;
 449     for (uint i = 1; i &lt;= last_block; i++) {
 450       Block* block = C-&gt;cfg()-&gt;get_block(i);
 451       // Check the first loop&#39;s block which requires an alignment.
 452       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 453         uint sum_size = 0;
 454         uint inst_cnt = NumberOfLoopInstrToAlign;
 455         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());
 456 
 457         // Check subsequent fallthrough blocks if the loop&#39;s first
 458         // block(s) does not have enough instructions.
 459         Block *nb = block;
 460         while(inst_cnt &gt; 0 &amp;&amp;
 461               i &lt; last_block &amp;&amp;
 462               !C-&gt;cfg()-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;
 463               !nb-&gt;has_successor(block)) {
 464           i++;
 465           nb = C-&gt;cfg()-&gt;get_block(i);
 466           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());
 467         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 468 
 469         block-&gt;set_first_inst_size(sum_size);
 470       } // f( b-&gt;head()-&gt;is_Loop() )
 471     } // for( i &lt;= last_block )
 472   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 473 }
 474 
 475 // The architecture description provides short branch variants for some long
 476 // branch instructions. Replace eligible long branches with short branches.
 477 void PhaseOutput::shorten_branches(uint* blk_starts) {
 478   // Compute size of each block, method size, and relocation information size
 479   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();
 480 
 481   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 482   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 483   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 484 
 485   // Collect worst case block paddings
 486   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 487   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 488 
 489   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 490   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 491 
 492   bool has_short_branch_candidate = false;
 493 
 494   // Initialize the sizes to 0
 495   int code_size  = 0;          // Size in bytes of generated code
 496   int stub_size  = 0;          // Size in bytes of all stub entries
 497   // Size in bytes of all relocation entries, including those in local stubs.
 498   // Start with 2-bytes of reloc info for the unvalidated entry point
 499   int reloc_size = 1;          // Number of relocation entries
 500 
 501   // Make three passes.  The first computes pessimistic blk_starts,
 502   // relative jmp_offset and reloc_size information.  The second performs
 503   // short branch substitution using the pessimistic sizing.  The
 504   // third inserts nops where needed.
 505 
 506   // Step one, perform a pessimistic sizing pass.
 507   uint last_call_adr = max_juint;
 508   uint last_avoid_back_to_back_adr = max_juint;
 509   uint nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());
 510   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 511     Block* block = C-&gt;cfg()-&gt;get_block(i);
 512     _block = block;
 513 
 514     // During short branch replacement, we store the relative (to blk_starts)
 515     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 516     // This is so that we do not need to recompute sizes of all nodes when
 517     // we compute correct blk_starts in our next sizing pass.
 518     jmp_offset[i] = 0;
 519     jmp_size[i]   = 0;
 520     jmp_nidx[i]   = -1;
 521     DEBUG_ONLY( jmp_target[i] = 0; )
 522     DEBUG_ONLY( jmp_rule[i]   = 0; )
 523 
 524     // Sum all instruction sizes to compute block size
 525     uint last_inst = block-&gt;number_of_nodes();
 526     uint blk_size = 0;
 527     for (uint j = 0; j &lt; last_inst; j++) {
 528       _index = j;
 529       Node* nj = block-&gt;get_node(_index);
 530       // Handle machine instruction nodes
 531       if (nj-&gt;is_Mach()) {
 532         MachNode* mach = nj-&gt;as_Mach();
 533         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
 534         reloc_size += mach-&gt;reloc();
 535         if (mach-&gt;is_MachCall()) {
 536           // add size information for trampoline stub
 537           // class CallStubImpl is platform-specific and defined in the *.ad files.
 538           stub_size  += CallStubImpl::size_call_trampoline();
 539           reloc_size += CallStubImpl::reloc_call_trampoline();
 540 
 541           MachCallNode *mcall = mach-&gt;as_MachCall();
 542           // This destination address is NOT PC-relative
 543 
<a name="8" id="anc8"></a><span class="line-modified"> 544           if (mcall-&gt;entry_point() != NULL) {</span>
<span class="line-added"> 545             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());</span>
<span class="line-added"> 546           }</span>
 547 
 548           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 549             stub_size  += CompiledStaticCall::to_interp_stub_size();
 550             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 551 #if INCLUDE_AOT
 552             stub_size  += CompiledStaticCall::to_aot_stub_size();
 553             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 554 #endif
 555           }
 556         } else if (mach-&gt;is_MachSafePoint()) {
 557           // If call/safepoint are adjacent, account for possible
 558           // nop to disambiguate the two safepoints.
 559           // ScheduleAndBundle() can rearrange nodes in a block,
 560           // check for all offsets inside this block.
 561           if (last_call_adr &gt;= blk_starts[i]) {
 562             blk_size += nop_size;
 563           }
 564         }
 565         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 566           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 567           // ScheduleAndBundle() can rearrange nodes in a block,
 568           // check for all offsets inside this block.
 569           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 570             blk_size += nop_size;
 571           }
 572         }
 573         if (mach-&gt;may_be_short_branch()) {
 574           if (!nj-&gt;is_MachBranch()) {
 575 #ifndef PRODUCT
 576             nj-&gt;dump(3);
 577 #endif
 578             Unimplemented();
 579           }
 580           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 581           jmp_offset[i] = blk_size;
 582           jmp_size[i]   = nj-&gt;size(C-&gt;regalloc());
 583           jmp_nidx[i]   = j;
 584           has_short_branch_candidate = true;
 585         }
 586       }
 587       blk_size += nj-&gt;size(C-&gt;regalloc());
 588       // Remember end of call offset
 589       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 590         last_call_adr = blk_starts[i]+blk_size;
 591       }
 592       // Remember end of avoid_back_to_back offset
 593       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 594         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 595       }
 596     }
 597 
 598     // When the next block starts a loop, we may insert pad NOP
 599     // instructions.  Since we cannot know our future alignment,
 600     // assume the worst.
 601     if (i &lt; nblocks - 1) {
 602       Block* nb = C-&gt;cfg()-&gt;get_block(i + 1);
 603       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 604       if (max_loop_pad &gt; 0) {
 605         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 606         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 607         // If either is the last instruction in this block, bump by
 608         // max_loop_pad in lock-step with blk_size, so sizing
 609         // calculations in subsequent blocks still can conservatively
 610         // detect that it may the last instruction in this block.
 611         if (last_call_adr == blk_starts[i]+blk_size) {
 612           last_call_adr += max_loop_pad;
 613         }
 614         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 615           last_avoid_back_to_back_adr += max_loop_pad;
 616         }
 617         blk_size += max_loop_pad;
 618         block_worst_case_pad[i + 1] = max_loop_pad;
 619       }
 620     }
 621 
 622     // Save block size; update total method size
 623     blk_starts[i+1] = blk_starts[i]+blk_size;
 624   }
 625 
 626   // Step two, replace eligible long jumps.
 627   bool progress = true;
 628   uint last_may_be_short_branch_adr = max_juint;
 629   while (has_short_branch_candidate &amp;&amp; progress) {
 630     progress = false;
 631     has_short_branch_candidate = false;
 632     int adjust_block_start = 0;
 633     for (uint i = 0; i &lt; nblocks; i++) {
 634       Block* block = C-&gt;cfg()-&gt;get_block(i);
 635       int idx = jmp_nidx[i];
 636       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 637       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 638 #ifdef ASSERT
 639         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 640         int j;
 641         // Find the branch; ignore trailing NOPs.
 642         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 643           Node* n = block-&gt;get_node(j);
 644           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 645             break;
 646         }
 647         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 648 #endif
 649         int br_size = jmp_size[i];
 650         int br_offs = blk_starts[i] + jmp_offset[i];
 651 
 652         // This requires the TRUE branch target be in succs[0]
 653         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 654         int offset = blk_starts[bnum] - br_offs;
 655         if (bnum &gt; i) { // adjust following block&#39;s offset
 656           offset -= adjust_block_start;
 657         }
 658 
 659         // This block can be a loop header, account for the padding
 660         // in the previous block.
 661         int block_padding = block_worst_case_pad[i];
 662         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 663         // In the following code a nop could be inserted before
 664         // the branch which will increase the backward distance.
 665         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 666         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 667 
 668         if (needs_padding &amp;&amp; offset &lt;= 0)
 669           offset -= nop_size;
 670 
 671         if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
 672           // We&#39;ve got a winner.  Replace this branch.
 673           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 674 
 675           // Update the jmp_size.
 676           int new_size = replacement-&gt;size(C-&gt;regalloc());
 677           int diff     = br_size - new_size;
 678           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 679           // Conservatively take into account padding between
 680           // avoid_back_to_back branches. Previous branch could be
 681           // converted into avoid_back_to_back branch during next
 682           // rounds.
 683           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 684             jmp_offset[i] += nop_size;
 685             diff -= nop_size;
 686           }
 687           adjust_block_start += diff;
 688           block-&gt;map_node(replacement, idx);
 689           mach-&gt;subsume_by(replacement, C);
 690           mach = replacement;
 691           progress = true;
 692 
 693           jmp_size[i] = new_size;
 694           DEBUG_ONLY( jmp_target[i] = bnum; );
 695           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 696         } else {
 697           // The jump distance is not short, try again during next iteration.
 698           has_short_branch_candidate = true;
 699         }
 700       } // (mach-&gt;may_be_short_branch())
 701       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 702                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 703         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 704       }
 705       blk_starts[i+1] -= adjust_block_start;
 706     }
 707   }
 708 
 709 #ifdef ASSERT
 710   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 711     if (jmp_target[i] != 0) {
 712       int br_size = jmp_size[i];
 713       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
 714       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
 715         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 716       }
 717       assert(C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);
 718     }
 719   }
 720 #endif
 721 
 722   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 723   // after ScheduleAndBundle().
 724 
 725   // ------------------
 726   // Compute size for code buffer
 727   code_size = blk_starts[nblocks];
 728 
 729   // Relocation records
 730   reloc_size += 1;              // Relo entry for exception handler
 731 
 732   // Adjust reloc_size to number of record of relocation info
 733   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 734   // a relocation index.
 735   // The CodeBuffer will expand the locs array if this estimate is too low.
 736   reloc_size *= 10 / sizeof(relocInfo);
 737 
 738   _buf_sizes._reloc = reloc_size;
 739   _buf_sizes._code  = code_size;
 740   _buf_sizes._stub  = stub_size;
 741 }
 742 
 743 //------------------------------FillLocArray-----------------------------------
 744 // Create a bit of debug info and append it to the array.  The mapping is from
 745 // Java local or expression stack to constant, register or stack-slot.  For
 746 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 747 // entry has been taken care of and caller should skip it).
 748 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 749   // This should never have accepted Bad before
 750   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 751   return (OptoReg::is_reg(regnum))
 752          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 753          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 754 }
 755 
 756 
 757 ObjectValue*
 758 PhaseOutput::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
 759   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 760     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 761     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 762     if (sv-&gt;id() == id) {
 763       return sv;
 764     }
 765   }
 766   // Otherwise..
 767   return NULL;
 768 }
 769 
 770 void PhaseOutput::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
 771                                      ObjectValue* sv ) {
 772   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 773   objs-&gt;append(sv);
 774 }
 775 
 776 
 777 void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
 778                             GrowableArray&lt;ScopeValue*&gt; *array,
 779                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 780   assert( local, &quot;use _top instead of null&quot; );
 781   if (array-&gt;length() != idx) {
 782     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 783     // Old functionality:
 784     //   return
 785     // New functionality:
 786     //   Assert if the local is not top. In product mode let the new node
 787     //   override the old entry.
 788     assert(local == C-&gt;top(), &quot;LocArray collision&quot;);
 789     if (local == C-&gt;top()) {
 790       return;
 791     }
 792     array-&gt;pop();
 793   }
 794   const Type *t = local-&gt;bottom_type();
 795 
 796   // Is it a safepoint scalar object node?
 797   if (local-&gt;is_SafePointScalarObject()) {
 798     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 799 
 800     ObjectValue* sv = sv_for_node_id(objs, spobj-&gt;_idx);
 801     if (sv == NULL) {
 802       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 803       assert(cik-&gt;is_instance_klass() ||
 804              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 805       sv = new ObjectValue(spobj-&gt;_idx,
 806                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 807       set_sv_for_object_node(objs, sv);
 808 
 809       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 810       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 811         Node* fld_node = sfpt-&gt;in(first_ind+i);
 812         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 813       }
 814     }
 815     array-&gt;append(sv);
 816     return;
 817   }
 818 
 819   // Grab the register number for the local
 820   OptoReg::Name regnum = C-&gt;regalloc()-&gt;get_reg_first(local);
 821   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 822     // Record the double as two float registers.
 823     // The register mask for such a value always specifies two adjacent
 824     // float registers, with the lower register number even.
 825     // Normally, the allocation of high and low words to these registers
 826     // is irrelevant, because nearly all operations on register pairs
 827     // (e.g., StoreD) treat them as a single unit.
 828     // Here, we assume in addition that the words in these two registers
 829     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 830     // within the interpreter) such that the lower-numbered register
 831     // is written to the lower memory address.  This may seem like
 832     // a machine dependency, but it is not--it is a requirement on
 833     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 834     // even/odd double-register pair to which a double may be allocated,
 835     // the word in the even single-register is stored to the first
 836     // memory word.  (Note that register numbers are completely
 837     // arbitrary, and are not tied to any machine-level encodings.)
 838 #ifdef _LP64
 839     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 840       array-&gt;append(new ConstantIntValue((jint)0));
 841       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::dbl ));
 842     } else if ( t-&gt;base() == Type::Long ) {
 843       array-&gt;append(new ConstantIntValue((jint)0));
 844       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));
 845     } else if ( t-&gt;base() == Type::RawPtr ) {
 846       // jsr/ret return address which must be restored into a the full
 847       // width 64-bit stack slot.
 848       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));
 849     }
 850 #else //_LP64
 851     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 852       // Repack the double/long as two jints.
 853       // The convention the interpreter uses is that the second local
 854       // holds the first raw word of the native double representation.
 855       // This is actually reasonable, since locals and stack arrays
 856       // grow downwards in all implementations.
 857       // (If, on some machine, the interpreter&#39;s Java locals or stack
 858       // were to grow upwards, the embedded doubles would be word-swapped.)
 859       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));
 860       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));
 861     }
 862 #endif //_LP64
 863     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 864              OptoReg::is_reg(regnum) ) {
 865       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::float_in_double()
 866                                                       ? Location::float_in_dbl : Location::normal ));
 867     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
 868       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::int_in_long
 869                                                       ? Location::int_in_long : Location::normal ));
 870     } else if( t-&gt;base() == Type::NarrowOop ) {
 871       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::narrowoop ));
 872     } else {
 873       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, C-&gt;regalloc()-&gt;is_oop(local) ? Location::oop : Location::normal ));
 874     }
 875     return;
 876   }
 877 
 878   // No register.  It must be constant data.
 879   switch (t-&gt;base()) {
 880     case Type::Half:              // Second half of a double
 881       ShouldNotReachHere();       // Caller should skip 2nd halves
 882       break;
 883     case Type::AnyPtr:
 884       array-&gt;append(new ConstantOopWriteValue(NULL));
 885       break;
 886     case Type::AryPtr:
 887     case Type::InstPtr:          // fall through
 888       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 889       break;
 890     case Type::NarrowOop:
 891       if (t == TypeNarrowOop::NULL_PTR) {
 892         array-&gt;append(new ConstantOopWriteValue(NULL));
 893       } else {
 894         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 895       }
 896       break;
 897     case Type::Int:
 898       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));
 899       break;
 900     case Type::RawPtr:
 901       // A return address (T_ADDRESS).
 902       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);
 903 #ifdef _LP64
 904       // Must be restored to the full-width 64-bit stack slot.
 905       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));
 906 #else
 907       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));
 908 #endif
 909       break;
 910     case Type::FloatCon: {
 911       float f = t-&gt;is_float_constant()-&gt;getf();
 912       array-&gt;append(new ConstantIntValue(jint_cast(f)));
 913       break;
 914     }
 915     case Type::DoubleCon: {
 916       jdouble d = t-&gt;is_double_constant()-&gt;getd();
 917 #ifdef _LP64
 918       array-&gt;append(new ConstantIntValue((jint)0));
 919       array-&gt;append(new ConstantDoubleValue(d));
 920 #else
 921       // Repack the double as two jints.
 922     // The convention the interpreter uses is that the second local
 923     // holds the first raw word of the native double representation.
 924     // This is actually reasonable, since locals and stack arrays
 925     // grow downwards in all implementations.
 926     // (If, on some machine, the interpreter&#39;s Java locals or stack
 927     // were to grow upwards, the embedded doubles would be word-swapped.)
 928     jlong_accessor acc;
 929     acc.long_value = jlong_cast(d);
 930     array-&gt;append(new ConstantIntValue(acc.words[1]));
 931     array-&gt;append(new ConstantIntValue(acc.words[0]));
 932 #endif
 933       break;
 934     }
 935     case Type::Long: {
 936       jlong d = t-&gt;is_long()-&gt;get_con();
 937 #ifdef _LP64
 938       array-&gt;append(new ConstantIntValue((jint)0));
 939       array-&gt;append(new ConstantLongValue(d));
 940 #else
 941       // Repack the long as two jints.
 942     // The convention the interpreter uses is that the second local
 943     // holds the first raw word of the native double representation.
 944     // This is actually reasonable, since locals and stack arrays
 945     // grow downwards in all implementations.
 946     // (If, on some machine, the interpreter&#39;s Java locals or stack
 947     // were to grow upwards, the embedded doubles would be word-swapped.)
 948     jlong_accessor acc;
 949     acc.long_value = d;
 950     array-&gt;append(new ConstantIntValue(acc.words[1]));
 951     array-&gt;append(new ConstantIntValue(acc.words[0]));
 952 #endif
 953       break;
 954     }
 955     case Type::Top:               // Add an illegal value here
 956       array-&gt;append(new LocationValue(Location()));
 957       break;
 958     default:
 959       ShouldNotReachHere();
 960       break;
 961   }
 962 }
 963 
 964 // Determine if this node starts a bundle
 965 bool PhaseOutput::starts_bundle(const Node *n) const {
 966   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 967           _node_bundling_base[n-&gt;_idx].starts_bundle());
 968 }
 969 
 970 //--------------------------Process_OopMap_Node--------------------------------
 971 void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {
 972   // Handle special safepoint nodes for synchronization
 973   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 974   MachCallNode      *mcall;
 975 
 976   int safepoint_pc_offset = current_offset;
 977   bool is_method_handle_invoke = false;
 978   bool return_oop = false;
<a name="9" id="anc9"></a><span class="line-added"> 979   bool return_vt = false;</span>
 980 
 981   // Add the safepoint in the DebugInfoRecorder
 982   if( !mach-&gt;is_MachCall() ) {
 983     mcall = NULL;
 984     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);
 985   } else {
 986     mcall = mach-&gt;as_MachCall();
 987 
 988     // Is the call a MethodHandle call?
 989     if (mcall-&gt;is_MachCallJava()) {
 990       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
 991         assert(C-&gt;has_method_handle_invokes(), &quot;must have been set during call generation&quot;);
 992         is_method_handle_invoke = true;
 993       }
 994     }
 995 
 996     // Check if a call returns an object.
<a name="10" id="anc10"></a><span class="line-modified"> 997     if (mcall-&gt;returns_pointer() || mcall-&gt;returns_vt()) {</span>
 998       return_oop = true;
 999     }
<a name="11" id="anc11"></a><span class="line-added">1000     if (mcall-&gt;returns_vt()) {</span>
<span class="line-added">1001       return_vt = true;</span>
<span class="line-added">1002     }</span>
1003     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
1004     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);
1005   }
1006 
1007   // Loop over the JVMState list to add scope information
1008   // Do not skip safepoints with a NULL method, they need monitor info
1009   JVMState* youngest_jvms = sfn-&gt;jvms();
1010   int max_depth = youngest_jvms-&gt;depth();
1011 
1012   // Allocate the object pool for scalar-replaced objects -- the map from
1013   // small-integer keys (which can be recorded in the local and ostack
1014   // arrays) to descriptions of the object state.
1015   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
1016 
1017   // Visit scopes from oldest to youngest.
1018   for (int depth = 1; depth &lt;= max_depth; depth++) {
1019     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1020     int idx;
1021     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1022     // Safepoints that do not have method() set only provide oop-map and monitor info
1023     // to support GC; these do not support deoptimization.
1024     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
1025     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
1026     int num_mon  = jvms-&gt;nof_monitors();
1027     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
1028            &quot;JVMS local count must match that of the method&quot;);
1029 
1030     // Add Local and Expression Stack Information
1031 
1032     // Insert locals into the locarray
1033     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
1034     for( idx = 0; idx &lt; num_locs; idx++ ) {
1035       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
1036     }
1037 
1038     // Insert expression stack entries into the exparray
1039     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
1040     for( idx = 0; idx &lt; num_exps; idx++ ) {
1041       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
1042     }
1043 
1044     // Add in mappings of the monitors
1045     assert( !method ||
1046             !method-&gt;is_synchronized() ||
1047             method-&gt;is_native() ||
1048             num_mon &gt; 0 ||
1049             !GenerateSynchronizationCode,
1050             &quot;monitors must always exist for synchronized methods&quot;);
1051 
1052     // Build the growable array of ScopeValues for exp stack
1053     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
1054 
1055     // Loop over monitors and insert into array
1056     for (idx = 0; idx &lt; num_mon; idx++) {
1057       // Grab the node that defines this monitor
1058       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1059       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1060 
1061       // Create ScopeValue for object
1062       ScopeValue *scval = NULL;
1063 
1064       if (obj_node-&gt;is_SafePointScalarObject()) {
1065         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
1066         scval = PhaseOutput::sv_for_node_id(objs, spobj-&gt;_idx);
1067         if (scval == NULL) {
1068           const Type *t = spobj-&gt;bottom_type();
1069           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
1070           assert(cik-&gt;is_instance_klass() ||
1071                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
1072           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
1073                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
1074           PhaseOutput::set_sv_for_object_node(objs, sv);
1075 
1076           uint first_ind = spobj-&gt;first_index(youngest_jvms);
1077           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
1078             Node* fld_node = sfn-&gt;in(first_ind+i);
1079             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
1080           }
1081           scval = sv;
1082         }
1083       } else if (!obj_node-&gt;is_Con()) {
1084         OptoReg::Name obj_reg = C-&gt;regalloc()-&gt;get_reg_first(obj_node);
1085         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
1086           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::narrowoop );
1087         } else {
1088           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::oop );
1089         }
1090       } else {
1091         const TypePtr *tp = obj_node-&gt;get_ptr_type();
1092         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
1093       }
1094 
1095       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
1096       Location basic_lock = Location::new_stk_loc(Location::normal,C-&gt;regalloc()-&gt;reg2offset(box_reg));
1097       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
1098       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
1099     }
1100 
1101     // We dump the object pool first, since deoptimization reads it in first.
1102     C-&gt;debug_info()-&gt;dump_object_pool(objs);
1103 
1104     // Build first class objects to pass to scope
1105     DebugToken *locvals = C-&gt;debug_info()-&gt;create_scope_values(locarray);
1106     DebugToken *expvals = C-&gt;debug_info()-&gt;create_scope_values(exparray);
1107     DebugToken *monvals = C-&gt;debug_info()-&gt;create_monitor_values(monarray);
1108 
1109     // Make method available for all Safepoints
1110     ciMethod* scope_method = method ? method : C-&gt;method();
1111     // Describe the scope here
1112     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
1113     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
1114     // Now we can describe the scope.
1115     methodHandle null_mh;
1116     bool rethrow_exception = false;
<a name="12" id="anc12"></a><span class="line-modified">1117     C-&gt;debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, return_vt, locvals, expvals, monvals);</span>
1118   } // End jvms loop
1119 
1120   // Mark the end of the scope set.
1121   C-&gt;debug_info()-&gt;end_safepoint(safepoint_pc_offset);
1122 }
1123 
1124 
1125 
1126 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
1127 class NonSafepointEmitter {
1128     Compile*  C;
1129     JVMState* _pending_jvms;
1130     int       _pending_offset;
1131 
1132     void emit_non_safepoint();
1133 
1134  public:
1135     NonSafepointEmitter(Compile* compile) {
1136       this-&gt;C = compile;
1137       _pending_jvms = NULL;
1138       _pending_offset = 0;
1139     }
1140 
1141     void observe_instruction(Node* n, int pc_offset) {
1142       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;
1143 
1144       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);
1145       if (nn == NULL || nn-&gt;jvms() == NULL)  return;
1146       if (_pending_jvms != NULL &amp;&amp;
1147           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {
1148         // Repeated JVMS?  Stretch it up here.
1149         _pending_offset = pc_offset;
1150       } else {
1151         if (_pending_jvms != NULL &amp;&amp;
1152             _pending_offset &lt; pc_offset) {
1153           emit_non_safepoint();
1154         }
1155         _pending_jvms = NULL;
1156         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {
1157           // This is the only way _pending_jvms can become non-NULL:
1158           _pending_jvms = nn-&gt;jvms();
1159           _pending_offset = pc_offset;
1160         }
1161       }
1162     }
1163 
1164     // Stay out of the way of real safepoints:
1165     void observe_safepoint(JVMState* jvms, int pc_offset) {
1166       if (_pending_jvms != NULL &amp;&amp;
1167           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;
1168           _pending_offset &lt; pc_offset) {
1169         emit_non_safepoint();
1170       }
1171       _pending_jvms = NULL;
1172     }
1173 
1174     void flush_at_end() {
1175       if (_pending_jvms != NULL) {
1176         emit_non_safepoint();
1177       }
1178       _pending_jvms = NULL;
1179     }
1180 };
1181 
1182 void NonSafepointEmitter::emit_non_safepoint() {
1183   JVMState* youngest_jvms = _pending_jvms;
1184   int       pc_offset     = _pending_offset;
1185 
1186   // Clear it now:
1187   _pending_jvms = NULL;
1188 
1189   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1190   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1191 
1192   debug_info-&gt;add_non_safepoint(pc_offset);
1193   int max_depth = youngest_jvms-&gt;depth();
1194 
1195   // Visit scopes from oldest to youngest.
1196   for (int depth = 1; depth &lt;= max_depth; depth++) {
1197     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1198     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1199     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1200     methodHandle null_mh;
1201     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1202   }
1203 
1204   // Mark the end of the scope set.
1205   debug_info-&gt;end_non_safepoint(pc_offset);
1206 }
1207 
1208 //------------------------------init_buffer------------------------------------
1209 void PhaseOutput::estimate_buffer_size(int&amp; const_req) {
1210 
1211   // Set the initially allocated size
1212   const_req = initial_const_capacity;
1213 
1214   // The extra spacing after the code is necessary on some platforms.
1215   // Sometimes we need to patch in a jump after the last instruction,
1216   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1217 
1218   // Compute the byte offset where we can store the deopt pc.
1219   if (C-&gt;fixed_slots() != 0) {
1220     _orig_pc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
1221   }
<a name="13" id="anc13"></a><span class="line-added">1222   if (C-&gt;needs_stack_repair()) {</span>
<span class="line-added">1223     // Compute the byte offset of the stack increment value</span>
<span class="line-added">1224     _sp_inc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_sp_inc_slot));</span>
<span class="line-added">1225   }</span>
1226 
1227   // Compute prolog code size
1228   _method_size = 0;
1229   _frame_slots = OptoReg::reg2stack(C-&gt;matcher()-&gt;_old_SP) + C-&gt;regalloc()-&gt;_framesize;
1230 #if defined(IA64) &amp;&amp; !defined(AIX)
1231   if (save_argument_registers()) {
1232     // 4815101: this is a stub with implicit and unknown precision fp args.
1233     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1234     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1235     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1236     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1237     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1238     //
1239     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1240     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1241     // instead of stfd/stfs/ldfd/ldfs.
1242     _frame_slots += 8*(16/BytesPerInt);
1243   }
1244 #endif
1245   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1246 
1247   if (C-&gt;has_mach_constant_base_node()) {
1248     uint add_size = 0;
1249     // Fill the constant table.
1250     // Note:  This must happen before shorten_branches.
1251     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
1252       Block* b = C-&gt;cfg()-&gt;get_block(i);
1253 
1254       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1255         Node* n = b-&gt;get_node(j);
1256 
1257         // If the node is a MachConstantNode evaluate the constant
1258         // value section.
1259         if (n-&gt;is_MachConstant()) {
1260           MachConstantNode* machcon = n-&gt;as_MachConstant();
1261           machcon-&gt;eval_constant(C);
1262         } else if (n-&gt;is_Mach()) {
1263           // On Power there are more nodes that issue constants.
1264           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1265         }
1266       }
1267     }
1268 
1269     // Calculate the offsets of the constants and the size of the
1270     // constant table (including the padding to the next section).
1271     constant_table().calculate_offsets_and_size();
1272     const_req = constant_table().size() + add_size;
1273   }
1274 
1275   // Initialize the space for the BufferBlob used to find and verify
1276   // instruction size in MachNode::emit_size()
1277   init_scratch_buffer_blob(const_req);
1278 }
1279 
1280 CodeBuffer* PhaseOutput::init_buffer() {
1281   int stub_req  = _buf_sizes._stub;
1282   int code_req  = _buf_sizes._code;
1283   int const_req = _buf_sizes._const;
1284 
1285   int pad_req   = NativeCall::instruction_size;
1286 
1287   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1288   stub_req += bs-&gt;estimate_stub_size();
1289 
1290   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1291   // class HandlerImpl is platform-specific and defined in the *.ad files.
1292   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1293   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1294   stub_req += MAX_stubs_size;   // ensure per-stub margin
1295   code_req += MAX_inst_size;    // ensure per-instruction margin
1296 
1297   if (StressCodeBuffers)
1298     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1299 
1300   int total_req =
1301           const_req +
1302           code_req +
1303           pad_req +
1304           stub_req +
1305           exception_handler_req +
1306           deopt_handler_req;               // deopt handler
1307 
1308   if (C-&gt;has_method_handle_invokes())
1309     total_req += deopt_handler_req;  // deopt MH handler
1310 
1311   CodeBuffer* cb = code_buffer();
1312   cb-&gt;initialize(total_req, _buf_sizes._reloc);
1313 
1314   // Have we run out of code space?
1315   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1316     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1317     return NULL;
1318   }
1319   // Configure the code buffer.
1320   cb-&gt;initialize_consts_size(const_req);
1321   cb-&gt;initialize_stubs_size(stub_req);
1322   cb-&gt;initialize_oop_recorder(C-&gt;env()-&gt;oop_recorder());
1323 
1324   // fill in the nop array for bundling computations
1325   MachNode *_nop_list[Bundle::_nop_count];
1326   Bundle::initialize_nops(_nop_list);
1327 
1328   return cb;
1329 }
1330 
1331 //------------------------------fill_buffer------------------------------------
1332 void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
1333   // blk_starts[] contains offsets calculated during short branches processing,
1334   // offsets should not be increased during following steps.
1335 
1336   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1337   // of a loop. It is used to determine the padding for loop alignment.
1338   compute_loop_first_inst_sizes();
1339 
1340   // Create oopmap set.
1341   _oop_map_set = new OopMapSet();
1342 
1343   // !!!!! This preserves old handling of oopmaps for now
1344   C-&gt;debug_info()-&gt;set_oopmaps(_oop_map_set);
1345 
1346   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();
1347   // Count and start of implicit null check instructions
1348   uint inct_cnt = 0;
1349   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1350 
1351   // Count and start of calls
1352   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1353 
1354   uint  return_offset = 0;
1355   int nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());
1356 
1357   int previous_offset = 0;
1358   int current_offset  = 0;
1359   int last_call_offset = -1;
1360   int last_avoid_back_to_back_offset = -1;
1361 #ifdef ASSERT
1362   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1363   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1364   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1365   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1366 #endif
1367 
1368   // Create an array of unused labels, one for each basic block, if printing is enabled
1369 #if defined(SUPPORT_OPTO_ASSEMBLY)
1370   int *node_offsets      = NULL;
1371   uint node_offset_limit = C-&gt;unique();
1372 
1373   if (C-&gt;print_assembly()) {
1374     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1375   }
1376   if (node_offsets != NULL) {
1377     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1378     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1379   }
1380 #endif
1381 
1382   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily
1383 
1384   // Emit the constant table.
1385   if (C-&gt;has_mach_constant_base_node()) {
1386     constant_table().emit(*cb);
1387   }
1388 
1389   // Create an array of labels, one for each basic block
1390   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1391   for (uint i=0; i &lt;= nblocks; i++) {
1392     blk_labels[i].init();
1393   }
1394 
1395   // ------------------
1396   // Now fill in the code buffer
1397   Node *delay_slot = NULL;
1398 
1399   for (uint i = 0; i &lt; nblocks; i++) {
1400     Block* block = C-&gt;cfg()-&gt;get_block(i);
1401     _block = block;
1402     Node* head = block-&gt;head();
1403 
1404     // If this block needs to start aligned (i.e, can be reached other
1405     // than by falling-thru from the previous block), then force the
1406     // start of a new bundle.
1407     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1408       cb-&gt;flush_bundle(true);
1409     }
1410 
1411 #ifdef ASSERT
1412     if (!block-&gt;is_connector()) {
1413       stringStream st;
1414       block-&gt;dump_head(C-&gt;cfg(), &amp;st);
1415       MacroAssembler(cb).block_comment(st.as_string());
1416     }
1417     jmp_target[i] = 0;
1418     jmp_offset[i] = 0;
1419     jmp_size[i]   = 0;
1420     jmp_rule[i]   = 0;
1421 #endif
1422     int blk_offset = current_offset;
1423 
1424     // Define the label at the beginning of the basic block
1425     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1426 
1427     uint last_inst = block-&gt;number_of_nodes();
1428 
1429     // Emit block normally, except for last instruction.
1430     // Emit means &quot;dump code bits into code buffer&quot;.
1431     for (uint j = 0; j&lt;last_inst; j++) {
1432       _index = j;
1433 
1434       // Get the node
1435       Node* n = block-&gt;get_node(j);
1436 
1437       // See if delay slots are supported
1438       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;used_in_unconditional_delay()) {
1439         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
1440         assert(n-&gt;size(C-&gt;regalloc()) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);
1441 
1442         delay_slot = n;
1443         continue;
1444       }
1445 
1446       // If this starts a new instruction group, then flush the current one
1447       // (but allow split bundles)
1448       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1449         cb-&gt;flush_bundle(false);
1450 
1451       // Special handling for SafePoint/Call Nodes
1452       bool is_mcall = false;
1453       if (n-&gt;is_Mach()) {
1454         MachNode *mach = n-&gt;as_Mach();
1455         is_mcall = n-&gt;is_MachCall();
1456         bool is_sfn = n-&gt;is_MachSafePoint();
1457 
1458         // If this requires all previous instructions be flushed, then do so
1459         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1460           cb-&gt;flush_bundle(true);
1461           current_offset = cb-&gt;insts_size();
1462         }
1463 
1464         // A padding may be needed again since a previous instruction
1465         // could be moved to delay slot.
1466 
1467         // align the instruction if necessary
1468         int padding = mach-&gt;compute_padding(current_offset);
1469         // Make sure safepoint node for polling is distinct from a call&#39;s
1470         // return by adding a nop if needed.
1471         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1472           padding = nop_size;
1473         }
1474         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1475             current_offset == last_avoid_back_to_back_offset) {
1476           // Avoid back to back some instructions.
1477           padding = nop_size;
1478         }
1479 
1480         if (padding &gt; 0) {
1481           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1482           int nops_cnt = padding / nop_size;
1483           MachNode *nop = new MachNopNode(nops_cnt);
1484           block-&gt;insert_node(nop, j++);
1485           last_inst++;
1486           C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1487           // Ensure enough space.
1488           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1489           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1490             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1491             return;
1492           }
1493           nop-&gt;emit(*cb, C-&gt;regalloc());
1494           cb-&gt;flush_bundle(true);
1495           current_offset = cb-&gt;insts_size();
1496         }
1497 
1498         // Remember the start of the last call in a basic block
1499         if (is_mcall) {
1500           MachCallNode *mcall = mach-&gt;as_MachCall();
1501 
<a name="14" id="anc14"></a><span class="line-modified">1502           if (mcall-&gt;entry_point() != NULL) {</span>
<span class="line-modified">1503             // This destination address is NOT PC-relative</span>
<span class="line-added">1504             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());</span>
<span class="line-added">1505           }</span>
1506 
1507           // Save the return address
1508           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1509 
1510           if (mcall-&gt;is_MachCallLeaf()) {
1511             is_mcall = false;
1512             is_sfn = false;
1513           }
1514         }
1515 
1516         // sfn will be valid whenever mcall is valid now because of inheritance
1517         if (is_sfn || is_mcall) {
1518 
1519           // Handle special safepoint nodes for synchronization
1520           if (!is_mcall) {
1521             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1522             // !!!!! Stubs only need an oopmap right now, so bail out
1523             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1524               // Write the oopmap directly to the code blob??!!
1525               continue;
1526             }
1527           } // End synchronization
1528 
1529           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1530                                            current_offset);
1531           Process_OopMap_Node(mach, current_offset);
1532         } // End if safepoint
1533 
1534           // If this is a null check, then add the start of the previous instruction to the list
1535         else if( mach-&gt;is_MachNullCheck() ) {
1536           inct_starts[inct_cnt++] = previous_offset;
1537         }
1538 
1539           // If this is a branch, then fill in the label with the target BB&#39;s label
1540         else if (mach-&gt;is_MachBranch()) {
1541           // This requires the TRUE branch target be in succs[0]
1542           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1543 
1544           // Try to replace long branch if delay slot is not used,
1545           // it is mostly for back branches since forward branch&#39;s
1546           // distance is not updated yet.
1547           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
1548                                     C-&gt;output()-&gt;node_bundling(n)-&gt;use_unconditional_delay();
1549           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1550             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
1551             int br_size = n-&gt;size(C-&gt;regalloc());
1552             int offset = blk_starts[block_num] - current_offset;
1553             if (block_num &gt;= i) {
1554               // Current and following block&#39;s offset are not
1555               // finalized yet, adjust distance by the difference
1556               // between calculated and final offsets of current block.
1557               offset -= (blk_starts[i] - blk_offset);
1558             }
1559             // In the following code a nop could be inserted before
1560             // the branch which will increase the backward distance.
1561             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1562             if (needs_padding &amp;&amp; offset &lt;= 0)
1563               offset -= nop_size;
1564 
1565             if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
1566               // We&#39;ve got a winner.  Replace this branch.
1567               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1568 
1569               // Update the jmp_size.
1570               int new_size = replacement-&gt;size(C-&gt;regalloc());
1571               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1572               // Insert padding between avoid_back_to_back branches.
1573               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1574                 MachNode *nop = new MachNopNode();
1575                 block-&gt;insert_node(nop, j++);
1576                 C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1577                 last_inst++;
1578                 nop-&gt;emit(*cb, C-&gt;regalloc());
1579                 cb-&gt;flush_bundle(true);
1580                 current_offset = cb-&gt;insts_size();
1581               }
1582 #ifdef ASSERT
1583               jmp_target[i] = block_num;
1584               jmp_offset[i] = current_offset - blk_offset;
1585               jmp_size[i]   = new_size;
1586               jmp_rule[i]   = mach-&gt;rule();
1587 #endif
1588               block-&gt;map_node(replacement, j);
1589               mach-&gt;subsume_by(replacement, C);
1590               n    = replacement;
1591               mach = replacement;
1592             }
1593           }
1594           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1595         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1596           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1597             Block* succs_block = block-&gt;_succs[h];
1598             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1599               Node* jpn = succs_block-&gt;pred(j);
1600               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1601                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1602                 Label *blkLabel = &amp;blk_labels[block_num];
1603                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1604               }
1605             }
1606           }
1607         }
1608 #ifdef ASSERT
1609           // Check that oop-store precedes the card-mark
1610         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1611           uint storeCM_idx = j;
1612           int count = 0;
1613           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1614             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1615             if (oop_store == NULL) continue;
1616             count++;
1617             uint i4;
1618             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1619               if (block-&gt;get_node(i4) == oop_store) {
1620                 break;
1621               }
1622             }
1623             // Note: This test can provide a false failure if other precedence
1624             // edges have been added to the storeCMNode.
1625             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1626           }
1627           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1628         }
1629 #endif
1630         else if (!n-&gt;is_Proj()) {
1631           // Remember the beginning of the previous instruction, in case
1632           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1633           // Intel all the time, with add-to-memory kind of opcodes.
1634           previous_offset = current_offset;
1635         }
1636 
1637         // Not an else-if!
1638         // If this is a trap based cmp then add its offset to the list.
1639         if (mach-&gt;is_TrapBasedCheckNode()) {
1640           inct_starts[inct_cnt++] = current_offset;
1641         }
1642       }
1643 
1644       // Verify that there is sufficient space remaining
1645       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1646       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1647         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1648         return;
1649       }
1650 
1651       // Save the offset for the listing
1652 #if defined(SUPPORT_OPTO_ASSEMBLY)
1653       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1654         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1655       }
1656 #endif
1657 
1658       // &quot;Normal&quot; instruction case
1659       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1660       n-&gt;emit(*cb, C-&gt;regalloc());
1661       current_offset  = cb-&gt;insts_size();
1662 
1663       // Above we only verified that there is enough space in the instruction section.
1664       // However, the instruction may emit stubs that cause code buffer expansion.
1665       // Bail out here if expansion failed due to a lack of code cache space.
1666       if (C-&gt;failing()) {
1667         return;
1668       }
1669 
1670 #ifdef ASSERT
1671       if (n-&gt;size(C-&gt;regalloc()) &lt; (current_offset-instr_offset)) {
1672         n-&gt;dump();
1673         assert(false, &quot;wrong size of mach node&quot;);
1674       }
1675 #endif
1676       non_safepoints.observe_instruction(n, current_offset);
1677 
1678       // mcall is last &quot;call&quot; that can be a safepoint
1679       // record it so we can see if a poll will directly follow it
1680       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1681       // see  5010568. This can be slightly inaccurate but conservative
1682       // in the case that return address is not actually at current_offset.
1683       // This is a small price to pay.
1684 
1685       if (is_mcall) {
1686         last_call_offset = current_offset;
1687       }
1688 
1689       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1690         // Avoid back to back some instructions.
1691         last_avoid_back_to_back_offset = current_offset;
1692       }
1693 
1694       // See if this instruction has a delay slot
1695       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1696         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1697 
1698         // Back up 1 instruction
1699         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1700 
1701         // Save the offset for the listing
1702 #if defined(SUPPORT_OPTO_ASSEMBLY)
1703         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {
1704           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
1705         }
1706 #endif
1707 
1708         // Support a SafePoint in the delay slot
1709         if (delay_slot-&gt;is_MachSafePoint()) {
1710           MachNode *mach = delay_slot-&gt;as_Mach();
1711           // !!!!! Stubs only need an oopmap right now, so bail out
1712           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1713             // Write the oopmap directly to the code blob??!!
1714             delay_slot = NULL;
1715             continue;
1716           }
1717 
1718           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1719           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1720                                            adjusted_offset);
1721           // Generate an OopMap entry
1722           Process_OopMap_Node(mach, adjusted_offset);
1723         }
1724 
1725         // Insert the delay slot instruction
1726         delay_slot-&gt;emit(*cb, C-&gt;regalloc());
1727 
1728         // Don&#39;t reuse it
1729         delay_slot = NULL;
1730       }
1731 
1732     } // End for all instructions in block
1733 
1734     // If the next block is the top of a loop, pad this block out to align
1735     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1736     if (i &lt; nblocks-1) {
1737       Block *nb = C-&gt;cfg()-&gt;get_block(i + 1);
1738       int padding = nb-&gt;alignment_padding(current_offset);
1739       if( padding &gt; 0 ) {
1740         MachNode *nop = new MachNopNode(padding / nop_size);
1741         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
1742         C-&gt;cfg()-&gt;map_node_to_block(nop, block);
1743         nop-&gt;emit(*cb, C-&gt;regalloc());
1744         current_offset = cb-&gt;insts_size();
1745       }
1746     }
1747     // Verify that the distance for generated before forward
1748     // short branches is still valid.
1749     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1750 
1751     // Save new block start offset
1752     blk_starts[i] = blk_offset;
1753   } // End of for all blocks
1754   blk_starts[nblocks] = current_offset;
1755 
1756   non_safepoints.flush_at_end();
1757 
1758   // Offset too large?
1759   if (C-&gt;failing())  return;
1760 
1761   // Define a pseudo-label at the end of the code
1762   MacroAssembler(cb).bind( blk_labels[nblocks] );
1763 
1764   // Compute the size of the first block
1765   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1766 
1767 #ifdef ASSERT
1768   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1769     if (jmp_target[i] != 0) {
1770       int br_size = jmp_size[i];
1771       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
1772       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
1773         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1774         assert(false, &quot;Displacement too large for short jmp&quot;);
1775       }
1776     }
1777   }
1778 #endif
1779 
1780   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1781   bs-&gt;emit_stubs(*cb);
1782   if (C-&gt;failing())  return;
1783 
1784 #ifndef PRODUCT
1785   // Information on the size of the method, without the extraneous code
1786   Scheduling::increment_method_size(cb-&gt;insts_size());
1787 #endif
1788 
1789   // ------------------
1790   // Fill in exception table entries.
1791   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1792 
1793   // Only java methods have exception handlers and deopt handlers
1794   // class HandlerImpl is platform-specific and defined in the *.ad files.
1795   if (C-&gt;method()) {
1796     // Emit the exception handler code.
1797     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
1798     if (C-&gt;failing()) {
1799       return; // CodeBuffer::expand failed
1800     }
1801     // Emit the deopt handler code.
1802     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1803 
1804     // Emit the MethodHandle deopt handler code (if required).
1805     if (C-&gt;has_method_handle_invokes() &amp;&amp; !C-&gt;failing()) {
1806       // We can use the same code as for the normal deopt handler, we
1807       // just need a different entry point address.
1808       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1809     }
1810   }
1811 
1812   // One last check for failed CodeBuffer::expand:
1813   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1814     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1815     return;
1816   }
1817 
1818 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
1819   if (C-&gt;print_assembly()) {
1820     tty-&gt;cr();
1821     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1822   }
1823 #endif
1824 
1825 #if defined(SUPPORT_OPTO_ASSEMBLY)
1826   // Dump the assembly code, including basic-block numbers
1827   if (C-&gt;print_assembly()) {
1828     ttyLocker ttyl;  // keep the following output all in one block
1829     if (!VMThread::should_terminate()) {  // test this under the tty lock
1830       // This output goes directly to the tty, not the compiler log.
1831       // To enable tools to match it up with the compilation activity,
1832       // be sure to tag this tty output with the compile ID.
1833       if (xtty != NULL) {
1834         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, C-&gt;compile_id(),
1835                    C-&gt;is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
1836                    &quot;&quot;);
1837       }
1838       if (C-&gt;method() != NULL) {
1839         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, C-&gt;compile_id());
1840         C-&gt;method()-&gt;print_metadata();
1841       } else if (C-&gt;stub_name() != NULL) {
1842         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, C-&gt;stub_name());
1843       }
1844       tty-&gt;cr();
1845       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, C-&gt;compile_id());
1846       dump_asm(node_offsets, node_offset_limit);
1847       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1848       if (xtty != NULL) {
1849         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1850         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1851         // thread safe
1852         ttyLocker ttyl2;
1853         xtty-&gt;tail(&quot;opto_assembly&quot;);
1854       }
1855     }
1856   }
1857 #endif
1858 }
1859 
1860 void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
1861   _inc_table.set_size(cnt);
1862 
1863   uint inct_cnt = 0;
1864   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
1865     Block* block = C-&gt;cfg()-&gt;get_block(i);
1866     Node *n = NULL;
1867     int j;
1868 
1869     // Find the branch; ignore trailing NOPs.
1870     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1871       n = block-&gt;get_node(j);
1872       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1873         break;
1874       }
1875     }
1876 
1877     // If we didn&#39;t find anything, continue
1878     if (j &lt; 0) {
1879       continue;
1880     }
1881 
1882     // Compute ExceptionHandlerTable subtable entry and add it
1883     // (skip empty blocks)
1884     if (n-&gt;is_Catch()) {
1885 
1886       // Get the offset of the return from the call
1887       uint call_return = call_returns[block-&gt;_pre_order];
1888 #ifdef ASSERT
1889       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1890       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1891       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1892 #endif
1893       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1894       int nof_succs = block-&gt;_num_succs;
1895       // allocate space
1896       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1897       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1898       // iterate through all successors
1899       for (int j = 0; j &lt; nof_succs; j++) {
1900         Block* s = block-&gt;_succs[j];
1901         bool found_p = false;
1902         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1903           Node* pk = s-&gt;pred(k);
1904           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1905             const CatchProjNode* p = pk-&gt;as_CatchProj();
1906             found_p = true;
1907             // add the corresponding handler bci &amp; pco information
1908             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1909               // p leads to an exception handler (and is not fall through)
1910               assert(s == C-&gt;cfg()-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);
1911               // no duplicates, please
1912               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1913                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1914                 handler_bcis.append(p-&gt;handler_bci());
1915                 handler_pcos.append(blk_labels[block_num].loc_pos());
1916               }
1917             }
1918           }
1919         }
1920         assert(found_p, &quot;no matching predecessor found&quot;);
1921         // Note:  Due to empty block removal, one block may have
1922         // several CatchProj inputs, from the same Catch.
1923       }
1924 
1925       // Set the offset of the return from the call
1926       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1927       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1928       continue;
1929     }
1930 
1931     // Handle implicit null exception table updates
1932     if (n-&gt;is_MachNullCheck()) {
1933       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1934       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1935       continue;
1936     }
1937     // Handle implicit exception table updates: trap instructions.
1938     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1939       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1940       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1941       continue;
1942     }
1943   } // End of for all blocks fill in exception table entries
1944 }
1945 
1946 // Static Variables
1947 #ifndef PRODUCT
1948 uint Scheduling::_total_nop_size = 0;
1949 uint Scheduling::_total_method_size = 0;
1950 uint Scheduling::_total_branches = 0;
1951 uint Scheduling::_total_unconditional_delays = 0;
1952 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1953 #endif
1954 
1955 // Initializer for class Scheduling
1956 
1957 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
1958         : _arena(arena),
1959           _cfg(compile.cfg()),
1960           _regalloc(compile.regalloc()),
1961           _scheduled(arena),
1962           _available(arena),
1963           _reg_node(arena),
1964           _pinch_free_list(arena),
1965           _next_node(NULL),
1966           _bundle_instr_count(0),
1967           _bundle_cycle_number(0),
1968           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1969 #ifndef PRODUCT
1970         , _branches(0)
1971         , _unconditional_delays(0)
1972 #endif
1973 {
1974   // Create a MachNopNode
1975   _nop = new MachNopNode();
1976 
1977   // Now that the nops are in the array, save the count
1978   // (but allow entries for the nops)
1979   _node_bundling_limit = compile.unique();
1980   uint node_max = _regalloc-&gt;node_regs_max_index();
1981 
1982   compile.output()-&gt;set_node_bundling_limit(_node_bundling_limit);
1983 
1984   // This one is persistent within the Compile class
1985   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1986 
1987   // Allocate space for fixed-size arrays
1988   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1989   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1990   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1991 
1992   // Clear the arrays
1993   for (uint i = 0; i &lt; node_max; i++) {
1994     ::new (&amp;_node_bundling_base[i]) Bundle();
1995   }
1996   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1997   memset(_uses,               0, node_max * sizeof(short));
1998   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1999 
2000   // Clear the bundling information
2001   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
2002 
2003   // Get the last node
2004   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
2005 
2006   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
2007 }
2008 
2009 #ifndef PRODUCT
2010 // Scheduling destructor
2011 Scheduling::~Scheduling() {
2012   _total_branches             += _branches;
2013   _total_unconditional_delays += _unconditional_delays;
2014 }
2015 #endif
2016 
2017 // Step ahead &quot;i&quot; cycles
2018 void Scheduling::step(uint i) {
2019 
2020   Bundle *bundle = node_bundling(_next_node);
2021   bundle-&gt;set_starts_bundle();
2022 
2023   // Update the bundle record, but leave the flags information alone
2024   if (_bundle_instr_count &gt; 0) {
2025     bundle-&gt;set_instr_count(_bundle_instr_count);
2026     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
2027   }
2028 
2029   // Update the state information
2030   _bundle_instr_count = 0;
2031   _bundle_cycle_number += i;
2032   _bundle_use.step(i);
2033 }
2034 
2035 void Scheduling::step_and_clear() {
2036   Bundle *bundle = node_bundling(_next_node);
2037   bundle-&gt;set_starts_bundle();
2038 
2039   // Update the bundle record
2040   if (_bundle_instr_count &gt; 0) {
2041     bundle-&gt;set_instr_count(_bundle_instr_count);
2042     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
2043 
2044     _bundle_cycle_number += 1;
2045   }
2046 
2047   // Clear the bundling information
2048   _bundle_instr_count = 0;
2049   _bundle_use.reset();
2050 
2051   memcpy(_bundle_use_elements,
2052          Pipeline_Use::elaborated_elements,
2053          sizeof(Pipeline_Use::elaborated_elements));
2054 }
2055 
2056 // Perform instruction scheduling and bundling over the sequence of
2057 // instructions in backwards order.
2058 void PhaseOutput::ScheduleAndBundle() {
2059 
2060   // Don&#39;t optimize this if it isn&#39;t a method
2061   if (!C-&gt;method())
2062     return;
2063 
2064   // Don&#39;t optimize this if scheduling is disabled
2065   if (!C-&gt;do_scheduling())
2066     return;
2067 
2068   // Scheduling code works only with pairs (16 bytes) maximum.
2069   if (C-&gt;max_vector_size() &gt; 16)
2070     return;
2071 
2072   Compile::TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);
2073 
2074   // Create a data structure for all the scheduling information
2075   Scheduling scheduling(Thread::current()-&gt;resource_area(), *C);
2076 
2077   // Walk backwards over each basic block, computing the needed alignment
2078   // Walk over all the basic blocks
2079   scheduling.DoScheduling();
2080 
2081 #ifndef PRODUCT
2082   if (C-&gt;trace_opto_output()) {
2083     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
2084     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
2085       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
2086       Block* block = C-&gt;cfg()-&gt;get_block(i);
2087       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
2088         Node* n = block-&gt;get_node(j);
2089         OptoReg::Name reg = C-&gt;regalloc()-&gt;get_reg_first(n);
2090         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
2091         n-&gt;dump();
2092       }
2093     }
2094   }
2095 #endif
2096 }
2097 
2098 // Compute the latency of all the instructions.  This is fairly simple,
2099 // because we already have a legal ordering.  Walk over the instructions
2100 // from first to last, and compute the latency of the instruction based
2101 // on the latency of the preceding instruction(s).
2102 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
2103 #ifndef PRODUCT
2104   if (_cfg-&gt;C-&gt;trace_opto_output())
2105     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
2106 #endif
2107 
2108   // Walk over all the schedulable instructions
2109   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
2110 
2111     // This is a kludge, forcing all latency calculations to start at 1.
2112     // Used to allow latency 0 to force an instruction to the beginning
2113     // of the bb
2114     uint latency = 1;
2115     Node *use = bb-&gt;get_node(j);
2116     uint nlen = use-&gt;len();
2117 
2118     // Walk over all the inputs
2119     for ( uint k=0; k &lt; nlen; k++ ) {
2120       Node *def = use-&gt;in(k);
2121       if (!def)
2122         continue;
2123 
2124       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
2125       if (latency &lt; l)
2126         latency = l;
2127     }
2128 
2129     _node_latency[use-&gt;_idx] = latency;
2130 
2131 #ifndef PRODUCT
2132     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2133       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
2134       use-&gt;dump();
2135     }
2136 #endif
2137   }
2138 
2139 #ifndef PRODUCT
2140   if (_cfg-&gt;C-&gt;trace_opto_output())
2141     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
2142 #endif
2143 
2144 } // end ComputeLocalLatenciesForward
2145 
2146 // See if this node fits into the present instruction bundle
2147 bool Scheduling::NodeFitsInBundle(Node *n) {
2148   uint n_idx = n-&gt;_idx;
2149 
2150   // If this is the unconditional delay instruction, then it fits
2151   if (n == _unconditional_delay_slot) {
2152 #ifndef PRODUCT
2153     if (_cfg-&gt;C-&gt;trace_opto_output())
2154       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
2155 #endif
2156     return (true);
2157   }
2158 
2159   // If the node cannot be scheduled this cycle, skip it
2160   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
2161 #ifndef PRODUCT
2162     if (_cfg-&gt;C-&gt;trace_opto_output())
2163       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
2164                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);
2165 #endif
2166     return (false);
2167   }
2168 
2169   const Pipeline *node_pipeline = n-&gt;pipeline();
2170 
2171   uint instruction_count = node_pipeline-&gt;instructionCount();
2172   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2173     instruction_count = 0;
2174   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2175     instruction_count++;
2176 
2177   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
2178 #ifndef PRODUCT
2179     if (_cfg-&gt;C-&gt;trace_opto_output())
2180       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
2181                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
2182 #endif
2183     return (false);
2184   }
2185 
2186   // Don&#39;t allow non-machine nodes to be handled this way
2187   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
2188     return (false);
2189 
2190   // See if there is any overlap
2191   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
2192 
2193   if (delay &gt; 0) {
2194 #ifndef PRODUCT
2195     if (_cfg-&gt;C-&gt;trace_opto_output())
2196       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
2197 #endif
2198     return false;
2199   }
2200 
2201 #ifndef PRODUCT
2202   if (_cfg-&gt;C-&gt;trace_opto_output())
2203     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
2204 #endif
2205 
2206   return true;
2207 }
2208 
2209 Node * Scheduling::ChooseNodeToBundle() {
2210   uint siz = _available.size();
2211 
2212   if (siz == 0) {
2213 
2214 #ifndef PRODUCT
2215     if (_cfg-&gt;C-&gt;trace_opto_output())
2216       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
2217 #endif
2218     return (NULL);
2219   }
2220 
2221   // Fast path, if only 1 instruction in the bundle
2222   if (siz == 1) {
2223 #ifndef PRODUCT
2224     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2225       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
2226       _available[0]-&gt;dump();
2227     }
2228 #endif
2229     return (_available[0]);
2230   }
2231 
2232   // Don&#39;t bother, if the bundle is already full
2233   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
2234     for ( uint i = 0; i &lt; siz; i++ ) {
2235       Node *n = _available[i];
2236 
2237       // Skip projections, we&#39;ll handle them another way
2238       if (n-&gt;is_Proj())
2239         continue;
2240 
2241       // This presupposed that instructions are inserted into the
2242       // available list in a legality order; i.e. instructions that
2243       // must be inserted first are at the head of the list
2244       if (NodeFitsInBundle(n)) {
2245 #ifndef PRODUCT
2246         if (_cfg-&gt;C-&gt;trace_opto_output()) {
2247           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2248           n-&gt;dump();
2249         }
2250 #endif
2251         return (n);
2252       }
2253     }
2254   }
2255 
2256   // Nothing fits in this bundle, choose the highest priority
2257 #ifndef PRODUCT
2258   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2259     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2260     _available[0]-&gt;dump();
2261   }
2262 #endif
2263 
2264   return _available[0];
2265 }
2266 
2267 void Scheduling::AddNodeToAvailableList(Node *n) {
2268   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2269 #ifndef PRODUCT
2270   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2271     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2272     n-&gt;dump();
2273   }
2274 #endif
2275 
2276   int latency = _current_latency[n-&gt;_idx];
2277 
2278   // Insert in latency order (insertion sort)
2279   uint i;
2280   for ( i=0; i &lt; _available.size(); i++ )
2281     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2282       break;
2283 
2284   // Special Check for compares following branches
2285   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2286     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2287     Node *last = _scheduled[0];
2288     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2289         ( op == Op_CmpI ||
2290           op == Op_CmpU ||
2291           op == Op_CmpUL ||
2292           op == Op_CmpP ||
2293           op == Op_CmpF ||
2294           op == Op_CmpD ||
2295           op == Op_CmpL ) ) {
2296 
2297       // Recalculate position, moving to front of same latency
2298       for ( i=0 ; i &lt; _available.size(); i++ )
2299         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2300           break;
2301     }
2302   }
2303 
2304   // Insert the node in the available list
2305   _available.insert(i, n);
2306 
2307 #ifndef PRODUCT
2308   if (_cfg-&gt;C-&gt;trace_opto_output())
2309     dump_available();
2310 #endif
2311 }
2312 
2313 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2314   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2315     Node *def = n-&gt;in(i);
2316     if (!def) continue;
2317     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2318       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2319 
2320     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2321       continue;
2322     }
2323 
2324     // Compute the latency
2325     uint l = _bundle_cycle_number + n-&gt;latency(i);
2326     if (_current_latency[def-&gt;_idx] &lt; l)
2327       _current_latency[def-&gt;_idx] = l;
2328 
2329     // If this does not have uses then schedule it
2330     if ((--_uses[def-&gt;_idx]) == 0)
2331       AddNodeToAvailableList(def);
2332   }
2333 }
2334 
2335 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2336 #ifndef PRODUCT
2337   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2338     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2339     n-&gt;dump();
2340   }
2341 #endif
2342 
2343   // Remove this from the available list
2344   uint i;
2345   for (i = 0; i &lt; _available.size(); i++)
2346     if (_available[i] == n)
2347       break;
2348   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2349   _available.remove(i);
2350 
2351   // See if this fits in the current bundle
2352   const Pipeline *node_pipeline = n-&gt;pipeline();
2353   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2354 
2355   // Check for instructions to be placed in the delay slot. We
2356   // do this before we actually schedule the current instruction,
2357   // because the delay slot follows the current instruction.
2358   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2359       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2360       !_unconditional_delay_slot) {
2361 
2362     uint siz = _available.size();
2363 
2364     // Conditional branches can support an instruction that
2365     // is unconditionally executed and not dependent by the
2366     // branch, OR a conditionally executed instruction if
2367     // the branch is taken.  In practice, this means that
2368     // the first instruction at the branch target is
2369     // copied to the delay slot, and the branch goes to
2370     // the instruction after that at the branch target
2371     if ( n-&gt;is_MachBranch() ) {
2372 
2373       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2374       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2375 
2376 #ifndef PRODUCT
2377       _branches++;
2378 #endif
2379 
2380       // At least 1 instruction is on the available list
2381       // that is not dependent on the branch
2382       for (uint i = 0; i &lt; siz; i++) {
2383         Node *d = _available[i];
2384         const Pipeline *avail_pipeline = d-&gt;pipeline();
2385 
2386         // Don&#39;t allow safepoints in the branch shadow, that will
2387         // cause a number of difficulties
2388         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
2389              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;
2390              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;
2391              Pipeline::instr_has_unit_size() &amp;&amp;
2392              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;
2393              NodeFitsInBundle(d) &amp;&amp;
2394              !node_bundling(d)-&gt;used_in_delay()) {
2395 
2396           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2397             // A node that fits in the delay slot was found, so we need to
2398             // set the appropriate bits in the bundle pipeline information so
2399             // that it correctly indicates resource usage.  Later, when we
2400             // attempt to add this instruction to the bundle, we will skip
2401             // setting the resource usage.
2402             _unconditional_delay_slot = d;
2403             node_bundling(n)-&gt;set_use_unconditional_delay();
2404             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2405             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2406             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2407             _next_node = d;
2408             ++_bundle_instr_count;
2409 #ifndef PRODUCT
2410             _unconditional_delays++;
2411 #endif
2412             break;
2413           }
2414         }
2415       }
2416     }
2417 
2418     // No delay slot, add a nop to the usage
2419     if (!_unconditional_delay_slot) {
2420       // See if adding an instruction in the delay slot will overflow
2421       // the bundle.
2422       if (!NodeFitsInBundle(_nop)) {
2423 #ifndef PRODUCT
2424         if (_cfg-&gt;C-&gt;trace_opto_output())
2425           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2426 #endif
2427         step(1);
2428       }
2429 
2430       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2431       _next_node = _nop;
2432       ++_bundle_instr_count;
2433     }
2434 
2435     // See if the instruction in the delay slot requires a
2436     // step of the bundles
2437     if (!NodeFitsInBundle(n)) {
2438 #ifndef PRODUCT
2439       if (_cfg-&gt;C-&gt;trace_opto_output())
2440         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);
2441 #endif
2442       // Update the state information
2443       _bundle_instr_count = 0;
2444       _bundle_cycle_number += 1;
2445       _bundle_use.step(1);
2446     }
2447   }
2448 
2449   // Get the number of instructions
2450   uint instruction_count = node_pipeline-&gt;instructionCount();
2451   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2452     instruction_count = 0;
2453 
2454   // Compute the latency information
2455   uint delay = 0;
2456 
2457   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2458     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2459     if (relative_latency &lt; 0)
2460       relative_latency = 0;
2461 
2462     delay = _bundle_use.full_latency(relative_latency, node_usage);
2463 
2464     // Does not fit in this bundle, start a new one
2465     if (delay &gt; 0) {
2466       step(delay);
2467 
2468 #ifndef PRODUCT
2469       if (_cfg-&gt;C-&gt;trace_opto_output())
2470         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2471 #endif
2472     }
2473   }
2474 
2475   // If this was placed in the delay slot, ignore it
2476   if (n != _unconditional_delay_slot) {
2477 
2478     if (delay == 0) {
2479       if (node_pipeline-&gt;hasMultipleBundles()) {
2480 #ifndef PRODUCT
2481         if (_cfg-&gt;C-&gt;trace_opto_output())
2482           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2483 #endif
2484         step(1);
2485       }
2486 
2487       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2488 #ifndef PRODUCT
2489         if (_cfg-&gt;C-&gt;trace_opto_output())
2490           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
2491                      instruction_count + _bundle_instr_count,
2492                      Pipeline::_max_instrs_per_cycle);
2493 #endif
2494         step(1);
2495       }
2496     }
2497 
2498     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2499       _bundle_instr_count++;
2500 
2501     // Set the node&#39;s latency
2502     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2503 
2504     // Now merge the functional unit information
2505     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2506       _bundle_use.add_usage(node_usage);
2507 
2508     // Increment the number of instructions in this bundle
2509     _bundle_instr_count += instruction_count;
2510 
2511     // Remember this node for later
2512     if (n-&gt;is_Mach())
2513       _next_node = n;
2514   }
2515 
2516   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2517   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2518   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2519   // into the block.  All other scheduled nodes get put in the schedule here.
2520   int op = n-&gt;Opcode();
2521   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2522       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2523        // not an unallocated boxlock
2524        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2525 
2526     // Push any trailing projections
2527     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2528       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2529         Node *foi = n-&gt;fast_out(i);
2530         if( foi-&gt;is_Proj() )
2531           _scheduled.push(foi);
2532       }
2533     }
2534 
2535     // Put the instruction in the schedule list
2536     _scheduled.push(n);
2537   }
2538 
2539 #ifndef PRODUCT
2540   if (_cfg-&gt;C-&gt;trace_opto_output())
2541     dump_available();
2542 #endif
2543 
2544   // Walk all the definitions, decrementing use counts, and
2545   // if a definition has a 0 use count, place it in the available list.
2546   DecrementUseCounts(n,bb);
2547 }
2548 
2549 // This method sets the use count within a basic block.  We will ignore all
2550 // uses outside the current basic block.  As we are doing a backwards walk,
2551 // any node we reach that has a use count of 0 may be scheduled.  This also
2552 // avoids the problem of cyclic references from phi nodes, as long as phi
2553 // nodes are at the front of the basic block.  This method also initializes
2554 // the available list to the set of instructions that have no uses within this
2555 // basic block.
2556 void Scheduling::ComputeUseCount(const Block *bb) {
2557 #ifndef PRODUCT
2558   if (_cfg-&gt;C-&gt;trace_opto_output())
2559     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2560 #endif
2561 
2562   // Clear the list of available and scheduled instructions, just in case
2563   _available.clear();
2564   _scheduled.clear();
2565 
2566   // No delay slot specified
2567   _unconditional_delay_slot = NULL;
2568 
2569 #ifdef ASSERT
2570   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2571     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2572 #endif
2573 
2574   // Force the _uses count to never go to zero for unscheduable pieces
2575   // of the block
2576   for( uint k = 0; k &lt; _bb_start; k++ )
2577     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2578   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2579     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2580 
2581   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2582   // branch projections at end or the block header instructions.
2583   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2584     Node *n = bb-&gt;get_node(j);
2585     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2586 
2587     // Account for all uses
2588     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2589       Node *inp = n-&gt;in(k);
2590       if (!inp) continue;
2591       assert(inp != n, &quot;no cycles allowed&quot; );
2592       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2593         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2594           inp = inp-&gt;in(0);
2595         }
2596         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2597       }
2598     }
2599 
2600     // If this instruction has a 0 use count, then it is available
2601     if (!_uses[n-&gt;_idx]) {
2602       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2603       AddNodeToAvailableList(n);
2604     }
2605 
2606 #ifndef PRODUCT
2607     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2608       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2609       n-&gt;dump();
2610     }
2611 #endif
2612   }
2613 
2614 #ifndef PRODUCT
2615   if (_cfg-&gt;C-&gt;trace_opto_output())
2616     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2617 #endif
2618 }
2619 
2620 // This routine performs scheduling on each basic block in reverse order,
2621 // using instruction latencies and taking into account function unit
2622 // availability.
2623 void Scheduling::DoScheduling() {
2624 #ifndef PRODUCT
2625   if (_cfg-&gt;C-&gt;trace_opto_output())
2626     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2627 #endif
2628 
2629   Block *succ_bb = NULL;
2630   Block *bb;
2631   Compile* C = Compile::current();
2632 
2633   // Walk over all the basic blocks in reverse order
2634   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2635     bb = _cfg-&gt;get_block(i);
2636 
2637 #ifndef PRODUCT
2638     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2639       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2640       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2641         bb-&gt;get_node(j)-&gt;dump();
2642       }
2643     }
2644 #endif
2645 
2646     // On the head node, skip processing
2647     if (bb == _cfg-&gt;get_root_block()) {
2648       continue;
2649     }
2650 
2651     // Skip empty, connector blocks
2652     if (bb-&gt;is_connector())
2653       continue;
2654 
2655     // If the following block is not the sole successor of
2656     // this one, then reset the pipeline information
2657     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2658 #ifndef PRODUCT
2659       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2660         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2661                    _next_node-&gt;_idx, _bundle_instr_count);
2662       }
2663 #endif
2664       step_and_clear();
2665     }
2666 
2667     // Leave untouched the starting instruction, any Phis, a CreateEx node
2668     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2669     _bb_end = bb-&gt;number_of_nodes()-1;
2670     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2671       Node *n = bb-&gt;get_node(_bb_start);
2672       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2673       // Also, MachIdealNodes do not get scheduled
2674       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2675       MachNode *mach = n-&gt;as_Mach();
2676       int iop = mach-&gt;ideal_Opcode();
2677       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2678       if( iop == Op_Con ) continue;      // Do not schedule Top
2679       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2680           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2681           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2682         continue;
2683       break;                    // Funny loop structure to be sure...
2684     }
2685     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2686     // might schedule.  _bb_end points just after last schedulable inst.  We
2687     // normally schedule conditional branches (despite them being forced last
2688     // in the block), because they have delay slots we can fill.  Calls all
2689     // have their delay slots filled in the template expansions, so we don&#39;t
2690     // bother scheduling them.
2691     Node *last = bb-&gt;get_node(_bb_end);
2692     // Ignore trailing NOPs.
2693     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2694            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2695       last = bb-&gt;get_node(--_bb_end);
2696     }
2697     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2698     if( last-&gt;is_Catch() ||
2699         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2700       // There might be a prior call.  Skip it.
2701       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2702     } else if( last-&gt;is_MachNullCheck() ) {
2703       // Backup so the last null-checked memory instruction is
2704       // outside the schedulable range. Skip over the nullcheck,
2705       // projection, and the memory nodes.
2706       Node *mem = last-&gt;in(1);
2707       do {
2708         _bb_end--;
2709       } while (mem != bb-&gt;get_node(_bb_end));
2710     } else {
2711       // Set _bb_end to point after last schedulable inst.
2712       _bb_end++;
2713     }
2714 
2715     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2716 
2717     // Compute the register antidependencies for the basic block
2718     ComputeRegisterAntidependencies(bb);
2719     if (C-&gt;failing())  return;  // too many D-U pinch points
2720 
2721     // Compute intra-bb latencies for the nodes
2722     ComputeLocalLatenciesForward(bb);
2723 
2724     // Compute the usage within the block, and set the list of all nodes
2725     // in the block that have no uses within the block.
2726     ComputeUseCount(bb);
2727 
2728     // Schedule the remaining instructions in the block
2729     while ( _available.size() &gt; 0 ) {
2730       Node *n = ChooseNodeToBundle();
2731       guarantee(n != NULL, &quot;no nodes available&quot;);
2732       AddNodeToBundle(n,bb);
2733     }
2734 
2735     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2736 #ifdef ASSERT
2737     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2738       Node *n = bb-&gt;get_node(l);
2739       uint m;
2740       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2741         if( _scheduled[m] == n )
2742           break;
2743       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2744     }
2745 #endif
2746 
2747     // Now copy the instructions (in reverse order) back to the block
2748     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2749       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2750 
2751 #ifndef PRODUCT
2752     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2753       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2754       uint current = 0;
2755       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2756         Node *n = bb-&gt;get_node(j);
2757         if( valid_bundle_info(n) ) {
2758           Bundle *bundle = node_bundling(n);
2759           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2760             tty-&gt;print(&quot;*** Bundle: &quot;);
2761             bundle-&gt;dump();
2762           }
2763           n-&gt;dump();
2764         }
2765       }
2766     }
2767 #endif
2768 #ifdef ASSERT
2769     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2770 #endif
2771   }
2772 
2773 #ifndef PRODUCT
2774   if (_cfg-&gt;C-&gt;trace_opto_output())
2775     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2776 #endif
2777 
2778   // Record final node-bundling array location
2779   _regalloc-&gt;C-&gt;output()-&gt;set_node_bundling_base(_node_bundling_base);
2780 
2781 } // end DoScheduling
2782 
2783 // Verify that no live-range used in the block is killed in the block by a
2784 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2785 
2786 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2787 static bool edge_from_to( Node *from, Node *to ) {
2788   for( uint i=0; i&lt;from-&gt;len(); i++ )
2789     if( from-&gt;in(i) == to )
2790       return true;
2791   return false;
2792 }
2793 
2794 #ifdef ASSERT
2795 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2796   // Check for bad kills
2797   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2798     Node *prior_use = _reg_node[def];
2799     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2800       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2801       n-&gt;dump();
2802       tty-&gt;print_cr(&quot;...&quot;);
2803       prior_use-&gt;dump();
2804       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2805     }
2806     _reg_node.map(def,NULL); // Kill live USEs
2807   }
2808 }
2809 
2810 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2811 
2812   // Zap to something reasonable for the verify code
2813   _reg_node.clear();
2814 
2815   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2816   // kill a live value (other than the one it&#39;s supposed to).  Add each
2817   // USE to the live set.
2818   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2819     Node *n = b-&gt;get_node(i);
2820     int n_op = n-&gt;Opcode();
2821     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2822       // Fat-proj kills a slew of registers
2823       RegMask rm = n-&gt;out_RegMask();// Make local copy
2824       while( rm.is_NotEmpty() ) {
2825         OptoReg::Name kill = rm.find_first_elem();
2826         rm.Remove(kill);
2827         verify_do_def( n, kill, msg );
2828       }
2829     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2830       // Get DEF&#39;d registers the normal way
2831       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2832       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2833     }
2834 
2835     // Now make all USEs live
2836     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2837       Node *def = n-&gt;in(i);
2838       assert(def != 0, &quot;input edge required&quot;);
2839       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2840       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2841       if( OptoReg::is_valid(reg_lo) ) {
2842         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2843         _reg_node.map(reg_lo,n);
2844       }
2845       if( OptoReg::is_valid(reg_hi) ) {
2846         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2847         _reg_node.map(reg_hi,n);
2848       }
2849     }
2850 
2851   }
2852 
2853   // Zap to something reasonable for the Antidependence code
2854   _reg_node.clear();
2855 }
2856 #endif
2857 
2858 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2859 static void add_prec_edge_from_to( Node *from, Node *to ) {
2860   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2861     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2862     from = from-&gt;in(0);
2863   }
2864   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2865       !edge_from_to( from, to ) ) // Avoid duplicate edge
2866     from-&gt;add_prec(to);
2867 }
2868 
2869 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2870   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2871     return;
2872 
2873   Node *pinch = _reg_node[def_reg]; // Get pinch point
2874   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2875       is_def ) {    // Check for a true def (not a kill)
2876     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2877     return;
2878   }
2879 
2880   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2881   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2882 
2883   // After some number of kills there _may_ be a later def
2884   Node *later_def = NULL;
2885 
2886   Compile* C = Compile::current();
2887 
2888   // Finding a kill requires a real pinch-point.
2889   // Check for not already having a pinch-point.
2890   // Pinch points are Op_Node&#39;s.
2891   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2892     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2893     if ( _pinch_free_list.size() &gt; 0) {
2894       pinch = _pinch_free_list.pop();
2895     } else {
2896       pinch = new Node(1); // Pinch point to-be
2897     }
2898     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2899       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2900       return;
2901     }
2902     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2903     _reg_node.map(def_reg,pinch); // Record pinch-point
2904     //regalloc()-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.
2905     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
2906       pinch-&gt;init_req(0, C-&gt;top());     // set not NULL for the next call
2907       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2908       later_def = NULL;           // and no later def
2909     }
2910     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2911   } else {                        // Else have valid pinch point
2912     if( pinch-&gt;in(0) )            // If there is a later-def
2913       later_def = pinch-&gt;in(0);   // Get it
2914   }
2915 
2916   // Add output-dependence edge from later def to kill
2917   if( later_def )               // If there is some original def
2918     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2919 
2920   // See if current kill is also a use, and so is forced to be the pinch-point.
2921   if( pinch-&gt;Opcode() == Op_Node ) {
2922     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2923     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2924       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2925           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2926         // Yes, found a use/kill pinch-point
2927         pinch-&gt;set_req(0,NULL);  //
2928         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2929         pinch = kill;
2930         _reg_node.map(def_reg,pinch);
2931         return;
2932       }
2933     }
2934   }
2935 
2936   // Add edge from kill to pinch-point
2937   add_prec_edge_from_to(kill,pinch);
2938 }
2939 
2940 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2941   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2942     return;
2943   Node *pinch = _reg_node[use_reg]; // Get pinch point
2944   // Check for no later def_reg/kill in block
2945   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2946       // Use has to be block-local as well
2947       _cfg-&gt;get_block_for_node(use) == b) {
2948     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2949         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2950       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2951       // Insert the pinch-point in the block just after the last use
2952       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2953       _bb_end++;                // Increase size scheduled region in block
2954     }
2955 
2956     add_prec_edge_from_to(pinch,use);
2957   }
2958 }
2959 
2960 // We insert antidependences between the reads and following write of
2961 // allocated registers to prevent illegal code motion. Hopefully, the
2962 // number of added references should be fairly small, especially as we
2963 // are only adding references within the current basic block.
2964 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2965 
2966 #ifdef ASSERT
2967   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2968 #endif
2969 
2970   // A valid schedule, for each register independently, is an endless cycle
2971   // of: a def, then some uses (connected to the def by true dependencies),
2972   // then some kills (defs with no uses), finally the cycle repeats with a new
2973   // def.  The uses are allowed to float relative to each other, as are the
2974   // kills.  No use is allowed to slide past a kill (or def).  This requires
2975   // antidependencies between all uses of a single def and all kills that
2976   // follow, up to the next def.  More edges are redundant, because later defs
2977   // &amp; kills are already serialized with true or antidependencies.  To keep
2978   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2979   // one use or more than one kill/def.
2980 
2981   // We add dependencies in one bottom-up pass.
2982 
2983   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2984 
2985   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2986   // register.  If not, we record the DEF/KILL in _reg_node, the
2987   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2988   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2989   // We put edges from the prior and current DEF/KILLs to the pinch point.
2990   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2991   // we merely add an edge from the current DEF/KILL to the pinch point.
2992 
2993   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2994   // put an edge from the pinch point to the USE.
2995 
2996   // To be expedient, the _reg_node array is pre-allocated for the whole
2997   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2998   // or a valid def/kill/pinch-point, or a leftover node from some prior
2999   // block.  Leftover node from some prior block is treated like a NULL (no
3000   // prior def, so no anti-dependence needed).  Valid def is distinguished by
3001   // it being in the current block.
3002   bool fat_proj_seen = false;
3003   uint last_safept = _bb_end-1;
3004   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
3005   Node* last_safept_node = end_node;
3006   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
3007     Node *n = b-&gt;get_node(i);
3008     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
3009     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
3010       // Fat-proj kills a slew of registers
3011       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
3012       // hence the is_def flag.
3013       fat_proj_seen = true;
3014       RegMask rm = n-&gt;out_RegMask();// Make local copy
3015       while( rm.is_NotEmpty() ) {
3016         OptoReg::Name kill = rm.find_first_elem();
3017         rm.Remove(kill);
3018         anti_do_def( b, n, kill, is_def );
3019       }
3020     } else {
3021       // Get DEF&#39;d registers the normal way
3022       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
3023       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
3024     }
3025 
3026     // Kill projections on a branch should appear to occur on the
3027     // branch, not afterwards, so grab the masks from the projections
3028     // and process them.
3029     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
3030       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3031         Node* use = n-&gt;fast_out(i);
3032         if (use-&gt;is_Proj()) {
3033           RegMask rm = use-&gt;out_RegMask();// Make local copy
3034           while( rm.is_NotEmpty() ) {
3035             OptoReg::Name kill = rm.find_first_elem();
3036             rm.Remove(kill);
3037             anti_do_def( b, n, kill, false );
3038           }
3039         }
3040       }
3041     }
3042 
3043     // Check each register used by this instruction for a following DEF/KILL
3044     // that must occur afterward and requires an anti-dependence edge.
3045     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
3046       Node *def = n-&gt;in(j);
3047       if( def ) {
3048         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
3049         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
3050         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
3051       }
3052     }
3053     // Do not allow defs of new derived values to float above GC
3054     // points unless the base is definitely available at the GC point.
3055 
3056     Node *m = b-&gt;get_node(i);
3057 
3058     // Add precedence edge from following safepoint to use of derived pointer
3059     if( last_safept_node != end_node &amp;&amp;
3060         m != last_safept_node) {
3061       for (uint k = 1; k &lt; m-&gt;req(); k++) {
3062         const Type *t = m-&gt;in(k)-&gt;bottom_type();
3063         if( t-&gt;isa_oop_ptr() &amp;&amp;
3064             t-&gt;is_ptr()-&gt;offset() != 0 ) {
3065           last_safept_node-&gt;add_prec( m );
3066           break;
3067         }
3068       }
3069     }
3070 
3071     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
3072       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
3073       if( b-&gt;get_node(last_safept) != last_safept_node ) {
3074         last_safept = b-&gt;find_node(last_safept_node);
3075       }
3076       for( uint j=last_safept; j &gt; i; j-- ) {
3077         Node *mach = b-&gt;get_node(j);
3078         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
3079           mach-&gt;add_prec( n );
3080       }
3081       last_safept = i;
3082       last_safept_node = m;
3083     }
3084   }
3085 
3086   if (fat_proj_seen) {
3087     // Garbage collect pinch nodes that were not consumed.
3088     // They are usually created by a fat kill MachProj for a call.
3089     garbage_collect_pinch_nodes();
3090   }
3091 }
3092 
3093 // Garbage collect pinch nodes for reuse by other blocks.
3094 //
3095 // The block scheduler&#39;s insertion of anti-dependence
3096 // edges creates many pinch nodes when the block contains
3097 // 2 or more Calls.  A pinch node is used to prevent a
3098 // combinatorial explosion of edges.  If a set of kills for a
3099 // register is anti-dependent on a set of uses (or defs), rather
3100 // than adding an edge in the graph between each pair of kill
3101 // and use (or def), a pinch is inserted between them:
3102 //
3103 //            use1   use2  use3
3104 //                \   |   /
3105 //                 \  |  /
3106 //                  pinch
3107 //                 /  |  \
3108 //                /   |   \
3109 //            kill1 kill2 kill3
3110 //
3111 // One pinch node is created per register killed when
3112 // the second call is encountered during a backwards pass
3113 // over the block.  Most of these pinch nodes are never
3114 // wired into the graph because the register is never
3115 // used or def&#39;ed in the block.
3116 //
3117 void Scheduling::garbage_collect_pinch_nodes() {
3118 #ifndef PRODUCT
3119   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);
3120 #endif
3121   int trace_cnt = 0;
3122   for (uint k = 0; k &lt; _reg_node.Size(); k++) {
3123     Node* pinch = _reg_node[k];
3124     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;
3125         // no predecence input edges
3126         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {
3127       cleanup_pinch(pinch);
3128       _pinch_free_list.push(pinch);
3129       _reg_node.map(k, NULL);
3130 #ifndef PRODUCT
3131       if (_cfg-&gt;C-&gt;trace_opto_output()) {
3132         trace_cnt++;
3133         if (trace_cnt &gt; 40) {
3134           tty-&gt;print(&quot;\n&quot;);
3135           trace_cnt = 0;
3136         }
3137         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);
3138       }
3139 #endif
3140     }
3141   }
3142 #ifndef PRODUCT
3143   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);
3144 #endif
3145 }
3146 
3147 // Clean up a pinch node for reuse.
3148 void Scheduling::cleanup_pinch( Node *pinch ) {
3149   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
3150 
3151   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
3152     Node* use = pinch-&gt;last_out(i);
3153     uint uses_found = 0;
3154     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
3155       if (use-&gt;in(j) == pinch) {
3156         use-&gt;rm_prec(j);
3157         uses_found++;
3158       }
3159     }
3160     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
3161     i -= uses_found;    // we deleted 1 or more copies of this edge
3162   }
3163   // May have a later_def entry
3164   pinch-&gt;set_req(0, NULL);
3165 }
3166 
3167 #ifndef PRODUCT
3168 
3169 void Scheduling::dump_available() const {
3170   tty-&gt;print(&quot;#Availist  &quot;);
3171   for (uint i = 0; i &lt; _available.size(); i++)
3172     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
3173   tty-&gt;cr();
3174 }
3175 
3176 // Print Scheduling Statistics
3177 void Scheduling::print_statistics() {
3178   // Print the size added by nops for bundling
3179   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
3180              _total_nop_size, _total_method_size);
3181   if (_total_method_size &gt; 0)
3182     tty-&gt;print(&quot;, for %.2f%%&quot;,
3183                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
3184   tty-&gt;print(&quot;\n&quot;);
3185 
3186   // Print the number of branch shadows filled
3187   if (Pipeline::_branch_has_delay_slot) {
3188     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
3189                _total_branches, _total_unconditional_delays);
3190     if (_total_branches &gt; 0)
3191       tty-&gt;print(&quot;, for %.2f%%&quot;,
3192                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3193     tty-&gt;print(&quot;\n&quot;);
3194   }
3195 
3196   uint total_instructions = 0, total_bundles = 0;
3197 
3198   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3199     uint bundle_count   = _total_instructions_per_bundle[i];
3200     total_instructions += bundle_count * i;
3201     total_bundles      += bundle_count;
3202   }
3203 
3204   if (total_bundles &gt; 0)
3205     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3206                ((double)total_instructions) / ((double)total_bundles));
3207 }
3208 #endif
3209 
3210 //-----------------------init_scratch_buffer_blob------------------------------
3211 // Construct a temporary BufferBlob and cache it for this compile.
3212 void PhaseOutput::init_scratch_buffer_blob(int const_size) {
3213   // If there is already a scratch buffer blob allocated and the
3214   // constant section is big enough, use it.  Otherwise free the
3215   // current and allocate a new one.
3216   BufferBlob* blob = scratch_buffer_blob();
3217   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {
3218     // Use the current blob.
3219   } else {
3220     if (blob != NULL) {
3221       BufferBlob::free(blob);
3222     }
3223 
3224     ResourceMark rm;
3225     _scratch_const_size = const_size;
3226     int size = C2Compiler::initial_code_buffer_size(const_size);
<a name="15" id="anc15"></a><span class="line-added">3227 #ifdef ASSERT</span>
<span class="line-added">3228     if (C-&gt;has_scalarized_args()) {</span>
<span class="line-added">3229       // Oop verification for loading object fields from scalarized value types in the new entry point requires lots of space</span>
<span class="line-added">3230       size += 5120;</span>
<span class="line-added">3231     }</span>
<span class="line-added">3232 #endif</span>
3233     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);
3234     // Record the buffer blob for next time.
3235     set_scratch_buffer_blob(blob);
3236     // Have we run out of code space?
3237     if (scratch_buffer_blob() == NULL) {
3238       // Let CompilerBroker disable further compilations.
3239       C-&gt;record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);
3240       return;
3241     }
3242   }
3243 
3244   // Initialize the relocation buffers
3245   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;
3246   set_scratch_locs_memory(locs_buf);
3247 }
3248 
3249 
3250 //-----------------------scratch_emit_size-------------------------------------
3251 // Helper function that computes size by emitting code
3252 uint PhaseOutput::scratch_emit_size(const Node* n) {
3253   // Start scratch_emit_size section.
3254   set_in_scratch_emit_size(true);
3255 
3256   // Emit into a trash buffer and count bytes emitted.
3257   // This is a pretty expensive way to compute a size,
3258   // but it works well enough if seldom used.
3259   // All common fixed-size instructions are given a size
3260   // method by the AD file.
3261   // Note that the scratch buffer blob and locs memory are
3262   // allocated at the beginning of the compile task, and
3263   // may be shared by several calls to scratch_emit_size.
3264   // The allocation of the scratch buffer blob is particularly
3265   // expensive, since it has to grab the code cache lock.
3266   BufferBlob* blob = this-&gt;scratch_buffer_blob();
3267   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);
3268   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);
3269   relocInfo* locs_buf = scratch_locs_memory();
3270   address blob_begin = blob-&gt;content_begin();
3271   address blob_end   = (address)locs_buf;
3272   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);
3273   CodeBuffer buf(blob_begin, blob_end - blob_begin);
3274   buf.initialize_consts_size(_scratch_const_size);
3275   buf.initialize_stubs_size(MAX_stubs_size);
3276   assert(locs_buf != NULL, &quot;sanity&quot;);
3277   int lsize = MAX_locs_size / 3;
3278   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);
3279   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);
3280   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);
3281   // Mark as scratch buffer.
3282   buf.consts()-&gt;set_scratch_emit();
3283   buf.insts()-&gt;set_scratch_emit();
3284   buf.stubs()-&gt;set_scratch_emit();
3285 
3286   // Do the emission.
3287 
3288   Label fakeL; // Fake label for branch instructions.
3289   Label*   saveL = NULL;
3290   uint save_bnum = 0;
3291   bool is_branch = n-&gt;is_MachBranch();
3292   if (is_branch) {
3293     MacroAssembler masm(&amp;buf);
3294     masm.bind(fakeL);
3295     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);
3296     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);
<a name="16" id="anc16"></a><span class="line-added">3297   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-added">3298     saveL = ((MachPrologNode*)n)-&gt;_verified_entry;</span>
<span class="line-added">3299     ((MachPrologNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-added">3300   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-added">3301     saveL = ((MachVEPNode*)n)-&gt;_verified_entry;</span>
<span class="line-added">3302     ((MachVEPNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
3303   }
3304   n-&gt;emit(buf, C-&gt;regalloc());
3305 
3306   // Emitting into the scratch buffer should not fail
3307   assert (!C-&gt;failing(), &quot;Must not have pending failure. Reason is: %s&quot;, C-&gt;failure_reason());
3308 
<a name="17" id="anc17"></a><span class="line-modified">3309   // Restore label.</span>
<span class="line-added">3310   if (is_branch) {</span>
3311     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);
<a name="18" id="anc18"></a><span class="line-added">3312   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-added">3313     ((MachPrologNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-added">3314   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-added">3315     ((MachVEPNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-added">3316   }</span>
3317 
3318   // End scratch_emit_size section.
3319   set_in_scratch_emit_size(false);
3320 
3321   return buf.insts_size();
3322 }
3323 
3324 void PhaseOutput::install() {
3325   if (C-&gt;stub_function() != NULL) {
3326     install_stub(C-&gt;stub_name(),
3327                  C-&gt;save_argument_registers());
3328   } else {
3329     install_code(C-&gt;method(),
3330                  C-&gt;entry_bci(),
3331                  CompileBroker::compiler2(),
3332                  C-&gt;has_unsafe_access(),
3333                  SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),
3334                  C-&gt;rtm_state());
3335   }
3336 }
3337 
3338 void PhaseOutput::install_code(ciMethod*         target,
3339                                int               entry_bci,
3340                                AbstractCompiler* compiler,
3341                                bool              has_unsafe_access,
3342                                bool              has_wide_vectors,
3343                                RTMState          rtm_state) {
3344   // Check if we want to skip execution of all compiled code.
3345   {
3346 #ifndef PRODUCT
3347     if (OptoNoExecute) {
3348       C-&gt;record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed
3349       return;
3350     }
3351 #endif
3352     Compile::TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);
3353 
3354     if (C-&gt;is_osr_compilation()) {
3355       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);
3356       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);
3357     } else {
3358       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);
<a name="19" id="anc19"></a><span class="line-added">3359       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry) == -1) {</span>
<span class="line-added">3360         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, _first_block_size);</span>
<span class="line-added">3361       }</span>
<span class="line-added">3362       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry_RO) == -1) {</span>
<span class="line-added">3363         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, _first_block_size);</span>
<span class="line-added">3364       }</span>
<span class="line-added">3365       if (_code_offsets.value(CodeOffsets::Entry) == -1) {</span>
<span class="line-added">3366         _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);</span>
<span class="line-added">3367       }</span>
3368       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);
3369     }
3370 
3371     C-&gt;env()-&gt;register_method(target,
<a name="20" id="anc20"></a><span class="line-modified">3372                               entry_bci,</span>
<span class="line-modified">3373                               &amp;_code_offsets,</span>
<span class="line-modified">3374                               _orig_pc_slot_offset_in_bytes,</span>
<span class="line-modified">3375                               code_buffer(),</span>
<span class="line-modified">3376                               frame_size_in_words(),</span>
<span class="line-modified">3377                               _oop_map_set,</span>
<span class="line-modified">3378                               &amp;_handler_table,</span>
<span class="line-modified">3379                               &amp;_inc_table,</span>
<span class="line-modified">3380                               compiler,</span>
<span class="line-modified">3381                               has_unsafe_access,</span>
<span class="line-modified">3382                               SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-modified">3383                               C-&gt;rtm_state());</span>
3384 
3385     if (C-&gt;log() != NULL) { // Print code cache state into compiler log
3386       C-&gt;log()-&gt;code_cache_state();
3387     }
3388   }
3389 }
3390 void PhaseOutput::install_stub(const char* stub_name,
3391                                bool        caller_must_gc_arguments) {
3392   // Entry point will be accessed using stub_entry_point();
3393   if (code_buffer() == NULL) {
3394     Matcher::soft_match_failure();
3395   } else {
3396     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))
3397       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);
3398 
3399     if (!C-&gt;failing()) {
3400       assert(C-&gt;fixed_slots() == 0, &quot;no fixed slots used for runtime stubs&quot;);
3401 
3402       // Make the NMethod
3403       // For now we mark the frame as never safe for profile stackwalking
3404       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,
3405                                                       code_buffer(),
3406                                                       CodeOffsets::frame_never_safe,
3407                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),
3408                                                       frame_size_in_words(),
3409                                                       oop_map_set(),
3410                                                       caller_must_gc_arguments);
3411       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);
3412 
3413       C-&gt;set_stub_entry_point(rs-&gt;entry_point());
3414     }
3415   }
3416 }
3417 
3418 // Support for bundling info
3419 Bundle* PhaseOutput::node_bundling(const Node *n) {
3420   assert(valid_bundle_info(n), &quot;oob&quot;);
3421   return &amp;_node_bundling_base[n-&gt;_idx];
3422 }
3423 
3424 bool PhaseOutput::valid_bundle_info(const Node *n) {
3425   return (_node_bundling_limit &gt; n-&gt;_idx);
3426 }
3427 
3428 //------------------------------frame_size_in_words-----------------------------
3429 // frame_slots in units of words
3430 int PhaseOutput::frame_size_in_words() const {
3431   // shift is 0 in LP32 and 1 in LP64
3432   const int shift = (LogBytesPerWord - LogBytesPerInt);
3433   int words = _frame_slots &gt;&gt; shift;
3434   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );
3435   return words;
3436 }
3437 
3438 // To bang the stack of this compiled method we use the stack size
3439 // that the interpreter would need in case of a deoptimization. This
3440 // removes the need to bang the stack in the deoptimization blob which
3441 // in turn simplifies stack overflow handling.
3442 int PhaseOutput::bang_size_in_bytes() const {
3443   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C-&gt;interpreter_frame_size());
3444 }
3445 
3446 //------------------------------dump_asm---------------------------------------
3447 // Dump formatted assembly
3448 #if defined(SUPPORT_OPTO_ASSEMBLY)
3449 void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {
3450 
3451   int pc_digits = 3; // #chars required for pc
3452   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator
3453   int tab_size  = 8;
3454   if (pcs != NULL) {
3455     int max_pc = 0;
3456     for (uint i = 0; i &lt; pc_limit; i++) {
3457       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;
3458     }
3459     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc
3460   }
3461   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;
3462 
3463   bool cut_short = false;
3464   st-&gt;print_cr(&quot;#&quot;);
3465   st-&gt;print(&quot;#  &quot;);  C-&gt;tf()-&gt;dump_on(st);  st-&gt;cr();
3466   st-&gt;print_cr(&quot;#&quot;);
3467 
3468   // For all blocks
3469   int pc = 0x0;                 // Program counter
3470   char starts_bundle = &#39; &#39;;
3471   C-&gt;regalloc()-&gt;dump_frame();
3472 
3473   Node *n = NULL;
3474   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {
3475     if (VMThread::should_terminate()) {
3476       cut_short = true;
3477       break;
3478     }
3479     Block* block = C-&gt;cfg()-&gt;get_block(i);
3480     if (block-&gt;is_connector() &amp;&amp; !Verbose) {
3481       continue;
3482     }
3483     n = block-&gt;head();
3484     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3485       pc = pcs[n-&gt;_idx];
3486       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3487     }
3488     st-&gt;fill_to(prefix_len);
3489     block-&gt;dump_head(C-&gt;cfg(), st);
3490     if (block-&gt;is_connector()) {
3491       st-&gt;fill_to(prefix_len);
3492       st-&gt;print_cr(&quot;# Empty connector block&quot;);
3493     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {
3494       st-&gt;fill_to(prefix_len);
3495       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);
3496     }
3497 
3498     // For all instructions
3499     Node *delay = NULL;
3500     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
3501       if (VMThread::should_terminate()) {
3502         cut_short = true;
3503         break;
3504       }
3505       n = block-&gt;get_node(j);
3506       if (valid_bundle_info(n)) {
3507         Bundle* bundle = node_bundling(n);
3508         if (bundle-&gt;used_in_unconditional_delay()) {
3509           delay = n;
3510           continue;
3511         }
3512         if (bundle-&gt;starts_bundle()) {
3513           starts_bundle = &#39;+&#39;;
3514         }
3515       }
3516 
3517       if (WizardMode) {
3518         n-&gt;dump();
3519       }
3520 
3521       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly
3522           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes
3523           !n-&gt;is_Proj() &amp;&amp;
3524           !n-&gt;is_MachTemp() &amp;&amp;
3525           !n-&gt;is_SafePointScalarObject() &amp;&amp;
3526           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets
3527           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting
3528           !n-&gt;is_top() &amp;&amp;       // Debug info table constants
3529           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants
3530           ) {
3531         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3532           pc = pcs[n-&gt;_idx];
3533           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3534         } else {
3535           st-&gt;fill_to(pc_digits);
3536         }
3537         st-&gt;print(&quot; %c &quot;, starts_bundle);
3538         starts_bundle = &#39; &#39;;
3539         st-&gt;fill_to(prefix_len);
3540         n-&gt;format(C-&gt;regalloc(), st);
3541         st-&gt;cr();
3542       }
3543 
3544       // If we have an instruction with a delay slot, and have seen a delay,
3545       // then back up and print it
3546       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
3547         // Coverity finding - Explicit null dereferenced.
3548         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);
3549         if (WizardMode) delay-&gt;dump();
3550 
3551         if (node_bundling(delay)-&gt;starts_bundle())
3552           starts_bundle = &#39;+&#39;;
3553         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {
3554           pc = pcs[n-&gt;_idx];
3555           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);
3556         } else {
3557           st-&gt;fill_to(pc_digits);
3558         }
3559         st-&gt;print(&quot; %c &quot;, starts_bundle);
3560         starts_bundle = &#39; &#39;;
3561         st-&gt;fill_to(prefix_len);
3562         delay-&gt;format(C-&gt;regalloc(), st);
3563         st-&gt;cr();
3564         delay = NULL;
3565       }
3566 
3567       // Dump the exception table as well
3568       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {
3569         // Print the exception table for this offset
3570         _handler_table.print_subtable_for(pc);
3571       }
3572       st-&gt;bol(); // Make sure we start on a new line
3573     }
3574     st-&gt;cr(); // one empty line between blocks
3575     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);
3576   } // End of per-block dump
3577 
3578   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);
3579 }
3580 #endif
3581 
3582 #ifndef PRODUCT
3583 void PhaseOutput::print_statistics() {
3584   Scheduling::print_statistics();
3585 }
3586 #endif
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
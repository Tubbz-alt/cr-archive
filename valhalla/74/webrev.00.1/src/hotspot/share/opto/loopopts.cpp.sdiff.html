<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopopts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/loopnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/mulnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 #include &quot;opto/subtypenode.hpp&quot;

  44 #include &quot;utilities/macros.hpp&quot;
  45 
  46 //=============================================================================
  47 //------------------------------split_thru_phi---------------------------------
  48 // Split Node &#39;n&#39; through merge point if there is enough win.
  49 Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
  50   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  51     // ConvI2L may have type information on it which is unsafe to push up
  52     // so disable this for now
  53     return NULL;
  54   }
  55 
  56   // Splitting range check CastIIs through a loop induction Phi can
  57   // cause new Phis to be created that are left unrelated to the loop
  58   // induction Phi and prevent optimizations (vectorization)
  59   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  60       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  61     return NULL;
  62   }
  63 






  64   int wins = 0;
  65   assert(!n-&gt;is_CFG(), &quot;&quot;);
  66   assert(region-&gt;is_Region(), &quot;&quot;);
  67 
  68   const Type* type = n-&gt;bottom_type();
  69   const TypeOopPtr *t_oop = _igvn.type(n)-&gt;isa_oopptr();
  70   Node *phi;
  71   if (t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance_field()) {
  72     int iid    = t_oop-&gt;instance_id();
  73     int index  = C-&gt;get_alias_index(t_oop);
  74     int offset = t_oop-&gt;offset();
  75     phi = new PhiNode(region, type, NULL, iid, index, offset);
  76   } else {
  77     phi = PhiNode::make_blank(region, n);
  78   }
  79   uint old_unique = C-&gt;unique();
  80   for (uint i = 1; i &lt; region-&gt;req(); i++) {
  81     Node *x;
  82     Node* the_clone = NULL;
  83     if (region-&gt;in(i) == C-&gt;top()) {
</pre>
<hr />
<pre>
1186 
1187   return true;
1188 }
1189 
1190 // Detect if the node is the inner strip-mined loop
1191 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1192 static Node* is_inner_of_stripmined_loop(const Node* out) {
1193   Node* out_le = NULL;
1194 
1195   if (out-&gt;is_CountedLoopEnd()) {
1196       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1197 
1198       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1199         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1200       }
1201   }
1202 
1203   return out_le;
1204 }
1205 
































































































1206 //------------------------------split_if_with_blocks_post----------------------
1207 // Do the real work in a non-recursive function.  CFG hackery wants to be
1208 // in the post-order, so it can dirty the I-DOM info and not use the dirtied
1209 // info.
1210 void PhaseIdealLoop::split_if_with_blocks_post(Node *n) {
1211 




1212   // Cloning Cmp through Phi&#39;s involves the split-if transform.
1213   // FastLock is not used by an If
1214   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock()) {
1215     Node *n_ctrl = get_ctrl(n);
1216     // Determine if the Node has inputs from some local Phi.
1217     // Returns the block to clone thru.
1218     Node *n_blk = has_local_phi_input(n);
1219     if (n_blk != n_ctrl) {
1220       return;
1221     }
1222 
1223     if (!can_split_if(n_ctrl)) {
1224       return;
1225     }
1226 
1227     if (n-&gt;outcnt() != 1) {
1228       return; // Multiple bool&#39;s from 1 compare?
1229     }
1230     Node *bol = n-&gt;unique_out();
1231     assert(bol-&gt;is_Bool(), &quot;expect a bool here&quot;);
</pre>
<hr />
<pre>
1456 
1457             // Some institutional knowledge is needed here: &#39;x&#39; is
1458             // yanked because if the optimizer runs GVN on it all the
1459             // cloned x&#39;s will common up and undo this optimization and
1460             // be forced back in the loop.
1461             // I tried setting control edges on the x&#39;s to force them to
1462             // not combine, but the matching gets worried when it tries
1463             // to fold a StoreP and an AddP together (as part of an
1464             // address expression) and the AddP and StoreP have
1465             // different controls.
1466             if (!x-&gt;is_Load() &amp;&amp; !x-&gt;is_DecodeNarrowPtr()) _igvn._worklist.yank(x);
1467           }
1468           _igvn.remove_dead_node(n);
1469         }
1470       }
1471     }
1472   }
1473 
1474   try_move_store_after_loop(n);
1475 






1476   // Check for Opaque2&#39;s who&#39;s loop has disappeared - who&#39;s input is in the
1477   // same loop nest as their output.  Remove &#39;em, they are no longer useful.
1478   if( n_op == Op_Opaque2 &amp;&amp;
1479       n-&gt;in(1) != NULL &amp;&amp;
1480       get_loop(get_ctrl(n)) == get_loop(get_ctrl(n-&gt;in(1))) ) {
1481     _igvn.replace_node( n, n-&gt;in(1) );
1482   }
1483 }
1484 
1485 //------------------------------split_if_with_blocks---------------------------
1486 // Check for aggressive application of &#39;split-if&#39; optimization,
1487 // using basic block level info.
1488 void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack) {
1489   Node* root = C-&gt;root();
1490   visited.set(root-&gt;_idx); // first, mark root as visited
1491   // Do pre-visit work for root
1492   Node* n   = split_if_with_blocks_pre(root);
1493   uint  cnt = n-&gt;outcnt();
1494   uint  i   = 0;
1495 
</pre>
</td>
<td>
<hr />
<pre>
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/callnode.hpp&quot;
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/divnode.hpp&quot;
  36 #include &quot;opto/loopnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/mulnode.hpp&quot;
  39 #include &quot;opto/movenode.hpp&quot;
  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/subnode.hpp&quot;
  43 #include &quot;opto/subtypenode.hpp&quot;
<span class="line-added">  44 #include &quot;opto/valuetypenode.hpp&quot;</span>
  45 #include &quot;utilities/macros.hpp&quot;
  46 
  47 //=============================================================================
  48 //------------------------------split_thru_phi---------------------------------
  49 // Split Node &#39;n&#39; through merge point if there is enough win.
  50 Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {
  51   if (n-&gt;Opcode() == Op_ConvI2L &amp;&amp; n-&gt;bottom_type() != TypeLong::LONG) {
  52     // ConvI2L may have type information on it which is unsafe to push up
  53     // so disable this for now
  54     return NULL;
  55   }
  56 
  57   // Splitting range check CastIIs through a loop induction Phi can
  58   // cause new Phis to be created that are left unrelated to the loop
  59   // induction Phi and prevent optimizations (vectorization)
  60   if (n-&gt;Opcode() == Op_CastII &amp;&amp; n-&gt;as_CastII()-&gt;has_range_check() &amp;&amp;
  61       region-&gt;is_CountedLoop() &amp;&amp; n-&gt;in(1) == region-&gt;as_CountedLoop()-&gt;phi()) {
  62     return NULL;
  63   }
  64 
<span class="line-added">  65   // Value types should not be split through Phis because they cannot be merged</span>
<span class="line-added">  66   // through Phi nodes but each value input needs to be merged individually.</span>
<span class="line-added">  67   if (n-&gt;is_ValueType()) {</span>
<span class="line-added">  68     return NULL;</span>
<span class="line-added">  69   }</span>
<span class="line-added">  70 </span>
  71   int wins = 0;
  72   assert(!n-&gt;is_CFG(), &quot;&quot;);
  73   assert(region-&gt;is_Region(), &quot;&quot;);
  74 
  75   const Type* type = n-&gt;bottom_type();
  76   const TypeOopPtr *t_oop = _igvn.type(n)-&gt;isa_oopptr();
  77   Node *phi;
  78   if (t_oop != NULL &amp;&amp; t_oop-&gt;is_known_instance_field()) {
  79     int iid    = t_oop-&gt;instance_id();
  80     int index  = C-&gt;get_alias_index(t_oop);
  81     int offset = t_oop-&gt;offset();
  82     phi = new PhiNode(region, type, NULL, iid, index, offset);
  83   } else {
  84     phi = PhiNode::make_blank(region, n);
  85   }
  86   uint old_unique = C-&gt;unique();
  87   for (uint i = 1; i &lt; region-&gt;req(); i++) {
  88     Node *x;
  89     Node* the_clone = NULL;
  90     if (region-&gt;in(i) == C-&gt;top()) {
</pre>
<hr />
<pre>
1193 
1194   return true;
1195 }
1196 
1197 // Detect if the node is the inner strip-mined loop
1198 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1199 static Node* is_inner_of_stripmined_loop(const Node* out) {
1200   Node* out_le = NULL;
1201 
1202   if (out-&gt;is_CountedLoopEnd()) {
1203       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1204 
1205       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1206         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1207       }
1208   }
1209 
1210   return out_le;
1211 }
1212 
<span class="line-added">1213 bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {</span>
<span class="line-added">1214   // If the CmpP is a subtype check for a value that has just been</span>
<span class="line-added">1215   // loaded from an array, the subtype checks guarantees the value</span>
<span class="line-added">1216   // can&#39;t be stored in a flattened array and the load of the value</span>
<span class="line-added">1217   // happens with a flattened array check then: push the type check</span>
<span class="line-added">1218   // through the phi of the flattened array check. This needs special</span>
<span class="line-added">1219   // logic because the subtype check&#39;s input is not a phi but a</span>
<span class="line-added">1220   // LoadKlass that must first be cloned through the phi.</span>
<span class="line-added">1221   if (n-&gt;Opcode() != Op_CmpP) {</span>
<span class="line-added">1222     return false;</span>
<span class="line-added">1223   }</span>
<span class="line-added">1224 </span>
<span class="line-added">1225   Node* klassptr = n-&gt;in(1);</span>
<span class="line-added">1226   Node* klasscon = n-&gt;in(2);</span>
<span class="line-added">1227 </span>
<span class="line-added">1228   if (klassptr-&gt;is_DecodeNarrowPtr()) {</span>
<span class="line-added">1229     klassptr = klassptr-&gt;in(1);</span>
<span class="line-added">1230   }</span>
<span class="line-added">1231 </span>
<span class="line-added">1232   if (klassptr-&gt;Opcode() != Op_LoadKlass &amp;&amp; klassptr-&gt;Opcode() != Op_LoadNKlass) {</span>
<span class="line-added">1233     return false;</span>
<span class="line-added">1234   }</span>
<span class="line-added">1235 </span>
<span class="line-added">1236   if (!klasscon-&gt;is_Con()) {</span>
<span class="line-added">1237     return false;</span>
<span class="line-added">1238   }</span>
<span class="line-added">1239 </span>
<span class="line-added">1240   Node* addr = klassptr-&gt;in(MemNode::Address);</span>
<span class="line-added">1241 </span>
<span class="line-added">1242   if (!addr-&gt;is_AddP()) {</span>
<span class="line-added">1243     return false;</span>
<span class="line-added">1244   }</span>
<span class="line-added">1245 </span>
<span class="line-added">1246   intptr_t offset;</span>
<span class="line-added">1247   Node* obj = AddPNode::Ideal_base_and_offset(addr, &amp;_igvn, offset);</span>
<span class="line-added">1248 </span>
<span class="line-added">1249   if (obj == NULL) {</span>
<span class="line-added">1250     return false;</span>
<span class="line-added">1251   }</span>
<span class="line-added">1252 </span>
<span class="line-added">1253   assert(obj != NULL &amp;&amp; addr-&gt;in(AddPNode::Base) == addr-&gt;in(AddPNode::Address), &quot;malformed AddP?&quot;);</span>
<span class="line-added">1254   if (obj-&gt;Opcode() == Op_CastPP) {</span>
<span class="line-added">1255     obj = obj-&gt;in(1);</span>
<span class="line-added">1256   }</span>
<span class="line-added">1257 </span>
<span class="line-added">1258   if (!obj-&gt;is_Phi()) {</span>
<span class="line-added">1259     return false;</span>
<span class="line-added">1260   }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262   Node* region = obj-&gt;in(0);</span>
<span class="line-added">1263 </span>
<span class="line-added">1264   Node* phi = PhiNode::make_blank(region, n-&gt;in(1));</span>
<span class="line-added">1265   for (uint i = 1; i &lt; region-&gt;req(); i++) {</span>
<span class="line-added">1266     Node* in = obj-&gt;in(i);</span>
<span class="line-added">1267     Node* ctrl = get_ctrl(in);</span>
<span class="line-added">1268     if (addr-&gt;in(AddPNode::Base) != obj) {</span>
<span class="line-added">1269       Node* cast = addr-&gt;in(AddPNode::Base);</span>
<span class="line-added">1270       assert(cast-&gt;Opcode() == Op_CastPP &amp;&amp; cast-&gt;in(0) != NULL, &quot;inconsistent subgraph&quot;);</span>
<span class="line-added">1271       Node* cast_clone = cast-&gt;clone();</span>
<span class="line-added">1272       cast_clone-&gt;set_req(0, region-&gt;in(i));</span>
<span class="line-added">1273       cast_clone-&gt;set_req(1, in);</span>
<span class="line-added">1274       register_new_node(cast_clone, region-&gt;in(i));</span>
<span class="line-added">1275       _igvn.set_type(cast_clone, cast_clone-&gt;Value(&amp;_igvn));</span>
<span class="line-added">1276       in = cast_clone;</span>
<span class="line-added">1277     }</span>
<span class="line-added">1278     Node* addr_clone = addr-&gt;clone();</span>
<span class="line-added">1279     addr_clone-&gt;set_req(AddPNode::Base, in);</span>
<span class="line-added">1280     addr_clone-&gt;set_req(AddPNode::Address, in);</span>
<span class="line-added">1281     register_new_node(addr_clone, ctrl);</span>
<span class="line-added">1282     _igvn.set_type(addr_clone, addr_clone-&gt;Value(&amp;_igvn));</span>
<span class="line-added">1283     Node* klassptr_clone = klassptr-&gt;clone();</span>
<span class="line-added">1284     klassptr_clone-&gt;set_req(2, addr_clone);</span>
<span class="line-added">1285     register_new_node(klassptr_clone, ctrl);</span>
<span class="line-added">1286     _igvn.set_type(klassptr_clone, klassptr_clone-&gt;Value(&amp;_igvn));</span>
<span class="line-added">1287     if (klassptr != n-&gt;in(1)) {</span>
<span class="line-added">1288       Node* decode = n-&gt;in(1);</span>
<span class="line-added">1289       assert(decode-&gt;is_DecodeNarrowPtr(), &quot;inconcistent subgraph&quot;);</span>
<span class="line-added">1290       Node* decode_clone = decode-&gt;clone();</span>
<span class="line-added">1291       decode_clone-&gt;set_req(1, klassptr_clone);</span>
<span class="line-added">1292       register_new_node(decode_clone, ctrl);</span>
<span class="line-added">1293       _igvn.set_type(decode_clone, decode_clone-&gt;Value(&amp;_igvn));</span>
<span class="line-added">1294       klassptr_clone = decode_clone;</span>
<span class="line-added">1295     }</span>
<span class="line-added">1296     phi-&gt;set_req(i, klassptr_clone);</span>
<span class="line-added">1297   }</span>
<span class="line-added">1298   register_new_node(phi, region);</span>
<span class="line-added">1299   Node* orig = n-&gt;in(1);</span>
<span class="line-added">1300   _igvn.replace_input_of(n, 1, phi);</span>
<span class="line-added">1301   split_if_with_blocks_post(n);</span>
<span class="line-added">1302   if (n-&gt;outcnt() != 0) {</span>
<span class="line-added">1303     _igvn.replace_input_of(n, 1, orig);</span>
<span class="line-added">1304     _igvn.remove_dead_node(phi);</span>
<span class="line-added">1305   }</span>
<span class="line-added">1306   return true;</span>
<span class="line-added">1307 }</span>
<span class="line-added">1308 </span>
1309 //------------------------------split_if_with_blocks_post----------------------
1310 // Do the real work in a non-recursive function.  CFG hackery wants to be
1311 // in the post-order, so it can dirty the I-DOM info and not use the dirtied
1312 // info.
1313 void PhaseIdealLoop::split_if_with_blocks_post(Node *n) {
1314 
<span class="line-added">1315   if (flatten_array_element_type_check(n)) {</span>
<span class="line-added">1316     return;</span>
<span class="line-added">1317   }</span>
<span class="line-added">1318 </span>
1319   // Cloning Cmp through Phi&#39;s involves the split-if transform.
1320   // FastLock is not used by an If
1321   if (n-&gt;is_Cmp() &amp;&amp; !n-&gt;is_FastLock()) {
1322     Node *n_ctrl = get_ctrl(n);
1323     // Determine if the Node has inputs from some local Phi.
1324     // Returns the block to clone thru.
1325     Node *n_blk = has_local_phi_input(n);
1326     if (n_blk != n_ctrl) {
1327       return;
1328     }
1329 
1330     if (!can_split_if(n_ctrl)) {
1331       return;
1332     }
1333 
1334     if (n-&gt;outcnt() != 1) {
1335       return; // Multiple bool&#39;s from 1 compare?
1336     }
1337     Node *bol = n-&gt;unique_out();
1338     assert(bol-&gt;is_Bool(), &quot;expect a bool here&quot;);
</pre>
<hr />
<pre>
1563 
1564             // Some institutional knowledge is needed here: &#39;x&#39; is
1565             // yanked because if the optimizer runs GVN on it all the
1566             // cloned x&#39;s will common up and undo this optimization and
1567             // be forced back in the loop.
1568             // I tried setting control edges on the x&#39;s to force them to
1569             // not combine, but the matching gets worried when it tries
1570             // to fold a StoreP and an AddP together (as part of an
1571             // address expression) and the AddP and StoreP have
1572             // different controls.
1573             if (!x-&gt;is_Load() &amp;&amp; !x-&gt;is_DecodeNarrowPtr()) _igvn._worklist.yank(x);
1574           }
1575           _igvn.remove_dead_node(n);
1576         }
1577       }
1578     }
1579   }
1580 
1581   try_move_store_after_loop(n);
1582 
<span class="line-added">1583   // Remove multiple allocations of the same value type</span>
<span class="line-added">1584   if (n-&gt;is_ValueType()) {</span>
<span class="line-added">1585     n-&gt;as_ValueType()-&gt;remove_redundant_allocations(&amp;_igvn, this);</span>
<span class="line-added">1586     return; // n is now dead</span>
<span class="line-added">1587   }</span>
<span class="line-added">1588 </span>
1589   // Check for Opaque2&#39;s who&#39;s loop has disappeared - who&#39;s input is in the
1590   // same loop nest as their output.  Remove &#39;em, they are no longer useful.
1591   if( n_op == Op_Opaque2 &amp;&amp;
1592       n-&gt;in(1) != NULL &amp;&amp;
1593       get_loop(get_ctrl(n)) == get_loop(get_ctrl(n-&gt;in(1))) ) {
1594     _igvn.replace_node( n, n-&gt;in(1) );
1595   }
1596 }
1597 
1598 //------------------------------split_if_with_blocks---------------------------
1599 // Check for aggressive application of &#39;split-if&#39; optimization,
1600 // using basic block level info.
1601 void PhaseIdealLoop::split_if_with_blocks(VectorSet &amp;visited, Node_Stack &amp;nstack) {
1602   Node* root = C-&gt;root();
1603   visited.set(root-&gt;_idx); // first, mark root as visited
1604   // Do pre-visit work for root
1605   Node* n   = split_if_with_blocks_pre(root);
1606   uint  cnt = n-&gt;outcnt();
1607   uint  i   = 0;
1608 
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
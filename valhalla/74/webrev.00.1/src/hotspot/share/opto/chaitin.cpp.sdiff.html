<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/chaitin.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c2compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="generateOptoStub.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/chaitin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1647 
1648     } // End of for all instructions
1649 
1650   } // End of for all blocks
1651 }
1652 
1653 // Helper to stretch above; recursively discover the base Node for a
1654 // given derived Node.  Easy for AddP-related machine nodes, but needs
1655 // to be recursive for derived Phis.
1656 Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &amp;maxlrg ) {
1657   // See if already computed; if so return it
1658   if( derived_base_map[derived-&gt;_idx] )
1659     return derived_base_map[derived-&gt;_idx];
1660 
1661   // See if this happens to be a base.
1662   // NOTE: we use TypePtr instead of TypeOopPtr because we can have
1663   // pointers derived from NULL!  These are always along paths that
1664   // can&#39;t happen at run-time but the optimizer cannot deduce it so
1665   // we have to handle it gracefully.
1666   assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
<span class="line-modified">1667           derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);</span>
1668   const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1669   // If its an OOP with a non-zero offset, then it is derived.
<span class="line-modified">1670   if( tj == NULL || tj-&gt;_offset == 0 ) {</span>
1671     derived_base_map[derived-&gt;_idx] = derived;
1672     return derived;
1673   }
1674   // Derived is NULL+offset?  Base is NULL!
1675   if( derived-&gt;is_Con() ) {
1676     Node *base = _matcher.mach_null();
1677     assert(base != NULL, &quot;sanity&quot;);
1678     if (base-&gt;in(0) == NULL) {
1679       // Initialize it once and make it shared:
1680       // set control to _root and place it into Start block
1681       // (where top() node is placed).
1682       base-&gt;init_req(0, _cfg.get_root_node());
1683       Block *startb = _cfg.get_block_for_node(C-&gt;top());
1684       uint node_pos = startb-&gt;find_node(C-&gt;top());
1685       startb-&gt;insert_node(base, node_pos);
1686       _cfg.map_node_to_block(base, startb);
1687       assert(_lrg_map.live_range_id(base) == 0, &quot;should not have LRG yet&quot;);
1688 
1689       // The loadConP0 might have projection nodes depending on architecture
1690       // Add the projection nodes to the CFG
</pre>
<hr />
<pre>
1816         // Copies do not define a new value and so do not interfere.
1817         // Remove the copies source from the liveout set before interfering.
1818         uint idx = n-&gt;is_Copy();
1819         if (idx) {
1820           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1821         }
1822       }
1823 
1824       // Found a safepoint?
1825       JVMState *jvms = n-&gt;jvms();
1826       if (jvms &amp;&amp; !liveout.is_empty()) {
1827         // Now scan for a live derived pointer
1828         IndexSetIterator elements(&amp;liveout);
1829         uint neighbor;
1830         while ((neighbor = elements.next()) != 0) {
1831           // Find reaching DEF for base and derived values
1832           // This works because we are still in SSA during this call.
1833           Node *derived = lrgs(neighbor)._def;
1834           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1835           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
<span class="line-modified">1836                   derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;_offset == 0, &quot;sanity&quot;);</span>
1837           // If its an OOP with a non-zero offset, then it is derived.
<span class="line-modified">1838           if( tj &amp;&amp; tj-&gt;_offset != 0 &amp;&amp; tj-&gt;isa_oop_ptr() ) {</span>
1839             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1840             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1841             // Add reaching DEFs of derived pointer and base pointer as a
1842             // pair of inputs
1843             n-&gt;add_req(derived);
1844             n-&gt;add_req(base);
1845 
1846             // See if the base pointer is already live to this point.
1847             // Since I&#39;m working on the SSA form, live-ness amounts to
1848             // reaching def&#39;s.  So if I find the base&#39;s live range then
1849             // I know the base&#39;s def reaches here.
1850             if ((_lrg_map.live_range_id(base) &gt;= _lrg_map.max_lrg_id() || // (Brand new base (hence not live) or
1851                  !liveout.member(_lrg_map.live_range_id(base))) &amp;&amp; // not live) AND
1852                  (_lrg_map.live_range_id(base) &gt; 0) &amp;&amp; // not a constant
1853                  _cfg.get_block_for_node(base) != block) { // base not def&#39;d in blk)
1854               // Base pointer is not currently live.  Since I stretched
1855               // the base pointer to here and it crosses basic-block
1856               // boundaries, the global live info is now incorrect.
1857               // Recompute live.
1858               must_recompute_live = true;
</pre>
<hr />
<pre>
2108   return buf+strlen(buf);
2109 }
2110 
2111 void PhaseChaitin::dump_for_spill_split_recycle() const {
2112   if( WizardMode &amp;&amp; (PrintCompilation || PrintOpto) ) {
2113     // Display which live ranges need to be split and the allocator&#39;s state
2114     tty-&gt;print_cr(&quot;Graph-Coloring Iteration %d will split the following live ranges&quot;, _trip_cnt);
2115     for (uint bidx = 1; bidx &lt; _lrg_map.max_lrg_id(); bidx++) {
2116       if( lrgs(bidx).alive() &amp;&amp; lrgs(bidx).reg() &gt;= LRG::SPILL_REG ) {
2117         tty-&gt;print(&quot;L%d: &quot;, bidx);
2118         lrgs(bidx).dump();
2119       }
2120     }
2121     tty-&gt;cr();
2122     dump();
2123   }
2124 }
2125 
2126 void PhaseChaitin::dump_frame() const {
2127   const char *fp = OptoReg::regname(OptoReg::c_frame_pointer);
<span class="line-modified">2128   const TypeTuple *domain = C-&gt;tf()-&gt;domain();</span>
2129   const int        argcnt = domain-&gt;cnt() - TypeFunc::Parms;
2130 
2131   // Incoming arguments in registers dump
2132   for( int k = 0; k &lt; argcnt; k++ ) {
2133     OptoReg::Name parmreg = _matcher._parm_regs[k].first();
2134     if( OptoReg::is_reg(parmreg))  {
2135       const char *reg_name = OptoReg::regname(parmreg);
2136       tty-&gt;print(&quot;#r%3.3d %s&quot;, parmreg, reg_name);
2137       parmreg = _matcher._parm_regs[k].second();
2138       if( OptoReg::is_reg(parmreg))  {
2139         tty-&gt;print(&quot;:%s&quot;, OptoReg::regname(parmreg));
2140       }
2141       tty-&gt;print(&quot;   : parm %d: &quot;, k);
2142       domain-&gt;field_at(k + TypeFunc::Parms)-&gt;dump();
2143       tty-&gt;cr();
2144     }
2145   }
2146 
2147   // Check for un-owned padding above incoming args
2148   OptoReg::Name reg = _matcher._new_SP;
2149   if( reg &gt; _matcher._in_arg_limit ) {
2150     reg = OptoReg::add(reg, -1);
2151     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: pad0, owned by CALLER&quot;, reg, fp, reg2offset_unchecked(reg));
2152   }
2153 
2154   // Incoming argument area dump
2155   OptoReg::Name begin_in_arg = OptoReg::add(_matcher._old_SP,C-&gt;out_preserve_stack_slots());
2156   while( reg &gt; begin_in_arg ) {
2157     reg = OptoReg::add(reg, -1);
2158     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2159     int j;
2160     for( j = 0; j &lt; argcnt; j++) {
2161       if( _matcher._parm_regs[j].first() == reg ||
2162           _matcher._parm_regs[j].second() == reg ) {
2163         tty-&gt;print(&quot;parm %d: &quot;,j);
2164         domain-&gt;field_at(j + TypeFunc::Parms)-&gt;dump();





2165         tty-&gt;cr();
2166         break;
2167       }
2168     }
2169     if( j &gt;= argcnt )
2170       tty-&gt;print_cr(&quot;HOLE, owned by SELF&quot;);
2171   }
2172 
2173   // Old outgoing preserve area
2174   while( reg &gt; _matcher._old_SP ) {
2175     reg = OptoReg::add(reg, -1);
2176     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: old out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2177   }
2178 
2179   // Old SP
2180   tty-&gt;print_cr(&quot;# -- Old %s -- Framesize: %d --&quot;,fp,
2181     reg2offset_unchecked(OptoReg::add(_matcher._old_SP,-1)) - reg2offset_unchecked(_matcher._new_SP)+jintSize);
2182 
2183   // Preserve area dump
2184   int fixed_slots = C-&gt;fixed_slots();
</pre>
</td>
<td>
<hr />
<pre>
1647 
1648     } // End of for all instructions
1649 
1650   } // End of for all blocks
1651 }
1652 
1653 // Helper to stretch above; recursively discover the base Node for a
1654 // given derived Node.  Easy for AddP-related machine nodes, but needs
1655 // to be recursive for derived Phis.
1656 Node *PhaseChaitin::find_base_for_derived( Node **derived_base_map, Node *derived, uint &amp;maxlrg ) {
1657   // See if already computed; if so return it
1658   if( derived_base_map[derived-&gt;_idx] )
1659     return derived_base_map[derived-&gt;_idx];
1660 
1661   // See if this happens to be a base.
1662   // NOTE: we use TypePtr instead of TypeOopPtr because we can have
1663   // pointers derived from NULL!  These are always along paths that
1664   // can&#39;t happen at run-time but the optimizer cannot deduce it so
1665   // we have to handle it gracefully.
1666   assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
<span class="line-modified">1667          derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;offset() == 0, &quot;sanity&quot;);</span>
1668   const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1669   // If its an OOP with a non-zero offset, then it is derived.
<span class="line-modified">1670   if (tj == NULL || tj-&gt;offset() == 0) {</span>
1671     derived_base_map[derived-&gt;_idx] = derived;
1672     return derived;
1673   }
1674   // Derived is NULL+offset?  Base is NULL!
1675   if( derived-&gt;is_Con() ) {
1676     Node *base = _matcher.mach_null();
1677     assert(base != NULL, &quot;sanity&quot;);
1678     if (base-&gt;in(0) == NULL) {
1679       // Initialize it once and make it shared:
1680       // set control to _root and place it into Start block
1681       // (where top() node is placed).
1682       base-&gt;init_req(0, _cfg.get_root_node());
1683       Block *startb = _cfg.get_block_for_node(C-&gt;top());
1684       uint node_pos = startb-&gt;find_node(C-&gt;top());
1685       startb-&gt;insert_node(base, node_pos);
1686       _cfg.map_node_to_block(base, startb);
1687       assert(_lrg_map.live_range_id(base) == 0, &quot;should not have LRG yet&quot;);
1688 
1689       // The loadConP0 might have projection nodes depending on architecture
1690       // Add the projection nodes to the CFG
</pre>
<hr />
<pre>
1816         // Copies do not define a new value and so do not interfere.
1817         // Remove the copies source from the liveout set before interfering.
1818         uint idx = n-&gt;is_Copy();
1819         if (idx) {
1820           liveout.remove(_lrg_map.live_range_id(n-&gt;in(idx)));
1821         }
1822       }
1823 
1824       // Found a safepoint?
1825       JVMState *jvms = n-&gt;jvms();
1826       if (jvms &amp;&amp; !liveout.is_empty()) {
1827         // Now scan for a live derived pointer
1828         IndexSetIterator elements(&amp;liveout);
1829         uint neighbor;
1830         while ((neighbor = elements.next()) != 0) {
1831           // Find reaching DEF for base and derived values
1832           // This works because we are still in SSA during this call.
1833           Node *derived = lrgs(neighbor)._def;
1834           const TypePtr *tj = derived-&gt;bottom_type()-&gt;isa_ptr();
1835           assert(!derived-&gt;bottom_type()-&gt;isa_narrowoop() ||
<span class="line-modified">1836                  derived-&gt;bottom_type()-&gt;make_ptr()-&gt;is_ptr()-&gt;offset() == 0, &quot;sanity&quot;);</span>
1837           // If its an OOP with a non-zero offset, then it is derived.
<span class="line-modified">1838           if (tj &amp;&amp; tj-&gt;offset() != 0 &amp;&amp; tj-&gt;isa_oop_ptr()) {</span>
1839             Node *base = find_base_for_derived(derived_base_map, derived, maxlrg);
1840             assert(base-&gt;_idx &lt; _lrg_map.size(), &quot;&quot;);
1841             // Add reaching DEFs of derived pointer and base pointer as a
1842             // pair of inputs
1843             n-&gt;add_req(derived);
1844             n-&gt;add_req(base);
1845 
1846             // See if the base pointer is already live to this point.
1847             // Since I&#39;m working on the SSA form, live-ness amounts to
1848             // reaching def&#39;s.  So if I find the base&#39;s live range then
1849             // I know the base&#39;s def reaches here.
1850             if ((_lrg_map.live_range_id(base) &gt;= _lrg_map.max_lrg_id() || // (Brand new base (hence not live) or
1851                  !liveout.member(_lrg_map.live_range_id(base))) &amp;&amp; // not live) AND
1852                  (_lrg_map.live_range_id(base) &gt; 0) &amp;&amp; // not a constant
1853                  _cfg.get_block_for_node(base) != block) { // base not def&#39;d in blk)
1854               // Base pointer is not currently live.  Since I stretched
1855               // the base pointer to here and it crosses basic-block
1856               // boundaries, the global live info is now incorrect.
1857               // Recompute live.
1858               must_recompute_live = true;
</pre>
<hr />
<pre>
2108   return buf+strlen(buf);
2109 }
2110 
2111 void PhaseChaitin::dump_for_spill_split_recycle() const {
2112   if( WizardMode &amp;&amp; (PrintCompilation || PrintOpto) ) {
2113     // Display which live ranges need to be split and the allocator&#39;s state
2114     tty-&gt;print_cr(&quot;Graph-Coloring Iteration %d will split the following live ranges&quot;, _trip_cnt);
2115     for (uint bidx = 1; bidx &lt; _lrg_map.max_lrg_id(); bidx++) {
2116       if( lrgs(bidx).alive() &amp;&amp; lrgs(bidx).reg() &gt;= LRG::SPILL_REG ) {
2117         tty-&gt;print(&quot;L%d: &quot;, bidx);
2118         lrgs(bidx).dump();
2119       }
2120     }
2121     tty-&gt;cr();
2122     dump();
2123   }
2124 }
2125 
2126 void PhaseChaitin::dump_frame() const {
2127   const char *fp = OptoReg::regname(OptoReg::c_frame_pointer);
<span class="line-modified">2128   const TypeTuple *domain = C-&gt;tf()-&gt;domain_cc();</span>
2129   const int        argcnt = domain-&gt;cnt() - TypeFunc::Parms;
2130 
2131   // Incoming arguments in registers dump
2132   for( int k = 0; k &lt; argcnt; k++ ) {
2133     OptoReg::Name parmreg = _matcher._parm_regs[k].first();
2134     if( OptoReg::is_reg(parmreg))  {
2135       const char *reg_name = OptoReg::regname(parmreg);
2136       tty-&gt;print(&quot;#r%3.3d %s&quot;, parmreg, reg_name);
2137       parmreg = _matcher._parm_regs[k].second();
2138       if( OptoReg::is_reg(parmreg))  {
2139         tty-&gt;print(&quot;:%s&quot;, OptoReg::regname(parmreg));
2140       }
2141       tty-&gt;print(&quot;   : parm %d: &quot;, k);
2142       domain-&gt;field_at(k + TypeFunc::Parms)-&gt;dump();
2143       tty-&gt;cr();
2144     }
2145   }
2146 
2147   // Check for un-owned padding above incoming args
2148   OptoReg::Name reg = _matcher._new_SP;
2149   if( reg &gt; _matcher._in_arg_limit ) {
2150     reg = OptoReg::add(reg, -1);
2151     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: pad0, owned by CALLER&quot;, reg, fp, reg2offset_unchecked(reg));
2152   }
2153 
2154   // Incoming argument area dump
2155   OptoReg::Name begin_in_arg = OptoReg::add(_matcher._old_SP,C-&gt;out_preserve_stack_slots());
2156   while( reg &gt; begin_in_arg ) {
2157     reg = OptoReg::add(reg, -1);
2158     tty-&gt;print(&quot;#r%3.3d %s+%2d: &quot;,reg,fp,reg2offset_unchecked(reg));
2159     int j;
2160     for( j = 0; j &lt; argcnt; j++) {
2161       if( _matcher._parm_regs[j].first() == reg ||
2162           _matcher._parm_regs[j].second() == reg ) {
2163         tty-&gt;print(&quot;parm %d: &quot;,j);
2164         domain-&gt;field_at(j + TypeFunc::Parms)-&gt;dump();
<span class="line-added">2165         if (!C-&gt;FIRST_STACK_mask().Member(reg)) {</span>
<span class="line-added">2166           // Reserved entry in the argument stack area that is not used because</span>
<span class="line-added">2167           // it may hold the return address (see Matcher::init_first_stack_mask()).</span>
<span class="line-added">2168           tty-&gt;print(&quot; [RESERVED] &quot;);</span>
<span class="line-added">2169         }</span>
2170         tty-&gt;cr();
2171         break;
2172       }
2173     }
2174     if( j &gt;= argcnt )
2175       tty-&gt;print_cr(&quot;HOLE, owned by SELF&quot;);
2176   }
2177 
2178   // Old outgoing preserve area
2179   while( reg &gt; _matcher._old_SP ) {
2180     reg = OptoReg::add(reg, -1);
2181     tty-&gt;print_cr(&quot;#r%3.3d %s+%2d: old out preserve&quot;,reg,fp,reg2offset_unchecked(reg));
2182   }
2183 
2184   // Old SP
2185   tty-&gt;print_cr(&quot;# -- Old %s -- Framesize: %d --&quot;,fp,
2186     reg2offset_unchecked(OptoReg::add(_matcher._old_SP,-1)) - reg2offset_unchecked(_matcher._new_SP)+jintSize);
2187 
2188   // Preserve area dump
2189   int fixed_slots = C-&gt;fixed_slots();
</pre>
</td>
</tr>
</table>
<center><a href="c2compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="generateOptoStub.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
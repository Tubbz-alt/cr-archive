diff a/src/hotspot/share/prims/jni.cpp b/src/hotspot/share/prims/jni.cpp
--- a/src/hotspot/share/prims/jni.cpp
+++ b/src/hotspot/share/prims/jni.cpp
@@ -57,10 +57,12 @@
 #include "oops/objArrayOop.inline.hpp"
 #include "oops/oop.inline.hpp"
 #include "oops/symbol.hpp"
 #include "oops/typeArrayKlass.hpp"
 #include "oops/typeArrayOop.inline.hpp"
+#include "oops/valueArrayOop.inline.hpp"
+#include "oops/valueKlass.inline.hpp"
 #include "prims/jniCheck.hpp"
 #include "prims/jniExport.hpp"
 #include "prims/jniFastGetField.hpp"
 #include "prims/jvm_misc.hpp"
 #include "prims/jvmtiExport.hpp"
@@ -474,12 +476,13 @@
 
   // The slot is the index of the field description in the field-array
   // The jfieldID is the offset of the field within the object
   // It may also have hash bits for k, if VerifyJNIFields is turned on.
   intptr_t offset = InstanceKlass::cast(k1)->field_offset( slot );
+  bool is_flattened = InstanceKlass::cast(k1)->field_is_flattened(slot);
   assert(InstanceKlass::cast(k1)->contains_field_offset(offset), "stay within object");
-  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
+  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);
   return ret;
 JNI_END
 
 
 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
@@ -494,11 +497,11 @@
   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&)ret);
 
   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
   assert(m->is_static() == (isStatic != 0), "jni_ToReflectedMethod access flags doesn't match");
   oop reflection_method;
-  if (m->is_initializer()) {
+  if (m->is_object_constructor()) {
     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
   } else {
     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
   }
   ret = JNIHandles::make_local(env, reflection_method);
@@ -556,11 +559,10 @@
   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
   assert(sub_klass != NULL && super_klass != NULL, "invalid arguments to jni_IsAssignableFrom");
   jboolean ret = sub_klass->is_subtype_of(super_klass) ?
                    JNI_TRUE : JNI_FALSE;
-
   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
   return ret;
 JNI_END
 
 
@@ -891,11 +893,12 @@
     // float is coerced to double w/ va_arg
     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 
     case T_ARRAY:
-    case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;
+    case T_OBJECT:
+    case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;
     default:            ShouldNotReachHere();
     }
   }
 
  public:
@@ -927,11 +930,12 @@
     case T_BOOLEAN:     push_boolean((_ap++)->z); break;
     case T_LONG:        push_long((_ap++)->j); break;
     case T_FLOAT:       push_float((_ap++)->f); break;
     case T_DOUBLE:      push_double((_ap++)->d); break;
     case T_ARRAY:
-    case T_OBJECT:      push_object((_ap++)->l); break;
+    case T_OBJECT:
+    case T_VALUETYPE:   push_object((_ap++)->l); break;
     default:            ShouldNotReachHere();
     }
   }
 
  public:
@@ -1067,17 +1071,31 @@
   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
 
   jobject obj = NULL;
   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
 
-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
-  obj = JNIHandles::make_local(env, i);
-  JavaValue jvalue(T_VOID);
-  JNI_ArgumentPusherArray ap(methodID, args);
-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
+  oop clazzoop = JNIHandles::resolve_non_null(clazz);
+  Klass* k = java_lang_Class::as_Klass(clazzoop);
+  if (k == NULL) {
+    ResourceMark rm(THREAD);
+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
+  }
+
+  if (!k->is_value()) {
+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
+    obj = JNIHandles::make_local(env, i);
+    JavaValue jvalue(T_VOID);
+    JNI_ArgumentPusherArray ap(methodID, args);
+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
+  } else {
+    JavaValue jvalue(T_VALUETYPE);
+    JNI_ArgumentPusherArray ap(methodID, args);
+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);
+    obj = jvalue.get_jobject();
+  }
   return obj;
-JNI_END
+  JNI_END
 
 
 DT_RETURN_MARK_DECL(NewObjectV, jobject
                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
 
@@ -1087,15 +1105,29 @@
   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
 
   jobject obj = NULL;
   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&)obj);
 
-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
-  obj = JNIHandles::make_local(env, i);
-  JavaValue jvalue(T_VOID);
-  JNI_ArgumentPusherVaArg ap(methodID, args);
-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
+  oop clazzoop = JNIHandles::resolve_non_null(clazz);
+  Klass* k = java_lang_Class::as_Klass(clazzoop);
+  if (k == NULL) {
+    ResourceMark rm(THREAD);
+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
+  }
+
+  if (!k->is_value()) {
+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
+    obj = JNIHandles::make_local(env, i);
+    JavaValue jvalue(T_VOID);
+    JNI_ArgumentPusherVaArg ap(methodID, args);
+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
+  } else {
+    JavaValue jvalue(T_VALUETYPE);
+    JNI_ArgumentPusherVaArg ap(methodID, args);
+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);
+    obj = jvalue.get_jobject();
+  }
   return obj;
 JNI_END
 
 
 DT_RETURN_MARK_DECL(NewObject, jobject
@@ -1107,18 +1139,35 @@
   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
 
   jobject obj = NULL;
   DT_RETURN_MARK(NewObject, jobject, (const jobject&)obj);
 
-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
-  obj = JNIHandles::make_local(env, i);
-  va_list args;
-  va_start(args, methodID);
-  JavaValue jvalue(T_VOID);
-  JNI_ArgumentPusherVaArg ap(methodID, args);
-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
-  va_end(args);
+  oop clazzoop = JNIHandles::resolve_non_null(clazz);
+  Klass* k = java_lang_Class::as_Klass(clazzoop);
+  if (k == NULL) {
+    ResourceMark rm(THREAD);
+    THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
+  }
+
+  if (!k->is_value()) {
+    instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
+    obj = JNIHandles::make_local(env, i);
+    va_list args;
+    va_start(args, methodID);
+    JavaValue jvalue(T_VOID);
+    JNI_ArgumentPusherVaArg ap(methodID, args);
+    jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_NULL);
+    va_end(args);
+  } else {
+    va_list args;
+    va_start(args, methodID);
+    JavaValue jvalue(T_VALUETYPE);
+    JNI_ArgumentPusherVaArg ap(methodID, args);
+    jni_invoke_static(env, &jvalue, NULL, JNI_STATIC, methodID, &ap, CHECK_NULL);
+    va_end(args);
+    obj = jvalue.get_jobject();
+  }
   return obj;
 JNI_END
 
 
 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
@@ -1891,28 +1940,39 @@
     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg("%s.%s %s", k->external_name(), name, sig));
   }
 
   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
   // It may also have hash bits for k, if VerifyJNIFields is turned on.
-  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
+  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());
   return ret;
 JNI_END
 
 
 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
   JNIWrapper("GetObjectField");
   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
   oop o = JNIHandles::resolve_non_null(obj);
   Klass* k = o->klass();
   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
+  oop res = NULL;
   // Keep JVMTI addition small and only check enabled flag here.
   // jni_GetField_probe() assumes that is okay to create handles.
   if (JvmtiExport::should_post_field_access()) {
     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
   }
-  oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);
-  jobject ret = JNIHandles::make_local(env, loaded_obj);
+  if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
+    res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);
+  } else {
+    assert(k->is_instance_klass(), "Only instance can have flattened fields");
+    InstanceKlass* ik = InstanceKlass::cast(k);
+    fieldDescriptor fd;
+    ik->find_field_from_offset(offset, false, &fd);  // performance bottleneck
+    InstanceKlass* holder = fd.field_holder();
+    ValueKlass* field_vklass = ValueKlass::cast(holder->get_value_field_klass(fd.index()));
+    res = field_vklass->read_flattened_field(o, ik->field_offset(fd.index()), CHECK_NULL);
+  }
+  jobject ret = JNIHandles::make_local(env, res);
   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
   return ret;
 JNI_END
 
 
@@ -2006,11 +2066,22 @@
   if (JvmtiExport::should_post_field_modification()) {
     jvalue field_value;
     field_value.l = value;
     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&field_value);
   }
-  HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));
+  if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));
+  } else {
+    assert(k->is_instance_klass(), "Only instances can have flattened fields");
+    InstanceKlass* ik = InstanceKlass::cast(k);
+    fieldDescriptor fd;
+    ik->find_field_from_offset(offset, false, &fd);
+    InstanceKlass* holder = fd.field_holder();
+    ValueKlass* vklass = ValueKlass::cast(holder->get_value_field_klass(fd.index()));
+    oop v = JNIHandles::resolve_non_null(value);
+    vklass->write_flattened_field(o, offset, v, CHECK);
+  }
   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
 JNI_END
 
 
 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
@@ -2443,54 +2514,93 @@
 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
   JNIWrapper("GetObjectArrayElement");
  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
   jobject ret = NULL;
   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&)ret);
-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
-  if (a->is_within_bounds(index)) {
-    ret = JNIHandles::make_local(env, a->obj_at(index));
-    return ret;
+  oop res = NULL;
+  arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
+  if (arr->is_within_bounds(index)) {
+    if (arr->is_valueArray()) {
+      valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
+      arrayHandle ah(THREAD, a);
+      valueArrayHandle vah(thread, a);
+      res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
+      assert(res != NULL, "Must be set in one of two paths above");
+    } else {
+      assert(arr->is_objArray(), "If not a valueArray. must be an objArray");
+      objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
+      res = a->obj_at(index);
+    }
   } else {
     ResourceMark rm(THREAD);
     stringStream ss;
-    ss.print("Index %d out of bounds for length %d", index, a->length());
+    ss.print("Index %d out of bounds for length %d", index,arr->length());
     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
   }
+  ret = JNIHandles::make_local(env, res);
+  return ret;
 JNI_END
 
 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
 
 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
   JNIWrapper("SetObjectArrayElement");
- HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
+  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
   DT_VOID_RETURN_MARK(SetObjectArrayElement);
 
-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
-  oop v = JNIHandles::resolve(value);
-  if (a->is_within_bounds(index)) {
-    if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {
-      a->obj_at_put(index, v);
-    } else {
-      ResourceMark rm(THREAD);
-      stringStream ss;
-      Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();
-      ss.print("type mismatch: can not store %s to %s[%d]",
-               v->klass()->external_name(),
-               bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),
-               index);
-      for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
-        ss.print("[]");
-      }
-      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
-    }
-  } else {
-    ResourceMark rm(THREAD);
-    stringStream ss;
-    ss.print("Index %d out of bounds for length %d", index, a->length());
-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
-  }
+   bool oob = false;
+   int length = -1;
+   oop res = NULL;
+   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
+   if (arr->is_within_bounds(index)) {
+     if (arr->is_valueArray()) {
+       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
+       oop v = JNIHandles::resolve(value);
+       ValueArrayKlass* vaklass = ValueArrayKlass::cast(a->klass());
+       ValueKlass* element_vklass = vaklass->element_klass();
+       if (v != NULL && v->is_a(element_vklass)) {
+         a->value_copy_to_index(v, index);
+       } else {
+         ResourceMark rm(THREAD);
+         stringStream ss;
+         Klass *kl = ValueArrayKlass::cast(a->klass());
+         ss.print("type mismatch: can not store %s to %s[%d]",
+             v->klass()->external_name(),
+             kl->external_name(),
+             index);
+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
+           ss.print("[]");
+         }
+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
+       }
+     } else {
+       assert(arr->is_objArray(), "If not a valueArray. must be an objArray");
+       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
+       oop v = JNIHandles::resolve(value);
+       if (v == NULL || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {
+         a->obj_at_put(index, v);
+       } else {
+         ResourceMark rm(THREAD);
+         stringStream ss;
+         Klass *bottom_kl = ObjArrayKlass::cast(a->klass())->bottom_klass();
+         ss.print("type mismatch: can not store %s to %s[%d]",
+             v->klass()->external_name(),
+             bottom_kl->is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)->element_type()] : bottom_kl->external_name(),
+                 index);
+         for (int dims = ArrayKlass::cast(a->klass())->dimension(); dims > 1; --dims) {
+           ss.print("[]");
+         }
+         THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
+       }
+     }
+   } else {
+     ResourceMark rm(THREAD);
+     stringStream ss;
+     ss.print("Index %d out of bounds for length %d", index, arr->length());
+     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
+   }
 JNI_END
 
 
 
 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
@@ -3273,10 +3383,285 @@
   JNIWrapper("GetModule");
   return Modules::get_module(clazz, THREAD);
 JNI_END
 
 
+JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
+  JNIWrapper("jni_GetFlattenedArrayElements");
+  if (isCopy != NULL) {
+    *isCopy = JNI_FALSE;
+  }
+  arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
+  if (!ar->is_array()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
+  }
+  if (!ar->is_valueArray()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
+  }
+  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  if (vak->contains_oops()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Flattened array contains oops");
+  }
+  oop a = lock_gc_or_pin_object(thread, array);
+  valueArrayOop vap = valueArrayOop(a);
+  void* ret = vap->value_at_addr(0, vak->layout_helper());
+  return ret;
+JNI_END
+
+JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
+  JNIWrapper("jni_ReleaseFlattenedArrayElements");
+  unlock_gc_or_unpin_object(thread, array);
+JNI_END
+
+JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
+  JNIWrapper("jni_GetFlattenedElementSize");
+  arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
+  if (!a->is_array()) {
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
+  }
+  if (!a->is_valueArray()) {
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
+  }
+  ValueArrayKlass* vak = ValueArrayKlass::cast(a->klass());
+  jsize ret = vak->element_byte_size();
+  return ret;
+}
+JNI_END
+
+JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
+  JNIWrapper("jni_GetArrayElementClass");
+  arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
+  if (!a->is_array()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
+  }
+  if (!a->is_valueArray()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
+  }
+  ValueArrayKlass* vak = ValueArrayKlass::cast(a->klass());
+  ValueKlass* vk = vak->element_klass();
+  return (jclass) JNIHandles::make_local(vk->java_mirror());
+JNI_END
+
+JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
+  JNIWrapper("jni_GetFieldOffsetInFlattenedLayout");
+
+  oop mirror = JNIHandles::resolve_non_null(clazz);
+  Klass* k = java_lang_Class::as_Klass(mirror);
+  if (!k->is_value()) {
+    ResourceMark rm;
+        THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("%s has not flattened layout", k->external_name()));
+  }
+  ValueKlass* vk = ValueKlass::cast(k);
+
+  TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
+  TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
+  if (fieldname == NULL || signame == NULL) {
+    ResourceMark rm;
+    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg("%s.%s %s", vk->external_name(), name, signature));
+  }
+
+  assert(vk->is_initialized(), "If a flattened array has been created, the element klass must have been initialized");
+
+  fieldDescriptor fd;
+  if (!vk->is_instance_klass() ||
+      !InstanceKlass::cast(vk)->find_field(fieldname, signame, false, &fd)) {
+    ResourceMark rm;
+    THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg("%s.%s %s", vk->external_name(), name, signature));
+  }
+
+  int offset = fd.offset() - vk->first_field_offset();
+  if (isFlattened != NULL) {
+    *isFlattened = fd.is_flattened();
+  }
+  return (jsize)offset;
+JNI_END
+
+JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
+  JNIWrapper("jni_CreateSubElementSelector");
+
+  arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
+  if (!ar->is_array()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not an array");
+  }
+  if (!ar->is_valueArray()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a flattened array");
+  }
+  Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
+        Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
+  InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
+  ses_ik->initialize(CHECK_NULL);
+  Klass* elementKlass = ArrayKlass::cast(ar->klass())->element_klass();
+  oop ses = ses_ik->allocate_instance(CHECK_NULL);
+  Handle ses_h(THREAD, ses);
+  jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass->java_mirror());
+  jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass->java_mirror());
+  jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
+  jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened
+  jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable
+  return JNIHandles::make_local(ses_h());
+JNI_END
+
+JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
+  JNIWrapper("jni_GetSubElementSelector");
+
+  oop slct = JNIHandles::resolve_non_null(selector);
+  if (slct->klass()->name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Not a SubElementSelector");
+  }
+  jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);
+  if (!isflattened) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "SubElement is not flattened");
+  }
+  oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
+  Klass* k = java_lang_Class::as_Klass(semirror);
+  if (!k->is_value()) {
+    ResourceMark rm;
+        THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg("%s is not an inline type", k->external_name()));
+  }
+  ValueKlass* vk = ValueKlass::cast(k);
+  assert(vk->is_initialized(), "If a flattened array has been created, the element klass must have been initialized");
+  int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);
+  fieldDescriptor fd;
+  if (!vk->find_field_from_offset(field_offset, false, &fd)) {
+    THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());
+  }
+  Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));
+  // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element
+  int offset = fd.offset() - vk->first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
+  InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)->klass());
+  oop res = sesklass->allocate_instance(CHECK_NULL);
+  Handle res_h(THREAD, res);
+  jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
+  InstanceKlass* holder = fd.field_holder();
+  BasicType bt = Signature::basic_type(fd.signature());
+  if (is_java_primitive(bt)) {
+    jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
+  } else {
+    Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder->class_loader()),
+        Handle(THREAD, holder->protection_domain()), true, CHECK_NULL);
+    jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass->java_mirror());
+  }
+  jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
+  jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());
+  jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());
+  return JNIHandles::make_local(res_h());
+JNI_END
+
+JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
+  JNIWrapper("jni_GetObjectSubElement");
+
+  valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+  oop slct = JNIHandles::resolve_non_null(selector);
+  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) {
+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch");
+  }
+  oop res = NULL;
+  if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
+    int offset = (address)ar->base() - cast_from_oop<address>(ar) + index * vak->element_byte_size()
+                      + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
+    res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(ar, offset);
+  } else {
+    ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
+    res = fieldKlass->allocate_instance(CHECK_NULL);
+    // The array might have been moved by the GC, refreshing the arrayOop
+    ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+    address addr = (address)ar->value_at_addr(index, vak->layout_helper())
+              + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
+    fieldKlass->value_copy_payload_to_new_oop(addr, res);
+  }
+  return JNIHandles::make_local(res);
+JNI_END
+
+JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
+  JNIWrapper("jni_SetObjectSubElement");
+
+  valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
+  oop slct = JNIHandles::resolve_non_null(selector);
+  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass());
+  if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) {
+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch");
+  }
+  oop val = JNIHandles::resolve(value);
+  if (val == NULL) {
+    if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {
+      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), "null cannot be stored in a flattened array");
+    }
+  } else {
+    if (!val->is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
+      THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), "type mismatch");
+    }
+  }
+  if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
+    int offset = (address)ar->base() - cast_from_oop<address>(ar) + index * vak->element_byte_size()
+                  + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(ar, offset, JNIHandles::resolve(value));
+  } else {
+    ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
+    address addr = (address)ar->value_at_addr(index, vak->layout_helper())
+                  + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
+    fieldKlass->value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
+  }
+JNI_END
+
+#define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
+\
+JNI_ENTRY(ElementType, \
+          jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
+  JNIWrapper("Get" XSTR(Result) "SubElement"); \
+  valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
+  oop slct = JNIHandles::resolve_non_null(selector); \
+  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass()); \
+  if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) { \
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch"); \
+  } \
+  if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Wrong SubElement type"); \
+  } \
+  address addr = (address)ar->value_at_addr(index, vak->layout_helper()) \
+               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
+  ElementType result = *(ElementType*)addr; \
+  return result; \
+JNI_END
+
+DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
+DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
+DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
+DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
+DEFINE_GETSUBELEMENT(jint, Int,T_INT)
+DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
+DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
+DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
+
+#define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
+\
+JNI_ENTRY(void, \
+          jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
+  JNIWrapper("Get" XSTR(Result) "SubElement"); \
+  valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
+  oop slct = JNIHandles::resolve_non_null(selector); \
+  ValueArrayKlass* vak = ValueArrayKlass::cast(ar->klass()); \
+  if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak->element_klass()->java_mirror()) { \
+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Array/Selector mismatch"); \
+  } \
+  if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), "Wrong SubElement type"); \
+  } \
+  address addr = (address)ar->value_at_addr(index, vak->layout_helper()) \
+               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
+  *(ElementType*)addr = value; \
+JNI_END
+
+DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
+DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
+DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
+DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
+DEFINE_SETSUBELEMENT(jint, Int,T_INT)
+DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
+DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
+DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
+
 // Structure containing all jni functions
 struct JNINativeInterface_ jni_NativeInterface = {
     NULL,
     NULL,
     NULL,
@@ -3556,11 +3941,42 @@
 
     jni_GetObjectRefType,
 
     // Module features
 
-    jni_GetModule
+    jni_GetModule,
+
+    // Flattened arrays features
+
+    jni_GetFlattenedArrayElements,
+    jni_ReleaseFlattenedArrayElements,
+    jni_GetFlattenedArrayElementClass,
+    jni_GetFlattenedArrayElementSize,
+    jni_GetFieldOffsetInFlattenedLayout,
+
+    jni_CreateSubElementSelector,
+    jni_GetSubElementSelector,
+    jni_GetObjectSubElement,
+    jni_SetObjectSubElement,
+
+    jni_GetBooleanSubElement,
+    jni_GetByteSubElement,
+    jni_GetShortSubElement,
+    jni_GetCharSubElement,
+    jni_GetIntSubElement,
+    jni_GetLongSubElement,
+    jni_GetFloatSubElement,
+    jni_GetDoubleSubElement,
+
+    jni_SetBooleanSubElement,
+    jni_SetByteSubElement,
+    jni_SetShortSubElement,
+    jni_SetCharSubElement,
+    jni_SetIntSubElement,
+    jni_SetLongSubElement,
+    jni_SetFloatSubElement,
+    jni_SetDoubleSubElement
 };
 
 
 // For jvmti use to modify jni function table.
 // Java threads in native contiues to run until it is transitioned

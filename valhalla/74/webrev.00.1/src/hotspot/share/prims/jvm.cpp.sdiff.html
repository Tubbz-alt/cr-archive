<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniCheck.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;

  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 688   JVMWrapper(&quot;JVM_Clone&quot;);
 689   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 690   Klass* klass = obj-&gt;klass();
 691   JvmtiVMObjectAllocEventCollector oam;
 692 
 693 #ifdef ASSERT
 694   // Just checking that the cloneable flag is set correct
 695   if (obj-&gt;is_array()) {
 696     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 697   } else {
 698     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 699     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 700     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 701   }
 702 #endif
 703 
 704   // Check if class of obj supports the Cloneable interface.
 705   // All arrays are considered to be cloneable (See JLS 20.1.5).
 706   // All j.l.r.Reference classes are considered non-cloneable.
 707   if (!klass-&gt;is_cloneable() ||

 708       (klass-&gt;is_instance_klass() &amp;&amp;
 709        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 710     ResourceMark rm(THREAD);
 711     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 712   }
 713 
 714   // Make shallow object copy
 715   const int size = obj-&gt;size();
 716   oop new_obj_oop = NULL;
 717   if (obj-&gt;is_array()) {
 718     const int length = ((arrayOop)obj())-&gt;length();
 719     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 720                                                    /* do_zero */ true, CHECK_NULL);
 721   } else {
 722     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 723   }
 724 
 725   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 726 
 727   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1231   return (jstring) JNIHandles::make_local(env, result);
1232 JVM_END
1233 
1234 
1235 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1236   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1237   JvmtiVMObjectAllocEventCollector oam;
1238   oop mirror = JNIHandles::resolve_non_null(cls);
1239 
1240   // Special handling for primitive objects
1241   if (java_lang_Class::is_primitive(mirror)) {
1242     // Primitive objects does not have any interfaces
1243     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1244     return (jobjectArray) JNIHandles::make_local(env, r);
1245   }
1246 
1247   Klass* klass = java_lang_Class::as_Klass(mirror);
1248   // Figure size of result array
1249   int size;
1250   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1251     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();</span>




1252   } else {
1253     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1254     size = 2;</span>
1255   }
1256 
1257   // Allocate result array
1258   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1259   objArrayHandle result (THREAD, r);
1260   // Fill in result
1261   if (klass-&gt;is_instance_klass()) {
1262     // Regular instance klass, fill in all local interfaces

1263     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1264       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-modified">1265       result-&gt;obj_at_put(index, k-&gt;java_mirror());</span>



1266     }
1267   } else {
<span class="line-modified">1268     // All arrays implement java.lang.Cloneable and java.io.Serializable</span>
1269     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1270     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());

1271   }
1272   return (jobjectArray) JNIHandles::make_local(env, result());
1273 JVM_END
1274 
1275 
1276 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1277   JVMWrapper(&quot;JVM_IsInterface&quot;);
1278   oop mirror = JNIHandles::resolve_non_null(cls);
1279   if (java_lang_Class::is_primitive(mirror)) {
1280     return JNI_FALSE;
1281   }
1282   Klass* k = java_lang_Class::as_Klass(mirror);
1283   jboolean result = k-&gt;is_interface();
1284   assert(!result || k-&gt;is_instance_klass(),
1285          &quot;all interfaces are instance types&quot;);
1286   // The compiler intrinsic for isInterface tests the
1287   // Klass::_access_flags bits in the same way.
1288   return result;
1289 JVM_END
1290 
</pre>
<hr />
<pre>
1870         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1871       objArrayHandle components_h (THREAD, record_components);
1872 
1873       for (int x = 0; x &lt; length; x++) {
1874         RecordComponent* component = components-&gt;at(x);
1875         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1876         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1877         components_h-&gt;obj_at_put(x, component_oop);
1878       }
1879       return (jobjectArray)JNIHandles::make_local(components_h());
1880     }
1881   }
1882 
1883   // Return empty array if ofClass is not a record.
1884   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1885   return (jobjectArray)JNIHandles::make_local(env, result);
1886 }
1887 JVM_END
1888 
1889 static bool select_method(const methodHandle&amp; method, bool want_constructor) {


1890   if (want_constructor) {
<span class="line-modified">1891     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());</span>
1892   } else {
<span class="line-modified">1893     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());</span>


1894   }
1895 }
1896 
1897 static jobjectArray get_class_declared_methods_helper(
1898                                   JNIEnv *env,
1899                                   jclass ofClass, jboolean publicOnly,
1900                                   bool want_constructor,
1901                                   Klass* klass, TRAPS) {
1902 
1903   JvmtiVMObjectAllocEventCollector oam;
1904 
1905   // Exclude primitive types and array types
1906   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1907       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1908     // Return empty array
1909     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1910     return (jobjectArray) JNIHandles::make_local(env, res);
1911   }
1912 
1913   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1935     }
1936   }
1937 
1938   // Allocate result
1939   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1940   objArrayHandle result (THREAD, r);
1941 
1942   // Now just put the methods that we selected above, but go by their idnum
1943   // in case of redefinition.  The methods can be redefined at any safepoint,
1944   // so above when allocating the oop array and below when creating reflect
1945   // objects.
1946   for (int i = 0; i &lt; num_methods; i++) {
1947     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1948     if (method.is_null()) {
1949       // Method may have been deleted and seems this API can handle null
1950       // Otherwise should probably put a method that throws NSME
1951       result-&gt;obj_at_put(i, NULL);
1952     } else {
1953       oop m;
1954       if (want_constructor) {


1955         m = Reflection::new_constructor(method, CHECK_NULL);
1956       } else {
1957         m = Reflection::new_method(method, false, CHECK_NULL);
1958       }
1959       result-&gt;obj_at_put(i, m);
1960     }
1961   }
1962 
1963   return (jobjectArray) JNIHandles::make_local(env, result());
1964 }
1965 
1966 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1967 {
1968   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1969   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1970                                            /*want_constructor*/ false,
1971                                            SystemDictionary::reflect_Method_klass(), THREAD);
1972 }
1973 JVM_END
1974 
</pre>
<hr />
<pre>
2165   constantTag tag = cp-&gt;tag_at(index);
2166   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2167     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2168   }
2169   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2170   Klass* k_o;
2171   if (force_resolution) {
2172     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2173   } else {
2174     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2175     if (k_o == NULL) return NULL;
2176   }
2177   InstanceKlass* k = InstanceKlass::cast(k_o);
2178   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2179   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2180   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2181   if (m.is_null()) {
2182     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2183   }
2184   oop method;
<span class="line-modified">2185   if (!m-&gt;is_initializer() || m-&gt;is_static()) {</span>
<span class="line-removed">2186     method = Reflection::new_method(m, true, CHECK_NULL);</span>
<span class="line-removed">2187   } else {</span>
2188     method = Reflection::new_constructor(m, CHECK_NULL);


2189   }
2190   return JNIHandles::make_local(method);
2191 }
2192 
2193 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2194 {
2195   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2196   JvmtiVMObjectAllocEventCollector oam;
2197   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2198   bounds_check(cp, index, CHECK_NULL);
2199   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2200   return res;
2201 }
2202 JVM_END
2203 
2204 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2205 {
2206   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2207   JvmtiVMObjectAllocEventCollector oam;
2208   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2456   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2457   if (!k-&gt;is_instance_klass()) return false;
2458 
2459   ResourceMark rm(THREAD);
2460   const char* name = k-&gt;name()-&gt;as_C_string();
2461   bool system_class = k-&gt;class_loader() == NULL;
2462   return JavaAssertions::enabled(name, system_class);
2463 
2464 JVM_END
2465 
2466 
2467 // Return a new AssertionStatusDirectives object with the fields filled in with
2468 // command-line assertion arguments (i.e., -ea, -da).
2469 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2470   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2471   JvmtiVMObjectAllocEventCollector oam;
2472   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2473   return JNIHandles::make_local(env, asd);
2474 JVM_END
2475 







































2476 // Verification ////////////////////////////////////////////////////////////////////////////////
2477 
2478 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2479 
2480 // RedefineClasses support: bug 6214132 caused verification to fail.
2481 // All functions from this section should call the jvmtiThreadSate function:
2482 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2483 // The function returns a Klass* of the _scratch_class if the verifier
2484 // was invoked in the middle of the class redefinition.
2485 // Otherwise it returns its argument value which is the _the_class Klass*.
2486 // Please, refer to the description in the jvmtiThreadSate.hpp.
2487 
2488 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2489   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2490   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2491   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2492   return k-&gt;name()-&gt;as_utf8();
2493 JVM_END
2494 
2495 
</pre>
<hr />
<pre>
2635   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2636   return method-&gt;size_of_parameters();
2637 JVM_END
2638 
2639 
2640 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2641   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2642   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2643   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2644   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2645   return method-&gt;verifier_max_stack();
2646 JVM_END
2647 
2648 
2649 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2650   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2651   ResourceMark rm(THREAD);
2652   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2653   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2654   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2655   return method-&gt;name() == vmSymbols::object_initializer_name();</span>
2656 JVM_END
2657 
2658 
2659 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2660   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2661   ResourceMark rm(THREAD);
2662   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2663   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2664   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2665   return method-&gt;is_overpass();
2666 JVM_END
2667 
2668 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2669   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2670   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2671   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2672   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2673   return method-&gt;name()-&gt;as_utf8();
2674 JVM_END
2675 
</pre>
<hr />
<pre>
3630   //   protection_domain. The protection_domain is passed as NULL by the java code
3631   //   if there is no security manager in 3-arg Class.forName().
3632   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3633 
3634   // Check if we should initialize the class
3635   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3636     klass-&gt;initialize(CHECK_NULL);
3637   }
3638   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3639 }
3640 
3641 
3642 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3643 
3644 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3645   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3646   Handle method_handle;
3647   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3648     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3649     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3650     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3651     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3652     jobject res = JNIHandles::make_local(env, result);
3653     if (JvmtiExport::should_post_vm_object_alloc()) {
3654       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3655       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3656       if (java_lang_Class::is_primitive(ret_type)) {
3657         // Only for primitive type vm allocates memory for java object.
3658         // See box() method.
3659         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3660       }
3661     }
3662     return res;
3663   } else {
3664     THROW_0(vmSymbols::java_lang_StackOverflowError());
3665   }
3666 JVM_END
3667 
3668 
3669 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3670   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);

3671   oop constructor_mirror = JNIHandles::resolve(c);
<span class="line-removed">3672   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));</span>
3673   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3674   jobject res = JNIHandles::make_local(env, result);
3675   if (JvmtiExport::should_post_vm_object_alloc()) {
3676     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3677   }
3678   return res;
3679 JVM_END
3680 
3681 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3682 
3683 JVM_LEAF(jboolean, JVM_SupportsCX8())
3684   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3685   return VM_Version::supports_cx8();
3686 JVM_END
3687 
3688 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3689   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3690   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3691   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3692   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  58 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  59 #include &quot;prims/jvm_misc.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;prims/nativeLookup.hpp&quot;
  63 #include &quot;prims/stackwalk.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/thread.inline.hpp&quot;
</pre>
<hr />
<pre>
 689   JVMWrapper(&quot;JVM_Clone&quot;);
 690   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 691   Klass* klass = obj-&gt;klass();
 692   JvmtiVMObjectAllocEventCollector oam;
 693 
 694 #ifdef ASSERT
 695   // Just checking that the cloneable flag is set correct
 696   if (obj-&gt;is_array()) {
 697     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 698   } else {
 699     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 700     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 701     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 702   }
 703 #endif
 704 
 705   // Check if class of obj supports the Cloneable interface.
 706   // All arrays are considered to be cloneable (See JLS 20.1.5).
 707   // All j.l.r.Reference classes are considered non-cloneable.
 708   if (!klass-&gt;is_cloneable() ||
<span class="line-added"> 709        klass-&gt;is_value() ||</span>
 710       (klass-&gt;is_instance_klass() &amp;&amp;
 711        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 712     ResourceMark rm(THREAD);
 713     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 714   }
 715 
 716   // Make shallow object copy
 717   const int size = obj-&gt;size();
 718   oop new_obj_oop = NULL;
 719   if (obj-&gt;is_array()) {
 720     const int length = ((arrayOop)obj())-&gt;length();
 721     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 722                                                    /* do_zero */ true, CHECK_NULL);
 723   } else {
 724     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 725   }
 726 
 727   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 728 
 729   Handle new_obj(THREAD, new_obj_oop);
</pre>
<hr />
<pre>
1233   return (jstring) JNIHandles::make_local(env, result);
1234 JVM_END
1235 
1236 
1237 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1238   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1239   JvmtiVMObjectAllocEventCollector oam;
1240   oop mirror = JNIHandles::resolve_non_null(cls);
1241 
1242   // Special handling for primitive objects
1243   if (java_lang_Class::is_primitive(mirror)) {
1244     // Primitive objects does not have any interfaces
1245     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1246     return (jobjectArray) JNIHandles::make_local(env, r);
1247   }
1248 
1249   Klass* klass = java_lang_Class::as_Klass(mirror);
1250   // Figure size of result array
1251   int size;
1252   if (klass-&gt;is_instance_klass()) {
<span class="line-modified">1253     InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-added">1254     size = ik-&gt;local_interfaces()-&gt;length();</span>
<span class="line-added">1255     if (ik-&gt;has_injected_identityObject()) {</span>
<span class="line-added">1256       size--;</span>
<span class="line-added">1257     }</span>
1258   } else {
1259     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
<span class="line-modified">1260     size = 3;</span>
1261   }
1262 
1263   // Allocate result array
1264   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1265   objArrayHandle result (THREAD, r);
1266   // Fill in result
1267   if (klass-&gt;is_instance_klass()) {
1268     // Regular instance klass, fill in all local interfaces
<span class="line-added">1269     int cursor = 0;</span>
1270     for (int index = 0; index &lt; size; index++) {
<span class="line-modified">1271       InstanceKlass* ik = InstanceKlass::cast(klass);</span>
<span class="line-modified">1272       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);</span>
<span class="line-added">1273       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">1274         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());</span>
<span class="line-added">1275       }</span>
1276     }
1277   } else {
<span class="line-modified">1278     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject</span>
1279     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1280     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
<span class="line-added">1281     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());</span>
1282   }
1283   return (jobjectArray) JNIHandles::make_local(env, result());
1284 JVM_END
1285 
1286 
1287 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1288   JVMWrapper(&quot;JVM_IsInterface&quot;);
1289   oop mirror = JNIHandles::resolve_non_null(cls);
1290   if (java_lang_Class::is_primitive(mirror)) {
1291     return JNI_FALSE;
1292   }
1293   Klass* k = java_lang_Class::as_Klass(mirror);
1294   jboolean result = k-&gt;is_interface();
1295   assert(!result || k-&gt;is_instance_klass(),
1296          &quot;all interfaces are instance types&quot;);
1297   // The compiler intrinsic for isInterface tests the
1298   // Klass::_access_flags bits in the same way.
1299   return result;
1300 JVM_END
1301 
</pre>
<hr />
<pre>
1881         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1882       objArrayHandle components_h (THREAD, record_components);
1883 
1884       for (int x = 0; x &lt; length; x++) {
1885         RecordComponent* component = components-&gt;at(x);
1886         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1887         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1888         components_h-&gt;obj_at_put(x, component_oop);
1889       }
1890       return (jobjectArray)JNIHandles::make_local(components_h());
1891     }
1892   }
1893 
1894   // Return empty array if ofClass is not a record.
1895   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1896   return (jobjectArray)JNIHandles::make_local(env, result);
1897 }
1898 JVM_END
1899 
1900 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
<span class="line-added">1901   bool is_ctor = (method-&gt;is_object_constructor() ||</span>
<span class="line-added">1902                   method-&gt;is_static_init_factory());</span>
1903   if (want_constructor) {
<span class="line-modified">1904     return is_ctor;</span>
1905   } else {
<span class="line-modified">1906     return (!is_ctor &amp;&amp;</span>
<span class="line-added">1907             !method-&gt;is_class_initializer() &amp;&amp;</span>
<span class="line-added">1908             !method-&gt;is_overpass());</span>
1909   }
1910 }
1911 
1912 static jobjectArray get_class_declared_methods_helper(
1913                                   JNIEnv *env,
1914                                   jclass ofClass, jboolean publicOnly,
1915                                   bool want_constructor,
1916                                   Klass* klass, TRAPS) {
1917 
1918   JvmtiVMObjectAllocEventCollector oam;
1919 
1920   // Exclude primitive types and array types
1921   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1922       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1923     // Return empty array
1924     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1925     return (jobjectArray) JNIHandles::make_local(env, res);
1926   }
1927 
1928   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
</pre>
<hr />
<pre>
1950     }
1951   }
1952 
1953   // Allocate result
1954   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1955   objArrayHandle result (THREAD, r);
1956 
1957   // Now just put the methods that we selected above, but go by their idnum
1958   // in case of redefinition.  The methods can be redefined at any safepoint,
1959   // so above when allocating the oop array and below when creating reflect
1960   // objects.
1961   for (int i = 0; i &lt; num_methods; i++) {
1962     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1963     if (method.is_null()) {
1964       // Method may have been deleted and seems this API can handle null
1965       // Otherwise should probably put a method that throws NSME
1966       result-&gt;obj_at_put(i, NULL);
1967     } else {
1968       oop m;
1969       if (want_constructor) {
<span class="line-added">1970         assert(method-&gt;is_object_constructor() ||</span>
<span class="line-added">1971                method-&gt;is_static_init_factory(), &quot;must be&quot;);</span>
1972         m = Reflection::new_constructor(method, CHECK_NULL);
1973       } else {
1974         m = Reflection::new_method(method, false, CHECK_NULL);
1975       }
1976       result-&gt;obj_at_put(i, m);
1977     }
1978   }
1979 
1980   return (jobjectArray) JNIHandles::make_local(env, result());
1981 }
1982 
1983 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1984 {
1985   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1986   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1987                                            /*want_constructor*/ false,
1988                                            SystemDictionary::reflect_Method_klass(), THREAD);
1989 }
1990 JVM_END
1991 
</pre>
<hr />
<pre>
2182   constantTag tag = cp-&gt;tag_at(index);
2183   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2184     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2185   }
2186   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2187   Klass* k_o;
2188   if (force_resolution) {
2189     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2190   } else {
2191     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2192     if (k_o == NULL) return NULL;
2193   }
2194   InstanceKlass* k = InstanceKlass::cast(k_o);
2195   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2196   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2197   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2198   if (m.is_null()) {
2199     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2200   }
2201   oop method;
<span class="line-modified">2202   if (m-&gt;is_object_constructor()) {</span>


2203     method = Reflection::new_constructor(m, CHECK_NULL);
<span class="line-added">2204   } else {</span>
<span class="line-added">2205     method = Reflection::new_method(m, true, CHECK_NULL);</span>
2206   }
2207   return JNIHandles::make_local(method);
2208 }
2209 
2210 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2211 {
2212   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2213   JvmtiVMObjectAllocEventCollector oam;
2214   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2215   bounds_check(cp, index, CHECK_NULL);
2216   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2217   return res;
2218 }
2219 JVM_END
2220 
2221 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2222 {
2223   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2224   JvmtiVMObjectAllocEventCollector oam;
2225   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
</pre>
<hr />
<pre>
2473   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2474   if (!k-&gt;is_instance_klass()) return false;
2475 
2476   ResourceMark rm(THREAD);
2477   const char* name = k-&gt;name()-&gt;as_C_string();
2478   bool system_class = k-&gt;class_loader() == NULL;
2479   return JavaAssertions::enabled(name, system_class);
2480 
2481 JVM_END
2482 
2483 
2484 // Return a new AssertionStatusDirectives object with the fields filled in with
2485 // command-line assertion arguments (i.e., -ea, -da).
2486 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2487   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2488   JvmtiVMObjectAllocEventCollector oam;
2489   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2490   return JNIHandles::make_local(env, asd);
2491 JVM_END
2492 
<span class="line-added">2493 // Arrays support /////////////////////////////////////////////////////////////</span>
<span class="line-added">2494 </span>
<span class="line-added">2495 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2496   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);</span>
<span class="line-added">2497   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2498   Klass* k = o-&gt;klass();</span>
<span class="line-added">2499   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2500     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2501   }</span>
<span class="line-added">2502   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();</span>
<span class="line-added">2503 JVM_END</span>
<span class="line-added">2504 </span>
<span class="line-added">2505 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))</span>
<span class="line-added">2506   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);</span>
<span class="line-added">2507   oop o = JNIHandles::resolve(array);</span>
<span class="line-added">2508   Klass* k = o-&gt;klass();</span>
<span class="line-added">2509   if ((o == NULL) || (!k-&gt;is_array_klass())) {</span>
<span class="line-added">2510     THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span>
<span class="line-added">2511   }</span>
<span class="line-added">2512   if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">2513     ValueArrayKlass* vk = ValueArrayKlass::cast(k);</span>
<span class="line-added">2514     if (!vk-&gt;element_access_is_atomic()) {</span>
<span class="line-added">2515       /**</span>
<span class="line-added">2516        * Need to decide how to implement:</span>
<span class="line-added">2517        *</span>
<span class="line-added">2518        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so</span>
<span class="line-added">2519        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through</span>
<span class="line-added">2520        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;</span>
<span class="line-added">2521        *</span>
<span class="line-added">2522        * 2) Use extra header in the valueArrayOop to flag atomicity required and</span>
<span class="line-added">2523        * possibly per instance lock structure. Said info, could be placed in</span>
<span class="line-added">2524        * &quot;trailer&quot; rather than disturb the current arrayOop</span>
<span class="line-added">2525        */</span>
<span class="line-added">2526       Unimplemented();</span>
<span class="line-added">2527     }</span>
<span class="line-added">2528   }</span>
<span class="line-added">2529   return array;</span>
<span class="line-added">2530 JVM_END</span>
<span class="line-added">2531 </span>
2532 // Verification ////////////////////////////////////////////////////////////////////////////////
2533 
2534 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2535 
2536 // RedefineClasses support: bug 6214132 caused verification to fail.
2537 // All functions from this section should call the jvmtiThreadSate function:
2538 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2539 // The function returns a Klass* of the _scratch_class if the verifier
2540 // was invoked in the middle of the class redefinition.
2541 // Otherwise it returns its argument value which is the _the_class Klass*.
2542 // Please, refer to the description in the jvmtiThreadSate.hpp.
2543 
2544 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2545   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2546   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2547   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2548   return k-&gt;name()-&gt;as_utf8();
2549 JVM_END
2550 
2551 
</pre>
<hr />
<pre>
2691   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2692   return method-&gt;size_of_parameters();
2693 JVM_END
2694 
2695 
2696 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2697   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2698   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2699   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2700   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2701   return method-&gt;verifier_max_stack();
2702 JVM_END
2703 
2704 
2705 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2706   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2707   ResourceMark rm(THREAD);
2708   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2709   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2710   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
<span class="line-modified">2711   return method-&gt;is_object_constructor();</span>
2712 JVM_END
2713 
2714 
2715 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2716   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2717   ResourceMark rm(THREAD);
2718   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2719   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2720   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2721   return method-&gt;is_overpass();
2722 JVM_END
2723 
2724 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2725   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2726   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2727   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2728   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2729   return method-&gt;name()-&gt;as_utf8();
2730 JVM_END
2731 
</pre>
<hr />
<pre>
3686   //   protection_domain. The protection_domain is passed as NULL by the java code
3687   //   if there is no security manager in 3-arg Class.forName().
3688   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3689 
3690   // Check if we should initialize the class
3691   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3692     klass-&gt;initialize(CHECK_NULL);
3693   }
3694   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3695 }
3696 
3697 
3698 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3699 
3700 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3701   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3702   Handle method_handle;
3703   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3704     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3705     Handle receiver(THREAD, JNIHandles::resolve(obj));
<span class="line-modified">3706     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3707     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3708     jobject res = JNIHandles::make_local(env, result);
3709     if (JvmtiExport::should_post_vm_object_alloc()) {
3710       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3711       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3712       if (java_lang_Class::is_primitive(ret_type)) {
3713         // Only for primitive type vm allocates memory for java object.
3714         // See box() method.
3715         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3716       }
3717     }
3718     return res;
3719   } else {
3720     THROW_0(vmSymbols::java_lang_StackOverflowError());
3721   }
3722 JVM_END
3723 
3724 
3725 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3726   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
<span class="line-added">3727   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);</span>
3728   oop constructor_mirror = JNIHandles::resolve(c);

3729   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3730   jobject res = JNIHandles::make_local(env, result);
3731   if (JvmtiExport::should_post_vm_object_alloc()) {
3732     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3733   }
3734   return res;
3735 JVM_END
3736 
3737 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3738 
3739 JVM_LEAF(jboolean, JVM_SupportsCX8())
3740   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3741   return VM_Version::supports_cx8();
3742 JVM_END
3743 
3744 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3745   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3746   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3747   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3748   HeapShared::initialize_from_archived_subgraph(k);
</pre>
</td>
</tr>
</table>
<center><a href="jniCheck.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
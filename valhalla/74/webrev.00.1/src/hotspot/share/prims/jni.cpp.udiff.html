<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../precompiled/precompiled.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -57,10 +57,12 @@</span>
  #include &quot;oops/objArrayOop.inline.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/typeArrayKlass.hpp&quot;
  #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  #include &quot;prims/jniCheck.hpp&quot;
  #include &quot;prims/jniExport.hpp&quot;
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
  #include &quot;prims/jvmtiExport.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,12 +476,13 @@</span>
  
    // The slot is the index of the field description in the field-array
    // The jfieldID is the offset of the field within the object
    // It may also have hash bits for k, if VerifyJNIFields is turned on.
    intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
<span class="udiff-line-added">+   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);</span>
    assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
<span class="udiff-line-modified-removed">-   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);</span>
<span class="udiff-line-modified-added">+   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);</span>
    return ret;
  JNI_END
  
  
  DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -494,11 +497,11 @@</span>
    DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
  
    methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
    assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
    oop reflection_method;
<span class="udiff-line-modified-removed">-   if (m-&gt;is_initializer()) {</span>
<span class="udiff-line-modified-added">+   if (m-&gt;is_object_constructor()) {</span>
      reflection_method = Reflection::new_constructor(m, CHECK_NULL);
    } else {
      reflection_method = Reflection::new_method(m, false, CHECK_NULL);
    }
    ret = JNIHandles::make_local(env, reflection_method);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -556,11 +559,10 @@</span>
    Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
    Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
    assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
    jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
                     JNI_TRUE : JNI_FALSE;
<span class="udiff-line-removed">- </span>
    HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
    return ret;
  JNI_END
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -891,11 +893,12 @@</span>
      // float is coerced to double w/ va_arg
      case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
      case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
  
      case T_ARRAY:
<span class="udiff-line-modified-removed">-     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>
<span class="udiff-line-modified-added">+     case T_OBJECT:</span>
<span class="udiff-line-added">+     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;</span>
      default:            ShouldNotReachHere();
      }
    }
  
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -927,11 +930,12 @@</span>
      case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
      case T_LONG:        push_long((_ap++)-&gt;j); break;
      case T_FLOAT:       push_float((_ap++)-&gt;f); break;
      case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
      case T_ARRAY:
<span class="udiff-line-modified-removed">-     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>
<span class="udiff-line-modified-added">+     case T_OBJECT:</span>
<span class="udiff-line-added">+     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;</span>
      default:            ShouldNotReachHere();
      }
    }
  
   public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1067,17 +1071,31 @@</span>
    HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
  
    jobject obj = NULL;
    DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
  
<span class="udiff-line-modified-removed">-   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-   obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-modified-removed">-   JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-modified-removed">-   JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="udiff-line-modified-removed">-   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="udiff-line-modified-added">+   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="udiff-line-modified-added">+   if (k == NULL) {</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!k-&gt;is_value()) {</span>
<span class="udiff-line-added">+     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="udiff-line-added">+     obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VALUETYPE);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+     obj = jvalue.get_jobject();</span>
<span class="udiff-line-added">+   }</span>
    return obj;
<span class="udiff-line-modified-removed">- JNI_END</span>
<span class="udiff-line-modified-added">+   JNI_END</span>
  
  
  DT_RETURN_MARK_DECL(NewObjectV, jobject
                      , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1087,15 +1105,29 @@</span>
    HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
  
    jobject obj = NULL;
    DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
  
<span class="udiff-line-modified-removed">-   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-   obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-modified-removed">-   JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-modified-removed">-   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-modified-removed">-   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-modified-added">+   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="udiff-line-modified-added">+   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="udiff-line-modified-added">+   if (k == NULL) {</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!k-&gt;is_value()) {</span>
<span class="udiff-line-added">+     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="udiff-line-added">+     obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VALUETYPE);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+     obj = jvalue.get_jobject();</span>
<span class="udiff-line-added">+   }</span>
    return obj;
  JNI_END
  
  
  DT_RETURN_MARK_DECL(NewObject, jobject
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1107,18 +1139,35 @@</span>
    HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
  
    jobject obj = NULL;
    DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
  
<span class="udiff-line-modified-removed">-   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-   obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-modified-removed">-   va_list args;</span>
<span class="udiff-line-modified-removed">-   va_start(args, methodID);</span>
<span class="udiff-line-modified-removed">-   JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-modified-removed">-   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-modified-removed">-   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-   va_end(args);</span>
<span class="udiff-line-modified-added">+   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="udiff-line-modified-added">+   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="udiff-line-modified-added">+   if (k == NULL) {</span>
<span class="udiff-line-modified-added">+     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (!k-&gt;is_value()) {</span>
<span class="udiff-line-added">+     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="udiff-line-added">+     obj = JNIHandles::make_local(env, i);</span>
<span class="udiff-line-added">+     va_list args;</span>
<span class="udiff-line-added">+     va_start(args, methodID);</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VOID);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+     va_end(args);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     va_list args;</span>
<span class="udiff-line-added">+     va_start(args, methodID);</span>
<span class="udiff-line-added">+     JavaValue jvalue(T_VALUETYPE);</span>
<span class="udiff-line-added">+     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="udiff-line-added">+     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="udiff-line-added">+     va_end(args);</span>
<span class="udiff-line-added">+     obj = jvalue.get_jobject();</span>
<span class="udiff-line-added">+   }</span>
    return obj;
  JNI_END
  
  
  JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1891,28 +1940,39 @@</span>
      THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
    }
  
    // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
    // It may also have hash bits for k, if VerifyJNIFields is turned on.
<span class="udiff-line-modified-removed">-   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());</span>
<span class="udiff-line-modified-added">+   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());</span>
    return ret;
  JNI_END
  
  
  JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
    JNIWrapper(&quot;GetObjectField&quot;);
    HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
    oop o = JNIHandles::resolve_non_null(obj);
    Klass* k = o-&gt;klass();
    int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
<span class="udiff-line-added">+   oop res = NULL;</span>
    // Keep JVMTI addition small and only check enabled flag here.
    // jni_GetField_probe() assumes that is okay to create handles.
    if (JvmtiExport::should_post_field_access()) {
      o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
    }
<span class="udiff-line-modified-removed">-   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="udiff-line-modified-removed">-   jobject ret = JNIHandles::make_local(env, loaded_obj);</span>
<span class="udiff-line-modified-added">+   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="udiff-line-modified-added">+     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);</span>
<span class="udiff-line-added">+     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="udiff-line-added">+     fieldDescriptor fd;</span>
<span class="udiff-line-added">+     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck</span>
<span class="udiff-line-added">+     InstanceKlass* holder = fd.field_holder();</span>
<span class="udiff-line-added">+     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="udiff-line-added">+     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   jobject ret = JNIHandles::make_local(env, res);</span>
    HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
    return ret;
  JNI_END
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2006,11 +2066,22 @@</span>
    if (JvmtiExport::should_post_field_modification()) {
      jvalue field_value;
      field_value.l = value;
      o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
    }
<span class="udiff-line-modified-removed">-   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>
<span class="udiff-line-modified-added">+   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="udiff-line-added">+     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);</span>
<span class="udiff-line-added">+     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="udiff-line-added">+     fieldDescriptor fd;</span>
<span class="udiff-line-added">+     ik-&gt;find_field_from_offset(offset, false, &amp;fd);</span>
<span class="udiff-line-added">+     InstanceKlass* holder = fd.field_holder();</span>
<span class="udiff-line-added">+     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="udiff-line-added">+     oop v = JNIHandles::resolve_non_null(value);</span>
<span class="udiff-line-added">+     vklass-&gt;write_flattened_field(o, offset, v, CHECK);</span>
<span class="udiff-line-added">+   }</span>
    HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
  JNI_END
  
  
  #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2443,54 +2514,93 @@</span>
  JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
    JNIWrapper(&quot;GetObjectArrayElement&quot;);
   HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
    jobject ret = NULL;
    DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
<span class="udiff-line-modified-removed">-   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-modified-removed">-   if (a-&gt;is_within_bounds(index)) {</span>
<span class="udiff-line-modified-removed">-     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));</span>
<span class="udiff-line-modified-removed">-     return ret;</span>
<span class="udiff-line-modified-added">+   oop res = NULL;</span>
<span class="udiff-line-modified-added">+   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-modified-added">+   if (arr-&gt;is_within_bounds(index)) {</span>
<span class="udiff-line-modified-added">+     if (arr-&gt;is_valueArray()) {</span>
<span class="udiff-line-added">+       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+       arrayHandle ah(THREAD, a);</span>
<span class="udiff-line-added">+       valueArrayHandle vah(thread, a);</span>
<span class="udiff-line-added">+       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);</span>
<span class="udiff-line-added">+       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="udiff-line-added">+       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+       res = a-&gt;obj_at(index);</span>
<span class="udiff-line-added">+     }</span>
    } else {
      ResourceMark rm(THREAD);
      stringStream ss;
<span class="udiff-line-modified-removed">-     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
<span class="udiff-line-modified-added">+     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());</span>
      THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
    }
<span class="udiff-line-added">+   ret = JNIHandles::make_local(env, res);</span>
<span class="udiff-line-added">+   return ret;</span>
  JNI_END
  
  DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
                           , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
  
  JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
    JNIWrapper(&quot;SetObjectArrayElement&quot;);
<span class="udiff-line-modified-removed">-  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
<span class="udiff-line-modified-added">+   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
    DT_VOID_RETURN_MARK(SetObjectArrayElement);
  
<span class="udiff-line-modified-removed">-   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-modified-removed">-   oop v = JNIHandles::resolve(value);</span>
<span class="udiff-line-modified-removed">-   if (a-&gt;is_within_bounds(index)) {</span>
<span class="udiff-line-modified-removed">-     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="udiff-line-modified-removed">-       a-&gt;obj_at_put(index, v);</span>
<span class="udiff-line-modified-removed">-     } else {</span>
<span class="udiff-line-modified-removed">-       ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-removed">-       stringStream ss;</span>
<span class="udiff-line-modified-removed">-       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="udiff-line-modified-removed">-       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="udiff-line-modified-removed">-                v-&gt;klass()-&gt;external_name(),</span>
<span class="udiff-line-modified-removed">-                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="udiff-line-modified-removed">-                index);</span>
<span class="udiff-line-modified-removed">-       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="udiff-line-modified-removed">-         ss.print(&quot;[]&quot;);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-   } else {</span>
<span class="udiff-line-modified-removed">-     ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-removed">-     stringStream ss;</span>
<span class="udiff-line-modified-removed">-     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
<span class="udiff-line-modified-removed">-     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+    bool oob = false;</span>
<span class="udiff-line-modified-added">+    int length = -1;</span>
<span class="udiff-line-modified-added">+    oop res = NULL;</span>
<span class="udiff-line-modified-added">+    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-modified-added">+    if (arr-&gt;is_within_bounds(index)) {</span>
<span class="udiff-line-modified-added">+      if (arr-&gt;is_valueArray()) {</span>
<span class="udiff-line-modified-added">+        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-modified-added">+        oop v = JNIHandles::resolve(value);</span>
<span class="udiff-line-modified-added">+        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="udiff-line-modified-added">+        ValueKlass* element_vklass = vaklass-&gt;element_klass();</span>
<span class="udiff-line-modified-added">+        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {</span>
<span class="udiff-line-modified-added">+          a-&gt;value_copy_to_index(v, index);</span>
<span class="udiff-line-modified-added">+        } else {</span>
<span class="udiff-line-modified-added">+          ResourceMark rm(THREAD);</span>
<span class="udiff-line-modified-added">+          stringStream ss;</span>
<span class="udiff-line-modified-added">+          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="udiff-line-modified-added">+          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="udiff-line-modified-added">+              v-&gt;klass()-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+              kl-&gt;external_name(),</span>
<span class="udiff-line-modified-added">+              index);</span>
<span class="udiff-line-modified-added">+          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="udiff-line-modified-added">+            ss.print(&quot;[]&quot;);</span>
<span class="udiff-line-modified-added">+          }</span>
<span class="udiff-line-modified-added">+          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="udiff-line-added">+        }</span>
<span class="udiff-line-added">+      } else {</span>
<span class="udiff-line-added">+        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="udiff-line-added">+        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+        oop v = JNIHandles::resolve(value);</span>
<span class="udiff-line-added">+        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="udiff-line-added">+          a-&gt;obj_at_put(index, v);</span>
<span class="udiff-line-added">+        } else {</span>
<span class="udiff-line-added">+          ResourceMark rm(THREAD);</span>
<span class="udiff-line-added">+          stringStream ss;</span>
<span class="udiff-line-added">+          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="udiff-line-added">+          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="udiff-line-added">+              v-&gt;klass()-&gt;external_name(),</span>
<span class="udiff-line-added">+              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="udiff-line-added">+                  index);</span>
<span class="udiff-line-added">+          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="udiff-line-added">+            ss.print(&quot;[]&quot;);</span>
<span class="udiff-line-added">+          }</span>
<span class="udiff-line-added">+          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="udiff-line-added">+        }</span>
<span class="udiff-line-added">+      }</span>
<span class="udiff-line-added">+    } else {</span>
<span class="udiff-line-added">+      ResourceMark rm(THREAD);</span>
<span class="udiff-line-added">+      stringStream ss;</span>
<span class="udiff-line-added">+      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());</span>
<span class="udiff-line-added">+      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="udiff-line-added">+    }</span>
  JNI_END
  
  
  
  #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3273,10 +3383,285 @@</span>
    JNIWrapper(&quot;GetModule&quot;);
    return Modules::get_module(clazz, THREAD);
  JNI_END
  
  
<span class="udiff-line-added">+ JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);</span>
<span class="udiff-line-added">+   if (isCopy != NULL) {</span>
<span class="udiff-line-added">+     *isCopy = JNI_FALSE;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+   if (!ar-&gt;is_array()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!ar-&gt;is_valueArray()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="udiff-line-added">+   if (vak-&gt;contains_oops()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oop a = lock_gc_or_pin_object(thread, array);</span>
<span class="udiff-line-added">+   valueArrayOop vap = valueArrayOop(a);</span>
<span class="udiff-line-added">+   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());</span>
<span class="udiff-line-added">+   return ret;</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);</span>
<span class="udiff-line-added">+   unlock_gc_or_unpin_object(thread, array);</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);</span>
<span class="udiff-line-added">+   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+   if (!a-&gt;is_array()) {</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!a-&gt;is_valueArray()) {</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="udiff-line-added">+   jsize ret = vak-&gt;element_byte_size();</span>
<span class="udiff-line-added">+   return ret;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);</span>
<span class="udiff-line-added">+   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+   if (!a-&gt;is_array()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!a-&gt;is_valueArray()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="udiff-line-added">+   ValueKlass* vk = vak-&gt;element_klass();</span>
<span class="udiff-line-added">+   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oop mirror = JNIHandles::resolve_non_null(clazz);</span>
<span class="udiff-line-added">+   Klass* k = java_lang_Class::as_Klass(mirror);</span>
<span class="udiff-line-added">+   if (!k-&gt;is_value()) {</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="udiff-line-added">+   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="udiff-line-added">+   if (fieldname == NULL || signame == NULL) {</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   fieldDescriptor fd;</span>
<span class="udiff-line-added">+   if (!vk-&gt;is_instance_klass() ||</span>
<span class="udiff-line-added">+       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int offset = fd.offset() - vk-&gt;first_field_offset();</span>
<span class="udiff-line-added">+   if (isFlattened != NULL) {</span>
<span class="udiff-line-added">+     *isFlattened = fd.is_flattened();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return (jsize)offset;</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="udiff-line-added">+   if (!ar-&gt;is_array()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!ar-&gt;is_valueArray()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),</span>
<span class="udiff-line-added">+         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);</span>
<span class="udiff-line-added">+   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);</span>
<span class="udiff-line-added">+   ses_ik-&gt;initialize(CHECK_NULL);</span>
<span class="udiff-line-added">+   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();</span>
<span class="udiff-line-added">+   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="udiff-line-added">+   Handle ses_h(THREAD, ses);</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable</span>
<span class="udiff-line-added">+   return JNIHandles::make_local(ses_h());</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="udiff-line-added">+   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);</span>
<span class="udiff-line-added">+   if (!isflattened) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);</span>
<span class="udiff-line-added">+   Klass* k = java_lang_Class::as_Klass(semirror);</span>
<span class="udiff-line-added">+   if (!k-&gt;is_value()) {</span>
<span class="udiff-line-added">+     ResourceMark rm;</span>
<span class="udiff-line-added">+         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="udiff-line-added">+   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="udiff-line-added">+   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);</span>
<span class="udiff-line-added">+   fieldDescriptor fd;</span>
<span class="udiff-line-added">+   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {</span>
<span class="udiff-line-added">+     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));</span>
<span class="udiff-line-added">+   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element</span>
<span class="udiff-line-added">+   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="udiff-line-added">+   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());</span>
<span class="udiff-line-added">+   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="udiff-line-added">+   Handle res_h(THREAD, res);</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());</span>
<span class="udiff-line-added">+   InstanceKlass* holder = fd.field_holder();</span>
<span class="udiff-line-added">+   BasicType bt = Signature::basic_type(fd.signature());</span>
<span class="udiff-line-added">+   if (is_java_primitive(bt)) {</span>
<span class="udiff-line-added">+     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),</span>
<span class="udiff-line-added">+         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);</span>
<span class="udiff-line-added">+     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());</span>
<span class="udiff-line-added">+   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());</span>
<span class="udiff-line-added">+   return JNIHandles::make_local(res_h());</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="udiff-line-added">+   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="udiff-line-added">+     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oop res = NULL;</span>
<span class="udiff-line-added">+   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="udiff-line-added">+     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="udiff-line-added">+                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="udiff-line-added">+     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="udiff-line-added">+     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="udiff-line-added">+     // The array might have been moved by the GC, refreshing the arrayOop</span>
<span class="udiff-line-added">+     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="udiff-line-added">+     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="udiff-line-added">+               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="udiff-line-added">+     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return JNIHandles::make_local(res);</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="udiff-line-added">+   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="udiff-line-added">+     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   oop val = JNIHandles::resolve(value);</span>
<span class="udiff-line-added">+   if (val == NULL) {</span>
<span class="udiff-line-added">+     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {</span>
<span class="udiff-line-added">+       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {</span>
<span class="udiff-line-added">+       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="udiff-line-added">+     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="udiff-line-added">+                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="udiff-line-added">+     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="udiff-line-added">+     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="udiff-line-added">+                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="udiff-line-added">+     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="udiff-line-added">+ \</span>
<span class="udiff-line-added">+ JNI_ENTRY(ElementType, \</span>
<span class="udiff-line-added">+           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="udiff-line-added">+   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="udiff-line-added">+   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="udiff-line-added">+     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="udiff-line-added">+                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="udiff-line-added">+   ElementType result = *(ElementType*)addr; \</span>
<span class="udiff-line-added">+   return result; \</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jint, Int,T_INT)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="udiff-line-added">+ DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="udiff-line-added">+ \</span>
<span class="udiff-line-added">+ JNI_ENTRY(void, \</span>
<span class="udiff-line-added">+           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \</span>
<span class="udiff-line-added">+   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="udiff-line-added">+   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="udiff-line-added">+   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="udiff-line-added">+   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="udiff-line-added">+     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="udiff-line-added">+     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="udiff-line-added">+   } \</span>
<span class="udiff-line-added">+   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="udiff-line-added">+                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="udiff-line-added">+   *(ElementType*)addr = value; \</span>
<span class="udiff-line-added">+ JNI_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jint, Int,T_INT)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="udiff-line-added">+ DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="udiff-line-added">+ </span>
  // Structure containing all jni functions
  struct JNINativeInterface_ jni_NativeInterface = {
      NULL,
      NULL,
      NULL,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3556,11 +3941,42 @@</span>
  
      jni_GetObjectRefType,
  
      // Module features
  
<span class="udiff-line-modified-removed">-     jni_GetModule</span>
<span class="udiff-line-modified-added">+     jni_GetModule,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Flattened arrays features</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jni_GetFlattenedArrayElements,</span>
<span class="udiff-line-added">+     jni_ReleaseFlattenedArrayElements,</span>
<span class="udiff-line-added">+     jni_GetFlattenedArrayElementClass,</span>
<span class="udiff-line-added">+     jni_GetFlattenedArrayElementSize,</span>
<span class="udiff-line-added">+     jni_GetFieldOffsetInFlattenedLayout,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jni_CreateSubElementSelector,</span>
<span class="udiff-line-added">+     jni_GetSubElementSelector,</span>
<span class="udiff-line-added">+     jni_GetObjectSubElement,</span>
<span class="udiff-line-added">+     jni_SetObjectSubElement,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jni_GetBooleanSubElement,</span>
<span class="udiff-line-added">+     jni_GetByteSubElement,</span>
<span class="udiff-line-added">+     jni_GetShortSubElement,</span>
<span class="udiff-line-added">+     jni_GetCharSubElement,</span>
<span class="udiff-line-added">+     jni_GetIntSubElement,</span>
<span class="udiff-line-added">+     jni_GetLongSubElement,</span>
<span class="udiff-line-added">+     jni_GetFloatSubElement,</span>
<span class="udiff-line-added">+     jni_GetDoubleSubElement,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     jni_SetBooleanSubElement,</span>
<span class="udiff-line-added">+     jni_SetByteSubElement,</span>
<span class="udiff-line-added">+     jni_SetShortSubElement,</span>
<span class="udiff-line-added">+     jni_SetCharSubElement,</span>
<span class="udiff-line-added">+     jni_SetIntSubElement,</span>
<span class="udiff-line-added">+     jni_SetLongSubElement,</span>
<span class="udiff-line-added">+     jni_SetFloatSubElement,</span>
<span class="udiff-line-added">+     jni_SetDoubleSubElement</span>
  };
  
  
  // For jvmti use to modify jni function table.
  // Java threads in native contiues to run until it is transitioned
</pre>
<center><a href="../precompiled/precompiled.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
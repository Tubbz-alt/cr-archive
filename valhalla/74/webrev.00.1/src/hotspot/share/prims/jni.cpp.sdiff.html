<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../precompiled/precompiled.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  62 #include &quot;prims/jniCheck.hpp&quot;
  63 #include &quot;prims/jniExport.hpp&quot;
  64 #include &quot;prims/jniFastGetField.hpp&quot;
  65 #include &quot;prims/jvm_misc.hpp&quot;
  66 #include &quot;prims/jvmtiExport.hpp&quot;
  67 #include &quot;prims/jvmtiThreadState.hpp&quot;
  68 #include &quot;runtime/atomic.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/safepointVerifiers.hpp&quot;
  78 #include &quot;runtime/sharedRuntime.hpp&quot;
  79 #include &quot;runtime/signature.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
 459   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 460 
 461   // Make sure class is initialized before handing id&#39;s out to fields
 462   k1-&gt;initialize(CHECK_NULL);
 463 
 464   // First check if this is a static field
 465   if (modifiers &amp; JVM_ACC_STATIC) {
 466     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 467     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 468     assert(id != NULL, &quot;corrupt Field object&quot;);
 469     debug_only(id-&gt;set_is_static_field_id();)
 470     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 471     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 472     return ret;
 473   }
 474 
 475   // The slot is the index of the field description in the field-array
 476   // The jfieldID is the offset of the field within the object
 477   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 478   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );

 479   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
<span class="line-modified"> 480   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);</span>
 481   return ret;
 482 JNI_END
 483 
 484 
 485 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 486                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 487 
 488 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 489   JNIWrapper(&quot;ToReflectedMethod&quot;);
 490 
 491   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 492 
 493   jobject ret = NULL;
 494   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 495 
 496   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 497   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 498   oop reflection_method;
<span class="line-modified"> 499   if (m-&gt;is_initializer()) {</span>
 500     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 501   } else {
 502     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 503   }
 504   ret = JNIHandles::make_local(env, reflection_method);
 505   return ret;
 506 JNI_END
 507 
 508 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 509                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 510 
 511 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 512   JNIWrapper(&quot;GetSuperclass&quot;);
 513 
 514   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 515 
 516   jclass obj = NULL;
 517   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 518 
 519   oop mirror = JNIHandles::resolve_non_null(sub);
</pre>
<hr />
<pre>
 541 
 542 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 543   JNIWrapper(&quot;IsSubclassOf&quot;);
 544 
 545   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 546 
 547   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 548   oop super_mirror = JNIHandles::resolve_non_null(super);
 549   if (java_lang_Class::is_primitive(sub_mirror) ||
 550       java_lang_Class::is_primitive(super_mirror)) {
 551     jboolean ret = (sub_mirror == super_mirror);
 552 
 553     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 554     return ret;
 555   }
 556   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 557   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 558   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 559   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 560                    JNI_TRUE : JNI_FALSE;
<span class="line-removed"> 561 </span>
 562   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 563   return ret;
 564 JNI_END
 565 
 566 
 567 DT_RETURN_MARK_DECL(Throw, jint
 568                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 569 
 570 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 571   JNIWrapper(&quot;Throw&quot;);
 572 
 573   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 574 
 575   jint ret = JNI_OK;
 576   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 577 
 578   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 579   ShouldNotReachHere();
 580   return 0;  // Mute compiler.
 581 JNI_END
</pre>
<hr />
<pre>
 876   }
 877 
 878   friend class SignatureIterator;  // so do_parameters_on can call do_type
 879   void do_type(BasicType type) {
 880     switch (type) {
 881     // these are coerced to int when using va_arg
 882     case T_BYTE:
 883     case T_CHAR:
 884     case T_SHORT:
 885     case T_INT:         push_int(va_arg(_ap, jint)); break;
 886     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 887 
 888     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 889 
 890     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 891     // float is coerced to double w/ va_arg
 892     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 893     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 894 
 895     case T_ARRAY:
<span class="line-modified"> 896     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>

 897     default:            ShouldNotReachHere();
 898     }
 899   }
 900 
 901  public:
 902   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 903       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 904     set_ap(rap);
 905   }
 906 
 907   virtual void push_arguments_on(JavaCallArguments* arguments) {
 908     _arguments = arguments;
 909     do_parameters_on(this);
 910   }
 911 };
 912 
 913 
 914 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 915  protected:
 916   const jvalue *_ap;
 917 
 918   inline void set_ap(const jvalue *rap) { _ap = rap; }
 919 
 920   friend class SignatureIterator;  // so do_parameters_on can call do_type
 921   void do_type(BasicType type) {
 922     switch (type) {
 923     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 924     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 925     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 926     case T_INT:         push_int((_ap++)-&gt;i); break;
 927     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 928     case T_LONG:        push_long((_ap++)-&gt;j); break;
 929     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 930     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 931     case T_ARRAY:
<span class="line-modified"> 932     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>

 933     default:            ShouldNotReachHere();
 934     }
 935   }
 936 
 937  public:
 938   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 939       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 940     set_ap(rap);
 941   }
 942 
 943   virtual void push_arguments_on(JavaCallArguments* arguments) {
 944     _arguments = arguments;
 945     do_parameters_on(this);
 946   }
 947 };
 948 
 949 
 950 enum JNICallType {
 951   JNI_STATIC,
 952   JNI_VIRTUAL,
</pre>
<hr />
<pre>
1052 
1053   jobject ret = NULL;
1054   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1055 
1056   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1057   ret = JNIHandles::make_local(env, i);
1058   return ret;
1059 JNI_END
1060 
1061 DT_RETURN_MARK_DECL(NewObjectA, jobject
1062                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1063 
1064 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1065   JNIWrapper(&quot;NewObjectA&quot;);
1066 
1067   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1068 
1069   jobject obj = NULL;
1070   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1071 
<span class="line-modified">1072   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1073   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1074   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1075   JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-modified">1076   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>














1077   return obj;
<span class="line-modified">1078 JNI_END</span>
1079 
1080 
1081 DT_RETURN_MARK_DECL(NewObjectV, jobject
1082                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1083 
1084 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1085   JNIWrapper(&quot;NewObjectV&quot;);
1086 
1087   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1088 
1089   jobject obj = NULL;
1090   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1091 
<span class="line-modified">1092   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1093   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1094   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1095   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-modified">1096   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>














1097   return obj;
1098 JNI_END
1099 
1100 
1101 DT_RETURN_MARK_DECL(NewObject, jobject
1102                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1103 
1104 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1105   JNIWrapper(&quot;NewObject&quot;);
1106 
1107   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1108 
1109   jobject obj = NULL;
1110   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1111 
<span class="line-modified">1112   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1113   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1114   va_list args;</span>
<span class="line-modified">1115   va_start(args, methodID);</span>
<span class="line-modified">1116   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1117   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-modified">1118   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-modified">1119   va_end(args);</span>

















1120   return obj;
1121 JNI_END
1122 
1123 
1124 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1125   JNIWrapper(&quot;GetObjectClass&quot;);
1126 
1127   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1128 
1129   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1130   jclass ret =
1131     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1132 
1133   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1134   return ret;
1135 JNI_END
1136 
1137 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1138   JNIWrapper(&quot;IsInstanceOf&quot;);
1139 
</pre>
<hr />
<pre>
1876   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1877   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1878   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1879   if (fieldname == NULL || signame == NULL) {
1880     ResourceMark rm;
1881     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1882   }
1883 
1884   // Make sure class is initialized before handing id&#39;s out to fields
1885   k-&gt;initialize(CHECK_NULL);
1886 
1887   fieldDescriptor fd;
1888   if (!k-&gt;is_instance_klass() ||
1889       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1890     ResourceMark rm;
1891     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1892   }
1893 
1894   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1895   // It may also have hash bits for k, if VerifyJNIFields is turned on.
<span class="line-modified">1896   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());</span>
1897   return ret;
1898 JNI_END
1899 
1900 
1901 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1902   JNIWrapper(&quot;GetObjectField&quot;);
1903   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1904   oop o = JNIHandles::resolve_non_null(obj);
1905   Klass* k = o-&gt;klass();
1906   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);

1907   // Keep JVMTI addition small and only check enabled flag here.
1908   // jni_GetField_probe() assumes that is okay to create handles.
1909   if (JvmtiExport::should_post_field_access()) {
1910     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1911   }
<span class="line-modified">1912   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="line-modified">1913   jobject ret = JNIHandles::make_local(env, loaded_obj);</span>










1914   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1915   return ret;
1916 JNI_END
1917 
1918 
1919 
1920 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1921   , EntryProbe, ReturnProbe) \
1922 \
1923   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1924   , ReturnProbe); \
1925 \
1926 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
1927   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1928 \
1929   EntryProbe; \
1930   Return ret = 0;\
1931   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1932 \
1933   oop o = JNIHandles::resolve_non_null(obj); \
</pre>
<hr />
<pre>
1991   return (address)jni_GetFloatField;
1992 }
1993 address jni_GetDoubleField_addr() {
1994   return (address)jni_GetDoubleField;
1995 }
1996 
1997 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
1998   JNIWrapper(&quot;SetObjectField&quot;);
1999   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2000   oop o = JNIHandles::resolve_non_null(obj);
2001   Klass* k = o-&gt;klass();
2002   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2003   // Keep JVMTI addition small and only check enabled flag here.
2004   // jni_SetField_probe_nh() assumes that is not okay to create handles
2005   // and creates a ResetNoHandleMark.
2006   if (JvmtiExport::should_post_field_modification()) {
2007     jvalue field_value;
2008     field_value.l = value;
2009     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2010   }
<span class="line-modified">2011   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>











2012   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2013 JNI_END
2014 
2015 
2016 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2017                         , EntryProbe, ReturnProbe) \
2018 \
2019 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2020   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2021 \
2022   EntryProbe; \
2023 \
2024   oop o = JNIHandles::resolve_non_null(obj); \
2025   Klass* k = o-&gt;klass(); \
2026   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2027   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2028   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2029   /* and creates a ResetNoHandleMark.                                   */ \
2030   if (JvmtiExport::should_post_field_modification()) { \
2031     jvalue field_value; \
</pre>
<hr />
<pre>
2428   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2429   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2430   oop initial_value = JNIHandles::resolve(initialElement);
2431   if (initial_value != NULL) {  // array already initialized with NULL
2432     for (int index = 0; index &lt; length; index++) {
2433       result-&gt;obj_at_put(index, initial_value);
2434     }
2435   }
2436   ret = (jobjectArray) JNIHandles::make_local(env, result);
2437   return ret;
2438 JNI_END
2439 
2440 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2441                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2442 
2443 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2444   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2445  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2446   jobject ret = NULL;
2447   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
<span class="line-modified">2448   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2449   if (a-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2450     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));</span>
<span class="line-modified">2451     return ret;</span>










2452   } else {
2453     ResourceMark rm(THREAD);
2454     stringStream ss;
<span class="line-modified">2455     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
2456     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2457   }


2458 JNI_END
2459 
2460 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2461                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2462 
2463 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2464   JNIWrapper(&quot;SetObjectArrayElement&quot;);
<span class="line-modified">2465  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
2466   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2467 
<span class="line-modified">2468   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2469   oop v = JNIHandles::resolve(value);</span>
<span class="line-modified">2470   if (a-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2471     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="line-modified">2472       a-&gt;obj_at_put(index, v);</span>
<span class="line-modified">2473     } else {</span>
<span class="line-modified">2474       ResourceMark rm(THREAD);</span>
<span class="line-modified">2475       stringStream ss;</span>
<span class="line-modified">2476       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="line-modified">2477       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-modified">2478                v-&gt;klass()-&gt;external_name(),</span>
<span class="line-modified">2479                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="line-modified">2480                index);</span>
<span class="line-modified">2481       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-modified">2482         ss.print(&quot;[]&quot;);</span>
<span class="line-modified">2483       }</span>
<span class="line-modified">2484       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-modified">2485     }</span>
<span class="line-modified">2486   } else {</span>
<span class="line-modified">2487     ResourceMark rm(THREAD);</span>
<span class="line-modified">2488     stringStream ss;</span>
<span class="line-modified">2489     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
<span class="line-modified">2490     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="line-modified">2491   }</span>



























2492 JNI_END
2493 
2494 
2495 
2496 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2497                               ,EntryProbe,ReturnProbe)  \
2498 \
2499   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2500                       , ReturnProbe); \
2501 \
2502 JNI_ENTRY(Return, \
2503           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2504   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2505   EntryProbe; \
2506   Return ret = NULL;\
2507   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2508 \
2509   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2510   ret = (Return) JNIHandles::make_local(env, obj); \
2511   return ret;\
</pre>
<hr />
<pre>
3258   return CurrentVersion;
3259 JNI_END
3260 
3261 extern struct JavaVM_ main_vm;
3262 
3263 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3264   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3265   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3266   *vm  = (JavaVM *)(&amp;main_vm);
3267   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3268   return JNI_OK;
3269 JNI_END
3270 
3271 
3272 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3273   JNIWrapper(&quot;GetModule&quot;);
3274   return Modules::get_module(clazz, THREAD);
3275 JNI_END
3276 
3277 



















































































































































































































































































3278 // Structure containing all jni functions
3279 struct JNINativeInterface_ jni_NativeInterface = {
3280     NULL,
3281     NULL,
3282     NULL,
3283 
3284     NULL,
3285 
3286     jni_GetVersion,
3287 
3288     jni_DefineClass,
3289     jni_FindClass,
3290 
3291     jni_FromReflectedMethod,
3292     jni_FromReflectedField,
3293 
3294     jni_ToReflectedMethod,
3295 
3296     jni_GetSuperclass,
3297     jni_IsAssignableFrom,
</pre>
<hr />
<pre>
3541     jni_ReleasePrimitiveArrayCritical,
3542 
3543     jni_GetStringCritical,
3544     jni_ReleaseStringCritical,
3545 
3546     jni_NewWeakGlobalRef,
3547     jni_DeleteWeakGlobalRef,
3548 
3549     jni_ExceptionCheck,
3550 
3551     jni_NewDirectByteBuffer,
3552     jni_GetDirectBufferAddress,
3553     jni_GetDirectBufferCapacity,
3554 
3555     // New 1_6 features
3556 
3557     jni_GetObjectRefType,
3558 
3559     // Module features
3560 
<span class="line-modified">3561     jni_GetModule</span>































3562 };
3563 
3564 
3565 // For jvmti use to modify jni function table.
3566 // Java threads in native contiues to run until it is transitioned
3567 // to VM at safepoint. Before the transition or before it is blocked
3568 // for safepoint it may access jni function table. VM could crash if
3569 // any java thread access the jni function table in the middle of memcpy.
3570 // To avoid this each function pointers are copied automically.
3571 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3572   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3573   intptr_t *a = (intptr_t *) jni_functions();
3574   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3575   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3576     Atomic::store(a++, *b++);
3577   }
3578 }
3579 
3580 void quicken_jni_functions() {
3581   // Replace Get&lt;Primitive&gt;Field with fast versions
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="line-added">  63 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
 461   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 462 
 463   // Make sure class is initialized before handing id&#39;s out to fields
 464   k1-&gt;initialize(CHECK_NULL);
 465 
 466   // First check if this is a static field
 467   if (modifiers &amp; JVM_ACC_STATIC) {
 468     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 469     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 470     assert(id != NULL, &quot;corrupt Field object&quot;);
 471     debug_only(id-&gt;set_is_static_field_id();)
 472     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 473     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 474     return ret;
 475   }
 476 
 477   // The slot is the index of the field description in the field-array
 478   // The jfieldID is the offset of the field within the object
 479   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 480   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
<span class="line-added"> 481   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);</span>
 482   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
<span class="line-modified"> 483   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);</span>
 484   return ret;
 485 JNI_END
 486 
 487 
 488 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 489                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 490 
 491 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 492   JNIWrapper(&quot;ToReflectedMethod&quot;);
 493 
 494   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 495 
 496   jobject ret = NULL;
 497   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 498 
 499   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 500   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 501   oop reflection_method;
<span class="line-modified"> 502   if (m-&gt;is_object_constructor()) {</span>
 503     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 504   } else {
 505     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 506   }
 507   ret = JNIHandles::make_local(env, reflection_method);
 508   return ret;
 509 JNI_END
 510 
 511 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 512                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 513 
 514 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 515   JNIWrapper(&quot;GetSuperclass&quot;);
 516 
 517   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 518 
 519   jclass obj = NULL;
 520   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 521 
 522   oop mirror = JNIHandles::resolve_non_null(sub);
</pre>
<hr />
<pre>
 544 
 545 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 546   JNIWrapper(&quot;IsSubclassOf&quot;);
 547 
 548   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 549 
 550   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 551   oop super_mirror = JNIHandles::resolve_non_null(super);
 552   if (java_lang_Class::is_primitive(sub_mirror) ||
 553       java_lang_Class::is_primitive(super_mirror)) {
 554     jboolean ret = (sub_mirror == super_mirror);
 555 
 556     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 557     return ret;
 558   }
 559   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 560   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 561   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 562   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 563                    JNI_TRUE : JNI_FALSE;

 564   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 565   return ret;
 566 JNI_END
 567 
 568 
 569 DT_RETURN_MARK_DECL(Throw, jint
 570                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 571 
 572 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 573   JNIWrapper(&quot;Throw&quot;);
 574 
 575   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 576 
 577   jint ret = JNI_OK;
 578   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 579 
 580   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 581   ShouldNotReachHere();
 582   return 0;  // Mute compiler.
 583 JNI_END
</pre>
<hr />
<pre>
 878   }
 879 
 880   friend class SignatureIterator;  // so do_parameters_on can call do_type
 881   void do_type(BasicType type) {
 882     switch (type) {
 883     // these are coerced to int when using va_arg
 884     case T_BYTE:
 885     case T_CHAR:
 886     case T_SHORT:
 887     case T_INT:         push_int(va_arg(_ap, jint)); break;
 888     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 889 
 890     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 891 
 892     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 893     // float is coerced to double w/ va_arg
 894     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 895     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 896 
 897     case T_ARRAY:
<span class="line-modified"> 898     case T_OBJECT:</span>
<span class="line-added"> 899     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;</span>
 900     default:            ShouldNotReachHere();
 901     }
 902   }
 903 
 904  public:
 905   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 906       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 907     set_ap(rap);
 908   }
 909 
 910   virtual void push_arguments_on(JavaCallArguments* arguments) {
 911     _arguments = arguments;
 912     do_parameters_on(this);
 913   }
 914 };
 915 
 916 
 917 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 918  protected:
 919   const jvalue *_ap;
 920 
 921   inline void set_ap(const jvalue *rap) { _ap = rap; }
 922 
 923   friend class SignatureIterator;  // so do_parameters_on can call do_type
 924   void do_type(BasicType type) {
 925     switch (type) {
 926     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 927     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 928     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 929     case T_INT:         push_int((_ap++)-&gt;i); break;
 930     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 931     case T_LONG:        push_long((_ap++)-&gt;j); break;
 932     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 933     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 934     case T_ARRAY:
<span class="line-modified"> 935     case T_OBJECT:</span>
<span class="line-added"> 936     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;</span>
 937     default:            ShouldNotReachHere();
 938     }
 939   }
 940 
 941  public:
 942   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 943       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 944     set_ap(rap);
 945   }
 946 
 947   virtual void push_arguments_on(JavaCallArguments* arguments) {
 948     _arguments = arguments;
 949     do_parameters_on(this);
 950   }
 951 };
 952 
 953 
 954 enum JNICallType {
 955   JNI_STATIC,
 956   JNI_VIRTUAL,
</pre>
<hr />
<pre>
1056 
1057   jobject ret = NULL;
1058   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1059 
1060   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1061   ret = JNIHandles::make_local(env, i);
1062   return ret;
1063 JNI_END
1064 
1065 DT_RETURN_MARK_DECL(NewObjectA, jobject
1066                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1067 
1068 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1069   JNIWrapper(&quot;NewObjectA&quot;);
1070 
1071   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1072 
1073   jobject obj = NULL;
1074   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1075 
<span class="line-modified">1076   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1077   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1078   if (k == NULL) {</span>
<span class="line-modified">1079     ResourceMark rm(THREAD);</span>
<span class="line-modified">1080     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-added">1081   }</span>
<span class="line-added">1082 </span>
<span class="line-added">1083   if (!k-&gt;is_value()) {</span>
<span class="line-added">1084     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1085     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1086     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1087     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-added">1088     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1089   } else {</span>
<span class="line-added">1090     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1091     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-added">1092     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1093     obj = jvalue.get_jobject();</span>
<span class="line-added">1094   }</span>
1095   return obj;
<span class="line-modified">1096   JNI_END</span>
1097 
1098 
1099 DT_RETURN_MARK_DECL(NewObjectV, jobject
1100                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1101 
1102 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1103   JNIWrapper(&quot;NewObjectV&quot;);
1104 
1105   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1106 
1107   jobject obj = NULL;
1108   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1109 
<span class="line-modified">1110   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1111   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1112   if (k == NULL) {</span>
<span class="line-modified">1113     ResourceMark rm(THREAD);</span>
<span class="line-modified">1114     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-added">1115   }</span>
<span class="line-added">1116 </span>
<span class="line-added">1117   if (!k-&gt;is_value()) {</span>
<span class="line-added">1118     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1119     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1120     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1121     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1122     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1123   } else {</span>
<span class="line-added">1124     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1125     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1126     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1127     obj = jvalue.get_jobject();</span>
<span class="line-added">1128   }</span>
1129   return obj;
1130 JNI_END
1131 
1132 
1133 DT_RETURN_MARK_DECL(NewObject, jobject
1134                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1135 
1136 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1137   JNIWrapper(&quot;NewObject&quot;);
1138 
1139   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1140 
1141   jobject obj = NULL;
1142   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1143 
<span class="line-modified">1144   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1145   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1146   if (k == NULL) {</span>
<span class="line-modified">1147     ResourceMark rm(THREAD);</span>
<span class="line-modified">1148     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-modified">1149   }</span>
<span class="line-modified">1150 </span>
<span class="line-modified">1151   if (!k-&gt;is_value()) {</span>
<span class="line-added">1152     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1153     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1154     va_list args;</span>
<span class="line-added">1155     va_start(args, methodID);</span>
<span class="line-added">1156     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1157     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1158     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1159     va_end(args);</span>
<span class="line-added">1160   } else {</span>
<span class="line-added">1161     va_list args;</span>
<span class="line-added">1162     va_start(args, methodID);</span>
<span class="line-added">1163     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1164     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1165     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1166     va_end(args);</span>
<span class="line-added">1167     obj = jvalue.get_jobject();</span>
<span class="line-added">1168   }</span>
1169   return obj;
1170 JNI_END
1171 
1172 
1173 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1174   JNIWrapper(&quot;GetObjectClass&quot;);
1175 
1176   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1177 
1178   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1179   jclass ret =
1180     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1181 
1182   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1183   return ret;
1184 JNI_END
1185 
1186 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1187   JNIWrapper(&quot;IsInstanceOf&quot;);
1188 
</pre>
<hr />
<pre>
1925   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1926   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1927   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1928   if (fieldname == NULL || signame == NULL) {
1929     ResourceMark rm;
1930     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1931   }
1932 
1933   // Make sure class is initialized before handing id&#39;s out to fields
1934   k-&gt;initialize(CHECK_NULL);
1935 
1936   fieldDescriptor fd;
1937   if (!k-&gt;is_instance_klass() ||
1938       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1939     ResourceMark rm;
1940     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1941   }
1942 
1943   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1944   // It may also have hash bits for k, if VerifyJNIFields is turned on.
<span class="line-modified">1945   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());</span>
1946   return ret;
1947 JNI_END
1948 
1949 
1950 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1951   JNIWrapper(&quot;GetObjectField&quot;);
1952   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1953   oop o = JNIHandles::resolve_non_null(obj);
1954   Klass* k = o-&gt;klass();
1955   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
<span class="line-added">1956   oop res = NULL;</span>
1957   // Keep JVMTI addition small and only check enabled flag here.
1958   // jni_GetField_probe() assumes that is okay to create handles.
1959   if (JvmtiExport::should_post_field_access()) {
1960     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1961   }
<span class="line-modified">1962   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="line-modified">1963     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="line-added">1964   } else {</span>
<span class="line-added">1965     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);</span>
<span class="line-added">1966     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">1967     fieldDescriptor fd;</span>
<span class="line-added">1968     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck</span>
<span class="line-added">1969     InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">1970     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="line-added">1971     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);</span>
<span class="line-added">1972   }</span>
<span class="line-added">1973   jobject ret = JNIHandles::make_local(env, res);</span>
1974   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1975   return ret;
1976 JNI_END
1977 
1978 
1979 
1980 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1981   , EntryProbe, ReturnProbe) \
1982 \
1983   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1984   , ReturnProbe); \
1985 \
1986 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
1987   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1988 \
1989   EntryProbe; \
1990   Return ret = 0;\
1991   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1992 \
1993   oop o = JNIHandles::resolve_non_null(obj); \
</pre>
<hr />
<pre>
2051   return (address)jni_GetFloatField;
2052 }
2053 address jni_GetDoubleField_addr() {
2054   return (address)jni_GetDoubleField;
2055 }
2056 
2057 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2058   JNIWrapper(&quot;SetObjectField&quot;);
2059   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2060   oop o = JNIHandles::resolve_non_null(obj);
2061   Klass* k = o-&gt;klass();
2062   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2063   // Keep JVMTI addition small and only check enabled flag here.
2064   // jni_SetField_probe_nh() assumes that is not okay to create handles
2065   // and creates a ResetNoHandleMark.
2066   if (JvmtiExport::should_post_field_modification()) {
2067     jvalue field_value;
2068     field_value.l = value;
2069     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2070   }
<span class="line-modified">2071   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="line-added">2072     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>
<span class="line-added">2073   } else {</span>
<span class="line-added">2074     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);</span>
<span class="line-added">2075     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">2076     fieldDescriptor fd;</span>
<span class="line-added">2077     ik-&gt;find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">2078     InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">2079     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="line-added">2080     oop v = JNIHandles::resolve_non_null(value);</span>
<span class="line-added">2081     vklass-&gt;write_flattened_field(o, offset, v, CHECK);</span>
<span class="line-added">2082   }</span>
2083   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2084 JNI_END
2085 
2086 
2087 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2088                         , EntryProbe, ReturnProbe) \
2089 \
2090 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2091   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2092 \
2093   EntryProbe; \
2094 \
2095   oop o = JNIHandles::resolve_non_null(obj); \
2096   Klass* k = o-&gt;klass(); \
2097   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2098   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2099   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2100   /* and creates a ResetNoHandleMark.                                   */ \
2101   if (JvmtiExport::should_post_field_modification()) { \
2102     jvalue field_value; \
</pre>
<hr />
<pre>
2499   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2500   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2501   oop initial_value = JNIHandles::resolve(initialElement);
2502   if (initial_value != NULL) {  // array already initialized with NULL
2503     for (int index = 0; index &lt; length; index++) {
2504       result-&gt;obj_at_put(index, initial_value);
2505     }
2506   }
2507   ret = (jobjectArray) JNIHandles::make_local(env, result);
2508   return ret;
2509 JNI_END
2510 
2511 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2512                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2513 
2514 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2515   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2516  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2517   jobject ret = NULL;
2518   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
<span class="line-modified">2519   oop res = NULL;</span>
<span class="line-modified">2520   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2521   if (arr-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2522     if (arr-&gt;is_valueArray()) {</span>
<span class="line-added">2523       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2524       arrayHandle ah(THREAD, a);</span>
<span class="line-added">2525       valueArrayHandle vah(thread, a);</span>
<span class="line-added">2526       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);</span>
<span class="line-added">2527       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);</span>
<span class="line-added">2528     } else {</span>
<span class="line-added">2529       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="line-added">2530       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2531       res = a-&gt;obj_at(index);</span>
<span class="line-added">2532     }</span>
2533   } else {
2534     ResourceMark rm(THREAD);
2535     stringStream ss;
<span class="line-modified">2536     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());</span>
2537     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2538   }
<span class="line-added">2539   ret = JNIHandles::make_local(env, res);</span>
<span class="line-added">2540   return ret;</span>
2541 JNI_END
2542 
2543 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2544                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2545 
2546 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2547   JNIWrapper(&quot;SetObjectArrayElement&quot;);
<span class="line-modified">2548   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
2549   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2550 
<span class="line-modified">2551    bool oob = false;</span>
<span class="line-modified">2552    int length = -1;</span>
<span class="line-modified">2553    oop res = NULL;</span>
<span class="line-modified">2554    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2555    if (arr-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2556      if (arr-&gt;is_valueArray()) {</span>
<span class="line-modified">2557        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2558        oop v = JNIHandles::resolve(value);</span>
<span class="line-modified">2559        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-modified">2560        ValueKlass* element_vklass = vaklass-&gt;element_klass();</span>
<span class="line-modified">2561        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {</span>
<span class="line-modified">2562          a-&gt;value_copy_to_index(v, index);</span>
<span class="line-modified">2563        } else {</span>
<span class="line-modified">2564          ResourceMark rm(THREAD);</span>
<span class="line-modified">2565          stringStream ss;</span>
<span class="line-modified">2566          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-modified">2567          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-modified">2568              v-&gt;klass()-&gt;external_name(),</span>
<span class="line-modified">2569              kl-&gt;external_name(),</span>
<span class="line-modified">2570              index);</span>
<span class="line-modified">2571          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-modified">2572            ss.print(&quot;[]&quot;);</span>
<span class="line-modified">2573          }</span>
<span class="line-modified">2574          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-added">2575        }</span>
<span class="line-added">2576      } else {</span>
<span class="line-added">2577        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="line-added">2578        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2579        oop v = JNIHandles::resolve(value);</span>
<span class="line-added">2580        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="line-added">2581          a-&gt;obj_at_put(index, v);</span>
<span class="line-added">2582        } else {</span>
<span class="line-added">2583          ResourceMark rm(THREAD);</span>
<span class="line-added">2584          stringStream ss;</span>
<span class="line-added">2585          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="line-added">2586          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-added">2587              v-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">2588              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="line-added">2589                  index);</span>
<span class="line-added">2590          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-added">2591            ss.print(&quot;[]&quot;);</span>
<span class="line-added">2592          }</span>
<span class="line-added">2593          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-added">2594        }</span>
<span class="line-added">2595      }</span>
<span class="line-added">2596    } else {</span>
<span class="line-added">2597      ResourceMark rm(THREAD);</span>
<span class="line-added">2598      stringStream ss;</span>
<span class="line-added">2599      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());</span>
<span class="line-added">2600      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="line-added">2601    }</span>
2602 JNI_END
2603 
2604 
2605 
2606 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2607                               ,EntryProbe,ReturnProbe)  \
2608 \
2609   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2610                       , ReturnProbe); \
2611 \
2612 JNI_ENTRY(Return, \
2613           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2614   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2615   EntryProbe; \
2616   Return ret = NULL;\
2617   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2618 \
2619   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2620   ret = (Return) JNIHandles::make_local(env, obj); \
2621   return ret;\
</pre>
<hr />
<pre>
3368   return CurrentVersion;
3369 JNI_END
3370 
3371 extern struct JavaVM_ main_vm;
3372 
3373 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3374   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3375   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3376   *vm  = (JavaVM *)(&amp;main_vm);
3377   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3378   return JNI_OK;
3379 JNI_END
3380 
3381 
3382 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3383   JNIWrapper(&quot;GetModule&quot;);
3384   return Modules::get_module(clazz, THREAD);
3385 JNI_END
3386 
3387 
<span class="line-added">3388 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))</span>
<span class="line-added">3389   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);</span>
<span class="line-added">3390   if (isCopy != NULL) {</span>
<span class="line-added">3391     *isCopy = JNI_FALSE;</span>
<span class="line-added">3392   }</span>
<span class="line-added">3393   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3394   if (!ar-&gt;is_array()) {</span>
<span class="line-added">3395     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3396   }</span>
<span class="line-added">3397   if (!ar-&gt;is_valueArray()) {</span>
<span class="line-added">3398     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3399   }</span>
<span class="line-added">3400   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3401   if (vak-&gt;contains_oops()) {</span>
<span class="line-added">3402     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);</span>
<span class="line-added">3403   }</span>
<span class="line-added">3404   oop a = lock_gc_or_pin_object(thread, array);</span>
<span class="line-added">3405   valueArrayOop vap = valueArrayOop(a);</span>
<span class="line-added">3406   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());</span>
<span class="line-added">3407   return ret;</span>
<span class="line-added">3408 JNI_END</span>
<span class="line-added">3409 </span>
<span class="line-added">3410 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))</span>
<span class="line-added">3411   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);</span>
<span class="line-added">3412   unlock_gc_or_unpin_object(thread, array);</span>
<span class="line-added">3413 JNI_END</span>
<span class="line-added">3414 </span>
<span class="line-added">3415 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {</span>
<span class="line-added">3416   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);</span>
<span class="line-added">3417   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3418   if (!a-&gt;is_array()) {</span>
<span class="line-added">3419     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3420   }</span>
<span class="line-added">3421   if (!a-&gt;is_valueArray()) {</span>
<span class="line-added">3422     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3423   }</span>
<span class="line-added">3424   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-added">3425   jsize ret = vak-&gt;element_byte_size();</span>
<span class="line-added">3426   return ret;</span>
<span class="line-added">3427 }</span>
<span class="line-added">3428 JNI_END</span>
<span class="line-added">3429 </span>
<span class="line-added">3430 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))</span>
<span class="line-added">3431   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);</span>
<span class="line-added">3432   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3433   if (!a-&gt;is_array()) {</span>
<span class="line-added">3434     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3435   }</span>
<span class="line-added">3436   if (!a-&gt;is_valueArray()) {</span>
<span class="line-added">3437     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3438   }</span>
<span class="line-added">3439   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-added">3440   ValueKlass* vk = vak-&gt;element_klass();</span>
<span class="line-added">3441   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());</span>
<span class="line-added">3442 JNI_END</span>
<span class="line-added">3443 </span>
<span class="line-added">3444 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))</span>
<span class="line-added">3445   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);</span>
<span class="line-added">3446 </span>
<span class="line-added">3447   oop mirror = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-added">3448   Klass* k = java_lang_Class::as_Klass(mirror);</span>
<span class="line-added">3449   if (!k-&gt;is_value()) {</span>
<span class="line-added">3450     ResourceMark rm;</span>
<span class="line-added">3451         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));</span>
<span class="line-added">3452   }</span>
<span class="line-added">3453   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added">3454 </span>
<span class="line-added">3455   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-added">3456   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-added">3457   if (fieldname == NULL || signame == NULL) {</span>
<span class="line-added">3458     ResourceMark rm;</span>
<span class="line-added">3459     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="line-added">3460   }</span>
<span class="line-added">3461 </span>
<span class="line-added">3462   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="line-added">3463 </span>
<span class="line-added">3464   fieldDescriptor fd;</span>
<span class="line-added">3465   if (!vk-&gt;is_instance_klass() ||</span>
<span class="line-added">3466       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {</span>
<span class="line-added">3467     ResourceMark rm;</span>
<span class="line-added">3468     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="line-added">3469   }</span>
<span class="line-added">3470 </span>
<span class="line-added">3471   int offset = fd.offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">3472   if (isFlattened != NULL) {</span>
<span class="line-added">3473     *isFlattened = fd.is_flattened();</span>
<span class="line-added">3474   }</span>
<span class="line-added">3475   return (jsize)offset;</span>
<span class="line-added">3476 JNI_END</span>
<span class="line-added">3477 </span>
<span class="line-added">3478 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))</span>
<span class="line-added">3479   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);</span>
<span class="line-added">3480 </span>
<span class="line-added">3481   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3482   if (!ar-&gt;is_array()) {</span>
<span class="line-added">3483     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3484   }</span>
<span class="line-added">3485   if (!ar-&gt;is_valueArray()) {</span>
<span class="line-added">3486     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3487   }</span>
<span class="line-added">3488   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),</span>
<span class="line-added">3489         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);</span>
<span class="line-added">3490   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);</span>
<span class="line-added">3491   ses_ik-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">3492   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();</span>
<span class="line-added">3493   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3494   Handle ses_h(THREAD, ses);</span>
<span class="line-added">3495   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="line-added">3496   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="line-added">3497   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);</span>
<span class="line-added">3498   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened</span>
<span class="line-added">3499   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable</span>
<span class="line-added">3500   return JNIHandles::make_local(ses_h());</span>
<span class="line-added">3501 JNI_END</span>
<span class="line-added">3502 </span>
<span class="line-added">3503 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))</span>
<span class="line-added">3504   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);</span>
<span class="line-added">3505 </span>
<span class="line-added">3506   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3507   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {</span>
<span class="line-added">3508     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);</span>
<span class="line-added">3509   }</span>
<span class="line-added">3510   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);</span>
<span class="line-added">3511   if (!isflattened) {</span>
<span class="line-added">3512     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);</span>
<span class="line-added">3513   }</span>
<span class="line-added">3514   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);</span>
<span class="line-added">3515   Klass* k = java_lang_Class::as_Klass(semirror);</span>
<span class="line-added">3516   if (!k-&gt;is_value()) {</span>
<span class="line-added">3517     ResourceMark rm;</span>
<span class="line-added">3518         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));</span>
<span class="line-added">3519   }</span>
<span class="line-added">3520   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added">3521   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="line-added">3522   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);</span>
<span class="line-added">3523   fieldDescriptor fd;</span>
<span class="line-added">3524   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {</span>
<span class="line-added">3525     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());</span>
<span class="line-added">3526   }</span>
<span class="line-added">3527   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));</span>
<span class="line-added">3528   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element</span>
<span class="line-added">3529   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3530   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());</span>
<span class="line-added">3531   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3532   Handle res_h(THREAD, res);</span>
<span class="line-added">3533   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());</span>
<span class="line-added">3534   InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">3535   BasicType bt = Signature::basic_type(fd.signature());</span>
<span class="line-added">3536   if (is_java_primitive(bt)) {</span>
<span class="line-added">3537     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));</span>
<span class="line-added">3538   } else {</span>
<span class="line-added">3539     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),</span>
<span class="line-added">3540         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);</span>
<span class="line-added">3541     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());</span>
<span class="line-added">3542   }</span>
<span class="line-added">3543   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);</span>
<span class="line-added">3544   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());</span>
<span class="line-added">3545   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());</span>
<span class="line-added">3546   return JNIHandles::make_local(res_h());</span>
<span class="line-added">3547 JNI_END</span>
<span class="line-added">3548 </span>
<span class="line-added">3549 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))</span>
<span class="line-added">3550   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);</span>
<span class="line-added">3551 </span>
<span class="line-added">3552   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3553   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3554   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3555   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="line-added">3556     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="line-added">3557   }</span>
<span class="line-added">3558   oop res = NULL;</span>
<span class="line-added">3559   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="line-added">3560     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="line-added">3561                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3562     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);</span>
<span class="line-added">3563   } else {</span>
<span class="line-added">3564     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="line-added">3565     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3566     // The array might have been moved by the GC, refreshing the arrayOop</span>
<span class="line-added">3567     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3568     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="line-added">3569               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3570     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);</span>
<span class="line-added">3571   }</span>
<span class="line-added">3572   return JNIHandles::make_local(res);</span>
<span class="line-added">3573 JNI_END</span>
<span class="line-added">3574 </span>
<span class="line-added">3575 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))</span>
<span class="line-added">3576   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);</span>
<span class="line-added">3577 </span>
<span class="line-added">3578   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3579   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3580   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3581   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="line-added">3582     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="line-added">3583   }</span>
<span class="line-added">3584   oop val = JNIHandles::resolve(value);</span>
<span class="line-added">3585   if (val == NULL) {</span>
<span class="line-added">3586     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {</span>
<span class="line-added">3587       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);</span>
<span class="line-added">3588     }</span>
<span class="line-added">3589   } else {</span>
<span class="line-added">3590     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {</span>
<span class="line-added">3591       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);</span>
<span class="line-added">3592     }</span>
<span class="line-added">3593   }</span>
<span class="line-added">3594   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="line-added">3595     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="line-added">3596                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3597     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));</span>
<span class="line-added">3598   } else {</span>
<span class="line-added">3599     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="line-added">3600     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="line-added">3601                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3602     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);</span>
<span class="line-added">3603   }</span>
<span class="line-added">3604 JNI_END</span>
<span class="line-added">3605 </span>
<span class="line-added">3606 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="line-added">3607 \</span>
<span class="line-added">3608 JNI_ENTRY(ElementType, \</span>
<span class="line-added">3609           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \</span>
<span class="line-added">3610   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="line-added">3611   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="line-added">3612   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="line-added">3613   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="line-added">3614   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="line-added">3615     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="line-added">3616   } \</span>
<span class="line-added">3617   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="line-added">3618     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="line-added">3619   } \</span>
<span class="line-added">3620   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="line-added">3621                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="line-added">3622   ElementType result = *(ElementType*)addr; \</span>
<span class="line-added">3623   return result; \</span>
<span class="line-added">3624 JNI_END</span>
<span class="line-added">3625 </span>
<span class="line-added">3626 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="line-added">3627 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="line-added">3628 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="line-added">3629 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="line-added">3630 DEFINE_GETSUBELEMENT(jint, Int,T_INT)</span>
<span class="line-added">3631 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="line-added">3632 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="line-added">3633 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="line-added">3634 </span>
<span class="line-added">3635 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="line-added">3636 \</span>
<span class="line-added">3637 JNI_ENTRY(void, \</span>
<span class="line-added">3638           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \</span>
<span class="line-added">3639   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="line-added">3640   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="line-added">3641   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="line-added">3642   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="line-added">3643   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="line-added">3644     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="line-added">3645   } \</span>
<span class="line-added">3646   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="line-added">3647     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="line-added">3648   } \</span>
<span class="line-added">3649   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="line-added">3650                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="line-added">3651   *(ElementType*)addr = value; \</span>
<span class="line-added">3652 JNI_END</span>
<span class="line-added">3653 </span>
<span class="line-added">3654 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="line-added">3655 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="line-added">3656 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="line-added">3657 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="line-added">3658 DEFINE_SETSUBELEMENT(jint, Int,T_INT)</span>
<span class="line-added">3659 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="line-added">3660 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="line-added">3661 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="line-added">3662 </span>
3663 // Structure containing all jni functions
3664 struct JNINativeInterface_ jni_NativeInterface = {
3665     NULL,
3666     NULL,
3667     NULL,
3668 
3669     NULL,
3670 
3671     jni_GetVersion,
3672 
3673     jni_DefineClass,
3674     jni_FindClass,
3675 
3676     jni_FromReflectedMethod,
3677     jni_FromReflectedField,
3678 
3679     jni_ToReflectedMethod,
3680 
3681     jni_GetSuperclass,
3682     jni_IsAssignableFrom,
</pre>
<hr />
<pre>
3926     jni_ReleasePrimitiveArrayCritical,
3927 
3928     jni_GetStringCritical,
3929     jni_ReleaseStringCritical,
3930 
3931     jni_NewWeakGlobalRef,
3932     jni_DeleteWeakGlobalRef,
3933 
3934     jni_ExceptionCheck,
3935 
3936     jni_NewDirectByteBuffer,
3937     jni_GetDirectBufferAddress,
3938     jni_GetDirectBufferCapacity,
3939 
3940     // New 1_6 features
3941 
3942     jni_GetObjectRefType,
3943 
3944     // Module features
3945 
<span class="line-modified">3946     jni_GetModule,</span>
<span class="line-added">3947 </span>
<span class="line-added">3948     // Flattened arrays features</span>
<span class="line-added">3949 </span>
<span class="line-added">3950     jni_GetFlattenedArrayElements,</span>
<span class="line-added">3951     jni_ReleaseFlattenedArrayElements,</span>
<span class="line-added">3952     jni_GetFlattenedArrayElementClass,</span>
<span class="line-added">3953     jni_GetFlattenedArrayElementSize,</span>
<span class="line-added">3954     jni_GetFieldOffsetInFlattenedLayout,</span>
<span class="line-added">3955 </span>
<span class="line-added">3956     jni_CreateSubElementSelector,</span>
<span class="line-added">3957     jni_GetSubElementSelector,</span>
<span class="line-added">3958     jni_GetObjectSubElement,</span>
<span class="line-added">3959     jni_SetObjectSubElement,</span>
<span class="line-added">3960 </span>
<span class="line-added">3961     jni_GetBooleanSubElement,</span>
<span class="line-added">3962     jni_GetByteSubElement,</span>
<span class="line-added">3963     jni_GetShortSubElement,</span>
<span class="line-added">3964     jni_GetCharSubElement,</span>
<span class="line-added">3965     jni_GetIntSubElement,</span>
<span class="line-added">3966     jni_GetLongSubElement,</span>
<span class="line-added">3967     jni_GetFloatSubElement,</span>
<span class="line-added">3968     jni_GetDoubleSubElement,</span>
<span class="line-added">3969 </span>
<span class="line-added">3970     jni_SetBooleanSubElement,</span>
<span class="line-added">3971     jni_SetByteSubElement,</span>
<span class="line-added">3972     jni_SetShortSubElement,</span>
<span class="line-added">3973     jni_SetCharSubElement,</span>
<span class="line-added">3974     jni_SetIntSubElement,</span>
<span class="line-added">3975     jni_SetLongSubElement,</span>
<span class="line-added">3976     jni_SetFloatSubElement,</span>
<span class="line-added">3977     jni_SetDoubleSubElement</span>
3978 };
3979 
3980 
3981 // For jvmti use to modify jni function table.
3982 // Java threads in native contiues to run until it is transitioned
3983 // to VM at safepoint. Before the transition or before it is blocked
3984 // for safepoint it may access jni function table. VM could crash if
3985 // any java thread access the jni function table in the middle of memcpy.
3986 // To avoid this each function pointers are copied automically.
3987 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3988   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3989   intptr_t *a = (intptr_t *) jni_functions();
3990   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3991   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3992     Atomic::store(a++, *b++);
3993   }
3994 }
3995 
3996 void quicken_jni_functions() {
3997   // Replace Get&lt;Primitive&gt;Field with fast versions
</pre>
</td>
</tr>
</table>
<center><a href="../precompiled/precompiled.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniCheck.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
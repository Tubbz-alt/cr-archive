<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;

  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  70 #include &quot;prims/jvmtiThreadState.hpp&quot;
  71 #include &quot;prims/methodComparator.hpp&quot;
  72 #include &quot;runtime/atomic.hpp&quot;
  73 #include &quot;runtime/biasedLocking.hpp&quot;
  74 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/javaCalls.hpp&quot;
  77 #include &quot;runtime/mutexLocker.hpp&quot;
  78 #include &quot;runtime/orderAccess.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;services/classLoadingService.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #include &quot;utilities/dtrace.hpp&quot;
  83 #include &quot;utilities/events.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stringUtils.hpp&quot;
  86 #ifdef COMPILER1
  87 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 405                               k-&gt;external_name());
 406   return access;
 407 }
 408 
 409 const char* InstanceKlass::nest_host_error(TRAPS) {
 410   if (_nest_host_index == 0) {
 411     return NULL;
 412   } else {
 413     constantPoolHandle cph(THREAD, constants());
 414     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 415   }
 416 }
 417 
 418 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 419   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 420   const int size = InstanceKlass::size(parser.vtable_size(),
 421                                        parser.itable_size(),
 422                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 423                                        parser.is_interface(),
 424                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 425                                        should_store_fingerprint(is_hidden_or_anonymous));</span>


 426 
 427   const Symbol* const class_name = parser.class_name();
 428   assert(class_name != NULL, &quot;invariant&quot;);
 429   ClassLoaderData* loader_data = parser.loader_data();
 430   assert(loader_data != NULL, &quot;invariant&quot;);
 431 
 432   InstanceKlass* ik;
 433 
 434   // Allocation
 435   if (REF_NONE == parser.reference_type()) {
 436     if (class_name == vmSymbols::java_lang_Class()) {
 437       // mirror
 438       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 439     }</span>
<span class="line-removed"> 440     else if (is_class_loader(class_name, parser)) {</span>
 441       // class loader
 442       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);



 443     } else {
 444       // normal
 445       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 446     }
 447   } else {
 448     // reference
 449     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 450   }
 451 
 452   // Check for pending exception before adding to the loader data and incrementing
 453   // class count.  Can get OOM here.
 454   if (HAS_PENDING_EXCEPTION) {
 455     return NULL;
 456   }
 457 







 458   return ik;
 459 }
 460 























 461 
 462 // copy method ordering from resource area to Metaspace
 463 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 464   if (m != NULL) {
 465     // allocate a new array and copy contents (memcpy?)
 466     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 467     for (int i = 0; i &lt; m-&gt;length(); i++) {
 468       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 469     }
 470   } else {
 471     _method_ordering = Universe::the_empty_int_array();
 472   }
 473 }
 474 
 475 // create a new array of vtable_indices for default methods
 476 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 477   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 478   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 479   set_default_vtable_indices(vtable_indices);
 480   return vtable_indices;
 481 }
 482 
 483 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 484   Klass(id),
 485   _nest_members(NULL),
 486   _nest_host(NULL),
 487   _record_components(NULL),
 488   _static_field_size(parser.static_field_size()),
 489   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 490   _itable_len(parser.itable_size()),
 491   _nest_host_index(0),
 492   _init_state(allocated),
 493   _reference_type(parser.reference_type()),
<span class="line-modified"> 494   _init_thread(NULL)</span>


 495 {
 496   set_vtable_length(parser.vtable_size());
 497   set_kind(kind);
 498   set_access_flags(parser.access_flags());
 499   if (parser.is_hidden()) set_is_hidden();
 500   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 501   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 502                                                     false));




 503 
<span class="line-modified"> 504   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 505   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 506   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 507 
 508   // Set biased locking bit for all instances of this class; it will be
 509   // cleared if revocation occurs too often for this type
 510   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 511     set_prototype_header(markWord::biased_locking_prototype());
 512   }



 513 }
 514 
 515 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 516                                        Array&lt;Method*&gt;* methods) {
 517   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 518       !methods-&gt;is_shared()) {
 519     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 520       Method* method = methods-&gt;at(i);
 521       if (method == NULL) continue;  // maybe null if error processing
 522       // Only want to delete methods that are not executing for RedefineClasses.
 523       // The previous version will point to them so they&#39;re not totally dangling
 524       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 525       MetadataFactory::free_metadata(loader_data, method);
 526     }
 527     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 528   }
 529 }
 530 
 531 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 532                                           const Klass* super_klass,
 533                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 534                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 535   // Only deallocate transitive interfaces if not empty, same as super class
 536   // or same as local interfaces.  See code in parseClassFile.
 537   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 538   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 539     // check that the interfaces don&#39;t come from super class
 540     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 541                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 542     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {</span>

 543       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 544     }
 545   }
 546 
 547   // local interfaces can be empty
 548   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 549       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {</span>

 550     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 551   }
 552 }
 553 
 554 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 555                                                  Array&lt;RecordComponent*&gt;* record_components) {
 556   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 557     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 558       RecordComponent* record_component = record_components-&gt;at(i);
 559       MetadataFactory::free_metadata(loader_data, record_component);
 560     }
 561     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 562   }
 563 }
 564 
 565 // This function deallocates the metadata and C heap pointers that the
 566 // InstanceKlass points to.
 567 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 568 
 569   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 844         vmSymbols::java_lang_IncompatibleClassChangeError(),
 845         &quot;class %s has interface %s as super class&quot;,
 846         external_name(),
 847         super_klass-&gt;external_name()
 848       );
 849       return false;
 850     }
 851 
 852     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 853     ik_super-&gt;link_class_impl(CHECK_false);
 854   }
 855 
 856   // link all interfaces implemented by this class before linking this class
 857   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 858   int num_interfaces = interfaces-&gt;length();
 859   for (int index = 0; index &lt; num_interfaces; index++) {
 860     InstanceKlass* interk = interfaces-&gt;at(index);
 861     interk-&gt;link_class_impl(CHECK_false);
 862   }
 863 
























































 864   // in case the class is linked in the process of linking its superclasses
 865   if (is_linked()) {
 866     return true;
 867   }
 868 
 869   // trace only the link time for this klass that includes
 870   // the verification time
 871   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 872                              ClassLoader::perf_class_link_selftime(),
 873                              ClassLoader::perf_classes_linked(),
 874                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 875                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 876                              PerfClassTraceTime::CLASS_LINK);
 877 
 878   // verification &amp; rewriting
 879   {
 880     HandleMark hm(THREAD);
 881     Handle h_init_lock(THREAD, init_lock());
 882     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 883     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 915       // fabricate new Method*s.
 916       // also does loader constraint checking
 917       //
 918       // initialize_vtable and initialize_itable need to be rerun
 919       // for a shared class if
 920       // 1) the class is loaded by custom class loader or
 921       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
 922       bool need_init_table = true;
 923       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
 924         need_init_table = false;
 925       }
 926       if (need_init_table) {
 927         vtable().initialize_vtable(true, CHECK_false);
 928         itable().initialize_itable(true, CHECK_false);
 929       }
 930 #ifdef ASSERT
 931       vtable().verify(tty, true);
 932       // In case itable verification is ever added.
 933       // itable().verify(tty, true);
 934 #endif

 935       set_init_state(linked);
 936       if (JvmtiExport::should_post_class_prepare()) {
 937         Thread *thread = THREAD;
 938         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 939         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
 940       }
 941     }
 942   }
 943   return true;
 944 }
 945 
 946 // Rewrite the byte codes of all of the methods of a class.
 947 // The rewriter must be called exactly once. Rewriting must happen after
 948 // verification but before the first method of the class is executed.
 949 void InstanceKlass::rewrite_class(TRAPS) {
 950   assert(is_loaded(), &quot;must be loaded&quot;);
 951   if (is_rewritten()) {
 952     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
 953     return;
 954   }
</pre>
<hr />
<pre>
1068     // having a superinterface that declares, non-static, concrete methods
1069     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1070       initialize_super_interfaces(THREAD);
1071     }
1072 
1073     // If any exceptions, complete abruptly, throwing the same exception as above.
1074     if (HAS_PENDING_EXCEPTION) {
1075       Handle e(THREAD, PENDING_EXCEPTION);
1076       CLEAR_PENDING_EXCEPTION;
1077       {
1078         EXCEPTION_MARK;
1079         // Locks object, set state, and notify all waiting threads
1080         set_initialization_state_and_notify(initialization_error, THREAD);
1081         CLEAR_PENDING_EXCEPTION;
1082       }
1083       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1084       THROW_OOP(e());
1085     }
1086   }
1087 































1088 
1089   // Look for aot compiled methods for this klass, including class initializer.
1090   AOTLoader::load_for_klass(this, THREAD);
1091 
<span class="line-modified">1092   // Step 8</span>
1093   {
1094     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1095     // Timer includes any side effects of class initialization (resolution,
1096     // etc), but not recursive entry into call_class_initializer().
1097     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1098                              ClassLoader::perf_class_init_selftime(),
1099                              ClassLoader::perf_classes_inited(),
1100                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1101                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1102                              PerfClassTraceTime::CLASS_CLINIT);
1103     call_class_initializer(THREAD);
1104   }
1105 
<span class="line-modified">1106   // Step 9</span>
1107   if (!HAS_PENDING_EXCEPTION) {
1108     set_initialization_state_and_notify(fully_initialized, CHECK);
1109     {
1110       debug_only(vtable().verify(tty, true);)
1111     }
1112   }
1113   else {
<span class="line-modified">1114     // Step 10 and 11</span>
1115     Handle e(THREAD, PENDING_EXCEPTION);
1116     CLEAR_PENDING_EXCEPTION;
1117     // JVMTI has already reported the pending exception
1118     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1119     JvmtiExport::clear_detected_exception(jt);
1120     {
1121       EXCEPTION_MARK;
1122       set_initialization_state_and_notify(initialization_error, THREAD);
1123       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1124       // JVMTI has already reported the pending exception
1125       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1126       JvmtiExport::clear_detected_exception(jt);
1127     }
1128     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1129     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1130       THROW_OOP(e());
1131     } else {
1132       JavaCallArguments args(e);
1133       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1134                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1382       }
1383     }
1384   }
1385   // _this will always be set at this point
1386   ObjArrayKlass* oak = array_klasses();
1387   if (or_null) {
1388     return oak-&gt;array_klass_or_null(n);
1389   }
1390   return oak-&gt;array_klass(n, THREAD);
1391 }
1392 
1393 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1394   return array_klass_impl(or_null, 1, THREAD);
1395 }
1396 
1397 static int call_class_initializer_counter = 0;   // for debugging
1398 
1399 Method* InstanceKlass::class_initializer() const {
1400   Method* clinit = find_method(
1401       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1402   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
1403     return clinit;
1404   }
1405   return NULL;
1406 }
1407 
1408 void InstanceKlass::call_class_initializer(TRAPS) {
1409   if (ReplayCompiles &amp;&amp;
1410       (ReplaySuppressInitializers == 1 ||
1411        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1412     // Hide the existence of the initializer for the purpose of replaying the compile
1413     return;
1414   }
1415 
1416   methodHandle h_method(THREAD, class_initializer());
1417   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1418   LogTarget(Info, class, init) lt;
1419   if (lt.is_enabled()) {
1420     ResourceMark rm(THREAD);
1421     LogStream ls(lt);
1422     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1423     name()-&gt;print_value_on(&amp;ls);
1424     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1425   }
1426   if (h_method() != NULL) {
1427     JavaCallArguments args; // No arguments
1428     JavaValue result(T_VOID);
1429     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1430   }
1431 }
1432 
1433 
1434 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1435   InterpreterOopMap* entry_for) {
1436   // Lazily create the _oop_map_cache at first request
1437   // Lock-free access requires load_acquire.
1438   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1439   if (oop_map_cache == NULL) {
<span class="line-modified">1440     MutexLocker x(OopMapCacheAlloc_lock);</span>
1441     // Check if _oop_map_cache was allocated while we were waiting for this lock
1442     if ((oop_map_cache = _oop_map_cache) == NULL) {
1443       oop_map_cache = new OopMapCache();
1444       // Ensure _oop_map_cache is stable, since it is examined without a lock
1445       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1446     }
1447   }
1448   // _oop_map_cache is constant after init; lookup below does its own locking.
1449   oop_map_cache-&gt;lookup(method, bci, entry_for);
1450 }
1451 
<span class="line-removed">1452 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-removed">1453   fieldDescriptor fd;</span>
<span class="line-removed">1454   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-removed">1455 }</span>
<span class="line-removed">1456 </span>
1457 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1458   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1459     Symbol* f_name = fs.name();
1460     Symbol* f_sig  = fs.signature();
1461     if (f_name == name &amp;&amp; f_sig == sig) {
1462       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1463       return true;
1464     }
1465   }
1466   return false;
1467 }
1468 
1469 
1470 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1471   const int n = local_interfaces()-&gt;length();
1472   for (int i = 0; i &lt; n; i++) {
1473     Klass* intf1 = local_interfaces()-&gt;at(i);
1474     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1475     // search for field in current interface
1476     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1507 
1508 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1509   // search order according to newest JVM spec (5.4.3.2, p.167).
1510   // 1) search for field in current klass
1511   if (find_local_field(name, sig, fd)) {
1512     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1513   }
1514   // 2) search for field recursively in direct superinterfaces
1515   if (is_static) {
1516     Klass* intf = find_interface_field(name, sig, fd);
1517     if (intf != NULL) return intf;
1518   }
1519   // 3) apply field lookup recursively if superclass exists
1520   { Klass* supr = super();
1521     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1522   }
1523   // 4) otherwise field lookup fails
1524   return NULL;
1525 }
1526 









1527 
1528 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1529   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1530     if (fs.offset() == offset) {
1531       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1532       if (fd-&gt;is_static() == is_static) return true;
1533     }
1534   }
1535   return false;
1536 }
1537 
1538 
1539 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1540   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1541   while (klass != NULL) {
1542     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1543       return true;
1544     }
1545     klass = klass-&gt;super();
1546   }
</pre>
<hr />
<pre>
1891 }
1892 
1893 // uncached_lookup_method searches both the local class methods array and all
1894 // superclasses methods arrays, skipping any overpass methods in superclasses,
1895 // and possibly skipping private methods.
1896 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1897                                               const Symbol* signature,
1898                                               OverpassLookupMode overpass_mode,
1899                                               PrivateLookupMode private_mode) const {
1900   OverpassLookupMode overpass_local_mode = overpass_mode;
1901   const Klass* klass = this;
1902   while (klass != NULL) {
1903     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1904                                                                         signature,
1905                                                                         overpass_local_mode,
1906                                                                         find_static,
1907                                                                         private_mode);
1908     if (method != NULL) {
1909       return method;
1910     }



1911     klass = klass-&gt;super();
1912     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
1913   }
1914   return NULL;
1915 }
1916 
1917 #ifdef ASSERT
1918 // search through class hierarchy and return true if this class or
1919 // one of the superclasses was redefined
1920 bool InstanceKlass::has_redefined_this_or_super() const {
1921   const Klass* klass = this;
1922   while (klass != NULL) {
1923     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
1924       return true;
1925     }
1926     klass = klass-&gt;super();
1927   }
1928   return false;
1929 }
1930 #endif
</pre>
<hr />
<pre>
2472 }
2473 
2474 void InstanceKlass::remove_java_mirror() {
2475   Klass::remove_java_mirror();
2476 
2477   // do array classes also.
2478   if (array_klasses() != NULL) {
2479     array_klasses()-&gt;remove_java_mirror();
2480   }
2481 }
2482 
2483 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2484                                              PackageEntry* pkg_entry, TRAPS) {
2485   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2486   // before the InstanceKlass is added to the SystemDictionary. Make
2487   // sure the current state is &lt;loaded.
2488   assert(!is_loaded(), &quot;invalid init state&quot;);
2489   set_package(loader_data, pkg_entry, CHECK);
2490   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2491 




2492   Array&lt;Method*&gt;* methods = this-&gt;methods();
2493   int num_methods = methods-&gt;length();
2494   for (int index = 0; index &lt; num_methods; ++index) {
2495     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2496   }
2497   if (JvmtiExport::has_redefined_a_class()) {
2498     // Reinitialize vtable because RedefineClasses may have changed some
2499     // entries in this vtable for super classes so the CDS vtable might
2500     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2501     // vtables in the shared system dictionary, only the main one.
2502     // It also redefines the itable too so fix that too.
2503     vtable().initialize_vtable(false, CHECK);
2504     itable().initialize_itable(false, CHECK);
2505   }
2506 
2507   // restore constant pool resolved references
2508   constants()-&gt;restore_unshareable_info(CHECK);
2509 
2510   if (array_klasses() != NULL) {
2511     // Array classes have null protection domain.
2512     // --&gt; see ArrayKlass::complete_create_array_klass()
2513     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2514   }
2515 
2516   // Initialize current biased locking state.
<span class="line-modified">2517   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
2518     set_prototype_header(markWord::biased_locking_prototype());
2519   }
2520 }
2521 
2522 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2523   switch (loader_type) {
2524   case ClassLoader::BOOT_LOADER:
2525     _misc_flags |= _misc_is_shared_boot_class;
2526     break;
2527   case ClassLoader::PLATFORM_LOADER:
2528     _misc_flags |= _misc_is_shared_platform_class;
2529     break;
2530   case ClassLoader::APP_LOADER:
2531     _misc_flags |= _misc_is_shared_app_class;
2532     break;
2533   default:
2534     ShouldNotReachHere();
2535     break;
2536   }
2537 }
</pre>
<hr />
<pre>
2649   }
2650 }
2651 
2652 const char* InstanceKlass::signature_name() const {
2653   int hash_len = 0;
2654   char hash_buf[40];
2655 
2656   // If this is an unsafe anonymous class, append a hash to make the name unique
2657   if (is_unsafe_anonymous()) {
2658     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2659     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2660     hash_len = (int)strlen(hash_buf);
2661   }
2662 
2663   // Get the internal name as a c string
2664   const char* src = (const char*) (name()-&gt;as_C_string());
2665   const int src_length = (int)strlen(src);
2666 
2667   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2668 
<span class="line-modified">2669   // Add L as type indicator</span>
2670   int dest_index = 0;
<span class="line-modified">2671   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2672 
2673   // Add the actual class name
2674   for (int src_index = 0; src_index &lt; src_length; ) {
2675     dest[dest_index++] = src[src_index++];
2676   }
2677 
2678   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2679     for (int index = (int)src_length; index &gt; 0; index--) {
2680       if (dest[index] == &#39;+&#39;) {
2681         dest[index] = JVM_SIGNATURE_DOT;
2682         break;
2683       }
2684     }
2685   }
2686 
2687   // If we have a hash, append it
2688   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2689     dest[dest_index++] = hash_buf[hash_index++];
2690   }
2691 
</pre>
<hr />
<pre>
3211   }
3212 
3213   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3214   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3215     return best;
3216   }
3217   return NULL;
3218 }
3219 
3220 // -----------------------------------------------------------------------------------------------------
3221 // Printing
3222 
3223 #ifndef PRODUCT
3224 
3225 #define BULLET  &quot; - &quot;
3226 
3227 static const char* state_names[] = {
3228   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3229 };
3230 
<span class="line-modified">3231 static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>



3232   for (int i = 0; i &lt; len; i++) {
3233     intptr_t e = start[i];
3234     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);





3235     if (MetaspaceObj::is_valid((Metadata*)e)) {
3236       st-&gt;print(&quot; &quot;);
3237       ((Metadata*)e)-&gt;print_value_on(st);






3238     }
3239     st-&gt;cr();
3240   }
3241 }
3242 
3243 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3244   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>





















3245 }
3246 
3247 void InstanceKlass::print_on(outputStream* st) const {
3248   assert(is_klass(), &quot;must be klass&quot;);
3249   Klass::print_on(st);
3250 
3251   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3252   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3253   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();

3254   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3255   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3256   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3257   st-&gt;print(BULLET&quot;sub:               &quot;);
3258   Klass* sub = subklass();
3259   int n;
3260   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3261     if (n &lt; MaxSubklassPrintSize) {
3262       sub-&gt;print_value_on(st);
3263       st-&gt;print(&quot;   &quot;);
3264     }
3265   }
3266   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3267   st-&gt;cr();
3268 
3269   if (is_interface()) {
3270     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3271     if (nof_implementors() == 1) {
3272       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3273       st-&gt;print(&quot;   &quot;);
3274       implementor()-&gt;print_value_on(st);
3275       st-&gt;cr();
3276     }
3277   }
3278 
3279   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3280   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="line-modified">3281   if (Verbose || WizardMode) {</span>
<span class="line-modified">3282     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="line-removed">3283     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3284       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3285     }</span>
<span class="line-removed">3286   }</span>
<span class="line-removed">3287   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3288   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3289   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="line-removed">3290     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="line-removed">3291     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3292       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3293     }</span>
<span class="line-removed">3294   }</span>
3295   if (default_vtable_indices() != NULL) {
<span class="line-modified">3296     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
3297   }
<span class="line-modified">3298   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-modified">3299   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
3300   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3301   if (class_loader_data() != NULL) {
3302     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3303     class_loader_data()-&gt;print_value_on(st);
3304     st-&gt;cr();
3305   }
3306   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3307   if (source_file_name() != NULL) {
3308     st-&gt;print(BULLET&quot;source file:       &quot;);
3309     source_file_name()-&gt;print_value_on(st);
3310     st-&gt;cr();
3311   }
3312   if (source_debug_extension() != NULL) {
3313     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3314     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3315     st-&gt;cr();
3316   }
3317   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3318   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3319   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3335   if (generic_signature() != NULL) {
3336     st-&gt;print(BULLET&quot;generic signature: &quot;);
3337     generic_signature()-&gt;print_value_on(st);
3338     st-&gt;cr();
3339   }
3340   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3341   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3342   if (record_components() != NULL) {
3343     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3344   }
3345   if (java_mirror() != NULL) {
3346     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3347     java_mirror()-&gt;print_value_on(st);
3348     st-&gt;cr();
3349   } else {
3350     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3351   }
3352   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3353   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3354   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3355   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
3356   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3357   FieldPrinter print_static_field(st);
3358   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3359   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3360   FieldPrinter print_nonstatic_field(st);
3361   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3362   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3363 
3364   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3365   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3366   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3367   while (map &lt; end_map) {
3368     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3369     map++;
3370   }
3371   st-&gt;cr();
3372 }
3373 
3374 #endif //PRODUCT
3375 
</pre>
<hr />
<pre>
4071   if (holder == NULL) {
4072     return NULL; // The version of klass is gone, no method is found
4073   }
4074   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4075   return method;
4076 }
4077 
4078 #if INCLUDE_JVMTI
4079 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4080   return _cached_class_file;
4081 }
4082 
4083 jint InstanceKlass::get_cached_class_file_len() {
4084   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4085 }
4086 
4087 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4088   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4089 }
4090 #endif





</pre>
</td>
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  68 #include &quot;oops/valueKlass.hpp&quot;</span>
  69 #include &quot;prims/jvmtiExport.hpp&quot;
  70 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  71 #include &quot;prims/jvmtiThreadState.hpp&quot;
  72 #include &quot;prims/methodComparator.hpp&quot;
  73 #include &quot;runtime/atomic.hpp&quot;
  74 #include &quot;runtime/biasedLocking.hpp&quot;
  75 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/javaCalls.hpp&quot;
  78 #include &quot;runtime/mutexLocker.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;services/classLoadingService.hpp&quot;
  82 #include &quot;services/threadService.hpp&quot;
  83 #include &quot;utilities/dtrace.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #ifdef COMPILER1
  88 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 406                               k-&gt;external_name());
 407   return access;
 408 }
 409 
 410 const char* InstanceKlass::nest_host_error(TRAPS) {
 411   if (_nest_host_index == 0) {
 412     return NULL;
 413   } else {
 414     constantPoolHandle cph(THREAD, constants());
 415     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 416   }
 417 }
 418 
 419 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 420   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 421   const int size = InstanceKlass::size(parser.vtable_size(),
 422                                        parser.itable_size(),
 423                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 424                                        parser.is_interface(),
 425                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 426                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
<span class="line-added"> 427                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,</span>
<span class="line-added"> 428                                        parser.is_inline_type());</span>
 429 
 430   const Symbol* const class_name = parser.class_name();
 431   assert(class_name != NULL, &quot;invariant&quot;);
 432   ClassLoaderData* loader_data = parser.loader_data();
 433   assert(loader_data != NULL, &quot;invariant&quot;);
 434 
 435   InstanceKlass* ik;
 436 
 437   // Allocation
 438   if (REF_NONE == parser.reference_type()) {
 439     if (class_name == vmSymbols::java_lang_Class()) {
 440       // mirror
 441       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 442     } else if (is_class_loader(class_name, parser)) {</span>

 443       // class loader
 444       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-added"> 445     } else if (parser.is_inline_type()) {</span>
<span class="line-added"> 446       // inline type</span>
<span class="line-added"> 447       ik = new (loader_data, size, THREAD) ValueKlass(parser);</span>
 448     } else {
 449       // normal
 450       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 451     }
 452   } else {
 453     // reference
 454     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 455   }
 456 
 457   // Check for pending exception before adding to the loader data and incrementing
 458   // class count.  Can get OOM here.
 459   if (HAS_PENDING_EXCEPTION) {
 460     return NULL;
 461   }
 462 
<span class="line-added"> 463 #ifdef ASSERT</span>
<span class="line-added"> 464   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="line-added"> 465   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="line-added"> 466   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="line-added"> 467   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="line-added"> 468   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="line-added"> 469 #endif //ASSERT</span>
 470   return ik;
 471 }
 472 
<span class="line-added"> 473 #ifndef PRODUCT</span>
<span class="line-added"> 474 bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="line-added"> 475   const char* bad = NULL;</span>
<span class="line-added"> 476   address end = NULL;</span>
<span class="line-added"> 477   if (addr &lt; (address)this) {</span>
<span class="line-added"> 478     bad = &quot;before&quot;;</span>
<span class="line-added"> 479   } else if (addr == (address)this) {</span>
<span class="line-added"> 480     if (edge_ok)  return true;</span>
<span class="line-added"> 481     bad = &quot;just before&quot;;</span>
<span class="line-added"> 482   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="line-added"> 483     if (edge_ok)  return true;</span>
<span class="line-added"> 484     bad = &quot;just after&quot;;</span>
<span class="line-added"> 485   } else if (addr &gt; end) {</span>
<span class="line-added"> 486     bad = &quot;after&quot;;</span>
<span class="line-added"> 487   } else {</span>
<span class="line-added"> 488     return true;</span>
<span class="line-added"> 489   }</span>
<span class="line-added"> 490   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="line-added"> 491       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="line-added"> 492   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="line-added"> 493   return false;</span>
<span class="line-added"> 494 }</span>
<span class="line-added"> 495 #endif //PRODUCT</span>
 496 
 497 // copy method ordering from resource area to Metaspace
 498 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 499   if (m != NULL) {
 500     // allocate a new array and copy contents (memcpy?)
 501     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 502     for (int i = 0; i &lt; m-&gt;length(); i++) {
 503       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 504     }
 505   } else {
 506     _method_ordering = Universe::the_empty_int_array();
 507   }
 508 }
 509 
 510 // create a new array of vtable_indices for default methods
 511 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 512   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 513   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 514   set_default_vtable_indices(vtable_indices);
 515   return vtable_indices;
 516 }
 517 
 518 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 519   Klass(id),
 520   _nest_members(NULL),
 521   _nest_host(NULL),
 522   _record_components(NULL),
 523   _static_field_size(parser.static_field_size()),
 524   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 525   _itable_len(parser.itable_size()),
 526   _nest_host_index(0),
 527   _init_state(allocated),
 528   _reference_type(parser.reference_type()),
<span class="line-modified"> 529   _init_thread(NULL),</span>
<span class="line-added"> 530   _value_field_klasses(NULL),</span>
<span class="line-added"> 531   _adr_valueklass_fixed_block(NULL)</span>
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
<span class="line-added"> 540     if (parser.has_flattenable_fields()) {</span>
<span class="line-added"> 541       set_has_inline_fields();</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543     _java_fields_count = parser.java_fields_count();</span>
 544 
<span class="line-modified"> 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 548 
 549   // Set biased locking bit for all instances of this class; it will be
 550   // cleared if revocation occurs too often for this type
 551   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 552     set_prototype_header(markWord::biased_locking_prototype());
 553   }
<span class="line-added"> 554   if (has_inline_fields()) {</span>
<span class="line-added"> 555     _value_field_klasses = (const Klass**) adr_value_fields_klasses();</span>
<span class="line-added"> 556   }</span>
 557 }
 558 
 559 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 560                                        Array&lt;Method*&gt;* methods) {
 561   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 562       !methods-&gt;is_shared()) {
 563     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 564       Method* method = methods-&gt;at(i);
 565       if (method == NULL) continue;  // maybe null if error processing
 566       // Only want to delete methods that are not executing for RedefineClasses.
 567       // The previous version will point to them so they&#39;re not totally dangling
 568       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 569       MetadataFactory::free_metadata(loader_data, method);
 570     }
 571     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 572   }
 573 }
 574 
 575 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 576                                           const Klass* super_klass,
 577                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 578                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 579   // Only deallocate transitive interfaces if not empty, same as super class
 580   // or same as local interfaces.  See code in parseClassFile.
 581   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 582   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 583     // check that the interfaces don&#39;t come from super class
 584     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 585                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 586     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 587         ti != Universe::the_single_IdentityObject_klass_array()) {</span>
 588       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 589     }
 590   }
 591 
 592   // local interfaces can be empty
 593   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 594       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 595       local_interfaces != Universe::the_single_IdentityObject_klass_array()) {</span>
 596     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 597   }
 598 }
 599 
 600 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 601                                                  Array&lt;RecordComponent*&gt;* record_components) {
 602   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 603     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 604       RecordComponent* record_component = record_components-&gt;at(i);
 605       MetadataFactory::free_metadata(loader_data, record_component);
 606     }
 607     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 608   }
 609 }
 610 
 611 // This function deallocates the metadata and C heap pointers that the
 612 // InstanceKlass points to.
 613 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 614 
 615   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 890         vmSymbols::java_lang_IncompatibleClassChangeError(),
 891         &quot;class %s has interface %s as super class&quot;,
 892         external_name(),
 893         super_klass-&gt;external_name()
 894       );
 895       return false;
 896     }
 897 
 898     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 899     ik_super-&gt;link_class_impl(CHECK_false);
 900   }
 901 
 902   // link all interfaces implemented by this class before linking this class
 903   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 904   int num_interfaces = interfaces-&gt;length();
 905   for (int index = 0; index &lt; num_interfaces; index++) {
 906     InstanceKlass* interk = interfaces-&gt;at(index);
 907     interk-&gt;link_class_impl(CHECK_false);
 908   }
 909 
<span class="line-added"> 910 </span>
<span class="line-added"> 911   // If a class declares a method that uses an inline class as an argument</span>
<span class="line-added"> 912   // type or return inline type, this inline class must be loaded during the</span>
<span class="line-added"> 913   // linking of this class because size and properties of the inline class</span>
<span class="line-added"> 914   // must be known in order to be able to perform inline type optimizations.</span>
<span class="line-added"> 915   // The implementation below is an approximation of this rule, the code</span>
<span class="line-added"> 916   // iterates over all methods of the current class (including overridden</span>
<span class="line-added"> 917   // methods), not only the methods declared by this class. This</span>
<span class="line-added"> 918   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="line-added"> 919   // because classes declaring methods overridden by the current class are</span>
<span class="line-added"> 920   // linked (and have performed their own pre-loading) before the linking</span>
<span class="line-added"> 921   // of the current class.</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924   // Note:</span>
<span class="line-added"> 925   // Inline class types used for flattenable fields are loaded during</span>
<span class="line-added"> 926   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="line-added"> 927   // Inline class types used as element types for array creation</span>
<span class="line-added"> 928   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="line-added"> 929   // or multianewarray bytecodes.</span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931   // Could it be possible to do the following processing only if the</span>
<span class="line-added"> 932   // class uses inline types?</span>
<span class="line-added"> 933   {</span>
<span class="line-added"> 934     ResourceMark rm(THREAD);</span>
<span class="line-added"> 935     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="line-added"> 936       Method* m = methods()-&gt;at(i);</span>
<span class="line-added"> 937       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="line-added"> 938         if (ss.is_reference()) {</span>
<span class="line-added"> 939           if (ss.is_array()) {</span>
<span class="line-added"> 940             ss.skip_array_prefix();</span>
<span class="line-added"> 941           }</span>
<span class="line-added"> 942           if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added"> 943             Symbol* symb = ss.as_symbol();</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945             oop loader = class_loader();</span>
<span class="line-added"> 946             oop protection_domain = this-&gt;protection_domain();</span>
<span class="line-added"> 947             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="line-added"> 948                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="line-added"> 949                                                              CHECK_false);</span>
<span class="line-added"> 950             if (klass == NULL) {</span>
<span class="line-added"> 951               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="line-added"> 952             }</span>
<span class="line-added"> 953             if (!klass-&gt;is_value()) {</span>
<span class="line-added"> 954               Exceptions::fthrow(</span>
<span class="line-added"> 955                 THREAD_AND_LOCATION,</span>
<span class="line-added"> 956                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added"> 957                 &quot;class %s is not an inline type&quot;,</span>
<span class="line-added"> 958                 klass-&gt;external_name());</span>
<span class="line-added"> 959             }</span>
<span class="line-added"> 960           }</span>
<span class="line-added"> 961         }</span>
<span class="line-added"> 962       }</span>
<span class="line-added"> 963     }</span>
<span class="line-added"> 964   }</span>
<span class="line-added"> 965 </span>
 966   // in case the class is linked in the process of linking its superclasses
 967   if (is_linked()) {
 968     return true;
 969   }
 970 
 971   // trace only the link time for this klass that includes
 972   // the verification time
 973   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 974                              ClassLoader::perf_class_link_selftime(),
 975                              ClassLoader::perf_classes_linked(),
 976                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 977                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 978                              PerfClassTraceTime::CLASS_LINK);
 979 
 980   // verification &amp; rewriting
 981   {
 982     HandleMark hm(THREAD);
 983     Handle h_init_lock(THREAD, init_lock());
 984     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 985     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
1017       // fabricate new Method*s.
1018       // also does loader constraint checking
1019       //
1020       // initialize_vtable and initialize_itable need to be rerun
1021       // for a shared class if
1022       // 1) the class is loaded by custom class loader or
1023       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
1024       bool need_init_table = true;
1025       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
1026         need_init_table = false;
1027       }
1028       if (need_init_table) {
1029         vtable().initialize_vtable(true, CHECK_false);
1030         itable().initialize_itable(true, CHECK_false);
1031       }
1032 #ifdef ASSERT
1033       vtable().verify(tty, true);
1034       // In case itable verification is ever added.
1035       // itable().verify(tty, true);
1036 #endif
<span class="line-added">1037 </span>
1038       set_init_state(linked);
1039       if (JvmtiExport::should_post_class_prepare()) {
1040         Thread *thread = THREAD;
1041         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1042         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1043       }
1044     }
1045   }
1046   return true;
1047 }
1048 
1049 // Rewrite the byte codes of all of the methods of a class.
1050 // The rewriter must be called exactly once. Rewriting must happen after
1051 // verification but before the first method of the class is executed.
1052 void InstanceKlass::rewrite_class(TRAPS) {
1053   assert(is_loaded(), &quot;must be loaded&quot;);
1054   if (is_rewritten()) {
1055     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1056     return;
1057   }
</pre>
<hr />
<pre>
1171     // having a superinterface that declares, non-static, concrete methods
1172     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1173       initialize_super_interfaces(THREAD);
1174     }
1175 
1176     // If any exceptions, complete abruptly, throwing the same exception as above.
1177     if (HAS_PENDING_EXCEPTION) {
1178       Handle e(THREAD, PENDING_EXCEPTION);
1179       CLEAR_PENDING_EXCEPTION;
1180       {
1181         EXCEPTION_MARK;
1182         // Locks object, set state, and notify all waiting threads
1183         set_initialization_state_and_notify(initialization_error, THREAD);
1184         CLEAR_PENDING_EXCEPTION;
1185       }
1186       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1187       THROW_OOP(e());
1188     }
1189   }
1190 
<span class="line-added">1191   // Step 8</span>
<span class="line-added">1192   // Initialize classes of flattenable fields</span>
<span class="line-added">1193   {</span>
<span class="line-added">1194     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="line-added">1195       if (fs.is_flattenable()) {</span>
<span class="line-added">1196         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());</span>
<span class="line-added">1197         if (klass == NULL) {</span>
<span class="line-added">1198           assert(fs.access_flags().is_static() &amp;&amp; fs.access_flags().is_flattenable(),</span>
<span class="line-added">1199               &quot;Otherwise should have been pre-loaded&quot;);</span>
<span class="line-added">1200           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="line-added">1201               Handle(THREAD, class_loader()),</span>
<span class="line-added">1202               Handle(THREAD, protection_domain()),</span>
<span class="line-added">1203               true, CHECK);</span>
<span class="line-added">1204           if (klass == NULL) {</span>
<span class="line-added">1205             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="line-added">1206           }</span>
<span class="line-added">1207           if (!klass-&gt;is_value()) {</span>
<span class="line-added">1208             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">1209           }</span>
<span class="line-added">1210           this-&gt;set_value_field_klass(fs.index(), klass);</span>
<span class="line-added">1211         }</span>
<span class="line-added">1212         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="line-added">1213         if (fs.access_flags().is_static()) {</span>
<span class="line-added">1214           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="line-added">1215             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());</span>
<span class="line-added">1216           }</span>
<span class="line-added">1217         }</span>
<span class="line-added">1218       }</span>
<span class="line-added">1219     }</span>
<span class="line-added">1220   }</span>
<span class="line-added">1221 </span>
1222 
1223   // Look for aot compiled methods for this klass, including class initializer.
1224   AOTLoader::load_for_klass(this, THREAD);
1225 
<span class="line-modified">1226   // Step 9</span>
1227   {
1228     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1229     // Timer includes any side effects of class initialization (resolution,
1230     // etc), but not recursive entry into call_class_initializer().
1231     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1232                              ClassLoader::perf_class_init_selftime(),
1233                              ClassLoader::perf_classes_inited(),
1234                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1235                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1236                              PerfClassTraceTime::CLASS_CLINIT);
1237     call_class_initializer(THREAD);
1238   }
1239 
<span class="line-modified">1240   // Step 10</span>
1241   if (!HAS_PENDING_EXCEPTION) {
1242     set_initialization_state_and_notify(fully_initialized, CHECK);
1243     {
1244       debug_only(vtable().verify(tty, true);)
1245     }
1246   }
1247   else {
<span class="line-modified">1248     // Step 11 and 12</span>
1249     Handle e(THREAD, PENDING_EXCEPTION);
1250     CLEAR_PENDING_EXCEPTION;
1251     // JVMTI has already reported the pending exception
1252     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1253     JvmtiExport::clear_detected_exception(jt);
1254     {
1255       EXCEPTION_MARK;
1256       set_initialization_state_and_notify(initialization_error, THREAD);
1257       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1258       // JVMTI has already reported the pending exception
1259       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1260       JvmtiExport::clear_detected_exception(jt);
1261     }
1262     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1263     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1264       THROW_OOP(e());
1265     } else {
1266       JavaCallArguments args(e);
1267       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1268                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1516       }
1517     }
1518   }
1519   // _this will always be set at this point
1520   ObjArrayKlass* oak = array_klasses();
1521   if (or_null) {
1522     return oak-&gt;array_klass_or_null(n);
1523   }
1524   return oak-&gt;array_klass(n, THREAD);
1525 }
1526 
1527 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1528   return array_klass_impl(or_null, 1, THREAD);
1529 }
1530 
1531 static int call_class_initializer_counter = 0;   // for debugging
1532 
1533 Method* InstanceKlass::class_initializer() const {
1534   Method* clinit = find_method(
1535       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1536   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
1537     return clinit;
1538   }
1539   return NULL;
1540 }
1541 
1542 void InstanceKlass::call_class_initializer(TRAPS) {
1543   if (ReplayCompiles &amp;&amp;
1544       (ReplaySuppressInitializers == 1 ||
1545        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1546     // Hide the existence of the initializer for the purpose of replaying the compile
1547     return;
1548   }
1549 
1550   methodHandle h_method(THREAD, class_initializer());
1551   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1552   LogTarget(Info, class, init) lt;
1553   if (lt.is_enabled()) {
1554     ResourceMark rm(THREAD);
1555     LogStream ls(lt);
1556     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1557     name()-&gt;print_value_on(&amp;ls);
1558     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1559   }
1560   if (h_method() != NULL) {
1561     JavaCallArguments args; // No arguments
1562     JavaValue result(T_VOID);
1563     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1564   }
1565 }
1566 
1567 
1568 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1569   InterpreterOopMap* entry_for) {
1570   // Lazily create the _oop_map_cache at first request
1571   // Lock-free access requires load_acquire.
1572   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1573   if (oop_map_cache == NULL) {
<span class="line-modified">1574     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
1575     // Check if _oop_map_cache was allocated while we were waiting for this lock
1576     if ((oop_map_cache = _oop_map_cache) == NULL) {
1577       oop_map_cache = new OopMapCache();
1578       // Ensure _oop_map_cache is stable, since it is examined without a lock
1579       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1580     }
1581   }
1582   // _oop_map_cache is constant after init; lookup below does its own locking.
1583   oop_map_cache-&gt;lookup(method, bci, entry_for);
1584 }
1585 





1586 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1587   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1588     Symbol* f_name = fs.name();
1589     Symbol* f_sig  = fs.signature();
1590     if (f_name == name &amp;&amp; f_sig == sig) {
1591       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1592       return true;
1593     }
1594   }
1595   return false;
1596 }
1597 
1598 
1599 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1600   const int n = local_interfaces()-&gt;length();
1601   for (int i = 0; i &lt; n; i++) {
1602     Klass* intf1 = local_interfaces()-&gt;at(i);
1603     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1604     // search for field in current interface
1605     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1636 
1637 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1638   // search order according to newest JVM spec (5.4.3.2, p.167).
1639   // 1) search for field in current klass
1640   if (find_local_field(name, sig, fd)) {
1641     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1642   }
1643   // 2) search for field recursively in direct superinterfaces
1644   if (is_static) {
1645     Klass* intf = find_interface_field(name, sig, fd);
1646     if (intf != NULL) return intf;
1647   }
1648   // 3) apply field lookup recursively if superclass exists
1649   { Klass* supr = super();
1650     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1651   }
1652   // 4) otherwise field lookup fails
1653   return NULL;
1654 }
1655 
<span class="line-added">1656 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1657   if (this-&gt;is_value()) {</span>
<span class="line-added">1658     ValueKlass* vk = ValueKlass::cast(this);</span>
<span class="line-added">1659     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="line-added">1660   } else {</span>
<span class="line-added">1661     fieldDescriptor fd;</span>
<span class="line-added">1662     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1663   }</span>
<span class="line-added">1664 }</span>
1665 
1666 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1667   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1668     if (fs.offset() == offset) {
1669       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1670       if (fd-&gt;is_static() == is_static) return true;
1671     }
1672   }
1673   return false;
1674 }
1675 
1676 
1677 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1678   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1679   while (klass != NULL) {
1680     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1681       return true;
1682     }
1683     klass = klass-&gt;super();
1684   }
</pre>
<hr />
<pre>
2029 }
2030 
2031 // uncached_lookup_method searches both the local class methods array and all
2032 // superclasses methods arrays, skipping any overpass methods in superclasses,
2033 // and possibly skipping private methods.
2034 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
2035                                               const Symbol* signature,
2036                                               OverpassLookupMode overpass_mode,
2037                                               PrivateLookupMode private_mode) const {
2038   OverpassLookupMode overpass_local_mode = overpass_mode;
2039   const Klass* klass = this;
2040   while (klass != NULL) {
2041     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
2042                                                                         signature,
2043                                                                         overpass_local_mode,
2044                                                                         find_static,
2045                                                                         private_mode);
2046     if (method != NULL) {
2047       return method;
2048     }
<span class="line-added">2049     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2050       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="line-added">2051     }</span>
2052     klass = klass-&gt;super();
2053     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
2054   }
2055   return NULL;
2056 }
2057 
2058 #ifdef ASSERT
2059 // search through class hierarchy and return true if this class or
2060 // one of the superclasses was redefined
2061 bool InstanceKlass::has_redefined_this_or_super() const {
2062   const Klass* klass = this;
2063   while (klass != NULL) {
2064     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
2065       return true;
2066     }
2067     klass = klass-&gt;super();
2068   }
2069   return false;
2070 }
2071 #endif
</pre>
<hr />
<pre>
2613 }
2614 
2615 void InstanceKlass::remove_java_mirror() {
2616   Klass::remove_java_mirror();
2617 
2618   // do array classes also.
2619   if (array_klasses() != NULL) {
2620     array_klasses()-&gt;remove_java_mirror();
2621   }
2622 }
2623 
2624 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2625                                              PackageEntry* pkg_entry, TRAPS) {
2626   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2627   // before the InstanceKlass is added to the SystemDictionary. Make
2628   // sure the current state is &lt;loaded.
2629   assert(!is_loaded(), &quot;invalid init state&quot;);
2630   set_package(loader_data, pkg_entry, CHECK);
2631   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2632 
<span class="line-added">2633   if (is_value()) {</span>
<span class="line-added">2634     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">2635   }</span>
<span class="line-added">2636 </span>
2637   Array&lt;Method*&gt;* methods = this-&gt;methods();
2638   int num_methods = methods-&gt;length();
2639   for (int index = 0; index &lt; num_methods; ++index) {
2640     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2641   }
2642   if (JvmtiExport::has_redefined_a_class()) {
2643     // Reinitialize vtable because RedefineClasses may have changed some
2644     // entries in this vtable for super classes so the CDS vtable might
2645     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2646     // vtables in the shared system dictionary, only the main one.
2647     // It also redefines the itable too so fix that too.
2648     vtable().initialize_vtable(false, CHECK);
2649     itable().initialize_itable(false, CHECK);
2650   }
2651 
2652   // restore constant pool resolved references
2653   constants()-&gt;restore_unshareable_info(CHECK);
2654 
2655   if (array_klasses() != NULL) {
2656     // Array classes have null protection domain.
2657     // --&gt; see ArrayKlass::complete_create_array_klass()
2658     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2659   }
2660 
2661   // Initialize current biased locking state.
<span class="line-modified">2662   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
2663     set_prototype_header(markWord::biased_locking_prototype());
2664   }
2665 }
2666 
2667 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2668   switch (loader_type) {
2669   case ClassLoader::BOOT_LOADER:
2670     _misc_flags |= _misc_is_shared_boot_class;
2671     break;
2672   case ClassLoader::PLATFORM_LOADER:
2673     _misc_flags |= _misc_is_shared_platform_class;
2674     break;
2675   case ClassLoader::APP_LOADER:
2676     _misc_flags |= _misc_is_shared_app_class;
2677     break;
2678   default:
2679     ShouldNotReachHere();
2680     break;
2681   }
2682 }
</pre>
<hr />
<pre>
2794   }
2795 }
2796 
2797 const char* InstanceKlass::signature_name() const {
2798   int hash_len = 0;
2799   char hash_buf[40];
2800 
2801   // If this is an unsafe anonymous class, append a hash to make the name unique
2802   if (is_unsafe_anonymous()) {
2803     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2804     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2805     hash_len = (int)strlen(hash_buf);
2806   }
2807 
2808   // Get the internal name as a c string
2809   const char* src = (const char*) (name()-&gt;as_C_string());
2810   const int src_length = (int)strlen(src);
2811 
2812   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2813 
<span class="line-modified">2814   // Add L or Q as type indicator</span>
2815   int dest_index = 0;
<span class="line-modified">2816   dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
2817 
2818   // Add the actual class name
2819   for (int src_index = 0; src_index &lt; src_length; ) {
2820     dest[dest_index++] = src[src_index++];
2821   }
2822 
2823   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2824     for (int index = (int)src_length; index &gt; 0; index--) {
2825       if (dest[index] == &#39;+&#39;) {
2826         dest[index] = JVM_SIGNATURE_DOT;
2827         break;
2828       }
2829     }
2830   }
2831 
2832   // If we have a hash, append it
2833   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2834     dest[dest_index++] = hash_buf[hash_index++];
2835   }
2836 
</pre>
<hr />
<pre>
3356   }
3357 
3358   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3359   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3360     return best;
3361   }
3362   return NULL;
3363 }
3364 
3365 // -----------------------------------------------------------------------------------------------------
3366 // Printing
3367 
3368 #ifndef PRODUCT
3369 
3370 #define BULLET  &quot; - &quot;
3371 
3372 static const char* state_names[] = {
3373   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3374 };
3375 
<span class="line-modified">3376 static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="line-added">3377   ResourceMark rm;</span>
<span class="line-added">3378   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="line-added">3379   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
3380   for (int i = 0; i &lt; len; i++) {
3381     intptr_t e = start[i];
3382     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-added">3383     if (forward_refs[i] != 0) {</span>
<span class="line-added">3384       int from = forward_refs[i];</span>
<span class="line-added">3385       int off = (int) start[from];</span>
<span class="line-added">3386       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="line-added">3387     }</span>
3388     if (MetaspaceObj::is_valid((Metadata*)e)) {
3389       st-&gt;print(&quot; &quot;);
3390       ((Metadata*)e)-&gt;print_value_on(st);
<span class="line-added">3391     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="line-added">3392       address location = self + e;</span>
<span class="line-added">3393       int index = (int)((intptr_t*)location - start);</span>
<span class="line-added">3394       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="line-added">3395       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="line-added">3396         forward_refs[index] = i;</span>
3397     }
3398     st-&gt;cr();
3399   }
3400 }
3401 
3402 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3403   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="line-added">3404 }</span>
<span class="line-added">3405 </span>
<span class="line-added">3406 template&lt;typename T&gt;</span>
<span class="line-added">3407  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="line-added">3408    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3409    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3410    if (Verbose || WizardMode) {</span>
<span class="line-added">3411      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3412        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3413      }</span>
<span class="line-added">3414    }</span>
<span class="line-added">3415  }</span>
<span class="line-added">3416 </span>
<span class="line-added">3417 static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="line-added">3418   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3419   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3420   if (Verbose || WizardMode) {</span>
<span class="line-added">3421     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3422       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="line-added">3423     }</span>
<span class="line-added">3424   }</span>
3425 }
3426 
3427 void InstanceKlass::print_on(outputStream* st) const {
3428   assert(is_klass(), &quot;must be klass&quot;);
3429   Klass::print_on(st);
3430 
3431   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3432   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3433   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="line-added">3434   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
3435   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3436   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3437   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3438   st-&gt;print(BULLET&quot;sub:               &quot;);
3439   Klass* sub = subklass();
3440   int n;
3441   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3442     if (n &lt; MaxSubklassPrintSize) {
3443       sub-&gt;print_value_on(st);
3444       st-&gt;print(&quot;   &quot;);
3445     }
3446   }
3447   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3448   st-&gt;cr();
3449 
3450   if (is_interface()) {
3451     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3452     if (nof_implementors() == 1) {
3453       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3454       st-&gt;print(&quot;   &quot;);
3455       implementor()-&gt;print_value_on(st);
3456       st-&gt;cr();
3457     }
3458   }
3459 
3460   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3461   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="line-modified">3462   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="line-modified">3463   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>












3464   if (default_vtable_indices() != NULL) {
<span class="line-modified">3465     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
3466   }
<span class="line-modified">3467   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="line-modified">3468   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
3469   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3470   if (class_loader_data() != NULL) {
3471     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3472     class_loader_data()-&gt;print_value_on(st);
3473     st-&gt;cr();
3474   }
3475   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3476   if (source_file_name() != NULL) {
3477     st-&gt;print(BULLET&quot;source file:       &quot;);
3478     source_file_name()-&gt;print_value_on(st);
3479     st-&gt;cr();
3480   }
3481   if (source_debug_extension() != NULL) {
3482     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3483     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3484     st-&gt;cr();
3485   }
3486   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3487   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3488   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3504   if (generic_signature() != NULL) {
3505     st-&gt;print(BULLET&quot;generic signature: &quot;);
3506     generic_signature()-&gt;print_value_on(st);
3507     st-&gt;cr();
3508   }
3509   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3510   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3511   if (record_components() != NULL) {
3512     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3513   }
3514   if (java_mirror() != NULL) {
3515     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3516     java_mirror()-&gt;print_value_on(st);
3517     st-&gt;cr();
3518   } else {
3519     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3520   }
3521   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3522   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3523   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3524   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
3525   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3526   FieldPrinter print_static_field(st);
3527   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3528   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3529   FieldPrinter print_nonstatic_field(st);
3530   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3531   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3532 
3533   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3534   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3535   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3536   while (map &lt; end_map) {
3537     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3538     map++;
3539   }
3540   st-&gt;cr();
3541 }
3542 
3543 #endif //PRODUCT
3544 
</pre>
<hr />
<pre>
4240   if (holder == NULL) {
4241     return NULL; // The version of klass is gone, no method is found
4242   }
4243   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4244   return method;
4245 }
4246 
4247 #if INCLUDE_JVMTI
4248 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4249   return _cached_class_file;
4250 }
4251 
4252 jint InstanceKlass::get_cached_class_file_len() {
4253   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4254 }
4255 
4256 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4257   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4258 }
4259 #endif
<span class="line-added">4260 </span>
<span class="line-added">4261 #define THROW_DVT_ERROR(s) \</span>
<span class="line-added">4262   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="line-added">4263       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="line-added">4264       return</span>
</pre>
</td>
</tr>
</table>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
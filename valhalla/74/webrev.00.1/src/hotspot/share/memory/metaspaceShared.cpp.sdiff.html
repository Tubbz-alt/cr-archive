<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="metaspaceClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;


  62 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/os.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/signature.hpp&quot;
  67 #include &quot;runtime/timerTrace.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;runtime/vmOperations.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/bitMap.inline.hpp&quot;
  72 #include &quot;utilities/ostream.hpp&quot;
  73 #include &quot;utilities/defaultStream.hpp&quot;
  74 #include &quot;utilities/hashtable.inline.hpp&quot;
  75 #if INCLUDE_G1GC
  76 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  77 #endif
  78 
  79 ReservedSpace MetaspaceShared::_shared_rs;
  80 VirtualSpace MetaspaceShared::_shared_vs;
  81 ReservedSpace MetaspaceShared::_symbol_rs;
</pre>
<hr />
<pre>
 714     fp.fingerprint();
 715   }
 716 }
 717 
 718 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 719 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 720 //
 721 // Addresses of the vtables and the methods may be different across JVM runs,
 722 // if libjvm.so is dynamically loaded at a different base address.
 723 //
 724 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 725 //
 726 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 727 //                  the CDS image
 728 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 729 //                  into our own tables.
 730 
 731 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 732 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 733   f(ConstantPool) \
<span class="line-modified"> 734   f(InstanceKlass) \</span>
 735   f(InstanceClassLoaderKlass) \
 736   f(InstanceMirrorKlass) \
 737   f(InstanceRefKlass) \
 738   f(Method) \
 739   f(ObjArrayKlass) \
<span class="line-modified"> 740   f(TypeArrayKlass)</span>


 741 
 742 class CppVtableInfo {
 743   intptr_t _vtable_size;
 744   intptr_t _cloned_vtable[1];
 745 public:
 746   static int num_slots(int vtable_size) {
 747     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 748   }
 749   int vtable_size()           { return int(uintx(_vtable_size)); }
 750   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 751   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 752   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 753   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 754   static size_t byte_size(int vtable_size) {
 755     CppVtableInfo i;
 756     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 757   }
 758 };
 759 
 760 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 908   Arguments::assert_is_dumping_archive();
 909   int kind = -1;
 910   switch (msotype) {
 911   case MetaspaceObj::SymbolType:
 912   case MetaspaceObj::TypeArrayU1Type:
 913   case MetaspaceObj::TypeArrayU2Type:
 914   case MetaspaceObj::TypeArrayU4Type:
 915   case MetaspaceObj::TypeArrayU8Type:
 916   case MetaspaceObj::TypeArrayOtherType:
 917   case MetaspaceObj::ConstMethodType:
 918   case MetaspaceObj::ConstantPoolCacheType:
 919   case MetaspaceObj::AnnotationsType:
 920   case MetaspaceObj::MethodCountersType:
 921   case MetaspaceObj::RecordComponentType:
 922     // These have no vtables.
 923     break;
 924   case MetaspaceObj::ClassType:
 925     {
 926       Klass* k = (Klass*)obj;
 927       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 928       if (k-&gt;is_instance_klass()) {</span>


 929         InstanceKlass* ik = InstanceKlass::cast(k);
 930         if (ik-&gt;is_class_loader_instance_klass()) {
 931           kind = InstanceClassLoaderKlass_Kind;
 932         } else if (ik-&gt;is_reference_instance_klass()) {
 933           kind = InstanceRefKlass_Kind;
 934         } else if (ik-&gt;is_mirror_instance_klass()) {
 935           kind = InstanceMirrorKlass_Kind;
 936         } else {
 937           kind = InstanceKlass_Kind;
 938         }
 939       } else if (k-&gt;is_typeArray_klass()) {
 940         kind = TypeArrayKlass_Kind;
 941       } else {
 942         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 943         kind = ObjArrayKlass_Kind;
 944       }
 945     }
 946     break;
 947 
 948   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1336     ShallowCopier(bool read_only) : _read_only(read_only) {}
1337 
1338     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1339       if (read_only == _read_only) {
1340         allocate(ref, read_only);
1341       }
1342       return true; // recurse into ref.obj()
1343     }
1344   };
1345 
1346   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1347   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1348   public:
1349     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1350       address new_loc = get_new_loc(ref);
1351       RefRelocator refer;
1352       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1353       return true; // recurse into ref.obj()
1354     }
1355     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1356       assert(type == _method_entry_ref, &quot;only special type allowed for now&quot;);</span>

1357       address obj = ref-&gt;obj();
1358       address new_obj = get_new_loc(ref);
1359       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1360       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1361       assert(*p == *new_p, &quot;must be a copy&quot;);</span>













1362       ArchivePtrMarker::mark_pointer((address*)new_p);
1363     }
1364   };
1365 
1366   // Relocate a reference to point to its shallow copy
1367   class RefRelocator: public MetaspaceClosure {
1368   public:
1369     virtual bool do_ref(Ref* ref, bool read_only) {
1370       if (ref-&gt;not_null()) {
1371         ref-&gt;update(get_new_loc(ref));
1372         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1373       }
1374       return false; // Do not recurse.
1375     }
1376   };
1377 
1378 #ifdef ASSERT
1379   class IsRefInArchiveChecker: public MetaspaceClosure {
1380   public:
1381     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  63 #include &quot;oops/valueKlass.hpp&quot;</span>
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
  74 #include &quot;utilities/ostream.hpp&quot;
  75 #include &quot;utilities/defaultStream.hpp&quot;
  76 #include &quot;utilities/hashtable.inline.hpp&quot;
  77 #if INCLUDE_G1GC
  78 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  79 #endif
  80 
  81 ReservedSpace MetaspaceShared::_shared_rs;
  82 VirtualSpace MetaspaceShared::_shared_vs;
  83 ReservedSpace MetaspaceShared::_symbol_rs;
</pre>
<hr />
<pre>
 716     fp.fingerprint();
 717   }
 718 }
 719 
 720 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 721 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 722 //
 723 // Addresses of the vtables and the methods may be different across JVM runs,
 724 // if libjvm.so is dynamically loaded at a different base address.
 725 //
 726 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 727 //
 728 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 729 //                  the CDS image
 730 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 731 //                  into our own tables.
 732 
 733 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 734 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 735   f(ConstantPool) \
<span class="line-modified"> 736   f(InstanceClassLoaderKlass) \</span>
 737   f(InstanceKlass) \
 738   f(InstanceMirrorKlass) \
 739   f(InstanceRefKlass) \
 740   f(Method) \
 741   f(ObjArrayKlass) \
<span class="line-modified"> 742   f(TypeArrayKlass) \</span>
<span class="line-added"> 743   f(ValueArrayKlass) \</span>
<span class="line-added"> 744   f(ValueKlass)</span>
 745 
 746 class CppVtableInfo {
 747   intptr_t _vtable_size;
 748   intptr_t _cloned_vtable[1];
 749 public:
 750   static int num_slots(int vtable_size) {
 751     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 752   }
 753   int vtable_size()           { return int(uintx(_vtable_size)); }
 754   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 755   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 756   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 757   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 758   static size_t byte_size(int vtable_size) {
 759     CppVtableInfo i;
 760     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 761   }
 762 };
 763 
 764 template &lt;class T&gt; class CppVtableCloner : public T {
</pre>
<hr />
<pre>
 912   Arguments::assert_is_dumping_archive();
 913   int kind = -1;
 914   switch (msotype) {
 915   case MetaspaceObj::SymbolType:
 916   case MetaspaceObj::TypeArrayU1Type:
 917   case MetaspaceObj::TypeArrayU2Type:
 918   case MetaspaceObj::TypeArrayU4Type:
 919   case MetaspaceObj::TypeArrayU8Type:
 920   case MetaspaceObj::TypeArrayOtherType:
 921   case MetaspaceObj::ConstMethodType:
 922   case MetaspaceObj::ConstantPoolCacheType:
 923   case MetaspaceObj::AnnotationsType:
 924   case MetaspaceObj::MethodCountersType:
 925   case MetaspaceObj::RecordComponentType:
 926     // These have no vtables.
 927     break;
 928   case MetaspaceObj::ClassType:
 929     {
 930       Klass* k = (Klass*)obj;
 931       assert(k-&gt;is_klass(), &quot;must be&quot;);
<span class="line-modified"> 932       if (k-&gt;is_value()) {</span>
<span class="line-added"> 933         kind = ValueKlass_Kind;</span>
<span class="line-added"> 934       } else if (k-&gt;is_instance_klass()) {</span>
 935         InstanceKlass* ik = InstanceKlass::cast(k);
 936         if (ik-&gt;is_class_loader_instance_klass()) {
 937           kind = InstanceClassLoaderKlass_Kind;
 938         } else if (ik-&gt;is_reference_instance_klass()) {
 939           kind = InstanceRefKlass_Kind;
 940         } else if (ik-&gt;is_mirror_instance_klass()) {
 941           kind = InstanceMirrorKlass_Kind;
 942         } else {
 943           kind = InstanceKlass_Kind;
 944         }
 945       } else if (k-&gt;is_typeArray_klass()) {
 946         kind = TypeArrayKlass_Kind;
 947       } else {
 948         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 949         kind = ObjArrayKlass_Kind;
 950       }
 951     }
 952     break;
 953 
 954   case MetaspaceObj::MethodType:
</pre>
<hr />
<pre>
1342     ShallowCopier(bool read_only) : _read_only(read_only) {}
1343 
1344     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1345       if (read_only == _read_only) {
1346         allocate(ref, read_only);
1347       }
1348       return true; // recurse into ref.obj()
1349     }
1350   };
1351 
1352   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1353   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1354   public:
1355     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1356       address new_loc = get_new_loc(ref);
1357       RefRelocator refer;
1358       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1359       return true; // recurse into ref.obj()
1360     }
1361     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
<span class="line-modified">1362       assert_valid(type);</span>
<span class="line-added">1363 </span>
1364       address obj = ref-&gt;obj();
1365       address new_obj = get_new_loc(ref);
1366       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1367       intptr_t* new_p = (intptr_t*)(new_obj + offset);
<span class="line-modified">1368       switch (type) {</span>
<span class="line-added">1369       case _method_entry_ref:</span>
<span class="line-added">1370         assert(*p == *new_p, &quot;must be a copy&quot;);</span>
<span class="line-added">1371         break;</span>
<span class="line-added">1372       case _internal_pointer_ref:</span>
<span class="line-added">1373         {</span>
<span class="line-added">1374           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));</span>
<span class="line-added">1375           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);</span>
<span class="line-added">1376           *((address*)new_p) = new_obj + off;</span>
<span class="line-added">1377         }</span>
<span class="line-added">1378         break;</span>
<span class="line-added">1379       default:</span>
<span class="line-added">1380         ShouldNotReachHere();</span>
<span class="line-added">1381       }</span>
1382       ArchivePtrMarker::mark_pointer((address*)new_p);
1383     }
1384   };
1385 
1386   // Relocate a reference to point to its shallow copy
1387   class RefRelocator: public MetaspaceClosure {
1388   public:
1389     virtual bool do_ref(Ref* ref, bool read_only) {
1390       if (ref-&gt;not_null()) {
1391         ref-&gt;update(get_new_loc(ref));
1392         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1393       }
1394       return false; // Do not recurse.
1395     }
1396   };
1397 
1398 #ifdef ASSERT
1399   class IsRefInArchiveChecker: public MetaspaceClosure {
1400   public:
1401     virtual bool do_ref(Ref* ref, bool read_only) {
</pre>
</td>
</tr>
</table>
<center><a href="metaspaceClosure.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="universe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
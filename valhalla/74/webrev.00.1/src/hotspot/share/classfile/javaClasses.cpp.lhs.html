<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<a name="2" id="anc2"></a>

  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  75 #endif
  76 
  77 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  78   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  79 
  80 #if INCLUDE_CDS
  81 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  82   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  83 #endif
  84 
  85 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  86   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  87 
  88 InjectedField JavaClasses::_injected_fields[] = {
  89   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  90 };
  91 
  92 // Register native methods of Object
  93 void java_lang_Object::register_natives(TRAPS) {
  94   InstanceKlass* obj = SystemDictionary::Object_klass();
  95   Method::register_native(obj, vmSymbols::hashCode_name(),
  96                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  97   Method::register_native(obj, vmSymbols::wait_name(),
  98                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
  99   Method::register_native(obj, vmSymbols::notify_name(),
 100                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 101   Method::register_native(obj, vmSymbols::notifyAll_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 103   Method::register_native(obj, vmSymbols::clone_name(),
 104                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 105 }
 106 
 107 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 108   return _injected_fields[id].compute_offset();
 109 }
 110 
 111 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 112   *field_count = 0;
 113 
 114   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 115   if (sid == vmSymbols::NO_SID) {
 116     // Only well known classes can inject fields
 117     return NULL;
 118   }
 119 
 120   int count = 0;
 121   int start = -1;
 122 
 123 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 124   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 125     count++;                                                       \
 126     if (start == -1) start = klass##_##name##_enum;                \
 127   }
 128   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 129 #undef LOOKUP_INJECTED_FIELD
 130 
 131   if (start != -1) {
 132     *field_count = count;
 133     return _injected_fields + start;
 134   }
 135   return NULL;
 136 }
 137 
 138 
 139 // Helpful routine for computing field offsets at run time rather than hardcoding them
 140 // Finds local fields only, including static fields.  Static field offsets are from the
 141 // beginning of the mirror.
 142 static void compute_offset(int &amp;dest_offset,
 143                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 144                            bool is_static = false) {
 145   fieldDescriptor fd;
 146   if (ik == NULL) {
 147     ResourceMark rm;
 148     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 149     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 150   }
 151 
 152   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 155                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 156 #ifndef PRODUCT
 157     // Prints all fields and offsets
 158     Log(class) lt;
 159     LogStream ls(lt.error());
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
 180 int java_lang_String::value_offset  = 0;
 181 int java_lang_String::hash_offset   = 0;
 182 int java_lang_String::hashIsZero_offset = 0;
 183 int java_lang_String::coder_offset  = 0;
 184 
 185 bool java_lang_String::initialized  = false;
 186 
 187 bool java_lang_String::is_instance(oop obj) {
 188   return is_instance_inlined(obj);
 189 }
 190 
 191 #if INCLUDE_CDS
 192 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 193   f-&gt;do_u4((u4*)&amp;offset)
 194 #endif
 195 
 196 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 197   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 198 
 199 #define STRING_FIELDS_DO(macro) \
 200   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 201   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 202   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 203   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 204 
 205 void java_lang_String::compute_offsets() {
 206   if (initialized) {
 207     return;
 208   }
 209 
 210   InstanceKlass* k = SystemDictionary::String_klass();
 211   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 212 
 213   initialized = true;
 214 }
 215 
 216 #if INCLUDE_CDS
 217 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 218   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 219   f-&gt;do_bool(&amp;initialized);
 220 }
 221 #endif
 222 
 223 class CompactStringsFixup : public FieldClosure {
 224 private:
 225   bool _value;
 226 
 227 public:
 228   CompactStringsFixup(bool value) : _value(value) {}
 229 
 230   void do_field(fieldDescriptor* fd) {
 231     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 232       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 233       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 234       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 235       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 236     }
 237   }
 238 };
 239 
 240 void java_lang_String::set_compact_strings(bool value) {
 241   CompactStringsFixup fix(value);
 242   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 243 }
 244 
 245 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 246   assert(initialized, &quot;Must be initialized&quot;);
 247   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 248 
 249   // Create the String object first, so there&#39;s a chance that the String
 250   // and the char array it points to end up in the same cache line.
 251   oop obj;
 252   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 253 
 254   // Create the char array.  The String object must be handlized here
 255   // because GC can happen as a result of the allocation attempt.
 256   Handle h_obj(THREAD, obj);
 257   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 258   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 259 
 260   // Point the String at the char array
 261   obj = h_obj();
 262   set_value(obj, buffer);
 263   // No need to zero the offset, allocation zero&#39;ed the entire String object
 264   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 265   return h_obj;
 266 }
 267 
 268 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 269   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 270   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 271   typeArrayOop buffer = value(h_obj());
 272   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 273   if (is_latin1) {
 274     for (int index = 0; index &lt; length; index++) {
 275       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 276     }
 277   } else {
 278     for (int index = 0; index &lt; length; index++) {
 279       buffer-&gt;char_at_put(index, unicode[index]);
 280     }
 281   }
 282 
 283 #ifdef ASSERT
 284   {
 285     ResourceMark rm;
 286     char* expected = UNICODE::as_utf8(unicode, length);
 287     char* actual = as_utf8_string(h_obj());
 288     if (strcmp(expected, actual) != 0) {
 289       fatal(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 290     }
 291   }
 292 #endif
 293 
 294   return h_obj;
 295 }
 296 
 297 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 298   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 299   return h_obj();
 300 }
 301 
 302 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 303   if (utf8_str == NULL) {
 304     return Handle();
 305   }
 306   bool has_multibyte, is_latin1;
 307   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 308   if (!CompactStrings) {
 309     has_multibyte = true;
 310     is_latin1 = false;
 311   }
 312 
 313   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 314   if (length &gt; 0) {
 315     if (!has_multibyte) {
 316       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 317       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 318     } else if (is_latin1) {
 319       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 320     } else {
 321       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 322     }
 323   }
 324 
 325 #ifdef ASSERT
 326   // This check is too strict when the input string is not a valid UTF8.
 327   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 328   if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {
 329     ResourceMark rm;
 330     const char* expected = utf8_str;
 331     char* actual = as_utf8_string(h_obj());
 332     if (strcmp(expected, actual) != 0) {
 333       fatal(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 334     }
 335   }
 336 #endif
 337 
 338   return h_obj;
 339 }
 340 
 341 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 342   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 343   return h_obj();
 344 }
 345 
 346 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 347   const char* utf8_str = (char*)symbol-&gt;bytes();
 348   int utf8_len = symbol-&gt;utf8_length();
 349 
 350   bool has_multibyte, is_latin1;
 351   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 352   if (!CompactStrings) {
 353     has_multibyte = true;
 354     is_latin1 = false;
 355   }
 356 
 357   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 358   if (length &gt; 0) {
 359     if (!has_multibyte) {
 360       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 361       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 362     } else if (is_latin1) {
 363       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 364     } else {
 365       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 366     }
 367   }
 368 
 369 #ifdef ASSERT
 370   {
 371     ResourceMark rm;
 372     const char* expected = symbol-&gt;as_utf8();
 373     char* actual = as_utf8_string(h_obj());
 374     if (strncmp(expected, actual, utf8_len) != 0) {
 375       fatal(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 376     }
 377   }
 378 #endif
 379 
 380   return h_obj;
 381 }
 382 
 383 // Converts a C string to a Java String based on current encoding
 384 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 385   assert(str != NULL, &quot;bad arguments&quot;);
 386 
 387   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 388   static to_java_string_fn_t _to_java_string_fn = NULL;
 389 
 390   if (_to_java_string_fn == NULL) {
 391     void *lib_handle = os::native_java_library();
 392     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 393 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 394     if (_to_java_string_fn == NULL) {
 395       // On 32 bit Windows, also try __stdcall decorated name
 396       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 397     }
 398 #endif
 399     if (_to_java_string_fn == NULL) {
 400       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 401     }
 402   }
 403 
 404   jstring js = NULL;
 405   {
 406     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 407     JavaThread* thread = (JavaThread*)THREAD;
 408     HandleMark hm(thread);
 409     ThreadToNativeFromVM ttn(thread);
 410     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 411   }
 412 
 413   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 414   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 415   return native_platform_string;
 416 }
 417 
 418 // Converts a Java String to a native C string that can be used for
 419 // native OS calls.
 420 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 421   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 422   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 423 
 424   if (_to_platform_string_fn == NULL) {
 425     void *lib_handle = os::native_java_library();
 426     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 427     if (_to_platform_string_fn == NULL) {
 428       fatal(&quot;GetStringPlatformChars missing&quot;);
 429     }
 430   }
 431 
 432   char *native_platform_string;
 433   { JavaThread* thread = (JavaThread*)THREAD;
 434     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 435     JNIEnv *env = thread-&gt;jni_environment();
 436     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 437     bool is_copy;
 438     HandleMark hm(thread);
 439     ThreadToNativeFromVM ttn(thread);
 440     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 441     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 442     JNIHandles::destroy_local(js);
 443   }
 444   return native_platform_string;
 445 }
 446 
 447 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 448   oop          obj    = java_string();
 449   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 450   typeArrayOop value  = java_lang_String::value(obj);
 451   int          length = java_lang_String::length(obj, value);
 452   bool      is_latin1 = java_lang_String::is_latin1(obj);
 453 
 454   // First check if any from_char exist
 455   int index; // Declared outside, used later
 456   for (index = 0; index &lt; length; index++) {
 457     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 458                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 459     if (c == from_char) {
 460       break;
 461     }
 462   }
 463   if (index == length) {
 464     // No from_char, so do not copy.
 465     return java_string;
 466   }
 467 
 468   // Check if result string will be latin1
 469   bool to_is_latin1 = false;
 470 
 471   // Replacement char must be latin1
 472   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 473     if (is_latin1) {
 474       // Source string is latin1 as well
 475       to_is_latin1 = true;
 476     } else if (!UNICODE::is_latin1(from_char)) {
 477       // We are replacing an UTF16 char. Scan string to
 478       // check if result can be latin1 encoded.
 479       to_is_latin1 = true;
 480       for (index = 0; index &lt; length; index++) {
 481         jchar c = value-&gt;char_at(index);
 482         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 483           to_is_latin1 = false;
 484           break;
 485         }
 486       }
 487     }
 488   }
 489 
 490   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 491   // may happen during String and char array creation.
 492   typeArrayHandle h_value(THREAD, value);
 493   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 494   typeArrayOop from_buffer = h_value();
 495   typeArrayOop to_buffer = java_lang_String::value(string());
 496 
 497   // Copy contents
 498   for (index = 0; index &lt; length; index++) {
 499     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 500                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 501     if (c == from_char) {
 502       c = to_char;
 503     }
 504     if (!to_is_latin1) {
 505       to_buffer-&gt;char_at_put(index, c);
 506     } else {
 507       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 508     }
 509   }
 510   return string;
 511 }
 512 
 513 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 514   typeArrayOop value  = java_lang_String::value(java_string);
 515                length = java_lang_String::length(java_string, value);
 516   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 517 
 518   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 519   if (result != NULL) {
 520     if (!is_latin1) {
 521       for (int index = 0; index &lt; length; index++) {
 522         result[index] = value-&gt;char_at(index);
 523       }
 524     } else {
 525       for (int index = 0; index &lt; length; index++) {
 526         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 527       }
 528     }
 529   } else {
 530     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 531   }
 532   return result;
 533 }
 534 
 535 unsigned int java_lang_String::hash_code(oop java_string) {
 536   // The hash and hashIsZero fields are subject to a benign data race,
 537   // making it crucial to ensure that any observable result of the
 538   // calculation in this method stays correct under any possible read of
 539   // these fields. Necessary restrictions to allow this to be correct
 540   // without explicit memory fences or similar concurrency primitives is
 541   // that we can ever only write to one of these two fields for a given
 542   // String instance, and that the computation is idempotent and derived
 543   // from immutable state
 544   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 545   if (java_lang_String::hash_is_set(java_string)) {
 546     return java_string-&gt;int_field(hash_offset);
 547   }
 548 
 549   typeArrayOop value = java_lang_String::value(java_string);
 550   int         length = java_lang_String::length(java_string, value);
 551   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 552 
 553   unsigned int hash = 0;
 554   if (length &gt; 0) {
 555     if (is_latin1) {
 556       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 557     } else {
 558       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 559     }
 560   }
 561 
 562   if (hash != 0) {
 563     java_string-&gt;int_field_put(hash_offset, hash);
 564   } else {
 565     java_string-&gt;bool_field_put(hashIsZero_offset, true);
 566   }
 567   return hash;
 568 }
 569 
 570 char* java_lang_String::as_quoted_ascii(oop java_string) {
 571   typeArrayOop value  = java_lang_String::value(java_string);
 572   int          length = java_lang_String::length(java_string, value);
 573   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 574 
 575   if (length == 0) return NULL;
 576 
 577   char* result;
 578   int result_length;
 579   if (!is_latin1) {
 580     jchar* base = value-&gt;char_at_addr(0);
 581     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 582     result = NEW_RESOURCE_ARRAY(char, result_length);
 583     UNICODE::as_quoted_ascii(base, length, result, result_length);
 584   } else {
 585     jbyte* base = value-&gt;byte_at_addr(0);
 586     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 587     result = NEW_RESOURCE_ARRAY(char, result_length);
 588     UNICODE::as_quoted_ascii(base, length, result, result_length);
 589   }
 590   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 591   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 592   return result;
 593 }
 594 
 595 Symbol* java_lang_String::as_symbol(oop java_string) {
 596   typeArrayOop value  = java_lang_String::value(java_string);
 597   int          length = java_lang_String::length(java_string, value);
 598   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 599   if (!is_latin1) {
 600     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 601     Symbol* sym = SymbolTable::new_symbol(base, length);
 602     return sym;
 603   } else {
 604     ResourceMark rm;
 605     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 606     const char* base = UNICODE::as_utf8(position, length);
 607     Symbol* sym = SymbolTable::new_symbol(base, length);
 608     return sym;
 609   }
 610 }
 611 
 612 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 613   typeArrayOop value  = java_lang_String::value(java_string);
 614   int          length = java_lang_String::length(java_string, value);
 615   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 616   if (!is_latin1) {
 617     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 618     return SymbolTable::probe_unicode(base, length);
 619   } else {
 620     ResourceMark rm;
 621     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 622     const char* base = UNICODE::as_utf8(position, length);
 623     return SymbolTable::probe(base, length);
 624   }
 625 }
 626 
 627 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 628   assert(value_equals(value, java_lang_String::value(java_string)),
 629          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 630   int length = java_lang_String::length(java_string, value);
 631   if (length == 0) {
 632     return 0;
 633   }
 634   if (!java_lang_String::is_latin1(java_string)) {
 635     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 636   } else {
 637     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 638   }
 639 }
 640 
 641 int java_lang_String::utf8_length(oop java_string) {
 642   typeArrayOop value = java_lang_String::value(java_string);
 643   return utf8_length(java_string, value);
 644 }
 645 
 646 char* java_lang_String::as_utf8_string(oop java_string) {
 647   int length;
 648   return as_utf8_string(java_string, length);
 649 }
 650 
 651 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 652   typeArrayOop value = java_lang_String::value(java_string);
 653   length             = java_lang_String::length(java_string, value);
 654   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 655   if (!is_latin1) {
 656     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 657     return UNICODE::as_utf8(position, length);
 658   } else {
 659     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 660     return UNICODE::as_utf8(position, length);
 661   }
 662 }
 663 
 664 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 665 // a resource array to fit
 666 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 667   typeArrayOop value = java_lang_String::value(java_string);
 668   int            len = java_lang_String::length(java_string, value);
 669   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 670   if (!is_latin1) {
 671     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 672     utf8_len = UNICODE::utf8_length(position, len);
 673     if (utf8_len &gt;= buflen) {
 674       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 675     }
 676     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 677   } else {
 678     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 679     utf8_len = UNICODE::utf8_length(position, len);
 680     if (utf8_len &gt;= buflen) {
 681       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 682     }
 683     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 684   }
 685 }
 686 
 687 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 688   assert(value_equals(value, java_lang_String::value(java_string)),
 689          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 690   int     length = java_lang_String::length(java_string, value);
 691   bool is_latin1 = java_lang_String::is_latin1(java_string);
 692   if (!is_latin1) {
 693     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 694     return UNICODE::as_utf8(position, length, buf, buflen);
 695   } else {
 696     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 697     return UNICODE::as_utf8(position, length, buf, buflen);
 698   }
 699 }
 700 
 701 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 702   typeArrayOop value = java_lang_String::value(java_string);
 703   return as_utf8_string(java_string, value, buf, buflen);
 704 }
 705 
 706 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 707   typeArrayOop value  = java_lang_String::value(java_string);
 708   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 709   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 710   if (!is_latin1) {
 711     jchar* position = value-&gt;char_at_addr(start);
 712     return UNICODE::as_utf8(position, len);
 713   } else {
 714     jbyte* position = value-&gt;byte_at_addr(start);
 715     return UNICODE::as_utf8(position, len);
 716   }
 717 }
 718 
 719 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 720   assert(value_equals(value, java_lang_String::value(java_string)),
 721          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 722   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 723   bool is_latin1 = java_lang_String::is_latin1(java_string);
 724   if (!is_latin1) {
 725     jchar* position = value-&gt;char_at_addr(start);
 726     return UNICODE::as_utf8(position, len, buf, buflen);
 727   } else {
 728     jbyte* position = value-&gt;byte_at_addr(start);
 729     return UNICODE::as_utf8(position, len, buf, buflen);
 730   }
 731 }
 732 
 733 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 734   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 735          &quot;must be java_string&quot;);
 736   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 737   int length = java_lang_String::length(java_string, value);
 738   if (length != len) {
 739     return false;
 740   }
 741   bool is_latin1 = java_lang_String::is_latin1(java_string);
 742   if (!is_latin1) {
 743     for (int i = 0; i &lt; len; i++) {
 744       if (value-&gt;char_at(i) != chars[i]) {
 745         return false;
 746       }
 747     }
 748   } else {
 749     for (int i = 0; i &lt; len; i++) {
 750       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 751         return false;
 752       }
 753     }
 754   }
 755   return true;
 756 }
 757 
 758 bool java_lang_String::equals(oop str1, oop str2) {
 759   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 760          &quot;must be java String&quot;);
 761   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 762          &quot;must be java String&quot;);
 763   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 764   bool         is_latin1 = java_lang_String::is_latin1(str1);
 765   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 766   bool         is_latin2 = java_lang_String::is_latin1(str2);
 767 
 768   if (is_latin1 != is_latin2) {
 769     // Strings with different coders are never equal.
 770     return false;
 771   }
 772   return value_equals(value1, value2);
 773 }
 774 
 775 void java_lang_String::print(oop java_string, outputStream* st) {
 776   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 777   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 778 
 779   if (value == NULL) {
 780     // This can happen if, e.g., printing a String
 781     // object before its initializer has been called
 782     st-&gt;print(&quot;NULL&quot;);
 783     return;
 784   }
 785 
 786   int length = java_lang_String::length(java_string, value);
 787   bool is_latin1 = java_lang_String::is_latin1(java_string);
 788 
 789   st-&gt;print(&quot;\&quot;&quot;);
 790   for (int index = 0; index &lt; length; index++) {
 791     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 792                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 793   }
 794   st-&gt;print(&quot;\&quot;&quot;);
 795 }
 796 
 797 
 798 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 799   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 800   if (fd-&gt;has_initial_value()) {
 801     BasicType t = fd-&gt;field_type();
 802     switch (t) {
 803       case T_BYTE:
 804         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 805               break;
 806       case T_BOOLEAN:
 807         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 808               break;
 809       case T_CHAR:
 810         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 811               break;
 812       case T_SHORT:
 813         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 814               break;
 815       case T_INT:
 816         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 817         break;
 818       case T_FLOAT:
 819         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 820         break;
 821       case T_DOUBLE:
 822         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 823         break;
 824       case T_LONG:
 825         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 826         break;
 827       case T_OBJECT:
 828         {
 829           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 830                  &quot;just checking&quot;);
 831           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 832             // Archive the String field and update the pointer.
 833             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 834             oop archived_s = StringTable::create_archived_string(s, CHECK);
 835             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 836           } else {
 837             oop string = fd-&gt;string_initial_value(CHECK);
 838             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 839           }
 840         }
 841         break;
 842       default:
 843         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 844                   &quot;Illegal ConstantValue attribute in class file&quot;);
 845     }
 846   }
 847 }
 848 
 849 
 850 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 851   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 852 
 853   // If the offset was read from the shared archive, it was fixed up already
 854   if (!k-&gt;is_shared()) {
 855     if (k-&gt;is_instance_klass()) {
 856       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 857       // offsets were computed without the size added it.  Go back and
 858       // update all the static field offsets to included the size.
 859       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 860         if (fs.access_flags().is_static()) {
 861           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 862           fs.set_offset(real_offset);
 863         }
 864       }
 865     }
 866   }
 867 
 868   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 869     if (HeapShared::open_archive_heap_region_mapped()) {
 870       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 871       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 872       return;
 873     } else {
 874       k-&gt;set_java_mirror_handle(NULL);
 875       k-&gt;clear_has_raw_archived_mirror();
 876     }
 877   }
 878   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 879 }
 880 
 881 void java_lang_Class::initialize_mirror_fields(Klass* k,
 882                                                Handle mirror,
 883                                                Handle protection_domain,
 884                                                Handle classData,
 885                                                TRAPS) {
 886   // Allocate a simple java object for a lock.
 887   // This needs to be a java object because during class initialization
 888   // it can be held across a java call.
 889   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 890   set_init_lock(mirror(), r);
 891 
 892   // Set protection domain also
 893   set_protection_domain(mirror(), protection_domain());
 894 
 895   // Initialize static fields
 896   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 897 
 898  // Set classData
 899   set_class_data(mirror(), classData());
 900 }
 901 
 902 // Set the java.lang.Module module field in the java_lang_Class mirror
 903 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 904   if (module.is_null()) {
 905     // During startup, the module may be NULL only if java.base has not been defined yet.
 906     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 907     // for java.base is known. But note that since we captured the NULL module another
 908     // thread may have completed that initialization.
 909 
 910     bool javabase_was_defined = false;
 911     {
 912       MutexLocker m1(THREAD, Module_lock);
 913       // Keep list of classes needing java.base module fixup
 914       if (!ModuleEntryTable::javabase_defined()) {
 915         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 916         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 917         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 918         fixup_module_field_list()-&gt;push(k);
 919       } else {
 920         javabase_was_defined = true;
 921       }
 922     }
 923 
 924     // If java.base was already defined then patch this particular class with java.base.
 925     if (javabase_was_defined) {
 926       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 927       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 928              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 929       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 930       set_module(mirror(), javabase_handle());
 931     }
 932   } else {
 933     assert(Universe::is_module_initialized() ||
 934            (ModuleEntryTable::javabase_defined() &amp;&amp;
 935             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 936            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 937     set_module(mirror(), module());
 938   }
 939 }
 940 
 941 // Statically allocate fixup lists because they always get created.
 942 void java_lang_Class::allocate_fixup_lists() {
 943   GrowableArray&lt;Klass*&gt;* mirror_list =
 944     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 945   set_fixup_mirror_list(mirror_list);
 946 
 947   GrowableArray&lt;Klass*&gt;* module_list =
 948     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 949   set_fixup_module_field_list(module_list);
 950 }
 951 
 952 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 953                                     Handle module, Handle protection_domain,
 954                                     Handle classData, TRAPS) {
 955   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 956   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 957 
 958   // Use this moment of initialization to cache modifier_flags also,
 959   // to support Class.getModifiers().  Instance classes recalculate
 960   // the cached flags after the class file is parsed, but before the
 961   // class is put into the system dictionary.
 962   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 963   k-&gt;set_modifier_flags(computed_modifiers);
 964   // Class_klass has to be loaded because it is used to allocate
 965   // the mirror.
 966   if (SystemDictionary::Class_klass_loaded()) {
 967     // Allocate mirror (java.lang.Class instance)
 968     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 969     Handle mirror(THREAD, mirror_oop);
 970     Handle comp_mirror;
 971 
 972     // Setup indirection from mirror-&gt;klass
 973     java_lang_Class::set_klass(mirror(), k);
 974 
 975     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 976     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 977 
 978     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 979 
 980     // It might also have a component mirror.  This mirror must already exist.
 981     if (k-&gt;is_array_klass()) {
<a name="3" id="anc3"></a><span class="line-modified"> 982       if (k-&gt;is_typeArray_klass()) {</span>





 983         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 984         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 985       } else {
 986         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 987         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 988         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 989         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 990       }
 991       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 992 
 993       // Two-way link between the array klass and its component mirror:
 994       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 995       set_component_mirror(mirror(), comp_mirror());
 996       // See below for ordering dependencies between field array_klass in component mirror
 997       // and java_mirror in this klass.
 998     } else {
 999       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1000 
1001       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1002       if (HAS_PENDING_EXCEPTION) {
1003         // If any of the fields throws an exception like OOM remove the klass field
1004         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1005         // This mirror looks like a primitive type, which logically it is because it
1006         // it represents no class.
1007         java_lang_Class::set_klass(mirror(), NULL);
1008         return;
1009       }
1010     }
1011 
1012     // set the classLoader field in the java_lang_Class instance
1013     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1014     set_class_loader(mirror(), class_loader());
1015 
1016     // Setup indirection from klass-&gt;mirror
1017     // after any exceptions can happen during allocations.
1018     k-&gt;set_java_mirror(mirror);
1019 
1020     // Set the module field in the java_lang_Class instance.  This must be done
1021     // after the mirror is set.
1022     set_mirror_module_field(k, mirror, module, THREAD);
1023 
1024     if (comp_mirror() != NULL) {
1025       // Set after k-&gt;java_mirror() is published, because compiled code running
1026       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1027       release_set_array_klass(comp_mirror(), k);
1028     }
<a name="4" id="anc4"></a>
















1029   } else {
1030     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1031     fixup_mirror_list()-&gt;push(k);
1032   }
1033 }
1034 
1035 #if INCLUDE_CDS_JAVA_HEAP
1036 // Clears mirror fields. Static final fields with initial values are reloaded
1037 // from constant pool. The object identity hash is in the object header and is
1038 // not affected.
1039 class ResetMirrorField: public FieldClosure {
1040  private:
1041   Handle _m;
1042 
1043  public:
1044   ResetMirrorField(Handle mirror) : _m(mirror) {}
1045 
1046   void do_field(fieldDescriptor* fd) {
1047     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1048     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1049 
1050     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1051       initialize_static_field(fd, _m, Thread::current());
1052       return;
1053     }
1054 
1055     BasicType ft = fd-&gt;field_type();
1056     switch (ft) {
1057       case T_BYTE:
1058         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1059         break;
1060       case T_CHAR:
1061         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1062         break;
1063       case T_DOUBLE:
1064         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1065         break;
1066       case T_FLOAT:
1067         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1068         break;
1069       case T_INT:
1070         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1071         break;
1072       case T_LONG:
1073         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1074         break;
1075       case T_SHORT:
1076         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1077         break;
1078       case T_BOOLEAN:
1079         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1080         break;
1081       case T_ARRAY:
1082       case T_OBJECT: {
1083         // It might be useful to cache the String field, but
1084         // for now just clear out any reference field
1085         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1086         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1087         break;
1088       }
1089       default:
1090         ShouldNotReachHere();
1091         break;
1092      }
1093   }
1094 };
1095 
1096 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1097   assert(HeapShared::is_heap_object_archiving_allowed(),
1098          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1099 
1100   for (int t = 0; t &lt;= T_VOID; t++) {
1101     oop m = Universe::_mirrors[t];
1102     if (m != NULL) {
1103       // Update the field at _array_klass_offset to point to the relocated array klass.
1104       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1105       assert(archived_m != NULL, &quot;sanity&quot;);
1106       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1107       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1108       if (ak != NULL) {
1109         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1110         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1111       }
1112 
1113       // Clear the fields. Just to be safe
1114       Klass *k = m-&gt;klass();
1115       Handle archived_mirror_h(THREAD, archived_m);
1116       ResetMirrorField reset(archived_mirror_h);
1117       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1118 
1119       log_trace(cds, heap, mirror)(
1120         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1121         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1122 
1123       Universe::_mirrors[t] = archived_m;
1124     }
1125   }
1126 
1127   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1128          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1129          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1130          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1131          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1132          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1133          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1134          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1135          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1136 
1137   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1138   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1139   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1140   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1141   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1142   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1143   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1144   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1145   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1146 }
1147 
1148 //
1149 // After the mirror object is successfully archived, the archived
1150 // klass is set with _has_archived_raw_mirror flag.
1151 //
1152 // The _has_archived_raw_mirror flag is cleared at runtime when the
1153 // archived mirror is restored. If archived java heap data cannot
1154 // be used at runtime, new mirror object is created for the shared
1155 // class. The _has_archived_raw_mirror is cleared also during the process.
1156 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1157   assert(HeapShared::is_heap_object_archiving_allowed(),
1158          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1159 
1160   // Mirror is already archived
1161   if (k-&gt;has_raw_archived_mirror()) {
1162     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1163     return k-&gt;archived_java_mirror_raw();
1164   }
1165 
1166   // No mirror
1167   oop mirror = k-&gt;java_mirror();
1168   if (mirror == NULL) {
1169     return NULL;
1170   }
1171 
1172   if (k-&gt;is_instance_klass()) {
1173     InstanceKlass *ik = InstanceKlass::cast(k);
1174     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1175 
1176     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1177           ik-&gt;is_shared_app_class())) {
1178       // Archiving mirror for classes from non-builtin loaders is not
1179       // supported. Clear the _java_mirror within the archived class.
1180       k-&gt;set_java_mirror_handle(NULL);
1181       return NULL;
1182     }
1183   }
1184 
<a name="5" id="anc5"></a>





1185   // Now start archiving the mirror object
1186   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1187   if (archived_mirror == NULL) {
1188     return NULL;
1189   }
1190 
1191   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1192   if (archived_mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1197 
1198   k-&gt;set_has_raw_archived_mirror();
1199 
1200   ResourceMark rm;
1201   log_trace(cds, heap, mirror)(
1202     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1203     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1204 
1205   return archived_mirror;
1206 }
1207 
1208 // The process is based on create_mirror().
1209 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1210                                              oop archived_mirror,
1211                                              Thread *THREAD) {
1212   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1213   // to archived metadata and objects below.
1214   Klass *c = archived_mirror-&gt;klass();
1215   Handle archived_mirror_h(THREAD, archived_mirror);
1216   ResetMirrorField reset(archived_mirror_h);
1217   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1218 
1219   if (k-&gt;is_array_klass()) {
1220     oop archived_comp_mirror;
1221     if (k-&gt;is_typeArray_klass()) {
1222       // The primitive type mirrors are already archived. Get the archived mirror.
1223       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1224       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1225       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1226     } else {
1227       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1228       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1229       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1230       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1231       if (archived_comp_mirror == NULL) {
1232         return NULL;
1233       }
1234     }
1235     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1236   } else {
1237     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1238 
1239     // Reset local static fields in the mirror
1240     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1241 
1242     java_lang_Class:set_init_lock(archived_mirror, NULL);
1243 
1244     set_protection_domain(archived_mirror, NULL);
1245   }
1246 
1247   // clear class loader and mirror_module_field
1248   set_class_loader(archived_mirror, NULL);
1249   set_module(archived_mirror, NULL);
1250 
1251   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1252   // klass. Updated the field in the archived mirror to point to the relocated
1253   // klass in the archive.
1254   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1255   log_debug(cds, heap, mirror)(
1256     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1257     p2i(as_Klass(mirror)), p2i(reloc_k));
1258   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1259 
1260   // The field at _array_klass_offset is pointing to the original one dimension
1261   // higher array klass if exists. Relocate the pointer.
1262   Klass *arr = array_klass_acquire(mirror);
1263   if (arr != NULL) {
1264     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1265     log_debug(cds, heap, mirror)(
1266       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1267       p2i(arr), p2i(reloc_arr));
1268     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1269   }
1270   return archived_mirror;
1271 }
1272 
1273 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1274   if (MetaspaceShared::relocation_delta() != 0) {
1275     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1276 
1277     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1278     if (ak != NULL) {
1279       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1280           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1281     }
1282   }
1283 }
1284 
1285 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1286   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1287 
1288   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1289   archived_mirror-&gt;metadata_field_put(_klass_offset,
1290       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1291 
1292   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1293   if (ak != NULL) {
1294     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1295         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1296   }
1297 }
1298 
1299 
1300 // Returns true if the mirror is updated, false if no archived mirror
1301 // data is present. After the archived mirror object is restored, the
1302 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1303 bool java_lang_Class::restore_archived_mirror(Klass *k,
1304                                               Handle class_loader, Handle module,
1305                                               Handle protection_domain, TRAPS) {
1306   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1307   // see more details in SystemDictionary::resolve_well_known_classes().
1308   if (!SystemDictionary::Class_klass_loaded()) {
1309     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1310     fixup_mirror_list()-&gt;push(k);
1311     return true;
1312   }
1313 
1314   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1315   if (m == NULL) {
1316     return false;
1317   }
1318 
1319   // mirror is archived, restore
1320   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1321   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1322   assert(as_Klass(m) == k, &quot;must be&quot;);
1323   Handle mirror(THREAD, m);
1324 
1325   if (!k-&gt;is_array_klass()) {
1326     // - local static final fields with initial values were initialized at dump time
1327 
1328     // create the init_lock
1329     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1330     set_init_lock(mirror(), r);
1331 
1332     if (protection_domain.not_null()) {
1333       set_protection_domain(mirror(), protection_domain());
1334     }
1335   }
1336 
1337   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1338   if (class_loader.not_null()) {
1339     set_class_loader(mirror(), class_loader());
1340   }
1341 
1342   k-&gt;set_java_mirror(mirror);
1343   k-&gt;clear_has_raw_archived_mirror();
1344 
1345   set_mirror_module_field(k, mirror, module, THREAD);
1346 
1347   if (log_is_enabled(Trace, cds, heap, mirror)) {
1348     ResourceMark rm(THREAD);
1349     log_trace(cds, heap, mirror)(
1350         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1351   }
1352 
1353   return true;
1354 }
1355 #endif // INCLUDE_CDS_JAVA_HEAP
1356 
1357 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1358   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1359   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1360 }
1361 
1362 int  java_lang_Class::oop_size(oop java_class) {
1363   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1364   int size = java_class-&gt;int_field(_oop_size_offset);
1365   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1366   return size;
1367 }
1368 
1369 
1370 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1371   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1372   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1373   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1374 }
1375 
1376 int  java_lang_Class::static_oop_field_count(oop java_class) {
1377   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1378   return java_class-&gt;int_field(_static_oop_field_count_offset);
1379 }
1380 
1381 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1382   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1383   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1384 }
1385 
1386 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1387   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1388   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1389 }
1390 
1391 oop java_lang_Class::protection_domain(oop java_class) {
1392   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1393   return java_class-&gt;obj_field(_protection_domain_offset);
1394 }
1395 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1396   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1397   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1398 }
1399 
1400 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1401   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1402     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1403   }
1404 oop java_lang_Class::component_mirror(oop java_class) {
1405   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1406   return java_class-&gt;obj_field(_component_mirror_offset);
1407 }
1408 
1409 oop java_lang_Class::init_lock(oop java_class) {
1410   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1411   return java_class-&gt;obj_field(_init_lock_offset);
1412 }
1413 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1414   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1415   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1416 }
1417 
1418 objArrayOop java_lang_Class::signers(oop java_class) {
1419   assert(_signers_offset != 0, &quot;must be set&quot;);
1420   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1421 }
1422 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1423   assert(_signers_offset != 0, &quot;must be set&quot;);
1424   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1425 }
1426 
1427 oop java_lang_Class::class_data(oop java_class) {
1428   assert(_classData_offset != 0, &quot;must be set&quot;);
1429   return java_class-&gt;obj_field(_classData_offset);
1430 }
1431 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1432   assert(_classData_offset != 0, &quot;must be set&quot;);
1433   java_class-&gt;obj_field_put(_classData_offset, class_data);
1434 }
1435 
1436 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1437   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1438   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1439 }
1440 
1441 oop java_lang_Class::class_loader(oop java_class) {
1442   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1443   return java_class-&gt;obj_field(_class_loader_offset);
1444 }
1445 
1446 oop java_lang_Class::module(oop java_class) {
1447   assert(_module_offset != 0, &quot;must be set&quot;);
1448   return java_class-&gt;obj_field(_module_offset);
1449 }
1450 
1451 void java_lang_Class::set_module(oop java_class, oop module) {
1452   assert(_module_offset != 0, &quot;must be set&quot;);
1453   java_class-&gt;obj_field_put(_module_offset, module);
1454 }
1455 
1456 oop java_lang_Class::name(Handle java_class, TRAPS) {
1457   assert(_name_offset != 0, &quot;must be set&quot;);
1458   oop o = java_class-&gt;obj_field(_name_offset);
1459   if (o == NULL) {
1460     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1461     java_class-&gt;obj_field_put(_name_offset, o);
1462   }
1463   return o;
1464 }
1465 
1466 oop java_lang_Class::source_file(oop java_class) {
1467   assert(_source_file_offset != 0, &quot;must be set&quot;);
1468   return java_class-&gt;obj_field(_source_file_offset);
1469 }
1470 
1471 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1472   assert(_source_file_offset != 0, &quot;must be set&quot;);
1473   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1474 }
1475 
<a name="6" id="anc6"></a>



















1476 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1477   // This should be improved by adding a field at the Java level or by
1478   // introducing a new VM klass (see comment in ClassFileParser)
1479   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1480   if (type != T_VOID) {
1481     Klass* aklass = Universe::typeArrayKlassObj(type);
1482     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1483     release_set_array_klass(java_class, aklass);
1484   }
1485 #ifdef ASSERT
1486   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1487   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1488 #endif
1489   return java_class;
1490 }
1491 
1492 
1493 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1494   //%note memory_2
1495   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1496   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1497   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1498   return k;
1499 }
1500 
1501 
1502 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1503   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1504   java_class-&gt;metadata_field_put(_klass_offset, klass);
1505 }
1506 
1507 
1508 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1509   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1510   Symbol* name = NULL;
1511   bool is_instance = false;
<a name="7" id="anc7"></a>
1512   if (is_primitive(java_class)) {
1513     name = vmSymbols::type_signature(primitive_type(java_class));
1514   } else {
1515     Klass* k = as_Klass(java_class);
1516     is_instance = k-&gt;is_instance_klass();
<a name="8" id="anc8"></a>
1517     name = k-&gt;name();
1518   }
1519   if (name == NULL) {
1520     st-&gt;print(&quot;&lt;null&gt;&quot;);
1521     return;
1522   }
<a name="9" id="anc9"></a><span class="line-modified">1523   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1524   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1525   if (is_instance)  st-&gt;print(&quot;;&quot;);
1526 }
1527 
1528 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1529   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1530   Symbol* name;
1531   if (is_primitive(java_class)) {
1532     name = vmSymbols::type_signature(primitive_type(java_class));
1533     // Because this can create a new symbol, the caller has to decrement
1534     // the refcount, so make adjustment here and below for symbols returned
1535     // that are not created or incremented due to a successful lookup.
1536     name-&gt;increment_refcount();
1537   } else {
1538     Klass* k = as_Klass(java_class);
1539     if (!k-&gt;is_instance_klass()) {
1540       name = k-&gt;name();
1541       name-&gt;increment_refcount();
1542     } else {
1543       ResourceMark rm;
1544       const char* sigstr = k-&gt;signature_name();
<a name="10" id="anc10"></a><span class="line-modified">1545       int         siglen = (int) strlen(sigstr);</span>
1546       if (!intern_if_not_found) {
1547         name = SymbolTable::probe(sigstr, siglen);
1548       } else {
1549         name = SymbolTable::new_symbol(sigstr, siglen);
1550       }
1551     }
1552   }
1553   return name;
1554 }
1555 
1556 // Returns the Java name for this Java mirror (Resource allocated)
1557 // See Klass::external_name().
1558 // For primitive type Java mirrors, its type name is returned.
1559 const char* java_lang_Class::as_external_name(oop java_class) {
1560   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1561   const char* name = NULL;
1562   if (is_primitive(java_class)) {
1563     name = type2name(primitive_type(java_class));
1564   } else {
1565     name = as_Klass(java_class)-&gt;external_name();
1566   }
1567   if (name == NULL) {
1568     name = &quot;&lt;null&gt;&quot;;
1569   }
1570   return name;
1571 }
1572 
1573 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1574   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1575   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1576   return k;
1577 }
1578 
1579 
1580 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1581   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1582   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1583 }
1584 
1585 
1586 BasicType java_lang_Class::primitive_type(oop java_class) {
1587   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1588   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1589   BasicType type = T_VOID;
1590   if (ak != NULL) {
1591     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1592     type = ArrayKlass::cast(ak)-&gt;element_type();
1593   } else {
1594     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1595   }
1596   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1597   return type;
1598 }
1599 
1600 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1601   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1602   if (is_primitive(java_class)) {
1603     if (reference_klass != NULL)
1604       (*reference_klass) = NULL;
1605     return primitive_type(java_class);
1606   } else {
1607     if (reference_klass != NULL)
1608       (*reference_klass) = as_Klass(java_class);
1609     return T_OBJECT;
1610   }
1611 }
1612 
1613 
1614 oop java_lang_Class::primitive_mirror(BasicType t) {
1615   oop mirror = Universe::java_mirror(t);
1616   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1617   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1618   return mirror;
1619 }
1620 
1621 bool java_lang_Class::offsets_computed = false;
1622 int  java_lang_Class::classRedefinedCount_offset = -1;
1623 
1624 #define CLASS_FIELDS_DO(macro) \
1625   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1626   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1627   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1628   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1629   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<a name="11" id="anc11"></a>

1630   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1631 
1632 void java_lang_Class::compute_offsets() {
1633   if (offsets_computed) {
1634     return;
1635   }
1636 
1637   offsets_computed = true;
1638 
1639   InstanceKlass* k = SystemDictionary::Class_klass();
1640   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1641 
1642   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1643   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1644   // GC treats them the same.
1645   _init_lock_offset = _component_mirror_offset;
1646 
1647   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1648 }
1649 
1650 #if INCLUDE_CDS
1651 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1652   f-&gt;do_bool(&amp;offsets_computed);
1653   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1654 
1655   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1656 
1657   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1658 }
1659 #endif
1660 
1661 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1662   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1663   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1664 }
1665 
1666 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1667   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1668   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1669 }
1670 
1671 
1672 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1673 //       platform thread structure, and a eetop offset which was used for thread
1674 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1675 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1676 //       instead of the privateInfo_offset.
1677 //
1678 // Note: The stackSize field is only present starting in 1.4.
1679 
1680 int java_lang_Thread::_name_offset = 0;
1681 int java_lang_Thread::_group_offset = 0;
1682 int java_lang_Thread::_contextClassLoader_offset = 0;
1683 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1684 int java_lang_Thread::_priority_offset = 0;
1685 int java_lang_Thread::_eetop_offset = 0;
1686 int java_lang_Thread::_interrupted_offset = 0;
1687 int java_lang_Thread::_daemon_offset = 0;
1688 int java_lang_Thread::_stillborn_offset = 0;
1689 int java_lang_Thread::_stackSize_offset = 0;
1690 int java_lang_Thread::_tid_offset = 0;
1691 int java_lang_Thread::_thread_status_offset = 0;
1692 int java_lang_Thread::_park_blocker_offset = 0;
1693 
1694 #define THREAD_FIELDS_DO(macro) \
1695   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1696   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1697   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1698   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1699   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1700   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1701   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1702   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1703   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1704   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1705   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1706   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1707   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1708 
1709 void java_lang_Thread::compute_offsets() {
1710   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1711 
1712   InstanceKlass* k = SystemDictionary::Thread_klass();
1713   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1714 }
1715 
1716 #if INCLUDE_CDS
1717 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1718   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1719 }
1720 #endif
1721 
1722 JavaThread* java_lang_Thread::thread(oop java_thread) {
1723   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1724 }
1725 
1726 
1727 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1728   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1729 }
1730 
1731 bool java_lang_Thread::interrupted(oop java_thread) {
1732   // Make sure the caller can safely access oops.
1733   assert(Thread::current()-&gt;is_VM_thread() ||
1734          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1735           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1736          &quot;Unsafe access to oop&quot;);
1737   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1738 }
1739 
1740 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1741   // Make sure the caller can safely access oops.
1742   assert(Thread::current()-&gt;is_VM_thread() ||
1743          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1744           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1745          &quot;Unsafe access to oop&quot;);
1746   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1747 }
1748 
1749 
1750 oop java_lang_Thread::name(oop java_thread) {
1751   return java_thread-&gt;obj_field(_name_offset);
1752 }
1753 
1754 
1755 void java_lang_Thread::set_name(oop java_thread, oop name) {
1756   java_thread-&gt;obj_field_put(_name_offset, name);
1757 }
1758 
1759 
1760 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1761   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1762 }
1763 
1764 
1765 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1766   java_thread-&gt;int_field_put(_priority_offset, priority);
1767 }
1768 
1769 
1770 oop java_lang_Thread::threadGroup(oop java_thread) {
1771   return java_thread-&gt;obj_field(_group_offset);
1772 }
1773 
1774 
1775 bool java_lang_Thread::is_stillborn(oop java_thread) {
1776   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1777 }
1778 
1779 
1780 // We never have reason to turn the stillborn bit off
1781 void java_lang_Thread::set_stillborn(oop java_thread) {
1782   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1783 }
1784 
1785 
1786 bool java_lang_Thread::is_alive(oop java_thread) {
1787   JavaThread* thr = java_lang_Thread::thread(java_thread);
1788   return (thr != NULL);
1789 }
1790 
1791 
1792 bool java_lang_Thread::is_daemon(oop java_thread) {
1793   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1794 }
1795 
1796 
1797 void java_lang_Thread::set_daemon(oop java_thread) {
1798   java_thread-&gt;bool_field_put(_daemon_offset, true);
1799 }
1800 
1801 oop java_lang_Thread::context_class_loader(oop java_thread) {
1802   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1803 }
1804 
1805 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1806   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1807 }
1808 
1809 
1810 jlong java_lang_Thread::stackSize(oop java_thread) {
1811   return java_thread-&gt;long_field(_stackSize_offset);
1812 }
1813 
1814 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1815 void java_lang_Thread::set_thread_status(oop java_thread,
1816                                          java_lang_Thread::ThreadStatus status) {
1817   java_thread-&gt;int_field_put(_thread_status_offset, status);
1818 }
1819 
1820 // Read thread status value from threadStatus field in java.lang.Thread java class.
1821 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1822   // Make sure the caller is operating on behalf of the VM or is
1823   // running VM code (state == _thread_in_vm).
1824   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1825          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1826          &quot;Java Thread is not running in vm&quot;);
1827   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1828 }
1829 
1830 
1831 jlong java_lang_Thread::thread_id(oop java_thread) {
1832   return java_thread-&gt;long_field(_tid_offset);
1833 }
1834 
1835 oop java_lang_Thread::park_blocker(oop java_thread) {
1836   return java_thread-&gt;obj_field(_park_blocker_offset);
1837 }
1838 
1839 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1840   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1841   switch (status) {
1842     case NEW                      : return &quot;NEW&quot;;
1843     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1844     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1845     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1846     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1847     case PARKED                   : return &quot;WAITING (parking)&quot;;
1848     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1849     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1850     case TERMINATED               : return &quot;TERMINATED&quot;;
1851     default                       : return &quot;UNKNOWN&quot;;
1852   };
1853 }
1854 int java_lang_ThreadGroup::_parent_offset = 0;
1855 int java_lang_ThreadGroup::_name_offset = 0;
1856 int java_lang_ThreadGroup::_threads_offset = 0;
1857 int java_lang_ThreadGroup::_groups_offset = 0;
1858 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1859 int java_lang_ThreadGroup::_destroyed_offset = 0;
1860 int java_lang_ThreadGroup::_daemon_offset = 0;
1861 int java_lang_ThreadGroup::_nthreads_offset = 0;
1862 int java_lang_ThreadGroup::_ngroups_offset = 0;
1863 
1864 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1865   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1866   return java_thread_group-&gt;obj_field(_parent_offset);
1867 }
1868 
1869 // (&quot;name as oop&quot; accessor is not necessary)
1870 
1871 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1872   oop name = java_thread_group-&gt;obj_field(_name_offset);
1873   // ThreadGroup.name can be null
1874   if (name != NULL) {
1875     return java_lang_String::as_utf8_string(name);
1876   }
1877   return NULL;
1878 }
1879 
1880 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1881   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1882   return java_thread_group-&gt;int_field(_nthreads_offset);
1883 }
1884 
1885 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1886   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1887   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1888   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1889   return objArrayOop(threads);
1890 }
1891 
1892 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1893   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1894   return java_thread_group-&gt;int_field(_ngroups_offset);
1895 }
1896 
1897 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1898   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1899   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1900   return objArrayOop(groups);
1901 }
1902 
1903 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1904   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1905   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1906 }
1907 
1908 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1909   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1910   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1911 }
1912 
1913 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1914   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1915   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1916 }
1917 
1918 #define THREADGROUP_FIELDS_DO(macro) \
1919   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1920   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1921   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1922   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1923   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1924   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1925   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1926   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1927   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1928 
1929 void java_lang_ThreadGroup::compute_offsets() {
1930   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1931 
1932   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1933   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1934 }
1935 
1936 #if INCLUDE_CDS
1937 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1938   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1939 }
1940 #endif
1941 
1942 #define THROWABLE_FIELDS_DO(macro) \
1943   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
1944   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
1945   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
1946   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
1947   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
1948 
1949 void java_lang_Throwable::compute_offsets() {
1950   InstanceKlass* k = SystemDictionary::Throwable_klass();
1951   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1952 }
1953 
1954 #if INCLUDE_CDS
1955 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1956   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1957 }
1958 #endif
1959 
1960 oop java_lang_Throwable::unassigned_stacktrace() {
1961   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1962   oop base = ik-&gt;static_field_base_raw();
1963   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
1964 }
1965 
1966 oop java_lang_Throwable::backtrace(oop throwable) {
1967   return throwable-&gt;obj_field_acquire(backtrace_offset);
1968 }
1969 
1970 
1971 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
1972   throwable-&gt;release_obj_field_put(backtrace_offset, value);
1973 }
1974 
1975 int java_lang_Throwable::depth(oop throwable) {
1976   return throwable-&gt;int_field(depth_offset);
1977 }
1978 
1979 void java_lang_Throwable::set_depth(oop throwable, int value) {
1980   throwable-&gt;int_field_put(depth_offset, value);
1981 }
1982 
1983 oop java_lang_Throwable::message(oop throwable) {
1984   return throwable-&gt;obj_field(detailMessage_offset);
1985 }
1986 
1987 
1988 // Return Symbol for detailed_message or NULL
1989 Symbol* java_lang_Throwable::detail_message(oop throwable) {
1990   PRESERVE_EXCEPTION_MARK;  // Keep original exception
1991   oop detailed_message = java_lang_Throwable::message(throwable);
1992   if (detailed_message != NULL) {
1993     return java_lang_String::as_symbol(detailed_message);
1994   }
1995   return NULL;
1996 }
1997 
1998 void java_lang_Throwable::set_message(oop throwable, oop value) {
1999   throwable-&gt;obj_field_put(detailMessage_offset, value);
2000 }
2001 
2002 
2003 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2004   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
2005 }
2006 
2007 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2008   set_stacktrace(throwable, NULL);
2009 }
2010 
2011 
2012 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2013   ResourceMark rm;
2014   Klass* k = throwable-&gt;klass();
2015   assert(k != NULL, &quot;just checking&quot;);
2016   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2017   oop msg = message(throwable);
2018   if (msg != NULL) {
2019     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2020   }
2021 }
2022 
2023 // After this many redefines, the stack trace is unreliable.
2024 const int MAX_VERSION = USHRT_MAX;
2025 
2026 static inline bool version_matches(Method* method, int version) {
2027   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2028   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2029 }
2030 
2031 // This class provides a simple wrapper over the internal structure of
2032 // exception backtrace to insulate users of the backtrace from needing
2033 // to know what it looks like.
2034 // The code of this class is not GC safe. Allocations can only happen
2035 // in expand().
2036 class BacktraceBuilder: public StackObj {
2037  friend class BacktraceIterator;
2038  private:
2039   Handle          _backtrace;
2040   objArrayOop     _head;
2041   typeArrayOop    _methods;
2042   typeArrayOop    _bcis;
2043   objArrayOop     _mirrors;
2044   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2045   // True if the top frame of the backtrace is omitted because it shall be hidden.
2046   bool            _has_hidden_top_frame;
2047   int             _index;
2048   NoSafepointVerifier _nsv;
2049 
2050   enum {
2051     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2052     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2053     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2054     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2055     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2056     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2057     trace_size           = java_lang_Throwable::trace_size,
2058     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2059   };
2060 
2061   // get info out of chunks
2062   static typeArrayOop get_methods(objArrayHandle chunk) {
2063     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2064     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2065     return methods;
2066   }
2067   static typeArrayOop get_bcis(objArrayHandle chunk) {
2068     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2069     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2070     return bcis;
2071   }
2072   static objArrayOop get_mirrors(objArrayHandle chunk) {
2073     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2074     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2075     return mirrors;
2076   }
2077   static typeArrayOop get_names(objArrayHandle chunk) {
2078     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2079     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2080     return names;
2081   }
2082   static bool has_hidden_top_frame(objArrayHandle chunk) {
2083     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2084     return hidden != NULL;
2085   }
2086 
2087  public:
2088 
2089   // constructor for new backtrace
2090   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2091     expand(CHECK);
2092     _backtrace = Handle(THREAD, _head);
2093     _index = 0;
2094   }
2095 
2096   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2097     _methods = get_methods(backtrace);
2098     _bcis = get_bcis(backtrace);
2099     _mirrors = get_mirrors(backtrace);
2100     _names = get_names(backtrace);
2101     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2102     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2103            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2104            _mirrors-&gt;length() == _names-&gt;length(),
2105            &quot;method and source information arrays should match&quot;);
2106 
2107     // head is the preallocated backtrace
2108     _head = backtrace();
2109     _backtrace = Handle(thread, _head);
2110     _index = 0;
2111   }
2112 
2113   void expand(TRAPS) {
2114     objArrayHandle old_head(THREAD, _head);
2115     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2116 
2117     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2118     objArrayHandle new_head(THREAD, head);
2119 
2120     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2121     typeArrayHandle new_methods(THREAD, methods);
2122 
2123     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2124     typeArrayHandle new_bcis(THREAD, bcis);
2125 
2126     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2127     objArrayHandle new_mirrors(THREAD, mirrors);
2128 
2129     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2130     typeArrayHandle new_names(THREAD, names);
2131 
2132     if (!old_head.is_null()) {
2133       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2134     }
2135     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2136     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2137     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2138     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2139     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2140 
2141     _head    = new_head();
2142     _methods = new_methods();
2143     _bcis = new_bcis();
2144     _mirrors = new_mirrors();
2145     _names  = new_names();
2146     _index = 0;
2147   }
2148 
2149   oop backtrace() {
2150     return _backtrace();
2151   }
2152 
2153   inline void push(Method* method, int bci, TRAPS) {
2154     // Smear the -1 bci to 0 since the array only holds unsigned
2155     // shorts.  The later line number lookup would just smear the -1
2156     // to a 0 even if it could be recorded.
2157     if (bci == SynchronizationEntryBCI) bci = 0;
2158 
2159     if (_index &gt;= trace_chunk_size) {
2160       methodHandle mhandle(THREAD, method);
2161       expand(CHECK);
2162       method = mhandle();
2163     }
2164 
2165     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2166     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2167 
2168     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2169     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2170     Symbol* name = method-&gt;name();
2171     _names-&gt;symbol_at_put(_index, name);
2172 
2173     // We need to save the mirrors in the backtrace to keep the class
2174     // from being unloaded while we still have this stack trace.
2175     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2176     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2177     _index++;
2178   }
2179 
2180   void set_has_hidden_top_frame(TRAPS) {
2181     if (!_has_hidden_top_frame) {
2182       // It would be nice to add java/lang/Boolean::TRUE here
2183       // to indicate that this backtrace has a hidden top frame.
2184       // But this code is used before TRUE is allocated.
2185       // Therefore let&#39;s just use an arbitrary legal oop
2186       // available right here. _methods is a short[].
2187       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2188       _has_hidden_top_frame = true;
2189       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2190     }
2191   }
2192 };
2193 
2194 struct BacktraceElement : public StackObj {
2195   int _method_id;
2196   int _bci;
2197   int _version;
2198   Symbol* _name;
2199   Handle _mirror;
2200   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2201                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2202 };
2203 
2204 class BacktraceIterator : public StackObj {
2205   int _index;
2206   objArrayHandle  _result;
2207   objArrayHandle  _mirrors;
2208   typeArrayHandle _methods;
2209   typeArrayHandle _bcis;
2210   typeArrayHandle _names;
2211 
2212   void init(objArrayHandle result, Thread* thread) {
2213     // Get method id, bci, version and mirror from chunk
2214     _result = result;
2215     if (_result.not_null()) {
2216       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2217       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2218       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2219       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2220       _index = 0;
2221     }
2222   }
2223  public:
2224   BacktraceIterator(objArrayHandle result, Thread* thread) {
2225     init(result, thread);
2226     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2227   }
2228 
2229   BacktraceElement next(Thread* thread) {
2230     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2231                         _methods-&gt;ushort_at(_index),
2232                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2233                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2234                         _names-&gt;symbol_at(_index));
2235     _index++;
2236 
2237     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2238       int next_offset = java_lang_Throwable::trace_next_offset;
2239       // Get next chunk
2240       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2241       init(result, thread);
2242     }
2243     return e;
2244   }
2245 
2246   bool repeat() {
2247     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2248   }
2249 };
2250 
2251 
2252 // Print stack trace element to resource allocated buffer
2253 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2254                                           int version, int bci, Symbol* name) {
2255   ResourceMark rm;
2256 
2257   // Get strings and string lengths
2258   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2259   const char* klass_name  = holder-&gt;external_name();
2260   int buf_len = (int)strlen(klass_name);
2261 
2262   char* method_name = name-&gt;as_C_string();
2263   buf_len += (int)strlen(method_name);
2264 
2265   char* source_file_name = NULL;
2266   Symbol* source = Backtrace::get_source_file_name(holder, version);
2267   if (source != NULL) {
2268     source_file_name = source-&gt;as_C_string();
2269     buf_len += (int)strlen(source_file_name);
2270   }
2271 
2272   char *module_name = NULL, *module_version = NULL;
2273   ModuleEntry* module = holder-&gt;module();
2274   if (module-&gt;is_named()) {
2275     module_name = module-&gt;name()-&gt;as_C_string();
2276     buf_len += (int)strlen(module_name);
2277     if (module-&gt;version() != NULL) {
2278       module_version = module-&gt;version()-&gt;as_C_string();
2279       buf_len += (int)strlen(module_version);
2280     }
2281   }
2282 
2283   // Allocate temporary buffer with extra space for formatting and line number
2284   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2285 
2286   // Print stack trace line in buffer
2287   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2288 
2289   // Print module information
2290   if (module_name != NULL) {
2291     if (module_version != NULL) {
2292       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2293     } else {
2294       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2295     }
2296   }
2297 
2298   // The method can be NULL if the requested class version is gone
2299   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2300   if (!version_matches(method, version)) {
2301     strcat(buf, &quot;Redefined)&quot;);
2302   } else {
2303     int line_number = Backtrace::get_line_number(method, bci);
2304     if (line_number == -2) {
2305       strcat(buf, &quot;Native Method)&quot;);
2306     } else {
2307       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2308         // Sourcename and linenumber
2309         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2310       } else if (source_file_name != NULL) {
2311         // Just sourcename
2312         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2313       } else {
2314         // Neither sourcename nor linenumber
2315         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2316       }
2317       CompiledMethod* nm = method-&gt;code();
2318       if (WizardMode &amp;&amp; nm != NULL) {
2319         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2320       }
2321     }
2322   }
2323 
2324   st-&gt;print_cr(&quot;%s&quot;, buf);
2325 }
2326 
2327 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2328   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2329   int method_id = method-&gt;orig_method_idnum();
2330   int version = method-&gt;constants()-&gt;version();
2331   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2332 }
2333 
2334 /**
2335  * Print the throwable message and its stack trace plus all causes by walking the
2336  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2337  */
2338 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2339   // First, print the message.
2340   print(throwable(), st);
2341   st-&gt;cr();
2342 
2343   // Now print the stack trace.
2344   Thread* THREAD = Thread::current();
2345   while (throwable.not_null()) {
2346     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2347     if (result.is_null()) {
2348       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2349       return;
2350     }
2351     BacktraceIterator iter(result, THREAD);
2352 
2353     while (iter.repeat()) {
2354       BacktraceElement bte = iter.next(THREAD);
2355       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2356     }
2357     {
2358       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2359       EXCEPTION_MARK;
2360       JavaValue cause(T_OBJECT);
2361       JavaCalls::call_virtual(&amp;cause,
2362                               throwable,
2363                               throwable-&gt;klass(),
2364                               vmSymbols::getCause_name(),
2365                               vmSymbols::void_throwable_signature(),
2366                               THREAD);
2367       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2368       if (HAS_PENDING_EXCEPTION) {
2369         CLEAR_PENDING_EXCEPTION;
2370         throwable = Handle();
2371       } else {
2372         throwable = Handle(THREAD, (oop) cause.get_jobject());
2373         if (throwable.not_null()) {
2374           st-&gt;print(&quot;Caused by: &quot;);
2375           print(throwable(), st);
2376           st-&gt;cr();
2377         }
2378       }
2379     }
2380   }
2381 }
2382 
2383 /**
2384  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2385  */
2386 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2387   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2388   JavaValue result(T_VOID);
2389   JavaCalls::call_virtual(&amp;result,
2390                           throwable,
2391                           SystemDictionary::Throwable_klass(),
2392                           vmSymbols::printStackTrace_name(),
2393                           vmSymbols::void_method_signature(),
2394                           THREAD);
2395 }
2396 
2397 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2398   if (!StackTraceInThrowable) return;
2399   ResourceMark rm(THREAD);
2400 
2401   // Start out by clearing the backtrace for this object, in case the VM
2402   // runs out of memory while allocating the stack trace
2403   set_backtrace(throwable(), NULL);
2404   // Clear lazily constructed Java level stacktrace if refilling occurs
2405   // This is unnecessary in 1.7+ but harmless
2406   clear_stacktrace(throwable());
2407 
2408   int max_depth = MaxJavaStackTraceDepth;
2409   JavaThread* thread = (JavaThread*)THREAD;
2410 
2411   BacktraceBuilder bt(CHECK);
2412 
2413   // If there is no Java frame just return the method that was being called
2414   // with bci 0
2415   if (!thread-&gt;has_last_Java_frame()) {
2416     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2417       bt.push(method(), 0, CHECK);
2418       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2419       set_depth(throwable(), 1);
2420       set_backtrace(throwable(), bt.backtrace());
2421     }
2422     return;
2423   }
2424 
2425   // Instead of using vframe directly, this version of fill_in_stack_trace
2426   // basically handles everything by hand. This significantly improved the
2427   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2428   // See bug 6333838 for  more details.
2429   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2430   // trace as utilizing vframe.
2431 #ifdef ASSERT
2432   vframeStream st(thread);
2433 #endif
2434   int total_count = 0;
2435   RegisterMap map(thread, false);
2436   int decode_offset = 0;
2437   CompiledMethod* nm = NULL;
2438   bool skip_fillInStackTrace_check = false;
2439   bool skip_throwableInit_check = false;
2440   bool skip_hidden = !ShowHiddenFrames;
2441 
2442   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2443     Method* method = NULL;
2444     int bci = 0;
2445 
2446     // Compiled java method case.
2447     if (decode_offset != 0) {
2448       DebugInfoReadStream stream(nm, decode_offset);
2449       decode_offset = stream.read_int();
2450       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2451       bci = stream.read_bci();
2452     } else {
2453       if (fr.is_first_frame()) break;
2454       address pc = fr.pc();
2455       if (fr.is_interpreted_frame()) {
2456         address bcp = fr.interpreter_frame_bcp();
2457         method = fr.interpreter_frame_method();
2458         bci =  method-&gt;bci_from(bcp);
2459         fr = fr.sender(&amp;map);
2460       } else {
2461         CodeBlob* cb = fr.cb();
2462         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2463         // but non nmethod
2464         fr = fr.sender(&amp;map);
2465         if (cb == NULL || !cb-&gt;is_compiled()) {
2466           continue;
2467         }
2468         nm = cb-&gt;as_compiled_method();
2469         if (nm-&gt;method()-&gt;is_native()) {
2470           method = nm-&gt;method();
2471           bci = 0;
2472         } else {
2473           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2474           decode_offset = pd-&gt;scope_decode_offset();
2475           // if decode_offset is not equal to 0, it will execute the
2476           // &quot;compiled java method case&quot; at the beginning of the loop.
2477           continue;
2478         }
2479       }
2480     }
2481 #ifdef ASSERT
2482     assert(st.method() == method &amp;&amp; st.bci() == bci,
2483            &quot;Wrong stack trace&quot;);
2484     st.next();
2485 #endif
2486 
2487     // the format of the stacktrace will be:
2488     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2489     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2490     // - rest of the stack
2491 
2492     if (!skip_fillInStackTrace_check) {
2493       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2494           throwable-&gt;is_a(method-&gt;method_holder())) {
2495         continue;
2496       }
2497       else {
2498         skip_fillInStackTrace_check = true; // gone past them all
2499       }
2500     }
2501     if (!skip_throwableInit_check) {
2502       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2503 
2504       // skip &lt;init&gt; methods of the exception class and superclasses
<a name="12" id="anc12"></a><span class="line-modified">2505       // This is simlar to classic VM.</span>
<span class="line-modified">2506       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2507           throwable-&gt;is_a(method-&gt;method_holder())) {
2508         continue;
2509       } else {
2510         // there are none or we&#39;ve seen them all - either way stop checking
2511         skip_throwableInit_check = true;
2512       }
2513     }
2514     if (method-&gt;is_hidden()) {
2515       if (skip_hidden) {
2516         if (total_count == 0) {
2517           // The top frame will be hidden from the stack trace.
2518           bt.set_has_hidden_top_frame(CHECK);
2519         }
2520         continue;
2521       }
2522     }
2523     bt.push(method, bci, CHECK);
2524     total_count++;
2525   }
2526 
2527   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2528 
2529   // Put completed stack trace into throwable object
2530   set_backtrace(throwable(), bt.backtrace());
2531   set_depth(throwable(), total_count);
2532 }
2533 
2534 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2535   // No-op if stack trace is disabled
2536   if (!StackTraceInThrowable) {
2537     return;
2538   }
2539 
2540   // Disable stack traces for some preallocated out of memory errors
2541   if (!Universe::should_fill_in_stack_trace(throwable)) {
2542     return;
2543   }
2544 
2545   PRESERVE_EXCEPTION_MARK;
2546 
2547   JavaThread* thread = JavaThread::active();
2548   fill_in_stack_trace(throwable, method, thread);
2549   // ignore exceptions thrown during stack trace filling
2550   CLEAR_PENDING_EXCEPTION;
2551 }
2552 
2553 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2554   // Allocate stack trace - backtrace is created but not filled in
2555 
2556   // No-op if stack trace is disabled
2557   if (!StackTraceInThrowable) return;
2558   BacktraceBuilder bt(CHECK);   // creates a backtrace
2559   set_backtrace(throwable(), bt.backtrace());
2560 }
2561 
2562 
2563 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2564   // Fill in stack trace into preallocated backtrace (no GC)
2565 
2566   // No-op if stack trace is disabled
2567   if (!StackTraceInThrowable) return;
2568 
2569   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2570 
2571   JavaThread* THREAD = JavaThread::current();
2572 
2573   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2574   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2575 
2576   ResourceMark rm(THREAD);
2577   vframeStream st(THREAD);
2578 
2579   BacktraceBuilder bt(THREAD, backtrace);
2580 
2581   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2582   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2583 
2584   // fill in as much stack trace as possible
2585   int chunk_count = 0;
2586   for (;!st.at_end(); st.next()) {
2587     bt.push(st.method(), st.bci(), CHECK);
2588     chunk_count++;
2589 
2590     // Bail-out for deep stacks
2591     if (chunk_count &gt;= trace_chunk_size) break;
2592   }
2593   set_depth(throwable(), chunk_count);
2594   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2595 
2596   // We support the Throwable immutability protocol defined for Java 7.
2597   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2598   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2599 }
2600 
2601 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2602                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2603 
2604   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2605     THROW(vmSymbols::java_lang_NullPointerException());
2606   }
2607 
2608   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2609 
2610   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2611     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2612   }
2613 
2614   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2615   BacktraceIterator iter(result, THREAD);
2616 
2617   int index = 0;
2618   while (iter.repeat()) {
2619     BacktraceElement bte = iter.next(THREAD);
2620 
2621     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2622 
2623     if (stack_trace_element.is_null()) {
2624       THROW(vmSymbols::java_lang_NullPointerException());
2625     }
2626 
2627     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2628     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2629 
2630     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2631                                          method,
2632                                          bte._version,
2633                                          bte._bci,
2634                                          bte._name, CHECK);
2635   }
2636 }
2637 
2638 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2639   Thread* THREAD = Thread::current();
2640   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2641   BacktraceIterator iter(result, THREAD);
2642   // No backtrace available.
2643   if (!iter.repeat()) return false;
2644 
2645   // If the exception happened in a frame that has been hidden, i.e.,
2646   // omitted from the back trace, we can not compute the message.
2647   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2648   if (hidden != NULL) {
2649     return false;
2650   }
2651 
2652   // Get first backtrace element.
2653   BacktraceElement bte = iter.next(THREAD);
2654 
2655   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2656   assert(holder != NULL, &quot;first element should be non-null&quot;);
2657   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2658 
2659   // Original version is no longer available.
2660   if (m == NULL || !version_matches(m, bte._version)) {
2661     return false;
2662   }
2663 
2664   *method = m;
2665   *bci = bte._bci;
2666   return true;
2667 }
2668 
2669 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2670   // Allocate java.lang.StackTraceElement instance
2671   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2672   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2673   if (k-&gt;should_be_initialized()) {
2674     k-&gt;initialize(CHECK_NULL);
2675   }
2676 
2677   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2678 
2679   int version = method-&gt;constants()-&gt;version();
2680   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2681   return element();
2682 }
2683 
2684 void java_lang_StackTraceElement::fill_in(Handle element,
2685                                           InstanceKlass* holder, const methodHandle&amp; method,
2686                                           int version, int bci, Symbol* name, TRAPS) {
2687   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2688 
2689   ResourceMark rm(THREAD);
2690   HandleMark hm(THREAD);
2691 
2692   // Fill in class name
2693   Handle java_class(THREAD, holder-&gt;java_mirror());
2694   oop classname = java_lang_Class::name(java_class, CHECK);
2695   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2696   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2697 
2698   oop loader = holder-&gt;class_loader();
2699   if (loader != NULL) {
2700     oop loader_name = java_lang_ClassLoader::name(loader);
2701     if (loader_name != NULL)
2702       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2703   }
2704 
2705   // Fill in method name
2706   oop methodname = StringTable::intern(name, CHECK);
2707   java_lang_StackTraceElement::set_methodName(element(), methodname);
2708 
2709   // Fill in module name and version
2710   ModuleEntry* module = holder-&gt;module();
2711   if (module-&gt;is_named()) {
2712     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2713     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2714     oop module_version;
2715     if (module-&gt;version() != NULL) {
2716       module_version = StringTable::intern(module-&gt;version(), CHECK);
2717     } else {
2718       module_version = NULL;
2719     }
2720     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2721   }
2722 
2723   if (method() == NULL || !version_matches(method(), version)) {
2724     // The method was redefined, accurate line number information isn&#39;t available
2725     java_lang_StackTraceElement::set_fileName(element(), NULL);
2726     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2727   } else {
2728     Symbol* source;
2729     oop source_file;
2730     int line_number;
2731     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2732 
2733     java_lang_StackTraceElement::set_fileName(element(), source_file);
2734     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2735   }
2736 }
2737 
2738 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2739                                                        InstanceKlass* holder,
2740                                                        int version,
2741                                                        const methodHandle&amp; method,
2742                                                        int bci,
2743                                                        Symbol*&amp; source,
2744                                                        oop&amp; source_file,
2745                                                        int&amp; line_number, TRAPS) {
2746   // Fill in source file name and line number.
2747   source = Backtrace::get_source_file_name(holder, version);
2748   source_file = java_lang_Class::source_file(java_class());
2749   if (source != NULL) {
2750     // Class was not redefined. We can trust its cache if set,
2751     // else we have to initialize it.
2752     if (source_file == NULL) {
2753       source_file = StringTable::intern(source, CHECK);
2754       java_lang_Class::set_source_file(java_class(), source_file);
2755     }
2756   } else {
2757     // Class was redefined. Dump the cache if it was set.
2758     if (source_file != NULL) {
2759       source_file = NULL;
2760       java_lang_Class::set_source_file(java_class(), source_file);
2761     }
2762   }
2763   line_number = Backtrace::get_line_number(method(), bci);
2764 }
2765 
2766 #if INCLUDE_JVMCI
2767 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2768                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2769   ResourceMark rm(THREAD);
2770   HandleMark hm(THREAD);
2771 
2772   filename = NULL;
2773   line_number = -1;
2774 
2775   oop source_file;
2776   int version = method-&gt;constants()-&gt;version();
2777   InstanceKlass* holder = method-&gt;method_holder();
2778   Handle java_class(THREAD, holder-&gt;java_mirror());
2779   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2780 }
2781 #endif // INCLUDE_JVMCI
2782 
2783 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2784   HandleMark hm(THREAD);
2785   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2786   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2787   // we should expand MemberName::name when Throwable uses StackTrace
2788   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2789   return method;
2790 }
2791 
2792 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2793   // set Method* or mid/cpref
2794   HandleMark hm(THREAD);
2795   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2796   InstanceKlass* ik = method-&gt;method_holder();
2797   CallInfo info(method(), ik, CHECK);
2798   MethodHandles::init_method_MemberName(mname, info);
2799   // set bci
2800   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2801   // method may be redefined; store the version
2802   int version = method-&gt;constants()-&gt;version();
2803   assert((jushort)version == version, &quot;version should be short&quot;);
2804   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2805 }
2806 
2807 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2808   ResourceMark rm(THREAD);
2809   HandleMark hm(THREAD);
2810   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2811   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2812   InstanceKlass* holder = InstanceKlass::cast(clazz);
2813   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2814 
2815   short version = stackFrame-&gt;short_field(_version_offset);
2816   int bci = stackFrame-&gt;int_field(_bci_offset);
2817   Symbol* name = method-&gt;name();
2818   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2819                                        version, bci, name, CHECK);
2820 }
2821 
2822 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2823   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2824   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2825 
2826 void java_lang_StackFrameInfo::compute_offsets() {
2827   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2828   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2829   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2830 }
2831 
2832 #if INCLUDE_CDS
2833 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2834   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2835   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2836 }
2837 #endif
2838 
2839 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2840   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2841   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2842   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2843   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2844 
2845 void java_lang_LiveStackFrameInfo::compute_offsets() {
2846   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2847   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2848 }
2849 
2850 #if INCLUDE_CDS
2851 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2852   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2853 }
2854 #endif
2855 
2856 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2857   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
2858 
2859 void java_lang_reflect_AccessibleObject::compute_offsets() {
2860   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2861   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2862 }
2863 
2864 #if INCLUDE_CDS
2865 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2866   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2867 }
2868 #endif
2869 
2870 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2871   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2872   return (jboolean) reflect-&gt;bool_field(override_offset);
2873 }
2874 
2875 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2876   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2877   reflect-&gt;bool_field_put(override_offset, (int) value);
2878 }
2879 
2880 #define METHOD_FIELDS_DO(macro) \
2881   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2882   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2883   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2884   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2885   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2886   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2887   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2888   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2889   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2890   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2891   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2892 
2893 void java_lang_reflect_Method::compute_offsets() {
2894   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2895   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2896 }
2897 
2898 #if INCLUDE_CDS
2899 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2900   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2901 }
2902 #endif
2903 
2904 Handle java_lang_reflect_Method::create(TRAPS) {
2905   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2906   Klass* klass = SystemDictionary::reflect_Method_klass();
2907   // This class is eagerly initialized during VM initialization, since we keep a refence
2908   // to one of the methods
2909   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2910   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2911 }
2912 
2913 oop java_lang_reflect_Method::clazz(oop reflect) {
2914   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2915   return reflect-&gt;obj_field(clazz_offset);
2916 }
2917 
2918 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2919   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2920    reflect-&gt;obj_field_put(clazz_offset, value);
2921 }
2922 
2923 int java_lang_reflect_Method::slot(oop reflect) {
2924   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2925   return reflect-&gt;int_field(slot_offset);
2926 }
2927 
2928 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
2929   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2930   reflect-&gt;int_field_put(slot_offset, value);
2931 }
2932 
2933 void java_lang_reflect_Method::set_name(oop method, oop value) {
2934   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2935   method-&gt;obj_field_put(name_offset, value);
2936 }
2937 
2938 oop java_lang_reflect_Method::return_type(oop method) {
2939   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2940   return method-&gt;obj_field(returnType_offset);
2941 }
2942 
2943 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
2944   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2945   method-&gt;obj_field_put(returnType_offset, value);
2946 }
2947 
2948 oop java_lang_reflect_Method::parameter_types(oop method) {
2949   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2950   return method-&gt;obj_field(parameterTypes_offset);
2951 }
2952 
2953 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
2954   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2955   method-&gt;obj_field_put(parameterTypes_offset, value);
2956 }
2957 
2958 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
2959   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2960   method-&gt;obj_field_put(exceptionTypes_offset, value);
2961 }
2962 
2963 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
2964   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2965   method-&gt;int_field_put(modifiers_offset, value);
2966 }
2967 
2968 void java_lang_reflect_Method::set_signature(oop method, oop value) {
2969   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2970   method-&gt;obj_field_put(signature_offset, value);
2971 }
2972 
2973 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
2974   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2975   method-&gt;obj_field_put(annotations_offset, value);
2976 }
2977 
2978 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
2979   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2980   method-&gt;obj_field_put(parameter_annotations_offset, value);
2981 }
2982 
2983 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
2984   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2985   method-&gt;obj_field_put(annotation_default_offset, value);
2986 }
2987 
2988 #define CONSTRUCTOR_FIELDS_DO(macro) \
2989   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2990   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2991   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2992   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2993   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2994   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2995   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2996   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
2997 
2998 void java_lang_reflect_Constructor::compute_offsets() {
2999   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3000   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3001 }
3002 
3003 #if INCLUDE_CDS
3004 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3005   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3006 }
3007 #endif
3008 
3009 Handle java_lang_reflect_Constructor::create(TRAPS) {
3010   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3011   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3012   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3013   InstanceKlass* ik = InstanceKlass::cast(k);
3014   // Ensure it is initialized
3015   ik-&gt;initialize(CHECK_NH);
3016   return ik-&gt;allocate_instance_handle(THREAD);
3017 }
3018 
3019 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3020   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3021   return reflect-&gt;obj_field(clazz_offset);
3022 }
3023 
3024 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3025   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3026    reflect-&gt;obj_field_put(clazz_offset, value);
3027 }
3028 
3029 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3030   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3031   return constructor-&gt;obj_field(parameterTypes_offset);
3032 }
3033 
3034 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3035   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3036   constructor-&gt;obj_field_put(parameterTypes_offset, value);
3037 }
3038 
3039 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3040   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3041   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
3042 }
3043 
3044 int java_lang_reflect_Constructor::slot(oop reflect) {
3045   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3046   return reflect-&gt;int_field(slot_offset);
3047 }
3048 
3049 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3050   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3051   reflect-&gt;int_field_put(slot_offset, value);
3052 }
3053 
3054 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3055   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3056   constructor-&gt;int_field_put(modifiers_offset, value);
3057 }
3058 
3059 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3060   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3061   constructor-&gt;obj_field_put(signature_offset, value);
3062 }
3063 
3064 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3065   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3066   constructor-&gt;obj_field_put(annotations_offset, value);
3067 }
3068 
3069 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3070   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3071   method-&gt;obj_field_put(parameter_annotations_offset, value);
3072 }
3073 
3074 #define FIELD_FIELDS_DO(macro) \
3075   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3076   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3077   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3078   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3079   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3080   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3081   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3082 
3083 void java_lang_reflect_Field::compute_offsets() {
3084   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3085   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3086 }
3087 
3088 #if INCLUDE_CDS
3089 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3090   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3091 }
3092 #endif
3093 
3094 Handle java_lang_reflect_Field::create(TRAPS) {
3095   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3096   Symbol* name = vmSymbols::java_lang_reflect_Field();
3097   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3098   InstanceKlass* ik = InstanceKlass::cast(k);
3099   // Ensure it is initialized
3100   ik-&gt;initialize(CHECK_NH);
3101   return ik-&gt;allocate_instance_handle(THREAD);
3102 }
3103 
3104 oop java_lang_reflect_Field::clazz(oop reflect) {
3105   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3106   return reflect-&gt;obj_field(clazz_offset);
3107 }
3108 
3109 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3110   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3111    reflect-&gt;obj_field_put(clazz_offset, value);
3112 }
3113 
3114 oop java_lang_reflect_Field::name(oop field) {
3115   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3116   return field-&gt;obj_field(name_offset);
3117 }
3118 
3119 void java_lang_reflect_Field::set_name(oop field, oop value) {
3120   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3121   field-&gt;obj_field_put(name_offset, value);
3122 }
3123 
3124 oop java_lang_reflect_Field::type(oop field) {
3125   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3126   return field-&gt;obj_field(type_offset);
3127 }
3128 
3129 void java_lang_reflect_Field::set_type(oop field, oop value) {
3130   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3131   field-&gt;obj_field_put(type_offset, value);
3132 }
3133 
3134 int java_lang_reflect_Field::slot(oop reflect) {
3135   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3136   return reflect-&gt;int_field(slot_offset);
3137 }
3138 
3139 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3140   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3141   reflect-&gt;int_field_put(slot_offset, value);
3142 }
3143 
3144 int java_lang_reflect_Field::modifiers(oop field) {
3145   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3146   return field-&gt;int_field(modifiers_offset);
3147 }
3148 
3149 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3150   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3151   field-&gt;int_field_put(modifiers_offset, value);
3152 }
3153 
3154 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3155   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3156   field-&gt;obj_field_put(signature_offset, value);
3157 }
3158 
3159 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3160   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3161   field-&gt;obj_field_put(annotations_offset, value);
3162 }
3163 
3164 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3165   // Allocate java.lang.reflect.RecordComponent instance
3166   HandleMark hm(THREAD);
3167   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3168   assert(ik != NULL, &quot;must be loaded&quot;);
3169   ik-&gt;initialize(CHECK_NULL);
3170 
3171   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3172 
3173   Handle decl_class(THREAD, holder-&gt;java_mirror());
3174   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3175 
3176   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3177   oop component_name = StringTable::intern(name, CHECK_NULL);
3178   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3179 
3180   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3181   Handle component_type_h =
3182     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3183   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3184 
3185   Method* accessor_method = NULL;
3186   {
3187     // Prepend &quot;()&quot; to type to create the full method signature.
3188     ResourceMark rm(THREAD);
3189     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3190     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3191     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3192     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3193     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3194   }
3195 
3196   if (accessor_method != NULL) {
3197     methodHandle method(THREAD, accessor_method);
3198     oop m = Reflection::new_method(method, false, CHECK_NULL);
3199     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3200   } else {
3201     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3202   }
3203 
3204   int sig_index = component-&gt;generic_signature_index();
3205   if (sig_index &gt; 0) {
3206     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3207     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3208     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3209   } else {
3210     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3211   }
3212 
3213   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3214   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3215 
3216   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3217   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3218 
3219   return element();
3220 }
3221 
3222 #define CONSTANTPOOL_FIELDS_DO(macro) \
3223   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3224 
3225 void reflect_ConstantPool::compute_offsets() {
3226   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3227   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3228   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3229 }
3230 
3231 #if INCLUDE_CDS
3232 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3233   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3234 }
3235 #endif
3236 
3237 #define PARAMETER_FIELDS_DO(macro) \
3238   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3239   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3240   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3241   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3242 
3243 void java_lang_reflect_Parameter::compute_offsets() {
3244   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3245   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3246 }
3247 
3248 #if INCLUDE_CDS
3249 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3250   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3251 }
3252 #endif
3253 
3254 Handle java_lang_reflect_Parameter::create(TRAPS) {
3255   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3256   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3257   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3258   InstanceKlass* ik = InstanceKlass::cast(k);
3259   // Ensure it is initialized
3260   ik-&gt;initialize(CHECK_NH);
3261   return ik-&gt;allocate_instance_handle(THREAD);
3262 }
3263 
3264 oop java_lang_reflect_Parameter::name(oop param) {
3265   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3266   return param-&gt;obj_field(name_offset);
3267 }
3268 
3269 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3270   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3271   param-&gt;obj_field_put(name_offset, value);
3272 }
3273 
3274 int java_lang_reflect_Parameter::modifiers(oop param) {
3275   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3276   return param-&gt;int_field(modifiers_offset);
3277 }
3278 
3279 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3280   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3281   param-&gt;int_field_put(modifiers_offset, value);
3282 }
3283 
3284 int java_lang_reflect_Parameter::index(oop param) {
3285   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3286   return param-&gt;int_field(index_offset);
3287 }
3288 
3289 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3290   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3291   param-&gt;int_field_put(index_offset, value);
3292 }
3293 
3294 oop java_lang_reflect_Parameter::executable(oop param) {
3295   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3296   return param-&gt;obj_field(executable_offset);
3297 }
3298 
3299 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3300   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3301   param-&gt;obj_field_put(executable_offset, value);
3302 }
3303 
3304 
3305 int java_lang_Module::loader_offset;
3306 int java_lang_Module::name_offset;
3307 int java_lang_Module::_module_entry_offset = -1;
3308 
3309 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3310   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3311   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3312                           vmSymbols::java_lang_module_init_signature(),
3313                           loader, module_name, CHECK_NH);
3314 }
3315 
3316 #define MODULE_FIELDS_DO(macro) \
3317   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3318   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3319 
3320 void java_lang_Module::compute_offsets() {
3321   InstanceKlass* k = SystemDictionary::Module_klass();
3322   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3323   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3324 }
3325 
3326 #if INCLUDE_CDS
3327 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3328   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3329   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3330 }
3331 #endif
3332 
3333 oop java_lang_Module::loader(oop module) {
3334   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3335   return module-&gt;obj_field(loader_offset);
3336 }
3337 
3338 void java_lang_Module::set_loader(oop module, oop value) {
3339   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3340   module-&gt;obj_field_put(loader_offset, value);
3341 }
3342 
3343 oop java_lang_Module::name(oop module) {
3344   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3345   return module-&gt;obj_field(name_offset);
3346 }
3347 
3348 void java_lang_Module::set_name(oop module, oop value) {
3349   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3350   module-&gt;obj_field_put(name_offset, value);
3351 }
3352 
3353 ModuleEntry* java_lang_Module::module_entry(oop module) {
3354   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3355   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3356   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3357 
3358   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3359   if (module_entry == NULL) {
3360     // If the inject field containing the ModuleEntry* is null then return the
3361     // class loader&#39;s unnamed module.
3362     oop loader = java_lang_Module::loader(module);
3363     Handle h_loader = Handle(Thread::current(), loader);
3364     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3365     return loader_cld-&gt;unnamed_module();
3366   }
3367   return module_entry;
3368 }
3369 
3370 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3371   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3372   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3373   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3374   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3375 }
3376 
3377 Handle reflect_ConstantPool::create(TRAPS) {
3378   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3379   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3380   // Ensure it is initialized
3381   k-&gt;initialize(CHECK_NH);
3382   return k-&gt;allocate_instance_handle(THREAD);
3383 }
3384 
3385 
3386 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3387   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3388   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3389   // Save the mirror to get back the constant pool.
3390   reflect-&gt;obj_field_put(_oop_offset, mirror);
3391 }
3392 
3393 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3394   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3395 
3396   oop mirror = reflect-&gt;obj_field(_oop_offset);
3397   Klass* k = java_lang_Class::as_Klass(mirror);
3398   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3399 
3400   // Get the constant pool back from the klass.  Since class redefinition
3401   // merges the new constant pool into the old, this is essentially the
3402   // same constant pool as the original.  If constant pool merging is
3403   // no longer done in the future, this will have to change to save
3404   // the original.
3405   return InstanceKlass::cast(k)-&gt;constants();
3406 }
3407 
3408 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3409   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3410 
3411 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3412   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3413   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3414 }
3415 
3416 #if INCLUDE_CDS
3417 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3418   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3419 }
3420 #endif
3421 
3422 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3423   Klass* k = SystemDictionary::box_klass(type);
3424   if (k == NULL)  return NULL;
3425   InstanceKlass* ik = InstanceKlass::cast(k);
3426   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3427   return ik-&gt;allocate_instance(THREAD);
3428 }
3429 
3430 
3431 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3432   oop box = initialize_and_allocate(type, CHECK_NULL);
3433   if (box == NULL)  return NULL;
3434   switch (type) {
3435     case T_BOOLEAN:
3436       box-&gt;bool_field_put(value_offset, value-&gt;z);
3437       break;
3438     case T_CHAR:
3439       box-&gt;char_field_put(value_offset, value-&gt;c);
3440       break;
3441     case T_FLOAT:
3442       box-&gt;float_field_put(value_offset, value-&gt;f);
3443       break;
3444     case T_DOUBLE:
3445       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3446       break;
3447     case T_BYTE:
3448       box-&gt;byte_field_put(value_offset, value-&gt;b);
3449       break;
3450     case T_SHORT:
3451       box-&gt;short_field_put(value_offset, value-&gt;s);
3452       break;
3453     case T_INT:
3454       box-&gt;int_field_put(value_offset, value-&gt;i);
3455       break;
3456     case T_LONG:
3457       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3458       break;
3459     default:
3460       return NULL;
3461   }
3462   return box;
3463 }
3464 
3465 
3466 BasicType java_lang_boxing_object::basic_type(oop box) {
3467   if (box == NULL)  return T_ILLEGAL;
3468   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3469   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3470     return T_ILLEGAL;
3471   return type;
3472 }
3473 
3474 
3475 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3476   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3477   switch (type) {
3478   case T_BOOLEAN:
3479     value-&gt;z = box-&gt;bool_field(value_offset);
3480     break;
3481   case T_CHAR:
3482     value-&gt;c = box-&gt;char_field(value_offset);
3483     break;
3484   case T_FLOAT:
3485     value-&gt;f = box-&gt;float_field(value_offset);
3486     break;
3487   case T_DOUBLE:
3488     value-&gt;d = box-&gt;double_field(long_value_offset);
3489     break;
3490   case T_BYTE:
3491     value-&gt;b = box-&gt;byte_field(value_offset);
3492     break;
3493   case T_SHORT:
3494     value-&gt;s = box-&gt;short_field(value_offset);
3495     break;
3496   case T_INT:
3497     value-&gt;i = box-&gt;int_field(value_offset);
3498     break;
3499   case T_LONG:
3500     value-&gt;j = box-&gt;long_field(long_value_offset);
3501     break;
3502   default:
3503     return T_ILLEGAL;
3504   } // end switch
3505   return type;
3506 }
3507 
3508 
3509 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3510   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3511   switch (type) {
3512   case T_BOOLEAN:
3513     box-&gt;bool_field_put(value_offset, value-&gt;z);
3514     break;
3515   case T_CHAR:
3516     box-&gt;char_field_put(value_offset, value-&gt;c);
3517     break;
3518   case T_FLOAT:
3519     box-&gt;float_field_put(value_offset, value-&gt;f);
3520     break;
3521   case T_DOUBLE:
3522     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3523     break;
3524   case T_BYTE:
3525     box-&gt;byte_field_put(value_offset, value-&gt;b);
3526     break;
3527   case T_SHORT:
3528     box-&gt;short_field_put(value_offset, value-&gt;s);
3529     break;
3530   case T_INT:
3531     box-&gt;int_field_put(value_offset, value-&gt;i);
3532     break;
3533   case T_LONG:
3534     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3535     break;
3536   default:
3537     return T_ILLEGAL;
3538   } // end switch
3539   return type;
3540 }
3541 
3542 
3543 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3544   switch (type) {
3545   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3546   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3547   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3548   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3549   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3550   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3551   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3552   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3553   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3554   }
3555 }
3556 
3557 // Support for java_lang_ref_Reference
3558 
3559 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3560   assert(obj != NULL, &quot;sanity&quot;);
3561   if (offset != java_lang_ref_Reference::referent_offset) {
3562     return false;
3563   }
3564 
3565   Klass* k = obj-&gt;klass();
3566   if (!k-&gt;is_instance_klass()) {
3567     return false;
3568   }
3569 
3570   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3571   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3572   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3573   return is_reference;
3574 }
3575 
3576 #define REFERENCE_FIELDS_DO(macro) \
3577   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \
3578   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \
3579   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \
3580   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);
3581 
3582 void java_lang_ref_Reference::compute_offsets() {
3583   if (_offsets_initialized) {
3584     return;
3585   }
3586   _offsets_initialized = true;
3587   InstanceKlass* k = SystemDictionary::Reference_klass();
3588   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3589 }
3590 
3591 #if INCLUDE_CDS
3592 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
3593   f-&gt;do_bool(&amp;_offsets_initialized);
3594   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3595 }
3596 #endif
3597 
3598 #define BOXING_FIELDS_DO(macro) \
3599   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \
3600   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);
3601 
3602 void java_lang_boxing_object::compute_offsets() {
3603   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
3604   InstanceKlass* longKlass = SystemDictionary::Long_klass();
3605   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3606 }
3607 
3608 #if INCLUDE_CDS
3609 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
3610   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3611 }
3612 #endif
3613 
3614 // Support for java_lang_ref_SoftReference
3615 //
3616 
3617 #define SOFTREFERENCE_FIELDS_DO(macro) \
3618   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3619   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3620 
3621 void java_lang_ref_SoftReference::compute_offsets() {
3622   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3623   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3624 }
3625 
3626 #if INCLUDE_CDS
3627 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3628   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3629 }
3630 #endif
3631 
3632 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3633   return ref-&gt;long_field(timestamp_offset);
3634 }
3635 
3636 jlong java_lang_ref_SoftReference::clock() {
3637   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3638   oop base = ik-&gt;static_field_base_raw();
3639   return base-&gt;long_field(static_clock_offset);
3640 }
3641 
3642 void java_lang_ref_SoftReference::set_clock(jlong value) {
3643   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3644   oop base = ik-&gt;static_field_base_raw();
3645   base-&gt;long_field_put(static_clock_offset, value);
3646 }
3647 
3648 // Support for java_lang_invoke_DirectMethodHandle
3649 
3650 int java_lang_invoke_DirectMethodHandle::_member_offset;
3651 
3652 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3653   oop member_name = NULL;
3654   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3655          &quot;a DirectMethodHandle oop is expected&quot;);
3656   return dmh-&gt;obj_field(member_offset_in_bytes());
3657 }
3658 
3659 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3660   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3661 
3662 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3663   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3664   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3665 }
3666 
3667 #if INCLUDE_CDS
3668 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3669   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3670 }
3671 #endif
3672 
3673 // Support for java_lang_invoke_MethodHandle
3674 
3675 int java_lang_invoke_MethodHandle::_type_offset;
3676 int java_lang_invoke_MethodHandle::_form_offset;
3677 
3678 int java_lang_invoke_MemberName::_clazz_offset;
3679 int java_lang_invoke_MemberName::_name_offset;
3680 int java_lang_invoke_MemberName::_type_offset;
3681 int java_lang_invoke_MemberName::_flags_offset;
3682 int java_lang_invoke_MemberName::_method_offset;
3683 int java_lang_invoke_MemberName::_vmindex_offset;
3684 
3685 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3686 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3687 
3688 int java_lang_invoke_LambdaForm::_vmentry_offset;
3689 
3690 #define METHODHANDLE_FIELDS_DO(macro) \
3691   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3692   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3693 
3694 void java_lang_invoke_MethodHandle::compute_offsets() {
3695   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3696   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3697 }
3698 
3699 #if INCLUDE_CDS
3700 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3701   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3702 }
3703 #endif
3704 
3705 #define MEMBERNAME_FIELDS_DO(macro) \
3706   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3707   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3708   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3709   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3710   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3711 
3712 void java_lang_invoke_MemberName::compute_offsets() {
3713   InstanceKlass* k = SystemDictionary::MemberName_klass();
3714   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3715   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3716 }
3717 
3718 #if INCLUDE_CDS
3719 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3720   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3721   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3722 }
3723 #endif
3724 
3725 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3726   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3727   assert(k != NULL, &quot;jdk mismatch&quot;);
3728   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3729 }
3730 
3731 #if INCLUDE_CDS
3732 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3733   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3734 }
3735 #endif
3736 
3737 #define LAMBDAFORM_FIELDS_DO(macro) \
3738   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3739 
3740 void java_lang_invoke_LambdaForm::compute_offsets() {
3741   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3742   assert (k != NULL, &quot;jdk mismatch&quot;);
3743   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3744 }
3745 
3746 #if INCLUDE_CDS
3747 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3748   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3749 }
3750 #endif
3751 
3752 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3753   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3754 }
3755 
3756 
3757 oop java_lang_invoke_MethodHandle::type(oop mh) {
3758   return mh-&gt;obj_field(_type_offset);
3759 }
3760 
3761 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3762   mh-&gt;obj_field_put(_type_offset, mtype);
3763 }
3764 
3765 oop java_lang_invoke_MethodHandle::form(oop mh) {
3766   assert(_form_offset != 0, &quot;&quot;);
3767   return mh-&gt;obj_field(_form_offset);
3768 }
3769 
3770 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3771   assert(_form_offset != 0, &quot;&quot;);
3772   mh-&gt;obj_field_put(_form_offset, lform);
3773 }
3774 
3775 /// MemberName accessors
3776 
3777 oop java_lang_invoke_MemberName::clazz(oop mname) {
3778   assert(is_instance(mname), &quot;wrong type&quot;);
3779   return mname-&gt;obj_field(_clazz_offset);
3780 }
3781 
3782 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3783   assert(is_instance(mname), &quot;wrong type&quot;);
3784   mname-&gt;obj_field_put(_clazz_offset, clazz);
3785 }
3786 
3787 oop java_lang_invoke_MemberName::name(oop mname) {
3788   assert(is_instance(mname), &quot;wrong type&quot;);
3789   return mname-&gt;obj_field(_name_offset);
3790 }
3791 
3792 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3793   assert(is_instance(mname), &quot;wrong type&quot;);
3794   mname-&gt;obj_field_put(_name_offset, name);
3795 }
3796 
3797 oop java_lang_invoke_MemberName::type(oop mname) {
3798   assert(is_instance(mname), &quot;wrong type&quot;);
3799   return mname-&gt;obj_field(_type_offset);
3800 }
3801 
3802 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3803   assert(is_instance(mname), &quot;wrong type&quot;);
3804   mname-&gt;obj_field_put(_type_offset, type);
3805 }
3806 
3807 int java_lang_invoke_MemberName::flags(oop mname) {
3808   assert(is_instance(mname), &quot;wrong type&quot;);
3809   return mname-&gt;int_field(_flags_offset);
3810 }
3811 
3812 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3813   assert(is_instance(mname), &quot;wrong type&quot;);
3814   mname-&gt;int_field_put(_flags_offset, flags);
3815 }
3816 
3817 
3818 // Return vmtarget from ResolvedMethodName method field through indirection
3819 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3820   assert(is_instance(mname), &quot;wrong type&quot;);
3821   oop method = mname-&gt;obj_field(_method_offset);
3822   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3823 }
3824 
3825 bool java_lang_invoke_MemberName::is_method(oop mname) {
3826   assert(is_instance(mname), &quot;must be MemberName&quot;);
<a name="13" id="anc13"></a><span class="line-modified">3827   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3828 }
3829 
3830 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3831   assert(is_instance(mname), &quot;wrong type&quot;);
3832   mname-&gt;obj_field_put(_method_offset, resolved_method);
3833 }
3834 
3835 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3836   assert(is_instance(mname), &quot;wrong type&quot;);
3837   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3838 }
3839 
3840 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3841   assert(is_instance(mname), &quot;wrong type&quot;);
3842   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3843 }
3844 
3845 
3846 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3847   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3848   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3849   assert(m-&gt;is_method(), &quot;must be&quot;);
3850   return m;
3851 }
3852 
3853 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3854 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3855   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3856   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3857 }
3858 
3859 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
3860   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3861   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
3862 }
3863 
3864 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
3865   const Method* method = m();
3866 
3867   // lookup ResolvedMethod oop in the table, or create a new one and intern it
3868   oop resolved_method = ResolvedMethodTable::find_method(method);
3869   if (resolved_method != NULL) {
3870     return resolved_method;
3871   }
3872 
3873   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3874   if (!k-&gt;is_initialized()) {
3875     k-&gt;initialize(CHECK_NULL);
3876   }
3877 
3878   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
3879 
3880   NoSafepointVerifier nsv;
3881 
3882   if (method-&gt;is_old()) {
3883     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
3884                                       method-&gt;get_new_method();
3885   }
3886 
3887   InstanceKlass* holder = method-&gt;method_holder();
3888 
3889   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
3890   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
3891   // distinct loaders) to ensure the metadata is kept alive.
3892   // This mirror may be different than the one in clazz field.
3893   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
3894 
3895   // Set flag in class to indicate this InstanceKlass has entries in the table
3896   // to avoid walking table during redefinition if none of the redefined classes
3897   // have any membernames in the table.
3898   holder-&gt;set_has_resolved_methods();
3899 
3900   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
3901 }
3902 
3903 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3904   assert(is_instance(lform), &quot;wrong type&quot;);
3905   return lform-&gt;obj_field(_vmentry_offset);
3906 }
3907 
3908 
3909 // Support for java_lang_invoke_MethodType
3910 
3911 int java_lang_invoke_MethodType::_rtype_offset;
3912 int java_lang_invoke_MethodType::_ptypes_offset;
3913 
3914 #define METHODTYPE_FIELDS_DO(macro) \
3915   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3916   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3917 
3918 void java_lang_invoke_MethodType::compute_offsets() {
3919   InstanceKlass* k = SystemDictionary::MethodType_klass();
3920   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3921 }
3922 
3923 #if INCLUDE_CDS
3924 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3925   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3926 }
3927 #endif
3928 
3929 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3930   st-&gt;print(&quot;(&quot;);
3931   objArrayOop pts = ptypes(mt);
3932   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3933     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3934   }
3935   st-&gt;print(&quot;)&quot;);
3936   java_lang_Class::print_signature(rtype(mt), st);
3937 }
3938 
3939 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
3940   ResourceMark rm;
3941   stringStream buffer(128);
3942   print_signature(mt, &amp;buffer);
3943   const char* sigstr =       buffer.base();
3944   int         siglen = (int) buffer.size();
3945   Symbol *name;
3946   if (!intern_if_not_found) {
3947     name = SymbolTable::probe(sigstr, siglen);
3948   } else {
3949     name = SymbolTable::new_symbol(sigstr, siglen);
3950   }
3951   return name;
3952 }
3953 
3954 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
3955   if (mt1 == mt2)
3956     return true;
3957   if (rtype(mt1) != rtype(mt2))
3958     return false;
3959   if (ptype_count(mt1) != ptype_count(mt2))
3960     return false;
3961   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
3962     if (ptype(mt1, i) != ptype(mt2, i))
3963       return false;
3964   }
3965   return true;
3966 }
3967 
3968 oop java_lang_invoke_MethodType::rtype(oop mt) {
3969   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3970   return mt-&gt;obj_field(_rtype_offset);
3971 }
3972 
3973 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
3974   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3975   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
3976 }
3977 
3978 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
3979   return ptypes(mt)-&gt;obj_at(idx);
3980 }
3981 
3982 int java_lang_invoke_MethodType::ptype_count(oop mt) {
3983   return ptypes(mt)-&gt;length();
3984 }
3985 
3986 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
3987   objArrayOop pts = ptypes(mt);
3988   int count = pts-&gt;length();
3989   int slots = 0;
3990   for (int i = 0; i &lt; count; i++) {
3991     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
3992     slots += type2size[bt];
3993   }
3994   return slots;
3995 }
3996 
3997 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
3998   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
3999   return type2size[bt];
4000 }
4001 
4002 
4003 // Support for java_lang_invoke_CallSite
4004 
4005 int java_lang_invoke_CallSite::_target_offset;
4006 int java_lang_invoke_CallSite::_context_offset;
4007 
4008 #define CALLSITE_FIELDS_DO(macro) \
4009   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4010   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4011 
4012 void java_lang_invoke_CallSite::compute_offsets() {
4013   InstanceKlass* k = SystemDictionary::CallSite_klass();
4014   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4015 }
4016 
4017 #if INCLUDE_CDS
4018 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4019   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4020 }
4021 #endif
4022 
4023 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4024   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4025 
4026   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4027   return dep_oop;
4028 }
4029 
4030 // Support for java_lang_invoke_ConstantCallSite
4031 
4032 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4033 
4034 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4035   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4036 
4037 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4038   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4039   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4040 }
4041 
4042 #if INCLUDE_CDS
4043 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4044   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4045 }
4046 #endif
4047 
4048 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4049 
4050 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4051 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4052 
4053 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4054   InstanceKlass* k = SystemDictionary::Context_klass();
4055   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4056 }
4057 
4058 #if INCLUDE_CDS
4059 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4060   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4061 }
4062 #endif
4063 
4064 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4065   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4066   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4067   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4068   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4069   return dep_ctx;
4070 }
4071 
4072 // Support for java_security_AccessControlContext
4073 
4074 int java_security_AccessControlContext::_context_offset = 0;
4075 int java_security_AccessControlContext::_privilegedContext_offset = 0;
4076 int java_security_AccessControlContext::_isPrivileged_offset = 0;
4077 int java_security_AccessControlContext::_isAuthorized_offset = -1;
4078 
4079 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4080   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4081   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4082   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4083   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4084 
4085 void java_security_AccessControlContext::compute_offsets() {
4086   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4087   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4088   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4089 }
4090 
4091 #if INCLUDE_CDS
4092 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4093   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4094 }
4095 #endif
4096 
4097 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4098   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4099   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4100   // Ensure klass is initialized
4101   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4102   // Allocate result
4103   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4104   // Fill in values
4105   result-&gt;obj_field_put(_context_offset, context());
4106   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4107   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4108   // whitelist AccessControlContexts created by the JVM
4109   result-&gt;bool_field_put(_isAuthorized_offset, true);
4110   return result;
4111 }
4112 
4113 
4114 // Support for java_lang_ClassLoader
4115 
4116 bool java_lang_ClassLoader::offsets_computed = false;
4117 int  java_lang_ClassLoader::_loader_data_offset = -1;
4118 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4119 int  java_lang_ClassLoader::name_offset = -1;
4120 int  java_lang_ClassLoader::nameAndId_offset = -1;
4121 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4122 
4123 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4124   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4125   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4126   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4127 }
4128 
4129 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4130   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4131   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4132   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4133 }
4134 
4135 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4136   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4137   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4138   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4139 }
4140 
4141 #define CLASSLOADER_FIELDS_DO(macro) \
4142   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4143   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4144   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4145   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4146   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4147 
4148 void java_lang_ClassLoader::compute_offsets() {
4149   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4150   offsets_computed = true;
4151 
4152   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4153   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4154 
4155   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4156 }
4157 
4158 #if INCLUDE_CDS
4159 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4160   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4161   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4162 }
4163 #endif
4164 
4165 oop java_lang_ClassLoader::parent(oop loader) {
4166   assert(is_instance(loader), &quot;loader must be oop&quot;);
4167   return loader-&gt;obj_field(parent_offset);
4168 }
4169 
4170 // Returns the name field of this class loader.  If the name field has not
4171 // been set, null will be returned.
4172 oop java_lang_ClassLoader::name(oop loader) {
4173   assert(is_instance(loader), &quot;loader must be oop&quot;);
4174   return loader-&gt;obj_field(name_offset);
4175 }
4176 
4177 // Returns the nameAndId field of this class loader. The format is
4178 // as follows:
4179 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4180 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4181 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4182 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4183 oop java_lang_ClassLoader::nameAndId(oop loader) {
4184   assert(is_instance(loader), &quot;loader must be oop&quot;);
4185   return loader-&gt;obj_field(nameAndId_offset);
4186 }
4187 
4188 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4189   assert(is_instance(loader), &quot;loader must be oop&quot;);
4190   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4191   oop acl = loader;
4192   debug_only(jint loop_count = 0);
4193   // This loop taken verbatim from ClassLoader.java:
4194   do {
4195     acl = parent(acl);
4196     if (cl == acl) {
4197       return true;
4198     }
4199     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4200   } while (acl != NULL);
4201   return false;
4202 }
4203 
4204 bool java_lang_ClassLoader::is_instance(oop obj) {
4205   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4206 }
4207 
4208 
4209 // For class loader classes, parallelCapable defined
4210 // based on non-null field
4211 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4212 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4213   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);
4214   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4215 }
4216 
4217 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4218   // Fix for 4474172; see evaluation for more details
4219   loader = non_reflection_class_loader(loader);
4220 
4221   oop cl = SystemDictionary::java_system_loader();
4222   while(cl != NULL) {
4223     if (cl == loader) return true;
4224     cl = parent(cl);
4225   }
4226   return false;
4227 }
4228 
4229 // Return true if this is one of the class loaders associated with
4230 // the generated bytecodes for reflection.
4231 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4232   if (loader != NULL) {
4233     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4234     // This might be null in non-1.4 JDKs
4235     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4236   }
4237   return false;
4238 }
4239 
4240 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4241   // See whether this is one of the class loaders associated with
4242   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4243   // delegate to its parent to prevent class loading from occurring
4244   // in places where applications using reflection didn&#39;t expect it.
4245   if (is_reflection_class_loader(loader)) {
4246     return parent(loader);
4247   }
4248   return loader;
4249 }
4250 
4251 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4252   assert(is_instance(loader), &quot;loader must be oop&quot;);
4253   return loader-&gt;obj_field(unnamedModule_offset);
4254 }
4255 
4256 // Support for java_lang_System
4257 //
4258 #define SYSTEM_FIELDS_DO(macro) \
4259   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4260   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4261   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4262   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4263 
4264 void java_lang_System::compute_offsets() {
4265   InstanceKlass* k = SystemDictionary::System_klass();
4266   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4267 }
4268 
4269 #if INCLUDE_CDS
4270 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4271    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4272 }
4273 #endif
4274 
4275 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4276 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4277 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4278 
4279 // Support for jdk_internal_misc_UnsafeConstants
4280 //
4281 class UnsafeConstantsFixup : public FieldClosure {
4282 private:
4283   int _address_size;
4284   int _page_size;
4285   bool _big_endian;
4286   bool _use_unaligned_access;
4287   int _data_cache_line_flush_size;
4288 public:
4289   UnsafeConstantsFixup() {
4290     // round up values for all static final fields
4291     _address_size = sizeof(void*);
4292     _page_size = os::vm_page_size();
4293     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4294     _use_unaligned_access = UseUnalignedAccesses;
4295     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4296   }
4297 
4298   void do_field(fieldDescriptor* fd) {
4299     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4300     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4301     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4302     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4303     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4304     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4305       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4306     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4307       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4308     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4309       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4310     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4311       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4312     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4313       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4314     } else {
4315       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4316     }
4317   }
4318 };
4319 
4320 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4321   UnsafeConstantsFixup fixup;
4322   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4323 }
4324 
4325 int java_lang_Class::_klass_offset;
4326 int java_lang_Class::_array_klass_offset;
4327 int java_lang_Class::_oop_size_offset;
4328 int java_lang_Class::_static_oop_field_count_offset;
4329 int java_lang_Class::_class_loader_offset;
4330 int java_lang_Class::_module_offset;
4331 int java_lang_Class::_protection_domain_offset;
4332 int java_lang_Class::_component_mirror_offset;
<a name="14" id="anc14"></a>

4333 int java_lang_Class::_init_lock_offset;
4334 int java_lang_Class::_signers_offset;
4335 int java_lang_Class::_name_offset;
4336 int java_lang_Class::_source_file_offset;
4337 int java_lang_Class::_classData_offset;
4338 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4339 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4340 int java_lang_Throwable::backtrace_offset;
4341 int java_lang_Throwable::detailMessage_offset;
4342 int java_lang_Throwable::stackTrace_offset;
4343 int java_lang_Throwable::depth_offset;
4344 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4345 int java_lang_reflect_AccessibleObject::override_offset;
4346 int java_lang_reflect_Method::clazz_offset;
4347 int java_lang_reflect_Method::name_offset;
4348 int java_lang_reflect_Method::returnType_offset;
4349 int java_lang_reflect_Method::parameterTypes_offset;
4350 int java_lang_reflect_Method::exceptionTypes_offset;
4351 int java_lang_reflect_Method::slot_offset;
4352 int java_lang_reflect_Method::modifiers_offset;
4353 int java_lang_reflect_Method::signature_offset;
4354 int java_lang_reflect_Method::annotations_offset;
4355 int java_lang_reflect_Method::parameter_annotations_offset;
4356 int java_lang_reflect_Method::annotation_default_offset;
4357 int java_lang_reflect_Constructor::clazz_offset;
4358 int java_lang_reflect_Constructor::parameterTypes_offset;
4359 int java_lang_reflect_Constructor::exceptionTypes_offset;
4360 int java_lang_reflect_Constructor::slot_offset;
4361 int java_lang_reflect_Constructor::modifiers_offset;
4362 int java_lang_reflect_Constructor::signature_offset;
4363 int java_lang_reflect_Constructor::annotations_offset;
4364 int java_lang_reflect_Constructor::parameter_annotations_offset;
4365 int java_lang_reflect_Field::clazz_offset;
4366 int java_lang_reflect_Field::name_offset;
4367 int java_lang_reflect_Field::type_offset;
4368 int java_lang_reflect_Field::slot_offset;
4369 int java_lang_reflect_Field::modifiers_offset;
4370 int java_lang_reflect_Field::signature_offset;
4371 int java_lang_reflect_Field::annotations_offset;
4372 int java_lang_reflect_Parameter::name_offset;
4373 int java_lang_reflect_Parameter::modifiers_offset;
4374 int java_lang_reflect_Parameter::index_offset;
4375 int java_lang_reflect_Parameter::executable_offset;
4376 int java_lang_boxing_object::value_offset;
4377 int java_lang_boxing_object::long_value_offset;
4378 bool java_lang_ref_Reference::_offsets_initialized;
4379 int java_lang_ref_Reference::referent_offset;
4380 int java_lang_ref_Reference::queue_offset;
4381 int java_lang_ref_Reference::next_offset;
4382 int java_lang_ref_Reference::discovered_offset;
4383 int java_lang_ref_SoftReference::timestamp_offset;
4384 int java_lang_ref_SoftReference::static_clock_offset;
4385 int java_lang_ClassLoader::parent_offset;
4386 int java_lang_System::static_in_offset;
4387 int java_lang_System::static_out_offset;
4388 int java_lang_System::static_err_offset;
4389 int java_lang_System::static_security_offset;
4390 int java_lang_StackTraceElement::methodName_offset;
4391 int java_lang_StackTraceElement::fileName_offset;
4392 int java_lang_StackTraceElement::lineNumber_offset;
4393 int java_lang_StackTraceElement::moduleName_offset;
4394 int java_lang_StackTraceElement::moduleVersion_offset;
4395 int java_lang_StackTraceElement::classLoaderName_offset;
4396 int java_lang_StackTraceElement::declaringClass_offset;
4397 int java_lang_StackTraceElement::declaringClassObject_offset;
4398 int java_lang_StackFrameInfo::_memberName_offset;
4399 int java_lang_StackFrameInfo::_bci_offset;
4400 int java_lang_StackFrameInfo::_version_offset;
4401 int java_lang_LiveStackFrameInfo::_monitors_offset;
4402 int java_lang_LiveStackFrameInfo::_locals_offset;
4403 int java_lang_LiveStackFrameInfo::_operands_offset;
4404 int java_lang_LiveStackFrameInfo::_mode_offset;
4405 int java_lang_AssertionStatusDirectives::classes_offset;
4406 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4407 int java_lang_AssertionStatusDirectives::packages_offset;
4408 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4409 int java_lang_AssertionStatusDirectives::deflt_offset;
4410 int java_nio_Buffer::_limit_offset;
4411 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4412 int reflect_ConstantPool::_oop_offset;
4413 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4414 int java_lang_Integer_IntegerCache::_static_cache_offset;
4415 int java_lang_Long_LongCache::_static_cache_offset;
4416 int java_lang_Character_CharacterCache::_static_cache_offset;
4417 int java_lang_Short_ShortCache::_static_cache_offset;
4418 int java_lang_Byte_ByteCache::_static_cache_offset;
4419 int java_lang_Boolean::_static_TRUE_offset;
4420 int java_lang_Boolean::_static_FALSE_offset;
4421 int java_lang_reflect_RecordComponent::clazz_offset;
4422 int java_lang_reflect_RecordComponent::name_offset;
4423 int java_lang_reflect_RecordComponent::type_offset;
4424 int java_lang_reflect_RecordComponent::accessor_offset;
4425 int java_lang_reflect_RecordComponent::signature_offset;
4426 int java_lang_reflect_RecordComponent::annotations_offset;
4427 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<a name="15" id="anc15"></a>




4428 
4429 
4430 
4431 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4432   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4433   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4434   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4435   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4436   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4437   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4438   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4439   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4440 
4441 // Support for java_lang_StackTraceElement
4442 void java_lang_StackTraceElement::compute_offsets() {
4443   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4444   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4445 }
4446 
4447 #if INCLUDE_CDS
4448 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4449   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4450 }
4451 #endif
4452 
4453 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4454   element-&gt;obj_field_put(fileName_offset, value);
4455 }
4456 
4457 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4458   element-&gt;obj_field_put(declaringClass_offset, value);
4459 }
4460 
4461 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4462   element-&gt;obj_field_put(methodName_offset, value);
4463 }
4464 
4465 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4466   element-&gt;int_field_put(lineNumber_offset, value);
4467 }
4468 
4469 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4470   element-&gt;obj_field_put(moduleName_offset, value);
4471 }
4472 
4473 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4474   element-&gt;obj_field_put(moduleVersion_offset, value);
4475 }
4476 
4477 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4478   element-&gt;obj_field_put(classLoaderName_offset, value);
4479 }
4480 
4481 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4482   element-&gt;obj_field_put(declaringClassObject_offset, value);
4483 }
4484 
4485 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4486   element-&gt;short_field_put(_version_offset, value);
4487 }
4488 
4489 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
4490   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
4491   element-&gt;int_field_put(_bci_offset, value);
4492 }
4493 
4494 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4495   element-&gt;obj_field_put(_monitors_offset, value);
4496 }
4497 
4498 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4499   element-&gt;obj_field_put(_locals_offset, value);
4500 }
4501 
4502 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4503   element-&gt;obj_field_put(_operands_offset, value);
4504 }
4505 
4506 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4507   element-&gt;int_field_put(_mode_offset, value);
4508 }
4509 
4510 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4511 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4512   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4513   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4514   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4515   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4516   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4517 
4518 void java_lang_AssertionStatusDirectives::compute_offsets() {
4519   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4520   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4521 }
4522 
4523 #if INCLUDE_CDS
4524 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4525   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4526 }
4527 #endif
4528 
4529 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4530   o-&gt;obj_field_put(classes_offset, val);
4531 }
4532 
4533 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4534   o-&gt;obj_field_put(classEnabled_offset, val);
4535 }
4536 
4537 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4538   o-&gt;obj_field_put(packages_offset, val);
4539 }
4540 
4541 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4542   o-&gt;obj_field_put(packageEnabled_offset, val);
4543 }
4544 
4545 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4546   o-&gt;bool_field_put(deflt_offset, val);
4547 }
4548 
4549 
4550 // Support for intrinsification of java.nio.Buffer.checkIndex
4551 int java_nio_Buffer::limit_offset() {
4552   return _limit_offset;
4553 }
4554 
4555 #define BUFFER_FIELDS_DO(macro) \
4556   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4557 
4558 void java_nio_Buffer::compute_offsets() {
4559   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4560   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4561   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4562 }
4563 
4564 #if INCLUDE_CDS
4565 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4566   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4567 }
4568 #endif
4569 
4570 #define AOS_FIELDS_DO(macro) \
4571   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4572 
4573 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4574   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4575   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4576 }
4577 
4578 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4579   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4580   return obj-&gt;obj_field(_owner_offset);
4581 }
4582 
4583 #if INCLUDE_CDS
4584 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4585   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4586 }
4587 #endif
4588 
4589 #define INTEGER_CACHE_FIELDS_DO(macro) \
4590   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4591 
4592 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4593   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4594   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4595 }
4596 
4597 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4598   oop base = ik-&gt;static_field_base_raw();
4599   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4600 }
4601 
4602 Symbol* java_lang_Integer_IntegerCache::symbol() {
4603   return vmSymbols::java_lang_Integer_IntegerCache();
4604 }
4605 
4606 #if INCLUDE_CDS
4607 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4608   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4609 }
4610 #endif
4611 #undef INTEGER_CACHE_FIELDS_DO
4612 
4613 jint java_lang_Integer::value(oop obj) {
4614    jvalue v;
4615    java_lang_boxing_object::get_value(obj, &amp;v);
4616    return v.i;
4617 }
4618 
4619 #define LONG_CACHE_FIELDS_DO(macro) \
4620   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4621 
4622 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4623   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4624   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4625 }
4626 
4627 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4628   oop base = ik-&gt;static_field_base_raw();
4629   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4630 }
4631 
4632 Symbol* java_lang_Long_LongCache::symbol() {
4633   return vmSymbols::java_lang_Long_LongCache();
4634 }
4635 
4636 #if INCLUDE_CDS
4637 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4638   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4639 }
4640 #endif
4641 #undef LONG_CACHE_FIELDS_DO
4642 
4643 jlong java_lang_Long::value(oop obj) {
4644    jvalue v;
4645    java_lang_boxing_object::get_value(obj, &amp;v);
4646    return v.j;
4647 }
4648 
4649 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4650   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4651 
4652 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4653   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4654   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4655 }
4656 
4657 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4658   oop base = ik-&gt;static_field_base_raw();
4659   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4660 }
4661 
4662 Symbol* java_lang_Character_CharacterCache::symbol() {
4663   return vmSymbols::java_lang_Character_CharacterCache();
4664 }
4665 
4666 #if INCLUDE_CDS
4667 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4668   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4669 }
4670 #endif
4671 #undef CHARACTER_CACHE_FIELDS_DO
4672 
4673 jchar java_lang_Character::value(oop obj) {
4674    jvalue v;
4675    java_lang_boxing_object::get_value(obj, &amp;v);
4676    return v.c;
4677 }
4678 
4679 #define SHORT_CACHE_FIELDS_DO(macro) \
4680   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4681 
4682 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4683   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4684   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4685 }
4686 
4687 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4688   oop base = ik-&gt;static_field_base_raw();
4689   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4690 }
4691 
4692 Symbol* java_lang_Short_ShortCache::symbol() {
4693   return vmSymbols::java_lang_Short_ShortCache();
4694 }
4695 
4696 #if INCLUDE_CDS
4697 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4698   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4699 }
4700 #endif
4701 #undef SHORT_CACHE_FIELDS_DO
4702 
4703 jshort java_lang_Short::value(oop obj) {
4704    jvalue v;
4705    java_lang_boxing_object::get_value(obj, &amp;v);
4706    return v.s;
4707 }
4708 
4709 #define BYTE_CACHE_FIELDS_DO(macro) \
4710   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4711 
4712 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4713   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4714   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4715 }
4716 
4717 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4718   oop base = ik-&gt;static_field_base_raw();
4719   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4720 }
4721 
4722 Symbol* java_lang_Byte_ByteCache::symbol() {
4723   return vmSymbols::java_lang_Byte_ByteCache();
4724 }
4725 
4726 #if INCLUDE_CDS
4727 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4728   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4729 }
4730 #endif
4731 #undef BYTE_CACHE_FIELDS_DO
4732 
<a name="16" id="anc16"></a>






























































4733 jbyte java_lang_Byte::value(oop obj) {
4734    jvalue v;
4735    java_lang_boxing_object::get_value(obj, &amp;v);
4736    return v.b;
4737 }
4738 #define BOOLEAN_FIELDS_DO(macro) \
4739   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4740   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4741 
4742 
4743 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4744   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4745   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4746 }
4747 
4748 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4749   oop base = ik-&gt;static_field_base_raw();
4750   return base-&gt;obj_field(_static_TRUE_offset);
4751 }
4752 
4753 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4754   oop base = ik-&gt;static_field_base_raw();
4755   return base-&gt;obj_field(_static_FALSE_offset);
4756 }
4757 
4758 Symbol* java_lang_Boolean::symbol() {
4759   return vmSymbols::java_lang_Boolean();
4760 }
4761 
4762 #if INCLUDE_CDS
4763 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4764   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4765 }
4766 #endif
4767 #undef BOOLEAN_CACHE_FIELDS_DO
4768 
4769 jboolean java_lang_Boolean::value(oop obj) {
4770    jvalue v;
4771    java_lang_boxing_object::get_value(obj, &amp;v);
4772    return v.z;
4773 }
4774 
4775 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4776   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4777   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4778   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4779   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4780   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4781   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4782   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4783 
4784 // Support for java_lang_reflect_RecordComponent
4785 void java_lang_reflect_RecordComponent::compute_offsets() {
4786   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4787   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4788 }
4789 
4790 #if INCLUDE_CDS
4791 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4792   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4793 }
4794 #endif
4795 
4796 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4797   element-&gt;obj_field_put(clazz_offset, value);
4798 }
4799 
4800 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4801   element-&gt;obj_field_put(name_offset, value);
4802 }
4803 
4804 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4805   element-&gt;obj_field_put(type_offset, value);
4806 }
4807 
4808 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4809   element-&gt;obj_field_put(accessor_offset, value);
4810 }
4811 
4812 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4813   element-&gt;obj_field_put(signature_offset, value);
4814 }
4815 
4816 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4817   element-&gt;obj_field_put(annotations_offset, value);
4818 }
4819 
4820 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4821   element-&gt;obj_field_put(typeAnnotations_offset, value);
4822 }
4823 
4824 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4825 
4826 // Compute non-hard-coded field offsets of all the classes in this file
4827 void JavaClasses::compute_offsets() {
4828   if (UseSharedSpaces) {
4829     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4830                                                          JvmtiExport::has_early_class_hook_env()),
4831                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4832     // None of the classes used by the rest of this function can be replaced by
4833     // JMVTI ClassFileLoadHook.
4834     // We are safe to use the archived offsets, which have already been restored
4835     // by JavaClasses::serialize_offsets, without computing the offsets again.
4836     return;
4837   }
4838 
4839   // We have already called the compute_offsets() of the
4840   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4841   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4842   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4843 }
4844 
4845 #if INCLUDE_CDS
4846 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4847 
4848 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4849   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4850 }
4851 #endif
4852 
4853 #if INCLUDE_CDS_JAVA_HEAP
4854 bool JavaClasses::is_supported_for_archiving(oop obj) {
4855   Klass* klass = obj-&gt;klass();
4856 
4857   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4858       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4859       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4860       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4861       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4862       // So for now we cannot not support these classes for archiving.
4863       //
4864       // These objects typically are not referenced by static fields, but rather by resolved
4865       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4866       klass == SystemDictionary::ResolvedMethodName_klass() ||
4867       klass == SystemDictionary::MemberName_klass() ||
4868       klass == SystemDictionary::Context_klass()) {
4869     return false;
4870   }
4871 
4872   return true;
4873 }
4874 #endif
4875 
4876 #ifndef PRODUCT
4877 
4878 // These functions exist to assert the validity of hard-coded field offsets to guard
4879 // against changes in the class files
4880 
4881 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
4882   EXCEPTION_MARK;
4883   fieldDescriptor fd;
4884   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4885   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4886   InstanceKlass* ik = InstanceKlass::cast(k);
4887   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
4888   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
4889   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4890     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4891     return false;
4892   }
4893   if (fd.is_static()) {
4894     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4895     return false;
4896   }
4897   if (fd.offset() == hardcoded_offset ) {
4898     return true;
4899   } else {
4900     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
4901                   klass_name, field_name, hardcoded_offset, fd.offset());
4902     return false;
4903   }
4904 }
4905 
4906 // Check the hard-coded field offsets of all the classes in this file
4907 
4908 void JavaClasses::check_offsets() {
4909   bool valid = true;
4910 
4911 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4912   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
4913 
4914 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4915   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
4916 
4917   // Boxed primitive objects (java_lang_boxing_object)
4918 
4919   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4920   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4921   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4922   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4923   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4924   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4925   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4926   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4927 
4928   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
4929 }
4930 
4931 #endif // PRODUCT
4932 
4933 int InjectedField::compute_offset() {
4934   InstanceKlass* ik = InstanceKlass::cast(klass());
4935   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4936     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4937       // Only look at injected fields
4938       continue;
4939     }
4940     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4941       return fs.offset();
4942     }
4943   }
4944   ResourceMark rm;
4945   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4946 #ifndef PRODUCT
4947   ik-&gt;print();
4948   tty-&gt;print_cr(&quot;all fields:&quot;);
4949   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4950     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
4951   }
4952 #endif //PRODUCT
4953   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
4954   return -1;
4955 }
4956 
4957 void javaClasses_init() {
4958   JavaClasses::compute_offsets();
4959   JavaClasses::check_offsets();
4960   FilteredFieldsMap::initialize();  // must be done after computing offsets.
4961 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
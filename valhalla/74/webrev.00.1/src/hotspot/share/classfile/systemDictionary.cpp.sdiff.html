<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;

  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;

  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;
  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;

  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #include &quot;utilities/utf8.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/jfr.hpp&quot;
  93 #endif
  94 
  95 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  96 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  97 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  98 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  99 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 100 
</pre>
<hr />
<pre>
 304 
 305 
 306 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 307 
 308 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 309   if (Signature::is_array(class_name)) {
 310     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 311   } else {
 312     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 313   }
 314 }
 315 
 316 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 317 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 318                                                                        Handle class_loader,
 319                                                                        Handle protection_domain,
 320                                                                        TRAPS) {
 321   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 322   if (Signature::has_envelope(class_name)) {
 323     ResourceMark rm(THREAD);
<span class="line-modified"> 324     // Ignore wrapping L and ;.</span>
 325     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 326                                                  class_name-&gt;utf8_length() - 2);
 327     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 328   } else {
 329     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 330   }
 331 }
 332 
 333 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 334   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 335 }
 336 
 337 // Forwards to resolve_instance_class_or_null
 338 
 339 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 340                                                      Handle class_loader,
 341                                                      Handle protection_domain,
 342                                                      TRAPS) {
 343   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 344   ResourceMark rm(THREAD);
 345   SignatureStream ss(class_name, false);
 346   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 347   Klass* k = NULL;
 348   BasicType t = ss.type();
 349   if (ss.has_envelope()) {
 350     Symbol* obj_class = ss.as_symbol();
 351     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 352                                                          class_loader,
 353                                                          protection_domain,
 354                                                          CHECK_NULL);
 355     if (k != NULL) {
 356       k = k-&gt;array_klass(ndims, CHECK_NULL);
 357     }
 358   } else {
 359     k = Universe::typeArrayKlassObj(t);
 360     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 361   }
 362   return k;
 363 }
 364 
<span class="line-removed"> 365 </span>
 366 // Must be called for any super-class or super-interface resolution
 367 // during class definition to allow class circularity checking
 368 // super-interface callers:
 369 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 370 // super-class callers:
 371 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 372 //   load_shared_class - while loading a class from shared archive
 373 //   resolve_instance_class_or_null:
 374 //     via: handle_parallel_super_load
 375 //      when resolving a class that has an existing placeholder with
 376 //      a saved superclass [i.e. a defineClass is currently in progress]
 377 //      if another thread is trying to resolve the class, it must do
 378 //      super-class checks on its own thread to catch class circularity
 379 // This last call is critical in class circularity checking for cases
 380 // where classloading is delegated to different threads and the
 381 // classloader lock is released.
 382 // Take the case: Base-&gt;Super-&gt;Base
 383 //   1. If thread T1 tries to do a defineClass of class Base
 384 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 385 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 489   // The instanceKlass is kept alive because the class loader is on the stack,
 490   // which keeps the loader_data alive, as well as all instanceKlasses in
 491   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 492   {
 493     MutexLocker mu(THREAD, SystemDictionary_lock);
 494     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 495     SystemDictionary_lock-&gt;notify_all();
 496   }
 497   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 498     // can null superk
 499     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 500     assert(k == NULL || k == superk, &quot;must be&quot;);
 501     if (k == NULL) {
 502       superk = NULL;
 503     }
 504   }
 505 
 506   return superk;
 507 }
 508 













































 509 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 510                                                   Handle class_loader,
 511                                                   Handle protection_domain,
 512                                                   TRAPS) {
 513   // Now we have to call back to java to check if the initating class has access
 514   JavaValue result(T_VOID);
 515   LogTarget(Debug, protectiondomain) lt;
 516   if (lt.is_enabled()) {
 517     ResourceMark rm(THREAD);
 518     // Print out trace information
 519     LogStream ls(lt);
 520     ls.print_cr(&quot;Checking package access&quot;);
 521     if (class_loader() != NULL) {
 522       ls.print(&quot;class loader: &quot;);
 523       class_loader()-&gt;print_value_on(&amp;ls);
 524     } else {
 525       ls.print_cr(&quot;class loader: NULL&quot;);
 526     }
 527     if (protection_domain() != NULL) {
 528       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1016                           protection_domain);
1017 }
1018 
1019 
1020 // Look for a loaded instance or array klass by name.  Do not do any loading.
1021 // return NULL in case of error.
1022 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1023                                                       Handle class_loader,
1024                                                       Handle protection_domain,
1025                                                       TRAPS) {
1026   Klass* k = NULL;
1027   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1028 
1029   if (Signature::is_array(class_name)) {
1030     // The name refers to an array.  Parse the name.
1031     // dimension and object_key in FieldArrayInfo are assigned as a
1032     // side-effect of this call
1033     SignatureStream ss(class_name, false);
1034     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1035     BasicType t = ss.type();
<span class="line-modified">1036     if (t != T_OBJECT) {</span>
1037       k = Universe::typeArrayKlassObj(t);
1038     } else {
1039       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1040     }
1041     if (k != NULL) {
1042       k = k-&gt;array_klass_or_null(ndims);
1043     }
1044   } else {
1045     k = find(class_name, class_loader, protection_domain, THREAD);
1046   }
1047   return k;
1048 }
1049 
1050 // Note: this method is much like resolve_from_stream, but
1051 // does not publish the classes via the SystemDictionary.
1052 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1053 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1054 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1055                                               Handle class_loader,
1056                                               ClassFileStream* st,
</pre>
<hr />
<pre>
2287 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2288                     Symbol* class_name, Handle class_loader, TRAPS) {
2289 
2290   // First see if it has been loaded directly.
2291   // Force the protection domain to be null.  (This removes protection checks.)
2292   Handle no_protection_domain;
2293   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2294                                               no_protection_domain, CHECK_NULL);
2295   if (klass != NULL)
2296     return klass;
2297 
2298   // Now look to see if it has been loaded elsewhere, and is subject to
2299   // a loader constraint that would require this loader to return the
2300   // klass that is already loaded.
2301   if (Signature::is_array(class_name)) {
2302     // For array classes, their Klass*s are not kept in the
2303     // constraint table. The element Klass*s are.
2304     SignatureStream ss(class_name, false);
2305     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2306     BasicType t = ss.type();
<span class="line-modified">2307     if (t != T_OBJECT) {</span>
2308       klass = Universe::typeArrayKlassObj(t);
2309     } else {
2310       MutexLocker mu(THREAD, SystemDictionary_lock);
2311       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2312     }
2313     // If element class already loaded, allocate array klass
2314     if (klass != NULL) {
2315       klass = klass-&gt;array_klass_or_null(ndims);
2316     }
2317   } else {
2318     MutexLocker mu(THREAD, SystemDictionary_lock);
2319     // Non-array classes are easy: simply check the constraint table.
2320     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2321   }
2322 
2323   return klass;
2324 }
2325 
2326 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2327                                              Klass* klass_being_linked,
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
<span class="line-added">  63 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  64 #include &quot;oops/instanceKlass.hpp&quot;
  65 #include &quot;oops/instanceRefKlass.hpp&quot;
  66 #include &quot;oops/klass.inline.hpp&quot;
  67 #include &quot;oops/method.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.hpp&quot;
  70 #include &quot;oops/objArrayOop.inline.hpp&quot;
  71 #include &quot;oops/oop.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  74 #include &quot;oops/valueKlass.hpp&quot;</span>
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added">  83 #include &quot;runtime/os.hpp&quot;</span>
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/utf8.hpp&quot;
  91 #if INCLUDE_CDS
  92 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  93 #endif
  94 #if INCLUDE_JFR
  95 #include &quot;jfr/jfr.hpp&quot;
  96 #endif
  97 
  98 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  99 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
 100 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 101 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 102 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 103 
</pre>
<hr />
<pre>
 307 
 308 
 309 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 310 
 311 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 312   if (Signature::is_array(class_name)) {
 313     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 314   } else {
 315     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 316   }
 317 }
 318 
 319 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 320 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 321                                                                        Handle class_loader,
 322                                                                        Handle protection_domain,
 323                                                                        TRAPS) {
 324   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 325   if (Signature::has_envelope(class_name)) {
 326     ResourceMark rm(THREAD);
<span class="line-modified"> 327     // Ignore wrapping L and ;. (and Q and ; for value types);</span>
 328     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 329                                                  class_name-&gt;utf8_length() - 2);
 330     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 331   } else {
 332     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 333   }
 334 }
 335 
 336 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 337   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 338 }
 339 
 340 // Forwards to resolve_instance_class_or_null
 341 
 342 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 343                                                      Handle class_loader,
 344                                                      Handle protection_domain,
 345                                                      TRAPS) {
 346   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 347   ResourceMark rm(THREAD);
 348   SignatureStream ss(class_name, false);
 349   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 350   Klass* k = NULL;
 351   BasicType t = ss.type();
 352   if (ss.has_envelope()) {
 353     Symbol* obj_class = ss.as_symbol();
 354     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 355                                                          class_loader,
 356                                                          protection_domain,
 357                                                          CHECK_NULL);
 358     if (k != NULL) {
 359       k = k-&gt;array_klass(ndims, CHECK_NULL);
 360     }
 361   } else {
 362     k = Universe::typeArrayKlassObj(t);
 363     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 364   }
 365   return k;
 366 }
 367 

 368 // Must be called for any super-class or super-interface resolution
 369 // during class definition to allow class circularity checking
 370 // super-interface callers:
 371 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 372 // super-class callers:
 373 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 374 //   load_shared_class - while loading a class from shared archive
 375 //   resolve_instance_class_or_null:
 376 //     via: handle_parallel_super_load
 377 //      when resolving a class that has an existing placeholder with
 378 //      a saved superclass [i.e. a defineClass is currently in progress]
 379 //      if another thread is trying to resolve the class, it must do
 380 //      super-class checks on its own thread to catch class circularity
 381 // This last call is critical in class circularity checking for cases
 382 // where classloading is delegated to different threads and the
 383 // classloader lock is released.
 384 // Take the case: Base-&gt;Super-&gt;Base
 385 //   1. If thread T1 tries to do a defineClass of class Base
 386 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 387 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 491   // The instanceKlass is kept alive because the class loader is on the stack,
 492   // which keeps the loader_data alive, as well as all instanceKlasses in
 493   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 494   {
 495     MutexLocker mu(THREAD, SystemDictionary_lock);
 496     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 497     SystemDictionary_lock-&gt;notify_all();
 498   }
 499   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 500     // can null superk
 501     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 502     assert(k == NULL || k == superk, &quot;must be&quot;);
 503     if (k == NULL) {
 504       superk = NULL;
 505     }
 506   }
 507 
 508   return superk;
 509 }
 510 
<span class="line-added"> 511 Klass* SystemDictionary::resolve_flattenable_field_or_fail(AllFieldStream* fs,</span>
<span class="line-added"> 512                                                            Handle class_loader,</span>
<span class="line-added"> 513                                                            Handle protection_domain,</span>
<span class="line-added"> 514                                                            bool throw_error,</span>
<span class="line-added"> 515                                                            TRAPS) {</span>
<span class="line-added"> 516   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 517   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));</span>
<span class="line-added"> 518   ClassLoaderData* loader_data = class_loader_data(class_loader);</span>
<span class="line-added"> 519   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);</span>
<span class="line-added"> 520   int p_index = placeholders()-&gt;hash_to_index(p_hash);</span>
<span class="line-added"> 521   bool throw_circularity_error = false;</span>
<span class="line-added"> 522   PlaceholderEntry* oldprobe;</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524   {</span>
<span class="line-added"> 525     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 526     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);</span>
<span class="line-added"> 527     if (oldprobe != NULL &amp;&amp;</span>
<span class="line-added"> 528       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::FLATTENABLE_FIELD)) {</span>
<span class="line-added"> 529       throw_circularity_error = true;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531     } else {</span>
<span class="line-added"> 532       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 533                                    PlaceholderTable::FLATTENABLE_FIELD, NULL, THREAD);</span>
<span class="line-added"> 534     }</span>
<span class="line-added"> 535   }</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537   Klass* klass = NULL;</span>
<span class="line-added"> 538   if (!throw_circularity_error) {</span>
<span class="line-added"> 539     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,</span>
<span class="line-added"> 540                                                protection_domain, true, THREAD);</span>
<span class="line-added"> 541   } else {</span>
<span class="line-added"> 542     ResourceMark rm(THREAD);</span>
<span class="line-added"> 543     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());</span>
<span class="line-added"> 544   }</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546   {</span>
<span class="line-added"> 547     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 548     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 549                                     PlaceholderTable::FLATTENABLE_FIELD, THREAD);</span>
<span class="line-added"> 550   }</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552   class_name-&gt;decrement_refcount();</span>
<span class="line-added"> 553   return klass;</span>
<span class="line-added"> 554 }</span>
<span class="line-added"> 555 </span>
 556 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 557                                                   Handle class_loader,
 558                                                   Handle protection_domain,
 559                                                   TRAPS) {
 560   // Now we have to call back to java to check if the initating class has access
 561   JavaValue result(T_VOID);
 562   LogTarget(Debug, protectiondomain) lt;
 563   if (lt.is_enabled()) {
 564     ResourceMark rm(THREAD);
 565     // Print out trace information
 566     LogStream ls(lt);
 567     ls.print_cr(&quot;Checking package access&quot;);
 568     if (class_loader() != NULL) {
 569       ls.print(&quot;class loader: &quot;);
 570       class_loader()-&gt;print_value_on(&amp;ls);
 571     } else {
 572       ls.print_cr(&quot;class loader: NULL&quot;);
 573     }
 574     if (protection_domain() != NULL) {
 575       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1063                           protection_domain);
1064 }
1065 
1066 
1067 // Look for a loaded instance or array klass by name.  Do not do any loading.
1068 // return NULL in case of error.
1069 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1070                                                       Handle class_loader,
1071                                                       Handle protection_domain,
1072                                                       TRAPS) {
1073   Klass* k = NULL;
1074   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1075 
1076   if (Signature::is_array(class_name)) {
1077     // The name refers to an array.  Parse the name.
1078     // dimension and object_key in FieldArrayInfo are assigned as a
1079     // side-effect of this call
1080     SignatureStream ss(class_name, false);
1081     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1082     BasicType t = ss.type();
<span class="line-modified">1083     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {</span>
1084       k = Universe::typeArrayKlassObj(t);
1085     } else {
1086       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1087     }
1088     if (k != NULL) {
1089       k = k-&gt;array_klass_or_null(ndims);
1090     }
1091   } else {
1092     k = find(class_name, class_loader, protection_domain, THREAD);
1093   }
1094   return k;
1095 }
1096 
1097 // Note: this method is much like resolve_from_stream, but
1098 // does not publish the classes via the SystemDictionary.
1099 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1100 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1101 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1102                                               Handle class_loader,
1103                                               ClassFileStream* st,
</pre>
<hr />
<pre>
2334 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2335                     Symbol* class_name, Handle class_loader, TRAPS) {
2336 
2337   // First see if it has been loaded directly.
2338   // Force the protection domain to be null.  (This removes protection checks.)
2339   Handle no_protection_domain;
2340   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2341                                               no_protection_domain, CHECK_NULL);
2342   if (klass != NULL)
2343     return klass;
2344 
2345   // Now look to see if it has been loaded elsewhere, and is subject to
2346   // a loader constraint that would require this loader to return the
2347   // klass that is already loaded.
2348   if (Signature::is_array(class_name)) {
2349     // For array classes, their Klass*s are not kept in the
2350     // constraint table. The element Klass*s are.
2351     SignatureStream ss(class_name, false);
2352     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2353     BasicType t = ss.type();
<span class="line-modified">2354     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {</span>
2355       klass = Universe::typeArrayKlassObj(t);
2356     } else {
2357       MutexLocker mu(THREAD, SystemDictionary_lock);
2358       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2359     }
2360     // If element class already loaded, allocate array klass
2361     if (klass != NULL) {
2362       klass = klass-&gt;array_klass_or_null(ndims);
2363     }
2364   } else {
2365     MutexLocker mu(THREAD, SystemDictionary_lock);
2366     // Non-array classes are easy: simply check the constraint table.
2367     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2368   }
2369 
2370   return klass;
2371 }
2372 
2373 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2374                                              Klass* klass_being_linked,
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
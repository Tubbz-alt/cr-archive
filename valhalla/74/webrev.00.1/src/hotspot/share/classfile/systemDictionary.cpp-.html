<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;
  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;
  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #include &quot;utilities/utf8.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/jfr.hpp&quot;
  93 #endif
  94 
  95 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  96 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  97 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  98 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  99 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 100 
 101 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 102 
 103 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 104                                                           =  { NULL /*, NULL...*/ };
 105 
 106 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 107 
 108 oop         SystemDictionary::_java_system_loader         =  NULL;
 109 oop         SystemDictionary::_java_platform_loader       =  NULL;
 110 
 111 // Default ProtectionDomainCacheSize value
 112 
 113 const int defaultProtectionDomainCacheSize = 1009;
 114 
 115 ClassLoadInfo::ClassLoadInfo() {
 116   _protection_domain = Handle();
 117   _unsafe_anonymous_host = NULL;
 118   _cp_patches = NULL;
 119   _class_hidden_info._dynamic_nest_host = NULL;
 120   _class_hidden_info._class_data = Handle();
 121   _is_hidden = false;
 122   _is_strong_hidden = false;
 123   _can_access_vm_annotations = false;
 124 }
 125 
 126 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 127   _protection_domain = protection_domain;
 128   _unsafe_anonymous_host = NULL;
 129   _cp_patches = NULL;
 130   _class_hidden_info._dynamic_nest_host = NULL;
 131   _class_hidden_info._class_data = Handle();
 132   _is_hidden = false;
 133   _is_strong_hidden = false;
 134   _can_access_vm_annotations = false;
 135 }
 136 
 137 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 138                              const InstanceKlass* unsafe_anonymous_host,
 139                              GrowableArray&lt;Handle&gt;* cp_patches,
 140                              InstanceKlass* dynamic_nest_host,
 141                              Handle class_data,
 142                              bool is_hidden,
 143                              bool is_strong_hidden,
 144                              bool can_access_vm_annotations) {
 145   _protection_domain = protection_domain;
 146   _unsafe_anonymous_host = unsafe_anonymous_host;
 147   _cp_patches = cp_patches;
 148   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 149   _class_hidden_info._class_data = class_data;
 150   _is_hidden = is_hidden;
 151   _is_strong_hidden = is_strong_hidden;
 152   _can_access_vm_annotations = can_access_vm_annotations;
 153 }
 154 
 155 // ----------------------------------------------------------------------------
 156 // Java-level SystemLoader and PlatformLoader
 157 
 158 oop SystemDictionary::java_system_loader() {
 159   return _java_system_loader;
 160 }
 161 
 162 oop SystemDictionary::java_platform_loader() {
 163   return _java_platform_loader;
 164 }
 165 
 166 void SystemDictionary::compute_java_loaders(TRAPS) {
 167   JavaValue result(T_OBJECT);
 168   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 169   JavaCalls::call_static(&amp;result,
 170                          class_loader_klass,
 171                          vmSymbols::getSystemClassLoader_name(),
 172                          vmSymbols::void_classloader_signature(),
 173                          CHECK);
 174 
 175   _java_system_loader = (oop)result.get_jobject();
 176 
 177   JavaCalls::call_static(&amp;result,
 178                          class_loader_klass,
 179                          vmSymbols::getPlatformClassLoader_name(),
 180                          vmSymbols::void_classloader_signature(),
 181                          CHECK);
 182 
 183   _java_platform_loader = (oop)result.get_jobject();
 184 }
 185 
 186 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 187   if (create_mirror_cld) {
 188     // Add a new class loader data to the graph.
 189     return ClassLoaderDataGraph::add(class_loader, true);
 190   } else {
 191     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 192                                       ClassLoaderDataGraph::find_or_create(class_loader);
 193   }
 194 }
 195 
 196 // ----------------------------------------------------------------------------
 197 // Parallel class loading check
 198 
 199 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 200   if (class_loader.is_null()) return true;
 201   if (AlwaysLockClassLoader) return false;
 202   return java_lang_ClassLoader::parallelCapable(class_loader());
 203 }
 204 // ----------------------------------------------------------------------------
 205 // ParallelDefineClass flag does not apply to bootclass loader
 206 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 207    if (class_loader.is_null()) return false;
 208    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 209      return true;
 210    }
 211    return false;
 212 }
 213 
 214 // Returns true if the passed class loader is the builtin application class loader
 215 // or a custom system class loader. A customer system class loader can be
 216 // specified via -Djava.system.class.loader.
 217 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 218   if (class_loader == NULL) {
 219     return false;
 220   }
 221   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 222          class_loader == _java_system_loader);
 223 }
 224 
 225 // Returns true if the passed class loader is the platform class loader.
 226 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 227   if (class_loader == NULL) {
 228     return false;
 229   }
 230   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 231 }
 232 
 233 // ----------------------------------------------------------------------------
 234 // Resolving of classes
 235 
 236 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 237   if (name == NULL) {
 238     THROW_MSG_0(exception, &quot;No class name given&quot;);
 239   }
 240   if ((int)strlen(name) &gt; Symbol::max_length()) {
 241     // It&#39;s impossible to create this class;  the name cannot fit
 242     // into the constant pool.
 243     Exceptions::fthrow(THREAD_AND_LOCATION, exception,
 244                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 245                        Symbol::max_length(),
 246                        name);
 247     return NULL;
 248   }
 249   // Callers should ensure that the name is never an illegal UTF8 string.
 250   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),
 251          &quot;Class name is not a valid utf8 string.&quot;);
 252 
 253   // Make a new symbol for the class name.
 254   return SymbolTable::new_symbol(name);
 255 }
 256 
 257 // Forwards to resolve_or_null
 258 
 259 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 260   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 261   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 262     // can return a null klass
 263     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 264   }
 265   return klass;
 266 }
 267 
 268 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 269                                                      bool throw_error,
 270                                                      Klass* klass, TRAPS) {
 271   if (HAS_PENDING_EXCEPTION) {
 272     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 273     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 274     // and if so convert it to a NoClassDefFoundError
 275     // And chain the original ClassNotFoundException
 276     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 277       ResourceMark rm(THREAD);
 278       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 279       Handle e(THREAD, PENDING_EXCEPTION);
 280       CLEAR_PENDING_EXCEPTION;
 281       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 282     } else {
 283       return NULL;
 284     }
 285   }
 286   // Class not found, throw appropriate error or exception depending on value of throw_error
 287   if (klass == NULL) {
 288     ResourceMark rm(THREAD);
 289     if (throw_error) {
 290       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 291     } else {
 292       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 293     }
 294   }
 295   return klass;
 296 }
 297 
 298 
 299 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 300                                            bool throw_error, TRAPS)
 301 {
 302   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 303 }
 304 
 305 
 306 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 307 
 308 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 309   if (Signature::is_array(class_name)) {
 310     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 311   } else {
 312     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 313   }
 314 }
 315 
 316 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 317 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 318                                                                        Handle class_loader,
 319                                                                        Handle protection_domain,
 320                                                                        TRAPS) {
 321   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 322   if (Signature::has_envelope(class_name)) {
 323     ResourceMark rm(THREAD);
 324     // Ignore wrapping L and ;.
 325     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 326                                                  class_name-&gt;utf8_length() - 2);
 327     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 328   } else {
 329     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 330   }
 331 }
 332 
 333 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 334   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 335 }
 336 
 337 // Forwards to resolve_instance_class_or_null
 338 
 339 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 340                                                      Handle class_loader,
 341                                                      Handle protection_domain,
 342                                                      TRAPS) {
 343   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 344   ResourceMark rm(THREAD);
 345   SignatureStream ss(class_name, false);
 346   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 347   Klass* k = NULL;
 348   BasicType t = ss.type();
 349   if (ss.has_envelope()) {
 350     Symbol* obj_class = ss.as_symbol();
 351     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 352                                                          class_loader,
 353                                                          protection_domain,
 354                                                          CHECK_NULL);
 355     if (k != NULL) {
 356       k = k-&gt;array_klass(ndims, CHECK_NULL);
 357     }
 358   } else {
 359     k = Universe::typeArrayKlassObj(t);
 360     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 361   }
 362   return k;
 363 }
 364 
 365 
 366 // Must be called for any super-class or super-interface resolution
 367 // during class definition to allow class circularity checking
 368 // super-interface callers:
 369 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 370 // super-class callers:
 371 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 372 //   load_shared_class - while loading a class from shared archive
 373 //   resolve_instance_class_or_null:
 374 //     via: handle_parallel_super_load
 375 //      when resolving a class that has an existing placeholder with
 376 //      a saved superclass [i.e. a defineClass is currently in progress]
 377 //      if another thread is trying to resolve the class, it must do
 378 //      super-class checks on its own thread to catch class circularity
 379 // This last call is critical in class circularity checking for cases
 380 // where classloading is delegated to different threads and the
 381 // classloader lock is released.
 382 // Take the case: Base-&gt;Super-&gt;Base
 383 //   1. If thread T1 tries to do a defineClass of class Base
 384 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 385 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 386 //    so it tries to load Super
 387 //   3. If we load the class internally, or user classloader uses same thread
 388 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 389 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 390 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 391 //      3.4 calls resolve_super_or_fail Base
 392 //      3.5 finds T1,Base -&gt; throws class circularity
 393 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 394 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 395 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 396 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 397 //      4.4 finds T2, Super -&gt; throws class circularity
 398 // Must be called, even if superclass is null, since this is
 399 // where the placeholder entry is created which claims this
 400 // thread is loading this class/classloader.
 401 // Be careful when modifying this code: once you have run
 402 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 403 // you need to find_and_remove it before returning.
 404 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 405 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 406                                                        Symbol* super_name,
 407                                                        Handle class_loader,
 408                                                        Handle protection_domain,
 409                                                        bool is_superclass,
 410                                                        TRAPS) {
 411   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 412 #if INCLUDE_CDS
 413   if (DumpSharedSpaces) {
 414     // Special processing for handling UNREGISTERED shared classes.
 415     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 416         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 417     if (k) {
 418       return k;
 419     }
 420   }
 421 #endif // INCLUDE_CDS
 422 
 423   // Double-check, if child class is already loaded, just return super-class,interface
 424   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 425   // dictionary.
 426   // Make sure there&#39;s a placeholder for the *child* before resolving.
 427   // Used as a claim that this thread is currently loading superclass/classloader
 428   // Used here for ClassCircularity checks and also for heap verification
 429   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 430   // Must check ClassCircularity before checking if super class is already loaded.
 431   //
 432   // We might not already have a placeholder if this child_name was
 433   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 434   // the name of the class might not be known until the stream is actually
 435   // parsed.
 436   // Bugs 4643874, 4715493
 437 
 438   ClassLoaderData* loader_data = class_loader_data(class_loader);
 439   Dictionary* dictionary = loader_data-&gt;dictionary();
 440   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 441   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 442   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 443   // can&#39;t throw error holding a lock
 444   bool child_already_loaded = false;
 445   bool throw_circularity_error = false;
 446   {
 447     MutexLocker mu(THREAD, SystemDictionary_lock);
 448     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 449     InstanceKlass* quicksuperk;
 450     // to support // loading: if child done loading, just return superclass
 451     // if super_name, &amp; class_loader don&#39;t match:
 452     // if initial define, SD update will give LinkageError
 453     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 454     // so we don&#39;t throw an exception here.
 455     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 456     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 457         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 458          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 459             (quicksuperk-&gt;class_loader() == class_loader()))) {
 460            return quicksuperk;
 461     } else {
 462       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 463       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 464           throw_circularity_error = true;
 465       }
 466     }
 467     if (!throw_circularity_error) {
 468       // Be careful not to exit resolve_super
 469       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 470     }
 471   }
 472   if (throw_circularity_error) {
 473       ResourceMark rm(THREAD);
 474       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 475   }
 476 
 477 // java.lang.Object should have been found above
 478   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 479   // Resolve the super class or interface, check results on return
 480   InstanceKlass* superk =
 481     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 482                                                             class_loader,
 483                                                             protection_domain,
 484                                                             THREAD);
 485 
 486   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 487   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 488   // or error. GC used to walk the placeholder table as strong roots.
 489   // The instanceKlass is kept alive because the class loader is on the stack,
 490   // which keeps the loader_data alive, as well as all instanceKlasses in
 491   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 492   {
 493     MutexLocker mu(THREAD, SystemDictionary_lock);
 494     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 495     SystemDictionary_lock-&gt;notify_all();
 496   }
 497   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 498     // can null superk
 499     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 500     assert(k == NULL || k == superk, &quot;must be&quot;);
 501     if (k == NULL) {
 502       superk = NULL;
 503     }
 504   }
 505 
 506   return superk;
 507 }
 508 
 509 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 510                                                   Handle class_loader,
 511                                                   Handle protection_domain,
 512                                                   TRAPS) {
 513   // Now we have to call back to java to check if the initating class has access
 514   JavaValue result(T_VOID);
 515   LogTarget(Debug, protectiondomain) lt;
 516   if (lt.is_enabled()) {
 517     ResourceMark rm(THREAD);
 518     // Print out trace information
 519     LogStream ls(lt);
 520     ls.print_cr(&quot;Checking package access&quot;);
 521     if (class_loader() != NULL) {
 522       ls.print(&quot;class loader: &quot;);
 523       class_loader()-&gt;print_value_on(&amp;ls);
 524     } else {
 525       ls.print_cr(&quot;class loader: NULL&quot;);
 526     }
 527     if (protection_domain() != NULL) {
 528       ls.print(&quot; protection domain: &quot;);
 529       protection_domain()-&gt;print_value_on(&amp;ls);
 530     } else {
 531       ls.print_cr(&quot; protection domain: NULL&quot;);
 532     }
 533     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 534     ls.cr();
 535   }
 536 
 537   // This handle and the class_loader handle passed in keeps this class from
 538   // being unloaded through several GC points.
 539   // The class_loader handle passed in is the initiating loader.
 540   Handle mirror(THREAD, klass-&gt;java_mirror());
 541 
 542   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 543   JavaCalls::call_special(&amp;result,
 544                          class_loader,
 545                          system_loader,
 546                          vmSymbols::checkPackageAccess_name(),
 547                          vmSymbols::class_protectiondomain_signature(),
 548                          mirror,
 549                          protection_domain,
 550                          THREAD);
 551 
 552   if (HAS_PENDING_EXCEPTION) {
 553     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 554   } else {
 555    log_debug(protectiondomain)(&quot;granted&quot;);
 556   }
 557 
 558   if (HAS_PENDING_EXCEPTION) return;
 559 
 560   // If no exception has been thrown, we have validated the protection domain
 561   // Insert the protection domain of the initiating class into the set.
 562   {
 563     ClassLoaderData* loader_data = class_loader_data(class_loader);
 564     Dictionary* dictionary = loader_data-&gt;dictionary();
 565 
 566     Symbol*  kn = klass-&gt;name();
 567     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 568 
 569     MutexLocker mu(THREAD, SystemDictionary_lock);
 570     int d_index = dictionary-&gt;hash_to_index(d_hash);
 571     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 572                                       protection_domain, THREAD);
 573   }
 574 }
 575 
 576 // We only get here if this thread finds that another thread
 577 // has already claimed the placeholder token for the current operation,
 578 // but that other thread either never owned or gave up the
 579 // object lock
 580 // Waits on SystemDictionary_lock to indicate placeholder table updated
 581 // On return, caller must recheck placeholder table state
 582 //
 583 // We only get here if
 584 //  1) custom classLoader, i.e. not bootstrap classloader
 585 //  2) custom classLoader has broken the class loader objectLock
 586 //     so another thread got here in parallel
 587 //
 588 // lockObject must be held.
 589 // Complicated dance due to lock ordering:
 590 // Must first release the classloader object lock to
 591 // allow initial definer to complete the class definition
 592 // and to avoid deadlock
 593 // Reclaim classloader lock object with same original recursion count
 594 // Must release SystemDictionary_lock after notify, since
 595 // class loader lock must be claimed before SystemDictionary_lock
 596 // to prevent deadlocks
 597 //
 598 // The notify allows applications that did an untimed wait() on
 599 // the classloader object lock to not hang.
 600 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 601   assert_lock_strong(SystemDictionary_lock);
 602 
 603   bool calledholdinglock
 604       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 605   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 606   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 607   ObjectSynchronizer::notifyall(lockObject, THREAD);
 608   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 609   SystemDictionary_lock-&gt;wait();
 610   SystemDictionary_lock-&gt;unlock();
 611   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 612   SystemDictionary_lock-&gt;lock();
 613 }
 614 
 615 // If the class in is in the placeholder table, class loading is in progress
 616 // For cases where the application changes threads to load classes, it
 617 // is critical to ClassCircularity detection that we try loading
 618 // the superclass on the same thread internally, so we do parallel
 619 // super class loading here.
 620 // This also is critical in cases where the original thread gets stalled
 621 // even in non-circularity situations.
 622 // Note: must call resolve_super_or_fail even if null super -
 623 // to force placeholder entry creation for this class for circularity detection
 624 // Caller must check for pending exception
 625 // Returns non-null Klass* if other thread has completed load
 626 // and we are done,
 627 // If return null Klass* and no pending exception, the caller must load the class
 628 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 629     Symbol* name, Symbol* superclassname, Handle class_loader,
 630     Handle protection_domain, Handle lockObject, TRAPS) {
 631 
 632   ClassLoaderData* loader_data = class_loader_data(class_loader);
 633   Dictionary* dictionary = loader_data-&gt;dictionary();
 634   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 635   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 636   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 637 
 638   // superk is not used, resolve_super called for circularity check only
 639   // This code is reached in two situations. One if this thread
 640   // is loading the same class twice (e.g. ClassCircularity, or
 641   // java.lang.instrument).
 642   // The second is if another thread started the resolve_super first
 643   // and has not yet finished.
 644   // In both cases the original caller will clean up the placeholder
 645   // entry on error.
 646   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 647                                                           superclassname,
 648                                                           class_loader,
 649                                                           protection_domain,
 650                                                           true,
 651                                                           CHECK_NULL);
 652 
 653   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 654   // Serial class loaders and bootstrap classloader do wait for superclass loads
 655  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 656     MutexLocker mu(THREAD, SystemDictionary_lock);
 657     // Check if classloading completed while we were loading superclass or waiting
 658     return find_class(d_hash, name, dictionary);
 659   }
 660 
 661   // must loop to both handle other placeholder updates
 662   // and spurious notifications
 663   bool super_load_in_progress = true;
 664   PlaceholderEntry* placeholder;
 665   while (super_load_in_progress) {
 666     MutexLocker mu(THREAD, SystemDictionary_lock);
 667     // Check if classloading completed while we were loading superclass or waiting
 668     InstanceKlass* check = find_class(d_hash, name, dictionary);
 669     if (check != NULL) {
 670       // Klass is already loaded, so just return it
 671       return check;
 672     } else {
 673       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 674       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 675         // We only get here if the application has released the
 676         // classloader lock when another thread was in the middle of loading a
 677         // superclass/superinterface for this class, and now
 678         // this thread is also trying to load this class.
 679         // To minimize surprises, the first thread that started to
 680         // load a class should be the one to complete the loading
 681         // with the classfile it initially expected.
 682         // This logic has the current thread wait once it has done
 683         // all the superclass/superinterface loading it can, until
 684         // the original thread completes the class loading or fails
 685         // If it completes we will use the resulting InstanceKlass
 686         // which we will find below in the systemDictionary.
 687         // We also get here for parallel bootstrap classloader
 688         if (class_loader.is_null()) {
 689           SystemDictionary_lock-&gt;wait();
 690         } else {
 691           double_lock_wait(lockObject, THREAD);
 692         }
 693       } else {
 694         // If not in SD and not in PH, other thread&#39;s load must have failed
 695         super_load_in_progress = false;
 696       }
 697     }
 698   }
 699   return NULL;
 700 }
 701 
 702 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 703   assert(event != NULL, &quot;invariant&quot;);
 704   assert(k != NULL, &quot;invariant&quot;);
 705   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 706   event-&gt;set_loadedClass(k);
 707   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 708   event-&gt;set_initiatingClassLoader(init_cld);
 709   event-&gt;commit();
 710 }
 711 
 712 
 713 // Be careful when modifying this code: once you have run
 714 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 715 // you need to find_and_remove it before returning.
 716 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 717 //
 718 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 719 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 720                                                                 Handle class_loader,
 721                                                                 Handle protection_domain,
 722                                                                 TRAPS) {
 723   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 724          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 725 
 726   EventClassLoad class_load_start_event;
 727 
 728   HandleMark hm(THREAD);
 729 
 730   // Fix for 4474172; see evaluation for more details
 731   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 732   ClassLoaderData* loader_data = register_loader(class_loader);
 733   Dictionary* dictionary = loader_data-&gt;dictionary();
 734   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 735 
 736   // Do lookup to see if class already exist and the protection domain
 737   // has the right access
 738   // This call uses find which checks protection domain already matches
 739   // All subsequent calls use find_class, and set has_loaded_class so that
 740   // before we return a result we call out to java to check for valid protection domain
 741   // to allow returning the Klass* and add it to the pd_set if it is valid
 742   {
 743     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 744     if (probe != NULL) return probe;
 745   }
 746 
 747   // Non-bootstrap class loaders will call out to class loader and
 748   // define via jvm/jni_DefineClass which will acquire the
 749   // class loader object lock to protect against multiple threads
 750   // defining the class in parallel by accident.
 751   // This lock must be acquired here so the waiter will find
 752   // any successful result in the SystemDictionary and not attempt
 753   // the define.
 754   // ParallelCapable Classloaders and the bootstrap classloader
 755   // do not acquire lock here.
 756   bool DoObjectLock = true;
 757   if (is_parallelCapable(class_loader)) {
 758     DoObjectLock = false;
 759   }
 760 
 761   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 762   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 763 
 764   // Class is not in SystemDictionary so we have to do loading.
 765   // Make sure we are synchronized on the class loader before we proceed
 766   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 767   check_loader_lock_contention(lockObject, THREAD);
 768   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 769 
 770   // Check again (after locking) if class already exist in SystemDictionary
 771   bool class_has_been_loaded   = false;
 772   bool super_load_in_progress  = false;
 773   bool havesupername = false;
 774   InstanceKlass* k = NULL;
 775   PlaceholderEntry* placeholder;
 776   Symbol* superclassname = NULL;
 777 
 778   assert(THREAD-&gt;can_call_java(),
 779          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 780          name-&gt;as_C_string(),
 781          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 782   {
 783     MutexLocker mu(THREAD, SystemDictionary_lock);
 784     InstanceKlass* check = find_class(d_hash, name, dictionary);
 785     if (check != NULL) {
 786       // InstanceKlass is already loaded, so just return it
 787       class_has_been_loaded = true;
 788       k = check;
 789     } else {
 790       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 791       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 792          super_load_in_progress = true;
 793          if (placeholder-&gt;havesupername() == true) {
 794            superclassname = placeholder-&gt;supername();
 795            havesupername = true;
 796          }
 797       }
 798     }
 799   }
 800 
 801   // If the class is in the placeholder table, class loading is in progress
 802   if (super_load_in_progress &amp;&amp; havesupername==true) {
 803     k = handle_parallel_super_load(name,
 804                                    superclassname,
 805                                    class_loader,
 806                                    protection_domain,
 807                                    lockObject, THREAD);
 808     if (HAS_PENDING_EXCEPTION) {
 809       return NULL;
 810     }
 811     if (k != NULL) {
 812       class_has_been_loaded = true;
 813     }
 814   }
 815 
 816   bool throw_circularity_error = false;
 817   if (!class_has_been_loaded) {
 818     bool load_instance_added = false;
 819 
 820     // add placeholder entry to record loading instance class
 821     // Five cases:
 822     // All cases need to prevent modifying bootclasssearchpath
 823     // in parallel with a classload of same classname
 824     // Redefineclasses uses existence of the placeholder for the duration
 825     // of the class load to prevent concurrent redefinition of not completely
 826     // defined classes.
 827     // case 1. traditional classloaders that rely on the classloader object lock
 828     //   - no other need for LOAD_INSTANCE
 829     // case 2. traditional classloaders that break the classloader object lock
 830     //    as a deadlock workaround. Detection of this case requires that
 831     //    this check is done while holding the classloader object lock,
 832     //    and that lock is still held when calling classloader&#39;s loadClass.
 833     //    For these classloaders, we ensure that the first requestor
 834     //    completes the load and other requestors wait for completion.
 835     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 836     //    This classloader supports parallelism at the classloader level,
 837     //    but only allows a single load of a class/classloader pair.
 838     //    No performance benefit and no deadlock issues.
 839     // case 4. parallelCapable user level classloaders - without objectLocker
 840     //    Allow parallel classloading of a class/classloader pair
 841 
 842     {
 843       MutexLocker mu(THREAD, SystemDictionary_lock);
 844       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 845         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 846         if (oldprobe) {
 847           // only need check_seen_thread once, not on each loop
 848           // 6341374 java/lang/Instrument with -Xcomp
 849           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 850             throw_circularity_error = true;
 851           } else {
 852             // case 1: traditional: should never see load_in_progress.
 853             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 854 
 855               // case 3: bootstrap classloader: prevent futile classloading,
 856               // wait on first requestor
 857               if (class_loader.is_null()) {
 858                 SystemDictionary_lock-&gt;wait();
 859               } else {
 860               // case 2: traditional with broken classloader lock. wait on first
 861               // requestor.
 862                 double_lock_wait(lockObject, THREAD);
 863               }
 864               // Check if classloading completed while we were waiting
 865               InstanceKlass* check = find_class(d_hash, name, dictionary);
 866               if (check != NULL) {
 867                 // Klass is already loaded, so just return it
 868                 k = check;
 869                 class_has_been_loaded = true;
 870               }
 871               // check if other thread failed to load and cleaned up
 872               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 873             }
 874           }
 875         }
 876       }
 877       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 878       // case 4: parallelCapable: allow competing threads to try
 879       // LOAD_INSTANCE in parallel
 880 
 881       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 882         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 883         load_instance_added = true;
 884         // For class loaders that do not acquire the classloader object lock,
 885         // if they did not catch another thread holding LOAD_INSTANCE,
 886         // need a check analogous to the acquire ObjectLocker/find_class
 887         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 888         // one final check if the load has already completed
 889         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 890         InstanceKlass* check = find_class(d_hash, name, dictionary);
 891         if (check != NULL) {
 892           // Klass is already loaded, so return it after checking/adding protection domain
 893           k = check;
 894           class_has_been_loaded = true;
 895         }
 896       }
 897     }
 898 
 899     // must throw error outside of owning lock
 900     if (throw_circularity_error) {
 901       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 902       ResourceMark rm(THREAD);
 903       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 904     }
 905 
 906     if (!class_has_been_loaded) {
 907 
 908       // Do actual loading
 909       k = load_instance_class(name, class_loader, THREAD);
 910 
 911       // If everything was OK (no exceptions, no null return value), and
 912       // class_loader is NOT the defining loader, do a little more bookkeeping.
 913       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 914         k-&gt;class_loader() != class_loader()) {
 915 
 916         check_constraints(d_hash, k, class_loader, false, THREAD);
 917 
 918         // Need to check for a PENDING_EXCEPTION again; check_constraints
 919         // can throw but we may have to remove entry from the placeholder table below.
 920         if (!HAS_PENDING_EXCEPTION) {
 921           // Record dependency for non-parent delegation.
 922           // This recording keeps the defining class loader of the klass (k) found
 923           // from being unloaded while the initiating class loader is loaded
 924           // even if the reference to the defining class loader is dropped
 925           // before references to the initiating class loader.
 926           loader_data-&gt;record_dependency(k);
 927 
 928           { // Grabbing the Compile_lock prevents systemDictionary updates
 929             // during compilations.
 930             MutexLocker mu(THREAD, Compile_lock);
 931             update_dictionary(d_hash, p_index, p_hash,
 932               k, class_loader, THREAD);
 933           }
 934 
 935           if (JvmtiExport::should_post_class_load()) {
 936             Thread *thread = THREAD;
 937             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 938             JvmtiExport::post_class_load((JavaThread *) thread, k);
 939           }
 940         }
 941       }
 942     } // load_instance_class
 943 
 944     if (load_instance_added == true) {
 945       // clean up placeholder entries for LOAD_INSTANCE success or error
 946       // This brackets the SystemDictionary updates for both defining
 947       // and initiating loaders
 948       MutexLocker mu(THREAD, SystemDictionary_lock);
 949       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 950       SystemDictionary_lock-&gt;notify_all();
 951     }
 952   }
 953 
 954   if (HAS_PENDING_EXCEPTION || k == NULL) {
 955     return NULL;
 956   }
 957   if (class_load_start_event.should_commit()) {
 958     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 959   }
 960 #ifdef ASSERT
 961   {
 962     ClassLoaderData* loader_data = k-&gt;class_loader_data();
 963     MutexLocker mu(THREAD, SystemDictionary_lock);
 964     InstanceKlass* kk = find_class(name, loader_data);
 965     assert(kk == k, &quot;should be present in dictionary&quot;);
 966   }
 967 #endif
 968 
 969   // return if the protection domain in NULL
 970   if (protection_domain() == NULL) return k;
 971 
 972   // Check the protection domain has the right access
 973   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 974                                              protection_domain)) {
 975     return k;
 976   }
 977 
 978   // Verify protection domain. If it fails an exception is thrown
 979   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
 980 
 981   return k;
 982 }
 983 
 984 
 985 // This routine does not lock the system dictionary.
 986 //
 987 // Since readers don&#39;t hold a lock, we must make sure that system
 988 // dictionary entries are only removed at a safepoint (when only one
 989 // thread is running), and are added to in a safe way (all links must
 990 // be updated in an MT-safe manner).
 991 //
 992 // Callers should be aware that an entry could be added just after
 993 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
 994 // the new entry.
 995 
 996 Klass* SystemDictionary::find(Symbol* class_name,
 997                               Handle class_loader,
 998                               Handle protection_domain,
 999                               TRAPS) {
1000 
1001   // The result of this call should be consistent with the result
1002   // of the call to resolve_instance_class_or_null().
1003   // See evaluation 6790209 and 4474172 for more details.
1004   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1005   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
1006 
1007   if (loader_data == NULL) {
1008     // If the ClassLoaderData has not been setup,
1009     // then the class loader has no entries in the dictionary.
1010     return NULL;
1011   }
1012 
1013   Dictionary* dictionary = loader_data-&gt;dictionary();
1014   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1015   return dictionary-&gt;find(d_hash, class_name,
1016                           protection_domain);
1017 }
1018 
1019 
1020 // Look for a loaded instance or array klass by name.  Do not do any loading.
1021 // return NULL in case of error.
1022 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1023                                                       Handle class_loader,
1024                                                       Handle protection_domain,
1025                                                       TRAPS) {
1026   Klass* k = NULL;
1027   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1028 
1029   if (Signature::is_array(class_name)) {
1030     // The name refers to an array.  Parse the name.
1031     // dimension and object_key in FieldArrayInfo are assigned as a
1032     // side-effect of this call
1033     SignatureStream ss(class_name, false);
1034     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1035     BasicType t = ss.type();
1036     if (t != T_OBJECT) {
1037       k = Universe::typeArrayKlassObj(t);
1038     } else {
1039       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1040     }
1041     if (k != NULL) {
1042       k = k-&gt;array_klass_or_null(ndims);
1043     }
1044   } else {
1045     k = find(class_name, class_loader, protection_domain, THREAD);
1046   }
1047   return k;
1048 }
1049 
1050 // Note: this method is much like resolve_from_stream, but
1051 // does not publish the classes via the SystemDictionary.
1052 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1053 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1054 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1055                                               Handle class_loader,
1056                                               ClassFileStream* st,
1057                                               const ClassLoadInfo&amp; cl_info,
1058                                               TRAPS) {
1059 
1060   EventClassLoad class_load_start_event;
1061   ClassLoaderData* loader_data;
1062   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1063 
1064   // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1065   //                               the same class loader as the unsafe_anonymous_host.
1066   // - for hidden classes that are not strong: create a new CLD that has a class holder and
1067   //                                           whose loader is the Lookup class&#39;s loader.
1068   // - for hidden class: add the class to the Lookup class&#39;s loader&#39;s CLD.
1069   if (is_unsafe_anon_class || cl_info.is_hidden()) {
1070     guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1071               &quot;should be NULL or the same&quot;);
1072     bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();
1073     loader_data = register_loader(class_loader, create_mirror_cld);
1074   } else {
1075     loader_data = ClassLoaderData::class_loader_data(class_loader());
1076   }
1077 
1078   assert(st != NULL, &quot;invariant&quot;);
1079   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1080 
1081   // Parse stream and create a klass.
1082   // Note that we do this even though this klass might
1083   // already be present in the SystemDictionary, otherwise we would not
1084   // throw potential ClassFormatErrors.
1085 
1086   InstanceKlass* k = KlassFactory::create_from_stream(st,
1087                                                       class_name,
1088                                                       loader_data,
1089                                                       cl_info,
1090                                                       CHECK_NULL);
1091 
1092   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1093     // Hidden classes that are not strong and unsafe anonymous classes must update
1094     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1095     // longer referenced.
1096     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1097       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1098     }
1099 
1100     {
1101       MutexLocker mu_r(THREAD, Compile_lock);
1102 
1103       // Add to class hierarchy, initialize vtables, and do possible
1104       // deoptimizations.
1105       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1106       // But, do not add to dictionary.
1107     }
1108 
1109     // Rewrite and patch constant pool here.
1110     k-&gt;link_class(CHECK_NULL);
1111     if (cl_info.cp_patches() != NULL) {
1112       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1113     }
1114 
1115     // If it&#39;s anonymous, initialize it now, since nobody else will.
1116     if (is_unsafe_anon_class) {
1117       k-&gt;eager_initialize(CHECK_NULL);
1118     }
1119 
1120     // notify jvmti
1121     if (JvmtiExport::should_post_class_load()) {
1122         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1123         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1124     }
1125     if (class_load_start_event.should_commit()) {
1126       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1127     }
1128   }
1129   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1130          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1131 
1132   return k;
1133 }
1134 
1135 // Add a klass to the system from a stream (called by jni_DefineClass and
1136 // JVM_DefineClass).
1137 // Note: class_name can be NULL. In that case we do not know the name of
1138 // the class until we have parsed the stream.
1139 
1140 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1141                                                      Handle class_loader,
1142                                                      Handle protection_domain,
1143                                                      ClassFileStream* st,
1144                                                      TRAPS) {
1145 
1146   HandleMark hm(THREAD);
1147 
1148   // Classloaders that support parallelism, e.g. bootstrap classloader,
1149   // do not acquire lock here
1150   bool DoObjectLock = true;
1151   if (is_parallelCapable(class_loader)) {
1152     DoObjectLock = false;
1153   }
1154 
1155   ClassLoaderData* loader_data = register_loader(class_loader);
1156 
1157   // Make sure we are synchronized on the class loader before we proceed
1158   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1159   check_loader_lock_contention(lockObject, THREAD);
1160   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1161 
1162   assert(st != NULL, &quot;invariant&quot;);
1163 
1164   // Parse the stream and create a klass.
1165   // Note that we do this even though this klass might
1166   // already be present in the SystemDictionary, otherwise we would not
1167   // throw potential ClassFormatErrors.
1168  InstanceKlass* k = NULL;
1169 
1170 #if INCLUDE_CDS
1171   if (!DumpSharedSpaces) {
1172     k = SystemDictionaryShared::lookup_from_stream(class_name,
1173                                                    class_loader,
1174                                                    protection_domain,
1175                                                    st,
1176                                                    CHECK_NULL);
1177   }
1178 #endif
1179 
1180   if (k == NULL) {
1181     if (st-&gt;buffer() == NULL) {
1182       return NULL;
1183     }
1184     ClassLoadInfo cl_info(protection_domain);
1185     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1186   }
1187 
1188   assert(k != NULL, &quot;no klass created&quot;);
1189   Symbol* h_name = k-&gt;name();
1190   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1191 
1192   // Add class just loaded
1193   // If a class loader supports parallel classloading handle parallel define requests
1194   // find_or_define_instance_class may return a different InstanceKlass
1195   if (is_parallelCapable(class_loader)) {
1196     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1197     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1198       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1199       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1200       loader_data-&gt;add_to_deallocate_list(k);
1201       k = defined_k;
1202     }
1203   } else {
1204     define_instance_class(k, THREAD);
1205   }
1206 
1207   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1208   if (HAS_PENDING_EXCEPTION) {
1209     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1210     loader_data-&gt;add_to_deallocate_list(k);
1211     return NULL;
1212   }
1213 
1214   // Make sure we have an entry in the SystemDictionary on success
1215   debug_only( {
1216     MutexLocker mu(THREAD, SystemDictionary_lock);
1217 
1218     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1219     assert(check == k, &quot;should be present in the dictionary&quot;);
1220   } );
1221 
1222   return k;
1223 }
1224 
1225 #if INCLUDE_CDS
1226 // Load a class for boot loader from the shared spaces. This also
1227 // forces the super class and all interfaces to be loaded.
1228 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1229                                                         PackageEntry* pkg_entry,
1230                                                         TRAPS) {
1231   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1232   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1233     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1234   }
1235   return NULL;
1236 }
1237 
1238 // Check if a shared class can be loaded by the specific classloader:
1239 //
1240 // NULL classloader:
1241 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1242 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1243 //     be defined in an unnamed module.
1244 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1245                                                InstanceKlass* ik,
1246                                                PackageEntry* pkg_entry,
1247                                                Handle class_loader, TRAPS) {
1248   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1249          &quot;Cannot use sharing if java.base is patched&quot;);
1250   ResourceMark rm(THREAD);
1251   int path_index = ik-&gt;shared_classpath_index();
1252   ClassLoaderData* loader_data = class_loader_data(class_loader);
1253   if (path_index &lt; 0) {
1254     // path_index &lt; 0 indicates that the class is intended for a custom loader
1255     // and should not be loaded by boot/platform/app loaders
1256     if (loader_data-&gt;is_builtin_class_loader_data()) {
1257       return false;
1258     } else {
1259       return true;
1260     }
1261   }
1262   SharedClassPathEntry* ent =
1263             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1264   if (!Universe::is_module_initialized()) {
1265     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1266            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1267     assert(class_loader.is_null(), &quot;sanity&quot;);
1268     return true;
1269   }
1270   // Get the pkg_entry from the classloader
1271   ModuleEntry* mod_entry = NULL;
1272   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :
1273                                                ClassLoader::package_from_class_name(class_name);
1274   if (pkg_name != NULL) {
1275     if (loader_data != NULL) {
1276       if (pkg_entry != NULL) {
1277         mod_entry = pkg_entry-&gt;module();
1278         // If the archived class is from a module that has been patched at runtime,
1279         // the class cannot be loaded from the archive.
1280         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1281           return false;
1282         }
1283       }
1284     }
1285   }
1286 
1287   if (class_loader.is_null()) {
1288     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1289     // The NULL classloader can load archived class originated from the
1290     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1291     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1292     // by the NULL classloader.
1293     if (mod_entry != NULL) {
1294       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1295       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1296       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1297         return true; // Module class from the &quot;module&quot; jimage
1298       }
1299     }
1300 
1301     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1302     // loaded by the NULL classloader if
1303     //
1304     // 1. the class is from the unamed package
1305     // 2. or, the class is not from a module defined in the NULL classloader
1306     // 3. or, the class is from an unamed module
1307     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1308       // the class is from the -Xbootclasspath/a
1309       if (pkg_name == NULL ||
1310           pkg_entry == NULL ||
1311           pkg_entry-&gt;in_unnamed_module()) {
1312         assert(mod_entry == NULL ||
1313                mod_entry == loader_data-&gt;unnamed_module(),
1314                &quot;the unnamed module is not defined in the classloader&quot;);
1315         return true;
1316       }
1317     }
1318     return false;
1319   } else {
1320     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1321               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1322     return res;
1323   }
1324 }
1325 
1326 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1327                                                      Handle class_loader,  Handle protection_domain,
1328                                                      bool is_superclass, TRAPS) {
1329   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1330 
1331   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1332                                        class_loader, protection_domain, is_superclass, CHECK_0);
1333   if (found == super_type) {
1334     return true;
1335   } else {
1336     // The dynamically resolved super type is not the same as the one we used during dump time,
1337     // so we cannot use the child class.
1338     return false;
1339   }
1340 }
1341 
1342 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1343                                                       Handle protection_domain, TRAPS) {
1344   // Check the superclass and interfaces. They must be the same
1345   // as in dump time, because the layout of &lt;ik&gt; depends on
1346   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1347   //
1348   // If unexpected superclass or interfaces are found, we cannot
1349   // load &lt;ik&gt; from the shared archive.
1350 
1351   if (ik-&gt;super() != NULL &amp;&amp;
1352       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1353                                      class_loader, protection_domain, true, THREAD)) {
1354     return false;
1355   }
1356 
1357   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1358   int num_interfaces = interfaces-&gt;length();
1359   for (int index = 0; index &lt; num_interfaces; index++) {
1360     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1361       return false;
1362     }
1363   }
1364 
1365   return true;
1366 }
1367 
1368 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1369                                                    Handle class_loader,
1370                                                    Handle protection_domain,
1371                                                    const ClassFileStream *cfs,
1372                                                    PackageEntry* pkg_entry,
1373                                                    TRAPS) {
1374   assert(ik != NULL, &quot;sanity&quot;);
1375   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1376   Symbol* class_name = ik-&gt;name();
1377 
1378   bool visible = is_shared_class_visible(
1379                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1380   if (!visible) {
1381     return NULL;
1382   }
1383 
1384   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1385     return NULL;
1386   }
1387 
1388   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1389       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1390   if (new_ik != NULL) {
1391     // The class is changed by CFLH. Return the new class. The shared class is
1392     // not used.
1393     return new_ik;
1394   }
1395 
1396   // Adjust methods to recover missing data.  They need addresses for
1397   // interpreter entry points and their default native method address
1398   // must be reset.
1399 
1400   // Updating methods must be done under a lock so multiple
1401   // threads don&#39;t update these in parallel
1402   //
1403   // Shared classes are all currently loaded by either the bootstrap or
1404   // internal parallel class loaders, so this will never cause a deadlock
1405   // on a custom class loader lock.
1406 
1407   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1408   {
1409     HandleMark hm(THREAD);
1410     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1411     check_loader_lock_contention(lockObject, THREAD);
1412     ObjectLocker ol(lockObject, THREAD, true);
1413     // prohibited package check assumes all classes loaded from archive call
1414     // restore_unshareable_info which calls ik-&gt;set_package()
1415     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1416   }
1417 
1418   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1419   return ik;
1420 }
1421 
1422 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1423   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1424 
1425   // For boot loader, ensure that GetSystemPackage knows that a class in this
1426   // package was loaded.
1427   if (loader_data-&gt;is_the_null_class_loader_data()) {
1428     int path_index = ik-&gt;shared_classpath_index();
1429     ik-&gt;set_classpath_index(path_index, THREAD);
1430   }
1431 
1432   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1433     // Only dump the classes that can be stored into CDS archive
1434     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1435       ResourceMark rm(THREAD);
1436       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1437       classlist_file-&gt;flush();
1438     }
1439   }
1440 
1441   // notify a class loaded from shared object
1442   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1443 
1444   ik-&gt;set_has_passed_fingerprint_check(false);
1445   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1446     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1447     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1448     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1449       // This class matches with a class saved in an AOT library
1450       ik-&gt;set_has_passed_fingerprint_check(true);
1451     } else {
1452       if (log_is_enabled(Info, class, fingerprint)) {
1453         ResourceMark rm(THREAD);
1454         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1455       }
1456     }
1457   }
1458 }
1459 
1460 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1461   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1462   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1463   if (klass-&gt;class_loader_data() != NULL) {
1464     return;
1465   }
1466 
1467   // add super and interfaces first
1468   Klass* super = klass-&gt;super();
1469   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1470     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1471     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1472   }
1473 
1474   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1475   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1476     InstanceKlass* ik = ifs-&gt;at(i);
1477     if (ik-&gt;class_loader_data()  == NULL) {
1478       quick_resolve(ik, loader_data, domain, CHECK);
1479     }
1480   }
1481 
1482   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1483   load_shared_class_misc(klass, loader_data, CHECK);
1484   Dictionary* dictionary = loader_data-&gt;dictionary();
1485   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1486   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1487   add_to_hierarchy(klass, CHECK);
1488   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1489 }
1490 #endif // INCLUDE_CDS
1491 
1492 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1493 
1494   if (class_loader.is_null()) {
1495     ResourceMark rm(THREAD);
1496     PackageEntry* pkg_entry = NULL;
1497     bool search_only_bootloader_append = false;
1498     ClassLoaderData *loader_data = class_loader_data(class_loader);
1499 
1500     // Find the package in the boot loader&#39;s package entry table.
1501     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1502     if (pkg_name != NULL) {
1503       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1504     }
1505 
1506     // Prior to attempting to load the class, enforce the boot loader&#39;s
1507     // visibility boundaries.
1508     if (!Universe::is_module_initialized()) {
1509       // During bootstrapping, prior to module initialization, any
1510       // class attempting to be loaded must be checked against the
1511       // java.base packages in the boot loader&#39;s PackageEntryTable.
1512       // No class outside of java.base is allowed to be loaded during
1513       // this bootstrapping window.
1514       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1515         // Class is either in the unnamed package or in
1516         // a named package within the unnamed module.  Either
1517         // case is outside of java.base, do not attempt to
1518         // load the class post java.base definition.  If
1519         // java.base has not been defined, let the class load
1520         // and its package will be checked later by
1521         // ModuleEntryTable::verify_javabase_packages.
1522         if (ModuleEntryTable::javabase_defined()) {
1523           return NULL;
1524         }
1525       } else {
1526         // Check that the class&#39; package is defined within java.base.
1527         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1528         Symbol* mod_entry_name = mod_entry-&gt;name();
1529         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1530           return NULL;
1531         }
1532       }
1533     } else {
1534       // After the module system has been initialized, check if the class&#39;
1535       // package is in a module defined to the boot loader.
1536       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1537         // Class is either in the unnamed package, in a named package
1538         // within a module not defined to the boot loader or in a
1539         // a named package within the unnamed module.  In all cases,
1540         // limit visibility to search for the class only in the boot
1541         // loader&#39;s append path.
1542         if (!ClassLoader::has_bootclasspath_append()) {
1543            // If there is no bootclasspath append entry, no need to continue
1544            // searching.
1545            return NULL;
1546         }
1547         search_only_bootloader_append = true;
1548       }
1549     }
1550 
1551     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1552     // of the boot loader&#39;s module path
1553     assert(Universe::is_module_initialized() ||
1554            !search_only_bootloader_append,
1555            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1556 
1557     // Search for classes in the CDS archive.
1558     InstanceKlass* k = NULL;
1559     {
1560 #if INCLUDE_CDS
1561       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1562       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1563 #endif
1564     }
1565 
1566     if (k == NULL) {
1567       // Use VM class loader
1568       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1569       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1570     }
1571 
1572     // find_or_define_instance_class may return a different InstanceKlass
1573     if (k != NULL) {
1574       InstanceKlass* defined_k =
1575         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1576       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1577         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1578         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1579         loader_data-&gt;add_to_deallocate_list(k);
1580         k = defined_k;
1581       } else if (HAS_PENDING_EXCEPTION) {
1582         loader_data-&gt;add_to_deallocate_list(k);
1583         return NULL;
1584       }
1585     }
1586     return k;
1587   } else {
1588     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1589     ResourceMark rm(THREAD);
1590 
1591     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1592     JavaThread* jt = (JavaThread*) THREAD;
1593 
1594     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1595                                ClassLoader::perf_app_classload_selftime(),
1596                                ClassLoader::perf_app_classload_count(),
1597                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1598                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1599                                PerfClassTraceTime::CLASS_LOAD);
1600 
1601     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1602     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1603     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1604 
1605     JavaValue result(T_OBJECT);
1606 
1607     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1608 
1609     // Call public unsynchronized loadClass(String) directly for all class loaders.
1610     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1611     // acquire a class-name based lock rather than the class loader object lock.
1612     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1613     JavaCalls::call_virtual(&amp;result,
1614                             class_loader,
1615                             spec_klass,
1616                             vmSymbols::loadClass_name(),
1617                             vmSymbols::string_class_signature(),
1618                             string,
1619                             CHECK_NULL);
1620 
1621     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1622     oop obj = (oop) result.get_jobject();
1623 
1624     // Primitive classes return null since forName() can not be
1625     // used to obtain any of the Class objects representing primitives or void
1626     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1627       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1628       // For user defined Java class loaders, check that the name returned is
1629       // the same as that requested.  This check is done for the bootstrap
1630       // loader when parsing the class file.
1631       if (class_name == k-&gt;name()) {
1632         return k;
1633       }
1634     }
1635     // Class is not found or has the wrong name, return NULL
1636     return NULL;
1637   }
1638 }
1639 
1640 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1641   EventClassDefine event;
1642   if (event.should_commit()) {
1643     event.set_definedClass(k);
1644     event.set_definingClassLoader(def_cld);
1645     event.commit();
1646   }
1647 }
1648 
1649 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1650 
1651   HandleMark hm(THREAD);
1652   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1653   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1654 
1655  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1656  // use placeholder token
1657  // If a parallelCapable class loader calls define_instance_class instead of
1658  // find_or_define_instance_class to get here, we have a timing
1659  // hole with systemDictionary updates and check_constraints
1660  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1661     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1662          compute_loader_lock_object(class_loader_h, THREAD)),
1663          &quot;define called without lock&quot;);
1664   }
1665 
1666   // Check class-loading constraints. Throw exception if violation is detected.
1667   // Grabs and releases SystemDictionary_lock
1668   // The check_constraints/find_class call and update_dictionary sequence
1669   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1670   // define two different instanceKlasses for that class/classloader pair.
1671   // Existing classloaders will call define_instance_class with the
1672   // classloader lock held
1673   // Parallel classloaders will call find_or_define_instance_class
1674   // which will require a token to perform the define class
1675   Symbol*  name_h = k-&gt;name();
1676   Dictionary* dictionary = loader_data-&gt;dictionary();
1677   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1678   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1679 
1680   // Register class just loaded with class loader (placed in ArrayList)
1681   // Note we do this before updating the dictionary, as this can
1682   // fail with an OutOfMemoryError (if it does, we will *not* put this
1683   // class in the dictionary and will not update the class hierarchy).
1684   // JVMTI FollowReferences needs to find the classes this way.
1685   if (k-&gt;class_loader() != NULL) {
1686     methodHandle m(THREAD, Universe::loader_addClass_method());
1687     JavaValue result(T_VOID);
1688     JavaCallArguments args(class_loader_h);
1689     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1690     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1691   }
1692 
1693   // Add the new class. We need recompile lock during update of CHA.
1694   {
1695     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1696     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1697 
1698     MutexLocker mu_r(THREAD, Compile_lock);
1699 
1700     // Add to class hierarchy, initialize vtables, and do possible
1701     // deoptimizations.
1702     add_to_hierarchy(k, CHECK); // No exception, but can block
1703 
1704     // Add to systemDictionary - so other classes can see it.
1705     // Grabs and releases SystemDictionary_lock
1706     update_dictionary(d_hash, p_index, p_hash,
1707                       k, class_loader_h, THREAD);
1708   }
1709   k-&gt;eager_initialize(THREAD);
1710 
1711   // notify jvmti
1712   if (JvmtiExport::should_post_class_load()) {
1713       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1714       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1715 
1716   }
1717   post_class_define_event(k, loader_data);
1718 }
1719 
1720 // Support parallel classloading
1721 // All parallel class loaders, including bootstrap classloader
1722 // lock a placeholder entry for this class/class_loader pair
1723 // to allow parallel defines of different classes for this class loader
1724 // With AllowParallelDefine flag==true, in case they do not synchronize around
1725 // FindLoadedClass/DefineClass, calls, we check for parallel
1726 // loading for them, wait if a defineClass is in progress
1727 // and return the initial requestor&#39;s results
1728 // This flag does not apply to the bootstrap classloader.
1729 // With AllowParallelDefine flag==false, call through to define_instance_class
1730 // which will throw LinkageError: duplicate class definition.
1731 // False is the requested default.
1732 // For better performance, the class loaders should synchronize
1733 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1734 // potentially waste time reading and parsing the bytestream.
1735 // Note: VM callers should ensure consistency of k/class_name,class_loader
1736 // Be careful when modifying this code: once you have run
1737 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1738 // you need to find_and_remove it before returning.
1739 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1740 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1741                                                                InstanceKlass* k, TRAPS) {
1742 
1743   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1744   ClassLoaderData* loader_data = class_loader_data(class_loader);
1745   Dictionary* dictionary = loader_data-&gt;dictionary();
1746 
1747   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1748 
1749   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1750   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1751   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1752   PlaceholderEntry* probe;
1753 
1754   {
1755     MutexLocker mu(THREAD, SystemDictionary_lock);
1756     // First check if class already defined
1757     if (is_parallelDefine(class_loader)) {
1758       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1759       if (check != NULL) {
1760         return check;
1761       }
1762     }
1763 
1764     // Acquire define token for this class/classloader
1765     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1766     // Wait if another thread defining in parallel
1767     // All threads wait - even those that will throw duplicate class: otherwise
1768     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1769     // if other thread has not finished updating dictionary
1770     while (probe-&gt;definer() != NULL) {
1771       SystemDictionary_lock-&gt;wait();
1772     }
1773     // Only special cases allow parallel defines and can use other thread&#39;s results
1774     // Other cases fall through, and may run into duplicate defines
1775     // caught by finding an entry in the SystemDictionary
1776     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1777         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1778         SystemDictionary_lock-&gt;notify_all();
1779 #ifdef ASSERT
1780         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1781         assert(check != NULL, &quot;definer missed recording success&quot;);
1782 #endif
1783         return probe-&gt;instance_klass();
1784     } else {
1785       // This thread will define the class (even if earlier thread tried and had an error)
1786       probe-&gt;set_definer(THREAD);
1787     }
1788   }
1789 
1790   define_instance_class(k, THREAD);
1791 
1792   Handle linkage_exception = Handle(); // null handle
1793 
1794   // definer must notify any waiting threads
1795   {
1796     MutexLocker mu(THREAD, SystemDictionary_lock);
1797     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1798     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1799     if (probe != NULL) {
1800       if (HAS_PENDING_EXCEPTION) {
1801         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1802         CLEAR_PENDING_EXCEPTION;
1803       } else {
1804         probe-&gt;set_instance_klass(k);
1805       }
1806       probe-&gt;set_definer(NULL);
1807       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1808       SystemDictionary_lock-&gt;notify_all();
1809     }
1810   }
1811 
1812   // Can&#39;t throw exception while holding lock due to rank ordering
1813   if (linkage_exception() != NULL) {
1814     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1815   }
1816 
1817   return k;
1818 }
1819 
1820 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1821   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1822   if (class_loader.is_null()) {
1823     return Handle(THREAD, _system_loader_lock_obj);
1824   } else {
1825     return class_loader;
1826   }
1827 }
1828 
1829 // This method is added to check how often we have to wait to grab loader
1830 // lock. The results are being recorded in the performance counters defined in
1831 // ClassLoader::_sync_systemLoaderLockContentionRate and
1832 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1833 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1834   if (!UsePerfData) {
1835     return;
1836   }
1837 
1838   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1839 
1840   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1841       == ObjectSynchronizer::owner_other) {
1842     // contention will likely happen, so increment the corresponding
1843     // contention counter.
1844     if (loader_lock() == _system_loader_lock_obj) {
1845       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1846     } else {
1847       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1848     }
1849   }
1850 }
1851 
1852 // ----------------------------------------------------------------------------
1853 // Lookup
1854 
1855 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1856                                             Symbol* class_name,
1857                                             Dictionary* dictionary) {
1858   assert_locked_or_safepoint(SystemDictionary_lock);
1859   int index = dictionary-&gt;hash_to_index(hash);
1860   return dictionary-&gt;find_class(index, hash, class_name);
1861 }
1862 
1863 
1864 // Basic find on classes in the midst of being loaded
1865 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
1866                                            ClassLoaderData* loader_data) {
1867   assert_locked_or_safepoint(SystemDictionary_lock);
1868   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
1869   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1870   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
1871 }
1872 
1873 
1874 // Used for assertions and verification only
1875 // Precalculating the hash and index is an optimization because there are many lookups
1876 // before adding the class.
1877 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
1878   assert_locked_or_safepoint(SystemDictionary_lock);
1879   #ifndef ASSERT
1880   guarantee(VerifyBeforeGC      ||
1881             VerifyDuringGC      ||
1882             VerifyBeforeExit    ||
1883             VerifyDuringStartup ||
1884             VerifyAfterGC, &quot;too expensive&quot;);
1885   #endif
1886 
1887   Dictionary* dictionary = loader_data-&gt;dictionary();
1888   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1889   return find_class(d_hash, class_name, dictionary);
1890 }
1891 
1892 
1893 // ----------------------------------------------------------------------------
1894 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1895 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1896 // before a new class is used.
1897 
1898 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1899   assert(k != NULL, &quot;just checking&quot;);
1900   if (Universe::is_fully_initialized()) {
1901     assert_locked_or_safepoint(Compile_lock);
1902   }
1903 
1904   k-&gt;set_init_state(InstanceKlass::loaded);
1905   // make sure init_state store is already done.
1906   // The compiler reads the hierarchy outside of the Compile_lock.
1907   // Access ordering is used to add to hierarchy.
1908 
1909   // Link into hierachy.
1910   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1911   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1912 
1913   // Now flush all code that depended on old class hierarchy.
1914   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1915   if (Universe::is_fully_initialized()) {
1916     CodeCache::flush_dependents_on(k);
1917   }
1918 }
1919 
1920 // ----------------------------------------------------------------------------
1921 // GC support
1922 
1923 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1924 // Note: anonymous classes are not in the SD.
1925 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1926 
1927   bool unloading_occurred;
1928   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1929   {
1930     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1931     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1932     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1933     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1934     if (unloading_occurred) {
1935       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1936       JFR_ONLY(Jfr::on_unloading_classes();)
1937 
1938       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
1939       ClassLoaderDataGraph::clean_module_and_package_info();
1940       constraints()-&gt;purge_loader_constraints();
1941       resolution_errors()-&gt;purge_resolution_errors();
1942     }
1943   }
1944 
1945   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1946 
1947   if (unloading_occurred) {
1948     SymbolTable::trigger_cleanup();
1949 
1950     // Oops referenced by the protection domain cache table may get unreachable independently
1951     // of the class loader (eg. cached protection domain oops). So we need to
1952     // explicitly unlink them here.
1953     // All protection domain oops are linked to the caller class, so if nothing
1954     // unloads, this is not needed.
1955     _pd_cache_table-&gt;trigger_cleanup();
1956   }
1957 
1958   return unloading_occurred;
1959 }
1960 
1961 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {
1962   f-&gt;do_oop(&amp;_java_system_loader);
1963   f-&gt;do_oop(&amp;_java_platform_loader);
1964   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1965   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1966 
1967   // Visit extra methods
1968   invoke_method_table()-&gt;oops_do(f);
1969 
1970   if (include_handles) {
1971     OopStorageSet::vm_global()-&gt;oops_do(f);
1972   }
1973 }
1974 
1975 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
1976 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
1977   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
1978     it-&gt;push(well_known_klass_addr((WKID)id));
1979   }
1980 }
1981 
1982 void SystemDictionary::methods_do(void f(Method*)) {
1983   // Walk methods in loaded classes
1984   MutexLocker ml(ClassLoaderDataGraph_lock);
1985   ClassLoaderDataGraph::methods_do(f);
1986   // Walk method handle intrinsics
1987   invoke_method_table()-&gt;methods_do(f);
1988 }
1989 
1990 // ----------------------------------------------------------------------------
1991 // Initialization
1992 
1993 void SystemDictionary::initialize(TRAPS) {
1994   // Allocate arrays
1995   _placeholders        = new PlaceholderTable(_placeholder_table_size);
1996   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
1997   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
1998   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
1999   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2000 
2001   // Allocate private object used as system class loader lock
2002   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
2003   // Initialize basic classes
2004   resolve_well_known_classes(CHECK);
2005 }
2006 
2007 // Compact table of directions on the initialization of klasses:
2008 static const short wk_init_info[] = {
2009   #define WK_KLASS_INIT_INFO(name, symbol) \
2010     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2011 
2012   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2013   #undef WK_KLASS_INIT_INFO
2014   0
2015 };
2016 
2017 #ifdef ASSERT
2018 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2019   int sid;
2020   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2021     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2022     if (class_name == symbol) {
2023       return true;
2024     }
2025   }
2026   return false;
2027 }
2028 #endif
2029 
2030 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2031   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2032   int sid = wk_init_info[id - FIRST_WKID];
2033   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2034   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2035 
2036 #if INCLUDE_CDS
2037   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2038     InstanceKlass* k = *klassp;
2039     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2040 
2041     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2042     quick_resolve(k, loader_data, Handle(), CHECK_false);
2043     return true;
2044   }
2045 #endif // INCLUDE_CDS
2046 
2047   if (!is_wk_klass_loaded(*klassp)) {
2048     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2049     (*klassp) = InstanceKlass::cast(k);
2050   }
2051   return ((*klassp) != NULL);
2052 }
2053 
2054 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2055   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2056   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2057     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2058     resolve_wk_klass((WKID)id, CHECK);
2059   }
2060 
2061   // move the starting value forward to the limit:
2062   start_id = limit_id;
2063 }
2064 
2065 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2066   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2067 
2068   // Create the ModuleEntry for java.base.  This call needs to be done here,
2069   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2070   ClassLoader::classLoader_init2(CHECK);
2071 
2072   // Preload commonly used klasses
2073   WKID scan = FIRST_WKID;
2074   // first do Object, then String, Class
2075 #if INCLUDE_CDS
2076   if (UseSharedSpaces) {
2077     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2078 
2079     // It&#39;s unsafe to access the archived heap regions before they
2080     // are fixed up, so we must do the fixup as early as possible
2081     // before the archived java objects are accessed by functions
2082     // such as java_lang_Class::restore_archived_mirror and
2083     // ConstantPool::restore_unshareable_info (restores the archived
2084     // resolved_references array object).
2085     //
2086     // HeapShared::fixup_mapped_heap_regions() fills the empty
2087     // spaces in the archived heap regions and may use
2088     // SystemDictionary::Object_klass(), so we can do this only after
2089     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2090     // call. No mirror objects are accessed/restored in the above call.
2091     // Mirrors are restored after java.lang.Class is loaded.
2092     HeapShared::fixup_mapped_heap_regions();
2093 
2094     // Initialize the constant pool for the Object_class
2095     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2096     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2097     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2098   } else
2099 #endif
2100   {
2101     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2102   }
2103 
2104   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2105 
2106   java_lang_Object::register_natives(CHECK);
2107 
2108   // Calculate offsets for String and Class classes since they are loaded and
2109   // can be used after this point.
2110   java_lang_String::compute_offsets();
2111   java_lang_Class::compute_offsets();
2112 
2113   // Fixup mirrors for classes loaded before java.lang.Class.
2114   Universe::initialize_basic_type_mirrors(CHECK);
2115   Universe::fixup_mirrors(CHECK);
2116 
2117   // do a bunch more:
2118   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2119 
2120   // The offsets for jlr.Reference must be computed before
2121   // InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses
2122   // the offsets to remove the referent and discovered fields from the oop maps,
2123   // as they are treated in a special way by the GC. Removing these oops from the
2124   // oop maps must be done before the usual subclasses of jlr.Reference are loaded.
2125   java_lang_ref_Reference::compute_offsets();
2126 
2127   // Preload ref klasses and set reference types
2128   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2129   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2130 
2131   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2132   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2133   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2134   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2135   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2136 
2137   // JSR 292 classes
2138   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2139   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2140   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2141   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2142   WKID last = WKID_LIMIT;
2143   resolve_wk_klasses_until(last, scan, CHECK);
2144 
2145   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2146   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2147   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2148   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2149   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2150   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2151   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2152   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2153   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2154   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2155 
2156 #ifdef ASSERT
2157   if (UseSharedSpaces) {
2158     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2159                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2160     for (int i = FIRST_WKID; i &lt; last; i++) {
2161       InstanceKlass* k = _well_known_klasses[i];
2162       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2163     }
2164   }
2165 #endif
2166 }
2167 
2168 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2169 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2170 BasicType SystemDictionary::box_klass_type(Klass* k) {
2171   assert(k != NULL, &quot;&quot;);
2172   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2173     if (_box_klasses[i] == k)
2174       return (BasicType)i;
2175   }
2176   return T_OBJECT;
2177 }
2178 
2179 // Constraints on class loaders. The details of the algorithm can be
2180 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2181 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2182 // that the dictionary needs to maintain a set of contraints that
2183 // must be satisfied by all classes in the dictionary.
2184 // if defining is true, then LinkageError if already in dictionary
2185 // if initiating loader, then ok if InstanceKlass matches existing entry
2186 
2187 void SystemDictionary::check_constraints(unsigned int d_hash,
2188                                          InstanceKlass* k,
2189                                          Handle class_loader,
2190                                          bool defining,
2191                                          TRAPS) {
2192   ResourceMark rm(THREAD);
2193   stringStream ss;
2194   bool throwException = false;
2195 
2196   {
2197     Symbol *name = k-&gt;name();
2198     ClassLoaderData *loader_data = class_loader_data(class_loader);
2199 
2200     MutexLocker mu(THREAD, SystemDictionary_lock);
2201 
2202     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2203     if (check != NULL) {
2204       // If different InstanceKlass - duplicate class definition,
2205       // else - ok, class loaded by a different thread in parallel.
2206       // We should only have found it if it was done loading and ok to use.
2207       // The dictionary only holds instance classes, placeholders
2208       // also hold array classes.
2209 
2210       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2211       if ((defining == true) || (k != check)) {
2212         throwException = true;
2213         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2214         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2215                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2216       } else {
2217         return;
2218       }
2219     }
2220 
2221 #ifdef ASSERT
2222     Symbol* ph_check = find_placeholder(name, loader_data);
2223     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2224 #endif
2225 
2226     if (throwException == false) {
2227       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2228         throwException = true;
2229         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2230         ss.print(&quot; wants to load %s %s.&quot;,
2231                  k-&gt;external_kind(), k-&gt;external_name());
2232         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2233         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2234           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2235                    existing_klass-&gt;external_kind(),
2236                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2237                    existing_klass-&gt;class_in_module_of_loader(false, true));
2238         } else {
2239           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2240         }
2241       }
2242     }
2243   }
2244 
2245   // Throw error now if needed (cannot throw while holding
2246   // SystemDictionary_lock because of rank ordering)
2247   if (throwException == true) {
2248     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2249   }
2250 }
2251 
2252 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2253 // have been called.
2254 void SystemDictionary::update_dictionary(unsigned int d_hash,
2255                                          int p_index, unsigned int p_hash,
2256                                          InstanceKlass* k,
2257                                          Handle class_loader,
2258                                          TRAPS) {
2259   // Compile_lock prevents systemDictionary updates during compilations
2260   assert_locked_or_safepoint(Compile_lock);
2261   Symbol*  name  = k-&gt;name();
2262   ClassLoaderData *loader_data = class_loader_data(class_loader);
2263 
2264   {
2265     MutexLocker mu1(THREAD, SystemDictionary_lock);
2266 
2267     // Make a new dictionary entry.
2268     Dictionary* dictionary = loader_data-&gt;dictionary();
2269     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2270     if (sd_check == NULL) {
2271       dictionary-&gt;add_klass(d_hash, name, k);
2272     }
2273   #ifdef ASSERT
2274     sd_check = find_class(d_hash, name, dictionary);
2275     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2276     // Note: there may be a placeholder entry: for circularity testing
2277     // or for parallel defines
2278   #endif
2279     SystemDictionary_lock-&gt;notify_all();
2280   }
2281 }
2282 
2283 
2284 // Try to find a class name using the loader constraints.  The
2285 // loader constraints might know about a class that isn&#39;t fully loaded
2286 // yet and these will be ignored.
2287 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2288                     Symbol* class_name, Handle class_loader, TRAPS) {
2289 
2290   // First see if it has been loaded directly.
2291   // Force the protection domain to be null.  (This removes protection checks.)
2292   Handle no_protection_domain;
2293   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2294                                               no_protection_domain, CHECK_NULL);
2295   if (klass != NULL)
2296     return klass;
2297 
2298   // Now look to see if it has been loaded elsewhere, and is subject to
2299   // a loader constraint that would require this loader to return the
2300   // klass that is already loaded.
2301   if (Signature::is_array(class_name)) {
2302     // For array classes, their Klass*s are not kept in the
2303     // constraint table. The element Klass*s are.
2304     SignatureStream ss(class_name, false);
2305     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2306     BasicType t = ss.type();
2307     if (t != T_OBJECT) {
2308       klass = Universe::typeArrayKlassObj(t);
2309     } else {
2310       MutexLocker mu(THREAD, SystemDictionary_lock);
2311       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2312     }
2313     // If element class already loaded, allocate array klass
2314     if (klass != NULL) {
2315       klass = klass-&gt;array_klass_or_null(ndims);
2316     }
2317   } else {
2318     MutexLocker mu(THREAD, SystemDictionary_lock);
2319     // Non-array classes are easy: simply check the constraint table.
2320     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2321   }
2322 
2323   return klass;
2324 }
2325 
2326 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2327                                              Klass* klass_being_linked,
2328                                              Handle class_loader1,
2329                                              Handle class_loader2,
2330                                              Thread* THREAD) {
2331   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2332   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2333 
2334   Symbol* constraint_name = NULL;
2335 
2336   if (!Signature::is_array(class_name)) {
2337     constraint_name = class_name;
2338   } else {
2339     // For array classes, their Klass*s are not kept in the
2340     // constraint table. The element classes are.
2341     SignatureStream ss(class_name, false);
2342     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2343     if (!ss.has_envelope()) {
2344       return true;     // primitive types always pass
2345     }
2346     constraint_name = ss.as_symbol();
2347     // Increment refcount to keep constraint_name alive after
2348     // SignatureStream is destructed. It will be decremented below
2349     // before returning.
2350     constraint_name-&gt;increment_refcount();
2351   }
2352 
2353   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2354   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2355 
2356   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2357   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2358 
2359   {
2360     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2361     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2362     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2363     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2364                                            klass2, class_loader2);
2365 #if INCLUDE_CDS
2366     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;
2367         !klass_being_linked-&gt;is_shared()) {
2368          SystemDictionaryShared::record_linking_constraint(constraint_name,
2369                                      InstanceKlass::cast(klass_being_linked),
2370                                      class_loader1, class_loader2, THREAD);
2371     }
2372 #endif // INCLUDE_CDS
2373     if (Signature::is_array(class_name)) {
2374       constraint_name-&gt;decrement_refcount();
2375     }
2376     return result;
2377   }
2378 }
2379 
2380 // Add entry to resolution error table to record the error when the first
2381 // attempt to resolve a reference to a class has failed.
2382 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2383                                             Symbol* error, Symbol* message) {
2384   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2385   int index = resolution_errors()-&gt;hash_to_index(hash);
2386   {
2387     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2388     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2389   }
2390 }
2391 
2392 // Delete a resolution error for RedefineClasses for a constant pool is going away
2393 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2394   resolution_errors()-&gt;delete_entry(pool);
2395 }
2396 
2397 // Lookup resolution error table. Returns error if found, otherwise NULL.
2398 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2399                                                 Symbol** message) {
2400   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2401   int index = resolution_errors()-&gt;hash_to_index(hash);
2402   {
2403     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2404     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2405     if (entry != NULL) {
2406       *message = entry-&gt;message();
2407       return entry-&gt;error();
2408     } else {
2409       return NULL;
2410     }
2411   }
2412 }
2413 
2414 // Add an entry to resolution error table to record an error in resolving or
2415 // validating a nest host. This is used to construct informative error
2416 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2417 // be updated with the nest host error message.
2418 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2419                                            int which,
2420                                            const char* message) {
2421   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2422   int index = resolution_errors()-&gt;hash_to_index(hash);
2423   {
2424     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2425     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2426     if (entry != NULL) {
2427       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2428       entry-&gt;set_nest_host_error(message);
2429     } else {
2430       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2431     }
2432   }
2433 }
2434 
2435 // Lookup any nest host error
2436 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2437   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2438   int index = resolution_errors()-&gt;hash_to_index(hash);
2439   {
2440     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2441     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2442     if (entry != NULL) {
2443       return entry-&gt;nest_host_error();
2444     } else {
2445       return NULL;
2446     }
2447   }
2448 }
2449 
2450 
2451 // Signature constraints ensure that callers and callees agree about
2452 // the meaning of type names in their signatures.  This routine is the
2453 // intake for constraints.  It collects them from several places:
2454 //
2455 //  * LinkResolver::resolve_method (if check_access is true) requires
2456 //    that the resolving class (the caller) and the defining class of
2457 //    the resolved method (the callee) agree on each type in the
2458 //    method&#39;s signature.
2459 //
2460 //  * LinkResolver::resolve_interface_method performs exactly the same
2461 //    checks.
2462 //
2463 //  * LinkResolver::resolve_field requires that the constant pool
2464 //    attempting to link to a field agree with the field&#39;s defining
2465 //    class about the type of the field signature.
2466 //
2467 //  * klassVtable::initialize_vtable requires that, when a class
2468 //    overrides a vtable entry allocated by a superclass, that the
2469 //    overriding method (i.e., the callee) agree with the superclass
2470 //    on each type in the method&#39;s signature.
2471 //
2472 //  * klassItable::initialize_itable requires that, when a class fills
2473 //    in its itables, for each non-abstract method installed in an
2474 //    itable, the method (i.e., the callee) agree with the interface
2475 //    on each type in the method&#39;s signature.
2476 //
2477 // All those methods have a boolean (check_access, checkconstraints)
2478 // which turns off the checks.  This is used from specialized contexts
2479 // such as bootstrapping, dumping, and debugging.
2480 //
2481 // No direct constraint is placed between the class and its
2482 // supertypes.  Constraints are only placed along linked relations
2483 // between callers and callees.  When a method overrides or implements
2484 // an abstract method in a supertype (superclass or interface), the
2485 // constraints are placed as if the supertype were the caller to the
2486 // overriding method.  (This works well, since callers to the
2487 // supertype have already established agreement between themselves and
2488 // the supertype.)  As a result of all this, a class can disagree with
2489 // its supertype about the meaning of a type name, as long as that
2490 // class neither calls a relevant method of the supertype, nor is
2491 // called (perhaps via an override) from the supertype.
2492 //
2493 //
2494 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)
2495 //
2496 // Make sure all class components (including arrays) in the given
2497 // signature will be resolved to the same class in both loaders.
2498 // Returns the name of the type that failed a loader constraint check, or
2499 // NULL if no constraint failed.  No exception except OOME is thrown.
2500 // Arrays are not added to the loader constraint table, their elements are.
2501 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2502                                                Klass* klass_being_linked,
2503                                                Handle loader1, Handle loader2,
2504                                                bool is_method, TRAPS)  {
2505   // Nothing to do if loaders are the same.
2506   if (loader1() == loader2()) {
2507     return NULL;
2508   }
2509 
2510   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2511     if (ss.is_reference()) {
2512       Symbol* sig = ss.as_symbol();
2513       // Note: In the future, if template-like types can take
2514       // arguments, we will want to recognize them and dig out class
2515       // names hiding inside the argument lists.
2516       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {
2517         return sig;
2518       }
2519     }
2520   }
2521   return NULL;
2522 }
2523 
2524 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2525                                                        Symbol* signature,
2526                                                        TRAPS) {
2527   methodHandle empty;
2528   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2529          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2530          iid != vmIntrinsics::_invokeGeneric,
2531          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2532 
2533   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2534   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2535   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2536   methodHandle m;
2537   if (spe == NULL || spe-&gt;method() == NULL) {
2538     spe = NULL;
2539     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2540     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2541     if (!Arguments::is_interpreter_only()) {
2542       // Generate a compiled form of the MH intrinsic.
2543       AdapterHandlerLibrary::create_native_wrapper(m);
2544       // Check if have the compiled code.
2545       if (!m-&gt;has_compiled_code()) {
2546         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2547                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2548       }
2549     }
2550     // Now grab the lock.  We might have to throw away the new method,
2551     // if a racing thread has managed to install one at the same time.
2552     {
2553       MutexLocker ml(THREAD, SystemDictionary_lock);
2554       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2555       if (spe == NULL)
2556         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2557       if (spe-&gt;method() == NULL)
2558         spe-&gt;set_method(m());
2559     }
2560   }
2561 
2562   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2563   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2564          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2565          &quot;MH intrinsic invariant&quot;);
2566   return spe-&gt;method();
2567 }
2568 
2569 // Helper for unpacking the return value from linkMethod and linkCallSite.
2570 static Method* unpack_method_and_appendix(Handle mname,
2571                                           Klass* accessing_klass,
2572                                           objArrayHandle appendix_box,
2573                                           Handle* appendix_result,
2574                                           TRAPS) {
2575   if (mname.not_null()) {
2576     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2577     if (m != NULL) {
2578       oop appendix = appendix_box-&gt;obj_at(0);
2579       LogTarget(Info, methodhandles) lt;
2580       if (lt.develop_is_enabled()) {
2581         ResourceMark rm(THREAD);
2582         LogStream ls(lt);
2583         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2584         m-&gt;print_on(&amp;ls);
2585         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2586         ls.cr();
2587       }
2588 
2589       (*appendix_result) = Handle(THREAD, appendix);
2590       // the target is stored in the cpCache and if a reference to this
2591       // MemberName is dropped we need a way to make sure the
2592       // class_loader containing this method is kept alive.
2593       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2594       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2595       this_key-&gt;record_dependency(m-&gt;method_holder());
2596       return mh();
2597     }
2598   }
2599   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2600 }
2601 
2602 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2603                                                      Symbol* name,
2604                                                      Symbol* signature,
2605                                                           Klass* accessing_klass,
2606                                                           Handle *appendix_result,
2607                                                           TRAPS) {
2608   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2609   Handle method_type =
2610     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2611 
2612   int ref_kind = JVM_REF_invokeVirtual;
2613   oop name_oop = StringTable::intern(name, CHECK_NULL);
2614   Handle name_str (THREAD, name_oop);
2615   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2616   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2617 
2618   // This should not happen.  JDK code should take care of that.
2619   if (accessing_klass == NULL || method_type.is_null()) {
2620     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2621   }
2622 
2623   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2624   JavaCallArguments args;
2625   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2626   args.push_int(ref_kind);
2627   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2628   args.push_oop(name_str);
2629   args.push_oop(method_type);
2630   args.push_oop(appendix_box);
2631   JavaValue result(T_OBJECT);
2632   JavaCalls::call_static(&amp;result,
2633                          SystemDictionary::MethodHandleNatives_klass(),
2634                          vmSymbols::linkMethod_name(),
2635                          vmSymbols::linkMethod_signature(),
2636                          &amp;args, CHECK_NULL);
2637   Handle mname(THREAD, (oop) result.get_jobject());
2638   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2639 }
2640 
2641 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2642 // We must ensure that all class loaders everywhere will reach this class, for any client.
2643 // This is a safe bet for public classes in java.lang, such as Object and String.
2644 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2645 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2646 static bool is_always_visible_class(oop mirror) {
2647   Klass* klass = java_lang_Class::as_Klass(mirror);
2648   if (klass-&gt;is_objArray_klass()) {
2649     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2650   }
2651   if (klass-&gt;is_typeArray_klass()) {
2652     return true; // primitive array
2653   }
2654   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2655   return klass-&gt;is_public() &amp;&amp;
2656          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2657           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2658 }
2659 
2660 // Find or construct the Java mirror (java.lang.Class instance) for
2661 // the given field type signature, as interpreted relative to the
2662 // given class loader.  Handles primitives, void, references, arrays,
2663 // and all other reflectable types, except method types.
2664 // N.B.  Code in reflection should use this entry point.
2665 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2666                                                    Klass* accessing_klass,
2667                                                    Handle class_loader,
2668                                                    Handle protection_domain,
2669                                                    SignatureStream::FailureMode failure_mode,
2670                                                    TRAPS) {
2671   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2672          &quot;one or the other, or perhaps neither&quot;);
2673 
2674   // What we have here must be a valid field descriptor,
2675   // and all valid field descriptors are supported.
2676   // Produce the same java.lang.Class that reflection reports.
2677   if (accessing_klass != NULL) {
2678     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2679     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2680   }
2681   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2682   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2683   if (mirror_oop == NULL) {
2684     return Handle();  // report failure this way
2685   }
2686   Handle mirror(THREAD, mirror_oop);
2687 
2688   if (accessing_klass != NULL) {
2689     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2690     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2691     if (sel_klass != NULL) {
2692       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2693     }
2694   }
2695   return mirror;
2696 }
2697 
2698 
2699 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2700 // signature, as interpreted relative to the given class loader.
2701 // Because of class loader constraints, all method handle usage must be
2702 // consistent with this loader.
2703 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2704                                                  Klass* accessing_klass,
2705                                                  TRAPS) {
2706   Handle empty;
2707   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2708   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2709   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2710   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2711   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2712     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2713     return Handle(THREAD, spe-&gt;method_type());
2714   } else if (!THREAD-&gt;can_call_java()) {
2715     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2716     return Handle();  // do not attempt from within compiler, unless it was cached
2717   }
2718 
2719   Handle class_loader, protection_domain;
2720   if (accessing_klass != NULL) {
2721     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2722     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2723   }
2724   bool can_be_cached = true;
2725   int npts = ArgumentCount(signature).size();
2726   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2727   int arg = 0;
2728   Handle rt; // the return type from the signature
2729   ResourceMark rm(THREAD);
2730   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2731     oop mirror = NULL;
2732     if (can_be_cached) {
2733       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2734       mirror = ss.as_java_mirror(Handle(), Handle(),
2735                                  SignatureStream::ReturnNull, CHECK_(empty));
2736       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2737         // Fall back to accessing_klass context.
2738         can_be_cached = false;
2739       }
2740     }
2741     if (!can_be_cached) {
2742       // Resolve, throwing a real error if it doesn&#39;t work.
2743       mirror = ss.as_java_mirror(class_loader, protection_domain,
2744                                  SignatureStream::NCDFError, CHECK_(empty));
2745     }
2746     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2747     if (ss.at_return_type())
2748       rt = Handle(THREAD, mirror);
2749     else
2750       pts-&gt;obj_at_put(arg++, mirror);
2751 
2752     // Check accessibility.
2753     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2754       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2755       mirror = NULL;  // safety
2756       // Emulate ConstantPool::verify_constant_pool_resolve.
2757       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2758     }
2759   }
2760   assert(arg == npts, &quot;&quot;);
2761 
2762   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2763   JavaCallArguments args(Handle(THREAD, rt()));
2764   args.push_oop(pts);
2765   JavaValue result(T_OBJECT);
2766   JavaCalls::call_static(&amp;result,
2767                          SystemDictionary::MethodHandleNatives_klass(),
2768                          vmSymbols::findMethodHandleType_name(),
2769                          vmSymbols::findMethodHandleType_signature(),
2770                          &amp;args, CHECK_(empty));
2771   Handle method_type(THREAD, (oop) result.get_jobject());
2772 
2773   if (can_be_cached) {
2774     // We can cache this MethodType inside the JVM.
2775     MutexLocker ml(THREAD, SystemDictionary_lock);
2776     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2777     if (spe == NULL)
2778       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2779     if (spe-&gt;method_type() == NULL) {
2780       spe-&gt;set_method_type(method_type());
2781     }
2782   }
2783 
2784   // report back to the caller with the MethodType
2785   return method_type;
2786 }
2787 
2788 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2789                                                 Klass* accessing_klass,
2790                                                 TRAPS) {
2791   Handle empty;
2792   ResourceMark rm(THREAD);
2793   SignatureStream ss(signature, /*is_method=*/ false);
2794   if (!ss.is_done()) {
2795     Handle class_loader, protection_domain;
2796     if (accessing_klass != NULL) {
2797       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2798       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2799     }
2800     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2801     ss.next();
2802     if (ss.is_done()) {
2803       return Handle(THREAD, mirror);
2804     }
2805   }
2806   return empty;
2807 }
2808 
2809 // Ask Java code to find or construct a method handle constant.
2810 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2811                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2812                                                      Klass* callee,
2813                                                      Symbol* name,
2814                                                      Symbol* signature,
2815                                                      TRAPS) {
2816   Handle empty;
2817   if (caller == NULL) {
2818     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2819   }
2820   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2821   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2822 
2823   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2824   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2825   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2826   java_lang_invoke_MemberName::set_name (mname(), name_str());
2827   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2828   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2829 
2830   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2831       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2832     // Skip resolution for public signature polymorphic methods such as
2833     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2834     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2835     // There&#39;s special logic on JDK side to handle them
2836     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2837   } else {
2838     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2839   }
2840 
2841   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2842   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2843 
2844   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2845   JavaCallArguments args;
2846   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2847   args.push_int(ref_kind);
2848   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2849   args.push_oop(name_str);
2850   args.push_oop(type);
2851   JavaValue result(T_OBJECT);
2852   JavaCalls::call_static(&amp;result,
2853                          SystemDictionary::MethodHandleNatives_klass(),
2854                          vmSymbols::linkMethodHandleConstant_name(),
2855                          vmSymbols::linkMethodHandleConstant_signature(),
2856                          &amp;args, CHECK_(empty));
2857   return Handle(THREAD, (oop) result.get_jobject());
2858 }
2859 
2860 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2861 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2862 // with linkage results being stored back into the bootstrap specifier.
2863 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2864   // Resolve the bootstrap specifier, its name, type, and static arguments
2865   bootstrap_specifier.resolve_bsm(CHECK);
2866 
2867   // This should not happen.  JDK code should take care of that.
2868   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2869     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2870   }
2871 
2872   bool is_indy = bootstrap_specifier.is_method_call();
2873   objArrayHandle appendix_box;
2874   if (is_indy) {
2875     // Some method calls may require an appendix argument.  Arrange to receive it.
2876     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
2877     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2878   }
2879 
2880   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
2881   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
2882   JavaCallArguments args;
2883   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
2884   args.push_int(bootstrap_specifier.bss_index());
2885   args.push_oop(bootstrap_specifier.bsm());
2886   args.push_oop(bootstrap_specifier.name_arg());
2887   args.push_oop(bootstrap_specifier.type_arg());
2888   args.push_oop(bootstrap_specifier.arg_values());
2889   if (is_indy) {
2890     args.push_oop(appendix_box);
2891   }
2892   JavaValue result(T_OBJECT);
2893   JavaCalls::call_static(&amp;result,
2894                          SystemDictionary::MethodHandleNatives_klass(),
2895                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
2896                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
2897                          &amp;args, CHECK);
2898 
2899   Handle value(THREAD, (oop) result.get_jobject());
2900   if (is_indy) {
2901     Handle appendix;
2902     Method* method = unpack_method_and_appendix(value,
2903                                                 bootstrap_specifier.caller(),
2904                                                 appendix_box,
2905                                                 &amp;appendix, CHECK);
2906     methodHandle mh(THREAD, method);
2907     bootstrap_specifier.set_resolved_method(mh, appendix);
2908   } else {
2909     bootstrap_specifier.set_resolved_value(value);
2910   }
2911 
2912   // sanity check
2913   assert(bootstrap_specifier.is_resolved() ||
2914          (bootstrap_specifier.is_method_call() &amp;&amp;
2915           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
2916 }
2917 
2918 // Protection domain cache table handling
2919 
2920 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2921   return _pd_cache_table-&gt;get(protection_domain);
2922 }
2923 
2924 // ----------------------------------------------------------------------------
2925 
2926 void SystemDictionary::print_on(outputStream *st) {
2927   CDS_ONLY(SystemDictionaryShared::print_on(st));
2928   GCMutexLocker mu(SystemDictionary_lock);
2929 
2930   ClassLoaderDataGraph::print_dictionary(st);
2931 
2932   // Placeholders
2933   placeholders()-&gt;print_on(st);
2934   st-&gt;cr();
2935 
2936   // loader constraints - print under SD_lock
2937   constraints()-&gt;print_on(st);
2938   st-&gt;cr();
2939 
2940   _pd_cache_table-&gt;print_on(st);
2941   st-&gt;cr();
2942 }
2943 
2944 void SystemDictionary::print() { print_on(tty); }
2945 
2946 void SystemDictionary::verify() {
2947   guarantee(constraints() != NULL,
2948             &quot;Verify of loader constraints failed&quot;);
2949   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2950             &quot;Verify of placeholders failed&quot;);
2951 
2952   GCMutexLocker mu(SystemDictionary_lock);
2953 
2954   // Verify dictionary
2955   ClassLoaderDataGraph::verify_dictionary();
2956 
2957   placeholders()-&gt;verify();
2958 
2959   // Verify constraint table
2960   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2961   constraints()-&gt;verify(placeholders());
2962 
2963   _pd_cache_table-&gt;verify();
2964 }
2965 
2966 void SystemDictionary::dump(outputStream *st, bool verbose) {
2967   assert_locked_or_safepoint(SystemDictionary_lock);
2968   if (verbose) {
2969     print_on(st);
2970   } else {
2971     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
2972     ClassLoaderDataGraph::print_table_statistics(st);
2973     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2974     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
2975     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
2976   }
2977 }
2978 
2979 TableStatistics SystemDictionary::placeholders_statistics() {
2980   MutexLocker ml(SystemDictionary_lock);
2981   return placeholders()-&gt;statistics_calculate();
2982 }
2983 
2984 TableStatistics SystemDictionary::loader_constraints_statistics() {
2985   MutexLocker ml(SystemDictionary_lock);
2986   return constraints()-&gt;statistics_calculate();
2987 }
2988 
2989 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
2990   MutexLocker ml(SystemDictionary_lock);
2991   return pd_cache_table()-&gt;statistics_calculate();
2992 }
2993 
2994 // Utility for dumping dictionaries.
2995 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
2996                                  DCmdWithParser(output, heap),
2997   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
2998            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
2999   _dcmdparser.add_dcmd_option(&amp;_verbose);
3000 }
3001 
3002 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
3003   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
3004                          _verbose.value());
3005   VMThread::execute(&amp;dumper);
3006 }
3007 
3008 int SystemDictionaryDCmd::num_arguments() {
3009   ResourceMark rm;
3010   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
3011   if (dcmd != NULL) {
3012     DCmdMark mark(dcmd);
3013     return dcmd-&gt;_dcmdparser.num_arguments();
3014   } else {
3015     return 0;
3016   }
3017 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  77 #endif
  78 
  79 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  80   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  81 
  82 #if INCLUDE_CDS
  83 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  84   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  85 #endif
  86 
  87 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  88   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  89 
  90 InjectedField JavaClasses::_injected_fields[] = {
  91   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  92 };
  93 
  94 // Register native methods of Object
  95 void java_lang_Object::register_natives(TRAPS) {
  96   InstanceKlass* obj = SystemDictionary::Object_klass();
  97   Method::register_native(obj, vmSymbols::hashCode_name(),
  98                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  99   Method::register_native(obj, vmSymbols::wait_name(),
 100                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
 101   Method::register_native(obj, vmSymbols::notify_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 103   Method::register_native(obj, vmSymbols::notifyAll_name(),
 104                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 105   Method::register_native(obj, vmSymbols::clone_name(),
 106                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 107 }
 108 
 109 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 110   return _injected_fields[id].compute_offset();
 111 }
 112 
 113 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 114   *field_count = 0;
 115 
 116   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 117   if (sid == vmSymbols::NO_SID) {
 118     // Only well known classes can inject fields
 119     return NULL;
 120   }
 121 
 122   int count = 0;
 123   int start = -1;
 124 
 125 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 126   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 127     count++;                                                       \
 128     if (start == -1) start = klass##_##name##_enum;                \
 129   }
 130   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 131 #undef LOOKUP_INJECTED_FIELD
 132 
 133   if (start != -1) {
 134     *field_count = count;
 135     return _injected_fields + start;
 136   }
 137   return NULL;
 138 }
 139 
 140 
 141 // Helpful routine for computing field offsets at run time rather than hardcoding them
 142 // Finds local fields only, including static fields.  Static field offsets are from the
 143 // beginning of the mirror.
 144 static void compute_offset(int &amp;dest_offset,
 145                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 146                            bool is_static = false) {
 147   fieldDescriptor fd;
 148   if (ik == NULL) {
 149     ResourceMark rm;
 150     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 151     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 152   }
 153 
 154   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 155     ResourceMark rm;
 156     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 157                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 158 #ifndef PRODUCT
 159     // Prints all fields and offsets
 160     Log(class) lt;
 161     LogStream ls(lt.error());
 162     ik-&gt;print_on(&amp;ls);
 163 #endif //PRODUCT
 164     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 165   }
 166   dest_offset = fd.offset();
 167 }
 168 
 169 // Overloading to pass name as a string.
 170 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 171                            const char* name_string, Symbol* signature_symbol,
 172                            bool is_static = false) {
 173   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 174   if (name == NULL) {
 175     ResourceMark rm;
 176     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 177     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 178   }
 179   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 180 }
 181 
 182 int java_lang_String::value_offset  = 0;
 183 int java_lang_String::hash_offset   = 0;
 184 int java_lang_String::hashIsZero_offset = 0;
 185 int java_lang_String::coder_offset  = 0;
 186 
 187 bool java_lang_String::initialized  = false;
 188 
 189 bool java_lang_String::is_instance(oop obj) {
 190   return is_instance_inlined(obj);
 191 }
 192 
 193 #if INCLUDE_CDS
 194 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 195   f-&gt;do_u4((u4*)&amp;offset)
 196 #endif
 197 
 198 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 199   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 200 
 201 #define STRING_FIELDS_DO(macro) \
 202   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 203   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 204   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 205   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 206 
 207 void java_lang_String::compute_offsets() {
 208   if (initialized) {
 209     return;
 210   }
 211 
 212   InstanceKlass* k = SystemDictionary::String_klass();
 213   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 214 
 215   initialized = true;
 216 }
 217 
 218 #if INCLUDE_CDS
 219 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 220   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 221   f-&gt;do_bool(&amp;initialized);
 222 }
 223 #endif
 224 
 225 class CompactStringsFixup : public FieldClosure {
 226 private:
 227   bool _value;
 228 
 229 public:
 230   CompactStringsFixup(bool value) : _value(value) {}
 231 
 232   void do_field(fieldDescriptor* fd) {
 233     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 234       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 235       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 236       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 237       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 238     }
 239   }
 240 };
 241 
 242 void java_lang_String::set_compact_strings(bool value) {
 243   CompactStringsFixup fix(value);
 244   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 245 }
 246 
 247 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 248   assert(initialized, &quot;Must be initialized&quot;);
 249   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 250 
 251   // Create the String object first, so there&#39;s a chance that the String
 252   // and the char array it points to end up in the same cache line.
 253   oop obj;
 254   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 255 
 256   // Create the char array.  The String object must be handlized here
 257   // because GC can happen as a result of the allocation attempt.
 258   Handle h_obj(THREAD, obj);
 259   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 260   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 261 
 262   // Point the String at the char array
 263   obj = h_obj();
 264   set_value(obj, buffer);
 265   // No need to zero the offset, allocation zero&#39;ed the entire String object
 266   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 267   return h_obj;
 268 }
 269 
 270 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 271   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 272   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 273   typeArrayOop buffer = value(h_obj());
 274   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 275   if (is_latin1) {
 276     for (int index = 0; index &lt; length; index++) {
 277       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 278     }
 279   } else {
 280     for (int index = 0; index &lt; length; index++) {
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
 291       fatal(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 292     }
 293   }
 294 #endif
 295 
 296   return h_obj;
 297 }
 298 
 299 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 300   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 301   return h_obj();
 302 }
 303 
 304 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 305   if (utf8_str == NULL) {
 306     return Handle();
 307   }
 308   bool has_multibyte, is_latin1;
 309   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 310   if (!CompactStrings) {
 311     has_multibyte = true;
 312     is_latin1 = false;
 313   }
 314 
 315   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 316   if (length &gt; 0) {
 317     if (!has_multibyte) {
 318       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 319       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 320     } else if (is_latin1) {
 321       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 322     } else {
 323       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 324     }
 325   }
 326 
 327 #ifdef ASSERT
 328   // This check is too strict when the input string is not a valid UTF8.
 329   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 330   if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {
 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
 335       fatal(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 336     }
 337   }
 338 #endif
 339 
 340   return h_obj;
 341 }
 342 
 343 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 344   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 345   return h_obj();
 346 }
 347 
 348 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 349   const char* utf8_str = (char*)symbol-&gt;bytes();
 350   int utf8_len = symbol-&gt;utf8_length();
 351 
 352   bool has_multibyte, is_latin1;
 353   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 354   if (!CompactStrings) {
 355     has_multibyte = true;
 356     is_latin1 = false;
 357   }
 358 
 359   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 360   if (length &gt; 0) {
 361     if (!has_multibyte) {
 362       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 363       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 364     } else if (is_latin1) {
 365       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 366     } else {
 367       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 368     }
 369   }
 370 
 371 #ifdef ASSERT
 372   {
 373     ResourceMark rm;
 374     const char* expected = symbol-&gt;as_utf8();
 375     char* actual = as_utf8_string(h_obj());
 376     if (strncmp(expected, actual, utf8_len) != 0) {
 377       fatal(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 378     }
 379   }
 380 #endif
 381 
 382   return h_obj;
 383 }
 384 
 385 // Converts a C string to a Java String based on current encoding
 386 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 387   assert(str != NULL, &quot;bad arguments&quot;);
 388 
 389   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 390   static to_java_string_fn_t _to_java_string_fn = NULL;
 391 
 392   if (_to_java_string_fn == NULL) {
 393     void *lib_handle = os::native_java_library();
 394     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 395 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 396     if (_to_java_string_fn == NULL) {
 397       // On 32 bit Windows, also try __stdcall decorated name
 398       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 399     }
 400 #endif
 401     if (_to_java_string_fn == NULL) {
 402       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 403     }
 404   }
 405 
 406   jstring js = NULL;
 407   {
 408     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 409     JavaThread* thread = (JavaThread*)THREAD;
 410     HandleMark hm(thread);
 411     ThreadToNativeFromVM ttn(thread);
 412     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 413   }
 414 
 415   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 416   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 417   return native_platform_string;
 418 }
 419 
 420 // Converts a Java String to a native C string that can be used for
 421 // native OS calls.
 422 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 423   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 424   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 425 
 426   if (_to_platform_string_fn == NULL) {
 427     void *lib_handle = os::native_java_library();
 428     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 429     if (_to_platform_string_fn == NULL) {
 430       fatal(&quot;GetStringPlatformChars missing&quot;);
 431     }
 432   }
 433 
 434   char *native_platform_string;
 435   { JavaThread* thread = (JavaThread*)THREAD;
 436     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 437     JNIEnv *env = thread-&gt;jni_environment();
 438     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 439     bool is_copy;
 440     HandleMark hm(thread);
 441     ThreadToNativeFromVM ttn(thread);
 442     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 443     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 444     JNIHandles::destroy_local(js);
 445   }
 446   return native_platform_string;
 447 }
 448 
 449 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 450   oop          obj    = java_string();
 451   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 452   typeArrayOop value  = java_lang_String::value(obj);
 453   int          length = java_lang_String::length(obj, value);
 454   bool      is_latin1 = java_lang_String::is_latin1(obj);
 455 
 456   // First check if any from_char exist
 457   int index; // Declared outside, used later
 458   for (index = 0; index &lt; length; index++) {
 459     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 460                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 461     if (c == from_char) {
 462       break;
 463     }
 464   }
 465   if (index == length) {
 466     // No from_char, so do not copy.
 467     return java_string;
 468   }
 469 
 470   // Check if result string will be latin1
 471   bool to_is_latin1 = false;
 472 
 473   // Replacement char must be latin1
 474   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 475     if (is_latin1) {
 476       // Source string is latin1 as well
 477       to_is_latin1 = true;
 478     } else if (!UNICODE::is_latin1(from_char)) {
 479       // We are replacing an UTF16 char. Scan string to
 480       // check if result can be latin1 encoded.
 481       to_is_latin1 = true;
 482       for (index = 0; index &lt; length; index++) {
 483         jchar c = value-&gt;char_at(index);
 484         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 485           to_is_latin1 = false;
 486           break;
 487         }
 488       }
 489     }
 490   }
 491 
 492   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 493   // may happen during String and char array creation.
 494   typeArrayHandle h_value(THREAD, value);
 495   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 496   typeArrayOop from_buffer = h_value();
 497   typeArrayOop to_buffer = java_lang_String::value(string());
 498 
 499   // Copy contents
 500   for (index = 0; index &lt; length; index++) {
 501     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 502                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 503     if (c == from_char) {
 504       c = to_char;
 505     }
 506     if (!to_is_latin1) {
 507       to_buffer-&gt;char_at_put(index, c);
 508     } else {
 509       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 510     }
 511   }
 512   return string;
 513 }
 514 
 515 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 516   typeArrayOop value  = java_lang_String::value(java_string);
 517                length = java_lang_String::length(java_string, value);
 518   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 519 
 520   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 521   if (result != NULL) {
 522     if (!is_latin1) {
 523       for (int index = 0; index &lt; length; index++) {
 524         result[index] = value-&gt;char_at(index);
 525       }
 526     } else {
 527       for (int index = 0; index &lt; length; index++) {
 528         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 529       }
 530     }
 531   } else {
 532     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 533   }
 534   return result;
 535 }
 536 
 537 unsigned int java_lang_String::hash_code(oop java_string) {
 538   // The hash and hashIsZero fields are subject to a benign data race,
 539   // making it crucial to ensure that any observable result of the
 540   // calculation in this method stays correct under any possible read of
 541   // these fields. Necessary restrictions to allow this to be correct
 542   // without explicit memory fences or similar concurrency primitives is
 543   // that we can ever only write to one of these two fields for a given
 544   // String instance, and that the computation is idempotent and derived
 545   // from immutable state
 546   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 547   if (java_lang_String::hash_is_set(java_string)) {
 548     return java_string-&gt;int_field(hash_offset);
 549   }
 550 
 551   typeArrayOop value = java_lang_String::value(java_string);
 552   int         length = java_lang_String::length(java_string, value);
 553   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 554 
 555   unsigned int hash = 0;
 556   if (length &gt; 0) {
 557     if (is_latin1) {
 558       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 559     } else {
 560       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 561     }
 562   }
 563 
 564   if (hash != 0) {
 565     java_string-&gt;int_field_put(hash_offset, hash);
 566   } else {
 567     java_string-&gt;bool_field_put(hashIsZero_offset, true);
 568   }
 569   return hash;
 570 }
 571 
 572 char* java_lang_String::as_quoted_ascii(oop java_string) {
 573   typeArrayOop value  = java_lang_String::value(java_string);
 574   int          length = java_lang_String::length(java_string, value);
 575   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 576 
 577   if (length == 0) return NULL;
 578 
 579   char* result;
 580   int result_length;
 581   if (!is_latin1) {
 582     jchar* base = value-&gt;char_at_addr(0);
 583     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 584     result = NEW_RESOURCE_ARRAY(char, result_length);
 585     UNICODE::as_quoted_ascii(base, length, result, result_length);
 586   } else {
 587     jbyte* base = value-&gt;byte_at_addr(0);
 588     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 589     result = NEW_RESOURCE_ARRAY(char, result_length);
 590     UNICODE::as_quoted_ascii(base, length, result, result_length);
 591   }
 592   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 593   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 594   return result;
 595 }
 596 
 597 Symbol* java_lang_String::as_symbol(oop java_string) {
 598   typeArrayOop value  = java_lang_String::value(java_string);
 599   int          length = java_lang_String::length(java_string, value);
 600   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 601   if (!is_latin1) {
 602     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 603     Symbol* sym = SymbolTable::new_symbol(base, length);
 604     return sym;
 605   } else {
 606     ResourceMark rm;
 607     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 608     const char* base = UNICODE::as_utf8(position, length);
 609     Symbol* sym = SymbolTable::new_symbol(base, length);
 610     return sym;
 611   }
 612 }
 613 
 614 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 615   typeArrayOop value  = java_lang_String::value(java_string);
 616   int          length = java_lang_String::length(java_string, value);
 617   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 618   if (!is_latin1) {
 619     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 620     return SymbolTable::probe_unicode(base, length);
 621   } else {
 622     ResourceMark rm;
 623     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 624     const char* base = UNICODE::as_utf8(position, length);
 625     return SymbolTable::probe(base, length);
 626   }
 627 }
 628 
 629 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 630   assert(value_equals(value, java_lang_String::value(java_string)),
 631          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 632   int length = java_lang_String::length(java_string, value);
 633   if (length == 0) {
 634     return 0;
 635   }
 636   if (!java_lang_String::is_latin1(java_string)) {
 637     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 638   } else {
 639     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 640   }
 641 }
 642 
 643 int java_lang_String::utf8_length(oop java_string) {
 644   typeArrayOop value = java_lang_String::value(java_string);
 645   return utf8_length(java_string, value);
 646 }
 647 
 648 char* java_lang_String::as_utf8_string(oop java_string) {
 649   int length;
 650   return as_utf8_string(java_string, length);
 651 }
 652 
 653 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 654   typeArrayOop value = java_lang_String::value(java_string);
 655   length             = java_lang_String::length(java_string, value);
 656   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 657   if (!is_latin1) {
 658     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 659     return UNICODE::as_utf8(position, length);
 660   } else {
 661     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 662     return UNICODE::as_utf8(position, length);
 663   }
 664 }
 665 
 666 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 667 // a resource array to fit
 668 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 669   typeArrayOop value = java_lang_String::value(java_string);
 670   int            len = java_lang_String::length(java_string, value);
 671   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 672   if (!is_latin1) {
 673     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 674     utf8_len = UNICODE::utf8_length(position, len);
 675     if (utf8_len &gt;= buflen) {
 676       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 677     }
 678     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 679   } else {
 680     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 681     utf8_len = UNICODE::utf8_length(position, len);
 682     if (utf8_len &gt;= buflen) {
 683       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 684     }
 685     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 686   }
 687 }
 688 
 689 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 690   assert(value_equals(value, java_lang_String::value(java_string)),
 691          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 692   int     length = java_lang_String::length(java_string, value);
 693   bool is_latin1 = java_lang_String::is_latin1(java_string);
 694   if (!is_latin1) {
 695     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 696     return UNICODE::as_utf8(position, length, buf, buflen);
 697   } else {
 698     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 699     return UNICODE::as_utf8(position, length, buf, buflen);
 700   }
 701 }
 702 
 703 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 704   typeArrayOop value = java_lang_String::value(java_string);
 705   return as_utf8_string(java_string, value, buf, buflen);
 706 }
 707 
 708 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 709   typeArrayOop value  = java_lang_String::value(java_string);
 710   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 711   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 712   if (!is_latin1) {
 713     jchar* position = value-&gt;char_at_addr(start);
 714     return UNICODE::as_utf8(position, len);
 715   } else {
 716     jbyte* position = value-&gt;byte_at_addr(start);
 717     return UNICODE::as_utf8(position, len);
 718   }
 719 }
 720 
 721 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 722   assert(value_equals(value, java_lang_String::value(java_string)),
 723          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 724   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 725   bool is_latin1 = java_lang_String::is_latin1(java_string);
 726   if (!is_latin1) {
 727     jchar* position = value-&gt;char_at_addr(start);
 728     return UNICODE::as_utf8(position, len, buf, buflen);
 729   } else {
 730     jbyte* position = value-&gt;byte_at_addr(start);
 731     return UNICODE::as_utf8(position, len, buf, buflen);
 732   }
 733 }
 734 
 735 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 736   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 737          &quot;must be java_string&quot;);
 738   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 739   int length = java_lang_String::length(java_string, value);
 740   if (length != len) {
 741     return false;
 742   }
 743   bool is_latin1 = java_lang_String::is_latin1(java_string);
 744   if (!is_latin1) {
 745     for (int i = 0; i &lt; len; i++) {
 746       if (value-&gt;char_at(i) != chars[i]) {
 747         return false;
 748       }
 749     }
 750   } else {
 751     for (int i = 0; i &lt; len; i++) {
 752       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 753         return false;
 754       }
 755     }
 756   }
 757   return true;
 758 }
 759 
 760 bool java_lang_String::equals(oop str1, oop str2) {
 761   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 762          &quot;must be java String&quot;);
 763   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 764          &quot;must be java String&quot;);
 765   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 766   bool         is_latin1 = java_lang_String::is_latin1(str1);
 767   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 768   bool         is_latin2 = java_lang_String::is_latin1(str2);
 769 
 770   if (is_latin1 != is_latin2) {
 771     // Strings with different coders are never equal.
 772     return false;
 773   }
 774   return value_equals(value1, value2);
 775 }
 776 
 777 void java_lang_String::print(oop java_string, outputStream* st) {
 778   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 779   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 780 
 781   if (value == NULL) {
 782     // This can happen if, e.g., printing a String
 783     // object before its initializer has been called
 784     st-&gt;print(&quot;NULL&quot;);
 785     return;
 786   }
 787 
 788   int length = java_lang_String::length(java_string, value);
 789   bool is_latin1 = java_lang_String::is_latin1(java_string);
 790 
 791   st-&gt;print(&quot;\&quot;&quot;);
 792   for (int index = 0; index &lt; length; index++) {
 793     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 794                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 795   }
 796   st-&gt;print(&quot;\&quot;&quot;);
 797 }
 798 
 799 
 800 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 801   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 802   if (fd-&gt;has_initial_value()) {
 803     BasicType t = fd-&gt;field_type();
 804     switch (t) {
 805       case T_BYTE:
 806         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 807               break;
 808       case T_BOOLEAN:
 809         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 810               break;
 811       case T_CHAR:
 812         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 813               break;
 814       case T_SHORT:
 815         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 816               break;
 817       case T_INT:
 818         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 819         break;
 820       case T_FLOAT:
 821         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 822         break;
 823       case T_DOUBLE:
 824         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 825         break;
 826       case T_LONG:
 827         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 828         break;
 829       case T_OBJECT:
 830         {
 831           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 832                  &quot;just checking&quot;);
 833           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 834             // Archive the String field and update the pointer.
 835             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 836             oop archived_s = StringTable::create_archived_string(s, CHECK);
 837             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 838           } else {
 839             oop string = fd-&gt;string_initial_value(CHECK);
 840             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 841           }
 842         }
 843         break;
 844       default:
 845         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 846                   &quot;Illegal ConstantValue attribute in class file&quot;);
 847     }
 848   }
 849 }
 850 
 851 
 852 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 853   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 854 
 855   // If the offset was read from the shared archive, it was fixed up already
 856   if (!k-&gt;is_shared()) {
 857     if (k-&gt;is_instance_klass()) {
 858       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 859       // offsets were computed without the size added it.  Go back and
 860       // update all the static field offsets to included the size.
 861       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 862         if (fs.access_flags().is_static()) {
 863           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 864           fs.set_offset(real_offset);
 865         }
 866       }
 867     }
 868   }
 869 
 870   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 871     if (HeapShared::open_archive_heap_region_mapped()) {
 872       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 873       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 874       return;
 875     } else {
 876       k-&gt;set_java_mirror_handle(NULL);
 877       k-&gt;clear_has_raw_archived_mirror();
 878     }
 879   }
 880   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 881 }
 882 
 883 void java_lang_Class::initialize_mirror_fields(Klass* k,
 884                                                Handle mirror,
 885                                                Handle protection_domain,
 886                                                Handle classData,
 887                                                TRAPS) {
 888   // Allocate a simple java object for a lock.
 889   // This needs to be a java object because during class initialization
 890   // it can be held across a java call.
 891   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 892   set_init_lock(mirror(), r);
 893 
 894   // Set protection domain also
 895   set_protection_domain(mirror(), protection_domain());
 896 
 897   // Initialize static fields
 898   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 899 
 900  // Set classData
 901   set_class_data(mirror(), classData());
 902 }
 903 
 904 // Set the java.lang.Module module field in the java_lang_Class mirror
 905 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 906   if (module.is_null()) {
 907     // During startup, the module may be NULL only if java.base has not been defined yet.
 908     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 909     // for java.base is known. But note that since we captured the NULL module another
 910     // thread may have completed that initialization.
 911 
 912     bool javabase_was_defined = false;
 913     {
 914       MutexLocker m1(THREAD, Module_lock);
 915       // Keep list of classes needing java.base module fixup
 916       if (!ModuleEntryTable::javabase_defined()) {
 917         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 918         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 919         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 920         fixup_module_field_list()-&gt;push(k);
 921       } else {
 922         javabase_was_defined = true;
 923       }
 924     }
 925 
 926     // If java.base was already defined then patch this particular class with java.base.
 927     if (javabase_was_defined) {
 928       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 929       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 930              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 931       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 932       set_module(mirror(), javabase_handle());
 933     }
 934   } else {
 935     assert(Universe::is_module_initialized() ||
 936            (ModuleEntryTable::javabase_defined() &amp;&amp;
 937             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 938            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 939     set_module(mirror(), module());
 940   }
 941 }
 942 
 943 // Statically allocate fixup lists because they always get created.
 944 void java_lang_Class::allocate_fixup_lists() {
 945   GrowableArray&lt;Klass*&gt;* mirror_list =
 946     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 947   set_fixup_mirror_list(mirror_list);
 948 
 949   GrowableArray&lt;Klass*&gt;* module_list =
 950     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 951   set_fixup_module_field_list(module_list);
 952 }
 953 
 954 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 955                                     Handle module, Handle protection_domain,
 956                                     Handle classData, TRAPS) {
 957   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 958   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 959 
 960   // Use this moment of initialization to cache modifier_flags also,
 961   // to support Class.getModifiers().  Instance classes recalculate
 962   // the cached flags after the class file is parsed, but before the
 963   // class is put into the system dictionary.
 964   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 965   k-&gt;set_modifier_flags(computed_modifiers);
 966   // Class_klass has to be loaded because it is used to allocate
 967   // the mirror.
 968   if (SystemDictionary::Class_klass_loaded()) {
 969     // Allocate mirror (java.lang.Class instance)
 970     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 971     Handle mirror(THREAD, mirror_oop);
 972     Handle comp_mirror;
 973 
 974     // Setup indirection from mirror-&gt;klass
 975     java_lang_Class::set_klass(mirror(), k);
 976 
 977     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 978     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 979 
 980     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 981 
 982     // It might also have a component mirror.  This mirror must already exist.
 983     if (k-&gt;is_array_klass()) {
<a name="3" id="anc3"></a><span class="line-modified"> 984       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 985         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 986         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 987         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 988         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added"> 989       } else if (k-&gt;is_typeArray_klass()) {</span>
 990         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 991         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 992       } else {
 993         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 994         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 995         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 996         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 997       }
 998       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 999 
1000       // Two-way link between the array klass and its component mirror:
1001       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1002       set_component_mirror(mirror(), comp_mirror());
1003       // See below for ordering dependencies between field array_klass in component mirror
1004       // and java_mirror in this klass.
1005     } else {
1006       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1007 
1008       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1009       if (HAS_PENDING_EXCEPTION) {
1010         // If any of the fields throws an exception like OOM remove the klass field
1011         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1012         // This mirror looks like a primitive type, which logically it is because it
1013         // it represents no class.
1014         java_lang_Class::set_klass(mirror(), NULL);
1015         return;
1016       }
1017     }
1018 
1019     // set the classLoader field in the java_lang_Class instance
1020     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1021     set_class_loader(mirror(), class_loader());
1022 
1023     // Setup indirection from klass-&gt;mirror
1024     // after any exceptions can happen during allocations.
1025     k-&gt;set_java_mirror(mirror);
1026 
1027     // Set the module field in the java_lang_Class instance.  This must be done
1028     // after the mirror is set.
1029     set_mirror_module_field(k, mirror, module, THREAD);
1030 
1031     if (comp_mirror() != NULL) {
1032       // Set after k-&gt;java_mirror() is published, because compiled code running
1033       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1034       release_set_array_klass(comp_mirror(), k);
1035     }
<a name="4" id="anc4"></a><span class="line-added">1036 </span>
<span class="line-added">1037     if (k-&gt;is_value()) {</span>
<span class="line-added">1038       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1039       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1040 </span>
<span class="line-added">1041       // if the supertype is a restricted abstract class</span>
<span class="line-added">1042       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1043         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1044         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1045         // set the reference projection type</span>
<span class="line-added">1046         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1047 </span>
<span class="line-added">1048         // set the value and reference projection types</span>
<span class="line-added">1049         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1050         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1051       }</span>
<span class="line-added">1052     }</span>
1053   } else {
1054     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1055     fixup_mirror_list()-&gt;push(k);
1056   }
1057 }
1058 
1059 #if INCLUDE_CDS_JAVA_HEAP
1060 // Clears mirror fields. Static final fields with initial values are reloaded
1061 // from constant pool. The object identity hash is in the object header and is
1062 // not affected.
1063 class ResetMirrorField: public FieldClosure {
1064  private:
1065   Handle _m;
1066 
1067  public:
1068   ResetMirrorField(Handle mirror) : _m(mirror) {}
1069 
1070   void do_field(fieldDescriptor* fd) {
1071     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1072     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1073 
1074     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1075       initialize_static_field(fd, _m, Thread::current());
1076       return;
1077     }
1078 
1079     BasicType ft = fd-&gt;field_type();
1080     switch (ft) {
1081       case T_BYTE:
1082         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1083         break;
1084       case T_CHAR:
1085         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1086         break;
1087       case T_DOUBLE:
1088         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1089         break;
1090       case T_FLOAT:
1091         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1092         break;
1093       case T_INT:
1094         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1095         break;
1096       case T_LONG:
1097         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1098         break;
1099       case T_SHORT:
1100         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1101         break;
1102       case T_BOOLEAN:
1103         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1104         break;
1105       case T_ARRAY:
1106       case T_OBJECT: {
1107         // It might be useful to cache the String field, but
1108         // for now just clear out any reference field
1109         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1110         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1111         break;
1112       }
1113       default:
1114         ShouldNotReachHere();
1115         break;
1116      }
1117   }
1118 };
1119 
1120 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1121   assert(HeapShared::is_heap_object_archiving_allowed(),
1122          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1123 
1124   for (int t = 0; t &lt;= T_VOID; t++) {
1125     oop m = Universe::_mirrors[t];
1126     if (m != NULL) {
1127       // Update the field at _array_klass_offset to point to the relocated array klass.
1128       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1129       assert(archived_m != NULL, &quot;sanity&quot;);
1130       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1131       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1132       if (ak != NULL) {
1133         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1134         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1135       }
1136 
1137       // Clear the fields. Just to be safe
1138       Klass *k = m-&gt;klass();
1139       Handle archived_mirror_h(THREAD, archived_m);
1140       ResetMirrorField reset(archived_mirror_h);
1141       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1142 
1143       log_trace(cds, heap, mirror)(
1144         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1145         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1146 
1147       Universe::_mirrors[t] = archived_m;
1148     }
1149   }
1150 
1151   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1152          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1153          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1154          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1155          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1156          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1157          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1158          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1159          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1160 
1161   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1162   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1163   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1164   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1165   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1166   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1167   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1168   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1169   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1170 }
1171 
1172 //
1173 // After the mirror object is successfully archived, the archived
1174 // klass is set with _has_archived_raw_mirror flag.
1175 //
1176 // The _has_archived_raw_mirror flag is cleared at runtime when the
1177 // archived mirror is restored. If archived java heap data cannot
1178 // be used at runtime, new mirror object is created for the shared
1179 // class. The _has_archived_raw_mirror is cleared also during the process.
1180 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1181   assert(HeapShared::is_heap_object_archiving_allowed(),
1182          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1183 
1184   // Mirror is already archived
1185   if (k-&gt;has_raw_archived_mirror()) {
1186     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1187     return k-&gt;archived_java_mirror_raw();
1188   }
1189 
1190   // No mirror
1191   oop mirror = k-&gt;java_mirror();
1192   if (mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   if (k-&gt;is_instance_klass()) {
1197     InstanceKlass *ik = InstanceKlass::cast(k);
1198     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1199 
1200     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1201           ik-&gt;is_shared_app_class())) {
1202       // Archiving mirror for classes from non-builtin loaders is not
1203       // supported. Clear the _java_mirror within the archived class.
1204       k-&gt;set_java_mirror_handle(NULL);
1205       return NULL;
1206     }
1207   }
1208 
<a name="5" id="anc5"></a><span class="line-added">1209   if (k-&gt;is_value()) {</span>
<span class="line-added">1210     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1211     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1212     return NULL;</span>
<span class="line-added">1213   }</span>
<span class="line-added">1214 </span>
1215   // Now start archiving the mirror object
1216   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1217   if (archived_mirror == NULL) {
1218     return NULL;
1219   }
1220 
1221   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1222   if (archived_mirror == NULL) {
1223     return NULL;
1224   }
1225 
1226   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1227 
1228   k-&gt;set_has_raw_archived_mirror();
1229 
1230   ResourceMark rm;
1231   log_trace(cds, heap, mirror)(
1232     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1233     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1234 
1235   return archived_mirror;
1236 }
1237 
1238 // The process is based on create_mirror().
1239 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1240                                              oop archived_mirror,
1241                                              Thread *THREAD) {
1242   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1243   // to archived metadata and objects below.
1244   Klass *c = archived_mirror-&gt;klass();
1245   Handle archived_mirror_h(THREAD, archived_mirror);
1246   ResetMirrorField reset(archived_mirror_h);
1247   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1248 
1249   if (k-&gt;is_array_klass()) {
1250     oop archived_comp_mirror;
1251     if (k-&gt;is_typeArray_klass()) {
1252       // The primitive type mirrors are already archived. Get the archived mirror.
1253       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1254       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1255       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1256     } else {
1257       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1258       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1259       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1260       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1261       if (archived_comp_mirror == NULL) {
1262         return NULL;
1263       }
1264     }
1265     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1266   } else {
1267     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1268 
1269     // Reset local static fields in the mirror
1270     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1271 
1272     java_lang_Class:set_init_lock(archived_mirror, NULL);
1273 
1274     set_protection_domain(archived_mirror, NULL);
1275   }
1276 
1277   // clear class loader and mirror_module_field
1278   set_class_loader(archived_mirror, NULL);
1279   set_module(archived_mirror, NULL);
1280 
1281   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1282   // klass. Updated the field in the archived mirror to point to the relocated
1283   // klass in the archive.
1284   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1285   log_debug(cds, heap, mirror)(
1286     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1287     p2i(as_Klass(mirror)), p2i(reloc_k));
1288   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1289 
1290   // The field at _array_klass_offset is pointing to the original one dimension
1291   // higher array klass if exists. Relocate the pointer.
1292   Klass *arr = array_klass_acquire(mirror);
1293   if (arr != NULL) {
1294     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1295     log_debug(cds, heap, mirror)(
1296       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1297       p2i(arr), p2i(reloc_arr));
1298     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1299   }
1300   return archived_mirror;
1301 }
1302 
1303 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1304   if (MetaspaceShared::relocation_delta() != 0) {
1305     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1306 
1307     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1308     if (ak != NULL) {
1309       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1310           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1311     }
1312   }
1313 }
1314 
1315 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1316   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1317 
1318   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1319   archived_mirror-&gt;metadata_field_put(_klass_offset,
1320       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1321 
1322   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1323   if (ak != NULL) {
1324     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1325         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1326   }
1327 }
1328 
1329 
1330 // Returns true if the mirror is updated, false if no archived mirror
1331 // data is present. After the archived mirror object is restored, the
1332 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1333 bool java_lang_Class::restore_archived_mirror(Klass *k,
1334                                               Handle class_loader, Handle module,
1335                                               Handle protection_domain, TRAPS) {
1336   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1337   // see more details in SystemDictionary::resolve_well_known_classes().
1338   if (!SystemDictionary::Class_klass_loaded()) {
1339     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1340     fixup_mirror_list()-&gt;push(k);
1341     return true;
1342   }
1343 
1344   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1345   if (m == NULL) {
1346     return false;
1347   }
1348 
1349   // mirror is archived, restore
1350   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1351   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1352   assert(as_Klass(m) == k, &quot;must be&quot;);
1353   Handle mirror(THREAD, m);
1354 
1355   if (!k-&gt;is_array_klass()) {
1356     // - local static final fields with initial values were initialized at dump time
1357 
1358     // create the init_lock
1359     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1360     set_init_lock(mirror(), r);
1361 
1362     if (protection_domain.not_null()) {
1363       set_protection_domain(mirror(), protection_domain());
1364     }
1365   }
1366 
1367   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1368   if (class_loader.not_null()) {
1369     set_class_loader(mirror(), class_loader());
1370   }
1371 
1372   k-&gt;set_java_mirror(mirror);
1373   k-&gt;clear_has_raw_archived_mirror();
1374 
1375   set_mirror_module_field(k, mirror, module, THREAD);
1376 
1377   if (log_is_enabled(Trace, cds, heap, mirror)) {
1378     ResourceMark rm(THREAD);
1379     log_trace(cds, heap, mirror)(
1380         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1381   }
1382 
1383   return true;
1384 }
1385 #endif // INCLUDE_CDS_JAVA_HEAP
1386 
1387 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1388   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1389   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1390 }
1391 
1392 int  java_lang_Class::oop_size(oop java_class) {
1393   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1394   int size = java_class-&gt;int_field(_oop_size_offset);
1395   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1396   return size;
1397 }
1398 
1399 
1400 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1401   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1402   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1403   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1404 }
1405 
1406 int  java_lang_Class::static_oop_field_count(oop java_class) {
1407   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1408   return java_class-&gt;int_field(_static_oop_field_count_offset);
1409 }
1410 
1411 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1412   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1413   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1414 }
1415 
1416 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1417   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1418   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1419 }
1420 
1421 oop java_lang_Class::protection_domain(oop java_class) {
1422   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1423   return java_class-&gt;obj_field(_protection_domain_offset);
1424 }
1425 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1426   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1427   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1428 }
1429 
1430 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1431   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1432     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1433   }
1434 oop java_lang_Class::component_mirror(oop java_class) {
1435   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1436   return java_class-&gt;obj_field(_component_mirror_offset);
1437 }
1438 
1439 oop java_lang_Class::init_lock(oop java_class) {
1440   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1441   return java_class-&gt;obj_field(_init_lock_offset);
1442 }
1443 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1444   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1445   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1446 }
1447 
1448 objArrayOop java_lang_Class::signers(oop java_class) {
1449   assert(_signers_offset != 0, &quot;must be set&quot;);
1450   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1451 }
1452 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1453   assert(_signers_offset != 0, &quot;must be set&quot;);
1454   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1455 }
1456 
1457 oop java_lang_Class::class_data(oop java_class) {
1458   assert(_classData_offset != 0, &quot;must be set&quot;);
1459   return java_class-&gt;obj_field(_classData_offset);
1460 }
1461 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1462   assert(_classData_offset != 0, &quot;must be set&quot;);
1463   java_class-&gt;obj_field_put(_classData_offset, class_data);
1464 }
1465 
1466 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1467   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1468   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1469 }
1470 
1471 oop java_lang_Class::class_loader(oop java_class) {
1472   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1473   return java_class-&gt;obj_field(_class_loader_offset);
1474 }
1475 
1476 oop java_lang_Class::module(oop java_class) {
1477   assert(_module_offset != 0, &quot;must be set&quot;);
1478   return java_class-&gt;obj_field(_module_offset);
1479 }
1480 
1481 void java_lang_Class::set_module(oop java_class, oop module) {
1482   assert(_module_offset != 0, &quot;must be set&quot;);
1483   java_class-&gt;obj_field_put(_module_offset, module);
1484 }
1485 
1486 oop java_lang_Class::name(Handle java_class, TRAPS) {
1487   assert(_name_offset != 0, &quot;must be set&quot;);
1488   oop o = java_class-&gt;obj_field(_name_offset);
1489   if (o == NULL) {
1490     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1491     java_class-&gt;obj_field_put(_name_offset, o);
1492   }
1493   return o;
1494 }
1495 
1496 oop java_lang_Class::source_file(oop java_class) {
1497   assert(_source_file_offset != 0, &quot;must be set&quot;);
1498   return java_class-&gt;obj_field(_source_file_offset);
1499 }
1500 
1501 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1502   assert(_source_file_offset != 0, &quot;must be set&quot;);
1503   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1504 }
1505 
<a name="6" id="anc6"></a><span class="line-added">1506 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1507   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1508   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1509 }</span>
<span class="line-added">1510 </span>
<span class="line-added">1511 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1512   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1513   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1514 }</span>
<span class="line-added">1515 </span>
<span class="line-added">1516 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1517   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1518   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1519 }</span>
<span class="line-added">1520 </span>
<span class="line-added">1521 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1522   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1523   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
1526 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1527   // This should be improved by adding a field at the Java level or by
1528   // introducing a new VM klass (see comment in ClassFileParser)
1529   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1530   if (type != T_VOID) {
1531     Klass* aklass = Universe::typeArrayKlassObj(type);
1532     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1533     release_set_array_klass(java_class, aklass);
1534   }
1535 #ifdef ASSERT
1536   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1537   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1538 #endif
1539   return java_class;
1540 }
1541 
1542 
1543 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1544   //%note memory_2
1545   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1546   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1547   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1548   return k;
1549 }
1550 
1551 
1552 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1553   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1554   java_class-&gt;metadata_field_put(_klass_offset, klass);
1555 }
1556 
1557 
1558 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1559   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1560   Symbol* name = NULL;
1561   bool is_instance = false;
<a name="7" id="anc7"></a><span class="line-added">1562   bool is_value = false;</span>
1563   if (is_primitive(java_class)) {
1564     name = vmSymbols::type_signature(primitive_type(java_class));
1565   } else {
1566     Klass* k = as_Klass(java_class);
1567     is_instance = k-&gt;is_instance_klass();
<a name="8" id="anc8"></a><span class="line-added">1568     is_value = k-&gt;is_value();</span>
1569     name = k-&gt;name();
1570   }
1571   if (name == NULL) {
1572     st-&gt;print(&quot;&lt;null&gt;&quot;);
1573     return;
1574   }
<a name="9" id="anc9"></a><span class="line-modified">1575   if (is_instance)  {</span>
<span class="line-added">1576     if (is_value) {</span>
<span class="line-added">1577       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1578     } else {</span>
<span class="line-added">1579       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1580     }</span>
<span class="line-added">1581   }</span>
1582   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1583   if (is_instance)  st-&gt;print(&quot;;&quot;);
1584 }
1585 
1586 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1587   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1588   Symbol* name;
1589   if (is_primitive(java_class)) {
1590     name = vmSymbols::type_signature(primitive_type(java_class));
1591     // Because this can create a new symbol, the caller has to decrement
1592     // the refcount, so make adjustment here and below for symbols returned
1593     // that are not created or incremented due to a successful lookup.
1594     name-&gt;increment_refcount();
1595   } else {
1596     Klass* k = as_Klass(java_class);
1597     if (!k-&gt;is_instance_klass()) {
1598       name = k-&gt;name();
1599       name-&gt;increment_refcount();
1600     } else {
1601       ResourceMark rm;
1602       const char* sigstr = k-&gt;signature_name();
<a name="10" id="anc10"></a><span class="line-modified">1603       int siglen = (int) strlen(sigstr);</span>
1604       if (!intern_if_not_found) {
1605         name = SymbolTable::probe(sigstr, siglen);
1606       } else {
1607         name = SymbolTable::new_symbol(sigstr, siglen);
1608       }
1609     }
1610   }
1611   return name;
1612 }
1613 
1614 // Returns the Java name for this Java mirror (Resource allocated)
1615 // See Klass::external_name().
1616 // For primitive type Java mirrors, its type name is returned.
1617 const char* java_lang_Class::as_external_name(oop java_class) {
1618   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1619   const char* name = NULL;
1620   if (is_primitive(java_class)) {
1621     name = type2name(primitive_type(java_class));
1622   } else {
1623     name = as_Klass(java_class)-&gt;external_name();
1624   }
1625   if (name == NULL) {
1626     name = &quot;&lt;null&gt;&quot;;
1627   }
1628   return name;
1629 }
1630 
1631 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1632   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1633   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1634   return k;
1635 }
1636 
1637 
1638 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1639   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1640   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1641 }
1642 
1643 
1644 BasicType java_lang_Class::primitive_type(oop java_class) {
1645   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1646   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1647   BasicType type = T_VOID;
1648   if (ak != NULL) {
1649     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1650     type = ArrayKlass::cast(ak)-&gt;element_type();
1651   } else {
1652     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1653   }
1654   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1655   return type;
1656 }
1657 
1658 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1659   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1660   if (is_primitive(java_class)) {
1661     if (reference_klass != NULL)
1662       (*reference_klass) = NULL;
1663     return primitive_type(java_class);
1664   } else {
1665     if (reference_klass != NULL)
1666       (*reference_klass) = as_Klass(java_class);
1667     return T_OBJECT;
1668   }
1669 }
1670 
1671 
1672 oop java_lang_Class::primitive_mirror(BasicType t) {
1673   oop mirror = Universe::java_mirror(t);
1674   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1675   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1676   return mirror;
1677 }
1678 
1679 bool java_lang_Class::offsets_computed = false;
1680 int  java_lang_Class::classRedefinedCount_offset = -1;
1681 
1682 #define CLASS_FIELDS_DO(macro) \
1683   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1684   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1685   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1686   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1687   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<a name="11" id="anc11"></a><span class="line-added">1688   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1689   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1690   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1691 
1692 void java_lang_Class::compute_offsets() {
1693   if (offsets_computed) {
1694     return;
1695   }
1696 
1697   offsets_computed = true;
1698 
1699   InstanceKlass* k = SystemDictionary::Class_klass();
1700   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1701 
1702   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1703   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1704   // GC treats them the same.
1705   _init_lock_offset = _component_mirror_offset;
1706 
1707   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1708 }
1709 
1710 #if INCLUDE_CDS
1711 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1712   f-&gt;do_bool(&amp;offsets_computed);
1713   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1714 
1715   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1716 
1717   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1718 }
1719 #endif
1720 
1721 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1722   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1723   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1724 }
1725 
1726 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1727   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1728   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1729 }
1730 
1731 
1732 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1733 //       platform thread structure, and a eetop offset which was used for thread
1734 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1735 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1736 //       instead of the privateInfo_offset.
1737 //
1738 // Note: The stackSize field is only present starting in 1.4.
1739 
1740 int java_lang_Thread::_name_offset = 0;
1741 int java_lang_Thread::_group_offset = 0;
1742 int java_lang_Thread::_contextClassLoader_offset = 0;
1743 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1744 int java_lang_Thread::_priority_offset = 0;
1745 int java_lang_Thread::_eetop_offset = 0;
1746 int java_lang_Thread::_interrupted_offset = 0;
1747 int java_lang_Thread::_daemon_offset = 0;
1748 int java_lang_Thread::_stillborn_offset = 0;
1749 int java_lang_Thread::_stackSize_offset = 0;
1750 int java_lang_Thread::_tid_offset = 0;
1751 int java_lang_Thread::_thread_status_offset = 0;
1752 int java_lang_Thread::_park_blocker_offset = 0;
1753 
1754 #define THREAD_FIELDS_DO(macro) \
1755   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1756   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1757   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1758   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1759   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1760   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1761   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1762   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1763   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1764   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1765   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1766   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1767   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1768 
1769 void java_lang_Thread::compute_offsets() {
1770   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1771 
1772   InstanceKlass* k = SystemDictionary::Thread_klass();
1773   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1774 }
1775 
1776 #if INCLUDE_CDS
1777 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1778   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1779 }
1780 #endif
1781 
1782 JavaThread* java_lang_Thread::thread(oop java_thread) {
1783   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1784 }
1785 
1786 
1787 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1788   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1789 }
1790 
1791 bool java_lang_Thread::interrupted(oop java_thread) {
1792   // Make sure the caller can safely access oops.
1793   assert(Thread::current()-&gt;is_VM_thread() ||
1794          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1795           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1796          &quot;Unsafe access to oop&quot;);
1797   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1798 }
1799 
1800 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1801   // Make sure the caller can safely access oops.
1802   assert(Thread::current()-&gt;is_VM_thread() ||
1803          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1804           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1805          &quot;Unsafe access to oop&quot;);
1806   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1807 }
1808 
1809 
1810 oop java_lang_Thread::name(oop java_thread) {
1811   return java_thread-&gt;obj_field(_name_offset);
1812 }
1813 
1814 
1815 void java_lang_Thread::set_name(oop java_thread, oop name) {
1816   java_thread-&gt;obj_field_put(_name_offset, name);
1817 }
1818 
1819 
1820 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1821   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1822 }
1823 
1824 
1825 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1826   java_thread-&gt;int_field_put(_priority_offset, priority);
1827 }
1828 
1829 
1830 oop java_lang_Thread::threadGroup(oop java_thread) {
1831   return java_thread-&gt;obj_field(_group_offset);
1832 }
1833 
1834 
1835 bool java_lang_Thread::is_stillborn(oop java_thread) {
1836   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1837 }
1838 
1839 
1840 // We never have reason to turn the stillborn bit off
1841 void java_lang_Thread::set_stillborn(oop java_thread) {
1842   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1843 }
1844 
1845 
1846 bool java_lang_Thread::is_alive(oop java_thread) {
1847   JavaThread* thr = java_lang_Thread::thread(java_thread);
1848   return (thr != NULL);
1849 }
1850 
1851 
1852 bool java_lang_Thread::is_daemon(oop java_thread) {
1853   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1854 }
1855 
1856 
1857 void java_lang_Thread::set_daemon(oop java_thread) {
1858   java_thread-&gt;bool_field_put(_daemon_offset, true);
1859 }
1860 
1861 oop java_lang_Thread::context_class_loader(oop java_thread) {
1862   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1863 }
1864 
1865 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1866   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1867 }
1868 
1869 
1870 jlong java_lang_Thread::stackSize(oop java_thread) {
1871   return java_thread-&gt;long_field(_stackSize_offset);
1872 }
1873 
1874 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1875 void java_lang_Thread::set_thread_status(oop java_thread,
1876                                          java_lang_Thread::ThreadStatus status) {
1877   java_thread-&gt;int_field_put(_thread_status_offset, status);
1878 }
1879 
1880 // Read thread status value from threadStatus field in java.lang.Thread java class.
1881 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1882   // Make sure the caller is operating on behalf of the VM or is
1883   // running VM code (state == _thread_in_vm).
1884   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1885          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1886          &quot;Java Thread is not running in vm&quot;);
1887   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1888 }
1889 
1890 
1891 jlong java_lang_Thread::thread_id(oop java_thread) {
1892   return java_thread-&gt;long_field(_tid_offset);
1893 }
1894 
1895 oop java_lang_Thread::park_blocker(oop java_thread) {
1896   return java_thread-&gt;obj_field(_park_blocker_offset);
1897 }
1898 
1899 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1900   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1901   switch (status) {
1902     case NEW                      : return &quot;NEW&quot;;
1903     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1904     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1905     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1906     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1907     case PARKED                   : return &quot;WAITING (parking)&quot;;
1908     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1909     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1910     case TERMINATED               : return &quot;TERMINATED&quot;;
1911     default                       : return &quot;UNKNOWN&quot;;
1912   };
1913 }
1914 int java_lang_ThreadGroup::_parent_offset = 0;
1915 int java_lang_ThreadGroup::_name_offset = 0;
1916 int java_lang_ThreadGroup::_threads_offset = 0;
1917 int java_lang_ThreadGroup::_groups_offset = 0;
1918 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1919 int java_lang_ThreadGroup::_destroyed_offset = 0;
1920 int java_lang_ThreadGroup::_daemon_offset = 0;
1921 int java_lang_ThreadGroup::_nthreads_offset = 0;
1922 int java_lang_ThreadGroup::_ngroups_offset = 0;
1923 
1924 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1925   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1926   return java_thread_group-&gt;obj_field(_parent_offset);
1927 }
1928 
1929 // (&quot;name as oop&quot; accessor is not necessary)
1930 
1931 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1932   oop name = java_thread_group-&gt;obj_field(_name_offset);
1933   // ThreadGroup.name can be null
1934   if (name != NULL) {
1935     return java_lang_String::as_utf8_string(name);
1936   }
1937   return NULL;
1938 }
1939 
1940 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1941   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1942   return java_thread_group-&gt;int_field(_nthreads_offset);
1943 }
1944 
1945 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1946   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1947   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1948   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1949   return objArrayOop(threads);
1950 }
1951 
1952 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1953   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1954   return java_thread_group-&gt;int_field(_ngroups_offset);
1955 }
1956 
1957 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1958   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1959   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1960   return objArrayOop(groups);
1961 }
1962 
1963 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1964   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1965   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1966 }
1967 
1968 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1969   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1970   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1971 }
1972 
1973 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1974   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1975   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1976 }
1977 
1978 #define THREADGROUP_FIELDS_DO(macro) \
1979   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1980   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1981   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1982   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1983   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1984   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1985   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1986   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1987   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1988 
1989 void java_lang_ThreadGroup::compute_offsets() {
1990   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1991 
1992   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1993   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1994 }
1995 
1996 #if INCLUDE_CDS
1997 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1998   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1999 }
2000 #endif
2001 
2002 #define THROWABLE_FIELDS_DO(macro) \
2003   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
2004   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
2005   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
2006   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
2007   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
2008 
2009 void java_lang_Throwable::compute_offsets() {
2010   InstanceKlass* k = SystemDictionary::Throwable_klass();
2011   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2012 }
2013 
2014 #if INCLUDE_CDS
2015 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2016   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2017 }
2018 #endif
2019 
2020 oop java_lang_Throwable::unassigned_stacktrace() {
2021   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2022   oop base = ik-&gt;static_field_base_raw();
2023   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
2024 }
2025 
2026 oop java_lang_Throwable::backtrace(oop throwable) {
2027   return throwable-&gt;obj_field_acquire(backtrace_offset);
2028 }
2029 
2030 
2031 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
2032   throwable-&gt;release_obj_field_put(backtrace_offset, value);
2033 }
2034 
2035 int java_lang_Throwable::depth(oop throwable) {
2036   return throwable-&gt;int_field(depth_offset);
2037 }
2038 
2039 void java_lang_Throwable::set_depth(oop throwable, int value) {
2040   throwable-&gt;int_field_put(depth_offset, value);
2041 }
2042 
2043 oop java_lang_Throwable::message(oop throwable) {
2044   return throwable-&gt;obj_field(detailMessage_offset);
2045 }
2046 
2047 
2048 // Return Symbol for detailed_message or NULL
2049 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2050   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2051   oop detailed_message = java_lang_Throwable::message(throwable);
2052   if (detailed_message != NULL) {
2053     return java_lang_String::as_symbol(detailed_message);
2054   }
2055   return NULL;
2056 }
2057 
2058 void java_lang_Throwable::set_message(oop throwable, oop value) {
2059   throwable-&gt;obj_field_put(detailMessage_offset, value);
2060 }
2061 
2062 
2063 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2064   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
2065 }
2066 
2067 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2068   set_stacktrace(throwable, NULL);
2069 }
2070 
2071 
2072 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2073   ResourceMark rm;
2074   Klass* k = throwable-&gt;klass();
2075   assert(k != NULL, &quot;just checking&quot;);
2076   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2077   oop msg = message(throwable);
2078   if (msg != NULL) {
2079     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2080   }
2081 }
2082 
2083 // After this many redefines, the stack trace is unreliable.
2084 const int MAX_VERSION = USHRT_MAX;
2085 
2086 static inline bool version_matches(Method* method, int version) {
2087   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2088   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2089 }
2090 
2091 // This class provides a simple wrapper over the internal structure of
2092 // exception backtrace to insulate users of the backtrace from needing
2093 // to know what it looks like.
2094 // The code of this class is not GC safe. Allocations can only happen
2095 // in expand().
2096 class BacktraceBuilder: public StackObj {
2097  friend class BacktraceIterator;
2098  private:
2099   Handle          _backtrace;
2100   objArrayOop     _head;
2101   typeArrayOop    _methods;
2102   typeArrayOop    _bcis;
2103   objArrayOop     _mirrors;
2104   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2105   // True if the top frame of the backtrace is omitted because it shall be hidden.
2106   bool            _has_hidden_top_frame;
2107   int             _index;
2108   NoSafepointVerifier _nsv;
2109 
2110   enum {
2111     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2112     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2113     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2114     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2115     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2116     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2117     trace_size           = java_lang_Throwable::trace_size,
2118     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2119   };
2120 
2121   // get info out of chunks
2122   static typeArrayOop get_methods(objArrayHandle chunk) {
2123     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2124     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2125     return methods;
2126   }
2127   static typeArrayOop get_bcis(objArrayHandle chunk) {
2128     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2129     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2130     return bcis;
2131   }
2132   static objArrayOop get_mirrors(objArrayHandle chunk) {
2133     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2134     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2135     return mirrors;
2136   }
2137   static typeArrayOop get_names(objArrayHandle chunk) {
2138     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2139     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2140     return names;
2141   }
2142   static bool has_hidden_top_frame(objArrayHandle chunk) {
2143     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2144     return hidden != NULL;
2145   }
2146 
2147  public:
2148 
2149   // constructor for new backtrace
2150   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2151     expand(CHECK);
2152     _backtrace = Handle(THREAD, _head);
2153     _index = 0;
2154   }
2155 
2156   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2157     _methods = get_methods(backtrace);
2158     _bcis = get_bcis(backtrace);
2159     _mirrors = get_mirrors(backtrace);
2160     _names = get_names(backtrace);
2161     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2162     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2163            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2164            _mirrors-&gt;length() == _names-&gt;length(),
2165            &quot;method and source information arrays should match&quot;);
2166 
2167     // head is the preallocated backtrace
2168     _head = backtrace();
2169     _backtrace = Handle(thread, _head);
2170     _index = 0;
2171   }
2172 
2173   void expand(TRAPS) {
2174     objArrayHandle old_head(THREAD, _head);
2175     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2176 
2177     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2178     objArrayHandle new_head(THREAD, head);
2179 
2180     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2181     typeArrayHandle new_methods(THREAD, methods);
2182 
2183     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2184     typeArrayHandle new_bcis(THREAD, bcis);
2185 
2186     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2187     objArrayHandle new_mirrors(THREAD, mirrors);
2188 
2189     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2190     typeArrayHandle new_names(THREAD, names);
2191 
2192     if (!old_head.is_null()) {
2193       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2194     }
2195     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2196     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2197     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2198     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2199     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2200 
2201     _head    = new_head();
2202     _methods = new_methods();
2203     _bcis = new_bcis();
2204     _mirrors = new_mirrors();
2205     _names  = new_names();
2206     _index = 0;
2207   }
2208 
2209   oop backtrace() {
2210     return _backtrace();
2211   }
2212 
2213   inline void push(Method* method, int bci, TRAPS) {
2214     // Smear the -1 bci to 0 since the array only holds unsigned
2215     // shorts.  The later line number lookup would just smear the -1
2216     // to a 0 even if it could be recorded.
2217     if (bci == SynchronizationEntryBCI) bci = 0;
2218 
2219     if (_index &gt;= trace_chunk_size) {
2220       methodHandle mhandle(THREAD, method);
2221       expand(CHECK);
2222       method = mhandle();
2223     }
2224 
2225     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2226     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2227 
2228     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2229     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2230     Symbol* name = method-&gt;name();
2231     _names-&gt;symbol_at_put(_index, name);
2232 
2233     // We need to save the mirrors in the backtrace to keep the class
2234     // from being unloaded while we still have this stack trace.
2235     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2236     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2237     _index++;
2238   }
2239 
2240   void set_has_hidden_top_frame(TRAPS) {
2241     if (!_has_hidden_top_frame) {
2242       // It would be nice to add java/lang/Boolean::TRUE here
2243       // to indicate that this backtrace has a hidden top frame.
2244       // But this code is used before TRUE is allocated.
2245       // Therefore let&#39;s just use an arbitrary legal oop
2246       // available right here. _methods is a short[].
2247       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2248       _has_hidden_top_frame = true;
2249       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2250     }
2251   }
2252 };
2253 
2254 struct BacktraceElement : public StackObj {
2255   int _method_id;
2256   int _bci;
2257   int _version;
2258   Symbol* _name;
2259   Handle _mirror;
2260   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2261                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2262 };
2263 
2264 class BacktraceIterator : public StackObj {
2265   int _index;
2266   objArrayHandle  _result;
2267   objArrayHandle  _mirrors;
2268   typeArrayHandle _methods;
2269   typeArrayHandle _bcis;
2270   typeArrayHandle _names;
2271 
2272   void init(objArrayHandle result, Thread* thread) {
2273     // Get method id, bci, version and mirror from chunk
2274     _result = result;
2275     if (_result.not_null()) {
2276       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2277       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2278       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2279       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2280       _index = 0;
2281     }
2282   }
2283  public:
2284   BacktraceIterator(objArrayHandle result, Thread* thread) {
2285     init(result, thread);
2286     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2287   }
2288 
2289   BacktraceElement next(Thread* thread) {
2290     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2291                         _methods-&gt;ushort_at(_index),
2292                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2293                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2294                         _names-&gt;symbol_at(_index));
2295     _index++;
2296 
2297     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2298       int next_offset = java_lang_Throwable::trace_next_offset;
2299       // Get next chunk
2300       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2301       init(result, thread);
2302     }
2303     return e;
2304   }
2305 
2306   bool repeat() {
2307     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2308   }
2309 };
2310 
2311 
2312 // Print stack trace element to resource allocated buffer
2313 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2314                                           int version, int bci, Symbol* name) {
2315   ResourceMark rm;
2316 
2317   // Get strings and string lengths
2318   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2319   const char* klass_name  = holder-&gt;external_name();
2320   int buf_len = (int)strlen(klass_name);
2321 
2322   char* method_name = name-&gt;as_C_string();
2323   buf_len += (int)strlen(method_name);
2324 
2325   char* source_file_name = NULL;
2326   Symbol* source = Backtrace::get_source_file_name(holder, version);
2327   if (source != NULL) {
2328     source_file_name = source-&gt;as_C_string();
2329     buf_len += (int)strlen(source_file_name);
2330   }
2331 
2332   char *module_name = NULL, *module_version = NULL;
2333   ModuleEntry* module = holder-&gt;module();
2334   if (module-&gt;is_named()) {
2335     module_name = module-&gt;name()-&gt;as_C_string();
2336     buf_len += (int)strlen(module_name);
2337     if (module-&gt;version() != NULL) {
2338       module_version = module-&gt;version()-&gt;as_C_string();
2339       buf_len += (int)strlen(module_version);
2340     }
2341   }
2342 
2343   // Allocate temporary buffer with extra space for formatting and line number
2344   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2345 
2346   // Print stack trace line in buffer
2347   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2348 
2349   // Print module information
2350   if (module_name != NULL) {
2351     if (module_version != NULL) {
2352       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2353     } else {
2354       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2355     }
2356   }
2357 
2358   // The method can be NULL if the requested class version is gone
2359   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2360   if (!version_matches(method, version)) {
2361     strcat(buf, &quot;Redefined)&quot;);
2362   } else {
2363     int line_number = Backtrace::get_line_number(method, bci);
2364     if (line_number == -2) {
2365       strcat(buf, &quot;Native Method)&quot;);
2366     } else {
2367       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2368         // Sourcename and linenumber
2369         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2370       } else if (source_file_name != NULL) {
2371         // Just sourcename
2372         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2373       } else {
2374         // Neither sourcename nor linenumber
2375         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2376       }
2377       CompiledMethod* nm = method-&gt;code();
2378       if (WizardMode &amp;&amp; nm != NULL) {
2379         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2380       }
2381     }
2382   }
2383 
2384   st-&gt;print_cr(&quot;%s&quot;, buf);
2385 }
2386 
2387 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2388   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2389   int method_id = method-&gt;orig_method_idnum();
2390   int version = method-&gt;constants()-&gt;version();
2391   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2392 }
2393 
2394 /**
2395  * Print the throwable message and its stack trace plus all causes by walking the
2396  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2397  */
2398 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2399   // First, print the message.
2400   print(throwable(), st);
2401   st-&gt;cr();
2402 
2403   // Now print the stack trace.
2404   Thread* THREAD = Thread::current();
2405   while (throwable.not_null()) {
2406     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2407     if (result.is_null()) {
2408       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2409       return;
2410     }
2411     BacktraceIterator iter(result, THREAD);
2412 
2413     while (iter.repeat()) {
2414       BacktraceElement bte = iter.next(THREAD);
2415       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2416     }
2417     {
2418       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2419       EXCEPTION_MARK;
2420       JavaValue cause(T_OBJECT);
2421       JavaCalls::call_virtual(&amp;cause,
2422                               throwable,
2423                               throwable-&gt;klass(),
2424                               vmSymbols::getCause_name(),
2425                               vmSymbols::void_throwable_signature(),
2426                               THREAD);
2427       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2428       if (HAS_PENDING_EXCEPTION) {
2429         CLEAR_PENDING_EXCEPTION;
2430         throwable = Handle();
2431       } else {
2432         throwable = Handle(THREAD, (oop) cause.get_jobject());
2433         if (throwable.not_null()) {
2434           st-&gt;print(&quot;Caused by: &quot;);
2435           print(throwable(), st);
2436           st-&gt;cr();
2437         }
2438       }
2439     }
2440   }
2441 }
2442 
2443 /**
2444  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2445  */
2446 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2447   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2448   JavaValue result(T_VOID);
2449   JavaCalls::call_virtual(&amp;result,
2450                           throwable,
2451                           SystemDictionary::Throwable_klass(),
2452                           vmSymbols::printStackTrace_name(),
2453                           vmSymbols::void_method_signature(),
2454                           THREAD);
2455 }
2456 
2457 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2458   if (!StackTraceInThrowable) return;
2459   ResourceMark rm(THREAD);
2460 
2461   // Start out by clearing the backtrace for this object, in case the VM
2462   // runs out of memory while allocating the stack trace
2463   set_backtrace(throwable(), NULL);
2464   // Clear lazily constructed Java level stacktrace if refilling occurs
2465   // This is unnecessary in 1.7+ but harmless
2466   clear_stacktrace(throwable());
2467 
2468   int max_depth = MaxJavaStackTraceDepth;
2469   JavaThread* thread = (JavaThread*)THREAD;
2470 
2471   BacktraceBuilder bt(CHECK);
2472 
2473   // If there is no Java frame just return the method that was being called
2474   // with bci 0
2475   if (!thread-&gt;has_last_Java_frame()) {
2476     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2477       bt.push(method(), 0, CHECK);
2478       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2479       set_depth(throwable(), 1);
2480       set_backtrace(throwable(), bt.backtrace());
2481     }
2482     return;
2483   }
2484 
2485   // Instead of using vframe directly, this version of fill_in_stack_trace
2486   // basically handles everything by hand. This significantly improved the
2487   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2488   // See bug 6333838 for  more details.
2489   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2490   // trace as utilizing vframe.
2491 #ifdef ASSERT
2492   vframeStream st(thread);
2493 #endif
2494   int total_count = 0;
2495   RegisterMap map(thread, false);
2496   int decode_offset = 0;
2497   CompiledMethod* nm = NULL;
2498   bool skip_fillInStackTrace_check = false;
2499   bool skip_throwableInit_check = false;
2500   bool skip_hidden = !ShowHiddenFrames;
2501 
2502   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2503     Method* method = NULL;
2504     int bci = 0;
2505 
2506     // Compiled java method case.
2507     if (decode_offset != 0) {
2508       DebugInfoReadStream stream(nm, decode_offset);
2509       decode_offset = stream.read_int();
2510       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2511       bci = stream.read_bci();
2512     } else {
2513       if (fr.is_first_frame()) break;
2514       address pc = fr.pc();
2515       if (fr.is_interpreted_frame()) {
2516         address bcp = fr.interpreter_frame_bcp();
2517         method = fr.interpreter_frame_method();
2518         bci =  method-&gt;bci_from(bcp);
2519         fr = fr.sender(&amp;map);
2520       } else {
2521         CodeBlob* cb = fr.cb();
2522         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2523         // but non nmethod
2524         fr = fr.sender(&amp;map);
2525         if (cb == NULL || !cb-&gt;is_compiled()) {
2526           continue;
2527         }
2528         nm = cb-&gt;as_compiled_method();
2529         if (nm-&gt;method()-&gt;is_native()) {
2530           method = nm-&gt;method();
2531           bci = 0;
2532         } else {
2533           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2534           decode_offset = pd-&gt;scope_decode_offset();
2535           // if decode_offset is not equal to 0, it will execute the
2536           // &quot;compiled java method case&quot; at the beginning of the loop.
2537           continue;
2538         }
2539       }
2540     }
2541 #ifdef ASSERT
2542     assert(st.method() == method &amp;&amp; st.bci() == bci,
2543            &quot;Wrong stack trace&quot;);
2544     st.next();
2545 #endif
2546 
2547     // the format of the stacktrace will be:
2548     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2549     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2550     // - rest of the stack
2551 
2552     if (!skip_fillInStackTrace_check) {
2553       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2554           throwable-&gt;is_a(method-&gt;method_holder())) {
2555         continue;
2556       }
2557       else {
2558         skip_fillInStackTrace_check = true; // gone past them all
2559       }
2560     }
2561     if (!skip_throwableInit_check) {
2562       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2563 
2564       // skip &lt;init&gt; methods of the exception class and superclasses
<a name="12" id="anc12"></a><span class="line-modified">2565       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2566       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2567           throwable-&gt;is_a(method-&gt;method_holder())) {
2568         continue;
2569       } else {
2570         // there are none or we&#39;ve seen them all - either way stop checking
2571         skip_throwableInit_check = true;
2572       }
2573     }
2574     if (method-&gt;is_hidden()) {
2575       if (skip_hidden) {
2576         if (total_count == 0) {
2577           // The top frame will be hidden from the stack trace.
2578           bt.set_has_hidden_top_frame(CHECK);
2579         }
2580         continue;
2581       }
2582     }
2583     bt.push(method, bci, CHECK);
2584     total_count++;
2585   }
2586 
2587   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2588 
2589   // Put completed stack trace into throwable object
2590   set_backtrace(throwable(), bt.backtrace());
2591   set_depth(throwable(), total_count);
2592 }
2593 
2594 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2595   // No-op if stack trace is disabled
2596   if (!StackTraceInThrowable) {
2597     return;
2598   }
2599 
2600   // Disable stack traces for some preallocated out of memory errors
2601   if (!Universe::should_fill_in_stack_trace(throwable)) {
2602     return;
2603   }
2604 
2605   PRESERVE_EXCEPTION_MARK;
2606 
2607   JavaThread* thread = JavaThread::active();
2608   fill_in_stack_trace(throwable, method, thread);
2609   // ignore exceptions thrown during stack trace filling
2610   CLEAR_PENDING_EXCEPTION;
2611 }
2612 
2613 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2614   // Allocate stack trace - backtrace is created but not filled in
2615 
2616   // No-op if stack trace is disabled
2617   if (!StackTraceInThrowable) return;
2618   BacktraceBuilder bt(CHECK);   // creates a backtrace
2619   set_backtrace(throwable(), bt.backtrace());
2620 }
2621 
2622 
2623 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2624   // Fill in stack trace into preallocated backtrace (no GC)
2625 
2626   // No-op if stack trace is disabled
2627   if (!StackTraceInThrowable) return;
2628 
2629   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2630 
2631   JavaThread* THREAD = JavaThread::current();
2632 
2633   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2634   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2635 
2636   ResourceMark rm(THREAD);
2637   vframeStream st(THREAD);
2638 
2639   BacktraceBuilder bt(THREAD, backtrace);
2640 
2641   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2642   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2643 
2644   // fill in as much stack trace as possible
2645   int chunk_count = 0;
2646   for (;!st.at_end(); st.next()) {
2647     bt.push(st.method(), st.bci(), CHECK);
2648     chunk_count++;
2649 
2650     // Bail-out for deep stacks
2651     if (chunk_count &gt;= trace_chunk_size) break;
2652   }
2653   set_depth(throwable(), chunk_count);
2654   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2655 
2656   // We support the Throwable immutability protocol defined for Java 7.
2657   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2658   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2659 }
2660 
2661 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2662                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2663 
2664   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2665     THROW(vmSymbols::java_lang_NullPointerException());
2666   }
2667 
2668   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2669 
2670   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2671     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2672   }
2673 
2674   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2675   BacktraceIterator iter(result, THREAD);
2676 
2677   int index = 0;
2678   while (iter.repeat()) {
2679     BacktraceElement bte = iter.next(THREAD);
2680 
2681     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2682 
2683     if (stack_trace_element.is_null()) {
2684       THROW(vmSymbols::java_lang_NullPointerException());
2685     }
2686 
2687     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2688     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2689 
2690     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2691                                          method,
2692                                          bte._version,
2693                                          bte._bci,
2694                                          bte._name, CHECK);
2695   }
2696 }
2697 
2698 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2699   Thread* THREAD = Thread::current();
2700   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2701   BacktraceIterator iter(result, THREAD);
2702   // No backtrace available.
2703   if (!iter.repeat()) return false;
2704 
2705   // If the exception happened in a frame that has been hidden, i.e.,
2706   // omitted from the back trace, we can not compute the message.
2707   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2708   if (hidden != NULL) {
2709     return false;
2710   }
2711 
2712   // Get first backtrace element.
2713   BacktraceElement bte = iter.next(THREAD);
2714 
2715   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2716   assert(holder != NULL, &quot;first element should be non-null&quot;);
2717   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2718 
2719   // Original version is no longer available.
2720   if (m == NULL || !version_matches(m, bte._version)) {
2721     return false;
2722   }
2723 
2724   *method = m;
2725   *bci = bte._bci;
2726   return true;
2727 }
2728 
2729 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2730   // Allocate java.lang.StackTraceElement instance
2731   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2732   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2733   if (k-&gt;should_be_initialized()) {
2734     k-&gt;initialize(CHECK_NULL);
2735   }
2736 
2737   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2738 
2739   int version = method-&gt;constants()-&gt;version();
2740   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2741   return element();
2742 }
2743 
2744 void java_lang_StackTraceElement::fill_in(Handle element,
2745                                           InstanceKlass* holder, const methodHandle&amp; method,
2746                                           int version, int bci, Symbol* name, TRAPS) {
2747   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2748 
2749   ResourceMark rm(THREAD);
2750   HandleMark hm(THREAD);
2751 
2752   // Fill in class name
2753   Handle java_class(THREAD, holder-&gt;java_mirror());
2754   oop classname = java_lang_Class::name(java_class, CHECK);
2755   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2756   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2757 
2758   oop loader = holder-&gt;class_loader();
2759   if (loader != NULL) {
2760     oop loader_name = java_lang_ClassLoader::name(loader);
2761     if (loader_name != NULL)
2762       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2763   }
2764 
2765   // Fill in method name
2766   oop methodname = StringTable::intern(name, CHECK);
2767   java_lang_StackTraceElement::set_methodName(element(), methodname);
2768 
2769   // Fill in module name and version
2770   ModuleEntry* module = holder-&gt;module();
2771   if (module-&gt;is_named()) {
2772     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2773     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2774     oop module_version;
2775     if (module-&gt;version() != NULL) {
2776       module_version = StringTable::intern(module-&gt;version(), CHECK);
2777     } else {
2778       module_version = NULL;
2779     }
2780     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2781   }
2782 
2783   if (method() == NULL || !version_matches(method(), version)) {
2784     // The method was redefined, accurate line number information isn&#39;t available
2785     java_lang_StackTraceElement::set_fileName(element(), NULL);
2786     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2787   } else {
2788     Symbol* source;
2789     oop source_file;
2790     int line_number;
2791     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2792 
2793     java_lang_StackTraceElement::set_fileName(element(), source_file);
2794     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2795   }
2796 }
2797 
2798 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2799                                                        InstanceKlass* holder,
2800                                                        int version,
2801                                                        const methodHandle&amp; method,
2802                                                        int bci,
2803                                                        Symbol*&amp; source,
2804                                                        oop&amp; source_file,
2805                                                        int&amp; line_number, TRAPS) {
2806   // Fill in source file name and line number.
2807   source = Backtrace::get_source_file_name(holder, version);
2808   source_file = java_lang_Class::source_file(java_class());
2809   if (source != NULL) {
2810     // Class was not redefined. We can trust its cache if set,
2811     // else we have to initialize it.
2812     if (source_file == NULL) {
2813       source_file = StringTable::intern(source, CHECK);
2814       java_lang_Class::set_source_file(java_class(), source_file);
2815     }
2816   } else {
2817     // Class was redefined. Dump the cache if it was set.
2818     if (source_file != NULL) {
2819       source_file = NULL;
2820       java_lang_Class::set_source_file(java_class(), source_file);
2821     }
2822   }
2823   line_number = Backtrace::get_line_number(method(), bci);
2824 }
2825 
2826 #if INCLUDE_JVMCI
2827 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2828                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2829   ResourceMark rm(THREAD);
2830   HandleMark hm(THREAD);
2831 
2832   filename = NULL;
2833   line_number = -1;
2834 
2835   oop source_file;
2836   int version = method-&gt;constants()-&gt;version();
2837   InstanceKlass* holder = method-&gt;method_holder();
2838   Handle java_class(THREAD, holder-&gt;java_mirror());
2839   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2840 }
2841 #endif // INCLUDE_JVMCI
2842 
2843 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2844   HandleMark hm(THREAD);
2845   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2846   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2847   // we should expand MemberName::name when Throwable uses StackTrace
2848   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2849   return method;
2850 }
2851 
2852 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2853   // set Method* or mid/cpref
2854   HandleMark hm(THREAD);
2855   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2856   InstanceKlass* ik = method-&gt;method_holder();
2857   CallInfo info(method(), ik, CHECK);
2858   MethodHandles::init_method_MemberName(mname, info);
2859   // set bci
2860   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2861   // method may be redefined; store the version
2862   int version = method-&gt;constants()-&gt;version();
2863   assert((jushort)version == version, &quot;version should be short&quot;);
2864   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2865 }
2866 
2867 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2868   ResourceMark rm(THREAD);
2869   HandleMark hm(THREAD);
2870   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2871   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2872   InstanceKlass* holder = InstanceKlass::cast(clazz);
2873   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2874 
2875   short version = stackFrame-&gt;short_field(_version_offset);
2876   int bci = stackFrame-&gt;int_field(_bci_offset);
2877   Symbol* name = method-&gt;name();
2878   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2879                                        version, bci, name, CHECK);
2880 }
2881 
2882 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2883   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2884   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2885 
2886 void java_lang_StackFrameInfo::compute_offsets() {
2887   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2888   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2889   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2890 }
2891 
2892 #if INCLUDE_CDS
2893 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2894   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2895   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2896 }
2897 #endif
2898 
2899 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2900   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2901   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2902   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2903   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2904 
2905 void java_lang_LiveStackFrameInfo::compute_offsets() {
2906   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2907   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2908 }
2909 
2910 #if INCLUDE_CDS
2911 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2912   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2913 }
2914 #endif
2915 
2916 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2917   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
2918 
2919 void java_lang_reflect_AccessibleObject::compute_offsets() {
2920   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2921   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2922 }
2923 
2924 #if INCLUDE_CDS
2925 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2926   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2927 }
2928 #endif
2929 
2930 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2931   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2932   return (jboolean) reflect-&gt;bool_field(override_offset);
2933 }
2934 
2935 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2936   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2937   reflect-&gt;bool_field_put(override_offset, (int) value);
2938 }
2939 
2940 #define METHOD_FIELDS_DO(macro) \
2941   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2942   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2943   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2944   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2945   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2946   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2947   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2948   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2949   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2950   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2951   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2952 
2953 void java_lang_reflect_Method::compute_offsets() {
2954   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2955   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2956 }
2957 
2958 #if INCLUDE_CDS
2959 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2960   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2961 }
2962 #endif
2963 
2964 Handle java_lang_reflect_Method::create(TRAPS) {
2965   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2966   Klass* klass = SystemDictionary::reflect_Method_klass();
2967   // This class is eagerly initialized during VM initialization, since we keep a refence
2968   // to one of the methods
2969   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2970   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2971 }
2972 
2973 oop java_lang_reflect_Method::clazz(oop reflect) {
2974   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2975   return reflect-&gt;obj_field(clazz_offset);
2976 }
2977 
2978 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2979   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2980    reflect-&gt;obj_field_put(clazz_offset, value);
2981 }
2982 
2983 int java_lang_reflect_Method::slot(oop reflect) {
2984   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2985   return reflect-&gt;int_field(slot_offset);
2986 }
2987 
2988 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
2989   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2990   reflect-&gt;int_field_put(slot_offset, value);
2991 }
2992 
2993 void java_lang_reflect_Method::set_name(oop method, oop value) {
2994   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2995   method-&gt;obj_field_put(name_offset, value);
2996 }
2997 
2998 oop java_lang_reflect_Method::return_type(oop method) {
2999   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3000   return method-&gt;obj_field(returnType_offset);
3001 }
3002 
3003 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
3004   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3005   method-&gt;obj_field_put(returnType_offset, value);
3006 }
3007 
3008 oop java_lang_reflect_Method::parameter_types(oop method) {
3009   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3010   return method-&gt;obj_field(parameterTypes_offset);
3011 }
3012 
3013 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
3014   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3015   method-&gt;obj_field_put(parameterTypes_offset, value);
3016 }
3017 
3018 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
3019   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3020   method-&gt;obj_field_put(exceptionTypes_offset, value);
3021 }
3022 
3023 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
3024   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3025   method-&gt;int_field_put(modifiers_offset, value);
3026 }
3027 
3028 void java_lang_reflect_Method::set_signature(oop method, oop value) {
3029   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3030   method-&gt;obj_field_put(signature_offset, value);
3031 }
3032 
3033 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
3034   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3035   method-&gt;obj_field_put(annotations_offset, value);
3036 }
3037 
3038 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
3039   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3040   method-&gt;obj_field_put(parameter_annotations_offset, value);
3041 }
3042 
3043 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
3044   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3045   method-&gt;obj_field_put(annotation_default_offset, value);
3046 }
3047 
3048 #define CONSTRUCTOR_FIELDS_DO(macro) \
3049   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3050   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3051   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3052   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3053   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3054   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3055   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3056   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3057 
3058 void java_lang_reflect_Constructor::compute_offsets() {
3059   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3060   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3061 }
3062 
3063 #if INCLUDE_CDS
3064 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3065   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3066 }
3067 #endif
3068 
3069 Handle java_lang_reflect_Constructor::create(TRAPS) {
3070   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3071   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3072   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3073   InstanceKlass* ik = InstanceKlass::cast(k);
3074   // Ensure it is initialized
3075   ik-&gt;initialize(CHECK_NH);
3076   return ik-&gt;allocate_instance_handle(THREAD);
3077 }
3078 
3079 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3080   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3081   return reflect-&gt;obj_field(clazz_offset);
3082 }
3083 
3084 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3085   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3086    reflect-&gt;obj_field_put(clazz_offset, value);
3087 }
3088 
3089 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3090   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3091   return constructor-&gt;obj_field(parameterTypes_offset);
3092 }
3093 
3094 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3095   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3096   constructor-&gt;obj_field_put(parameterTypes_offset, value);
3097 }
3098 
3099 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3100   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3101   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
3102 }
3103 
3104 int java_lang_reflect_Constructor::slot(oop reflect) {
3105   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3106   return reflect-&gt;int_field(slot_offset);
3107 }
3108 
3109 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3110   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3111   reflect-&gt;int_field_put(slot_offset, value);
3112 }
3113 
3114 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3115   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3116   constructor-&gt;int_field_put(modifiers_offset, value);
3117 }
3118 
3119 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3120   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3121   constructor-&gt;obj_field_put(signature_offset, value);
3122 }
3123 
3124 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3125   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3126   constructor-&gt;obj_field_put(annotations_offset, value);
3127 }
3128 
3129 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3130   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3131   method-&gt;obj_field_put(parameter_annotations_offset, value);
3132 }
3133 
3134 #define FIELD_FIELDS_DO(macro) \
3135   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3136   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3137   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3138   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3139   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3140   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3141   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3142 
3143 void java_lang_reflect_Field::compute_offsets() {
3144   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3145   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3146 }
3147 
3148 #if INCLUDE_CDS
3149 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3150   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3151 }
3152 #endif
3153 
3154 Handle java_lang_reflect_Field::create(TRAPS) {
3155   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3156   Symbol* name = vmSymbols::java_lang_reflect_Field();
3157   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3158   InstanceKlass* ik = InstanceKlass::cast(k);
3159   // Ensure it is initialized
3160   ik-&gt;initialize(CHECK_NH);
3161   return ik-&gt;allocate_instance_handle(THREAD);
3162 }
3163 
3164 oop java_lang_reflect_Field::clazz(oop reflect) {
3165   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3166   return reflect-&gt;obj_field(clazz_offset);
3167 }
3168 
3169 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3170   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3171    reflect-&gt;obj_field_put(clazz_offset, value);
3172 }
3173 
3174 oop java_lang_reflect_Field::name(oop field) {
3175   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3176   return field-&gt;obj_field(name_offset);
3177 }
3178 
3179 void java_lang_reflect_Field::set_name(oop field, oop value) {
3180   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3181   field-&gt;obj_field_put(name_offset, value);
3182 }
3183 
3184 oop java_lang_reflect_Field::type(oop field) {
3185   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3186   return field-&gt;obj_field(type_offset);
3187 }
3188 
3189 void java_lang_reflect_Field::set_type(oop field, oop value) {
3190   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3191   field-&gt;obj_field_put(type_offset, value);
3192 }
3193 
3194 int java_lang_reflect_Field::slot(oop reflect) {
3195   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3196   return reflect-&gt;int_field(slot_offset);
3197 }
3198 
3199 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3200   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3201   reflect-&gt;int_field_put(slot_offset, value);
3202 }
3203 
3204 int java_lang_reflect_Field::modifiers(oop field) {
3205   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3206   return field-&gt;int_field(modifiers_offset);
3207 }
3208 
3209 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3210   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3211   field-&gt;int_field_put(modifiers_offset, value);
3212 }
3213 
3214 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3215   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3216   field-&gt;obj_field_put(signature_offset, value);
3217 }
3218 
3219 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3220   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3221   field-&gt;obj_field_put(annotations_offset, value);
3222 }
3223 
3224 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3225   // Allocate java.lang.reflect.RecordComponent instance
3226   HandleMark hm(THREAD);
3227   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3228   assert(ik != NULL, &quot;must be loaded&quot;);
3229   ik-&gt;initialize(CHECK_NULL);
3230 
3231   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3232 
3233   Handle decl_class(THREAD, holder-&gt;java_mirror());
3234   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3235 
3236   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3237   oop component_name = StringTable::intern(name, CHECK_NULL);
3238   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3239 
3240   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3241   Handle component_type_h =
3242     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3243   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3244 
3245   Method* accessor_method = NULL;
3246   {
3247     // Prepend &quot;()&quot; to type to create the full method signature.
3248     ResourceMark rm(THREAD);
3249     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3250     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3251     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3252     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3253     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3254   }
3255 
3256   if (accessor_method != NULL) {
3257     methodHandle method(THREAD, accessor_method);
3258     oop m = Reflection::new_method(method, false, CHECK_NULL);
3259     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3260   } else {
3261     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3262   }
3263 
3264   int sig_index = component-&gt;generic_signature_index();
3265   if (sig_index &gt; 0) {
3266     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3267     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3268     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3269   } else {
3270     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3271   }
3272 
3273   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3274   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3275 
3276   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3277   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3278 
3279   return element();
3280 }
3281 
3282 #define CONSTANTPOOL_FIELDS_DO(macro) \
3283   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3284 
3285 void reflect_ConstantPool::compute_offsets() {
3286   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3287   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3288   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3289 }
3290 
3291 #if INCLUDE_CDS
3292 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3293   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3294 }
3295 #endif
3296 
3297 #define PARAMETER_FIELDS_DO(macro) \
3298   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3299   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3300   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3301   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3302 
3303 void java_lang_reflect_Parameter::compute_offsets() {
3304   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3305   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3306 }
3307 
3308 #if INCLUDE_CDS
3309 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3310   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3311 }
3312 #endif
3313 
3314 Handle java_lang_reflect_Parameter::create(TRAPS) {
3315   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3316   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3317   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3318   InstanceKlass* ik = InstanceKlass::cast(k);
3319   // Ensure it is initialized
3320   ik-&gt;initialize(CHECK_NH);
3321   return ik-&gt;allocate_instance_handle(THREAD);
3322 }
3323 
3324 oop java_lang_reflect_Parameter::name(oop param) {
3325   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3326   return param-&gt;obj_field(name_offset);
3327 }
3328 
3329 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3330   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3331   param-&gt;obj_field_put(name_offset, value);
3332 }
3333 
3334 int java_lang_reflect_Parameter::modifiers(oop param) {
3335   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3336   return param-&gt;int_field(modifiers_offset);
3337 }
3338 
3339 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3340   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3341   param-&gt;int_field_put(modifiers_offset, value);
3342 }
3343 
3344 int java_lang_reflect_Parameter::index(oop param) {
3345   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3346   return param-&gt;int_field(index_offset);
3347 }
3348 
3349 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3350   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3351   param-&gt;int_field_put(index_offset, value);
3352 }
3353 
3354 oop java_lang_reflect_Parameter::executable(oop param) {
3355   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3356   return param-&gt;obj_field(executable_offset);
3357 }
3358 
3359 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3360   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3361   param-&gt;obj_field_put(executable_offset, value);
3362 }
3363 
3364 
3365 int java_lang_Module::loader_offset;
3366 int java_lang_Module::name_offset;
3367 int java_lang_Module::_module_entry_offset = -1;
3368 
3369 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3370   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3371   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3372                           vmSymbols::java_lang_module_init_signature(),
3373                           loader, module_name, CHECK_NH);
3374 }
3375 
3376 #define MODULE_FIELDS_DO(macro) \
3377   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3378   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3379 
3380 void java_lang_Module::compute_offsets() {
3381   InstanceKlass* k = SystemDictionary::Module_klass();
3382   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3383   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3384 }
3385 
3386 #if INCLUDE_CDS
3387 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3388   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3389   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3390 }
3391 #endif
3392 
3393 oop java_lang_Module::loader(oop module) {
3394   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3395   return module-&gt;obj_field(loader_offset);
3396 }
3397 
3398 void java_lang_Module::set_loader(oop module, oop value) {
3399   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3400   module-&gt;obj_field_put(loader_offset, value);
3401 }
3402 
3403 oop java_lang_Module::name(oop module) {
3404   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3405   return module-&gt;obj_field(name_offset);
3406 }
3407 
3408 void java_lang_Module::set_name(oop module, oop value) {
3409   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3410   module-&gt;obj_field_put(name_offset, value);
3411 }
3412 
3413 ModuleEntry* java_lang_Module::module_entry(oop module) {
3414   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3415   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3416   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3417 
3418   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3419   if (module_entry == NULL) {
3420     // If the inject field containing the ModuleEntry* is null then return the
3421     // class loader&#39;s unnamed module.
3422     oop loader = java_lang_Module::loader(module);
3423     Handle h_loader = Handle(Thread::current(), loader);
3424     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3425     return loader_cld-&gt;unnamed_module();
3426   }
3427   return module_entry;
3428 }
3429 
3430 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3431   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3432   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3433   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3434   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3435 }
3436 
3437 Handle reflect_ConstantPool::create(TRAPS) {
3438   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3439   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3440   // Ensure it is initialized
3441   k-&gt;initialize(CHECK_NH);
3442   return k-&gt;allocate_instance_handle(THREAD);
3443 }
3444 
3445 
3446 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3447   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3448   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3449   // Save the mirror to get back the constant pool.
3450   reflect-&gt;obj_field_put(_oop_offset, mirror);
3451 }
3452 
3453 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3454   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3455 
3456   oop mirror = reflect-&gt;obj_field(_oop_offset);
3457   Klass* k = java_lang_Class::as_Klass(mirror);
3458   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3459 
3460   // Get the constant pool back from the klass.  Since class redefinition
3461   // merges the new constant pool into the old, this is essentially the
3462   // same constant pool as the original.  If constant pool merging is
3463   // no longer done in the future, this will have to change to save
3464   // the original.
3465   return InstanceKlass::cast(k)-&gt;constants();
3466 }
3467 
3468 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3469   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3470 
3471 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3472   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3473   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3474 }
3475 
3476 #if INCLUDE_CDS
3477 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3478   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3479 }
3480 #endif
3481 
3482 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3483   Klass* k = SystemDictionary::box_klass(type);
3484   if (k == NULL)  return NULL;
3485   InstanceKlass* ik = InstanceKlass::cast(k);
3486   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3487   return ik-&gt;allocate_instance(THREAD);
3488 }
3489 
3490 
3491 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3492   oop box = initialize_and_allocate(type, CHECK_NULL);
3493   if (box == NULL)  return NULL;
3494   switch (type) {
3495     case T_BOOLEAN:
3496       box-&gt;bool_field_put(value_offset, value-&gt;z);
3497       break;
3498     case T_CHAR:
3499       box-&gt;char_field_put(value_offset, value-&gt;c);
3500       break;
3501     case T_FLOAT:
3502       box-&gt;float_field_put(value_offset, value-&gt;f);
3503       break;
3504     case T_DOUBLE:
3505       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3506       break;
3507     case T_BYTE:
3508       box-&gt;byte_field_put(value_offset, value-&gt;b);
3509       break;
3510     case T_SHORT:
3511       box-&gt;short_field_put(value_offset, value-&gt;s);
3512       break;
3513     case T_INT:
3514       box-&gt;int_field_put(value_offset, value-&gt;i);
3515       break;
3516     case T_LONG:
3517       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3518       break;
3519     default:
3520       return NULL;
3521   }
3522   return box;
3523 }
3524 
3525 
3526 BasicType java_lang_boxing_object::basic_type(oop box) {
3527   if (box == NULL)  return T_ILLEGAL;
3528   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3529   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3530     return T_ILLEGAL;
3531   return type;
3532 }
3533 
3534 
3535 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3536   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3537   switch (type) {
3538   case T_BOOLEAN:
3539     value-&gt;z = box-&gt;bool_field(value_offset);
3540     break;
3541   case T_CHAR:
3542     value-&gt;c = box-&gt;char_field(value_offset);
3543     break;
3544   case T_FLOAT:
3545     value-&gt;f = box-&gt;float_field(value_offset);
3546     break;
3547   case T_DOUBLE:
3548     value-&gt;d = box-&gt;double_field(long_value_offset);
3549     break;
3550   case T_BYTE:
3551     value-&gt;b = box-&gt;byte_field(value_offset);
3552     break;
3553   case T_SHORT:
3554     value-&gt;s = box-&gt;short_field(value_offset);
3555     break;
3556   case T_INT:
3557     value-&gt;i = box-&gt;int_field(value_offset);
3558     break;
3559   case T_LONG:
3560     value-&gt;j = box-&gt;long_field(long_value_offset);
3561     break;
3562   default:
3563     return T_ILLEGAL;
3564   } // end switch
3565   return type;
3566 }
3567 
3568 
3569 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3570   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3571   switch (type) {
3572   case T_BOOLEAN:
3573     box-&gt;bool_field_put(value_offset, value-&gt;z);
3574     break;
3575   case T_CHAR:
3576     box-&gt;char_field_put(value_offset, value-&gt;c);
3577     break;
3578   case T_FLOAT:
3579     box-&gt;float_field_put(value_offset, value-&gt;f);
3580     break;
3581   case T_DOUBLE:
3582     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3583     break;
3584   case T_BYTE:
3585     box-&gt;byte_field_put(value_offset, value-&gt;b);
3586     break;
3587   case T_SHORT:
3588     box-&gt;short_field_put(value_offset, value-&gt;s);
3589     break;
3590   case T_INT:
3591     box-&gt;int_field_put(value_offset, value-&gt;i);
3592     break;
3593   case T_LONG:
3594     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3595     break;
3596   default:
3597     return T_ILLEGAL;
3598   } // end switch
3599   return type;
3600 }
3601 
3602 
3603 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3604   switch (type) {
3605   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3606   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3607   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3608   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3609   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3610   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3611   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3612   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3613   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3614   }
3615 }
3616 
3617 // Support for java_lang_ref_Reference
3618 
3619 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3620   assert(obj != NULL, &quot;sanity&quot;);
3621   if (offset != java_lang_ref_Reference::referent_offset) {
3622     return false;
3623   }
3624 
3625   Klass* k = obj-&gt;klass();
3626   if (!k-&gt;is_instance_klass()) {
3627     return false;
3628   }
3629 
3630   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3631   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3632   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3633   return is_reference;
3634 }
3635 
3636 #define REFERENCE_FIELDS_DO(macro) \
3637   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \
3638   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \
3639   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \
3640   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);
3641 
3642 void java_lang_ref_Reference::compute_offsets() {
3643   if (_offsets_initialized) {
3644     return;
3645   }
3646   _offsets_initialized = true;
3647   InstanceKlass* k = SystemDictionary::Reference_klass();
3648   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3649 }
3650 
3651 #if INCLUDE_CDS
3652 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {
3653   f-&gt;do_bool(&amp;_offsets_initialized);
3654   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3655 }
3656 #endif
3657 
3658 #define BOXING_FIELDS_DO(macro) \
3659   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \
3660   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);
3661 
3662 void java_lang_boxing_object::compute_offsets() {
3663   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();
3664   InstanceKlass* longKlass = SystemDictionary::Long_klass();
3665   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3666 }
3667 
3668 #if INCLUDE_CDS
3669 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {
3670   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3671 }
3672 #endif
3673 
3674 // Support for java_lang_ref_SoftReference
3675 //
3676 
3677 #define SOFTREFERENCE_FIELDS_DO(macro) \
3678   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3679   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3680 
3681 void java_lang_ref_SoftReference::compute_offsets() {
3682   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3683   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3684 }
3685 
3686 #if INCLUDE_CDS
3687 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3688   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3689 }
3690 #endif
3691 
3692 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3693   return ref-&gt;long_field(timestamp_offset);
3694 }
3695 
3696 jlong java_lang_ref_SoftReference::clock() {
3697   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3698   oop base = ik-&gt;static_field_base_raw();
3699   return base-&gt;long_field(static_clock_offset);
3700 }
3701 
3702 void java_lang_ref_SoftReference::set_clock(jlong value) {
3703   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3704   oop base = ik-&gt;static_field_base_raw();
3705   base-&gt;long_field_put(static_clock_offset, value);
3706 }
3707 
3708 // Support for java_lang_invoke_DirectMethodHandle
3709 
3710 int java_lang_invoke_DirectMethodHandle::_member_offset;
3711 
3712 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3713   oop member_name = NULL;
3714   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3715          &quot;a DirectMethodHandle oop is expected&quot;);
3716   return dmh-&gt;obj_field(member_offset_in_bytes());
3717 }
3718 
3719 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3720   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3721 
3722 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3723   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3724   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3725 }
3726 
3727 #if INCLUDE_CDS
3728 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3729   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3730 }
3731 #endif
3732 
3733 // Support for java_lang_invoke_MethodHandle
3734 
3735 int java_lang_invoke_MethodHandle::_type_offset;
3736 int java_lang_invoke_MethodHandle::_form_offset;
3737 
3738 int java_lang_invoke_MemberName::_clazz_offset;
3739 int java_lang_invoke_MemberName::_name_offset;
3740 int java_lang_invoke_MemberName::_type_offset;
3741 int java_lang_invoke_MemberName::_flags_offset;
3742 int java_lang_invoke_MemberName::_method_offset;
3743 int java_lang_invoke_MemberName::_vmindex_offset;
3744 
3745 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3746 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3747 
3748 int java_lang_invoke_LambdaForm::_vmentry_offset;
3749 
3750 #define METHODHANDLE_FIELDS_DO(macro) \
3751   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3752   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3753 
3754 void java_lang_invoke_MethodHandle::compute_offsets() {
3755   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3756   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3757 }
3758 
3759 #if INCLUDE_CDS
3760 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3761   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3762 }
3763 #endif
3764 
3765 #define MEMBERNAME_FIELDS_DO(macro) \
3766   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3767   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3768   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3769   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3770   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3771 
3772 void java_lang_invoke_MemberName::compute_offsets() {
3773   InstanceKlass* k = SystemDictionary::MemberName_klass();
3774   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3775   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3776 }
3777 
3778 #if INCLUDE_CDS
3779 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3780   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3781   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3782 }
3783 #endif
3784 
3785 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3786   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3787   assert(k != NULL, &quot;jdk mismatch&quot;);
3788   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3789 }
3790 
3791 #if INCLUDE_CDS
3792 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3793   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3794 }
3795 #endif
3796 
3797 #define LAMBDAFORM_FIELDS_DO(macro) \
3798   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3799 
3800 void java_lang_invoke_LambdaForm::compute_offsets() {
3801   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3802   assert (k != NULL, &quot;jdk mismatch&quot;);
3803   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3804 }
3805 
3806 #if INCLUDE_CDS
3807 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3808   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3809 }
3810 #endif
3811 
3812 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3813   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3814 }
3815 
3816 
3817 oop java_lang_invoke_MethodHandle::type(oop mh) {
3818   return mh-&gt;obj_field(_type_offset);
3819 }
3820 
3821 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3822   mh-&gt;obj_field_put(_type_offset, mtype);
3823 }
3824 
3825 oop java_lang_invoke_MethodHandle::form(oop mh) {
3826   assert(_form_offset != 0, &quot;&quot;);
3827   return mh-&gt;obj_field(_form_offset);
3828 }
3829 
3830 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3831   assert(_form_offset != 0, &quot;&quot;);
3832   mh-&gt;obj_field_put(_form_offset, lform);
3833 }
3834 
3835 /// MemberName accessors
3836 
3837 oop java_lang_invoke_MemberName::clazz(oop mname) {
3838   assert(is_instance(mname), &quot;wrong type&quot;);
3839   return mname-&gt;obj_field(_clazz_offset);
3840 }
3841 
3842 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3843   assert(is_instance(mname), &quot;wrong type&quot;);
3844   mname-&gt;obj_field_put(_clazz_offset, clazz);
3845 }
3846 
3847 oop java_lang_invoke_MemberName::name(oop mname) {
3848   assert(is_instance(mname), &quot;wrong type&quot;);
3849   return mname-&gt;obj_field(_name_offset);
3850 }
3851 
3852 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3853   assert(is_instance(mname), &quot;wrong type&quot;);
3854   mname-&gt;obj_field_put(_name_offset, name);
3855 }
3856 
3857 oop java_lang_invoke_MemberName::type(oop mname) {
3858   assert(is_instance(mname), &quot;wrong type&quot;);
3859   return mname-&gt;obj_field(_type_offset);
3860 }
3861 
3862 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3863   assert(is_instance(mname), &quot;wrong type&quot;);
3864   mname-&gt;obj_field_put(_type_offset, type);
3865 }
3866 
3867 int java_lang_invoke_MemberName::flags(oop mname) {
3868   assert(is_instance(mname), &quot;wrong type&quot;);
3869   return mname-&gt;int_field(_flags_offset);
3870 }
3871 
3872 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3873   assert(is_instance(mname), &quot;wrong type&quot;);
3874   mname-&gt;int_field_put(_flags_offset, flags);
3875 }
3876 
3877 
3878 // Return vmtarget from ResolvedMethodName method field through indirection
3879 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3880   assert(is_instance(mname), &quot;wrong type&quot;);
3881   oop method = mname-&gt;obj_field(_method_offset);
3882   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3883 }
3884 
3885 bool java_lang_invoke_MemberName::is_method(oop mname) {
3886   assert(is_instance(mname), &quot;must be MemberName&quot;);
<a name="13" id="anc13"></a><span class="line-modified">3887   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3888 }
3889 
3890 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3891   assert(is_instance(mname), &quot;wrong type&quot;);
3892   mname-&gt;obj_field_put(_method_offset, resolved_method);
3893 }
3894 
3895 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3896   assert(is_instance(mname), &quot;wrong type&quot;);
3897   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3898 }
3899 
3900 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3901   assert(is_instance(mname), &quot;wrong type&quot;);
3902   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3903 }
3904 
3905 
3906 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3907   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3908   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3909   assert(m-&gt;is_method(), &quot;must be&quot;);
3910   return m;
3911 }
3912 
3913 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3914 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3915   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3916   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3917 }
3918 
3919 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
3920   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3921   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
3922 }
3923 
3924 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
3925   const Method* method = m();
3926 
3927   // lookup ResolvedMethod oop in the table, or create a new one and intern it
3928   oop resolved_method = ResolvedMethodTable::find_method(method);
3929   if (resolved_method != NULL) {
3930     return resolved_method;
3931   }
3932 
3933   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3934   if (!k-&gt;is_initialized()) {
3935     k-&gt;initialize(CHECK_NULL);
3936   }
3937 
3938   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
3939 
3940   NoSafepointVerifier nsv;
3941 
3942   if (method-&gt;is_old()) {
3943     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
3944                                       method-&gt;get_new_method();
3945   }
3946 
3947   InstanceKlass* holder = method-&gt;method_holder();
3948 
3949   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
3950   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
3951   // distinct loaders) to ensure the metadata is kept alive.
3952   // This mirror may be different than the one in clazz field.
3953   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
3954 
3955   // Set flag in class to indicate this InstanceKlass has entries in the table
3956   // to avoid walking table during redefinition if none of the redefined classes
3957   // have any membernames in the table.
3958   holder-&gt;set_has_resolved_methods();
3959 
3960   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
3961 }
3962 
3963 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3964   assert(is_instance(lform), &quot;wrong type&quot;);
3965   return lform-&gt;obj_field(_vmentry_offset);
3966 }
3967 
3968 
3969 // Support for java_lang_invoke_MethodType
3970 
3971 int java_lang_invoke_MethodType::_rtype_offset;
3972 int java_lang_invoke_MethodType::_ptypes_offset;
3973 
3974 #define METHODTYPE_FIELDS_DO(macro) \
3975   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3976   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3977 
3978 void java_lang_invoke_MethodType::compute_offsets() {
3979   InstanceKlass* k = SystemDictionary::MethodType_klass();
3980   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3981 }
3982 
3983 #if INCLUDE_CDS
3984 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3985   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3986 }
3987 #endif
3988 
3989 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3990   st-&gt;print(&quot;(&quot;);
3991   objArrayOop pts = ptypes(mt);
3992   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3993     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3994   }
3995   st-&gt;print(&quot;)&quot;);
3996   java_lang_Class::print_signature(rtype(mt), st);
3997 }
3998 
3999 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
4000   ResourceMark rm;
4001   stringStream buffer(128);
4002   print_signature(mt, &amp;buffer);
4003   const char* sigstr =       buffer.base();
4004   int         siglen = (int) buffer.size();
4005   Symbol *name;
4006   if (!intern_if_not_found) {
4007     name = SymbolTable::probe(sigstr, siglen);
4008   } else {
4009     name = SymbolTable::new_symbol(sigstr, siglen);
4010   }
4011   return name;
4012 }
4013 
4014 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
4015   if (mt1 == mt2)
4016     return true;
4017   if (rtype(mt1) != rtype(mt2))
4018     return false;
4019   if (ptype_count(mt1) != ptype_count(mt2))
4020     return false;
4021   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
4022     if (ptype(mt1, i) != ptype(mt2, i))
4023       return false;
4024   }
4025   return true;
4026 }
4027 
4028 oop java_lang_invoke_MethodType::rtype(oop mt) {
4029   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4030   return mt-&gt;obj_field(_rtype_offset);
4031 }
4032 
4033 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
4034   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4035   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
4036 }
4037 
4038 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
4039   return ptypes(mt)-&gt;obj_at(idx);
4040 }
4041 
4042 int java_lang_invoke_MethodType::ptype_count(oop mt) {
4043   return ptypes(mt)-&gt;length();
4044 }
4045 
4046 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
4047   objArrayOop pts = ptypes(mt);
4048   int count = pts-&gt;length();
4049   int slots = 0;
4050   for (int i = 0; i &lt; count; i++) {
4051     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
4052     slots += type2size[bt];
4053   }
4054   return slots;
4055 }
4056 
4057 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
4058   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
4059   return type2size[bt];
4060 }
4061 
4062 
4063 // Support for java_lang_invoke_CallSite
4064 
4065 int java_lang_invoke_CallSite::_target_offset;
4066 int java_lang_invoke_CallSite::_context_offset;
4067 
4068 #define CALLSITE_FIELDS_DO(macro) \
4069   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4070   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4071 
4072 void java_lang_invoke_CallSite::compute_offsets() {
4073   InstanceKlass* k = SystemDictionary::CallSite_klass();
4074   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4075 }
4076 
4077 #if INCLUDE_CDS
4078 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4079   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4080 }
4081 #endif
4082 
4083 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4084   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4085 
4086   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4087   return dep_oop;
4088 }
4089 
4090 // Support for java_lang_invoke_ConstantCallSite
4091 
4092 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4093 
4094 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4095   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4096 
4097 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4098   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4099   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4100 }
4101 
4102 #if INCLUDE_CDS
4103 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4104   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4105 }
4106 #endif
4107 
4108 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4109 
4110 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4111 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4112 
4113 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4114   InstanceKlass* k = SystemDictionary::Context_klass();
4115   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4116 }
4117 
4118 #if INCLUDE_CDS
4119 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4120   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4121 }
4122 #endif
4123 
4124 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4125   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4126   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4127   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4128   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4129   return dep_ctx;
4130 }
4131 
4132 // Support for java_security_AccessControlContext
4133 
4134 int java_security_AccessControlContext::_context_offset = 0;
4135 int java_security_AccessControlContext::_privilegedContext_offset = 0;
4136 int java_security_AccessControlContext::_isPrivileged_offset = 0;
4137 int java_security_AccessControlContext::_isAuthorized_offset = -1;
4138 
4139 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4140   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4141   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4142   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4143   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4144 
4145 void java_security_AccessControlContext::compute_offsets() {
4146   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4147   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4148   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4149 }
4150 
4151 #if INCLUDE_CDS
4152 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4153   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4154 }
4155 #endif
4156 
4157 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4158   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4159   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4160   // Ensure klass is initialized
4161   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4162   // Allocate result
4163   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4164   // Fill in values
4165   result-&gt;obj_field_put(_context_offset, context());
4166   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4167   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4168   // whitelist AccessControlContexts created by the JVM
4169   result-&gt;bool_field_put(_isAuthorized_offset, true);
4170   return result;
4171 }
4172 
4173 
4174 // Support for java_lang_ClassLoader
4175 
4176 bool java_lang_ClassLoader::offsets_computed = false;
4177 int  java_lang_ClassLoader::_loader_data_offset = -1;
4178 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4179 int  java_lang_ClassLoader::name_offset = -1;
4180 int  java_lang_ClassLoader::nameAndId_offset = -1;
4181 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4182 
4183 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4184   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4185   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4186   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4187 }
4188 
4189 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4190   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4191   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4192   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4193 }
4194 
4195 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4196   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4197   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4198   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4199 }
4200 
4201 #define CLASSLOADER_FIELDS_DO(macro) \
4202   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4203   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4204   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4205   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4206   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4207 
4208 void java_lang_ClassLoader::compute_offsets() {
4209   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4210   offsets_computed = true;
4211 
4212   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4213   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4214 
4215   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4216 }
4217 
4218 #if INCLUDE_CDS
4219 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4220   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4221   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4222 }
4223 #endif
4224 
4225 oop java_lang_ClassLoader::parent(oop loader) {
4226   assert(is_instance(loader), &quot;loader must be oop&quot;);
4227   return loader-&gt;obj_field(parent_offset);
4228 }
4229 
4230 // Returns the name field of this class loader.  If the name field has not
4231 // been set, null will be returned.
4232 oop java_lang_ClassLoader::name(oop loader) {
4233   assert(is_instance(loader), &quot;loader must be oop&quot;);
4234   return loader-&gt;obj_field(name_offset);
4235 }
4236 
4237 // Returns the nameAndId field of this class loader. The format is
4238 // as follows:
4239 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4240 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4241 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4242 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4243 oop java_lang_ClassLoader::nameAndId(oop loader) {
4244   assert(is_instance(loader), &quot;loader must be oop&quot;);
4245   return loader-&gt;obj_field(nameAndId_offset);
4246 }
4247 
4248 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4249   assert(is_instance(loader), &quot;loader must be oop&quot;);
4250   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4251   oop acl = loader;
4252   debug_only(jint loop_count = 0);
4253   // This loop taken verbatim from ClassLoader.java:
4254   do {
4255     acl = parent(acl);
4256     if (cl == acl) {
4257       return true;
4258     }
4259     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4260   } while (acl != NULL);
4261   return false;
4262 }
4263 
4264 bool java_lang_ClassLoader::is_instance(oop obj) {
4265   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4266 }
4267 
4268 
4269 // For class loader classes, parallelCapable defined
4270 // based on non-null field
4271 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4272 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4273   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);
4274   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4275 }
4276 
4277 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4278   // Fix for 4474172; see evaluation for more details
4279   loader = non_reflection_class_loader(loader);
4280 
4281   oop cl = SystemDictionary::java_system_loader();
4282   while(cl != NULL) {
4283     if (cl == loader) return true;
4284     cl = parent(cl);
4285   }
4286   return false;
4287 }
4288 
4289 // Return true if this is one of the class loaders associated with
4290 // the generated bytecodes for reflection.
4291 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4292   if (loader != NULL) {
4293     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4294     // This might be null in non-1.4 JDKs
4295     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4296   }
4297   return false;
4298 }
4299 
4300 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4301   // See whether this is one of the class loaders associated with
4302   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4303   // delegate to its parent to prevent class loading from occurring
4304   // in places where applications using reflection didn&#39;t expect it.
4305   if (is_reflection_class_loader(loader)) {
4306     return parent(loader);
4307   }
4308   return loader;
4309 }
4310 
4311 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4312   assert(is_instance(loader), &quot;loader must be oop&quot;);
4313   return loader-&gt;obj_field(unnamedModule_offset);
4314 }
4315 
4316 // Support for java_lang_System
4317 //
4318 #define SYSTEM_FIELDS_DO(macro) \
4319   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4320   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4321   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4322   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4323 
4324 void java_lang_System::compute_offsets() {
4325   InstanceKlass* k = SystemDictionary::System_klass();
4326   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4327 }
4328 
4329 #if INCLUDE_CDS
4330 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4331    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4332 }
4333 #endif
4334 
4335 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4336 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4337 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4338 
4339 // Support for jdk_internal_misc_UnsafeConstants
4340 //
4341 class UnsafeConstantsFixup : public FieldClosure {
4342 private:
4343   int _address_size;
4344   int _page_size;
4345   bool _big_endian;
4346   bool _use_unaligned_access;
4347   int _data_cache_line_flush_size;
4348 public:
4349   UnsafeConstantsFixup() {
4350     // round up values for all static final fields
4351     _address_size = sizeof(void*);
4352     _page_size = os::vm_page_size();
4353     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4354     _use_unaligned_access = UseUnalignedAccesses;
4355     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4356   }
4357 
4358   void do_field(fieldDescriptor* fd) {
4359     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4360     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4361     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4362     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4363     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4364     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4365       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4366     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4367       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4368     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4369       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4370     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4371       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4372     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4373       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4374     } else {
4375       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4376     }
4377   }
4378 };
4379 
4380 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4381   UnsafeConstantsFixup fixup;
4382   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4383 }
4384 
4385 int java_lang_Class::_klass_offset;
4386 int java_lang_Class::_array_klass_offset;
4387 int java_lang_Class::_oop_size_offset;
4388 int java_lang_Class::_static_oop_field_count_offset;
4389 int java_lang_Class::_class_loader_offset;
4390 int java_lang_Class::_module_offset;
4391 int java_lang_Class::_protection_domain_offset;
4392 int java_lang_Class::_component_mirror_offset;
<a name="14" id="anc14"></a><span class="line-added">4393 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added">4394 int java_lang_Class::_ref_type_mirror_offset;</span>
4395 int java_lang_Class::_init_lock_offset;
4396 int java_lang_Class::_signers_offset;
4397 int java_lang_Class::_name_offset;
4398 int java_lang_Class::_source_file_offset;
4399 int java_lang_Class::_classData_offset;
4400 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4401 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4402 int java_lang_Throwable::backtrace_offset;
4403 int java_lang_Throwable::detailMessage_offset;
4404 int java_lang_Throwable::stackTrace_offset;
4405 int java_lang_Throwable::depth_offset;
4406 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4407 int java_lang_reflect_AccessibleObject::override_offset;
4408 int java_lang_reflect_Method::clazz_offset;
4409 int java_lang_reflect_Method::name_offset;
4410 int java_lang_reflect_Method::returnType_offset;
4411 int java_lang_reflect_Method::parameterTypes_offset;
4412 int java_lang_reflect_Method::exceptionTypes_offset;
4413 int java_lang_reflect_Method::slot_offset;
4414 int java_lang_reflect_Method::modifiers_offset;
4415 int java_lang_reflect_Method::signature_offset;
4416 int java_lang_reflect_Method::annotations_offset;
4417 int java_lang_reflect_Method::parameter_annotations_offset;
4418 int java_lang_reflect_Method::annotation_default_offset;
4419 int java_lang_reflect_Constructor::clazz_offset;
4420 int java_lang_reflect_Constructor::parameterTypes_offset;
4421 int java_lang_reflect_Constructor::exceptionTypes_offset;
4422 int java_lang_reflect_Constructor::slot_offset;
4423 int java_lang_reflect_Constructor::modifiers_offset;
4424 int java_lang_reflect_Constructor::signature_offset;
4425 int java_lang_reflect_Constructor::annotations_offset;
4426 int java_lang_reflect_Constructor::parameter_annotations_offset;
4427 int java_lang_reflect_Field::clazz_offset;
4428 int java_lang_reflect_Field::name_offset;
4429 int java_lang_reflect_Field::type_offset;
4430 int java_lang_reflect_Field::slot_offset;
4431 int java_lang_reflect_Field::modifiers_offset;
4432 int java_lang_reflect_Field::signature_offset;
4433 int java_lang_reflect_Field::annotations_offset;
4434 int java_lang_reflect_Parameter::name_offset;
4435 int java_lang_reflect_Parameter::modifiers_offset;
4436 int java_lang_reflect_Parameter::index_offset;
4437 int java_lang_reflect_Parameter::executable_offset;
4438 int java_lang_boxing_object::value_offset;
4439 int java_lang_boxing_object::long_value_offset;
4440 bool java_lang_ref_Reference::_offsets_initialized;
4441 int java_lang_ref_Reference::referent_offset;
4442 int java_lang_ref_Reference::queue_offset;
4443 int java_lang_ref_Reference::next_offset;
4444 int java_lang_ref_Reference::discovered_offset;
4445 int java_lang_ref_SoftReference::timestamp_offset;
4446 int java_lang_ref_SoftReference::static_clock_offset;
4447 int java_lang_ClassLoader::parent_offset;
4448 int java_lang_System::static_in_offset;
4449 int java_lang_System::static_out_offset;
4450 int java_lang_System::static_err_offset;
4451 int java_lang_System::static_security_offset;
4452 int java_lang_StackTraceElement::methodName_offset;
4453 int java_lang_StackTraceElement::fileName_offset;
4454 int java_lang_StackTraceElement::lineNumber_offset;
4455 int java_lang_StackTraceElement::moduleName_offset;
4456 int java_lang_StackTraceElement::moduleVersion_offset;
4457 int java_lang_StackTraceElement::classLoaderName_offset;
4458 int java_lang_StackTraceElement::declaringClass_offset;
4459 int java_lang_StackTraceElement::declaringClassObject_offset;
4460 int java_lang_StackFrameInfo::_memberName_offset;
4461 int java_lang_StackFrameInfo::_bci_offset;
4462 int java_lang_StackFrameInfo::_version_offset;
4463 int java_lang_LiveStackFrameInfo::_monitors_offset;
4464 int java_lang_LiveStackFrameInfo::_locals_offset;
4465 int java_lang_LiveStackFrameInfo::_operands_offset;
4466 int java_lang_LiveStackFrameInfo::_mode_offset;
4467 int java_lang_AssertionStatusDirectives::classes_offset;
4468 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4469 int java_lang_AssertionStatusDirectives::packages_offset;
4470 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4471 int java_lang_AssertionStatusDirectives::deflt_offset;
4472 int java_nio_Buffer::_limit_offset;
4473 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4474 int reflect_ConstantPool::_oop_offset;
4475 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4476 int java_lang_Integer_IntegerCache::_static_cache_offset;
4477 int java_lang_Long_LongCache::_static_cache_offset;
4478 int java_lang_Character_CharacterCache::_static_cache_offset;
4479 int java_lang_Short_ShortCache::_static_cache_offset;
4480 int java_lang_Byte_ByteCache::_static_cache_offset;
4481 int java_lang_Boolean::_static_TRUE_offset;
4482 int java_lang_Boolean::_static_FALSE_offset;
4483 int java_lang_reflect_RecordComponent::clazz_offset;
4484 int java_lang_reflect_RecordComponent::name_offset;
4485 int java_lang_reflect_RecordComponent::type_offset;
4486 int java_lang_reflect_RecordComponent::accessor_offset;
4487 int java_lang_reflect_RecordComponent::signature_offset;
4488 int java_lang_reflect_RecordComponent::annotations_offset;
4489 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<a name="15" id="anc15"></a><span class="line-added">4490 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4491 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4492 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4493 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4494 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4495 
4496 
4497 
4498 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4499   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4500   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4501   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4502   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4503   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4504   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4505   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4506   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4507 
4508 // Support for java_lang_StackTraceElement
4509 void java_lang_StackTraceElement::compute_offsets() {
4510   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4511   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4512 }
4513 
4514 #if INCLUDE_CDS
4515 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4516   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4517 }
4518 #endif
4519 
4520 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4521   element-&gt;obj_field_put(fileName_offset, value);
4522 }
4523 
4524 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4525   element-&gt;obj_field_put(declaringClass_offset, value);
4526 }
4527 
4528 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4529   element-&gt;obj_field_put(methodName_offset, value);
4530 }
4531 
4532 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4533   element-&gt;int_field_put(lineNumber_offset, value);
4534 }
4535 
4536 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4537   element-&gt;obj_field_put(moduleName_offset, value);
4538 }
4539 
4540 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4541   element-&gt;obj_field_put(moduleVersion_offset, value);
4542 }
4543 
4544 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4545   element-&gt;obj_field_put(classLoaderName_offset, value);
4546 }
4547 
4548 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4549   element-&gt;obj_field_put(declaringClassObject_offset, value);
4550 }
4551 
4552 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4553   element-&gt;short_field_put(_version_offset, value);
4554 }
4555 
4556 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
4557   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
4558   element-&gt;int_field_put(_bci_offset, value);
4559 }
4560 
4561 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4562   element-&gt;obj_field_put(_monitors_offset, value);
4563 }
4564 
4565 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4566   element-&gt;obj_field_put(_locals_offset, value);
4567 }
4568 
4569 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4570   element-&gt;obj_field_put(_operands_offset, value);
4571 }
4572 
4573 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4574   element-&gt;int_field_put(_mode_offset, value);
4575 }
4576 
4577 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4578 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4579   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4580   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4581   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4582   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4583   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4584 
4585 void java_lang_AssertionStatusDirectives::compute_offsets() {
4586   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4587   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4588 }
4589 
4590 #if INCLUDE_CDS
4591 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4592   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4593 }
4594 #endif
4595 
4596 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4597   o-&gt;obj_field_put(classes_offset, val);
4598 }
4599 
4600 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4601   o-&gt;obj_field_put(classEnabled_offset, val);
4602 }
4603 
4604 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4605   o-&gt;obj_field_put(packages_offset, val);
4606 }
4607 
4608 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4609   o-&gt;obj_field_put(packageEnabled_offset, val);
4610 }
4611 
4612 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4613   o-&gt;bool_field_put(deflt_offset, val);
4614 }
4615 
4616 
4617 // Support for intrinsification of java.nio.Buffer.checkIndex
4618 int java_nio_Buffer::limit_offset() {
4619   return _limit_offset;
4620 }
4621 
4622 #define BUFFER_FIELDS_DO(macro) \
4623   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4624 
4625 void java_nio_Buffer::compute_offsets() {
4626   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4627   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4628   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4629 }
4630 
4631 #if INCLUDE_CDS
4632 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4633   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4634 }
4635 #endif
4636 
4637 #define AOS_FIELDS_DO(macro) \
4638   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4639 
4640 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4641   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4642   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4643 }
4644 
4645 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4646   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4647   return obj-&gt;obj_field(_owner_offset);
4648 }
4649 
4650 #if INCLUDE_CDS
4651 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4652   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4653 }
4654 #endif
4655 
4656 #define INTEGER_CACHE_FIELDS_DO(macro) \
4657   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4658 
4659 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4660   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4661   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4662 }
4663 
4664 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4665   oop base = ik-&gt;static_field_base_raw();
4666   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4667 }
4668 
4669 Symbol* java_lang_Integer_IntegerCache::symbol() {
4670   return vmSymbols::java_lang_Integer_IntegerCache();
4671 }
4672 
4673 #if INCLUDE_CDS
4674 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4675   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4676 }
4677 #endif
4678 #undef INTEGER_CACHE_FIELDS_DO
4679 
4680 jint java_lang_Integer::value(oop obj) {
4681    jvalue v;
4682    java_lang_boxing_object::get_value(obj, &amp;v);
4683    return v.i;
4684 }
4685 
4686 #define LONG_CACHE_FIELDS_DO(macro) \
4687   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4688 
4689 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4690   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4691   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4692 }
4693 
4694 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4695   oop base = ik-&gt;static_field_base_raw();
4696   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4697 }
4698 
4699 Symbol* java_lang_Long_LongCache::symbol() {
4700   return vmSymbols::java_lang_Long_LongCache();
4701 }
4702 
4703 #if INCLUDE_CDS
4704 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4705   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4706 }
4707 #endif
4708 #undef LONG_CACHE_FIELDS_DO
4709 
4710 jlong java_lang_Long::value(oop obj) {
4711    jvalue v;
4712    java_lang_boxing_object::get_value(obj, &amp;v);
4713    return v.j;
4714 }
4715 
4716 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4717   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4718 
4719 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4720   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4721   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4722 }
4723 
4724 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4725   oop base = ik-&gt;static_field_base_raw();
4726   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4727 }
4728 
4729 Symbol* java_lang_Character_CharacterCache::symbol() {
4730   return vmSymbols::java_lang_Character_CharacterCache();
4731 }
4732 
4733 #if INCLUDE_CDS
4734 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4735   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4736 }
4737 #endif
4738 #undef CHARACTER_CACHE_FIELDS_DO
4739 
4740 jchar java_lang_Character::value(oop obj) {
4741    jvalue v;
4742    java_lang_boxing_object::get_value(obj, &amp;v);
4743    return v.c;
4744 }
4745 
4746 #define SHORT_CACHE_FIELDS_DO(macro) \
4747   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4748 
4749 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4750   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4751   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4752 }
4753 
4754 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4755   oop base = ik-&gt;static_field_base_raw();
4756   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4757 }
4758 
4759 Symbol* java_lang_Short_ShortCache::symbol() {
4760   return vmSymbols::java_lang_Short_ShortCache();
4761 }
4762 
4763 #if INCLUDE_CDS
4764 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4765   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4766 }
4767 #endif
4768 #undef SHORT_CACHE_FIELDS_DO
4769 
4770 jshort java_lang_Short::value(oop obj) {
4771    jvalue v;
4772    java_lang_boxing_object::get_value(obj, &amp;v);
4773    return v.s;
4774 }
4775 
4776 #define BYTE_CACHE_FIELDS_DO(macro) \
4777   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4778 
4779 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4780   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4781   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4782 }
4783 
4784 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4785   oop base = ik-&gt;static_field_base_raw();
4786   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4787 }
4788 
4789 Symbol* java_lang_Byte_ByteCache::symbol() {
4790   return vmSymbols::java_lang_Byte_ByteCache();
4791 }
4792 
4793 #if INCLUDE_CDS
4794 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4795   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4796 }
4797 #endif
4798 #undef BYTE_CACHE_FIELDS_DO
4799 
<a name="16" id="anc16"></a><span class="line-added">4800 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4801   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4802   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4803   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4804   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4805   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4806 </span>
<span class="line-added">4807 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4808   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4809   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4810 }</span>
<span class="line-added">4811 </span>
<span class="line-added">4812 #if INCLUDE_CDS</span>
<span class="line-added">4813 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4814   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 #endif</span>
<span class="line-added">4817 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4818 </span>
<span class="line-added">4819 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4820   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4821 }</span>
<span class="line-added">4822 </span>
<span class="line-added">4823 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4824   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4825 }</span>
<span class="line-added">4826 </span>
<span class="line-added">4827 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4828   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4829 }</span>
<span class="line-added">4830 </span>
<span class="line-added">4831 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4832   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4833 }</span>
<span class="line-added">4834 </span>
<span class="line-added">4835 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4836   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4837 }</span>
<span class="line-added">4838 </span>
<span class="line-added">4839 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4840   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4841 }</span>
<span class="line-added">4842 </span>
<span class="line-added">4843 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4844   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4845 }</span>
<span class="line-added">4846 </span>
<span class="line-added">4847 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4848   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4849 }</span>
<span class="line-added">4850 </span>
<span class="line-added">4851 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4852   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4853 }</span>
<span class="line-added">4854 </span>
<span class="line-added">4855 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4856   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4857 }</span>
<span class="line-added">4858 </span>
<span class="line-added">4859 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4860   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4861 }</span>
<span class="line-added">4862 </span>
4863 jbyte java_lang_Byte::value(oop obj) {
4864    jvalue v;
4865    java_lang_boxing_object::get_value(obj, &amp;v);
4866    return v.b;
4867 }
4868 #define BOOLEAN_FIELDS_DO(macro) \
4869   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4870   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4871 
4872 
4873 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4874   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4875   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4876 }
4877 
4878 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4879   oop base = ik-&gt;static_field_base_raw();
4880   return base-&gt;obj_field(_static_TRUE_offset);
4881 }
4882 
4883 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4884   oop base = ik-&gt;static_field_base_raw();
4885   return base-&gt;obj_field(_static_FALSE_offset);
4886 }
4887 
4888 Symbol* java_lang_Boolean::symbol() {
4889   return vmSymbols::java_lang_Boolean();
4890 }
4891 
4892 #if INCLUDE_CDS
4893 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4894   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4895 }
4896 #endif
4897 #undef BOOLEAN_CACHE_FIELDS_DO
4898 
4899 jboolean java_lang_Boolean::value(oop obj) {
4900    jvalue v;
4901    java_lang_boxing_object::get_value(obj, &amp;v);
4902    return v.z;
4903 }
4904 
4905 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4906   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4907   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4908   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4909   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4910   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4911   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4912   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4913 
4914 // Support for java_lang_reflect_RecordComponent
4915 void java_lang_reflect_RecordComponent::compute_offsets() {
4916   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4917   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4918 }
4919 
4920 #if INCLUDE_CDS
4921 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4922   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4923 }
4924 #endif
4925 
4926 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4927   element-&gt;obj_field_put(clazz_offset, value);
4928 }
4929 
4930 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4931   element-&gt;obj_field_put(name_offset, value);
4932 }
4933 
4934 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4935   element-&gt;obj_field_put(type_offset, value);
4936 }
4937 
4938 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4939   element-&gt;obj_field_put(accessor_offset, value);
4940 }
4941 
4942 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4943   element-&gt;obj_field_put(signature_offset, value);
4944 }
4945 
4946 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4947   element-&gt;obj_field_put(annotations_offset, value);
4948 }
4949 
4950 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4951   element-&gt;obj_field_put(typeAnnotations_offset, value);
4952 }
4953 
4954 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4955 
4956 // Compute non-hard-coded field offsets of all the classes in this file
4957 void JavaClasses::compute_offsets() {
4958   if (UseSharedSpaces) {
4959     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4960                                                          JvmtiExport::has_early_class_hook_env()),
4961                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4962     // None of the classes used by the rest of this function can be replaced by
4963     // JMVTI ClassFileLoadHook.
4964     // We are safe to use the archived offsets, which have already been restored
4965     // by JavaClasses::serialize_offsets, without computing the offsets again.
4966     return;
4967   }
4968 
4969   // We have already called the compute_offsets() of the
4970   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4971   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4972   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4973 }
4974 
4975 #if INCLUDE_CDS
4976 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4977 
4978 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4979   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4980 }
4981 #endif
4982 
4983 #if INCLUDE_CDS_JAVA_HEAP
4984 bool JavaClasses::is_supported_for_archiving(oop obj) {
4985   Klass* klass = obj-&gt;klass();
4986 
4987   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4988       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4989       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4990       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4991       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4992       // So for now we cannot not support these classes for archiving.
4993       //
4994       // These objects typically are not referenced by static fields, but rather by resolved
4995       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4996       klass == SystemDictionary::ResolvedMethodName_klass() ||
4997       klass == SystemDictionary::MemberName_klass() ||
4998       klass == SystemDictionary::Context_klass()) {
4999     return false;
5000   }
5001 
5002   return true;
5003 }
5004 #endif
5005 
5006 #ifndef PRODUCT
5007 
5008 // These functions exist to assert the validity of hard-coded field offsets to guard
5009 // against changes in the class files
5010 
5011 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
5012   EXCEPTION_MARK;
5013   fieldDescriptor fd;
5014   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
5015   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5016   InstanceKlass* ik = InstanceKlass::cast(k);
5017   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5018   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5019   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5020     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5021     return false;
5022   }
5023   if (fd.is_static()) {
5024     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5025     return false;
5026   }
5027   if (fd.offset() == hardcoded_offset ) {
5028     return true;
5029   } else {
5030     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
5031                   klass_name, field_name, hardcoded_offset, fd.offset());
5032     return false;
5033   }
5034 }
5035 
5036 // Check the hard-coded field offsets of all the classes in this file
5037 
5038 void JavaClasses::check_offsets() {
5039   bool valid = true;
5040 
5041 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5042   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
5043 
5044 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5045   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
5046 
5047   // Boxed primitive objects (java_lang_boxing_object)
5048 
5049   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5050   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5051   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5052   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5053   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5054   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5055   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5056   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5057 
5058   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
5059 }
5060 
5061 #endif // PRODUCT
5062 
5063 int InjectedField::compute_offset() {
5064   InstanceKlass* ik = InstanceKlass::cast(klass());
5065   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5066     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5067       // Only look at injected fields
5068       continue;
5069     }
5070     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5071       return fs.offset();
5072     }
5073   }
5074   ResourceMark rm;
5075   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5076 #ifndef PRODUCT
5077   ik-&gt;print();
5078   tty-&gt;print_cr(&quot;all fields:&quot;);
5079   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5080     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
5081   }
5082 #endif //PRODUCT
5083   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
5084   return -1;
5085 }
5086 
5087 void javaClasses_init() {
5088   JavaClasses::compute_offsets();
5089   JavaClasses::check_offsets();
5090   FilteredFieldsMap::initialize();  // must be done after computing offsets.
5091 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 962   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 963   k-&gt;set_modifier_flags(computed_modifiers);
 964   // Class_klass has to be loaded because it is used to allocate
 965   // the mirror.
 966   if (SystemDictionary::Class_klass_loaded()) {
 967     // Allocate mirror (java.lang.Class instance)
 968     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 969     Handle mirror(THREAD, mirror_oop);
 970     Handle comp_mirror;
 971 
 972     // Setup indirection from mirror-&gt;klass
 973     java_lang_Class::set_klass(mirror(), k);
 974 
 975     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 976     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 977 
 978     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 979 
 980     // It might also have a component mirror.  This mirror must already exist.
 981     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 982       if (k-&gt;is_typeArray_klass()) {</span>





 983         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 984         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 985       } else {
 986         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 987         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 988         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 989         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 990       }
 991       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 992 
 993       // Two-way link between the array klass and its component mirror:
 994       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
 995       set_component_mirror(mirror(), comp_mirror());
 996       // See below for ordering dependencies between field array_klass in component mirror
 997       // and java_mirror in this klass.
 998     } else {
 999       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1000 
1001       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1002       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1009       }
1010     }
1011 
1012     // set the classLoader field in the java_lang_Class instance
1013     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1014     set_class_loader(mirror(), class_loader());
1015 
1016     // Setup indirection from klass-&gt;mirror
1017     // after any exceptions can happen during allocations.
1018     k-&gt;set_java_mirror(mirror);
1019 
1020     // Set the module field in the java_lang_Class instance.  This must be done
1021     // after the mirror is set.
1022     set_mirror_module_field(k, mirror, module, THREAD);
1023 
1024     if (comp_mirror() != NULL) {
1025       // Set after k-&gt;java_mirror() is published, because compiled code running
1026       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1027       release_set_array_klass(comp_mirror(), k);
1028     }

















1029   } else {
1030     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1031     fixup_mirror_list()-&gt;push(k);
1032   }
1033 }
1034 
1035 #if INCLUDE_CDS_JAVA_HEAP
1036 // Clears mirror fields. Static final fields with initial values are reloaded
1037 // from constant pool. The object identity hash is in the object header and is
1038 // not affected.
1039 class ResetMirrorField: public FieldClosure {
1040  private:
1041   Handle _m;
1042 
1043  public:
1044   ResetMirrorField(Handle mirror) : _m(mirror) {}
1045 
1046   void do_field(fieldDescriptor* fd) {
1047     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1048     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1165 
1166   // No mirror
1167   oop mirror = k-&gt;java_mirror();
1168   if (mirror == NULL) {
1169     return NULL;
1170   }
1171 
1172   if (k-&gt;is_instance_klass()) {
1173     InstanceKlass *ik = InstanceKlass::cast(k);
1174     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1175 
1176     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1177           ik-&gt;is_shared_app_class())) {
1178       // Archiving mirror for classes from non-builtin loaders is not
1179       // supported. Clear the _java_mirror within the archived class.
1180       k-&gt;set_java_mirror_handle(NULL);
1181       return NULL;
1182     }
1183   }
1184 






1185   // Now start archiving the mirror object
1186   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1187   if (archived_mirror == NULL) {
1188     return NULL;
1189   }
1190 
1191   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1192   if (archived_mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1197 
1198   k-&gt;set_has_raw_archived_mirror();
1199 
1200   ResourceMark rm;
1201   log_trace(cds, heap, mirror)(
1202     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1203     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1204 
</pre>
<hr />
<pre>
1456 oop java_lang_Class::name(Handle java_class, TRAPS) {
1457   assert(_name_offset != 0, &quot;must be set&quot;);
1458   oop o = java_class-&gt;obj_field(_name_offset);
1459   if (o == NULL) {
1460     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1461     java_class-&gt;obj_field_put(_name_offset, o);
1462   }
1463   return o;
1464 }
1465 
1466 oop java_lang_Class::source_file(oop java_class) {
1467   assert(_source_file_offset != 0, &quot;must be set&quot;);
1468   return java_class-&gt;obj_field(_source_file_offset);
1469 }
1470 
1471 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1472   assert(_source_file_offset != 0, &quot;must be set&quot;);
1473   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1474 }
1475 




















1476 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1477   // This should be improved by adding a field at the Java level or by
1478   // introducing a new VM klass (see comment in ClassFileParser)
1479   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1480   if (type != T_VOID) {
1481     Klass* aklass = Universe::typeArrayKlassObj(type);
1482     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1483     release_set_array_klass(java_class, aklass);
1484   }
1485 #ifdef ASSERT
1486   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1487   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1488 #endif
1489   return java_class;
1490 }
1491 
1492 
1493 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1494   //%note memory_2
1495   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1496   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1497   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1498   return k;
1499 }
1500 
1501 
1502 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1503   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1504   java_class-&gt;metadata_field_put(_klass_offset, klass);
1505 }
1506 
1507 
1508 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1509   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1510   Symbol* name = NULL;
1511   bool is_instance = false;

1512   if (is_primitive(java_class)) {
1513     name = vmSymbols::type_signature(primitive_type(java_class));
1514   } else {
1515     Klass* k = as_Klass(java_class);
1516     is_instance = k-&gt;is_instance_klass();

1517     name = k-&gt;name();
1518   }
1519   if (name == NULL) {
1520     st-&gt;print(&quot;&lt;null&gt;&quot;);
1521     return;
1522   }
<span class="line-modified">1523   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1524   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1525   if (is_instance)  st-&gt;print(&quot;;&quot;);
1526 }
1527 
1528 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1529   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1530   Symbol* name;
1531   if (is_primitive(java_class)) {
1532     name = vmSymbols::type_signature(primitive_type(java_class));
1533     // Because this can create a new symbol, the caller has to decrement
1534     // the refcount, so make adjustment here and below for symbols returned
1535     // that are not created or incremented due to a successful lookup.
1536     name-&gt;increment_refcount();
1537   } else {
1538     Klass* k = as_Klass(java_class);
1539     if (!k-&gt;is_instance_klass()) {
1540       name = k-&gt;name();
1541       name-&gt;increment_refcount();
1542     } else {
1543       ResourceMark rm;
1544       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1545       int         siglen = (int) strlen(sigstr);</span>
1546       if (!intern_if_not_found) {
1547         name = SymbolTable::probe(sigstr, siglen);
1548       } else {
1549         name = SymbolTable::new_symbol(sigstr, siglen);
1550       }
1551     }
1552   }
1553   return name;
1554 }
1555 
1556 // Returns the Java name for this Java mirror (Resource allocated)
1557 // See Klass::external_name().
1558 // For primitive type Java mirrors, its type name is returned.
1559 const char* java_lang_Class::as_external_name(oop java_class) {
1560   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1561   const char* name = NULL;
1562   if (is_primitive(java_class)) {
1563     name = type2name(primitive_type(java_class));
1564   } else {
1565     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1610   }
1611 }
1612 
1613 
1614 oop java_lang_Class::primitive_mirror(BasicType t) {
1615   oop mirror = Universe::java_mirror(t);
1616   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1617   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1618   return mirror;
1619 }
1620 
1621 bool java_lang_Class::offsets_computed = false;
1622 int  java_lang_Class::classRedefinedCount_offset = -1;
1623 
1624 #define CLASS_FIELDS_DO(macro) \
1625   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1626   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1627   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1628   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1629   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \


1630   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1631 
1632 void java_lang_Class::compute_offsets() {
1633   if (offsets_computed) {
1634     return;
1635   }
1636 
1637   offsets_computed = true;
1638 
1639   InstanceKlass* k = SystemDictionary::Class_klass();
1640   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1641 
1642   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1643   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1644   // GC treats them the same.
1645   _init_lock_offset = _component_mirror_offset;
1646 
1647   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1648 }
1649 
</pre>
<hr />
<pre>
2485 #endif
2486 
2487     // the format of the stacktrace will be:
2488     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2489     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2490     // - rest of the stack
2491 
2492     if (!skip_fillInStackTrace_check) {
2493       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2494           throwable-&gt;is_a(method-&gt;method_holder())) {
2495         continue;
2496       }
2497       else {
2498         skip_fillInStackTrace_check = true; // gone past them all
2499       }
2500     }
2501     if (!skip_throwableInit_check) {
2502       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2503 
2504       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2505       // This is simlar to classic VM.</span>
<span class="line-modified">2506       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2507           throwable-&gt;is_a(method-&gt;method_holder())) {
2508         continue;
2509       } else {
2510         // there are none or we&#39;ve seen them all - either way stop checking
2511         skip_throwableInit_check = true;
2512       }
2513     }
2514     if (method-&gt;is_hidden()) {
2515       if (skip_hidden) {
2516         if (total_count == 0) {
2517           // The top frame will be hidden from the stack trace.
2518           bt.set_has_hidden_top_frame(CHECK);
2519         }
2520         continue;
2521       }
2522     }
2523     bt.push(method, bci, CHECK);
2524     total_count++;
2525   }
2526 
</pre>
<hr />
<pre>
3807 int java_lang_invoke_MemberName::flags(oop mname) {
3808   assert(is_instance(mname), &quot;wrong type&quot;);
3809   return mname-&gt;int_field(_flags_offset);
3810 }
3811 
3812 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3813   assert(is_instance(mname), &quot;wrong type&quot;);
3814   mname-&gt;int_field_put(_flags_offset, flags);
3815 }
3816 
3817 
3818 // Return vmtarget from ResolvedMethodName method field through indirection
3819 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3820   assert(is_instance(mname), &quot;wrong type&quot;);
3821   oop method = mname-&gt;obj_field(_method_offset);
3822   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3823 }
3824 
3825 bool java_lang_invoke_MemberName::is_method(oop mname) {
3826   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3827   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3828 }
3829 
3830 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3831   assert(is_instance(mname), &quot;wrong type&quot;);
3832   mname-&gt;obj_field_put(_method_offset, resolved_method);
3833 }
3834 
3835 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3836   assert(is_instance(mname), &quot;wrong type&quot;);
3837   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3838 }
3839 
3840 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3841   assert(is_instance(mname), &quot;wrong type&quot;);
3842   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3843 }
3844 
3845 
3846 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3847   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4313       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4314     } else {
4315       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4316     }
4317   }
4318 };
4319 
4320 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4321   UnsafeConstantsFixup fixup;
4322   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4323 }
4324 
4325 int java_lang_Class::_klass_offset;
4326 int java_lang_Class::_array_klass_offset;
4327 int java_lang_Class::_oop_size_offset;
4328 int java_lang_Class::_static_oop_field_count_offset;
4329 int java_lang_Class::_class_loader_offset;
4330 int java_lang_Class::_module_offset;
4331 int java_lang_Class::_protection_domain_offset;
4332 int java_lang_Class::_component_mirror_offset;


4333 int java_lang_Class::_init_lock_offset;
4334 int java_lang_Class::_signers_offset;
4335 int java_lang_Class::_name_offset;
4336 int java_lang_Class::_source_file_offset;
4337 int java_lang_Class::_classData_offset;
4338 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4339 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4340 int java_lang_Throwable::backtrace_offset;
4341 int java_lang_Throwable::detailMessage_offset;
4342 int java_lang_Throwable::stackTrace_offset;
4343 int java_lang_Throwable::depth_offset;
4344 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4345 int java_lang_reflect_AccessibleObject::override_offset;
4346 int java_lang_reflect_Method::clazz_offset;
4347 int java_lang_reflect_Method::name_offset;
4348 int java_lang_reflect_Method::returnType_offset;
4349 int java_lang_reflect_Method::parameterTypes_offset;
4350 int java_lang_reflect_Method::exceptionTypes_offset;
4351 int java_lang_reflect_Method::slot_offset;
4352 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4408 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4409 int java_lang_AssertionStatusDirectives::deflt_offset;
4410 int java_nio_Buffer::_limit_offset;
4411 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4412 int reflect_ConstantPool::_oop_offset;
4413 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4414 int java_lang_Integer_IntegerCache::_static_cache_offset;
4415 int java_lang_Long_LongCache::_static_cache_offset;
4416 int java_lang_Character_CharacterCache::_static_cache_offset;
4417 int java_lang_Short_ShortCache::_static_cache_offset;
4418 int java_lang_Byte_ByteCache::_static_cache_offset;
4419 int java_lang_Boolean::_static_TRUE_offset;
4420 int java_lang_Boolean::_static_FALSE_offset;
4421 int java_lang_reflect_RecordComponent::clazz_offset;
4422 int java_lang_reflect_RecordComponent::name_offset;
4423 int java_lang_reflect_RecordComponent::type_offset;
4424 int java_lang_reflect_RecordComponent::accessor_offset;
4425 int java_lang_reflect_RecordComponent::signature_offset;
4426 int java_lang_reflect_RecordComponent::annotations_offset;
4427 int java_lang_reflect_RecordComponent::typeAnnotations_offset;





4428 
4429 
4430 
4431 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4432   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4433   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4434   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4435   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4436   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4437   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4438   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4439   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4440 
4441 // Support for java_lang_StackTraceElement
4442 void java_lang_StackTraceElement::compute_offsets() {
4443   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4444   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4445 }
4446 
4447 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4713   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4714   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4715 }
4716 
4717 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4718   oop base = ik-&gt;static_field_base_raw();
4719   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4720 }
4721 
4722 Symbol* java_lang_Byte_ByteCache::symbol() {
4723   return vmSymbols::java_lang_Byte_ByteCache();
4724 }
4725 
4726 #if INCLUDE_CDS
4727 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4728   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4729 }
4730 #endif
4731 #undef BYTE_CACHE_FIELDS_DO
4732 































































4733 jbyte java_lang_Byte::value(oop obj) {
4734    jvalue v;
4735    java_lang_boxing_object::get_value(obj, &amp;v);
4736    return v.b;
4737 }
4738 #define BOOLEAN_FIELDS_DO(macro) \
4739   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4740   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4741 
4742 
4743 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4744   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4745   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4746 }
4747 
4748 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4749   oop base = ik-&gt;static_field_base_raw();
4750   return base-&gt;obj_field(_static_TRUE_offset);
4751 }
4752 
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 964   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 965   k-&gt;set_modifier_flags(computed_modifiers);
 966   // Class_klass has to be loaded because it is used to allocate
 967   // the mirror.
 968   if (SystemDictionary::Class_klass_loaded()) {
 969     // Allocate mirror (java.lang.Class instance)
 970     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 971     Handle mirror(THREAD, mirror_oop);
 972     Handle comp_mirror;
 973 
 974     // Setup indirection from mirror-&gt;klass
 975     java_lang_Class::set_klass(mirror(), k);
 976 
 977     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 978     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 979 
 980     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 981 
 982     // It might also have a component mirror.  This mirror must already exist.
 983     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 984       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 985         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 986         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 987         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 988         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added"> 989       } else if (k-&gt;is_typeArray_klass()) {</span>
 990         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 991         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 992       } else {
 993         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 994         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 995         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 996         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 997       }
 998       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 999 
1000       // Two-way link between the array klass and its component mirror:
1001       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1002       set_component_mirror(mirror(), comp_mirror());
1003       // See below for ordering dependencies between field array_klass in component mirror
1004       // and java_mirror in this klass.
1005     } else {
1006       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1007 
1008       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1009       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1016       }
1017     }
1018 
1019     // set the classLoader field in the java_lang_Class instance
1020     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1021     set_class_loader(mirror(), class_loader());
1022 
1023     // Setup indirection from klass-&gt;mirror
1024     // after any exceptions can happen during allocations.
1025     k-&gt;set_java_mirror(mirror);
1026 
1027     // Set the module field in the java_lang_Class instance.  This must be done
1028     // after the mirror is set.
1029     set_mirror_module_field(k, mirror, module, THREAD);
1030 
1031     if (comp_mirror() != NULL) {
1032       // Set after k-&gt;java_mirror() is published, because compiled code running
1033       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1034       release_set_array_klass(comp_mirror(), k);
1035     }
<span class="line-added">1036 </span>
<span class="line-added">1037     if (k-&gt;is_value()) {</span>
<span class="line-added">1038       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1039       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1040 </span>
<span class="line-added">1041       // if the supertype is a restricted abstract class</span>
<span class="line-added">1042       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1043         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1044         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1045         // set the reference projection type</span>
<span class="line-added">1046         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1047 </span>
<span class="line-added">1048         // set the value and reference projection types</span>
<span class="line-added">1049         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1050         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1051       }</span>
<span class="line-added">1052     }</span>
1053   } else {
1054     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1055     fixup_mirror_list()-&gt;push(k);
1056   }
1057 }
1058 
1059 #if INCLUDE_CDS_JAVA_HEAP
1060 // Clears mirror fields. Static final fields with initial values are reloaded
1061 // from constant pool. The object identity hash is in the object header and is
1062 // not affected.
1063 class ResetMirrorField: public FieldClosure {
1064  private:
1065   Handle _m;
1066 
1067  public:
1068   ResetMirrorField(Handle mirror) : _m(mirror) {}
1069 
1070   void do_field(fieldDescriptor* fd) {
1071     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1072     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1189 
1190   // No mirror
1191   oop mirror = k-&gt;java_mirror();
1192   if (mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   if (k-&gt;is_instance_klass()) {
1197     InstanceKlass *ik = InstanceKlass::cast(k);
1198     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1199 
1200     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1201           ik-&gt;is_shared_app_class())) {
1202       // Archiving mirror for classes from non-builtin loaders is not
1203       // supported. Clear the _java_mirror within the archived class.
1204       k-&gt;set_java_mirror_handle(NULL);
1205       return NULL;
1206     }
1207   }
1208 
<span class="line-added">1209   if (k-&gt;is_value()) {</span>
<span class="line-added">1210     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1211     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1212     return NULL;</span>
<span class="line-added">1213   }</span>
<span class="line-added">1214 </span>
1215   // Now start archiving the mirror object
1216   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1217   if (archived_mirror == NULL) {
1218     return NULL;
1219   }
1220 
1221   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1222   if (archived_mirror == NULL) {
1223     return NULL;
1224   }
1225 
1226   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1227 
1228   k-&gt;set_has_raw_archived_mirror();
1229 
1230   ResourceMark rm;
1231   log_trace(cds, heap, mirror)(
1232     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1233     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1234 
</pre>
<hr />
<pre>
1486 oop java_lang_Class::name(Handle java_class, TRAPS) {
1487   assert(_name_offset != 0, &quot;must be set&quot;);
1488   oop o = java_class-&gt;obj_field(_name_offset);
1489   if (o == NULL) {
1490     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1491     java_class-&gt;obj_field_put(_name_offset, o);
1492   }
1493   return o;
1494 }
1495 
1496 oop java_lang_Class::source_file(oop java_class) {
1497   assert(_source_file_offset != 0, &quot;must be set&quot;);
1498   return java_class-&gt;obj_field(_source_file_offset);
1499 }
1500 
1501 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1502   assert(_source_file_offset != 0, &quot;must be set&quot;);
1503   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1504 }
1505 
<span class="line-added">1506 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1507   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1508   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1509 }</span>
<span class="line-added">1510 </span>
<span class="line-added">1511 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1512   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1513   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1514 }</span>
<span class="line-added">1515 </span>
<span class="line-added">1516 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1517   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1518   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1519 }</span>
<span class="line-added">1520 </span>
<span class="line-added">1521 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1522   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1523   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
1526 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1527   // This should be improved by adding a field at the Java level or by
1528   // introducing a new VM klass (see comment in ClassFileParser)
1529   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1530   if (type != T_VOID) {
1531     Klass* aklass = Universe::typeArrayKlassObj(type);
1532     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1533     release_set_array_klass(java_class, aklass);
1534   }
1535 #ifdef ASSERT
1536   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1537   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1538 #endif
1539   return java_class;
1540 }
1541 
1542 
1543 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1544   //%note memory_2
1545   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1546   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1547   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1548   return k;
1549 }
1550 
1551 
1552 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1553   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1554   java_class-&gt;metadata_field_put(_klass_offset, klass);
1555 }
1556 
1557 
1558 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1559   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1560   Symbol* name = NULL;
1561   bool is_instance = false;
<span class="line-added">1562   bool is_value = false;</span>
1563   if (is_primitive(java_class)) {
1564     name = vmSymbols::type_signature(primitive_type(java_class));
1565   } else {
1566     Klass* k = as_Klass(java_class);
1567     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1568     is_value = k-&gt;is_value();</span>
1569     name = k-&gt;name();
1570   }
1571   if (name == NULL) {
1572     st-&gt;print(&quot;&lt;null&gt;&quot;);
1573     return;
1574   }
<span class="line-modified">1575   if (is_instance)  {</span>
<span class="line-added">1576     if (is_value) {</span>
<span class="line-added">1577       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1578     } else {</span>
<span class="line-added">1579       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1580     }</span>
<span class="line-added">1581   }</span>
1582   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1583   if (is_instance)  st-&gt;print(&quot;;&quot;);
1584 }
1585 
1586 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1587   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1588   Symbol* name;
1589   if (is_primitive(java_class)) {
1590     name = vmSymbols::type_signature(primitive_type(java_class));
1591     // Because this can create a new symbol, the caller has to decrement
1592     // the refcount, so make adjustment here and below for symbols returned
1593     // that are not created or incremented due to a successful lookup.
1594     name-&gt;increment_refcount();
1595   } else {
1596     Klass* k = as_Klass(java_class);
1597     if (!k-&gt;is_instance_klass()) {
1598       name = k-&gt;name();
1599       name-&gt;increment_refcount();
1600     } else {
1601       ResourceMark rm;
1602       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1603       int siglen = (int) strlen(sigstr);</span>
1604       if (!intern_if_not_found) {
1605         name = SymbolTable::probe(sigstr, siglen);
1606       } else {
1607         name = SymbolTable::new_symbol(sigstr, siglen);
1608       }
1609     }
1610   }
1611   return name;
1612 }
1613 
1614 // Returns the Java name for this Java mirror (Resource allocated)
1615 // See Klass::external_name().
1616 // For primitive type Java mirrors, its type name is returned.
1617 const char* java_lang_Class::as_external_name(oop java_class) {
1618   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1619   const char* name = NULL;
1620   if (is_primitive(java_class)) {
1621     name = type2name(primitive_type(java_class));
1622   } else {
1623     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1668   }
1669 }
1670 
1671 
1672 oop java_lang_Class::primitive_mirror(BasicType t) {
1673   oop mirror = Universe::java_mirror(t);
1674   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1675   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1676   return mirror;
1677 }
1678 
1679 bool java_lang_Class::offsets_computed = false;
1680 int  java_lang_Class::classRedefinedCount_offset = -1;
1681 
1682 #define CLASS_FIELDS_DO(macro) \
1683   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1684   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1685   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1686   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1687   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<span class="line-added">1688   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1689   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1690   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1691 
1692 void java_lang_Class::compute_offsets() {
1693   if (offsets_computed) {
1694     return;
1695   }
1696 
1697   offsets_computed = true;
1698 
1699   InstanceKlass* k = SystemDictionary::Class_klass();
1700   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1701 
1702   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1703   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1704   // GC treats them the same.
1705   _init_lock_offset = _component_mirror_offset;
1706 
1707   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1708 }
1709 
</pre>
<hr />
<pre>
2545 #endif
2546 
2547     // the format of the stacktrace will be:
2548     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2549     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2550     // - rest of the stack
2551 
2552     if (!skip_fillInStackTrace_check) {
2553       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2554           throwable-&gt;is_a(method-&gt;method_holder())) {
2555         continue;
2556       }
2557       else {
2558         skip_fillInStackTrace_check = true; // gone past them all
2559       }
2560     }
2561     if (!skip_throwableInit_check) {
2562       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2563 
2564       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2565       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2566       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2567           throwable-&gt;is_a(method-&gt;method_holder())) {
2568         continue;
2569       } else {
2570         // there are none or we&#39;ve seen them all - either way stop checking
2571         skip_throwableInit_check = true;
2572       }
2573     }
2574     if (method-&gt;is_hidden()) {
2575       if (skip_hidden) {
2576         if (total_count == 0) {
2577           // The top frame will be hidden from the stack trace.
2578           bt.set_has_hidden_top_frame(CHECK);
2579         }
2580         continue;
2581       }
2582     }
2583     bt.push(method, bci, CHECK);
2584     total_count++;
2585   }
2586 
</pre>
<hr />
<pre>
3867 int java_lang_invoke_MemberName::flags(oop mname) {
3868   assert(is_instance(mname), &quot;wrong type&quot;);
3869   return mname-&gt;int_field(_flags_offset);
3870 }
3871 
3872 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3873   assert(is_instance(mname), &quot;wrong type&quot;);
3874   mname-&gt;int_field_put(_flags_offset, flags);
3875 }
3876 
3877 
3878 // Return vmtarget from ResolvedMethodName method field through indirection
3879 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3880   assert(is_instance(mname), &quot;wrong type&quot;);
3881   oop method = mname-&gt;obj_field(_method_offset);
3882   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3883 }
3884 
3885 bool java_lang_invoke_MemberName::is_method(oop mname) {
3886   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3887   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3888 }
3889 
3890 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3891   assert(is_instance(mname), &quot;wrong type&quot;);
3892   mname-&gt;obj_field_put(_method_offset, resolved_method);
3893 }
3894 
3895 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3896   assert(is_instance(mname), &quot;wrong type&quot;);
3897   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3898 }
3899 
3900 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3901   assert(is_instance(mname), &quot;wrong type&quot;);
3902   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3903 }
3904 
3905 
3906 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3907   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4373       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4374     } else {
4375       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4376     }
4377   }
4378 };
4379 
4380 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4381   UnsafeConstantsFixup fixup;
4382   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4383 }
4384 
4385 int java_lang_Class::_klass_offset;
4386 int java_lang_Class::_array_klass_offset;
4387 int java_lang_Class::_oop_size_offset;
4388 int java_lang_Class::_static_oop_field_count_offset;
4389 int java_lang_Class::_class_loader_offset;
4390 int java_lang_Class::_module_offset;
4391 int java_lang_Class::_protection_domain_offset;
4392 int java_lang_Class::_component_mirror_offset;
<span class="line-added">4393 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added">4394 int java_lang_Class::_ref_type_mirror_offset;</span>
4395 int java_lang_Class::_init_lock_offset;
4396 int java_lang_Class::_signers_offset;
4397 int java_lang_Class::_name_offset;
4398 int java_lang_Class::_source_file_offset;
4399 int java_lang_Class::_classData_offset;
4400 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4401 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4402 int java_lang_Throwable::backtrace_offset;
4403 int java_lang_Throwable::detailMessage_offset;
4404 int java_lang_Throwable::stackTrace_offset;
4405 int java_lang_Throwable::depth_offset;
4406 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4407 int java_lang_reflect_AccessibleObject::override_offset;
4408 int java_lang_reflect_Method::clazz_offset;
4409 int java_lang_reflect_Method::name_offset;
4410 int java_lang_reflect_Method::returnType_offset;
4411 int java_lang_reflect_Method::parameterTypes_offset;
4412 int java_lang_reflect_Method::exceptionTypes_offset;
4413 int java_lang_reflect_Method::slot_offset;
4414 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4470 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4471 int java_lang_AssertionStatusDirectives::deflt_offset;
4472 int java_nio_Buffer::_limit_offset;
4473 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4474 int reflect_ConstantPool::_oop_offset;
4475 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4476 int java_lang_Integer_IntegerCache::_static_cache_offset;
4477 int java_lang_Long_LongCache::_static_cache_offset;
4478 int java_lang_Character_CharacterCache::_static_cache_offset;
4479 int java_lang_Short_ShortCache::_static_cache_offset;
4480 int java_lang_Byte_ByteCache::_static_cache_offset;
4481 int java_lang_Boolean::_static_TRUE_offset;
4482 int java_lang_Boolean::_static_FALSE_offset;
4483 int java_lang_reflect_RecordComponent::clazz_offset;
4484 int java_lang_reflect_RecordComponent::name_offset;
4485 int java_lang_reflect_RecordComponent::type_offset;
4486 int java_lang_reflect_RecordComponent::accessor_offset;
4487 int java_lang_reflect_RecordComponent::signature_offset;
4488 int java_lang_reflect_RecordComponent::annotations_offset;
4489 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<span class="line-added">4490 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4491 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4492 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4493 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4494 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4495 
4496 
4497 
4498 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4499   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4500   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4501   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4502   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4503   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4504   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4505   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4506   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4507 
4508 // Support for java_lang_StackTraceElement
4509 void java_lang_StackTraceElement::compute_offsets() {
4510   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4511   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4512 }
4513 
4514 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4780   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4781   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4782 }
4783 
4784 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4785   oop base = ik-&gt;static_field_base_raw();
4786   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4787 }
4788 
4789 Symbol* java_lang_Byte_ByteCache::symbol() {
4790   return vmSymbols::java_lang_Byte_ByteCache();
4791 }
4792 
4793 #if INCLUDE_CDS
4794 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4795   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4796 }
4797 #endif
4798 #undef BYTE_CACHE_FIELDS_DO
4799 
<span class="line-added">4800 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4801   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4802   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4803   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4804   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4805   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4806 </span>
<span class="line-added">4807 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4808   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4809   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4810 }</span>
<span class="line-added">4811 </span>
<span class="line-added">4812 #if INCLUDE_CDS</span>
<span class="line-added">4813 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4814   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 #endif</span>
<span class="line-added">4817 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4818 </span>
<span class="line-added">4819 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4820   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4821 }</span>
<span class="line-added">4822 </span>
<span class="line-added">4823 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4824   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4825 }</span>
<span class="line-added">4826 </span>
<span class="line-added">4827 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4828   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4829 }</span>
<span class="line-added">4830 </span>
<span class="line-added">4831 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4832   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4833 }</span>
<span class="line-added">4834 </span>
<span class="line-added">4835 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4836   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4837 }</span>
<span class="line-added">4838 </span>
<span class="line-added">4839 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4840   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4841 }</span>
<span class="line-added">4842 </span>
<span class="line-added">4843 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4844   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4845 }</span>
<span class="line-added">4846 </span>
<span class="line-added">4847 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4848   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4849 }</span>
<span class="line-added">4850 </span>
<span class="line-added">4851 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4852   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4853 }</span>
<span class="line-added">4854 </span>
<span class="line-added">4855 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4856   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4857 }</span>
<span class="line-added">4858 </span>
<span class="line-added">4859 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4860   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4861 }</span>
<span class="line-added">4862 </span>
4863 jbyte java_lang_Byte::value(oop obj) {
4864    jvalue v;
4865    java_lang_boxing_object::get_value(obj, &amp;v);
4866    return v.b;
4867 }
4868 #define BOOLEAN_FIELDS_DO(macro) \
4869   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4870   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4871 
4872 
4873 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4874   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4875   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4876 }
4877 
4878 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4879   oop base = ik-&gt;static_field_base_raw();
4880   return base-&gt;obj_field(_static_TRUE_offset);
4881 }
4882 
</pre>
</td>
</tr>
</table>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
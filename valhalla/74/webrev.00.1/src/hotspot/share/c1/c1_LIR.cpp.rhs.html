<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  31 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  32 #include &quot;runtime/sharedRuntime.hpp&quot;
  33 
  34 Register LIR_OprDesc::as_register() const {
  35   return FrameMap::cpu_rnr2reg(cpu_regnr());
  36 }
  37 
  38 Register LIR_OprDesc::as_register_lo() const {
  39   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  40 }
  41 
  42 Register LIR_OprDesc::as_register_hi() const {
  43   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  44 }
  45 
  46 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  47 
  48 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  49   ValueTag tag = type-&gt;tag();
  50   switch (tag) {
  51   case metaDataTag : {
  52     ClassConstant* c = type-&gt;as_ClassConstant();
  53     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_loaded()) {
  54       return LIR_OprFact::metadataConst(NULL);
  55     } else if (c != NULL) {
  56       return LIR_OprFact::metadataConst(c-&gt;value()-&gt;constant_encoding());
  57     } else {
  58       MethodConstant* m = type-&gt;as_MethodConstant();
  59       assert (m != NULL, &quot;not a class or a method?&quot;);
  60       return LIR_OprFact::metadataConst(m-&gt;value()-&gt;constant_encoding());
  61     }
  62   }
  63   case objectTag : {
  64       return LIR_OprFact::oopConst(type-&gt;as_ObjectType()-&gt;encoding());
  65     }
  66   case addressTag: return LIR_OprFact::addressConst(type-&gt;as_AddressConstant()-&gt;value());
  67   case intTag    : return LIR_OprFact::intConst(type-&gt;as_IntConstant()-&gt;value());
  68   case floatTag  : return LIR_OprFact::floatConst(type-&gt;as_FloatConstant()-&gt;value());
  69   case longTag   : return LIR_OprFact::longConst(type-&gt;as_LongConstant()-&gt;value());
  70   case doubleTag : return LIR_OprFact::doubleConst(type-&gt;as_DoubleConstant()-&gt;value());
  71   default: ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  72   }
  73 }
  74 
  75 
  76 //---------------------------------------------------
  77 
  78 
  79 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  80   int elem_size = type2aelembytes(type);
  81   switch (elem_size) {
  82   case 1: return LIR_Address::times_1;
  83   case 2: return LIR_Address::times_2;
  84   case 4: return LIR_Address::times_4;
  85   case 8: return LIR_Address::times_8;
  86   }
  87   ShouldNotReachHere();
  88   return LIR_Address::times_1;
  89 }
  90 
  91 //---------------------------------------------------
  92 
  93 char LIR_OprDesc::type_char(BasicType t) {
  94   switch (t) {
  95     case T_ARRAY:
<a name="2" id="anc2"></a><span class="line-added">  96     case T_VALUETYPE:</span>
  97       t = T_OBJECT;
  98     case T_BOOLEAN:
  99     case T_CHAR:
 100     case T_FLOAT:
 101     case T_DOUBLE:
 102     case T_BYTE:
 103     case T_SHORT:
 104     case T_INT:
 105     case T_LONG:
 106     case T_OBJECT:
 107     case T_ADDRESS:
 108     case T_VOID:
 109       return ::type2char(t);
 110     case T_METADATA:
 111       return &#39;M&#39;;
 112     case T_ILLEGAL:
 113       return &#39;?&#39;;
 114 
 115     default:
 116       ShouldNotReachHere();
 117       return &#39;?&#39;;
 118   }
 119 }
 120 
 121 #ifndef PRODUCT
 122 void LIR_OprDesc::validate_type() const {
 123 
 124 #ifdef ASSERT
 125   if (!is_pointer() &amp;&amp; !is_illegal()) {
 126     OprKind kindfield = kind_field(); // Factored out because of compiler bug, see 8002160
 127     switch (as_BasicType(type_field())) {
 128     case T_LONG:
 129       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 130              size_field() == double_size, &quot;must match&quot;);
 131       break;
 132     case T_FLOAT:
 133       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 134       assert((kindfield == fpu_register || kindfield == stack_value
 135              ARM_ONLY(|| kindfield == cpu_register)
 136              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 137              size_field() == single_size, &quot;must match&quot;);
 138       break;
 139     case T_DOUBLE:
 140       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 141       assert((kindfield == fpu_register || kindfield == stack_value
 142              ARM_ONLY(|| kindfield == cpu_register)
 143              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 144              size_field() == double_size, &quot;must match&quot;);
 145       break;
 146     case T_BOOLEAN:
 147     case T_CHAR:
 148     case T_BYTE:
 149     case T_SHORT:
 150     case T_INT:
 151     case T_ADDRESS:
 152     case T_OBJECT:
 153     case T_METADATA:
 154     case T_ARRAY:
<a name="3" id="anc3"></a><span class="line-added"> 155     case T_VALUETYPE:</span>
 156       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 157              size_field() == single_size, &quot;must match&quot;);
 158       break;
 159 
 160     case T_ILLEGAL:
 161       // XXX TKR also means unknown right now
 162       // assert(is_illegal(), &quot;must match&quot;);
 163       break;
 164 
 165     default:
 166       ShouldNotReachHere();
 167     }
 168   }
 169 #endif
 170 
 171 }
 172 #endif // PRODUCT
 173 
 174 
 175 bool LIR_OprDesc::is_oop() const {
 176   if (is_pointer()) {
 177     return pointer()-&gt;is_oop_pointer();
 178   } else {
 179     OprType t= type_field();
 180     assert(t != unknown_type, &quot;not set&quot;);
 181     return t == object_type;
 182   }
 183 }
 184 
 185 
 186 
 187 void LIR_Op2::verify() const {
 188 #ifdef ASSERT
 189   switch (code()) {
 190     case lir_cmove:
 191     case lir_xchg:
 192       break;
 193 
 194     default:
 195       assert(!result_opr()-&gt;is_register() || !result_opr()-&gt;is_oop_register(),
 196              &quot;can&#39;t produce oops from arith&quot;);
 197   }
 198 
 199   if (TwoOperandLIRForm) {
 200 
 201 #ifdef ASSERT
 202     bool threeOperandForm = false;
 203 #ifdef S390
 204     // There are 3 operand shifts on S390 (see LIR_Assembler::shift_op()).
 205     threeOperandForm =
 206       code() == lir_shl ||
 207       ((code() == lir_shr || code() == lir_ushr) &amp;&amp; (result_opr()-&gt;is_double_cpu() || in_opr1()-&gt;type() == T_OBJECT));
 208 #endif
 209 #endif
 210 
 211     switch (code()) {
 212     case lir_add:
 213     case lir_sub:
 214     case lir_mul:
 215     case lir_mul_strictfp:
 216     case lir_div:
 217     case lir_div_strictfp:
 218     case lir_rem:
 219     case lir_logic_and:
 220     case lir_logic_or:
 221     case lir_logic_xor:
 222     case lir_shl:
 223     case lir_shr:
 224       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 225       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 226       break;
 227 
 228     // special handling for lir_ushr because of write barriers
 229     case lir_ushr:
 230       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 231       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 232       break;
 233 
 234     default:
 235       break;
 236     }
 237   }
 238 #endif
 239 }
 240 
 241 
 242 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block)
 243   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 244   , _cond(cond)
 245   , _type(type)
 246   , _label(block-&gt;label())
 247   , _block(block)
 248   , _ublock(NULL)
 249   , _stub(NULL) {
 250 }
 251 
 252 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub) :
 253   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 254   , _cond(cond)
 255   , _type(type)
 256   , _label(stub-&gt;entry())
 257   , _block(NULL)
 258   , _ublock(NULL)
 259   , _stub(stub) {
 260 }
 261 
 262 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock)
 263   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 264   , _cond(cond)
 265   , _type(type)
 266   , _label(block-&gt;label())
 267   , _block(block)
 268   , _ublock(ublock)
 269   , _stub(NULL)
 270 {
 271 }
 272 
 273 void LIR_OpBranch::change_block(BlockBegin* b) {
 274   assert(_block != NULL, &quot;must have old block&quot;);
 275   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 276 
 277   _block = b;
 278   _label = b-&gt;label();
 279 }
 280 
 281 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 282   assert(_ublock != NULL, &quot;must have old block&quot;);
 283   _ublock = b;
 284 }
 285 
 286 void LIR_OpBranch::negate_cond() {
 287   switch (_cond) {
 288     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 289     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 290     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 291     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 292     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 293     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 294     default: ShouldNotReachHere();
 295   }
 296 }
 297 
 298 
 299 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 300                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 301                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<a name="4" id="anc4"></a><span class="line-modified"> 302                                  CodeStub* stub, bool need_null_check)</span>
 303 
 304   : LIR_Op(code, result, NULL)
 305   , _object(object)
 306   , _array(LIR_OprFact::illegalOpr)
 307   , _klass(klass)
 308   , _tmp1(tmp1)
 309   , _tmp2(tmp2)
 310   , _tmp3(tmp3)
 311   , _fast_check(fast_check)
 312   , _info_for_patch(info_for_patch)
 313   , _info_for_exception(info_for_exception)
 314   , _stub(stub)
 315   , _profiled_method(NULL)
 316   , _profiled_bci(-1)
 317   , _should_profile(false)
<a name="5" id="anc5"></a><span class="line-added"> 318   , _need_null_check(need_null_check)</span>
 319 {
 320   if (code == lir_checkcast) {
 321     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 322   } else if (code == lir_instanceof) {
 323     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 324   } else {
 325     ShouldNotReachHere();
 326   }
 327 }
 328 
 329 
 330 
 331 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 332   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 333   , _object(object)
 334   , _array(array)
 335   , _klass(NULL)
 336   , _tmp1(tmp1)
 337   , _tmp2(tmp2)
 338   , _tmp3(tmp3)
 339   , _fast_check(false)
 340   , _info_for_patch(NULL)
 341   , _info_for_exception(info_for_exception)
 342   , _stub(NULL)
 343   , _profiled_method(NULL)
 344   , _profiled_bci(-1)
 345   , _should_profile(false)
<a name="6" id="anc6"></a><span class="line-added"> 346   , _need_null_check(true)</span>
 347 {
 348   if (code == lir_store_check) {
 349     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 350     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 351   } else {
 352     ShouldNotReachHere();
 353   }
 354 }
 355 
<a name="7" id="anc7"></a><span class="line-added"> 356 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)</span>
<span class="line-added"> 357   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 358   , _array(array)</span>
<span class="line-added"> 359   , _value(value)</span>
<span class="line-added"> 360   , _tmp(tmp)</span>
<span class="line-added"> 361   , _stub(stub) {}</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)</span>
<span class="line-added"> 365   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 366   , _array(array)</span>
<span class="line-added"> 367   , _tmp(tmp) {}</span>
<span class="line-added"> 368 </span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added"> 371                                                          LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added"> 372                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added"> 373                                                          CodeEmitInfo* info, CodeStub* stub)</span>
<span class="line-added"> 374   : LIR_Op(lir_substitutability_check, result, info)</span>
<span class="line-added"> 375   , _left(left)</span>
<span class="line-added"> 376   , _right(right)</span>
<span class="line-added"> 377   , _equal_result(equal_result)</span>
<span class="line-added"> 378   , _not_equal_result(not_equal_result)</span>
<span class="line-added"> 379   , _tmp1(tmp1)</span>
<span class="line-added"> 380   , _tmp2(tmp2)</span>
<span class="line-added"> 381   , _left_klass(left_klass)</span>
<span class="line-added"> 382   , _right_klass(right_klass)</span>
<span class="line-added"> 383   , _left_klass_op(left_klass_op)</span>
<span class="line-added"> 384   , _right_klass_op(right_klass_op)</span>
<span class="line-added"> 385   , _stub(stub) {}</span>
<span class="line-added"> 386 </span>
 387 
 388 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 389                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 390   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 391   , _src(src)
 392   , _src_pos(src_pos)
 393   , _dst(dst)
 394   , _dst_pos(dst_pos)
 395   , _length(length)
 396   , _tmp(tmp)
 397   , _expected_type(expected_type)
 398   , _flags(flags) {
 399   _stub = new ArrayCopyStub(this);
 400 }
 401 
 402 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 403   : LIR_Op(lir_updatecrc32, res, NULL)
 404   , _crc(crc)
 405   , _val(val) {
 406 }
 407 
 408 //-------------------verify--------------------------
 409 
 410 void LIR_Op1::verify() const {
 411   switch(code()) {
 412   case lir_move:
 413     assert(in_opr()-&gt;is_valid() &amp;&amp; result_opr()-&gt;is_valid(), &quot;must be&quot;);
 414     break;
 415   case lir_null_check:
 416     assert(in_opr()-&gt;is_register(), &quot;must be&quot;);
 417     break;
 418   case lir_return:
 419     assert(in_opr()-&gt;is_register() || in_opr()-&gt;is_illegal(), &quot;must be&quot;);
 420     break;
 421   default:
 422     break;
 423   }
 424 }
 425 
 426 void LIR_OpRTCall::verify() const {
 427   assert(strcmp(Runtime1::name_for_address(addr()), &quot;&lt;unknown function&gt;&quot;) != 0, &quot;unknown function&quot;);
 428 }
 429 
 430 //-------------------visits--------------------------
 431 
 432 // complete rework of LIR instruction visitor.
 433 // The virtual call for each instruction type is replaced by a big
 434 // switch that adds the operands for each instruction
 435 
 436 void LIR_OpVisitState::visit(LIR_Op* op) {
 437   // copy information from the LIR_Op
 438   reset();
 439   set_op(op);
 440 
 441   switch (op-&gt;code()) {
 442 
 443 // LIR_Op0
 444     case lir_backwardbranch_target:    // result and info always invalid
 445     case lir_fpop_raw:                 // result and info always invalid
 446     case lir_breakpoint:               // result and info always invalid
 447     case lir_membar:                   // result and info always invalid
 448     case lir_membar_acquire:           // result and info always invalid
 449     case lir_membar_release:           // result and info always invalid
 450     case lir_membar_loadload:          // result and info always invalid
 451     case lir_membar_storestore:        // result and info always invalid
 452     case lir_membar_loadstore:         // result and info always invalid
 453     case lir_membar_storeload:         // result and info always invalid
<a name="8" id="anc8"></a><span class="line-added"> 454     case lir_check_orig_pc:            // result and info always invalid</span>
 455     case lir_on_spin_wait:
 456     {
 457       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 458       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 459       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 460       break;
 461     }
 462 
 463     case lir_nop:                      // may have info, result always invalid
 464     case lir_std_entry:                // may have result, info always invalid
 465     case lir_osr_entry:                // may have result, info always invalid
 466     case lir_get_thread:               // may have result, info always invalid
 467     {
 468       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 469       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 470       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 471       break;
 472     }
 473 
 474 
 475 // LIR_OpLabel
 476     case lir_label:                    // result and info always invalid
 477     {
 478       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 479       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 480       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 481       break;
 482     }
 483 
 484 
 485 // LIR_Op1
 486     case lir_fxch:           // input always valid, result and info always invalid
 487     case lir_fld:            // input always valid, result and info always invalid
 488     case lir_push:           // input always valid, result and info always invalid
 489     case lir_pop:            // input always valid, result and info always invalid
 490     case lir_return:         // input always valid, result and info always invalid
 491     case lir_leal:           // input and result always valid, info always invalid
 492     case lir_monaddr:        // input and result always valid, info always invalid
 493     case lir_null_check:     // input and info always valid, result always invalid
 494     case lir_move:           // input and result always valid, may have info
 495     {
 496       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 497       LIR_Op1* op1 = (LIR_Op1*)op;
 498 
 499       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 500       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 501       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 502 
 503       break;
 504     }
 505 
 506     case lir_safepoint:
 507     {
 508       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 509       LIR_Op1* op1 = (LIR_Op1*)op;
 510 
 511       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 512       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 513       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 514 
 515       break;
 516     }
 517 
 518 // LIR_OpConvert;
 519     case lir_convert:        // input and result always valid, info always invalid
 520     {
 521       assert(op-&gt;as_OpConvert() != NULL, &quot;must be&quot;);
 522       LIR_OpConvert* opConvert = (LIR_OpConvert*)op;
 523 
 524       assert(opConvert-&gt;_info == NULL, &quot;must be&quot;);
 525       if (opConvert-&gt;_opr-&gt;is_valid())       do_input(opConvert-&gt;_opr);
 526       if (opConvert-&gt;_result-&gt;is_valid())    do_output(opConvert-&gt;_result);
 527 #ifdef PPC32
 528       if (opConvert-&gt;_tmp1-&gt;is_valid())      do_temp(opConvert-&gt;_tmp1);
 529       if (opConvert-&gt;_tmp2-&gt;is_valid())      do_temp(opConvert-&gt;_tmp2);
 530 #endif
 531       do_stub(opConvert-&gt;_stub);
 532 
 533       break;
 534     }
 535 
 536 // LIR_OpBranch;
 537     case lir_branch:                   // may have info, input and result register always invalid
 538     case lir_cond_float_branch:        // may have info, input and result register always invalid
 539     {
 540       assert(op-&gt;as_OpBranch() != NULL, &quot;must be&quot;);
 541       LIR_OpBranch* opBranch = (LIR_OpBranch*)op;
 542 
 543       if (opBranch-&gt;_info != NULL)     do_info(opBranch-&gt;_info);
 544       assert(opBranch-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 545       if (opBranch-&gt;_stub != NULL)     opBranch-&gt;stub()-&gt;visit(this);
 546 
 547       break;
 548     }
 549 
 550 
 551 // LIR_OpAllocObj
 552     case lir_alloc_object:
 553     {
 554       assert(op-&gt;as_OpAllocObj() != NULL, &quot;must be&quot;);
 555       LIR_OpAllocObj* opAllocObj = (LIR_OpAllocObj*)op;
 556 
 557       if (opAllocObj-&gt;_info)                     do_info(opAllocObj-&gt;_info);
 558       if (opAllocObj-&gt;_opr-&gt;is_valid()) {        do_input(opAllocObj-&gt;_opr);
 559                                                  do_temp(opAllocObj-&gt;_opr);
 560                                         }
 561       if (opAllocObj-&gt;_tmp1-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp1);
 562       if (opAllocObj-&gt;_tmp2-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp2);
 563       if (opAllocObj-&gt;_tmp3-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp3);
 564       if (opAllocObj-&gt;_tmp4-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp4);
 565       if (opAllocObj-&gt;_result-&gt;is_valid())       do_output(opAllocObj-&gt;_result);
 566                                                  do_stub(opAllocObj-&gt;_stub);
 567       break;
 568     }
 569 
 570 
 571 // LIR_OpRoundFP;
 572     case lir_roundfp: {
 573       assert(op-&gt;as_OpRoundFP() != NULL, &quot;must be&quot;);
 574       LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;
 575 
 576       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 577       assert(opRoundFP-&gt;_tmp-&gt;is_illegal(), &quot;not used&quot;);
 578       do_input(opRoundFP-&gt;_opr);
 579       do_output(opRoundFP-&gt;_result);
 580 
 581       break;
 582     }
 583 
 584 
 585 // LIR_Op2
 586     case lir_cmp:
 587     case lir_cmp_l2i:
 588     case lir_ucmp_fd2i:
 589     case lir_cmp_fd2i:
 590     case lir_add:
 591     case lir_sub:
 592     case lir_mul:
 593     case lir_div:
 594     case lir_rem:
 595     case lir_sqrt:
 596     case lir_abs:
 597     case lir_neg:
 598     case lir_logic_and:
 599     case lir_logic_or:
 600     case lir_logic_xor:
 601     case lir_shl:
 602     case lir_shr:
 603     case lir_ushr:
 604     case lir_xadd:
 605     case lir_xchg:
 606     case lir_assert:
 607     {
 608       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 609       LIR_Op2* op2 = (LIR_Op2*)op;
 610       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 611              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 612 
 613       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 614       if (op2-&gt;_opr1-&gt;is_valid())         do_input(op2-&gt;_opr1);
 615       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2);
 616       if (op2-&gt;_tmp1-&gt;is_valid())         do_temp(op2-&gt;_tmp1);
 617       if (op2-&gt;_result-&gt;is_valid())       do_output(op2-&gt;_result);
 618       if (op-&gt;code() == lir_xchg || op-&gt;code() == lir_xadd) {
 619         // on ARM and PPC, return value is loaded first so could
 620         // destroy inputs. On other platforms that implement those
 621         // (x86, sparc), the extra constrainsts are harmless.
 622         if (op2-&gt;_opr1-&gt;is_valid())       do_temp(op2-&gt;_opr1);
 623         if (op2-&gt;_opr2-&gt;is_valid())       do_temp(op2-&gt;_opr2);
 624       }
 625 
 626       break;
 627     }
 628 
 629     // special handling for cmove: right input operand must not be equal
 630     // to the result operand, otherwise the backend fails
 631     case lir_cmove:
 632     {
 633       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 634       LIR_Op2* op2 = (LIR_Op2*)op;
 635 
 636       assert(op2-&gt;_info == NULL &amp;&amp; op2-&gt;_tmp1-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp;
 637              op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 638       assert(op2-&gt;_opr1-&gt;is_valid() &amp;&amp; op2-&gt;_opr2-&gt;is_valid() &amp;&amp; op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 639 
 640       do_input(op2-&gt;_opr1);
 641       do_input(op2-&gt;_opr2);
 642       do_temp(op2-&gt;_opr2);
 643       do_output(op2-&gt;_result);
 644 
 645       break;
 646     }
 647 
 648     // vspecial handling for strict operations: register input operands
 649     // as temp to guarantee that they do not overlap with other
 650     // registers
 651     case lir_mul_strictfp:
 652     case lir_div_strictfp:
 653     {
 654       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 655       LIR_Op2* op2 = (LIR_Op2*)op;
 656 
 657       assert(op2-&gt;_info == NULL, &quot;not used&quot;);
 658       assert(op2-&gt;_opr1-&gt;is_valid(), &quot;used&quot;);
 659       assert(op2-&gt;_opr2-&gt;is_valid(), &quot;used&quot;);
 660       assert(op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 661       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 662              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 663 
 664       do_input(op2-&gt;_opr1); do_temp(op2-&gt;_opr1);
 665       do_input(op2-&gt;_opr2); do_temp(op2-&gt;_opr2);
 666       if (op2-&gt;_tmp1-&gt;is_valid()) do_temp(op2-&gt;_tmp1);
 667       do_output(op2-&gt;_result);
 668 
 669       break;
 670     }
 671 
 672     case lir_throw: {
 673       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 674       LIR_Op2* op2 = (LIR_Op2*)op;
 675 
 676       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 677       if (op2-&gt;_opr1-&gt;is_valid())         do_temp(op2-&gt;_opr1);
 678       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2); // exception object is input parameter
 679       assert(op2-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 680       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 681              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 682 
 683       break;
 684     }
 685 
 686     case lir_unwind: {
 687       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 688       LIR_Op1* op1 = (LIR_Op1*)op;
 689 
 690       assert(op1-&gt;_info == NULL, &quot;no info&quot;);
 691       assert(op1-&gt;_opr-&gt;is_valid(), &quot;exception oop&quot;);         do_input(op1-&gt;_opr);
 692       assert(op1-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 693 
 694       break;
 695     }
 696 
 697 // LIR_Op3
 698     case lir_idiv:
 699     case lir_irem: {
 700       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 701       LIR_Op3* op3= (LIR_Op3*)op;
 702 
 703       if (op3-&gt;_info)                     do_info(op3-&gt;_info);
 704       if (op3-&gt;_opr1-&gt;is_valid())         do_input(op3-&gt;_opr1);
 705 
 706       // second operand is input and temp, so ensure that second operand
 707       // and third operand get not the same register
 708       if (op3-&gt;_opr2-&gt;is_valid())         do_input(op3-&gt;_opr2);
 709       if (op3-&gt;_opr2-&gt;is_valid())         do_temp(op3-&gt;_opr2);
 710       if (op3-&gt;_opr3-&gt;is_valid())         do_temp(op3-&gt;_opr3);
 711 
 712       if (op3-&gt;_result-&gt;is_valid())       do_output(op3-&gt;_result);
 713 
 714       break;
 715     }
 716 
 717     case lir_fmad:
 718     case lir_fmaf: {
 719       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 720       LIR_Op3* op3= (LIR_Op3*)op;
 721       assert(op3-&gt;_info == NULL, &quot;no info&quot;);
 722       do_input(op3-&gt;_opr1);
 723       do_input(op3-&gt;_opr2);
 724       do_input(op3-&gt;_opr3);
 725       do_output(op3-&gt;_result);
 726       break;
 727     }
 728 
 729 // LIR_OpJavaCall
 730     case lir_static_call:
 731     case lir_optvirtual_call:
 732     case lir_icvirtual_call:
 733     case lir_virtual_call:
 734     case lir_dynamic_call: {
 735       LIR_OpJavaCall* opJavaCall = op-&gt;as_OpJavaCall();
 736       assert(opJavaCall != NULL, &quot;must be&quot;);
 737 
 738       if (opJavaCall-&gt;_receiver-&gt;is_valid())     do_input(opJavaCall-&gt;_receiver);
 739 
 740       // only visit register parameters
 741       int n = opJavaCall-&gt;_arguments-&gt;length();
 742       for (int i = opJavaCall-&gt;_receiver-&gt;is_valid() ? 1 : 0; i &lt; n; i++) {
 743         if (!opJavaCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 744           do_input(*opJavaCall-&gt;_arguments-&gt;adr_at(i));
 745         }
 746       }
 747 
 748       if (opJavaCall-&gt;_info)                     do_info(opJavaCall-&gt;_info);
 749       if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &amp;&amp;
 750           opJavaCall-&gt;is_method_handle_invoke()) {
 751         opJavaCall-&gt;_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();
 752         do_temp(opJavaCall-&gt;_method_handle_invoke_SP_save_opr);
 753       }
 754       do_call();
 755       if (opJavaCall-&gt;_result-&gt;is_valid())       do_output(opJavaCall-&gt;_result);
 756 
 757       break;
 758     }
 759 
 760 
 761 // LIR_OpRTCall
 762     case lir_rtcall: {
 763       assert(op-&gt;as_OpRTCall() != NULL, &quot;must be&quot;);
 764       LIR_OpRTCall* opRTCall = (LIR_OpRTCall*)op;
 765 
 766       // only visit register parameters
 767       int n = opRTCall-&gt;_arguments-&gt;length();
 768       for (int i = 0; i &lt; n; i++) {
 769         if (!opRTCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 770           do_input(*opRTCall-&gt;_arguments-&gt;adr_at(i));
 771         }
 772       }
 773       if (opRTCall-&gt;_info)                     do_info(opRTCall-&gt;_info);
 774       if (opRTCall-&gt;_tmp-&gt;is_valid())          do_temp(opRTCall-&gt;_tmp);
 775       do_call();
 776       if (opRTCall-&gt;_result-&gt;is_valid())       do_output(opRTCall-&gt;_result);
 777 
 778       break;
 779     }
 780 
 781 
 782 // LIR_OpArrayCopy
 783     case lir_arraycopy: {
 784       assert(op-&gt;as_OpArrayCopy() != NULL, &quot;must be&quot;);
 785       LIR_OpArrayCopy* opArrayCopy = (LIR_OpArrayCopy*)op;
 786 
 787       assert(opArrayCopy-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 788       assert(opArrayCopy-&gt;_src-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_src);     do_temp(opArrayCopy-&gt;_src);
 789       assert(opArrayCopy-&gt;_src_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_src_pos); do_temp(opArrayCopy-&gt;_src_pos);
 790       assert(opArrayCopy-&gt;_dst-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_dst);     do_temp(opArrayCopy-&gt;_dst);
 791       assert(opArrayCopy-&gt;_dst_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_dst_pos); do_temp(opArrayCopy-&gt;_dst_pos);
 792       assert(opArrayCopy-&gt;_length-&gt;is_valid(), &quot;used&quot;);       do_input(opArrayCopy-&gt;_length);  do_temp(opArrayCopy-&gt;_length);
 793       assert(opArrayCopy-&gt;_tmp-&gt;is_valid(), &quot;used&quot;);          do_temp(opArrayCopy-&gt;_tmp);
 794       if (opArrayCopy-&gt;_info)                     do_info(opArrayCopy-&gt;_info);
 795 
 796       // the implementation of arraycopy always has a call into the runtime
 797       do_call();
 798 
 799       break;
 800     }
 801 
 802 
 803 // LIR_OpUpdateCRC32
 804     case lir_updatecrc32: {
 805       assert(op-&gt;as_OpUpdateCRC32() != NULL, &quot;must be&quot;);
 806       LIR_OpUpdateCRC32* opUp = (LIR_OpUpdateCRC32*)op;
 807 
 808       assert(opUp-&gt;_crc-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_crc);     do_temp(opUp-&gt;_crc);
 809       assert(opUp-&gt;_val-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_val);     do_temp(opUp-&gt;_val);
 810       assert(opUp-&gt;_result-&gt;is_valid(), &quot;used&quot;);       do_output(opUp-&gt;_result);
 811       assert(opUp-&gt;_info == NULL, &quot;no info for LIR_OpUpdateCRC32&quot;);
 812 
 813       break;
 814     }
 815 
 816 
 817 // LIR_OpLock
 818     case lir_lock:
 819     case lir_unlock: {
 820       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 821       LIR_OpLock* opLock = (LIR_OpLock*)op;
 822 
 823       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 824 
 825       // TODO: check if these operands really have to be temp
 826       // (or if input is sufficient). This may have influence on the oop map!
 827       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 828       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 829       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 830 
 831       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 832       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 833 
 834       do_stub(opLock-&gt;_stub);
<a name="9" id="anc9"></a><span class="line-added"> 835       do_stub(opLock-&gt;_throw_imse_stub);</span>
 836 
 837       break;
 838     }
 839 
 840 
 841 // LIR_OpDelay
 842     case lir_delay_slot: {
 843       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 844       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 845 
 846       visit(opDelay-&gt;delay_op());
 847       break;
 848     }
 849 
 850 // LIR_OpTypeCheck
 851     case lir_instanceof:
 852     case lir_checkcast:
 853     case lir_store_check: {
 854       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 855       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 856 
 857       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 858       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 859       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 860       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 861         do_temp(opTypeCheck-&gt;_object);
 862       }
 863       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 864       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 865       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 866       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 867       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 868                                                   do_stub(opTypeCheck-&gt;_stub);
 869       break;
 870     }
 871 
<a name="10" id="anc10"></a><span class="line-added"> 872 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added"> 873     case lir_flattened_array_check: {</span>
<span class="line-added"> 874       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 875       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);</span>
<span class="line-added"> 878       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);</span>
<span class="line-added"> 879       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 880                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882       break;</span>
<span class="line-added"> 883     }</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added"> 886     case lir_null_free_array_check: {</span>
<span class="line-added"> 887       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 888       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);</span>
<span class="line-added"> 891       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 892       break;</span>
<span class="line-added"> 893     }</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895 // LIR_OpSubstitutabilityCheck</span>
<span class="line-added"> 896     case lir_substitutability_check: {</span>
<span class="line-added"> 897       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 898       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;</span>
<span class="line-added"> 899                                                                 do_input(opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 900                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 901                                                                 do_input(opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 902                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 903                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 904                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 905                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 906                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 907       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);</span>
<span class="line-added"> 908       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);</span>
<span class="line-added"> 909       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);</span>
<span class="line-added"> 910       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);</span>
<span class="line-added"> 911       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);</span>
<span class="line-added"> 912                                                                 do_info(opSubstitutabilityCheck-&gt;_info);</span>
<span class="line-added"> 913                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);</span>
<span class="line-added"> 914       break;</span>
<span class="line-added"> 915     }</span>
<span class="line-added"> 916 </span>
 917 // LIR_OpCompareAndSwap
 918     case lir_cas_long:
 919     case lir_cas_obj:
 920     case lir_cas_int: {
 921       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 922       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 923 
 924       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 925       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 926       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 927       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 928                                                       do_input(opCompareAndSwap-&gt;_addr);
 929                                                       do_temp(opCompareAndSwap-&gt;_addr);
 930                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 931                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 932                                                       do_input(opCompareAndSwap-&gt;_new_value);
 933                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 934       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 935       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 936       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
 937 
 938       break;
 939     }
 940 
 941 
 942 // LIR_OpAllocArray;
 943     case lir_alloc_array: {
 944       assert(op-&gt;as_OpAllocArray() != NULL, &quot;must be&quot;);
 945       LIR_OpAllocArray* opAllocArray = (LIR_OpAllocArray*)op;
 946 
 947       if (opAllocArray-&gt;_info)                        do_info(opAllocArray-&gt;_info);
 948       if (opAllocArray-&gt;_klass-&gt;is_valid())           do_input(opAllocArray-&gt;_klass); do_temp(opAllocArray-&gt;_klass);
 949       if (opAllocArray-&gt;_len-&gt;is_valid())             do_input(opAllocArray-&gt;_len);   do_temp(opAllocArray-&gt;_len);
 950       if (opAllocArray-&gt;_tmp1-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp1);
 951       if (opAllocArray-&gt;_tmp2-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp2);
 952       if (opAllocArray-&gt;_tmp3-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp3);
 953       if (opAllocArray-&gt;_tmp4-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp4);
 954       if (opAllocArray-&gt;_result-&gt;is_valid())          do_output(opAllocArray-&gt;_result);
 955                                                       do_stub(opAllocArray-&gt;_stub);
 956       break;
 957     }
 958 
 959 // LIR_OpProfileCall:
 960     case lir_profile_call: {
 961       assert(op-&gt;as_OpProfileCall() != NULL, &quot;must be&quot;);
 962       LIR_OpProfileCall* opProfileCall = (LIR_OpProfileCall*)op;
 963 
 964       if (opProfileCall-&gt;_recv-&gt;is_valid())              do_temp(opProfileCall-&gt;_recv);
 965       assert(opProfileCall-&gt;_mdo-&gt;is_valid(), &quot;used&quot;);   do_temp(opProfileCall-&gt;_mdo);
 966       assert(opProfileCall-&gt;_tmp1-&gt;is_valid(), &quot;used&quot;);  do_temp(opProfileCall-&gt;_tmp1);
 967       break;
 968     }
 969 
 970 // LIR_OpProfileType:
 971     case lir_profile_type: {
 972       assert(op-&gt;as_OpProfileType() != NULL, &quot;must be&quot;);
 973       LIR_OpProfileType* opProfileType = (LIR_OpProfileType*)op;
 974 
 975       do_input(opProfileType-&gt;_mdp); do_temp(opProfileType-&gt;_mdp);
 976       do_input(opProfileType-&gt;_obj);
 977       do_temp(opProfileType-&gt;_tmp);
 978       break;
 979     }
 980   default:
 981     op-&gt;visit(this);
 982   }
 983 }
 984 
 985 void LIR_Op::visit(LIR_OpVisitState* state) {
 986   ShouldNotReachHere();
 987 }
 988 
 989 void LIR_OpVisitState::do_stub(CodeStub* stub) {
 990   if (stub != NULL) {
 991     stub-&gt;visit(this);
 992   }
 993 }
 994 
 995 XHandlers* LIR_OpVisitState::all_xhandler() {
 996   XHandlers* result = NULL;
 997 
 998   int i;
 999   for (i = 0; i &lt; info_count(); i++) {
1000     if (info_at(i)-&gt;exception_handlers() != NULL) {
1001       result = info_at(i)-&gt;exception_handlers();
1002       break;
1003     }
1004   }
1005 
1006 #ifdef ASSERT
1007   for (i = 0; i &lt; info_count(); i++) {
1008     assert(info_at(i)-&gt;exception_handlers() == NULL ||
1009            info_at(i)-&gt;exception_handlers() == result,
1010            &quot;only one xhandler list allowed per LIR-operation&quot;);
1011   }
1012 #endif
1013 
1014   if (result != NULL) {
1015     return result;
1016   } else {
1017     return new XHandlers();
1018   }
1019 
1020   return result;
1021 }
1022 
1023 
1024 #ifdef ASSERT
1025 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1026   visit(op);
1027 
1028   return opr_count(inputMode) == 0 &amp;&amp;
1029          opr_count(outputMode) == 0 &amp;&amp;
1030          opr_count(tempMode) == 0 &amp;&amp;
1031          info_count() == 0 &amp;&amp;
1032          !has_call() &amp;&amp;
1033          !has_slow_case();
1034 }
1035 #endif
1036 
1037 //---------------------------------------------------
1038 
1039 
1040 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1041   masm-&gt;emit_call(this);
1042 }
1043 
<a name="11" id="anc11"></a><span class="line-added">1044 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {</span>
<span class="line-added">1045   if (InlineTypeReturnedAsFields) {</span>
<span class="line-added">1046     if (method()-&gt;signature()-&gt;maybe_returns_never_null()) {</span>
<span class="line-added">1047       ciType* return_type = method()-&gt;return_type();</span>
<span class="line-added">1048       if (return_type-&gt;is_valuetype()) {</span>
<span class="line-added">1049         ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
<span class="line-added">1050         if (vk-&gt;can_be_returned_as_fields()) {</span>
<span class="line-added">1051           if (vk_ret != NULL) {</span>
<span class="line-added">1052             *vk_ret = vk;</span>
<span class="line-added">1053           }</span>
<span class="line-added">1054           return true;</span>
<span class="line-added">1055         }</span>
<span class="line-added">1056       } else {</span>
<span class="line-added">1057         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="line-added">1058         if (vk_ret != NULL) {</span>
<span class="line-added">1059           *vk_ret = NULL;</span>
<span class="line-added">1060         }</span>
<span class="line-added">1061         return true;</span>
<span class="line-added">1062       }</span>
<span class="line-added">1063     } else if (is_method_handle_invoke()) {</span>
<span class="line-added">1064       BasicType bt = method()-&gt;return_type()-&gt;basic_type();</span>
<span class="line-added">1065       if (bt == T_OBJECT || bt == T_VALUETYPE) {</span>
<span class="line-added">1066         // A value type might be returned from the call but we don&#39;t know its</span>
<span class="line-added">1067         // type. Either we get a buffered value (and nothing needs to be done)</span>
<span class="line-added">1068         // or one of the values being returned is the klass of the value type</span>
<span class="line-added">1069         // (RAX on x64, with LSB set to 1) and we need to allocate a value</span>
<span class="line-added">1070         // type instance of that type and initialize it with other values being</span>
<span class="line-added">1071         // returned (in other registers).</span>
<span class="line-added">1072         // type.</span>
<span class="line-added">1073         if (vk_ret != NULL) {</span>
<span class="line-added">1074           *vk_ret = NULL;</span>
<span class="line-added">1075         }</span>
<span class="line-added">1076         return true;</span>
<span class="line-added">1077       }</span>
<span class="line-added">1078     }</span>
<span class="line-added">1079   }</span>
<span class="line-added">1080   return false;</span>
<span class="line-added">1081 }</span>
<span class="line-added">1082 </span>
1083 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1084   masm-&gt;emit_rtcall(this);
1085 }
1086 
1087 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1088   masm-&gt;emit_opLabel(this);
1089 }
1090 
1091 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1092   masm-&gt;emit_arraycopy(this);
1093   masm-&gt;append_code_stub(stub());
1094 }
1095 
1096 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1097   masm-&gt;emit_updatecrc32(this);
1098 }
1099 
1100 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1101   masm-&gt;emit_op0(this);
1102 }
1103 
1104 void LIR_Op1::emit_code(LIR_Assembler* masm) {
1105   masm-&gt;emit_op1(this);
1106 }
1107 
1108 void LIR_OpAllocObj::emit_code(LIR_Assembler* masm) {
1109   masm-&gt;emit_alloc_obj(this);
1110   masm-&gt;append_code_stub(stub());
1111 }
1112 
1113 void LIR_OpBranch::emit_code(LIR_Assembler* masm) {
1114   masm-&gt;emit_opBranch(this);
1115   if (stub()) {
1116     masm-&gt;append_code_stub(stub());
1117   }
1118 }
1119 
1120 void LIR_OpConvert::emit_code(LIR_Assembler* masm) {
1121   masm-&gt;emit_opConvert(this);
1122   if (stub() != NULL) {
1123     masm-&gt;append_code_stub(stub());
1124   }
1125 }
1126 
1127 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1128   masm-&gt;emit_op2(this);
1129 }
1130 
1131 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1132   masm-&gt;emit_alloc_array(this);
1133   masm-&gt;append_code_stub(stub());
1134 }
1135 
1136 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1137   masm-&gt;emit_opTypeCheck(this);
1138   if (stub()) {
1139     masm-&gt;append_code_stub(stub());
1140   }
1141 }
1142 
<a name="12" id="anc12"></a><span class="line-added">1143 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1144   masm-&gt;emit_opFlattenedArrayCheck(this);</span>
<span class="line-added">1145   if (stub() != NULL) {</span>
<span class="line-added">1146     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1147   }</span>
<span class="line-added">1148 }</span>
<span class="line-added">1149 </span>
<span class="line-added">1150 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1151   masm-&gt;emit_opNullFreeArrayCheck(this);</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1155   masm-&gt;emit_opSubstitutabilityCheck(this);</span>
<span class="line-added">1156   if (stub() != NULL) {</span>
<span class="line-added">1157     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1158   }</span>
<span class="line-added">1159 }</span>
<span class="line-added">1160 </span>
1161 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1162   masm-&gt;emit_compare_and_swap(this);
1163 }
1164 
1165 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1166   masm-&gt;emit_op3(this);
1167 }
1168 
1169 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1170   masm-&gt;emit_lock(this);
1171   if (stub()) {
1172     masm-&gt;append_code_stub(stub());
1173   }
<a name="13" id="anc13"></a><span class="line-added">1174   if (throw_imse_stub()) {</span>
<span class="line-added">1175     masm-&gt;append_code_stub(throw_imse_stub());</span>
<span class="line-added">1176   }</span>
1177 }
1178 
1179 #ifdef ASSERT
1180 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1181   masm-&gt;emit_assert(this);
1182 }
1183 #endif
1184 
1185 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1186   masm-&gt;emit_delay(this);
1187 }
1188 
1189 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1190   masm-&gt;emit_profile_call(this);
1191 }
1192 
1193 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1194   masm-&gt;emit_profile_type(this);
1195 }
1196 
1197 // LIR_List
1198 LIR_List::LIR_List(Compilation* compilation, BlockBegin* block)
1199   : _operations(8)
1200   , _compilation(compilation)
1201 #ifndef PRODUCT
1202   , _block(block)
1203 #endif
1204 #ifdef ASSERT
1205   , _file(NULL)
1206   , _line(0)
1207 #endif
1208 { }
1209 
1210 
1211 #ifdef ASSERT
1212 void LIR_List::set_file_and_line(const char * file, int line) {
1213   const char * f = strrchr(file, &#39;/&#39;);
1214   if (f == NULL) f = strrchr(file, &#39;\\&#39;);
1215   if (f == NULL) {
1216     f = file;
1217   } else {
1218     f++;
1219   }
1220   _file = f;
1221   _line = line;
1222 }
1223 #endif
1224 
1225 
1226 void LIR_List::append(LIR_InsertionBuffer* buffer) {
1227   assert(this == buffer-&gt;lir_list(), &quot;wrong lir list&quot;);
1228   const int n = _operations.length();
1229 
1230   if (buffer-&gt;number_of_ops() &gt; 0) {
1231     // increase size of instructions list
1232     _operations.at_grow(n + buffer-&gt;number_of_ops() - 1, NULL);
1233     // insert ops from buffer into instructions list
1234     int op_index = buffer-&gt;number_of_ops() - 1;
1235     int ip_index = buffer-&gt;number_of_insertion_points() - 1;
1236     int from_index = n - 1;
1237     int to_index = _operations.length() - 1;
1238     for (; ip_index &gt;= 0; ip_index --) {
1239       int index = buffer-&gt;index_at(ip_index);
1240       // make room after insertion point
1241       while (index &lt; from_index) {
1242         _operations.at_put(to_index --, _operations.at(from_index --));
1243       }
1244       // insert ops from buffer
1245       for (int i = buffer-&gt;count_at(ip_index); i &gt; 0; i --) {
1246         _operations.at_put(to_index --, buffer-&gt;op_at(op_index --));
1247       }
1248     }
1249   }
1250 
1251   buffer-&gt;finish();
1252 }
1253 
1254 
1255 void LIR_List::oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info) {
1256   assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;);
1257   append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),  reg, T_OBJECT, lir_patch_normal, info));
1258 }
1259 
1260 void LIR_List::klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info) {
1261   assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;);
1262   append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg, T_METADATA, lir_patch_normal, info));
1263 }
1264 
1265 void LIR_List::load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1266   append(new LIR_Op1(
1267             lir_move,
1268             LIR_OprFact::address(addr),
1269             src,
1270             addr-&gt;type(),
1271             patch_code,
1272             info));
1273 }
1274 
1275 
1276 void LIR_List::volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1277   append(new LIR_Op1(
1278             lir_move,
1279             LIR_OprFact::address(address),
1280             dst,
1281             address-&gt;type(),
1282             patch_code,
1283             info, lir_move_volatile));
1284 }
1285 
1286 void LIR_List::volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1287   append(new LIR_Op1(
1288             lir_move,
1289             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1290             dst,
1291             type,
1292             patch_code,
1293             info, lir_move_volatile));
1294 }
1295 
1296 
1297 void LIR_List::store_mem_int(jint v, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1298   append(new LIR_Op1(
1299             lir_move,
1300             LIR_OprFact::intConst(v),
1301             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1302             type,
1303             patch_code,
1304             info));
1305 }
1306 
1307 
1308 void LIR_List::store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1309   append(new LIR_Op1(
1310             lir_move,
1311             LIR_OprFact::oopConst(o),
1312             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1313             type,
1314             patch_code,
1315             info));
1316 }
1317 
1318 
1319 void LIR_List::store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1320   append(new LIR_Op1(
1321             lir_move,
1322             src,
1323             LIR_OprFact::address(addr),
1324             addr-&gt;type(),
1325             patch_code,
1326             info));
1327 }
1328 
1329 
1330 void LIR_List::volatile_store_mem_reg(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1331   append(new LIR_Op1(
1332             lir_move,
1333             src,
1334             LIR_OprFact::address(addr),
1335             addr-&gt;type(),
1336             patch_code,
1337             info,
1338             lir_move_volatile));
1339 }
1340 
1341 void LIR_List::volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1342   append(new LIR_Op1(
1343             lir_move,
1344             src,
1345             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1346             type,
1347             patch_code,
1348             info, lir_move_volatile));
1349 }
1350 
1351 
1352 void LIR_List::idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1353   append(new LIR_Op3(
1354                     lir_idiv,
1355                     left,
1356                     right,
1357                     tmp,
1358                     res,
1359                     info));
1360 }
1361 
1362 
1363 void LIR_List::idiv(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1364   append(new LIR_Op3(
1365                     lir_idiv,
1366                     left,
1367                     LIR_OprFact::intConst(right),
1368                     tmp,
1369                     res,
1370                     info));
1371 }
1372 
1373 
1374 void LIR_List::irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1375   append(new LIR_Op3(
1376                     lir_irem,
1377                     left,
1378                     right,
1379                     tmp,
1380                     res,
1381                     info));
1382 }
1383 
1384 
1385 void LIR_List::irem(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1386   append(new LIR_Op3(
1387                     lir_irem,
1388                     left,
1389                     LIR_OprFact::intConst(right),
1390                     tmp,
1391                     res,
1392                     info));
1393 }
1394 
1395 
1396 void LIR_List::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
1397   append(new LIR_Op2(
1398                     lir_cmp,
1399                     condition,
1400                     LIR_OprFact::address(new LIR_Address(base, disp, T_INT)),
1401                     LIR_OprFact::intConst(c),
1402                     info));
1403 }
1404 
1405 
1406 void LIR_List::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info) {
1407   append(new LIR_Op2(
1408                     lir_cmp,
1409                     condition,
1410                     reg,
1411                     LIR_OprFact::address(addr),
1412                     info));
1413 }
1414 
1415 void LIR_List::allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1416                                int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub) {
1417   append(new LIR_OpAllocObj(
1418                            klass,
1419                            dst,
1420                            t1,
1421                            t2,
1422                            t3,
1423                            t4,
1424                            header_size,
1425                            object_size,
1426                            init_check,
1427                            stub));
1428 }
1429 
1430 void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {
1431   append(new LIR_OpAllocArray(
1432                            klass,
1433                            len,
1434                            dst,
1435                            t1,
1436                            t2,
1437                            t3,
1438                            t4,
1439                            type,
1440                            stub));
1441 }
1442 
1443 void LIR_List::shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1444  append(new LIR_Op2(
1445                     lir_shl,
1446                     value,
1447                     count,
1448                     dst,
1449                     tmp));
1450 }
1451 
1452 void LIR_List::shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1453  append(new LIR_Op2(
1454                     lir_shr,
1455                     value,
1456                     count,
1457                     dst,
1458                     tmp));
1459 }
1460 
1461 
1462 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1463  append(new LIR_Op2(
1464                     lir_ushr,
1465                     value,
1466                     count,
1467                     dst,
1468                     tmp));
1469 }
1470 
1471 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1472   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1473                      left,
1474                      right,
1475                      dst));
1476 }
1477 
<a name="14" id="anc14"></a><span class="line-modified">1478 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {</span>
1479   append(new LIR_OpLock(
1480                     lir_lock,
1481                     hdr,
1482                     obj,
1483                     lock,
1484                     scratch,
1485                     stub,
<a name="15" id="anc15"></a><span class="line-modified">1486                     info,</span>
<span class="line-added">1487                     throw_imse_stub));</span>
1488 }
1489 
1490 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1491   append(new LIR_OpLock(
1492                     lir_unlock,
1493                     hdr,
1494                     obj,
1495                     lock,
1496                     scratch,
1497                     stub,
1498                     NULL));
1499 }
1500 
1501 
1502 void check_LIR() {
1503   // cannot do the proper checking as PRODUCT and other modes return different results
1504   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1505 }
1506 
1507 
1508 
1509 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1510                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1511                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<a name="16" id="anc16"></a><span class="line-modified">1512                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {</span>
<span class="line-added">1513   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check</span>
<span class="line-added">1514   // on the object.</span>
<span class="line-added">1515   bool need_null_check = !is_never_null;</span>
1516   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<a name="17" id="anc17"></a><span class="line-modified">1517                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,</span>
<span class="line-added">1518                                            need_null_check);</span>
1519   if (profiled_method != NULL) {
1520     c-&gt;set_profiled_method(profiled_method);
1521     c-&gt;set_profiled_bci(profiled_bci);
1522     c-&gt;set_should_profile(true);
1523   }
1524   append(c);
1525 }
1526 
1527 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1528   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1529   if (profiled_method != NULL) {
1530     c-&gt;set_profiled_method(profiled_method);
1531     c-&gt;set_profiled_bci(profiled_bci);
1532     c-&gt;set_should_profile(true);
1533   }
1534   append(c);
1535 }
1536 
1537 
1538 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1539                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
<a name="18" id="anc18"></a><span class="line-added">1540   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass</span>
1541   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1542   if (profiled_method != NULL) {
1543     c-&gt;set_profiled_method(profiled_method);
1544     c-&gt;set_profiled_bci(profiled_bci);
1545     c-&gt;set_should_profile(true);
1546   }
1547   append(c);
1548 }
1549 
1550 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1551   if (deoptimize_on_null) {
1552     // Emit an explicit null check and deoptimize if opr is null
1553     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1554     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1555     branch(lir_cond_equal, T_OBJECT, deopt);
1556   } else {
1557     // Emit an implicit null check
1558     append(new LIR_Op1(lir_null_check, opr, info));
1559   }
1560 }
1561 
<a name="19" id="anc19"></a><span class="line-added">1562 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {</span>
<span class="line-added">1563   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);</span>
<span class="line-added">1564   append(c);</span>
<span class="line-added">1565 }</span>
<span class="line-added">1566 </span>
<span class="line-added">1567 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {</span>
<span class="line-added">1568   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);</span>
<span class="line-added">1569   append(c);</span>
<span class="line-added">1570 }</span>
<span class="line-added">1571 </span>
<span class="line-added">1572 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1573                                       LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1574                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1575                                       CodeEmitInfo* info, CodeStub* stub) {</span>
<span class="line-added">1576   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,</span>
<span class="line-added">1577                                                                    tmp1, tmp2,</span>
<span class="line-added">1578                                                                    left_klass, right_klass, left_klass_op, right_klass_op,</span>
<span class="line-added">1579                                                                    info, stub);</span>
<span class="line-added">1580   append(c);</span>
<span class="line-added">1581 }</span>
<span class="line-added">1582 </span>
1583 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1584                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1585   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1586 }
1587 
1588 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1589                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1590   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1591 }
1592 
1593 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1594                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1595   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1596 }
1597 
1598 
1599 #ifdef PRODUCT
1600 
1601 void print_LIR(BlockList* blocks) {
1602 }
1603 
1604 #else
1605 // LIR_OprDesc
1606 void LIR_OprDesc::print() const {
1607   print(tty);
1608 }
1609 
1610 void LIR_OprDesc::print(outputStream* out) const {
1611   if (is_illegal()) {
1612     return;
1613   }
1614 
1615   out-&gt;print(&quot;[&quot;);
1616   if (is_pointer()) {
1617     pointer()-&gt;print_value_on(out);
1618   } else if (is_single_stack()) {
1619     out-&gt;print(&quot;stack:%d&quot;, single_stack_ix());
1620   } else if (is_double_stack()) {
1621     out-&gt;print(&quot;dbl_stack:%d&quot;,double_stack_ix());
1622   } else if (is_virtual()) {
1623     out-&gt;print(&quot;R%d&quot;, vreg_number());
1624   } else if (is_single_cpu()) {
1625     out-&gt;print(&quot;%s&quot;, as_register()-&gt;name());
1626   } else if (is_double_cpu()) {
1627     out-&gt;print(&quot;%s&quot;, as_register_hi()-&gt;name());
1628     out-&gt;print(&quot;%s&quot;, as_register_lo()-&gt;name());
1629 #if defined(X86)
1630   } else if (is_single_xmm()) {
1631     out-&gt;print(&quot;%s&quot;, as_xmm_float_reg()-&gt;name());
1632   } else if (is_double_xmm()) {
1633     out-&gt;print(&quot;%s&quot;, as_xmm_double_reg()-&gt;name());
1634   } else if (is_single_fpu()) {
1635     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1636   } else if (is_double_fpu()) {
1637     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1638 #elif defined(AARCH64)
1639   } else if (is_single_fpu()) {
1640     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1641   } else if (is_double_fpu()) {
1642     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1643 #elif defined(ARM)
1644   } else if (is_single_fpu()) {
1645     out-&gt;print(&quot;s%d&quot;, fpu_regnr());
1646   } else if (is_double_fpu()) {
1647     out-&gt;print(&quot;d%d&quot;, fpu_regnrLo() &gt;&gt; 1);
1648 #else
1649   } else if (is_single_fpu()) {
1650     out-&gt;print(&quot;%s&quot;, as_float_reg()-&gt;name());
1651   } else if (is_double_fpu()) {
1652     out-&gt;print(&quot;%s&quot;, as_double_reg()-&gt;name());
1653 #endif
1654 
1655   } else if (is_illegal()) {
1656     out-&gt;print(&quot;-&quot;);
1657   } else {
1658     out-&gt;print(&quot;Unknown Operand&quot;);
1659   }
1660   if (!is_illegal()) {
1661     out-&gt;print(&quot;|%c&quot;, type_char());
1662   }
1663   if (is_register() &amp;&amp; is_last_use()) {
1664     out-&gt;print(&quot;(last_use)&quot;);
1665   }
1666   out-&gt;print(&quot;]&quot;);
1667 }
1668 
1669 
1670 // LIR_Address
1671 void LIR_Const::print_value_on(outputStream* out) const {
1672   switch (type()) {
1673     case T_ADDRESS:out-&gt;print(&quot;address:%d&quot;,as_jint());          break;
1674     case T_INT:    out-&gt;print(&quot;int:%d&quot;,   as_jint());           break;
1675     case T_LONG:   out-&gt;print(&quot;lng:&quot; JLONG_FORMAT, as_jlong()); break;
1676     case T_FLOAT:  out-&gt;print(&quot;flt:%f&quot;,   as_jfloat());         break;
1677     case T_DOUBLE: out-&gt;print(&quot;dbl:%f&quot;,   as_jdouble());        break;
1678     case T_OBJECT: out-&gt;print(&quot;obj:&quot; INTPTR_FORMAT, p2i(as_jobject()));        break;
1679     case T_METADATA: out-&gt;print(&quot;metadata:&quot; INTPTR_FORMAT, p2i(as_metadata()));break;
1680     default:       out-&gt;print(&quot;%3d:0x&quot; UINT64_FORMAT_X, type(), (uint64_t)as_jlong()); break;
1681   }
1682 }
1683 
1684 // LIR_Address
1685 void LIR_Address::print_value_on(outputStream* out) const {
1686   out-&gt;print(&quot;Base:&quot;); _base-&gt;print(out);
1687   if (!_index-&gt;is_illegal()) {
1688     out-&gt;print(&quot; Index:&quot;); _index-&gt;print(out);
1689     switch (scale()) {
1690     case times_1: break;
1691     case times_2: out-&gt;print(&quot; * 2&quot;); break;
1692     case times_4: out-&gt;print(&quot; * 4&quot;); break;
1693     case times_8: out-&gt;print(&quot; * 8&quot;); break;
1694     }
1695   }
1696   out-&gt;print(&quot; Disp: &quot; INTX_FORMAT, _disp);
1697 }
1698 
1699 // debug output of block header without InstructionPrinter
1700 //       (because phi functions are not necessary for LIR)
1701 static void print_block(BlockBegin* x) {
1702   // print block id
1703   BlockEnd* end = x-&gt;end();
1704   tty-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
1705 
1706   // print flags
1707   if (x-&gt;is_set(BlockBegin::std_entry_flag))               tty-&gt;print(&quot;std &quot;);
1708   if (x-&gt;is_set(BlockBegin::osr_entry_flag))               tty-&gt;print(&quot;osr &quot;);
1709   if (x-&gt;is_set(BlockBegin::exception_entry_flag))         tty-&gt;print(&quot;ex &quot;);
1710   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag))        tty-&gt;print(&quot;jsr &quot;);
1711   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag))  tty-&gt;print(&quot;bb &quot;);
1712   if (x-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) tty-&gt;print(&quot;lh &quot;);
1713   if (x-&gt;is_set(BlockBegin::linear_scan_loop_end_flag))    tty-&gt;print(&quot;le &quot;);
1714 
1715   // print block bci range
1716   tty-&gt;print(&quot;[%d, %d] &quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
1717 
1718   // print predecessors and successors
1719   if (x-&gt;number_of_preds() &gt; 0) {
1720     tty-&gt;print(&quot;preds: &quot;);
1721     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
1722       tty-&gt;print(&quot;B%d &quot;, x-&gt;pred_at(i)-&gt;block_id());
1723     }
1724   }
1725 
1726   if (x-&gt;number_of_sux() &gt; 0) {
1727     tty-&gt;print(&quot;sux: &quot;);
1728     for (int i = 0; i &lt; x-&gt;number_of_sux(); i ++) {
1729       tty-&gt;print(&quot;B%d &quot;, x-&gt;sux_at(i)-&gt;block_id());
1730     }
1731   }
1732 
1733   // print exception handlers
1734   if (x-&gt;number_of_exception_handlers() &gt; 0) {
1735     tty-&gt;print(&quot;xhandler: &quot;);
1736     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
1737       tty-&gt;print(&quot;B%d &quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
1738     }
1739   }
1740 
1741   tty-&gt;cr();
1742 }
1743 
1744 void print_LIR(BlockList* blocks) {
1745   tty-&gt;print_cr(&quot;LIR:&quot;);
1746   int i;
1747   for (i = 0; i &lt; blocks-&gt;length(); i++) {
1748     BlockBegin* bb = blocks-&gt;at(i);
1749     print_block(bb);
1750     tty-&gt;print(&quot;__id_Instruction___________________________________________&quot;); tty-&gt;cr();
1751     bb-&gt;lir()-&gt;print_instructions();
1752   }
1753 }
1754 
1755 void LIR_List::print_instructions() {
1756   for (int i = 0; i &lt; _operations.length(); i++) {
1757     _operations.at(i)-&gt;print(); tty-&gt;cr();
1758   }
1759   tty-&gt;cr();
1760 }
1761 
1762 // LIR_Ops printing routines
1763 // LIR_Op
1764 void LIR_Op::print_on(outputStream* out) const {
1765   if (id() != -1 || PrintCFGToFile) {
1766     out-&gt;print(&quot;%4d &quot;, id());
1767   } else {
1768     out-&gt;print(&quot;     &quot;);
1769   }
1770   out-&gt;print(&quot;%s &quot;, name());
1771   print_instr(out);
1772   if (info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info()-&gt;stack()-&gt;bci());
1773 #ifdef ASSERT
1774   if (Verbose &amp;&amp; _file != NULL) {
1775     out-&gt;print(&quot; (%s:%d)&quot;, _file, _line);
1776   }
1777 #endif
1778 }
1779 
1780 const char * LIR_Op::name() const {
1781   const char* s = NULL;
1782   switch(code()) {
1783      // LIR_Op0
1784      case lir_membar:                s = &quot;membar&quot;;        break;
1785      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1786      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1787      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1788      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1789      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1790      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1791      case lir_label:                 s = &quot;label&quot;;         break;
1792      case lir_nop:                   s = &quot;nop&quot;;           break;
1793      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1794      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1795      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1796      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1797      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1798      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1799      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<a name="20" id="anc20"></a><span class="line-added">1800      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;</span>
1801      // LIR_Op1
1802      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1803      case lir_fld:                   s = &quot;fld&quot;;           break;
1804      case lir_push:                  s = &quot;push&quot;;          break;
1805      case lir_pop:                   s = &quot;pop&quot;;           break;
1806      case lir_null_check:            s = &quot;null_check&quot;;    break;
1807      case lir_return:                s = &quot;return&quot;;        break;
1808      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1809      case lir_leal:                  s = &quot;leal&quot;;          break;
1810      case lir_branch:                s = &quot;branch&quot;;        break;
1811      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1812      case lir_move:                  s = &quot;move&quot;;          break;
1813      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1814      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1815      case lir_throw:                 s = &quot;throw&quot;;         break;
1816      case lir_unwind:                s = &quot;unwind&quot;;        break;
1817      case lir_convert:               s = &quot;convert&quot;;       break;
1818      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1819      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1820      // LIR_Op2
1821      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1822      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1823      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1824      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1825      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1826      case lir_add:                   s = &quot;add&quot;;           break;
1827      case lir_sub:                   s = &quot;sub&quot;;           break;
1828      case lir_mul:                   s = &quot;mul&quot;;           break;
1829      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1830      case lir_div:                   s = &quot;div&quot;;           break;
1831      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1832      case lir_rem:                   s = &quot;rem&quot;;           break;
1833      case lir_abs:                   s = &quot;abs&quot;;           break;
1834      case lir_neg:                   s = &quot;neg&quot;;           break;
1835      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1836      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1837      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1838      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1839      case lir_shl:                   s = &quot;shift_left&quot;;    break;
1840      case lir_shr:                   s = &quot;shift_right&quot;;   break;
1841      case lir_ushr:                  s = &quot;ushift_right&quot;;  break;
1842      case lir_alloc_array:           s = &quot;alloc_array&quot;;   break;
1843      case lir_xadd:                  s = &quot;xadd&quot;;          break;
1844      case lir_xchg:                  s = &quot;xchg&quot;;          break;
1845      // LIR_Op3
1846      case lir_idiv:                  s = &quot;idiv&quot;;          break;
1847      case lir_irem:                  s = &quot;irem&quot;;          break;
1848      case lir_fmad:                  s = &quot;fmad&quot;;          break;
1849      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1850      // LIR_OpJavaCall
1851      case lir_static_call:           s = &quot;static&quot;;        break;
1852      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1853      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1854      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1855      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1856      // LIR_OpArrayCopy
1857      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1858      // LIR_OpUpdateCRC32
1859      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1860      // LIR_OpLock
1861      case lir_lock:                  s = &quot;lock&quot;;          break;
1862      case lir_unlock:                s = &quot;unlock&quot;;        break;
1863      // LIR_OpDelay
1864      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1865      // LIR_OpTypeCheck
1866      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1867      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1868      case lir_store_check:           s = &quot;store_check&quot;;   break;
<a name="21" id="anc21"></a><span class="line-added">1869      // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1870      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;</span>
<span class="line-added">1871      // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1872      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;</span>
<span class="line-added">1873      // LIR_OpSubstitutabilityCheck</span>
<span class="line-added">1874      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;</span>
1875      // LIR_OpCompareAndSwap
1876      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1877      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1878      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1879      // LIR_OpProfileCall
1880      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1881      // LIR_OpProfileType
1882      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1883      // LIR_OpAssert
1884 #ifdef ASSERT
1885      case lir_assert:                s = &quot;assert&quot;;        break;
1886 #endif
1887      case lir_none:                  ShouldNotReachHere();break;
1888     default:                         s = &quot;illegal_op&quot;;    break;
1889   }
1890   return s;
1891 }
1892 
1893 // LIR_OpJavaCall
1894 void LIR_OpJavaCall::print_instr(outputStream* out) const {
1895   out-&gt;print(&quot;call: &quot;);
1896   out-&gt;print(&quot;[addr: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(address()));
1897   if (receiver()-&gt;is_valid()) {
1898     out-&gt;print(&quot; [recv: &quot;);   receiver()-&gt;print(out);   out-&gt;print(&quot;]&quot;);
1899   }
1900   if (result_opr()-&gt;is_valid()) {
1901     out-&gt;print(&quot; [result: &quot;); result_opr()-&gt;print(out); out-&gt;print(&quot;]&quot;);
1902   }
1903 }
1904 
1905 // LIR_OpLabel
1906 void LIR_OpLabel::print_instr(outputStream* out) const {
1907   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(_label));
1908 }
1909 
1910 // LIR_OpArrayCopy
1911 void LIR_OpArrayCopy::print_instr(outputStream* out) const {
1912   src()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1913   src_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1914   dst()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1915   dst_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1916   length()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1917   tmp()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1918 }
1919 
1920 // LIR_OpUpdateCRC32
1921 void LIR_OpUpdateCRC32::print_instr(outputStream* out) const {
1922   crc()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1923   val()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1924   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1925 }
1926 
1927 // LIR_OpCompareAndSwap
1928 void LIR_OpCompareAndSwap::print_instr(outputStream* out) const {
1929   addr()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1930   cmp_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1931   new_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1932   tmp1()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1933   tmp2()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1934 
1935 }
1936 
1937 // LIR_Op0
1938 void LIR_Op0::print_instr(outputStream* out) const {
1939   result_opr()-&gt;print(out);
1940 }
1941 
1942 // LIR_Op1
1943 const char * LIR_Op1::name() const {
1944   if (code() == lir_move) {
1945     switch (move_kind()) {
1946     case lir_move_normal:
1947       return &quot;move&quot;;
1948     case lir_move_unaligned:
1949       return &quot;unaligned move&quot;;
1950     case lir_move_volatile:
1951       return &quot;volatile_move&quot;;
1952     case lir_move_wide:
1953       return &quot;wide_move&quot;;
1954     default:
1955       ShouldNotReachHere();
1956     return &quot;illegal_op&quot;;
1957     }
1958   } else {
1959     return LIR_Op::name();
1960   }
1961 }
1962 
1963 
1964 void LIR_Op1::print_instr(outputStream* out) const {
1965   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1966   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1967   print_patch_code(out, patch_code());
1968 }
1969 
1970 
1971 // LIR_Op1
1972 void LIR_OpRTCall::print_instr(outputStream* out) const {
1973   intx a = (intx)addr();
1974   out-&gt;print(&quot;%s&quot;, Runtime1::name_for_address(addr()));
1975   out-&gt;print(&quot; &quot;);
1976   tmp()-&gt;print(out);
1977 }
1978 
1979 void LIR_Op1::print_patch_code(outputStream* out, LIR_PatchCode code) {
1980   switch(code) {
1981     case lir_patch_none:                                 break;
1982     case lir_patch_low:    out-&gt;print(&quot;[patch_low]&quot;);    break;
1983     case lir_patch_high:   out-&gt;print(&quot;[patch_high]&quot;);   break;
1984     case lir_patch_normal: out-&gt;print(&quot;[patch_normal]&quot;); break;
1985     default: ShouldNotReachHere();
1986   }
1987 }
1988 
1989 // LIR_OpBranch
1990 void LIR_OpBranch::print_instr(outputStream* out) const {
1991   print_condition(out, cond());             out-&gt;print(&quot; &quot;);
1992   if (block() != NULL) {
1993     out-&gt;print(&quot;[B%d] &quot;, block()-&gt;block_id());
1994   } else if (stub() != NULL) {
1995     out-&gt;print(&quot;[&quot;);
1996     stub()-&gt;print_name(out);
1997     out-&gt;print(&quot;: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()));
1998     if (stub()-&gt;info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, stub()-&gt;info()-&gt;stack()-&gt;bci());
1999   } else {
2000     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;] &quot;, p2i(label()));
2001   }
2002   if (ublock() != NULL) {
2003     out-&gt;print(&quot;unordered: [B%d] &quot;, ublock()-&gt;block_id());
2004   }
2005 }
2006 
2007 void LIR_Op::print_condition(outputStream* out, LIR_Condition cond) {
2008   switch(cond) {
2009     case lir_cond_equal:           out-&gt;print(&quot;[EQ]&quot;);      break;
2010     case lir_cond_notEqual:        out-&gt;print(&quot;[NE]&quot;);      break;
2011     case lir_cond_less:            out-&gt;print(&quot;[LT]&quot;);      break;
2012     case lir_cond_lessEqual:       out-&gt;print(&quot;[LE]&quot;);      break;
2013     case lir_cond_greaterEqual:    out-&gt;print(&quot;[GE]&quot;);      break;
2014     case lir_cond_greater:         out-&gt;print(&quot;[GT]&quot;);      break;
2015     case lir_cond_belowEqual:      out-&gt;print(&quot;[BE]&quot;);      break;
2016     case lir_cond_aboveEqual:      out-&gt;print(&quot;[AE]&quot;);      break;
2017     case lir_cond_always:          out-&gt;print(&quot;[AL]&quot;);      break;
2018     default:                       out-&gt;print(&quot;[%d]&quot;,cond); break;
2019   }
2020 }
2021 
2022 // LIR_OpConvert
2023 void LIR_OpConvert::print_instr(outputStream* out) const {
2024   print_bytecode(out, bytecode());
2025   in_opr()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2026   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2027 #ifdef PPC32
2028   if(tmp1()-&gt;is_valid()) {
2029     tmp1()-&gt;print(out); out-&gt;print(&quot; &quot;);
2030     tmp2()-&gt;print(out); out-&gt;print(&quot; &quot;);
2031   }
2032 #endif
2033 }
2034 
2035 void LIR_OpConvert::print_bytecode(outputStream* out, Bytecodes::Code code) {
2036   switch(code) {
2037     case Bytecodes::_d2f: out-&gt;print(&quot;[d2f] &quot;); break;
2038     case Bytecodes::_d2i: out-&gt;print(&quot;[d2i] &quot;); break;
2039     case Bytecodes::_d2l: out-&gt;print(&quot;[d2l] &quot;); break;
2040     case Bytecodes::_f2d: out-&gt;print(&quot;[f2d] &quot;); break;
2041     case Bytecodes::_f2i: out-&gt;print(&quot;[f2i] &quot;); break;
2042     case Bytecodes::_f2l: out-&gt;print(&quot;[f2l] &quot;); break;
2043     case Bytecodes::_i2b: out-&gt;print(&quot;[i2b] &quot;); break;
2044     case Bytecodes::_i2c: out-&gt;print(&quot;[i2c] &quot;); break;
2045     case Bytecodes::_i2d: out-&gt;print(&quot;[i2d] &quot;); break;
2046     case Bytecodes::_i2f: out-&gt;print(&quot;[i2f] &quot;); break;
2047     case Bytecodes::_i2l: out-&gt;print(&quot;[i2l] &quot;); break;
2048     case Bytecodes::_i2s: out-&gt;print(&quot;[i2s] &quot;); break;
2049     case Bytecodes::_l2i: out-&gt;print(&quot;[l2i] &quot;); break;
2050     case Bytecodes::_l2f: out-&gt;print(&quot;[l2f] &quot;); break;
2051     case Bytecodes::_l2d: out-&gt;print(&quot;[l2d] &quot;); break;
2052     default:
2053       out-&gt;print(&quot;[?%d]&quot;,code);
2054     break;
2055   }
2056 }
2057 
2058 void LIR_OpAllocObj::print_instr(outputStream* out) const {
2059   klass()-&gt;print(out);                      out-&gt;print(&quot; &quot;);
2060   obj()-&gt;print(out);                        out-&gt;print(&quot; &quot;);
2061   tmp1()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2062   tmp2()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2063   tmp3()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2064   tmp4()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
2065   out-&gt;print(&quot;[hdr:%d]&quot;, header_size()); out-&gt;print(&quot; &quot;);
2066   out-&gt;print(&quot;[obj:%d]&quot;, object_size()); out-&gt;print(&quot; &quot;);
2067   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2068 }
2069 
2070 void LIR_OpRoundFP::print_instr(outputStream* out) const {
2071   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
2072   tmp()-&gt;print(out);        out-&gt;print(&quot; &quot;);
2073   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
2074 }
2075 
2076 // LIR_Op2
2077 void LIR_Op2::print_instr(outputStream* out) const {
2078   if (code() == lir_cmove || code() == lir_cmp) {
2079     print_condition(out, condition());         out-&gt;print(&quot; &quot;);
2080   }
2081   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2082   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2083   if (tmp1_opr()-&gt;is_valid()) { tmp1_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2084   if (tmp2_opr()-&gt;is_valid()) { tmp2_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2085   if (tmp3_opr()-&gt;is_valid()) { tmp3_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2086   if (tmp4_opr()-&gt;is_valid()) { tmp4_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2087   if (tmp5_opr()-&gt;is_valid()) { tmp5_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
2088   result_opr()-&gt;print(out);
2089 }
2090 
2091 void LIR_OpAllocArray::print_instr(outputStream* out) const {
2092   klass()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
2093   len()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2094   obj()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
2095   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2096   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2097   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2098   tmp4()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2099   out-&gt;print(&quot;[type:0x%x]&quot;, type());     out-&gt;print(&quot; &quot;);
2100   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2101 }
2102 
2103 
2104 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2105   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2106   if (code() == lir_store_check) {
2107     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2108   }
2109   if (code() != lir_store_check) {
2110     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2111     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2112   }
2113   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2114   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2115   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2116   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2117   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2118 }
2119 
<a name="22" id="anc22"></a><span class="line-added">2120 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2121   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2122   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2123   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2124   if (stub() != NULL) {</span>
<span class="line-added">2125     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2126   }</span>
<span class="line-added">2127 }</span>
<span class="line-added">2128 </span>
<span class="line-added">2129 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2130   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2131   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2132 }</span>
<span class="line-added">2133 </span>
<span class="line-added">2134 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2135   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2136   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2137   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2138   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2139   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2140   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2141   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2142   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2143   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2144   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2145   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2146   if (stub() != NULL) {</span>
<span class="line-added">2147     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2148   }</span>
<span class="line-added">2149 }</span>
2150 
2151 // LIR_Op3
2152 void LIR_Op3::print_instr(outputStream* out) const {
2153   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2154   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2155   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2156   result_opr()-&gt;print(out);
2157 }
2158 
2159 
2160 void LIR_OpLock::print_instr(outputStream* out) const {
2161   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2162   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2163   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2164   if (_scratch-&gt;is_valid()) {
2165     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2166   }
2167   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2168 }
2169 
2170 #ifdef ASSERT
2171 void LIR_OpAssert::print_instr(outputStream* out) const {
2172   print_condition(out, condition()); out-&gt;print(&quot; &quot;);
2173   in_opr1()-&gt;print(out);             out-&gt;print(&quot; &quot;);
2174   in_opr2()-&gt;print(out);             out-&gt;print(&quot;, \&quot;&quot;);
2175   out-&gt;print(&quot;%s&quot;, msg());          out-&gt;print(&quot;\&quot;&quot;);
2176 }
2177 #endif
2178 
2179 
2180 void LIR_OpDelay::print_instr(outputStream* out) const {
2181   _op-&gt;print_on(out);
2182 }
2183 
2184 
2185 // LIR_OpProfileCall
2186 void LIR_OpProfileCall::print_instr(outputStream* out) const {
2187   profiled_method()-&gt;name()-&gt;print_symbol_on(out);
2188   out-&gt;print(&quot;.&quot;);
2189   profiled_method()-&gt;holder()-&gt;name()-&gt;print_symbol_on(out);
2190   out-&gt;print(&quot; @ %d &quot;, profiled_bci());
2191   mdo()-&gt;print(out);           out-&gt;print(&quot; &quot;);
2192   recv()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2193   tmp1()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2194 }
2195 
2196 // LIR_OpProfileType
2197 void LIR_OpProfileType::print_instr(outputStream* out) const {
2198   out-&gt;print(&quot;exact = &quot;);
2199   if  (exact_klass() == NULL) {
2200     out-&gt;print(&quot;unknown&quot;);
2201   } else {
2202     exact_klass()-&gt;print_name_on(out);
2203   }
2204   out-&gt;print(&quot; current = &quot;); ciTypeEntries::print_ciklass(out, current_klass());
2205   out-&gt;print(&quot; &quot;);
2206   mdp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2207   obj()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2208   tmp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2209 }
2210 
2211 #endif // PRODUCT
2212 
2213 // Implementation of LIR_InsertionBuffer
2214 
2215 void LIR_InsertionBuffer::append(int index, LIR_Op* op) {
2216   assert(_index_and_count.length() % 2 == 0, &quot;must have a count for each index&quot;);
2217 
2218   int i = number_of_insertion_points() - 1;
2219   if (i &lt; 0 || index_at(i) &lt; index) {
2220     append_new(index, 1);
2221   } else {
2222     assert(index_at(i) == index, &quot;can append LIR_Ops in ascending order only&quot;);
2223     assert(count_at(i) &gt; 0, &quot;check&quot;);
2224     set_count_at(i, count_at(i) + 1);
2225   }
2226   _ops.push(op);
2227 
2228   DEBUG_ONLY(verify());
2229 }
2230 
2231 #ifdef ASSERT
2232 void LIR_InsertionBuffer::verify() {
2233   int sum = 0;
2234   int prev_idx = -1;
2235 
2236   for (int i = 0; i &lt; number_of_insertion_points(); i++) {
2237     assert(prev_idx &lt; index_at(i), &quot;index must be ordered ascending&quot;);
2238     sum += count_at(i);
2239   }
2240   assert(sum == number_of_ops(), &quot;wrong total sum&quot;);
2241 }
2242 #endif
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Runtime1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LinearScan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Runtime1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;code/pcDesc.hpp&quot;
  39 #include &quot;code/scopeDesc.hpp&quot;
  40 #include &quot;code/vtableStubs.hpp&quot;
  41 #include &quot;compiler/compilationPolicy.hpp&quot;
  42 #include &quot;compiler/disassembler.hpp&quot;
  43 #include &quot;gc/shared/barrierSet.hpp&quot;
  44 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  45 #include &quot;gc/shared/collectedHeap.hpp&quot;
  46 #include &quot;interpreter/bytecode.hpp&quot;
  47 #include &quot;interpreter/interpreter.hpp&quot;
  48 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  49 #include &quot;logging/log.hpp&quot;
  50 #include &quot;memory/allocation.inline.hpp&quot;
  51 #include &quot;memory/oopFactory.hpp&quot;
  52 #include &quot;memory/resourceArea.hpp&quot;
  53 #include &quot;memory/universe.hpp&quot;
  54 #include &quot;oops/access.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;


  58 #include &quot;runtime/atomic.hpp&quot;
  59 #include &quot;runtime/biasedLocking.hpp&quot;
  60 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/sharedRuntime.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/vframe.inline.hpp&quot;
  68 #include &quot;runtime/vframeArray.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/copy.hpp&quot;
  71 #include &quot;utilities/events.hpp&quot;
  72 
  73 
  74 // Implementation of StubAssembler
  75 
  76 StubAssembler::StubAssembler(CodeBuffer* code, const char * name, int stub_id) : C1_MacroAssembler(code) {
  77   _name = name;
</pre>
<hr />
<pre>
 102   }
 103   assert(_num_rt_args == args, &quot;can&#39;t change the number of args&quot;);
 104 }
 105 
 106 // Implementation of Runtime1
 107 
 108 CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];
 109 const char *Runtime1::_blob_names[] = {
 110   RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)
 111 };
 112 
 113 #ifndef PRODUCT
 114 // statistics
 115 int Runtime1::_generic_arraycopy_cnt = 0;
 116 int Runtime1::_generic_arraycopystub_cnt = 0;
 117 int Runtime1::_arraycopy_slowcase_cnt = 0;
 118 int Runtime1::_arraycopy_checkcast_cnt = 0;
 119 int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
 120 int Runtime1::_new_type_array_slowcase_cnt = 0;
 121 int Runtime1::_new_object_array_slowcase_cnt = 0;

 122 int Runtime1::_new_instance_slowcase_cnt = 0;
 123 int Runtime1::_new_multi_array_slowcase_cnt = 0;





 124 int Runtime1::_monitorenter_slowcase_cnt = 0;
 125 int Runtime1::_monitorexit_slowcase_cnt = 0;
 126 int Runtime1::_patch_code_slowcase_cnt = 0;
 127 int Runtime1::_throw_range_check_exception_count = 0;
 128 int Runtime1::_throw_index_exception_count = 0;
 129 int Runtime1::_throw_div0_exception_count = 0;
 130 int Runtime1::_throw_null_pointer_exception_count = 0;
 131 int Runtime1::_throw_class_cast_exception_count = 0;
 132 int Runtime1::_throw_incompatible_class_change_error_count = 0;

 133 int Runtime1::_throw_array_store_exception_count = 0;
 134 int Runtime1::_throw_count = 0;
 135 
 136 static int _byte_arraycopy_stub_cnt = 0;
 137 static int _short_arraycopy_stub_cnt = 0;
 138 static int _int_arraycopy_stub_cnt = 0;
 139 static int _long_arraycopy_stub_cnt = 0;
 140 static int _oop_arraycopy_stub_cnt = 0;
 141 
 142 address Runtime1::arraycopy_count_address(BasicType type) {
 143   switch (type) {
 144   case T_BOOLEAN:
 145   case T_BYTE:   return (address)&amp;_byte_arraycopy_stub_cnt;
 146   case T_CHAR:
 147   case T_SHORT:  return (address)&amp;_short_arraycopy_stub_cnt;
 148   case T_FLOAT:
 149   case T_INT:    return (address)&amp;_int_arraycopy_stub_cnt;
 150   case T_DOUBLE:
 151   case T_LONG:   return (address)&amp;_long_arraycopy_stub_cnt;
 152   case T_ARRAY:
</pre>
<hr />
<pre>
 376   BasicType elt_type = TypeArrayKlass::cast(klass)-&gt;element_type();
 377   oop obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 378   thread-&gt;set_vm_result(obj);
 379   // This is pretty rare but this runtime patch is stressful to deoptimization
 380   // if we deoptimize here so force a deopt to stress the path.
 381   if (DeoptimizeALot) {
 382     deopt_caller();
 383   }
 384 
 385 JRT_END
 386 
 387 
 388 JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))
 389   NOT_PRODUCT(_new_object_array_slowcase_cnt++;)
 390 
 391   // Note: no handle for klass needed since they are not used
 392   //       anymore after new_objArray() and no GC can happen before.
 393   //       (This may have to change if this code changes!)
 394   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 395   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 396   Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();</span>
 397   objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 398   thread-&gt;set_vm_result(obj);
 399   // This is pretty rare but this runtime patch is stressful to deoptimization
 400   // if we deoptimize here so force a deopt to stress the path.
 401   if (DeoptimizeALot) {
 402     deopt_caller();
 403   }
 404 JRT_END
 405 
 406 






















 407 JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 408   NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)
 409 
 410   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 411   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 412   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 413   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 414   thread-&gt;set_vm_result(obj);
 415 JRT_END
 416 
 417 













































































 418 JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))
 419   tty-&gt;print_cr(&quot;Runtime1::entry_for(%d) returned unimplemented entry point&quot;, id);
 420 JRT_END
 421 
 422 
 423 JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
 424   ResourceMark rm(thread);
 425   const char* klass_name = obj-&gt;klass()-&gt;external_name();
 426   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
 427 JRT_END
 428 
 429 
 430 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 431 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
 432 // method) method oop is passed as an argument. In order to do that it is embedded in the code as
 433 // a constant.
 434 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
 435   nmethod* osr_nm = NULL;
 436   methodHandle method(THREAD, m);
 437 
</pre>
<hr />
<pre>
 683 JRT_END
 684 
 685 
 686 JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))
 687   NOT_PRODUCT(_throw_class_cast_exception_count++;)
 688   ResourceMark rm(thread);
 689   char* message = SharedRuntime::generate_class_cast_message(
 690     thread, object-&gt;klass());
 691   SharedRuntime::throw_and_post_jvmti_exception(
 692     thread, vmSymbols::java_lang_ClassCastException(), message);
 693 JRT_END
 694 
 695 
 696 JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))
 697   NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)
 698   ResourceMark rm(thread);
 699   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());
 700 JRT_END
 701 
 702 







 703 JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
 704   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
 705   if (!UseFastLocking) {
 706     lock-&gt;set_obj(obj);
 707   }
 708   assert(obj == lock-&gt;obj(), &quot;must match&quot;);
 709   SharedRuntime::monitor_enter_helper(obj, lock-&gt;lock(), thread);
 710 JRT_END
 711 
 712 
 713 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
 714   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
 715   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 716   oop obj = lock-&gt;obj();
 717   assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
 718   SharedRuntime::monitor_exit_helper(obj, lock-&gt;lock(), thread);
 719 JRT_END
 720 
 721 // Cf. OptoRuntime::deoptimize_caller_frame
 722 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
</pre>
<hr />
<pre>
 927     // accesses.
 928 
 929     patch_field_type = result.field_type();
 930     deoptimize_for_atomic = (AlwaysAtomicAccesses &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG));
 931 
 932   } else if (load_klass_or_mirror_patch_id) {
 933     Klass* k = NULL;
 934     switch (code) {
 935       case Bytecodes::_putstatic:
 936       case Bytecodes::_getstatic:
 937         { Klass* klass = resolve_field_return_klass(caller_method, bci, CHECK);
 938           init_klass = klass;
 939           mirror = Handle(THREAD, klass-&gt;java_mirror());
 940         }
 941         break;
 942       case Bytecodes::_new:
 943         { Bytecode_new bnew(caller_method(), caller_method-&gt;bcp_from(bci));
 944           k = caller_method-&gt;constants()-&gt;klass_at(bnew.index(), CHECK);
 945         }
 946         break;





 947       case Bytecodes::_multianewarray:
 948         { Bytecode_multianewarray mna(caller_method(), caller_method-&gt;bcp_from(bci));
 949           k = caller_method-&gt;constants()-&gt;klass_at(mna.index(), CHECK);




 950         }
 951         break;
 952       case Bytecodes::_instanceof:
 953         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
 954           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
 955         }
 956         break;
 957       case Bytecodes::_checkcast:
 958         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
 959           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
 960         }
 961         break;
 962       case Bytecodes::_anewarray:
 963         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
 964           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
 965           k = ek-&gt;array_klass(CHECK);
 966         }
 967         break;
 968       case Bytecodes::_ldc:
 969       case Bytecodes::_ldc_w:
</pre>
<hr />
<pre>
1444 void Runtime1::print_statistics() {
1445   tty-&gt;print_cr(&quot;C1 Runtime statistics:&quot;);
1446   tty-&gt;print_cr(&quot; _resolve_invoke_virtual_cnt:     %d&quot;, SharedRuntime::_resolve_virtual_ctr);
1447   tty-&gt;print_cr(&quot; _resolve_invoke_opt_virtual_cnt: %d&quot;, SharedRuntime::_resolve_opt_virtual_ctr);
1448   tty-&gt;print_cr(&quot; _resolve_invoke_static_cnt:      %d&quot;, SharedRuntime::_resolve_static_ctr);
1449   tty-&gt;print_cr(&quot; _handle_wrong_method_cnt:        %d&quot;, SharedRuntime::_wrong_method_ctr);
1450   tty-&gt;print_cr(&quot; _ic_miss_cnt:                    %d&quot;, SharedRuntime::_ic_miss_ctr);
1451   tty-&gt;print_cr(&quot; _generic_arraycopy_cnt:          %d&quot;, _generic_arraycopy_cnt);
1452   tty-&gt;print_cr(&quot; _generic_arraycopystub_cnt:      %d&quot;, _generic_arraycopystub_cnt);
1453   tty-&gt;print_cr(&quot; _byte_arraycopy_cnt:             %d&quot;, _byte_arraycopy_stub_cnt);
1454   tty-&gt;print_cr(&quot; _short_arraycopy_cnt:            %d&quot;, _short_arraycopy_stub_cnt);
1455   tty-&gt;print_cr(&quot; _int_arraycopy_cnt:              %d&quot;, _int_arraycopy_stub_cnt);
1456   tty-&gt;print_cr(&quot; _long_arraycopy_cnt:             %d&quot;, _long_arraycopy_stub_cnt);
1457   tty-&gt;print_cr(&quot; _oop_arraycopy_cnt:              %d&quot;, _oop_arraycopy_stub_cnt);
1458   tty-&gt;print_cr(&quot; _arraycopy_slowcase_cnt:         %d&quot;, _arraycopy_slowcase_cnt);
1459   tty-&gt;print_cr(&quot; _arraycopy_checkcast_cnt:        %d&quot;, _arraycopy_checkcast_cnt);
1460   tty-&gt;print_cr(&quot; _arraycopy_checkcast_attempt_cnt:%d&quot;, _arraycopy_checkcast_attempt_cnt);
1461 
1462   tty-&gt;print_cr(&quot; _new_type_array_slowcase_cnt:    %d&quot;, _new_type_array_slowcase_cnt);
1463   tty-&gt;print_cr(&quot; _new_object_array_slowcase_cnt:  %d&quot;, _new_object_array_slowcase_cnt);

1464   tty-&gt;print_cr(&quot; _new_instance_slowcase_cnt:      %d&quot;, _new_instance_slowcase_cnt);
1465   tty-&gt;print_cr(&quot; _new_multi_array_slowcase_cnt:   %d&quot;, _new_multi_array_slowcase_cnt);






1466   tty-&gt;print_cr(&quot; _monitorenter_slowcase_cnt:      %d&quot;, _monitorenter_slowcase_cnt);
1467   tty-&gt;print_cr(&quot; _monitorexit_slowcase_cnt:       %d&quot;, _monitorexit_slowcase_cnt);
1468   tty-&gt;print_cr(&quot; _patch_code_slowcase_cnt:        %d&quot;, _patch_code_slowcase_cnt);
1469 
1470   tty-&gt;print_cr(&quot; _throw_range_check_exception_count:            %d:&quot;, _throw_range_check_exception_count);
1471   tty-&gt;print_cr(&quot; _throw_index_exception_count:                  %d:&quot;, _throw_index_exception_count);
1472   tty-&gt;print_cr(&quot; _throw_div0_exception_count:                   %d:&quot;, _throw_div0_exception_count);
1473   tty-&gt;print_cr(&quot; _throw_null_pointer_exception_count:           %d:&quot;, _throw_null_pointer_exception_count);
1474   tty-&gt;print_cr(&quot; _throw_class_cast_exception_count:             %d:&quot;, _throw_class_cast_exception_count);
1475   tty-&gt;print_cr(&quot; _throw_incompatible_class_change_error_count:  %d:&quot;, _throw_incompatible_class_change_error_count);

1476   tty-&gt;print_cr(&quot; _throw_array_store_exception_count:            %d:&quot;, _throw_array_store_exception_count);
1477   tty-&gt;print_cr(&quot; _throw_count:                                  %d:&quot;, _throw_count);
1478 
1479   SharedRuntime::print_ic_miss_histogram();
1480   tty-&gt;cr();
1481 }
1482 #endif // PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;code/pcDesc.hpp&quot;
  39 #include &quot;code/scopeDesc.hpp&quot;
  40 #include &quot;code/vtableStubs.hpp&quot;
  41 #include &quot;compiler/compilationPolicy.hpp&quot;
  42 #include &quot;compiler/disassembler.hpp&quot;
  43 #include &quot;gc/shared/barrierSet.hpp&quot;
  44 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  45 #include &quot;gc/shared/collectedHeap.hpp&quot;
  46 #include &quot;interpreter/bytecode.hpp&quot;
  47 #include &quot;interpreter/interpreter.hpp&quot;
  48 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  49 #include &quot;logging/log.hpp&quot;
  50 #include &quot;memory/allocation.inline.hpp&quot;
  51 #include &quot;memory/oopFactory.hpp&quot;
  52 #include &quot;memory/resourceArea.hpp&quot;
  53 #include &quot;memory/universe.hpp&quot;
  54 #include &quot;oops/access.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  58 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  59 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
  60 #include &quot;runtime/atomic.hpp&quot;
  61 #include &quot;runtime/biasedLocking.hpp&quot;
  62 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  63 #include &quot;runtime/frame.inline.hpp&quot;
  64 #include &quot;runtime/handles.inline.hpp&quot;
  65 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/sharedRuntime.hpp&quot;
  68 #include &quot;runtime/threadCritical.hpp&quot;
  69 #include &quot;runtime/vframe.inline.hpp&quot;
  70 #include &quot;runtime/vframeArray.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/copy.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 
  75 
  76 // Implementation of StubAssembler
  77 
  78 StubAssembler::StubAssembler(CodeBuffer* code, const char * name, int stub_id) : C1_MacroAssembler(code) {
  79   _name = name;
</pre>
<hr />
<pre>
 104   }
 105   assert(_num_rt_args == args, &quot;can&#39;t change the number of args&quot;);
 106 }
 107 
 108 // Implementation of Runtime1
 109 
 110 CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];
 111 const char *Runtime1::_blob_names[] = {
 112   RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)
 113 };
 114 
 115 #ifndef PRODUCT
 116 // statistics
 117 int Runtime1::_generic_arraycopy_cnt = 0;
 118 int Runtime1::_generic_arraycopystub_cnt = 0;
 119 int Runtime1::_arraycopy_slowcase_cnt = 0;
 120 int Runtime1::_arraycopy_checkcast_cnt = 0;
 121 int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
 122 int Runtime1::_new_type_array_slowcase_cnt = 0;
 123 int Runtime1::_new_object_array_slowcase_cnt = 0;
<span class="line-added"> 124 int Runtime1::_new_value_array_slowcase_cnt = 0;</span>
 125 int Runtime1::_new_instance_slowcase_cnt = 0;
 126 int Runtime1::_new_multi_array_slowcase_cnt = 0;
<span class="line-added"> 127 int Runtime1::_load_flattened_array_slowcase_cnt = 0;</span>
<span class="line-added"> 128 int Runtime1::_store_flattened_array_slowcase_cnt = 0;</span>
<span class="line-added"> 129 int Runtime1::_substitutability_check_slowcase_cnt = 0;</span>
<span class="line-added"> 130 int Runtime1::_buffer_value_args_slowcase_cnt = 0;</span>
<span class="line-added"> 131 int Runtime1::_buffer_value_args_no_receiver_slowcase_cnt = 0;</span>
 132 int Runtime1::_monitorenter_slowcase_cnt = 0;
 133 int Runtime1::_monitorexit_slowcase_cnt = 0;
 134 int Runtime1::_patch_code_slowcase_cnt = 0;
 135 int Runtime1::_throw_range_check_exception_count = 0;
 136 int Runtime1::_throw_index_exception_count = 0;
 137 int Runtime1::_throw_div0_exception_count = 0;
 138 int Runtime1::_throw_null_pointer_exception_count = 0;
 139 int Runtime1::_throw_class_cast_exception_count = 0;
 140 int Runtime1::_throw_incompatible_class_change_error_count = 0;
<span class="line-added"> 141 int Runtime1::_throw_illegal_monitor_state_exception_count = 0;</span>
 142 int Runtime1::_throw_array_store_exception_count = 0;
 143 int Runtime1::_throw_count = 0;
 144 
 145 static int _byte_arraycopy_stub_cnt = 0;
 146 static int _short_arraycopy_stub_cnt = 0;
 147 static int _int_arraycopy_stub_cnt = 0;
 148 static int _long_arraycopy_stub_cnt = 0;
 149 static int _oop_arraycopy_stub_cnt = 0;
 150 
 151 address Runtime1::arraycopy_count_address(BasicType type) {
 152   switch (type) {
 153   case T_BOOLEAN:
 154   case T_BYTE:   return (address)&amp;_byte_arraycopy_stub_cnt;
 155   case T_CHAR:
 156   case T_SHORT:  return (address)&amp;_short_arraycopy_stub_cnt;
 157   case T_FLOAT:
 158   case T_INT:    return (address)&amp;_int_arraycopy_stub_cnt;
 159   case T_DOUBLE:
 160   case T_LONG:   return (address)&amp;_long_arraycopy_stub_cnt;
 161   case T_ARRAY:
</pre>
<hr />
<pre>
 385   BasicType elt_type = TypeArrayKlass::cast(klass)-&gt;element_type();
 386   oop obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 387   thread-&gt;set_vm_result(obj);
 388   // This is pretty rare but this runtime patch is stressful to deoptimization
 389   // if we deoptimize here so force a deopt to stress the path.
 390   if (DeoptimizeALot) {
 391     deopt_caller();
 392   }
 393 
 394 JRT_END
 395 
 396 
 397 JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))
 398   NOT_PRODUCT(_new_object_array_slowcase_cnt++;)
 399 
 400   // Note: no handle for klass needed since they are not used
 401   //       anymore after new_objArray() and no GC can happen before.
 402   //       (This may have to change if this code changes!)
 403   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 404   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 405   Klass* elem_klass = ArrayKlass::cast(array_klass)-&gt;element_klass();</span>
 406   objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 407   thread-&gt;set_vm_result(obj);
 408   // This is pretty rare but this runtime patch is stressful to deoptimization
 409   // if we deoptimize here so force a deopt to stress the path.
 410   if (DeoptimizeALot) {
 411     deopt_caller();
 412   }
 413 JRT_END
 414 
 415 
<span class="line-added"> 416 JRT_ENTRY(void, Runtime1::new_value_array(JavaThread* thread, Klass* array_klass, jint length))</span>
<span class="line-added"> 417   NOT_PRODUCT(_new_value_array_slowcase_cnt++;)</span>
<span class="line-added"> 418 </span>
<span class="line-added"> 419   // Note: no handle for klass needed since they are not used</span>
<span class="line-added"> 420   //       anymore after new_objArray() and no GC can happen before.</span>
<span class="line-added"> 421   //       (This may have to change if this code changes!)</span>
<span class="line-added"> 422   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);</span>
<span class="line-added"> 423   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive</span>
<span class="line-added"> 424   Klass* elem_klass = ArrayKlass::cast(array_klass)-&gt;element_klass();</span>
<span class="line-added"> 425   assert(elem_klass-&gt;is_value(), &quot;must be&quot;);</span>
<span class="line-added"> 426   // Logically creates elements, ensure klass init</span>
<span class="line-added"> 427   elem_klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 428   arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);</span>
<span class="line-added"> 429   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 430   // This is pretty rare but this runtime patch is stressful to deoptimization</span>
<span class="line-added"> 431   // if we deoptimize here so force a deopt to stress the path.</span>
<span class="line-added"> 432   if (DeoptimizeALot) {</span>
<span class="line-added"> 433     deopt_caller();</span>
<span class="line-added"> 434   }</span>
<span class="line-added"> 435 JRT_END</span>
<span class="line-added"> 436 </span>
<span class="line-added"> 437 </span>
 438 JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 439   NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)
 440 
 441   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 442   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 443   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 444   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 445   thread-&gt;set_vm_result(obj);
 446 JRT_END
 447 
 448 
<span class="line-added"> 449 static void profile_flat_array(JavaThread* thread) {</span>
<span class="line-added"> 450   ResourceMark rm(thread);</span>
<span class="line-added"> 451   vframeStream vfst(thread, true);</span>
<span class="line-added"> 452   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);</span>
<span class="line-added"> 453   int bci = vfst.bci();</span>
<span class="line-added"> 454   Method* method = vfst.method();</span>
<span class="line-added"> 455   MethodData* md = method-&gt;method_data();</span>
<span class="line-added"> 456   if (md != NULL) {</span>
<span class="line-added"> 457     ProfileData* data = md-&gt;bci_to_data(bci);</span>
<span class="line-added"> 458     assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);</span>
<span class="line-added"> 459     ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;</span>
<span class="line-added"> 460     load_store-&gt;set_flat_array();</span>
<span class="line-added"> 461   }</span>
<span class="line-added"> 462 }</span>
<span class="line-added"> 463 </span>
<span class="line-added"> 464 JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index))</span>
<span class="line-added"> 465   assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 466   profile_flat_array(thread);</span>
<span class="line-added"> 467 </span>
<span class="line-added"> 468   NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)</span>
<span class="line-added"> 469   assert(array-&gt;length() &gt; 0 &amp;&amp; index &lt; array-&gt;length(), &quot;already checked&quot;);</span>
<span class="line-added"> 470   valueArrayHandle vah(thread, array);</span>
<span class="line-added"> 471   oop obj = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);</span>
<span class="line-added"> 472   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 473 JRT_END</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475 </span>
<span class="line-added"> 476 JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value))</span>
<span class="line-added"> 477   if (array-&gt;klass()-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 478     profile_flat_array(thread);</span>
<span class="line-added"> 479   }</span>
<span class="line-added"> 480 </span>
<span class="line-added"> 481   NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)</span>
<span class="line-added"> 482   if (value == NULL) {</span>
<span class="line-added"> 483     assert(array-&gt;klass()-&gt;is_valueArray_klass() || array-&gt;klass()-&gt;is_null_free_array_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 484     SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());</span>
<span class="line-added"> 485   } else {</span>
<span class="line-added"> 486     assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 487     array-&gt;value_copy_to_index(value, index);</span>
<span class="line-added"> 488   }</span>
<span class="line-added"> 489 JRT_END</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 </span>
<span class="line-added"> 492 JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right))</span>
<span class="line-added"> 493   NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)</span>
<span class="line-added"> 494   JavaCallArguments args;</span>
<span class="line-added"> 495   args.push_oop(Handle(THREAD, left));</span>
<span class="line-added"> 496   args.push_oop(Handle(THREAD, right));</span>
<span class="line-added"> 497   JavaValue result(T_BOOLEAN);</span>
<span class="line-added"> 498   JavaCalls::call_static(&amp;result,</span>
<span class="line-added"> 499                          SystemDictionary::ValueBootstrapMethods_klass(),</span>
<span class="line-added"> 500                          vmSymbols::isSubstitutable_name(),</span>
<span class="line-added"> 501                          vmSymbols::object_object_boolean_signature(),</span>
<span class="line-added"> 502                          &amp;args, CHECK_0);</span>
<span class="line-added"> 503   return result.get_jboolean() ? 1 : 0;</span>
<span class="line-added"> 504 JRT_END</span>
<span class="line-added"> 505 </span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507 extern &quot;C&quot; void ps();</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509 void Runtime1::buffer_value_args_impl(JavaThread* thread, Method* m, bool allocate_receiver) {</span>
<span class="line-added"> 510   Thread* THREAD = thread;</span>
<span class="line-added"> 511   methodHandle method(thread, m); // We are inside the verified_entry or verified_value_ro_entry of this method.</span>
<span class="line-added"> 512   oop obj = SharedRuntime::allocate_value_types_impl(thread, method, allocate_receiver, CHECK);</span>
<span class="line-added"> 513   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 514 }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516 JRT_ENTRY(void, Runtime1::buffer_value_args(JavaThread* thread, Method* method))</span>
<span class="line-added"> 517   NOT_PRODUCT(_buffer_value_args_slowcase_cnt++;)</span>
<span class="line-added"> 518   buffer_value_args_impl(thread, method, true);</span>
<span class="line-added"> 519 JRT_END</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521 JRT_ENTRY(void, Runtime1::buffer_value_args_no_receiver(JavaThread* thread, Method* method))</span>
<span class="line-added"> 522   NOT_PRODUCT(_buffer_value_args_no_receiver_slowcase_cnt++;)</span>
<span class="line-added"> 523   buffer_value_args_impl(thread, method, false);</span>
<span class="line-added"> 524 JRT_END</span>
<span class="line-added"> 525 </span>
 526 JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))
 527   tty-&gt;print_cr(&quot;Runtime1::entry_for(%d) returned unimplemented entry point&quot;, id);
 528 JRT_END
 529 
 530 
 531 JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
 532   ResourceMark rm(thread);
 533   const char* klass_name = obj-&gt;klass()-&gt;external_name();
 534   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
 535 JRT_END
 536 
 537 
 538 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 539 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
 540 // method) method oop is passed as an argument. In order to do that it is embedded in the code as
 541 // a constant.
 542 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
 543   nmethod* osr_nm = NULL;
 544   methodHandle method(THREAD, m);
 545 
</pre>
<hr />
<pre>
 791 JRT_END
 792 
 793 
 794 JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))
 795   NOT_PRODUCT(_throw_class_cast_exception_count++;)
 796   ResourceMark rm(thread);
 797   char* message = SharedRuntime::generate_class_cast_message(
 798     thread, object-&gt;klass());
 799   SharedRuntime::throw_and_post_jvmti_exception(
 800     thread, vmSymbols::java_lang_ClassCastException(), message);
 801 JRT_END
 802 
 803 
 804 JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))
 805   NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)
 806   ResourceMark rm(thread);
 807   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());
 808 JRT_END
 809 
 810 
<span class="line-added"> 811 JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* thread))</span>
<span class="line-added"> 812   NOT_PRODUCT(_throw_illegal_monitor_state_exception_count++;)</span>
<span class="line-added"> 813   ResourceMark rm(thread);</span>
<span class="line-added"> 814   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IllegalMonitorStateException());</span>
<span class="line-added"> 815 JRT_END</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817 </span>
 818 JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
 819   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
 820   if (!UseFastLocking) {
 821     lock-&gt;set_obj(obj);
 822   }
 823   assert(obj == lock-&gt;obj(), &quot;must match&quot;);
 824   SharedRuntime::monitor_enter_helper(obj, lock-&gt;lock(), thread);
 825 JRT_END
 826 
 827 
 828 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
 829   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
 830   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 831   oop obj = lock-&gt;obj();
 832   assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
 833   SharedRuntime::monitor_exit_helper(obj, lock-&gt;lock(), thread);
 834 JRT_END
 835 
 836 // Cf. OptoRuntime::deoptimize_caller_frame
 837 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
</pre>
<hr />
<pre>
1042     // accesses.
1043 
1044     patch_field_type = result.field_type();
1045     deoptimize_for_atomic = (AlwaysAtomicAccesses &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG));
1046 
1047   } else if (load_klass_or_mirror_patch_id) {
1048     Klass* k = NULL;
1049     switch (code) {
1050       case Bytecodes::_putstatic:
1051       case Bytecodes::_getstatic:
1052         { Klass* klass = resolve_field_return_klass(caller_method, bci, CHECK);
1053           init_klass = klass;
1054           mirror = Handle(THREAD, klass-&gt;java_mirror());
1055         }
1056         break;
1057       case Bytecodes::_new:
1058         { Bytecode_new bnew(caller_method(), caller_method-&gt;bcp_from(bci));
1059           k = caller_method-&gt;constants()-&gt;klass_at(bnew.index(), CHECK);
1060         }
1061         break;
<span class="line-added">1062       case Bytecodes::_defaultvalue:</span>
<span class="line-added">1063         { Bytecode_defaultvalue bdefaultvalue(caller_method(), caller_method-&gt;bcp_from(bci));</span>
<span class="line-added">1064           k = caller_method-&gt;constants()-&gt;klass_at(bdefaultvalue.index(), CHECK);</span>
<span class="line-added">1065         }</span>
<span class="line-added">1066         break;</span>
1067       case Bytecodes::_multianewarray:
1068         { Bytecode_multianewarray mna(caller_method(), caller_method-&gt;bcp_from(bci));
1069           k = caller_method-&gt;constants()-&gt;klass_at(mna.index(), CHECK);
<span class="line-added">1070           if (k-&gt;name()-&gt;is_Q_array_signature()) {</span>
<span class="line-added">1071             // Logically creates elements, ensure klass init</span>
<span class="line-added">1072             k-&gt;initialize(CHECK);</span>
<span class="line-added">1073           }</span>
1074         }
1075         break;
1076       case Bytecodes::_instanceof:
1077         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
1078           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
1079         }
1080         break;
1081       case Bytecodes::_checkcast:
1082         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
1083           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
1084         }
1085         break;
1086       case Bytecodes::_anewarray:
1087         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
1088           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
1089           k = ek-&gt;array_klass(CHECK);
1090         }
1091         break;
1092       case Bytecodes::_ldc:
1093       case Bytecodes::_ldc_w:
</pre>
<hr />
<pre>
1568 void Runtime1::print_statistics() {
1569   tty-&gt;print_cr(&quot;C1 Runtime statistics:&quot;);
1570   tty-&gt;print_cr(&quot; _resolve_invoke_virtual_cnt:     %d&quot;, SharedRuntime::_resolve_virtual_ctr);
1571   tty-&gt;print_cr(&quot; _resolve_invoke_opt_virtual_cnt: %d&quot;, SharedRuntime::_resolve_opt_virtual_ctr);
1572   tty-&gt;print_cr(&quot; _resolve_invoke_static_cnt:      %d&quot;, SharedRuntime::_resolve_static_ctr);
1573   tty-&gt;print_cr(&quot; _handle_wrong_method_cnt:        %d&quot;, SharedRuntime::_wrong_method_ctr);
1574   tty-&gt;print_cr(&quot; _ic_miss_cnt:                    %d&quot;, SharedRuntime::_ic_miss_ctr);
1575   tty-&gt;print_cr(&quot; _generic_arraycopy_cnt:          %d&quot;, _generic_arraycopy_cnt);
1576   tty-&gt;print_cr(&quot; _generic_arraycopystub_cnt:      %d&quot;, _generic_arraycopystub_cnt);
1577   tty-&gt;print_cr(&quot; _byte_arraycopy_cnt:             %d&quot;, _byte_arraycopy_stub_cnt);
1578   tty-&gt;print_cr(&quot; _short_arraycopy_cnt:            %d&quot;, _short_arraycopy_stub_cnt);
1579   tty-&gt;print_cr(&quot; _int_arraycopy_cnt:              %d&quot;, _int_arraycopy_stub_cnt);
1580   tty-&gt;print_cr(&quot; _long_arraycopy_cnt:             %d&quot;, _long_arraycopy_stub_cnt);
1581   tty-&gt;print_cr(&quot; _oop_arraycopy_cnt:              %d&quot;, _oop_arraycopy_stub_cnt);
1582   tty-&gt;print_cr(&quot; _arraycopy_slowcase_cnt:         %d&quot;, _arraycopy_slowcase_cnt);
1583   tty-&gt;print_cr(&quot; _arraycopy_checkcast_cnt:        %d&quot;, _arraycopy_checkcast_cnt);
1584   tty-&gt;print_cr(&quot; _arraycopy_checkcast_attempt_cnt:%d&quot;, _arraycopy_checkcast_attempt_cnt);
1585 
1586   tty-&gt;print_cr(&quot; _new_type_array_slowcase_cnt:    %d&quot;, _new_type_array_slowcase_cnt);
1587   tty-&gt;print_cr(&quot; _new_object_array_slowcase_cnt:  %d&quot;, _new_object_array_slowcase_cnt);
<span class="line-added">1588   tty-&gt;print_cr(&quot; _new_value_array_slowcase_cnt:   %d&quot;, _new_value_array_slowcase_cnt);</span>
1589   tty-&gt;print_cr(&quot; _new_instance_slowcase_cnt:      %d&quot;, _new_instance_slowcase_cnt);
1590   tty-&gt;print_cr(&quot; _new_multi_array_slowcase_cnt:   %d&quot;, _new_multi_array_slowcase_cnt);
<span class="line-added">1591   tty-&gt;print_cr(&quot; _load_flattened_array_slowcase_cnt:   %d&quot;, _load_flattened_array_slowcase_cnt);</span>
<span class="line-added">1592   tty-&gt;print_cr(&quot; _store_flattened_array_slowcase_cnt:  %d&quot;, _store_flattened_array_slowcase_cnt);</span>
<span class="line-added">1593   tty-&gt;print_cr(&quot; _substitutability_check_slowcase_cnt: %d&quot;, _substitutability_check_slowcase_cnt);</span>
<span class="line-added">1594   tty-&gt;print_cr(&quot; _buffer_value_args_slowcase_cnt:%d&quot;, _buffer_value_args_slowcase_cnt);</span>
<span class="line-added">1595   tty-&gt;print_cr(&quot; _buffer_value_args_no_receiver_slowcase_cnt:%d&quot;, _buffer_value_args_no_receiver_slowcase_cnt);</span>
<span class="line-added">1596 </span>
1597   tty-&gt;print_cr(&quot; _monitorenter_slowcase_cnt:      %d&quot;, _monitorenter_slowcase_cnt);
1598   tty-&gt;print_cr(&quot; _monitorexit_slowcase_cnt:       %d&quot;, _monitorexit_slowcase_cnt);
1599   tty-&gt;print_cr(&quot; _patch_code_slowcase_cnt:        %d&quot;, _patch_code_slowcase_cnt);
1600 
1601   tty-&gt;print_cr(&quot; _throw_range_check_exception_count:            %d:&quot;, _throw_range_check_exception_count);
1602   tty-&gt;print_cr(&quot; _throw_index_exception_count:                  %d:&quot;, _throw_index_exception_count);
1603   tty-&gt;print_cr(&quot; _throw_div0_exception_count:                   %d:&quot;, _throw_div0_exception_count);
1604   tty-&gt;print_cr(&quot; _throw_null_pointer_exception_count:           %d:&quot;, _throw_null_pointer_exception_count);
1605   tty-&gt;print_cr(&quot; _throw_class_cast_exception_count:             %d:&quot;, _throw_class_cast_exception_count);
1606   tty-&gt;print_cr(&quot; _throw_incompatible_class_change_error_count:  %d:&quot;, _throw_incompatible_class_change_error_count);
<span class="line-added">1607   tty-&gt;print_cr(&quot; _throw_illegal_monitor_state_exception_count:  %d:&quot;, _throw_illegal_monitor_state_exception_count);</span>
1608   tty-&gt;print_cr(&quot; _throw_array_store_exception_count:            %d:&quot;, _throw_array_store_exception_count);
1609   tty-&gt;print_cr(&quot; _throw_count:                                  %d:&quot;, _throw_count);
1610 
1611   SharedRuntime::print_ic_miss_histogram();
1612   tty-&gt;cr();
1613 }
1614 #endif // PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="c1_LinearScan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../classfile/classListParser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
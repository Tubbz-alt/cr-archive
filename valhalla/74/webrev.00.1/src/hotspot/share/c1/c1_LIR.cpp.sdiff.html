<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;

  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 Register LIR_OprDesc::as_register() const {
  34   return FrameMap::cpu_rnr2reg(cpu_regnr());
  35 }
  36 
  37 Register LIR_OprDesc::as_register_lo() const {
  38   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  39 }
  40 
  41 Register LIR_OprDesc::as_register_hi() const {
  42   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  43 }
  44 
  45 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  46 
  47 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  48   ValueTag tag = type-&gt;tag();
  49   switch (tag) {
  50   case metaDataTag : {
</pre>
<hr />
<pre>
  75 //---------------------------------------------------
  76 
  77 
  78 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  79   int elem_size = type2aelembytes(type);
  80   switch (elem_size) {
  81   case 1: return LIR_Address::times_1;
  82   case 2: return LIR_Address::times_2;
  83   case 4: return LIR_Address::times_4;
  84   case 8: return LIR_Address::times_8;
  85   }
  86   ShouldNotReachHere();
  87   return LIR_Address::times_1;
  88 }
  89 
  90 //---------------------------------------------------
  91 
  92 char LIR_OprDesc::type_char(BasicType t) {
  93   switch (t) {
  94     case T_ARRAY:

  95       t = T_OBJECT;
  96     case T_BOOLEAN:
  97     case T_CHAR:
  98     case T_FLOAT:
  99     case T_DOUBLE:
 100     case T_BYTE:
 101     case T_SHORT:
 102     case T_INT:
 103     case T_LONG:
 104     case T_OBJECT:
 105     case T_ADDRESS:
 106     case T_VOID:
 107       return ::type2char(t);
 108     case T_METADATA:
 109       return &#39;M&#39;;
 110     case T_ILLEGAL:
 111       return &#39;?&#39;;
 112 
 113     default:
 114       ShouldNotReachHere();
</pre>
<hr />
<pre>
 133              ARM_ONLY(|| kindfield == cpu_register)
 134              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 135              size_field() == single_size, &quot;must match&quot;);
 136       break;
 137     case T_DOUBLE:
 138       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 139       assert((kindfield == fpu_register || kindfield == stack_value
 140              ARM_ONLY(|| kindfield == cpu_register)
 141              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 142              size_field() == double_size, &quot;must match&quot;);
 143       break;
 144     case T_BOOLEAN:
 145     case T_CHAR:
 146     case T_BYTE:
 147     case T_SHORT:
 148     case T_INT:
 149     case T_ADDRESS:
 150     case T_OBJECT:
 151     case T_METADATA:
 152     case T_ARRAY:

 153       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 154              size_field() == single_size, &quot;must match&quot;);
 155       break;
 156 
 157     case T_ILLEGAL:
 158       // XXX TKR also means unknown right now
 159       // assert(is_illegal(), &quot;must match&quot;);
 160       break;
 161 
 162     default:
 163       ShouldNotReachHere();
 164     }
 165   }
 166 #endif
 167 
 168 }
 169 #endif // PRODUCT
 170 
 171 
 172 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 279   assert(_ublock != NULL, &quot;must have old block&quot;);
 280   _ublock = b;
 281 }
 282 
 283 void LIR_OpBranch::negate_cond() {
 284   switch (_cond) {
 285     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 286     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 287     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 288     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 289     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 290     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 291     default: ShouldNotReachHere();
 292   }
 293 }
 294 
 295 
 296 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 297                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 298                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 299                                  CodeStub* stub)</span>
 300 
 301   : LIR_Op(code, result, NULL)
 302   , _object(object)
 303   , _array(LIR_OprFact::illegalOpr)
 304   , _klass(klass)
 305   , _tmp1(tmp1)
 306   , _tmp2(tmp2)
 307   , _tmp3(tmp3)
 308   , _fast_check(fast_check)
 309   , _info_for_patch(info_for_patch)
 310   , _info_for_exception(info_for_exception)
 311   , _stub(stub)
 312   , _profiled_method(NULL)
 313   , _profiled_bci(-1)
 314   , _should_profile(false)

 315 {
 316   if (code == lir_checkcast) {
 317     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 318   } else if (code == lir_instanceof) {
 319     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 320   } else {
 321     ShouldNotReachHere();
 322   }
 323 }
 324 
 325 
 326 
 327 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 328   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 329   , _object(object)
 330   , _array(array)
 331   , _klass(NULL)
 332   , _tmp1(tmp1)
 333   , _tmp2(tmp2)
 334   , _tmp3(tmp3)
 335   , _fast_check(false)
 336   , _info_for_patch(NULL)
 337   , _info_for_exception(info_for_exception)
 338   , _stub(NULL)
 339   , _profiled_method(NULL)
 340   , _profiled_bci(-1)
 341   , _should_profile(false)

 342 {
 343   if (code == lir_store_check) {
 344     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 345     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 346   } else {
 347     ShouldNotReachHere();
 348   }
 349 }
 350 































 351 
 352 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 353                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 354   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 355   , _src(src)
 356   , _src_pos(src_pos)
 357   , _dst(dst)
 358   , _dst_pos(dst_pos)
 359   , _length(length)
 360   , _tmp(tmp)
 361   , _expected_type(expected_type)
 362   , _flags(flags) {
 363   _stub = new ArrayCopyStub(this);
 364 }
 365 
 366 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 367   : LIR_Op(lir_updatecrc32, res, NULL)
 368   , _crc(crc)
 369   , _val(val) {
 370 }
</pre>
<hr />
<pre>
 398 // switch that adds the operands for each instruction
 399 
 400 void LIR_OpVisitState::visit(LIR_Op* op) {
 401   // copy information from the LIR_Op
 402   reset();
 403   set_op(op);
 404 
 405   switch (op-&gt;code()) {
 406 
 407 // LIR_Op0
 408     case lir_backwardbranch_target:    // result and info always invalid
 409     case lir_fpop_raw:                 // result and info always invalid
 410     case lir_breakpoint:               // result and info always invalid
 411     case lir_membar:                   // result and info always invalid
 412     case lir_membar_acquire:           // result and info always invalid
 413     case lir_membar_release:           // result and info always invalid
 414     case lir_membar_loadload:          // result and info always invalid
 415     case lir_membar_storestore:        // result and info always invalid
 416     case lir_membar_loadstore:         // result and info always invalid
 417     case lir_membar_storeload:         // result and info always invalid

 418     case lir_on_spin_wait:
 419     {
 420       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 421       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 422       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 423       break;
 424     }
 425 
 426     case lir_nop:                      // may have info, result always invalid
 427     case lir_std_entry:                // may have result, info always invalid
 428     case lir_osr_entry:                // may have result, info always invalid
 429     case lir_get_thread:               // may have result, info always invalid
 430     {
 431       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 432       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 433       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 434       break;
 435     }
 436 
 437 
</pre>
<hr />
<pre>
 778 
 779 
 780 // LIR_OpLock
 781     case lir_lock:
 782     case lir_unlock: {
 783       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 784       LIR_OpLock* opLock = (LIR_OpLock*)op;
 785 
 786       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 787 
 788       // TODO: check if these operands really have to be temp
 789       // (or if input is sufficient). This may have influence on the oop map!
 790       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 791       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 792       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 793 
 794       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 795       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 796 
 797       do_stub(opLock-&gt;_stub);

 798 
 799       break;
 800     }
 801 
 802 
 803 // LIR_OpDelay
 804     case lir_delay_slot: {
 805       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 806       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 807 
 808       visit(opDelay-&gt;delay_op());
 809       break;
 810     }
 811 
 812 // LIR_OpTypeCheck
 813     case lir_instanceof:
 814     case lir_checkcast:
 815     case lir_store_check: {
 816       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 817       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 818 
 819       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 820       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 821       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 822       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 823         do_temp(opTypeCheck-&gt;_object);
 824       }
 825       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 826       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 827       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 828       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 829       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 830                                                   do_stub(opTypeCheck-&gt;_stub);
 831       break;
 832     }
 833 













































 834 // LIR_OpCompareAndSwap
 835     case lir_cas_long:
 836     case lir_cas_obj:
 837     case lir_cas_int: {
 838       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 839       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 840 
 841       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 842       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 843       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 844       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 845                                                       do_input(opCompareAndSwap-&gt;_addr);
 846                                                       do_temp(opCompareAndSwap-&gt;_addr);
 847                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 848                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 849                                                       do_input(opCompareAndSwap-&gt;_new_value);
 850                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 851       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 852       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 853       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
 941 #ifdef ASSERT
 942 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
 943   visit(op);
 944 
 945   return opr_count(inputMode) == 0 &amp;&amp;
 946          opr_count(outputMode) == 0 &amp;&amp;
 947          opr_count(tempMode) == 0 &amp;&amp;
 948          info_count() == 0 &amp;&amp;
 949          !has_call() &amp;&amp;
 950          !has_slow_case();
 951 }
 952 #endif
 953 
 954 //---------------------------------------------------
 955 
 956 
 957 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
 958   masm-&gt;emit_call(this);
 959 }
 960 







































 961 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
 962   masm-&gt;emit_rtcall(this);
 963 }
 964 
 965 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
 966   masm-&gt;emit_opLabel(this);
 967 }
 968 
 969 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
 970   masm-&gt;emit_arraycopy(this);
 971   masm-&gt;append_code_stub(stub());
 972 }
 973 
 974 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
 975   masm-&gt;emit_updatecrc32(this);
 976 }
 977 
 978 void LIR_Op0::emit_code(LIR_Assembler* masm) {
 979   masm-&gt;emit_op0(this);
 980 }
</pre>
<hr />
<pre>
1001     masm-&gt;append_code_stub(stub());
1002   }
1003 }
1004 
1005 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1006   masm-&gt;emit_op2(this);
1007 }
1008 
1009 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1010   masm-&gt;emit_alloc_array(this);
1011   masm-&gt;append_code_stub(stub());
1012 }
1013 
1014 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1015   masm-&gt;emit_opTypeCheck(this);
1016   if (stub()) {
1017     masm-&gt;append_code_stub(stub());
1018   }
1019 }
1020 


















1021 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1022   masm-&gt;emit_compare_and_swap(this);
1023 }
1024 
1025 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1026   masm-&gt;emit_op3(this);
1027 }
1028 
1029 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1030   masm-&gt;emit_lock(this);
1031   if (stub()) {
1032     masm-&gt;append_code_stub(stub());
1033   }



1034 }
1035 
1036 #ifdef ASSERT
1037 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1038   masm-&gt;emit_assert(this);
1039 }
1040 #endif
1041 
1042 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1043   masm-&gt;emit_delay(this);
1044 }
1045 
1046 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1047   masm-&gt;emit_profile_call(this);
1048 }
1049 
1050 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1051   masm-&gt;emit_profile_type(this);
1052 }
1053 
</pre>
<hr />
<pre>
1315                     tmp));
1316 }
1317 
1318 
1319 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1320  append(new LIR_Op2(
1321                     lir_ushr,
1322                     value,
1323                     count,
1324                     dst,
1325                     tmp));
1326 }
1327 
1328 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1329   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1330                      left,
1331                      right,
1332                      dst));
1333 }
1334 
<span class="line-modified">1335 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {</span>
1336   append(new LIR_OpLock(
1337                     lir_lock,
1338                     hdr,
1339                     obj,
1340                     lock,
1341                     scratch,
1342                     stub,
<span class="line-modified">1343                     info));</span>

1344 }
1345 
1346 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1347   append(new LIR_OpLock(
1348                     lir_unlock,
1349                     hdr,
1350                     obj,
1351                     lock,
1352                     scratch,
1353                     stub,
1354                     NULL));
1355 }
1356 
1357 
1358 void check_LIR() {
1359   // cannot do the proper checking as PRODUCT and other modes return different results
1360   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1361 }
1362 
1363 
1364 
1365 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1366                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1367                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1368                           ciMethod* profiled_method, int profiled_bci) {</span>



1369   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1370                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);</span>

1371   if (profiled_method != NULL) {
1372     c-&gt;set_profiled_method(profiled_method);
1373     c-&gt;set_profiled_bci(profiled_bci);
1374     c-&gt;set_should_profile(true);
1375   }
1376   append(c);
1377 }
1378 
1379 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1380   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1381   if (profiled_method != NULL) {
1382     c-&gt;set_profiled_method(profiled_method);
1383     c-&gt;set_profiled_bci(profiled_bci);
1384     c-&gt;set_should_profile(true);
1385   }
1386   append(c);
1387 }
1388 
1389 
1390 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1391                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {

1392   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1393   if (profiled_method != NULL) {
1394     c-&gt;set_profiled_method(profiled_method);
1395     c-&gt;set_profiled_bci(profiled_bci);
1396     c-&gt;set_should_profile(true);
1397   }
1398   append(c);
1399 }
1400 
1401 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1402   if (deoptimize_on_null) {
1403     // Emit an explicit null check and deoptimize if opr is null
1404     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1405     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1406     branch(lir_cond_equal, T_OBJECT, deopt);
1407   } else {
1408     // Emit an implicit null check
1409     append(new LIR_Op1(lir_null_check, opr, info));
1410   }
1411 }
1412 





















1413 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1414                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1415   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1416 }
1417 
1418 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1419                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1420   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1421 }
1422 
1423 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1424                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1425   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1426 }
1427 
1428 
1429 #ifdef PRODUCT
1430 
1431 void print_LIR(BlockList* blocks) {
1432 }
</pre>
<hr />
<pre>
1610 const char * LIR_Op::name() const {
1611   const char* s = NULL;
1612   switch(code()) {
1613      // LIR_Op0
1614      case lir_membar:                s = &quot;membar&quot;;        break;
1615      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1616      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1617      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1618      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1619      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1620      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1621      case lir_label:                 s = &quot;label&quot;;         break;
1622      case lir_nop:                   s = &quot;nop&quot;;           break;
1623      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1624      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1625      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1626      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1627      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1628      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1629      case lir_get_thread:            s = &quot;get_thread&quot;;    break;

1630      // LIR_Op1
1631      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1632      case lir_fld:                   s = &quot;fld&quot;;           break;
1633      case lir_push:                  s = &quot;push&quot;;          break;
1634      case lir_pop:                   s = &quot;pop&quot;;           break;
1635      case lir_null_check:            s = &quot;null_check&quot;;    break;
1636      case lir_return:                s = &quot;return&quot;;        break;
1637      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1638      case lir_leal:                  s = &quot;leal&quot;;          break;
1639      case lir_branch:                s = &quot;branch&quot;;        break;
1640      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1641      case lir_move:                  s = &quot;move&quot;;          break;
1642      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1643      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1644      case lir_throw:                 s = &quot;throw&quot;;         break;
1645      case lir_unwind:                s = &quot;unwind&quot;;        break;
1646      case lir_convert:               s = &quot;convert&quot;;       break;
1647      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1648      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1649      // LIR_Op2
</pre>
<hr />
<pre>
1678      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1679      // LIR_OpJavaCall
1680      case lir_static_call:           s = &quot;static&quot;;        break;
1681      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1682      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1683      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1684      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1685      // LIR_OpArrayCopy
1686      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1687      // LIR_OpUpdateCRC32
1688      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1689      // LIR_OpLock
1690      case lir_lock:                  s = &quot;lock&quot;;          break;
1691      case lir_unlock:                s = &quot;unlock&quot;;        break;
1692      // LIR_OpDelay
1693      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1694      // LIR_OpTypeCheck
1695      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1696      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1697      case lir_store_check:           s = &quot;store_check&quot;;   break;






1698      // LIR_OpCompareAndSwap
1699      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1700      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1701      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1702      // LIR_OpProfileCall
1703      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1704      // LIR_OpProfileType
1705      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1706      // LIR_OpAssert
1707 #ifdef ASSERT
1708      case lir_assert:                s = &quot;assert&quot;;        break;
1709 #endif
1710      case lir_none:                  ShouldNotReachHere();break;
1711     default:                         s = &quot;illegal_op&quot;;    break;
1712   }
1713   return s;
1714 }
1715 
1716 // LIR_OpJavaCall
1717 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
1923   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1924 }
1925 
1926 
1927 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
1928   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1929   if (code() == lir_store_check) {
1930     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
1931   }
1932   if (code() != lir_store_check) {
1933     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
1934     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
1935   }
1936   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1937   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1938   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1939   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1940   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
1941 }
1942 






























1943 
1944 // LIR_Op3
1945 void LIR_Op3::print_instr(outputStream* out) const {
1946   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1947   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1948   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1949   result_opr()-&gt;print(out);
1950 }
1951 
1952 
1953 void LIR_OpLock::print_instr(outputStream* out) const {
1954   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1955   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1956   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1957   if (_scratch-&gt;is_valid()) {
1958     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
1959   }
1960   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1961 }
1962 
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
<span class="line-added">  31 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  32 #include &quot;runtime/sharedRuntime.hpp&quot;
  33 
  34 Register LIR_OprDesc::as_register() const {
  35   return FrameMap::cpu_rnr2reg(cpu_regnr());
  36 }
  37 
  38 Register LIR_OprDesc::as_register_lo() const {
  39   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  40 }
  41 
  42 Register LIR_OprDesc::as_register_hi() const {
  43   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  44 }
  45 
  46 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  47 
  48 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  49   ValueTag tag = type-&gt;tag();
  50   switch (tag) {
  51   case metaDataTag : {
</pre>
<hr />
<pre>
  76 //---------------------------------------------------
  77 
  78 
  79 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  80   int elem_size = type2aelembytes(type);
  81   switch (elem_size) {
  82   case 1: return LIR_Address::times_1;
  83   case 2: return LIR_Address::times_2;
  84   case 4: return LIR_Address::times_4;
  85   case 8: return LIR_Address::times_8;
  86   }
  87   ShouldNotReachHere();
  88   return LIR_Address::times_1;
  89 }
  90 
  91 //---------------------------------------------------
  92 
  93 char LIR_OprDesc::type_char(BasicType t) {
  94   switch (t) {
  95     case T_ARRAY:
<span class="line-added">  96     case T_VALUETYPE:</span>
  97       t = T_OBJECT;
  98     case T_BOOLEAN:
  99     case T_CHAR:
 100     case T_FLOAT:
 101     case T_DOUBLE:
 102     case T_BYTE:
 103     case T_SHORT:
 104     case T_INT:
 105     case T_LONG:
 106     case T_OBJECT:
 107     case T_ADDRESS:
 108     case T_VOID:
 109       return ::type2char(t);
 110     case T_METADATA:
 111       return &#39;M&#39;;
 112     case T_ILLEGAL:
 113       return &#39;?&#39;;
 114 
 115     default:
 116       ShouldNotReachHere();
</pre>
<hr />
<pre>
 135              ARM_ONLY(|| kindfield == cpu_register)
 136              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 137              size_field() == single_size, &quot;must match&quot;);
 138       break;
 139     case T_DOUBLE:
 140       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 141       assert((kindfield == fpu_register || kindfield == stack_value
 142              ARM_ONLY(|| kindfield == cpu_register)
 143              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 144              size_field() == double_size, &quot;must match&quot;);
 145       break;
 146     case T_BOOLEAN:
 147     case T_CHAR:
 148     case T_BYTE:
 149     case T_SHORT:
 150     case T_INT:
 151     case T_ADDRESS:
 152     case T_OBJECT:
 153     case T_METADATA:
 154     case T_ARRAY:
<span class="line-added"> 155     case T_VALUETYPE:</span>
 156       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 157              size_field() == single_size, &quot;must match&quot;);
 158       break;
 159 
 160     case T_ILLEGAL:
 161       // XXX TKR also means unknown right now
 162       // assert(is_illegal(), &quot;must match&quot;);
 163       break;
 164 
 165     default:
 166       ShouldNotReachHere();
 167     }
 168   }
 169 #endif
 170 
 171 }
 172 #endif // PRODUCT
 173 
 174 
 175 bool LIR_OprDesc::is_oop() const {
</pre>
<hr />
<pre>
 282   assert(_ublock != NULL, &quot;must have old block&quot;);
 283   _ublock = b;
 284 }
 285 
 286 void LIR_OpBranch::negate_cond() {
 287   switch (_cond) {
 288     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 289     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 290     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 291     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 292     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 293     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 294     default: ShouldNotReachHere();
 295   }
 296 }
 297 
 298 
 299 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 300                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 301                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
<span class="line-modified"> 302                                  CodeStub* stub, bool need_null_check)</span>
 303 
 304   : LIR_Op(code, result, NULL)
 305   , _object(object)
 306   , _array(LIR_OprFact::illegalOpr)
 307   , _klass(klass)
 308   , _tmp1(tmp1)
 309   , _tmp2(tmp2)
 310   , _tmp3(tmp3)
 311   , _fast_check(fast_check)
 312   , _info_for_patch(info_for_patch)
 313   , _info_for_exception(info_for_exception)
 314   , _stub(stub)
 315   , _profiled_method(NULL)
 316   , _profiled_bci(-1)
 317   , _should_profile(false)
<span class="line-added"> 318   , _need_null_check(need_null_check)</span>
 319 {
 320   if (code == lir_checkcast) {
 321     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 322   } else if (code == lir_instanceof) {
 323     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 324   } else {
 325     ShouldNotReachHere();
 326   }
 327 }
 328 
 329 
 330 
 331 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 332   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 333   , _object(object)
 334   , _array(array)
 335   , _klass(NULL)
 336   , _tmp1(tmp1)
 337   , _tmp2(tmp2)
 338   , _tmp3(tmp3)
 339   , _fast_check(false)
 340   , _info_for_patch(NULL)
 341   , _info_for_exception(info_for_exception)
 342   , _stub(NULL)
 343   , _profiled_method(NULL)
 344   , _profiled_bci(-1)
 345   , _should_profile(false)
<span class="line-added"> 346   , _need_null_check(true)</span>
 347 {
 348   if (code == lir_store_check) {
 349     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 350     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 351   } else {
 352     ShouldNotReachHere();
 353   }
 354 }
 355 
<span class="line-added"> 356 LIR_OpFlattenedArrayCheck::LIR_OpFlattenedArrayCheck(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub)</span>
<span class="line-added"> 357   : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 358   , _array(array)</span>
<span class="line-added"> 359   , _value(value)</span>
<span class="line-added"> 360   , _tmp(tmp)</span>
<span class="line-added"> 361   , _stub(stub) {}</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364 LIR_OpNullFreeArrayCheck::LIR_OpNullFreeArrayCheck(LIR_Opr array, LIR_Opr tmp)</span>
<span class="line-added"> 365   : LIR_Op(lir_null_free_array_check, LIR_OprFact::illegalOpr, NULL)</span>
<span class="line-added"> 366   , _array(array)</span>
<span class="line-added"> 367   , _tmp(tmp) {}</span>
<span class="line-added"> 368 </span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370 LIR_OpSubstitutabilityCheck::LIR_OpSubstitutabilityCheck(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added"> 371                                                          LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added"> 372                                                          ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added"> 373                                                          CodeEmitInfo* info, CodeStub* stub)</span>
<span class="line-added"> 374   : LIR_Op(lir_substitutability_check, result, info)</span>
<span class="line-added"> 375   , _left(left)</span>
<span class="line-added"> 376   , _right(right)</span>
<span class="line-added"> 377   , _equal_result(equal_result)</span>
<span class="line-added"> 378   , _not_equal_result(not_equal_result)</span>
<span class="line-added"> 379   , _tmp1(tmp1)</span>
<span class="line-added"> 380   , _tmp2(tmp2)</span>
<span class="line-added"> 381   , _left_klass(left_klass)</span>
<span class="line-added"> 382   , _right_klass(right_klass)</span>
<span class="line-added"> 383   , _left_klass_op(left_klass_op)</span>
<span class="line-added"> 384   , _right_klass_op(right_klass_op)</span>
<span class="line-added"> 385   , _stub(stub) {}</span>
<span class="line-added"> 386 </span>
 387 
 388 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 389                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 390   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 391   , _src(src)
 392   , _src_pos(src_pos)
 393   , _dst(dst)
 394   , _dst_pos(dst_pos)
 395   , _length(length)
 396   , _tmp(tmp)
 397   , _expected_type(expected_type)
 398   , _flags(flags) {
 399   _stub = new ArrayCopyStub(this);
 400 }
 401 
 402 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 403   : LIR_Op(lir_updatecrc32, res, NULL)
 404   , _crc(crc)
 405   , _val(val) {
 406 }
</pre>
<hr />
<pre>
 434 // switch that adds the operands for each instruction
 435 
 436 void LIR_OpVisitState::visit(LIR_Op* op) {
 437   // copy information from the LIR_Op
 438   reset();
 439   set_op(op);
 440 
 441   switch (op-&gt;code()) {
 442 
 443 // LIR_Op0
 444     case lir_backwardbranch_target:    // result and info always invalid
 445     case lir_fpop_raw:                 // result and info always invalid
 446     case lir_breakpoint:               // result and info always invalid
 447     case lir_membar:                   // result and info always invalid
 448     case lir_membar_acquire:           // result and info always invalid
 449     case lir_membar_release:           // result and info always invalid
 450     case lir_membar_loadload:          // result and info always invalid
 451     case lir_membar_storestore:        // result and info always invalid
 452     case lir_membar_loadstore:         // result and info always invalid
 453     case lir_membar_storeload:         // result and info always invalid
<span class="line-added"> 454     case lir_check_orig_pc:            // result and info always invalid</span>
 455     case lir_on_spin_wait:
 456     {
 457       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 458       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 459       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 460       break;
 461     }
 462 
 463     case lir_nop:                      // may have info, result always invalid
 464     case lir_std_entry:                // may have result, info always invalid
 465     case lir_osr_entry:                // may have result, info always invalid
 466     case lir_get_thread:               // may have result, info always invalid
 467     {
 468       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 469       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 470       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 471       break;
 472     }
 473 
 474 
</pre>
<hr />
<pre>
 815 
 816 
 817 // LIR_OpLock
 818     case lir_lock:
 819     case lir_unlock: {
 820       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 821       LIR_OpLock* opLock = (LIR_OpLock*)op;
 822 
 823       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 824 
 825       // TODO: check if these operands really have to be temp
 826       // (or if input is sufficient). This may have influence on the oop map!
 827       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 828       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 829       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 830 
 831       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 832       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 833 
 834       do_stub(opLock-&gt;_stub);
<span class="line-added"> 835       do_stub(opLock-&gt;_throw_imse_stub);</span>
 836 
 837       break;
 838     }
 839 
 840 
 841 // LIR_OpDelay
 842     case lir_delay_slot: {
 843       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 844       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 845 
 846       visit(opDelay-&gt;delay_op());
 847       break;
 848     }
 849 
 850 // LIR_OpTypeCheck
 851     case lir_instanceof:
 852     case lir_checkcast:
 853     case lir_store_check: {
 854       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 855       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 856 
 857       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 858       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 859       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 860       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 861         do_temp(opTypeCheck-&gt;_object);
 862       }
 863       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 864       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 865       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 866       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 867       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 868                                                   do_stub(opTypeCheck-&gt;_stub);
 869       break;
 870     }
 871 
<span class="line-added"> 872 // LIR_OpFlattenedArrayCheck</span>
<span class="line-added"> 873     case lir_flattened_array_check: {</span>
<span class="line-added"> 874       assert(op-&gt;as_OpFlattenedArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 875       LIR_OpFlattenedArrayCheck* opFlattenedArrayCheck = (LIR_OpFlattenedArrayCheck*)op;</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877       if (opFlattenedArrayCheck-&gt;_array-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_array);</span>
<span class="line-added"> 878       if (opFlattenedArrayCheck-&gt;_value-&gt;is_valid()) do_input(opFlattenedArrayCheck-&gt;_value);</span>
<span class="line-added"> 879       if (opFlattenedArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opFlattenedArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 880                                                      do_stub(opFlattenedArrayCheck-&gt;_stub);</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882       break;</span>
<span class="line-added"> 883     }</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885 // LIR_OpNullFreeArrayCheck</span>
<span class="line-added"> 886     case lir_null_free_array_check: {</span>
<span class="line-added"> 887       assert(op-&gt;as_OpNullFreeArrayCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 888       LIR_OpNullFreeArrayCheck* opNullFreeArrayCheck = (LIR_OpNullFreeArrayCheck*)op;</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890       if (opNullFreeArrayCheck-&gt;_array-&gt;is_valid()) do_input(opNullFreeArrayCheck-&gt;_array);</span>
<span class="line-added"> 891       if (opNullFreeArrayCheck-&gt;_tmp-&gt;is_valid())   do_temp(opNullFreeArrayCheck-&gt;_tmp);</span>
<span class="line-added"> 892       break;</span>
<span class="line-added"> 893     }</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895 // LIR_OpSubstitutabilityCheck</span>
<span class="line-added"> 896     case lir_substitutability_check: {</span>
<span class="line-added"> 897       assert(op-&gt;as_OpSubstitutabilityCheck() != NULL, &quot;must be&quot;);</span>
<span class="line-added"> 898       LIR_OpSubstitutabilityCheck* opSubstitutabilityCheck = (LIR_OpSubstitutabilityCheck*)op;</span>
<span class="line-added"> 899                                                                 do_input(opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 900                                                                 do_temp (opSubstitutabilityCheck-&gt;_left);</span>
<span class="line-added"> 901                                                                 do_input(opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 902                                                                 do_temp (opSubstitutabilityCheck-&gt;_right);</span>
<span class="line-added"> 903                                                                 do_input(opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 904                                                                 do_temp (opSubstitutabilityCheck-&gt;_equal_result);</span>
<span class="line-added"> 905                                                                 do_input(opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 906                                                                 do_temp (opSubstitutabilityCheck-&gt;_not_equal_result);</span>
<span class="line-added"> 907       if (opSubstitutabilityCheck-&gt;_tmp1-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp1);</span>
<span class="line-added"> 908       if (opSubstitutabilityCheck-&gt;_tmp2-&gt;is_valid())           do_temp(opSubstitutabilityCheck-&gt;_tmp2);</span>
<span class="line-added"> 909       if (opSubstitutabilityCheck-&gt;_left_klass_op-&gt;is_valid())  do_temp(opSubstitutabilityCheck-&gt;_left_klass_op);</span>
<span class="line-added"> 910       if (opSubstitutabilityCheck-&gt;_right_klass_op-&gt;is_valid()) do_temp(opSubstitutabilityCheck-&gt;_right_klass_op);</span>
<span class="line-added"> 911       if (opSubstitutabilityCheck-&gt;_result-&gt;is_valid())         do_output(opSubstitutabilityCheck-&gt;_result);</span>
<span class="line-added"> 912                                                                 do_info(opSubstitutabilityCheck-&gt;_info);</span>
<span class="line-added"> 913                                                                 do_stub(opSubstitutabilityCheck-&gt;_stub);</span>
<span class="line-added"> 914       break;</span>
<span class="line-added"> 915     }</span>
<span class="line-added"> 916 </span>
 917 // LIR_OpCompareAndSwap
 918     case lir_cas_long:
 919     case lir_cas_obj:
 920     case lir_cas_int: {
 921       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 922       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 923 
 924       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 925       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 926       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 927       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 928                                                       do_input(opCompareAndSwap-&gt;_addr);
 929                                                       do_temp(opCompareAndSwap-&gt;_addr);
 930                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 931                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 932                                                       do_input(opCompareAndSwap-&gt;_new_value);
 933                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 934       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 935       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 936       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
</pre>
<hr />
<pre>
1024 #ifdef ASSERT
1025 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
1026   visit(op);
1027 
1028   return opr_count(inputMode) == 0 &amp;&amp;
1029          opr_count(outputMode) == 0 &amp;&amp;
1030          opr_count(tempMode) == 0 &amp;&amp;
1031          info_count() == 0 &amp;&amp;
1032          !has_call() &amp;&amp;
1033          !has_slow_case();
1034 }
1035 #endif
1036 
1037 //---------------------------------------------------
1038 
1039 
1040 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
1041   masm-&gt;emit_call(this);
1042 }
1043 
<span class="line-added">1044 bool LIR_OpJavaCall::maybe_return_as_fields(ciValueKlass** vk_ret) const {</span>
<span class="line-added">1045   if (InlineTypeReturnedAsFields) {</span>
<span class="line-added">1046     if (method()-&gt;signature()-&gt;maybe_returns_never_null()) {</span>
<span class="line-added">1047       ciType* return_type = method()-&gt;return_type();</span>
<span class="line-added">1048       if (return_type-&gt;is_valuetype()) {</span>
<span class="line-added">1049         ciValueKlass* vk = return_type-&gt;as_value_klass();</span>
<span class="line-added">1050         if (vk-&gt;can_be_returned_as_fields()) {</span>
<span class="line-added">1051           if (vk_ret != NULL) {</span>
<span class="line-added">1052             *vk_ret = vk;</span>
<span class="line-added">1053           }</span>
<span class="line-added">1054           return true;</span>
<span class="line-added">1055         }</span>
<span class="line-added">1056       } else {</span>
<span class="line-added">1057         assert(return_type-&gt;is_instance_klass() &amp;&amp; !return_type-&gt;as_instance_klass()-&gt;is_loaded(), &quot;must be&quot;);</span>
<span class="line-added">1058         if (vk_ret != NULL) {</span>
<span class="line-added">1059           *vk_ret = NULL;</span>
<span class="line-added">1060         }</span>
<span class="line-added">1061         return true;</span>
<span class="line-added">1062       }</span>
<span class="line-added">1063     } else if (is_method_handle_invoke()) {</span>
<span class="line-added">1064       BasicType bt = method()-&gt;return_type()-&gt;basic_type();</span>
<span class="line-added">1065       if (bt == T_OBJECT || bt == T_VALUETYPE) {</span>
<span class="line-added">1066         // A value type might be returned from the call but we don&#39;t know its</span>
<span class="line-added">1067         // type. Either we get a buffered value (and nothing needs to be done)</span>
<span class="line-added">1068         // or one of the values being returned is the klass of the value type</span>
<span class="line-added">1069         // (RAX on x64, with LSB set to 1) and we need to allocate a value</span>
<span class="line-added">1070         // type instance of that type and initialize it with other values being</span>
<span class="line-added">1071         // returned (in other registers).</span>
<span class="line-added">1072         // type.</span>
<span class="line-added">1073         if (vk_ret != NULL) {</span>
<span class="line-added">1074           *vk_ret = NULL;</span>
<span class="line-added">1075         }</span>
<span class="line-added">1076         return true;</span>
<span class="line-added">1077       }</span>
<span class="line-added">1078     }</span>
<span class="line-added">1079   }</span>
<span class="line-added">1080   return false;</span>
<span class="line-added">1081 }</span>
<span class="line-added">1082 </span>
1083 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
1084   masm-&gt;emit_rtcall(this);
1085 }
1086 
1087 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
1088   masm-&gt;emit_opLabel(this);
1089 }
1090 
1091 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
1092   masm-&gt;emit_arraycopy(this);
1093   masm-&gt;append_code_stub(stub());
1094 }
1095 
1096 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
1097   masm-&gt;emit_updatecrc32(this);
1098 }
1099 
1100 void LIR_Op0::emit_code(LIR_Assembler* masm) {
1101   masm-&gt;emit_op0(this);
1102 }
</pre>
<hr />
<pre>
1123     masm-&gt;append_code_stub(stub());
1124   }
1125 }
1126 
1127 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1128   masm-&gt;emit_op2(this);
1129 }
1130 
1131 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1132   masm-&gt;emit_alloc_array(this);
1133   masm-&gt;append_code_stub(stub());
1134 }
1135 
1136 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1137   masm-&gt;emit_opTypeCheck(this);
1138   if (stub()) {
1139     masm-&gt;append_code_stub(stub());
1140   }
1141 }
1142 
<span class="line-added">1143 void LIR_OpFlattenedArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1144   masm-&gt;emit_opFlattenedArrayCheck(this);</span>
<span class="line-added">1145   if (stub() != NULL) {</span>
<span class="line-added">1146     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1147   }</span>
<span class="line-added">1148 }</span>
<span class="line-added">1149 </span>
<span class="line-added">1150 void LIR_OpNullFreeArrayCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1151   masm-&gt;emit_opNullFreeArrayCheck(this);</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 void LIR_OpSubstitutabilityCheck::emit_code(LIR_Assembler* masm) {</span>
<span class="line-added">1155   masm-&gt;emit_opSubstitutabilityCheck(this);</span>
<span class="line-added">1156   if (stub() != NULL) {</span>
<span class="line-added">1157     masm-&gt;append_code_stub(stub());</span>
<span class="line-added">1158   }</span>
<span class="line-added">1159 }</span>
<span class="line-added">1160 </span>
1161 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1162   masm-&gt;emit_compare_and_swap(this);
1163 }
1164 
1165 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1166   masm-&gt;emit_op3(this);
1167 }
1168 
1169 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1170   masm-&gt;emit_lock(this);
1171   if (stub()) {
1172     masm-&gt;append_code_stub(stub());
1173   }
<span class="line-added">1174   if (throw_imse_stub()) {</span>
<span class="line-added">1175     masm-&gt;append_code_stub(throw_imse_stub());</span>
<span class="line-added">1176   }</span>
1177 }
1178 
1179 #ifdef ASSERT
1180 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1181   masm-&gt;emit_assert(this);
1182 }
1183 #endif
1184 
1185 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1186   masm-&gt;emit_delay(this);
1187 }
1188 
1189 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1190   masm-&gt;emit_profile_call(this);
1191 }
1192 
1193 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1194   masm-&gt;emit_profile_type(this);
1195 }
1196 
</pre>
<hr />
<pre>
1458                     tmp));
1459 }
1460 
1461 
1462 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1463  append(new LIR_Op2(
1464                     lir_ushr,
1465                     value,
1466                     count,
1467                     dst,
1468                     tmp));
1469 }
1470 
1471 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1472   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1473                      left,
1474                      right,
1475                      dst));
1476 }
1477 
<span class="line-modified">1478 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info, CodeStub* throw_imse_stub) {</span>
1479   append(new LIR_OpLock(
1480                     lir_lock,
1481                     hdr,
1482                     obj,
1483                     lock,
1484                     scratch,
1485                     stub,
<span class="line-modified">1486                     info,</span>
<span class="line-added">1487                     throw_imse_stub));</span>
1488 }
1489 
1490 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1491   append(new LIR_OpLock(
1492                     lir_unlock,
1493                     hdr,
1494                     obj,
1495                     lock,
1496                     scratch,
1497                     stub,
1498                     NULL));
1499 }
1500 
1501 
1502 void check_LIR() {
1503   // cannot do the proper checking as PRODUCT and other modes return different results
1504   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1505 }
1506 
1507 
1508 
1509 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1510                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1511                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1512                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {</span>
<span class="line-added">1513   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check</span>
<span class="line-added">1514   // on the object.</span>
<span class="line-added">1515   bool need_null_check = !is_never_null;</span>
1516   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
<span class="line-modified">1517                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,</span>
<span class="line-added">1518                                            need_null_check);</span>
1519   if (profiled_method != NULL) {
1520     c-&gt;set_profiled_method(profiled_method);
1521     c-&gt;set_profiled_bci(profiled_bci);
1522     c-&gt;set_should_profile(true);
1523   }
1524   append(c);
1525 }
1526 
1527 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1528   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1529   if (profiled_method != NULL) {
1530     c-&gt;set_profiled_method(profiled_method);
1531     c-&gt;set_profiled_bci(profiled_bci);
1532     c-&gt;set_should_profile(true);
1533   }
1534   append(c);
1535 }
1536 
1537 
1538 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1539                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
<span class="line-added">1540   // FIXME -- if the types of the array and/or the object are known statically, we can avoid loading the klass</span>
1541   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1542   if (profiled_method != NULL) {
1543     c-&gt;set_profiled_method(profiled_method);
1544     c-&gt;set_profiled_bci(profiled_bci);
1545     c-&gt;set_should_profile(true);
1546   }
1547   append(c);
1548 }
1549 
1550 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1551   if (deoptimize_on_null) {
1552     // Emit an explicit null check and deoptimize if opr is null
1553     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1554     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1555     branch(lir_cond_equal, T_OBJECT, deopt);
1556   } else {
1557     // Emit an implicit null check
1558     append(new LIR_Op1(lir_null_check, opr, info));
1559   }
1560 }
1561 
<span class="line-added">1562 void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {</span>
<span class="line-added">1563   LIR_OpFlattenedArrayCheck* c = new LIR_OpFlattenedArrayCheck(array, value, tmp, stub);</span>
<span class="line-added">1564   append(c);</span>
<span class="line-added">1565 }</span>
<span class="line-added">1566 </span>
<span class="line-added">1567 void LIR_List::check_null_free_array(LIR_Opr array, LIR_Opr tmp) {</span>
<span class="line-added">1568   LIR_OpNullFreeArrayCheck* c = new LIR_OpNullFreeArrayCheck(array, tmp);</span>
<span class="line-added">1569   append(c);</span>
<span class="line-added">1570 }</span>
<span class="line-added">1571 </span>
<span class="line-added">1572 void LIR_List::substitutability_check(LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr equal_result, LIR_Opr not_equal_result,</span>
<span class="line-added">1573                                       LIR_Opr tmp1, LIR_Opr tmp2,</span>
<span class="line-added">1574                                       ciKlass* left_klass, ciKlass* right_klass, LIR_Opr left_klass_op, LIR_Opr right_klass_op,</span>
<span class="line-added">1575                                       CodeEmitInfo* info, CodeStub* stub) {</span>
<span class="line-added">1576   LIR_OpSubstitutabilityCheck* c = new LIR_OpSubstitutabilityCheck(result, left, right, equal_result, not_equal_result,</span>
<span class="line-added">1577                                                                    tmp1, tmp2,</span>
<span class="line-added">1578                                                                    left_klass, right_klass, left_klass_op, right_klass_op,</span>
<span class="line-added">1579                                                                    info, stub);</span>
<span class="line-added">1580   append(c);</span>
<span class="line-added">1581 }</span>
<span class="line-added">1582 </span>
1583 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1584                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1585   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1586 }
1587 
1588 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1589                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1590   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1591 }
1592 
1593 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1594                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1595   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1596 }
1597 
1598 
1599 #ifdef PRODUCT
1600 
1601 void print_LIR(BlockList* blocks) {
1602 }
</pre>
<hr />
<pre>
1780 const char * LIR_Op::name() const {
1781   const char* s = NULL;
1782   switch(code()) {
1783      // LIR_Op0
1784      case lir_membar:                s = &quot;membar&quot;;        break;
1785      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1786      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1787      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1788      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1789      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1790      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1791      case lir_label:                 s = &quot;label&quot;;         break;
1792      case lir_nop:                   s = &quot;nop&quot;;           break;
1793      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1794      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1795      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1796      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1797      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1798      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1799      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
<span class="line-added">1800      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;</span>
1801      // LIR_Op1
1802      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1803      case lir_fld:                   s = &quot;fld&quot;;           break;
1804      case lir_push:                  s = &quot;push&quot;;          break;
1805      case lir_pop:                   s = &quot;pop&quot;;           break;
1806      case lir_null_check:            s = &quot;null_check&quot;;    break;
1807      case lir_return:                s = &quot;return&quot;;        break;
1808      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1809      case lir_leal:                  s = &quot;leal&quot;;          break;
1810      case lir_branch:                s = &quot;branch&quot;;        break;
1811      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1812      case lir_move:                  s = &quot;move&quot;;          break;
1813      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1814      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1815      case lir_throw:                 s = &quot;throw&quot;;         break;
1816      case lir_unwind:                s = &quot;unwind&quot;;        break;
1817      case lir_convert:               s = &quot;convert&quot;;       break;
1818      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1819      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
1820      // LIR_Op2
</pre>
<hr />
<pre>
1849      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1850      // LIR_OpJavaCall
1851      case lir_static_call:           s = &quot;static&quot;;        break;
1852      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1853      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1854      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1855      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1856      // LIR_OpArrayCopy
1857      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1858      // LIR_OpUpdateCRC32
1859      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1860      // LIR_OpLock
1861      case lir_lock:                  s = &quot;lock&quot;;          break;
1862      case lir_unlock:                s = &quot;unlock&quot;;        break;
1863      // LIR_OpDelay
1864      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1865      // LIR_OpTypeCheck
1866      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1867      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1868      case lir_store_check:           s = &quot;store_check&quot;;   break;
<span class="line-added">1869      // LIR_OpFlattenedArrayCheck</span>
<span class="line-added">1870      case lir_flattened_array_check: s = &quot;flattened_array_check&quot;; break;</span>
<span class="line-added">1871      // LIR_OpNullFreeArrayCheck</span>
<span class="line-added">1872      case lir_null_free_array_check: s = &quot;null_free_array_check&quot;; break;</span>
<span class="line-added">1873      // LIR_OpSubstitutabilityCheck</span>
<span class="line-added">1874      case lir_substitutability_check: s = &quot;substitutability_check&quot;; break;</span>
1875      // LIR_OpCompareAndSwap
1876      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1877      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1878      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1879      // LIR_OpProfileCall
1880      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1881      // LIR_OpProfileType
1882      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1883      // LIR_OpAssert
1884 #ifdef ASSERT
1885      case lir_assert:                s = &quot;assert&quot;;        break;
1886 #endif
1887      case lir_none:                  ShouldNotReachHere();break;
1888     default:                         s = &quot;illegal_op&quot;;    break;
1889   }
1890   return s;
1891 }
1892 
1893 // LIR_OpJavaCall
1894 void LIR_OpJavaCall::print_instr(outputStream* out) const {
</pre>
<hr />
<pre>
2100   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2101 }
2102 
2103 
2104 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
2105   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
2106   if (code() == lir_store_check) {
2107     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
2108   }
2109   if (code() != lir_store_check) {
2110     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
2111     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
2112   }
2113   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2114   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2115   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
2116   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
2117   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
2118 }
2119 
<span class="line-added">2120 void LIR_OpFlattenedArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2121   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2122   value()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2123   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2124   if (stub() != NULL) {</span>
<span class="line-added">2125     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2126   }</span>
<span class="line-added">2127 }</span>
<span class="line-added">2128 </span>
<span class="line-added">2129 void LIR_OpNullFreeArrayCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2130   array()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2131   tmp()-&gt;print(out);                     out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2132 }</span>
<span class="line-added">2133 </span>
<span class="line-added">2134 void LIR_OpSubstitutabilityCheck::print_instr(outputStream* out) const {</span>
<span class="line-added">2135   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2136   left()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2137   right()-&gt;print(out);                   out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2138   equal_result()-&gt;print(out);            out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2139   not_equal_result()-&gt;print(out);        out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2140   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2141   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2142   left_klass()-&gt;print(out);              out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2143   right_klass()-&gt;print(out);             out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2144   left_klass_op()-&gt;print(out);           out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2145   right_klass_op()-&gt;print(out);          out-&gt;print(&quot; &quot;);</span>
<span class="line-added">2146   if (stub() != NULL) {</span>
<span class="line-added">2147     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));</span>
<span class="line-added">2148   }</span>
<span class="line-added">2149 }</span>
2150 
2151 // LIR_Op3
2152 void LIR_Op3::print_instr(outputStream* out) const {
2153   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2154   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2155   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
2156   result_opr()-&gt;print(out);
2157 }
2158 
2159 
2160 void LIR_OpLock::print_instr(outputStream* out) const {
2161   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2162   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
2163   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
2164   if (_scratch-&gt;is_valid()) {
2165     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
2166   }
2167   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
2168 }
2169 
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
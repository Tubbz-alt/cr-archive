<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;

  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;compiler/compilerEvent.hpp&quot;
  39 #include &quot;interpreter/bytecode.hpp&quot;
  40 #include &quot;jfr/jfrEvents.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #include &quot;runtime/vm_version.hpp&quot;
  45 #include &quot;utilities/bitMap.inline.hpp&quot;
  46 #include &quot;utilities/powerOfTwo.hpp&quot;
  47 
  48 class BlockListBuilder {
  49  private:
  50   Compilation* _compilation;
  51   IRScope*     _scope;
  52 
  53   BlockList    _blocks;                // internal list of all blocks
  54   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  55 
</pre>
<hr />
<pre>
 639         }
 640 #endif
 641         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 642         return result;
 643       }
 644     }
 645     return load;
 646   }
 647 
 648   // Record this newly allocated object
 649   void new_instance(NewInstance* object) {
 650     int index = _newobjects.length();
 651     _newobjects.append(object);
 652     if (_fields.at_grow(index, NULL) == NULL) {
 653       _fields.at_put(index, new FieldBuffer());
 654     } else {
 655       _fields.at(index)-&gt;kill();
 656     }
 657   }
 658 











 659   void store_value(Value value) {
 660     int index = _newobjects.find(value);
 661     if (index != -1) {
 662       // stored a newly allocated object into another object.
 663       // Assume we&#39;ve lost track of it as separate slice of memory.
 664       // We could do better by keeping track of whether individual
 665       // fields could alias each other.
 666       _newobjects.remove_at(index);
 667       // pull out the field info and store it at the end up the list
 668       // of field info list to be reused later.
 669       _fields.append(_fields.at(index));
 670       _fields.remove_at(index);
 671     }
 672   }
 673 
 674   void kill() {
 675     _newobjects.trunc_to(0);
 676     _objects.trunc_to(0);
 677     _values.kill();
 678   }
</pre>
<hr />
<pre>
 954     // constructs. Here we are figuring out in which circumstances we
 955     // need to bail out.
 956     if (x-&gt;type()-&gt;is_address()) {
 957       scope_data()-&gt;set_jsr_return_address_local(index);
 958 
 959       // Also check parent jsrs (if any) at this time to see whether
 960       // they are using this local. We don&#39;t handle skipping over a
 961       // ret.
 962       for (ScopeData* cur_scope_data = scope_data()-&gt;parent();
 963            cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
 964            cur_scope_data = cur_scope_data-&gt;parent()) {
 965         if (cur_scope_data-&gt;jsr_return_address_local() == index) {
 966           BAILOUT(&quot;subroutine overwrites return address from previous subroutine&quot;);
 967         }
 968       }
 969     } else if (index == scope_data()-&gt;jsr_return_address_local()) {
 970       scope_data()-&gt;set_jsr_return_address_local(-1);
 971     }
 972   }
 973 

 974   state-&gt;store_local(index, round_fp(x));
 975 }
 976 
 977 
 978 void GraphBuilder::load_indexed(BasicType type) {
 979   // In case of in block code motion in range check elimination
<span class="line-modified"> 980   ValueStack* state_before = copy_state_indexed_access();</span>








 981   compilation()-&gt;set_has_access_indexed(true);
 982   Value index = ipop();
 983   Value array = apop();
 984   Value length = NULL;
 985   if (CSEArrayLength ||
 986       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
 987       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
 988     length = append(new ArrayLength(array, state_before));
 989   }
<span class="line-modified"> 990   push(as_ValueType(type), append(new LoadIndexed(array, index, length, type, state_before)));</span>
























 991 }
 992 
 993 
 994 void GraphBuilder::store_indexed(BasicType type) {
 995   // In case of in block code motion in range check elimination
<span class="line-modified"> 996   ValueStack* state_before = copy_state_indexed_access();</span>








 997   compilation()-&gt;set_has_access_indexed(true);
 998   Value value = pop(as_ValueType(type));
 999   Value index = ipop();
1000   Value array = apop();
1001   Value length = NULL;

1002   if (CSEArrayLength ||
1003       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1004       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1005     length = append(new ArrayLength(array, state_before));
1006   }
1007   ciType* array_type = array-&gt;declared_type();
1008   bool check_boolean = false;
1009   if (array_type != NULL) {
1010     if (array_type-&gt;is_loaded() &amp;&amp;
1011       array_type-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() == T_BOOLEAN) {
1012       assert(type == T_BYTE, &quot;boolean store uses bastore&quot;);
1013       Value mask = append(new Constant(new IntConstant(1)));
1014       value = append(new LogicOp(Bytecodes::_iand, value, mask));
1015     }
1016   } else if (type == T_BYTE) {
1017     check_boolean = true;
1018   }
<span class="line-modified">1019   StoreIndexed* result = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);</span>
<span class="line-modified">1020   append(result);</span>
<span class="line-removed">1021   _memory-&gt;store_value(value);</span>
<span class="line-removed">1022 </span>
<span class="line-removed">1023   if (type == T_OBJECT &amp;&amp; is_profiling()) {</span>
1024     // Note that we&#39;d collect profile data in this method if we wanted it.
1025     compilation()-&gt;set_would_profile(true);
<span class="line-modified">1026 </span>
<span class="line-modified">1027     if (profile_checkcasts()) {</span>
<span class="line-modified">1028       result-&gt;set_profiled_method(method());</span>
<span class="line-removed">1029       result-&gt;set_profiled_bci(bci());</span>
<span class="line-removed">1030       result-&gt;set_should_profile(true);</span>
<span class="line-removed">1031     }</span>
1032   }




1033 }
1034 
1035 
1036 void GraphBuilder::stack_op(Bytecodes::Code code) {
1037   switch (code) {
1038     case Bytecodes::_pop:
1039       { state()-&gt;raw_pop();
1040       }
1041       break;
1042     case Bytecodes::_pop2:
1043       { state()-&gt;raw_pop();
1044         state()-&gt;raw_pop();
1045       }
1046       break;
1047     case Bytecodes::_dup:
1048       { Value w = state()-&gt;raw_pop();
1049         state()-&gt;raw_push(w);
1050         state()-&gt;raw_push(w);
1051       }
1052       break;
</pre>
<hr />
<pre>
1207 
1208 
1209 void GraphBuilder::_goto(int from_bci, int to_bci) {
1210   Goto *x = new Goto(block_at(to_bci), to_bci &lt;= from_bci);
1211   if (is_profiling()) {
1212     compilation()-&gt;set_would_profile(true);
1213     x-&gt;set_profiled_bci(bci());
1214     if (profile_branches()) {
1215       x-&gt;set_profiled_method(method());
1216       x-&gt;set_should_profile(true);
1217     }
1218   }
1219   append(x);
1220 }
1221 
1222 
1223 void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
1224   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1225   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1226   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();


























1227   // In case of loop invariant code motion or predicate insertion
1228   // before the body of a loop the state is needed
<span class="line-modified">1229   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic()) ? state_before : NULL, is_bb));</span>
1230 
1231   assert(i-&gt;as_Goto() == NULL ||
1232          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1233          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1234          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1235 
1236   if (is_profiling()) {
1237     If* if_node = i-&gt;as_If();
1238     if (if_node != NULL) {
1239       // Note that we&#39;d collect profile data in this method if we wanted it.
1240       compilation()-&gt;set_would_profile(true);
1241       // At level 2 we need the proper bci to count backedges
1242       if_node-&gt;set_profiled_bci(bci());
1243       if (profile_branches()) {
1244         // Successors can be rotated by the canonicalizer, check for this case.
1245         if_node-&gt;set_profiled_method(method());
1246         if_node-&gt;set_should_profile(true);
1247         if (if_node-&gt;tsux() == fsux) {
1248           if_node-&gt;set_swapped(true);
1249         }
</pre>
<hr />
<pre>
1460 
1461   if (needs_check) {
1462     // Perform the registration of finalizable objects.
1463     ValueStack* state_before = copy_state_for_exception();
1464     load_local(objectType, 0);
1465     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1466                                state()-&gt;pop_arguments(1),
1467                                true, state_before, true));
1468   }
1469 }
1470 
1471 
1472 void GraphBuilder::method_return(Value x, bool ignore_return) {
1473   if (RegisterFinalizersAtInit &amp;&amp;
1474       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1475     call_register_finalizer();
1476   }
1477 
1478   // The conditions for a memory barrier are described in Parse::do_exits().
1479   bool need_mem_bar = false;
<span class="line-modified">1480   if (method()-&gt;name() == ciSymbol::object_initializer_name() &amp;&amp;</span>
1481        (scope()-&gt;wrote_final() ||
1482          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
1483          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
1484     need_mem_bar = true;
1485   }
1486 
1487   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1488   switch (bt) {
1489     case T_BYTE:
1490     {
1491       Value shift = append(new Constant(new IntConstant(24)));
1492       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1493       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1494       break;
1495     }
1496     case T_SHORT:
1497     {
1498       Value shift = append(new Constant(new IntConstant(16)));
1499       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1500       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
</pre>
<hr />
<pre>
1611   // Attach dimension info to stable arrays.
1612   if (FoldStableValues &amp;&amp;
1613       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1614     ciArray* array = field_value.as_object()-&gt;as_array();
1615     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1616     value = new StableArrayConstant(array, dimension);
1617   }
1618 
1619   switch (field_type) {
1620     case T_ARRAY:
1621     case T_OBJECT:
1622       if (field_value.as_object()-&gt;should_be_constant()) {
1623         return new Constant(value);
1624       }
1625       return NULL; // Not a constant.
1626     default:
1627       return new Constant(value);
1628   }
1629 }
1630 














1631 void GraphBuilder::access_field(Bytecodes::Code code) {
1632   bool will_link;
1633   ciField* field = stream()-&gt;get_field(will_link);
1634   ciInstanceKlass* holder = field-&gt;holder();
1635   BasicType field_type = field-&gt;type()-&gt;basic_type();
1636   ValueType* type = as_ValueType(field_type);

1637   // call will_link again to determine if the field is valid.
1638   const bool needs_patching = !holder-&gt;is_loaded() ||
1639                               !field-&gt;will_link(method(), code) ||
1640                               PatchALot;
1641 
1642   ValueStack* state_before = NULL;
1643   if (!holder-&gt;is_initialized() || needs_patching) {
1644     // save state before instruction for debug info when
1645     // deoptimization happens during patching
1646     state_before = copy_state_before();
1647   }
1648 
1649   Value obj = NULL;
1650   if (code == Bytecodes::_getstatic || code == Bytecodes::_putstatic) {
1651     if (state_before != NULL) {
1652       // build a patching constant
1653       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()), state_before);
1654     } else {
1655       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
1656     }
1657   }
1658 
<span class="line-modified">1659   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield)) {</span>
1660     scope()-&gt;set_wrote_final();
1661   }
1662 
<span class="line-modified">1663   if (code == Bytecodes::_putfield) {</span>
1664     scope()-&gt;set_wrote_fields();
1665     if (field-&gt;is_volatile()) {
1666       scope()-&gt;set_wrote_volatile();
1667     }
1668   }
1669 
1670   const int offset = !needs_patching ? field-&gt;offset() : -1;
1671   switch (code) {
1672     case Bytecodes::_getstatic: {
1673       // check for compile-time constants, i.e., initialized static final fields
1674       Value constant = NULL;
1675       if (field-&gt;is_static_constant() &amp;&amp; !PatchALot) {
1676         ciConstant field_value = field-&gt;constant_value();
1677         assert(!field-&gt;is_stable() || !field_value.is_null_or_zero(),
1678                &quot;stable static w/ default value shouldn&#39;t be a constant&quot;);
1679         constant = make_constant(field_value, field);
1680       }
1681       if (constant != NULL) {
1682         push(type, append(constant));
1683       } else {
1684         if (state_before == NULL) {
1685           state_before = copy_state_for_exception();
1686         }
<span class="line-modified">1687         push(type, append(new LoadField(append(obj), offset, field, true,</span>
<span class="line-modified">1688                                         state_before, needs_patching)));</span>




1689       }
1690       break;
1691     }
1692     case Bytecodes::_putstatic: {
1693       Value val = pop(type);

1694       if (state_before == NULL) {
1695         state_before = copy_state_for_exception();
1696       }
1697       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1698         Value mask = append(new Constant(new IntConstant(1)));
1699         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1700       }
1701       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1702       break;
1703     }
1704     case Bytecodes::_getfield: {
1705       // Check for compile-time constants, i.e., trusted final non-static fields.
1706       Value constant = NULL;





1707       obj = apop();
1708       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
<span class="line-modified">1709       if (field-&gt;is_constant() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {</span>
1710         ciObject* const_oop = obj_type-&gt;constant_value();
1711         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1712           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1713           if (field_value.is_valid()) {
1714             constant = make_constant(field_value, field);
1715             // For CallSite objects add a dependency for invalidation of the optimization.
1716             if (field-&gt;is_call_site_target()) {
1717               ciCallSite* call_site = const_oop-&gt;as_call_site();
1718               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1719                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1720                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1721               }
1722             }
1723           }
1724         }
1725       }
1726       if (constant != NULL) {
1727         push(type, append(constant));
1728       } else {
1729         if (state_before == NULL) {
1730           state_before = copy_state_for_exception();
1731         }
<span class="line-modified">1732         LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);</span>
<span class="line-modified">1733         Value replacement = !needs_patching ? _memory-&gt;load(load) : load;</span>
<span class="line-modified">1734         if (replacement != load) {</span>
<span class="line-modified">1735           assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);</span>
<span class="line-modified">1736           // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="line-modified">1737           // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="line-modified">1738           BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-modified">1739           switch (bt) {</span>
<span class="line-modified">1740           case T_BOOLEAN:</span>
<span class="line-modified">1741           case T_BYTE:</span>
<span class="line-modified">1742             replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1743             break;</span>
<span class="line-modified">1744           case T_CHAR:</span>
<span class="line-modified">1745             replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1746             break;</span>
<span class="line-modified">1747           case T_SHORT:</span>
<span class="line-modified">1748             replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1749             break;</span>
<span class="line-modified">1750           default:</span>
<span class="line-modified">1751             break;</span>





1752           }
<span class="line-modified">1753           push(type, replacement);</span>
<span class="line-modified">1754         } else {</span>
<span class="line-modified">1755           push(type, append(load));</span>









1756         }
1757       }
1758       break;
1759     }

1760     case Bytecodes::_putfield: {
1761       Value val = pop(type);

1762       obj = apop();
1763       if (state_before == NULL) {
1764         state_before = copy_state_for_exception();
1765       }
1766       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1767         Value mask = append(new Constant(new IntConstant(1)));
1768         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1769       }
<span class="line-modified">1770       StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);</span>
<span class="line-modified">1771       if (!needs_patching) store = _memory-&gt;store(store);</span>
<span class="line-modified">1772       if (store != NULL) {</span>
<span class="line-modified">1773         append(store);</span>









1774       }
1775       break;
1776     }
1777     default:
1778       ShouldNotReachHere();
1779       break;
1780   }
1781 }
1782 















































































































1783 
1784 Dependencies* GraphBuilder::dependency_recorder() const {
1785   assert(DeoptC1, &quot;need debug information&quot;);
1786   return compilation()-&gt;dependency_recorder();
1787 }
1788 
1789 // How many arguments do we want to profile?
1790 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
1791   int n = 0;
1792   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
1793   start = has_receiver ? 1 : 0;
1794   if (profile_arguments()) {
1795     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
1796     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
1797       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
1798     }
1799   }
1800   // If we are inlining then we need to collect arguments to profile parameters for the target
1801   if (profile_parameters() &amp;&amp; target != NULL) {
1802     if (target-&gt;method_data() != NULL &amp;&amp; target-&gt;method_data()-&gt;parameters_type_data() != NULL) {
</pre>
<hr />
<pre>
1848   ciKlass*              holder = stream()-&gt;get_declared_method_holder();
1849   const Bytecodes::Code bc_raw = stream()-&gt;cur_bc_raw();
1850   assert(declared_signature != NULL, &quot;cannot be null&quot;);
1851   assert(will_link == target-&gt;is_loaded(), &quot;&quot;);
1852 
1853   ciInstanceKlass* klass = target-&gt;holder();
1854   assert(!target-&gt;is_loaded() || klass-&gt;is_loaded(), &quot;loaded target must imply loaded klass&quot;);
1855 
1856   // check if CHA possible: if so, change the code to invoke_special
1857   ciInstanceKlass* calling_klass = method()-&gt;holder();
1858   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
1859   ciInstanceKlass* actual_recv = callee_holder;
1860 
1861   CompileLog* log = compilation()-&gt;log();
1862   if (log != NULL)
1863       log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
1864                 log-&gt;identify(target),
1865                 Bytecodes::name(code));
1866 
1867   // invoke-special-super
<span class="line-modified">1868   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_initializer()) {</span>
1869     ciInstanceKlass* sender_klass =
1870           calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
1871                                                  calling_klass;
1872     if (sender_klass-&gt;is_interface()) {
1873       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
1874       Value receiver = state()-&gt;stack_at(index);
1875       CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());
1876       c-&gt;set_invokespecial_receiver_check();
1877       state()-&gt;stack_at_put(index, append_split(c));
1878     }
1879   }
1880 
1881   // Some methods are obviously bindable without any type checks so
1882   // convert them directly to an invokespecial or invokestatic.
1883   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
1884     switch (bc_raw) {
1885     case Bytecodes::_invokevirtual:
1886       code = Bytecodes::_invokespecial;
1887       break;
1888     case Bytecodes::_invokehandle:
</pre>
<hr />
<pre>
2103       null_check(recv);
2104     }
2105 
2106     if (is_profiling()) {
2107       // Note that we&#39;d collect profile data in this method if we wanted it.
2108       compilation()-&gt;set_would_profile(true);
2109 
2110       if (profile_calls()) {
2111         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2112         ciKlass* target_klass = NULL;
2113         if (cha_monomorphic_target != NULL) {
2114           target_klass = cha_monomorphic_target-&gt;holder();
2115         } else if (exact_target != NULL) {
2116           target_klass = exact_target-&gt;holder();
2117         }
2118         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2119       }
2120     }
2121   }
2122 
<span class="line-modified">2123   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before);</span>








2124   // push result
2125   append_split(result);
2126 
2127   if (result_type != voidType) {
2128     if (method()-&gt;is_strict()) {
2129       push(result_type, round_fp(result));
2130     } else {
2131       push(result_type, result);
2132     }
2133   }
2134   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2135     profile_return_type(result, target);
2136   }
2137 }
2138 
2139 
2140 void GraphBuilder::new_instance(int klass_index) {
2141   ValueStack* state_before = copy_state_exhandling();
2142   bool will_link;
2143   ciKlass* klass = stream()-&gt;get_klass(will_link);
2144   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);

2145   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2146   _memory-&gt;new_instance(new_instance);
2147   apush(append_split(new_instance));
2148 }
2149 










2150 
2151 void GraphBuilder::new_type_array() {
2152   ValueStack* state_before = copy_state_exhandling();
2153   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2154 }
2155 
2156 
2157 void GraphBuilder::new_object_array() {
2158   bool will_link;
2159   ciKlass* klass = stream()-&gt;get_klass(will_link);

2160   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
<span class="line-modified">2161   NewArray* n = new NewObjectArray(klass, ipop(), state_before);</span>
2162   apush(append_split(n));
2163 }
2164 
2165 
2166 bool GraphBuilder::direct_compare(ciKlass* k) {
2167   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2168     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2169     if (ik-&gt;is_final()) {
2170       return true;
2171     } else {
2172       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2173         // test class is leaf class
2174         dependency_recorder()-&gt;assert_leaf_type(ik);
2175         return true;
2176       }
2177     }
2178   }
2179   return false;
2180 }
2181 
2182 
2183 void GraphBuilder::check_cast(int klass_index) {
2184   bool will_link;
2185   ciKlass* klass = stream()-&gt;get_klass(will_link);

2186   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
<span class="line-modified">2187   CheckCast* c = new CheckCast(klass, apop(), state_before);</span>
2188   apush(append_split(c));
2189   c-&gt;set_direct_compare(direct_compare(klass));
2190 
2191   if (is_profiling()) {
2192     // Note that we&#39;d collect profile data in this method if we wanted it.
2193     compilation()-&gt;set_would_profile(true);
2194 
2195     if (profile_checkcasts()) {
2196       c-&gt;set_profiled_method(method());
2197       c-&gt;set_profiled_bci(bci());
2198       c-&gt;set_should_profile(true);
2199     }
2200   }
2201 }
2202 
2203 
2204 void GraphBuilder::instance_of(int klass_index) {
2205   bool will_link;
2206   ciKlass* klass = stream()-&gt;get_klass(will_link);
2207   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2208   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2209   ipush(append_split(i));
2210   i-&gt;set_direct_compare(direct_compare(klass));
2211 
2212   if (is_profiling()) {
2213     // Note that we&#39;d collect profile data in this method if we wanted it.
2214     compilation()-&gt;set_would_profile(true);
2215 
2216     if (profile_checkcasts()) {
2217       i-&gt;set_profiled_method(method());
2218       i-&gt;set_profiled_bci(bci());
2219       i-&gt;set_should_profile(true);
2220     }
2221   }
2222 }
2223 
2224 
2225 void GraphBuilder::monitorenter(Value x, int bci) {



















2226   // save state before locking in case of deoptimization after a NullPointerException
2227   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2228   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before), bci);</span>
2229   kill_all();
2230 }
2231 
2232 
2233 void GraphBuilder::monitorexit(Value x, int bci) {
2234   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2235   kill_all();
2236 }
2237 
2238 
2239 void GraphBuilder::new_multi_array(int dimensions) {
2240   bool will_link;
2241   ciKlass* klass = stream()-&gt;get_klass(will_link);
2242   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2243 
2244   Values* dims = new Values(dimensions, dimensions, NULL);
2245   // fill in all dimensions
2246   int i = dimensions;
2247   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2248   // create array
</pre>
<hr />
<pre>
2870       case Bytecodes::_invokevirtual  : // fall through
2871       case Bytecodes::_invokespecial  : // fall through
2872       case Bytecodes::_invokestatic   : // fall through
2873       case Bytecodes::_invokedynamic  : // fall through
2874       case Bytecodes::_invokeinterface: invoke(code); break;
2875       case Bytecodes::_new            : new_instance(s.get_index_u2()); break;
2876       case Bytecodes::_newarray       : new_type_array(); break;
2877       case Bytecodes::_anewarray      : new_object_array(); break;
2878       case Bytecodes::_arraylength    : { ValueStack* state_before = copy_state_for_exception(); ipush(append(new ArrayLength(apop(), state_before))); break; }
2879       case Bytecodes::_athrow         : throw_op(s.cur_bci()); break;
2880       case Bytecodes::_checkcast      : check_cast(s.get_index_u2()); break;
2881       case Bytecodes::_instanceof     : instance_of(s.get_index_u2()); break;
2882       case Bytecodes::_monitorenter   : monitorenter(apop(), s.cur_bci()); break;
2883       case Bytecodes::_monitorexit    : monitorexit (apop(), s.cur_bci()); break;
2884       case Bytecodes::_wide           : ShouldNotReachHere(); break;
2885       case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
2886       case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
2887       case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
2888       case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
2889       case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;


2890       case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
2891       default                         : ShouldNotReachHere(); break;
2892     }
2893 
2894     if (log != NULL)
2895       log-&gt;clear_context(); // skip marker if nothing was printed
2896 
2897     // save current bci to setup Goto at the end
2898     prev_bci = s.cur_bci();
2899 
2900   }
2901   CHECK_BAILOUT_(NULL);
2902   // stop processing of this block (see try_inline_full)
2903   if (_skip_block) {
2904     _skip_block = false;
2905     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
2906     return _last-&gt;as_BlockEnd();
2907   }
2908   // if there are any, check if last instruction is a BlockEnd instruction
2909   BlockEnd* end = last()-&gt;as_BlockEnd();
</pre>
<hr />
<pre>
3155   // the storage for the OSR buffer is freed manually in the LIRGenerator.
3156 
3157   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3158   state-&gt;clear_locals();
3159   Goto* g = new Goto(target, false);
3160   append(g);
3161   _osr_entry-&gt;set_end(g);
3162   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3163 
3164   scope_data()-&gt;set_stream(NULL);
3165 }
3166 
3167 
3168 ValueStack* GraphBuilder::state_at_entry() {
3169   ValueStack* state = new ValueStack(scope(), NULL);
3170 
3171   // Set up locals for receiver
3172   int idx = 0;
3173   if (!method()-&gt;is_static()) {
3174     // we should always see the receiver
<span class="line-modified">3175     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx, true));</span>

3176     idx = 1;
3177   }
3178 
3179   // Set up locals for incoming arguments
3180   ciSignature* sig = method()-&gt;signature();
3181   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3182     ciType* type = sig-&gt;type_at(i);
3183     BasicType basic_type = type-&gt;basic_type();
3184     // don&#39;t allow T_ARRAY to propagate into locals types
3185     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3186     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3187     state-&gt;store_local(idx, new Local(type, vt, idx, false));</span>
3188     idx += type-&gt;size();
3189   }
3190 
3191   // lock synchronized method
3192   if (method()-&gt;is_synchronized()) {
3193     state-&gt;lock(NULL);
3194   }
3195 
3196   return state;
3197 }
3198 
3199 
3200 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3201   : _scope_data(NULL)
3202   , _compilation(compilation)
3203   , _memory(new MemoryBuffer())
3204   , _inline_bailout_msg(NULL)
3205   , _instruction_count(0)
3206   , _osr_entry(NULL)
3207 {
</pre>
</td>
<td>
<hr />
<pre>
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_GraphBuilder.hpp&quot;
  30 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  31 #include &quot;ci/ciCallSite.hpp&quot;
  32 #include &quot;ci/ciField.hpp&quot;
  33 #include &quot;ci/ciKlass.hpp&quot;
  34 #include &quot;ci/ciMemberName.hpp&quot;
  35 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added">  36 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  37 #include &quot;compiler/compilationPolicy.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/compilerEvent.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/vm_version.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;
  47 #include &quot;utilities/powerOfTwo.hpp&quot;
  48 
  49 class BlockListBuilder {
  50  private:
  51   Compilation* _compilation;
  52   IRScope*     _scope;
  53 
  54   BlockList    _blocks;                // internal list of all blocks
  55   BlockList*   _bci2block;             // mapping from bci to blocks for GraphBuilder
  56 
</pre>
<hr />
<pre>
 640         }
 641 #endif
 642         assert(result-&gt;type()-&gt;tag() == load-&gt;type()-&gt;tag(), &quot;wrong types&quot;);
 643         return result;
 644       }
 645     }
 646     return load;
 647   }
 648 
 649   // Record this newly allocated object
 650   void new_instance(NewInstance* object) {
 651     int index = _newobjects.length();
 652     _newobjects.append(object);
 653     if (_fields.at_grow(index, NULL) == NULL) {
 654       _fields.at_put(index, new FieldBuffer());
 655     } else {
 656       _fields.at(index)-&gt;kill();
 657     }
 658   }
 659 
<span class="line-added"> 660   // Record this newly allocated object</span>
<span class="line-added"> 661   void new_instance(NewValueTypeInstance* object) {</span>
<span class="line-added"> 662     int index = _newobjects.length();</span>
<span class="line-added"> 663     _newobjects.append(object);</span>
<span class="line-added"> 664     if (_fields.at_grow(index, NULL) == NULL) {</span>
<span class="line-added"> 665       _fields.at_put(index, new FieldBuffer());</span>
<span class="line-added"> 666     } else {</span>
<span class="line-added"> 667       _fields.at(index)-&gt;kill();</span>
<span class="line-added"> 668     }</span>
<span class="line-added"> 669   }</span>
<span class="line-added"> 670 </span>
 671   void store_value(Value value) {
 672     int index = _newobjects.find(value);
 673     if (index != -1) {
 674       // stored a newly allocated object into another object.
 675       // Assume we&#39;ve lost track of it as separate slice of memory.
 676       // We could do better by keeping track of whether individual
 677       // fields could alias each other.
 678       _newobjects.remove_at(index);
 679       // pull out the field info and store it at the end up the list
 680       // of field info list to be reused later.
 681       _fields.append(_fields.at(index));
 682       _fields.remove_at(index);
 683     }
 684   }
 685 
 686   void kill() {
 687     _newobjects.trunc_to(0);
 688     _objects.trunc_to(0);
 689     _values.kill();
 690   }
</pre>
<hr />
<pre>
 966     // constructs. Here we are figuring out in which circumstances we
 967     // need to bail out.
 968     if (x-&gt;type()-&gt;is_address()) {
 969       scope_data()-&gt;set_jsr_return_address_local(index);
 970 
 971       // Also check parent jsrs (if any) at this time to see whether
 972       // they are using this local. We don&#39;t handle skipping over a
 973       // ret.
 974       for (ScopeData* cur_scope_data = scope_data()-&gt;parent();
 975            cur_scope_data != NULL &amp;&amp; cur_scope_data-&gt;parsing_jsr() &amp;&amp; cur_scope_data-&gt;scope() == scope();
 976            cur_scope_data = cur_scope_data-&gt;parent()) {
 977         if (cur_scope_data-&gt;jsr_return_address_local() == index) {
 978           BAILOUT(&quot;subroutine overwrites return address from previous subroutine&quot;);
 979         }
 980       }
 981     } else if (index == scope_data()-&gt;jsr_return_address_local()) {
 982       scope_data()-&gt;set_jsr_return_address_local(-1);
 983     }
 984   }
 985 
<span class="line-added"> 986   x-&gt;set_local_index(index);</span>
 987   state-&gt;store_local(index, round_fp(x));
 988 }
 989 
 990 
 991 void GraphBuilder::load_indexed(BasicType type) {
 992   // In case of in block code motion in range check elimination
<span class="line-modified"> 993   ValueStack* state_before = NULL;</span>
<span class="line-added"> 994   int array_idx = state()-&gt;stack_size() - 2;</span>
<span class="line-added"> 995   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {</span>
<span class="line-added"> 996     // Save the entire state and re-execute on deopt when accessing flattened arrays</span>
<span class="line-added"> 997     state_before = copy_state_before();</span>
<span class="line-added"> 998     state_before-&gt;set_should_reexecute(true);</span>
<span class="line-added"> 999   } else {</span>
<span class="line-added">1000     state_before = copy_state_indexed_access();</span>
<span class="line-added">1001   }</span>
1002   compilation()-&gt;set_has_access_indexed(true);
1003   Value index = ipop();
1004   Value array = apop();
1005   Value length = NULL;
1006   if (CSEArrayLength ||
1007       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1008       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1009     length = append(new ArrayLength(array, state_before));
1010   }
<span class="line-modified">1011 </span>
<span class="line-added">1012   LoadIndexed* load_indexed = NULL;</span>
<span class="line-added">1013   Instruction* result = NULL;</span>
<span class="line-added">1014   if (array-&gt;is_loaded_flattened_array()) {</span>
<span class="line-added">1015     ciType* array_type = array-&gt;declared_type();</span>
<span class="line-added">1016     ciValueKlass* elem_klass = array_type-&gt;as_value_array_klass()-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">1017     NewValueTypeInstance* new_instance = new NewValueTypeInstance(elem_klass, state_before, false);</span>
<span class="line-added">1018     _memory-&gt;new_instance(new_instance);</span>
<span class="line-added">1019     apush(append_split(new_instance));</span>
<span class="line-added">1020     load_indexed = new LoadIndexed(array, index, length, type, state_before);</span>
<span class="line-added">1021     load_indexed-&gt;set_vt(new_instance);</span>
<span class="line-added">1022   } else {</span>
<span class="line-added">1023     load_indexed = new LoadIndexed(array, index, length, type, state_before);</span>
<span class="line-added">1024   }</span>
<span class="line-added">1025   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {</span>
<span class="line-added">1026     compilation()-&gt;set_would_profile(true);</span>
<span class="line-added">1027     load_indexed-&gt;set_should_profile(true);</span>
<span class="line-added">1028     load_indexed-&gt;set_profiled_method(method());</span>
<span class="line-added">1029     load_indexed-&gt;set_profiled_bci(bci());</span>
<span class="line-added">1030   }</span>
<span class="line-added">1031   result = append(load_indexed);</span>
<span class="line-added">1032   assert(!(profile_array_accesses() &amp;&amp; is_reference_type(type)) || load_indexed == result, &quot;should not be optimized out&quot;);</span>
<span class="line-added">1033   if (!array-&gt;is_loaded_flattened_array()) {</span>
<span class="line-added">1034     push(as_ValueType(type), result);</span>
<span class="line-added">1035   }</span>
1036 }
1037 
1038 
1039 void GraphBuilder::store_indexed(BasicType type) {
1040   // In case of in block code motion in range check elimination
<span class="line-modified">1041   ValueStack* state_before = NULL;</span>
<span class="line-added">1042   int array_idx = state()-&gt;stack_size() - 3;</span>
<span class="line-added">1043   if (type == T_OBJECT &amp;&amp; state()-&gt;stack_at(array_idx)-&gt;maybe_flattened_array()) {</span>
<span class="line-added">1044     // Save the entire state and re-execute on deopt when accessing flattened arrays</span>
<span class="line-added">1045     state_before = copy_state_before();</span>
<span class="line-added">1046     state_before-&gt;set_should_reexecute(true);</span>
<span class="line-added">1047   } else {</span>
<span class="line-added">1048     state_before = copy_state_indexed_access();</span>
<span class="line-added">1049   }</span>
1050   compilation()-&gt;set_has_access_indexed(true);
1051   Value value = pop(as_ValueType(type));
1052   Value index = ipop();
1053   Value array = apop();
1054   Value length = NULL;
<span class="line-added">1055   value-&gt;set_escaped();</span>
1056   if (CSEArrayLength ||
1057       (array-&gt;as_AccessField() &amp;&amp; array-&gt;as_AccessField()-&gt;field()-&gt;is_constant()) ||
1058       (array-&gt;as_NewArray() &amp;&amp; array-&gt;as_NewArray()-&gt;length() &amp;&amp; array-&gt;as_NewArray()-&gt;length()-&gt;type()-&gt;is_constant())) {
1059     length = append(new ArrayLength(array, state_before));
1060   }
1061   ciType* array_type = array-&gt;declared_type();
1062   bool check_boolean = false;
1063   if (array_type != NULL) {
1064     if (array_type-&gt;is_loaded() &amp;&amp;
1065       array_type-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() == T_BOOLEAN) {
1066       assert(type == T_BYTE, &quot;boolean store uses bastore&quot;);
1067       Value mask = append(new Constant(new IntConstant(1)));
1068       value = append(new LogicOp(Bytecodes::_iand, value, mask));
1069     }
1070   } else if (type == T_BYTE) {
1071     check_boolean = true;
1072   }
<span class="line-modified">1073 </span>
<span class="line-modified">1074   StoreIndexed* store_indexed = new StoreIndexed(array, index, length, type, value, state_before, check_boolean);</span>



1075   if (profile_array_accesses() &amp;&amp; is_reference_type(type)) {
1076     compilation()-&gt;set_would_profile(true);
<span class="line-modified">1077     store_indexed-&gt;set_should_profile(true);</span>
<span class="line-modified">1078     store_indexed-&gt;set_profiled_method(method());</span>
<span class="line-modified">1079     store_indexed-&gt;set_profiled_bci(bci());</span>



1080   }
<span class="line-added">1081   Instruction* result = append(store_indexed);</span>
<span class="line-added">1082   assert(!store_indexed-&gt;should_profile() || store_indexed == result, &quot;should not be optimized out&quot;);</span>
<span class="line-added">1083   _memory-&gt;store_value(value);</span>
<span class="line-added">1084 </span>
1085 }
1086 
1087 
1088 void GraphBuilder::stack_op(Bytecodes::Code code) {
1089   switch (code) {
1090     case Bytecodes::_pop:
1091       { state()-&gt;raw_pop();
1092       }
1093       break;
1094     case Bytecodes::_pop2:
1095       { state()-&gt;raw_pop();
1096         state()-&gt;raw_pop();
1097       }
1098       break;
1099     case Bytecodes::_dup:
1100       { Value w = state()-&gt;raw_pop();
1101         state()-&gt;raw_push(w);
1102         state()-&gt;raw_push(w);
1103       }
1104       break;
</pre>
<hr />
<pre>
1259 
1260 
1261 void GraphBuilder::_goto(int from_bci, int to_bci) {
1262   Goto *x = new Goto(block_at(to_bci), to_bci &lt;= from_bci);
1263   if (is_profiling()) {
1264     compilation()-&gt;set_would_profile(true);
1265     x-&gt;set_profiled_bci(bci());
1266     if (profile_branches()) {
1267       x-&gt;set_profiled_method(method());
1268       x-&gt;set_should_profile(true);
1269     }
1270   }
1271   append(x);
1272 }
1273 
1274 
1275 void GraphBuilder::if_node(Value x, If::Condition cond, Value y, ValueStack* state_before) {
1276   BlockBegin* tsux = block_at(stream()-&gt;get_dest());
1277   BlockBegin* fsux = block_at(stream()-&gt;next_bci());
1278   bool is_bb = tsux-&gt;bci() &lt; stream()-&gt;cur_bci() || fsux-&gt;bci() &lt; stream()-&gt;cur_bci();
<span class="line-added">1279 </span>
<span class="line-added">1280   bool subst_check = false;</span>
<span class="line-added">1281   if (EnableValhalla &amp;&amp; (stream()-&gt;cur_bc() == Bytecodes::_if_acmpeq || stream()-&gt;cur_bc() == Bytecodes::_if_acmpne) &amp;&amp;</span>
<span class="line-added">1282       method() != ciEnv::current()-&gt;ValueBootstrapMethods_klass()-&gt;find_method(ciSymbol::isSubstitutable_name(), ciSymbol::object_object_boolean_signature())) {</span>
<span class="line-added">1283     // If current method is ValueBootstrapMethods::isSubstitutable(),</span>
<span class="line-added">1284     // compile the acmp as a regular pointer comparison otherwise we</span>
<span class="line-added">1285     // could call ValueBootstrapMethods::isSubstitutable() back</span>
<span class="line-added">1286     ValueType* left_vt = x-&gt;type();</span>
<span class="line-added">1287     ValueType* right_vt = y-&gt;type();</span>
<span class="line-added">1288     if (left_vt-&gt;is_object()) {</span>
<span class="line-added">1289       assert(right_vt-&gt;is_object(), &quot;must be&quot;);</span>
<span class="line-added">1290       ciKlass* left_klass = x-&gt;as_loaded_klass_or_null();</span>
<span class="line-added">1291       ciKlass* right_klass = y-&gt;as_loaded_klass_or_null();</span>
<span class="line-added">1292 </span>
<span class="line-added">1293       if (left_klass == NULL || right_klass == NULL) {</span>
<span class="line-added">1294         // The klass is still unloaded, or came from a Phi node. Go slow case;</span>
<span class="line-added">1295         subst_check = true;</span>
<span class="line-added">1296       } else if (left_klass-&gt;can_be_value_klass() || right_klass-&gt;can_be_value_klass()) {</span>
<span class="line-added">1297         // Either operand may be a value object, but we&#39;re not sure. Go slow case;</span>
<span class="line-added">1298         subst_check = true;</span>
<span class="line-added">1299       } else {</span>
<span class="line-added">1300         // No need to do substitutability check</span>
<span class="line-added">1301       }</span>
<span class="line-added">1302     }</span>
<span class="line-added">1303   }</span>
<span class="line-added">1304 </span>
1305   // In case of loop invariant code motion or predicate insertion
1306   // before the body of a loop the state is needed
<span class="line-modified">1307   Instruction *i = append(new If(x, cond, false, y, tsux, fsux, (is_bb || compilation()-&gt;is_optimistic() || subst_check) ? state_before : NULL, is_bb, subst_check));</span>
1308 
1309   assert(i-&gt;as_Goto() == NULL ||
1310          (i-&gt;as_Goto()-&gt;sux_at(0) == tsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == tsux-&gt;bci() &lt; stream()-&gt;cur_bci()) ||
1311          (i-&gt;as_Goto()-&gt;sux_at(0) == fsux  &amp;&amp; i-&gt;as_Goto()-&gt;is_safepoint() == fsux-&gt;bci() &lt; stream()-&gt;cur_bci()),
1312          &quot;safepoint state of Goto returned by canonicalizer incorrect&quot;);
1313 
1314   if (is_profiling()) {
1315     If* if_node = i-&gt;as_If();
1316     if (if_node != NULL) {
1317       // Note that we&#39;d collect profile data in this method if we wanted it.
1318       compilation()-&gt;set_would_profile(true);
1319       // At level 2 we need the proper bci to count backedges
1320       if_node-&gt;set_profiled_bci(bci());
1321       if (profile_branches()) {
1322         // Successors can be rotated by the canonicalizer, check for this case.
1323         if_node-&gt;set_profiled_method(method());
1324         if_node-&gt;set_should_profile(true);
1325         if (if_node-&gt;tsux() == fsux) {
1326           if_node-&gt;set_swapped(true);
1327         }
</pre>
<hr />
<pre>
1538 
1539   if (needs_check) {
1540     // Perform the registration of finalizable objects.
1541     ValueStack* state_before = copy_state_for_exception();
1542     load_local(objectType, 0);
1543     append_split(new Intrinsic(voidType, vmIntrinsics::_Object_init,
1544                                state()-&gt;pop_arguments(1),
1545                                true, state_before, true));
1546   }
1547 }
1548 
1549 
1550 void GraphBuilder::method_return(Value x, bool ignore_return) {
1551   if (RegisterFinalizersAtInit &amp;&amp;
1552       method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
1553     call_register_finalizer();
1554   }
1555 
1556   // The conditions for a memory barrier are described in Parse::do_exits().
1557   bool need_mem_bar = false;
<span class="line-modified">1558   if (method()-&gt;is_object_constructor() &amp;&amp;</span>
1559        (scope()-&gt;wrote_final() ||
1560          (AlwaysSafeConstructors &amp;&amp; scope()-&gt;wrote_fields()) ||
1561          (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; scope()-&gt;wrote_volatile()))) {
1562     need_mem_bar = true;
1563   }
1564 
1565   BasicType bt = method()-&gt;return_type()-&gt;basic_type();
1566   switch (bt) {
1567     case T_BYTE:
1568     {
1569       Value shift = append(new Constant(new IntConstant(24)));
1570       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1571       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
1572       break;
1573     }
1574     case T_SHORT:
1575     {
1576       Value shift = append(new Constant(new IntConstant(16)));
1577       x = append(new ShiftOp(Bytecodes::_ishl, x, shift));
1578       x = append(new ShiftOp(Bytecodes::_ishr, x, shift));
</pre>
<hr />
<pre>
1689   // Attach dimension info to stable arrays.
1690   if (FoldStableValues &amp;&amp;
1691       field-&gt;is_stable() &amp;&amp; field_type == T_ARRAY &amp;&amp; !field_value.is_null_or_zero()) {
1692     ciArray* array = field_value.as_object()-&gt;as_array();
1693     jint dimension = field-&gt;type()-&gt;as_array_klass()-&gt;dimension();
1694     value = new StableArrayConstant(array, dimension);
1695   }
1696 
1697   switch (field_type) {
1698     case T_ARRAY:
1699     case T_OBJECT:
1700       if (field_value.as_object()-&gt;should_be_constant()) {
1701         return new Constant(value);
1702       }
1703       return NULL; // Not a constant.
1704     default:
1705       return new Constant(value);
1706   }
1707 }
1708 
<span class="line-added">1709 void GraphBuilder::copy_value_content(ciValueKlass* vk, Value src, int src_off, Value dest, int dest_off,</span>
<span class="line-added">1710     ValueStack* state_before, bool needs_patching) {</span>
<span class="line-added">1711   src-&gt;set_escaped();</span>
<span class="line-added">1712   for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); i++) {</span>
<span class="line-added">1713     ciField* inner_field = vk-&gt;nonstatic_field_at(i);</span>
<span class="line-added">1714     assert(!inner_field-&gt;is_flattened(), &quot;the iteration over nested fields is handled by the loop itself&quot;);</span>
<span class="line-added">1715     int off = inner_field-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">1716     LoadField* load = new LoadField(src, src_off + off, inner_field, false, state_before, needs_patching);</span>
<span class="line-added">1717     Value replacement = append(load);</span>
<span class="line-added">1718     StoreField* store = new StoreField(dest, dest_off + off, inner_field, replacement, false, state_before, needs_patching);</span>
<span class="line-added">1719     append(store);</span>
<span class="line-added">1720   }</span>
<span class="line-added">1721 }</span>
<span class="line-added">1722 </span>
1723 void GraphBuilder::access_field(Bytecodes::Code code) {
1724   bool will_link;
1725   ciField* field = stream()-&gt;get_field(will_link);
1726   ciInstanceKlass* holder = field-&gt;holder();
1727   BasicType field_type = field-&gt;type()-&gt;basic_type();
1728   ValueType* type = as_ValueType(field_type);
<span class="line-added">1729 </span>
1730   // call will_link again to determine if the field is valid.
1731   const bool needs_patching = !holder-&gt;is_loaded() ||
1732                               !field-&gt;will_link(method(), code) ||
1733                               PatchALot;
1734 
1735   ValueStack* state_before = NULL;
1736   if (!holder-&gt;is_initialized() || needs_patching) {
1737     // save state before instruction for debug info when
1738     // deoptimization happens during patching
1739     state_before = copy_state_before();
1740   }
1741 
1742   Value obj = NULL;
1743   if (code == Bytecodes::_getstatic || code == Bytecodes::_putstatic) {
1744     if (state_before != NULL) {
1745       // build a patching constant
1746       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()), state_before);
1747     } else {
1748       obj = new Constant(new InstanceConstant(holder-&gt;java_mirror()));
1749     }
1750   }
1751 
<span class="line-modified">1752   if (field-&gt;is_final() &amp;&amp; (code == Bytecodes::_putfield || code == Bytecodes::_withfield)) {</span>
1753     scope()-&gt;set_wrote_final();
1754   }
1755 
<span class="line-modified">1756   if (code == Bytecodes::_putfield || code == Bytecodes::_withfield) {</span>
1757     scope()-&gt;set_wrote_fields();
1758     if (field-&gt;is_volatile()) {
1759       scope()-&gt;set_wrote_volatile();
1760     }
1761   }
1762 
1763   const int offset = !needs_patching ? field-&gt;offset() : -1;
1764   switch (code) {
1765     case Bytecodes::_getstatic: {
1766       // check for compile-time constants, i.e., initialized static final fields
1767       Value constant = NULL;
1768       if (field-&gt;is_static_constant() &amp;&amp; !PatchALot) {
1769         ciConstant field_value = field-&gt;constant_value();
1770         assert(!field-&gt;is_stable() || !field_value.is_null_or_zero(),
1771                &quot;stable static w/ default value shouldn&#39;t be a constant&quot;);
1772         constant = make_constant(field_value, field);
1773       }
1774       if (constant != NULL) {
1775         push(type, append(constant));
1776       } else {
1777         if (state_before == NULL) {
1778           state_before = copy_state_for_exception();
1779         }
<span class="line-modified">1780         LoadField* load_field = new LoadField(append(obj), offset, field, true,</span>
<span class="line-modified">1781                                         state_before, needs_patching);</span>
<span class="line-added">1782         if (field-&gt;is_flattenable()) {</span>
<span class="line-added">1783           load_field-&gt;set_never_null(true);</span>
<span class="line-added">1784         }</span>
<span class="line-added">1785         push(type, append(load_field));</span>
1786       }
1787       break;
1788     }
1789     case Bytecodes::_putstatic: {
1790       Value val = pop(type);
<span class="line-added">1791       val-&gt;set_escaped();</span>
1792       if (state_before == NULL) {
1793         state_before = copy_state_for_exception();
1794       }
1795       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1796         Value mask = append(new Constant(new IntConstant(1)));
1797         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1798       }
1799       append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1800       break;
1801     }
1802     case Bytecodes::_getfield: {
1803       // Check for compile-time constants, i.e., trusted final non-static fields.
1804       Value constant = NULL;
<span class="line-added">1805       if (state_before == NULL &amp;&amp; field-&gt;is_flattened()) {</span>
<span class="line-added">1806         // Save the entire state and re-execute on deopt when accessing flattened fields</span>
<span class="line-added">1807         assert(Interpreter::bytecode_should_reexecute(code), &quot;should reexecute&quot;);</span>
<span class="line-added">1808         state_before = copy_state_before();</span>
<span class="line-added">1809       }</span>
1810       obj = apop();
1811       ObjectType* obj_type = obj-&gt;type()-&gt;as_ObjectType();
<span class="line-modified">1812       if (field-&gt;is_constant() &amp;&amp; !field-&gt;is_flattened() &amp;&amp; obj_type-&gt;is_constant() &amp;&amp; !PatchALot) {</span>
1813         ciObject* const_oop = obj_type-&gt;constant_value();
1814         if (!const_oop-&gt;is_null_object() &amp;&amp; const_oop-&gt;is_loaded()) {
1815           ciConstant field_value = field-&gt;constant_value_of(const_oop);
1816           if (field_value.is_valid()) {
1817             constant = make_constant(field_value, field);
1818             // For CallSite objects add a dependency for invalidation of the optimization.
1819             if (field-&gt;is_call_site_target()) {
1820               ciCallSite* call_site = const_oop-&gt;as_call_site();
1821               if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
1822                 ciMethodHandle* target = field_value.as_object()-&gt;as_method_handle();
1823                 dependency_recorder()-&gt;assert_call_site_target_value(call_site, target);
1824               }
1825             }
1826           }
1827         }
1828       }
1829       if (constant != NULL) {
1830         push(type, append(constant));
1831       } else {
1832         if (state_before == NULL) {
1833           state_before = copy_state_for_exception();
1834         }
<span class="line-modified">1835         if (!field-&gt;is_flattened()) {</span>
<span class="line-modified">1836           LoadField* load = new LoadField(obj, offset, field, false, state_before, needs_patching);</span>
<span class="line-modified">1837           Value replacement = !needs_patching ? _memory-&gt;load(load) : load;</span>
<span class="line-modified">1838           if (replacement != load) {</span>
<span class="line-modified">1839             assert(replacement-&gt;is_linked() || !replacement-&gt;can_be_linked(), &quot;should already by linked&quot;);</span>
<span class="line-modified">1840             // Writing an (integer) value to a boolean, byte, char or short field includes an implicit narrowing</span>
<span class="line-modified">1841             // conversion. Emit an explicit conversion here to get the correct field value after the write.</span>
<span class="line-modified">1842             BasicType bt = field-&gt;type()-&gt;basic_type();</span>
<span class="line-modified">1843             switch (bt) {</span>
<span class="line-modified">1844             case T_BOOLEAN:</span>
<span class="line-modified">1845             case T_BYTE:</span>
<span class="line-modified">1846               replacement = append(new Convert(Bytecodes::_i2b, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1847               break;</span>
<span class="line-modified">1848             case T_CHAR:</span>
<span class="line-modified">1849               replacement = append(new Convert(Bytecodes::_i2c, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1850               break;</span>
<span class="line-modified">1851             case T_SHORT:</span>
<span class="line-modified">1852               replacement = append(new Convert(Bytecodes::_i2s, replacement, as_ValueType(bt)));</span>
<span class="line-modified">1853               break;</span>
<span class="line-modified">1854             default:</span>
<span class="line-added">1855               break;</span>
<span class="line-added">1856             }</span>
<span class="line-added">1857             push(type, replacement);</span>
<span class="line-added">1858           } else {</span>
<span class="line-added">1859             push(type, append(load));</span>
1860           }
<span class="line-modified">1861         } else { // flattened field, not optimized solution: re-instantiate the flattened value</span>
<span class="line-modified">1862           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-modified">1863           ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-added">1864           int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-added">1865           assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-added">1866           scope()-&gt;set_wrote_final();</span>
<span class="line-added">1867           scope()-&gt;set_wrote_fields();</span>
<span class="line-added">1868           NewValueTypeInstance* new_instance = new NewValueTypeInstance(value_klass, state_before, false);</span>
<span class="line-added">1869           _memory-&gt;new_instance(new_instance);</span>
<span class="line-added">1870           apush(append_split(new_instance));</span>
<span class="line-added">1871           copy_value_content(value_klass, obj, field-&gt;offset(), new_instance, value_klass-&gt;first_field_offset(),</span>
<span class="line-added">1872                        state_before, needs_patching);</span>
1873         }
1874       }
1875       break;
1876     }
<span class="line-added">1877     case Bytecodes::_withfield:</span>
1878     case Bytecodes::_putfield: {
1879       Value val = pop(type);
<span class="line-added">1880       val-&gt;set_escaped();</span>
1881       obj = apop();
1882       if (state_before == NULL) {
1883         state_before = copy_state_for_exception();
1884       }
1885       if (field-&gt;type()-&gt;basic_type() == T_BOOLEAN) {
1886         Value mask = append(new Constant(new IntConstant(1)));
1887         val = append(new LogicOp(Bytecodes::_iand, val, mask));
1888       }
<span class="line-modified">1889 </span>
<span class="line-modified">1890       if (!field-&gt;is_flattened()) {</span>
<span class="line-modified">1891         StoreField* store = new StoreField(obj, offset, field, val, false, state_before, needs_patching);</span>
<span class="line-modified">1892         if (!needs_patching) store = _memory-&gt;store(store);</span>
<span class="line-added">1893         if (store != NULL) {</span>
<span class="line-added">1894           append(store);</span>
<span class="line-added">1895         }</span>
<span class="line-added">1896       } else {</span>
<span class="line-added">1897         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-added">1898         ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-added">1899         int flattening_offset = field-&gt;offset() - value_klass-&gt;first_field_offset();</span>
<span class="line-added">1900         copy_value_content(value_klass, val, value_klass-&gt;first_field_offset(), obj, field-&gt;offset(),</span>
<span class="line-added">1901                    state_before, needs_patching);</span>
1902       }
1903       break;
1904     }
1905     default:
1906       ShouldNotReachHere();
1907       break;
1908   }
1909 }
1910 
<span class="line-added">1911 // Baseline version of withfield, allocate every time</span>
<span class="line-added">1912 void GraphBuilder::withfield(int field_index)</span>
<span class="line-added">1913 {</span>
<span class="line-added">1914   bool will_link;</span>
<span class="line-added">1915   ciField* field_modify = stream()-&gt;get_field(will_link);</span>
<span class="line-added">1916   ciInstanceKlass* holder = field_modify-&gt;holder();</span>
<span class="line-added">1917   BasicType field_type = field_modify-&gt;type()-&gt;basic_type();</span>
<span class="line-added">1918   ValueType* type = as_ValueType(field_type);</span>
<span class="line-added">1919 </span>
<span class="line-added">1920   // call will_link again to determine if the field is valid.</span>
<span class="line-added">1921   const bool needs_patching = !holder-&gt;is_loaded() ||</span>
<span class="line-added">1922                               !field_modify-&gt;will_link(method(), Bytecodes::_withfield) ||</span>
<span class="line-added">1923                               PatchALot;</span>
<span class="line-added">1924 </span>
<span class="line-added">1925 </span>
<span class="line-added">1926   scope()-&gt;set_wrote_final();</span>
<span class="line-added">1927   scope()-&gt;set_wrote_fields();</span>
<span class="line-added">1928 </span>
<span class="line-added">1929   const int offset = !needs_patching ? field_modify-&gt;offset() : -1;</span>
<span class="line-added">1930 </span>
<span class="line-added">1931   if (!holder-&gt;is_loaded()</span>
<span class="line-added">1932       || needs_patching /* FIXME: 8228634 - field_modify-&gt;will_link() may incorrectly return false */</span>
<span class="line-added">1933       ) {</span>
<span class="line-added">1934     ValueStack* state_before = copy_state_before();</span>
<span class="line-added">1935     Value val = pop(type);</span>
<span class="line-added">1936     Value obj = apop();</span>
<span class="line-added">1937     apush(append_split(new WithField(state_before)));</span>
<span class="line-added">1938     return;</span>
<span class="line-added">1939   }</span>
<span class="line-added">1940   ValueStack* state_before = copy_state_before();</span>
<span class="line-added">1941 </span>
<span class="line-added">1942   Value val = pop(type);</span>
<span class="line-added">1943   Value obj = apop();</span>
<span class="line-added">1944 </span>
<span class="line-added">1945   if (!needs_patching &amp;&amp; obj-&gt;is_optimizable_for_withfield()) {</span>
<span class="line-added">1946     int astore_index;</span>
<span class="line-added">1947     ciBytecodeStream s(method());</span>
<span class="line-added">1948     s.force_bci(bci());</span>
<span class="line-added">1949     s.next();</span>
<span class="line-added">1950     switch (s.cur_bc()) {</span>
<span class="line-added">1951     case Bytecodes::_astore:    astore_index = s.get_index(); break;</span>
<span class="line-added">1952     case Bytecodes::_astore_0:  astore_index = 0; break;</span>
<span class="line-added">1953     case Bytecodes::_astore_1:  astore_index = 1; break;</span>
<span class="line-added">1954     case Bytecodes::_astore_2:  astore_index = 2; break;</span>
<span class="line-added">1955     case Bytecodes::_astore_3:  astore_index = 3; break;</span>
<span class="line-added">1956     default: astore_index = -1;</span>
<span class="line-added">1957     }</span>
<span class="line-added">1958 </span>
<span class="line-added">1959     if (astore_index &gt;= 0 &amp;&amp; obj == state()-&gt;local_at(astore_index)) {</span>
<span class="line-added">1960       // We have a sequence like this, where we load a value object from a local slot,</span>
<span class="line-added">1961       // and overwrite the same local slot with a modified copy of the value object.</span>
<span class="line-added">1962       //      defaultvalue #1 // class compiler/valhalla/valuetypes/MyValue1</span>
<span class="line-added">1963       //      astore 9</span>
<span class="line-added">1964       //      ...</span>
<span class="line-added">1965       //      iload_0</span>
<span class="line-added">1966       //      aload 9</span>
<span class="line-added">1967       //      swap</span>
<span class="line-added">1968       //      withfield #7 // Field x:I</span>
<span class="line-added">1969       //      astore 9</span>
<span class="line-added">1970       // If this object was created by defaultvalue, and has not escaped, and is not stored</span>
<span class="line-added">1971       // in any other local slots, we can effectively treat the withfield/astore</span>
<span class="line-added">1972       // sequence as a single putfield bytecode.</span>
<span class="line-added">1973       push(objectType, obj);</span>
<span class="line-added">1974       push(type, val);</span>
<span class="line-added">1975       access_field(Bytecodes::_withfield);</span>
<span class="line-added">1976       stream()-&gt;next(); // skip the next astore/astore_n bytecode.</span>
<span class="line-added">1977       return;</span>
<span class="line-added">1978     }</span>
<span class="line-added">1979   }</span>
<span class="line-added">1980 </span>
<span class="line-added">1981   assert(holder-&gt;is_valuetype(), &quot;must be a value klass&quot;);</span>
<span class="line-added">1982   // Save the entire state and re-execute on deopt when executing withfield</span>
<span class="line-added">1983   state_before-&gt;set_should_reexecute(true);</span>
<span class="line-added">1984   NewValueTypeInstance* new_instance = new NewValueTypeInstance(holder-&gt;as_value_klass(), state_before, false);</span>
<span class="line-added">1985   _memory-&gt;new_instance(new_instance);</span>
<span class="line-added">1986   apush(append_split(new_instance));</span>
<span class="line-added">1987 </span>
<span class="line-added">1988   for (int i = 0; i &lt; holder-&gt;nof_nonstatic_fields(); i++) {</span>
<span class="line-added">1989     ciField* field = holder-&gt;nonstatic_field_at(i);</span>
<span class="line-added">1990     int off = field-&gt;offset();</span>
<span class="line-added">1991 </span>
<span class="line-added">1992     if (field-&gt;offset() != offset) {</span>
<span class="line-added">1993       if (field-&gt;is_flattened()) {</span>
<span class="line-added">1994         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Sanity check&quot;);</span>
<span class="line-added">1995         assert(field-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-added">1996         ciValueKlass* vk = field-&gt;type()-&gt;as_value_klass();</span>
<span class="line-added">1997         copy_value_content(vk, obj, off, new_instance, vk-&gt;first_field_offset(), state_before, needs_patching);</span>
<span class="line-added">1998       } else {</span>
<span class="line-added">1999         // Only load those fields who are not modified</span>
<span class="line-added">2000         LoadField* load = new LoadField(obj, off, field, false, state_before, needs_patching);</span>
<span class="line-added">2001         Value replacement = append(load);</span>
<span class="line-added">2002         StoreField* store = new StoreField(new_instance, off, field, replacement, false, state_before, needs_patching);</span>
<span class="line-added">2003         append(store);</span>
<span class="line-added">2004       }</span>
<span class="line-added">2005     }</span>
<span class="line-added">2006   }</span>
<span class="line-added">2007 </span>
<span class="line-added">2008   // Field to modify</span>
<span class="line-added">2009   if (field_modify-&gt;type()-&gt;basic_type() == T_BOOLEAN) {</span>
<span class="line-added">2010     Value mask = append(new Constant(new IntConstant(1)));</span>
<span class="line-added">2011     val = append(new LogicOp(Bytecodes::_iand, val, mask));</span>
<span class="line-added">2012   }</span>
<span class="line-added">2013   if (field_modify-&gt;is_flattened()) {</span>
<span class="line-added">2014     assert(field_modify-&gt;type()-&gt;is_valuetype(), &quot;Only value types can be flattened&quot;);</span>
<span class="line-added">2015     ciValueKlass* vk = field_modify-&gt;type()-&gt;as_value_klass();</span>
<span class="line-added">2016     copy_value_content(vk, val, vk-&gt;first_field_offset(), new_instance, field_modify-&gt;offset(), state_before, needs_patching);</span>
<span class="line-added">2017   } else {</span>
<span class="line-added">2018     StoreField* store = new StoreField(new_instance, offset, field_modify, val, false, state_before, needs_patching);</span>
<span class="line-added">2019     append(store);</span>
<span class="line-added">2020   }</span>
<span class="line-added">2021 }</span>
2022 
2023 Dependencies* GraphBuilder::dependency_recorder() const {
2024   assert(DeoptC1, &quot;need debug information&quot;);
2025   return compilation()-&gt;dependency_recorder();
2026 }
2027 
2028 // How many arguments do we want to profile?
2029 Values* GraphBuilder::args_list_for_profiling(ciMethod* target, int&amp; start, bool may_have_receiver) {
2030   int n = 0;
2031   bool has_receiver = may_have_receiver &amp;&amp; Bytecodes::has_receiver(method()-&gt;java_code_at_bci(bci()));
2032   start = has_receiver ? 1 : 0;
2033   if (profile_arguments()) {
2034     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2035     if (data != NULL &amp;&amp; (data-&gt;is_CallTypeData() || data-&gt;is_VirtualCallTypeData())) {
2036       n = data-&gt;is_CallTypeData() ? data-&gt;as_CallTypeData()-&gt;number_of_arguments() : data-&gt;as_VirtualCallTypeData()-&gt;number_of_arguments();
2037     }
2038   }
2039   // If we are inlining then we need to collect arguments to profile parameters for the target
2040   if (profile_parameters() &amp;&amp; target != NULL) {
2041     if (target-&gt;method_data() != NULL &amp;&amp; target-&gt;method_data()-&gt;parameters_type_data() != NULL) {
</pre>
<hr />
<pre>
2087   ciKlass*              holder = stream()-&gt;get_declared_method_holder();
2088   const Bytecodes::Code bc_raw = stream()-&gt;cur_bc_raw();
2089   assert(declared_signature != NULL, &quot;cannot be null&quot;);
2090   assert(will_link == target-&gt;is_loaded(), &quot;&quot;);
2091 
2092   ciInstanceKlass* klass = target-&gt;holder();
2093   assert(!target-&gt;is_loaded() || klass-&gt;is_loaded(), &quot;loaded target must imply loaded klass&quot;);
2094 
2095   // check if CHA possible: if so, change the code to invoke_special
2096   ciInstanceKlass* calling_klass = method()-&gt;holder();
2097   ciInstanceKlass* callee_holder = ciEnv::get_instance_klass_for_declared_method_holder(holder);
2098   ciInstanceKlass* actual_recv = callee_holder;
2099 
2100   CompileLog* log = compilation()-&gt;log();
2101   if (log != NULL)
2102       log-&gt;elem(&quot;call method=&#39;%d&#39; instr=&#39;%s&#39;&quot;,
2103                 log-&gt;identify(target),
2104                 Bytecodes::name(code));
2105 
2106   // invoke-special-super
<span class="line-modified">2107   if (bc_raw == Bytecodes::_invokespecial &amp;&amp; !target-&gt;is_object_constructor()) {</span>
2108     ciInstanceKlass* sender_klass =
2109           calling_klass-&gt;is_unsafe_anonymous() ? calling_klass-&gt;unsafe_anonymous_host() :
2110                                                  calling_klass;
2111     if (sender_klass-&gt;is_interface()) {
2112       int index = state()-&gt;stack_size() - (target-&gt;arg_size_no_receiver() + 1);
2113       Value receiver = state()-&gt;stack_at(index);
2114       CheckCast* c = new CheckCast(sender_klass, receiver, copy_state_before());
2115       c-&gt;set_invokespecial_receiver_check();
2116       state()-&gt;stack_at_put(index, append_split(c));
2117     }
2118   }
2119 
2120   // Some methods are obviously bindable without any type checks so
2121   // convert them directly to an invokespecial or invokestatic.
2122   if (target-&gt;is_loaded() &amp;&amp; !target-&gt;is_abstract() &amp;&amp; target-&gt;can_be_statically_bound()) {
2123     switch (bc_raw) {
2124     case Bytecodes::_invokevirtual:
2125       code = Bytecodes::_invokespecial;
2126       break;
2127     case Bytecodes::_invokehandle:
</pre>
<hr />
<pre>
2342       null_check(recv);
2343     }
2344 
2345     if (is_profiling()) {
2346       // Note that we&#39;d collect profile data in this method if we wanted it.
2347       compilation()-&gt;set_would_profile(true);
2348 
2349       if (profile_calls()) {
2350         assert(cha_monomorphic_target == NULL || exact_target == NULL, &quot;both can not be set&quot;);
2351         ciKlass* target_klass = NULL;
2352         if (cha_monomorphic_target != NULL) {
2353           target_klass = cha_monomorphic_target-&gt;holder();
2354         } else if (exact_target != NULL) {
2355           target_klass = exact_target-&gt;holder();
2356         }
2357         profile_call(target, recv, target_klass, collect_args_for_profiling(args, NULL, false), false);
2358       }
2359     }
2360   }
2361 
<span class="line-modified">2362   if (recv != NULL) {</span>
<span class="line-added">2363     recv-&gt;set_escaped();</span>
<span class="line-added">2364   }</span>
<span class="line-added">2365   for (int i=0; i&lt;args-&gt;length(); i++) {</span>
<span class="line-added">2366     args-&gt;at(0)-&gt;set_escaped();</span>
<span class="line-added">2367   }</span>
<span class="line-added">2368 </span>
<span class="line-added">2369   Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,</span>
<span class="line-added">2370                               declared_signature-&gt;returns_never_null());</span>
2371   // push result
2372   append_split(result);
2373 
2374   if (result_type != voidType) {
2375     if (method()-&gt;is_strict()) {
2376       push(result_type, round_fp(result));
2377     } else {
2378       push(result_type, result);
2379     }
2380   }
2381   if (profile_return() &amp;&amp; result_type-&gt;is_object_kind()) {
2382     profile_return_type(result, target);
2383   }
2384 }
2385 
2386 
2387 void GraphBuilder::new_instance(int klass_index) {
2388   ValueStack* state_before = copy_state_exhandling();
2389   bool will_link;
2390   ciKlass* klass = stream()-&gt;get_klass(will_link);
2391   assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
<span class="line-added">2392   assert(!klass-&gt;is_valuetype(), &quot;must not be a value klass&quot;);</span>
2393   NewInstance* new_instance = new NewInstance(klass-&gt;as_instance_klass(), state_before, stream()-&gt;is_unresolved_klass());
2394   _memory-&gt;new_instance(new_instance);
2395   apush(append_split(new_instance));
2396 }
2397 
<span class="line-added">2398 void GraphBuilder::default_value(int klass_index) {</span>
<span class="line-added">2399   bool will_link;</span>
<span class="line-added">2400   ciValueKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_value_klass();</span>
<span class="line-added">2401   if (!stream()-&gt;is_unresolved_klass()) {</span>
<span class="line-added">2402     apush(append(new Constant(new InstanceConstant(vk-&gt;default_value_instance()))));</span>
<span class="line-added">2403   } else {</span>
<span class="line-added">2404     ValueStack* state_before = copy_state_before();</span>
<span class="line-added">2405     apush(append_split(new DefaultValue(state_before)));</span>
<span class="line-added">2406   }</span>
<span class="line-added">2407 }</span>
2408 
2409 void GraphBuilder::new_type_array() {
2410   ValueStack* state_before = copy_state_exhandling();
2411   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2412 }
2413 
2414 
2415 void GraphBuilder::new_object_array() {
2416   bool will_link;
2417   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-added">2418   bool never_null = stream()-&gt;is_klass_never_null();</span>
2419   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
<span class="line-modified">2420   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);</span>
2421   apush(append_split(n));
2422 }
2423 
2424 
2425 bool GraphBuilder::direct_compare(ciKlass* k) {
2426   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2427     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2428     if (ik-&gt;is_final()) {
2429       return true;
2430     } else {
2431       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2432         // test class is leaf class
2433         dependency_recorder()-&gt;assert_leaf_type(ik);
2434         return true;
2435       }
2436     }
2437   }
2438   return false;
2439 }
2440 
2441 
2442 void GraphBuilder::check_cast(int klass_index) {
2443   bool will_link;
2444   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-added">2445   bool never_null = stream()-&gt;is_klass_never_null();</span>
2446   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
<span class="line-modified">2447   CheckCast* c = new CheckCast(klass, apop(), state_before, never_null);</span>
2448   apush(append_split(c));
2449   c-&gt;set_direct_compare(direct_compare(klass));
2450 
2451   if (is_profiling()) {
2452     // Note that we&#39;d collect profile data in this method if we wanted it.
2453     compilation()-&gt;set_would_profile(true);
2454 
2455     if (profile_checkcasts()) {
2456       c-&gt;set_profiled_method(method());
2457       c-&gt;set_profiled_bci(bci());
2458       c-&gt;set_should_profile(true);
2459     }
2460   }
2461 }
2462 
2463 
2464 void GraphBuilder::instance_of(int klass_index) {
2465   bool will_link;
2466   ciKlass* klass = stream()-&gt;get_klass(will_link);
2467   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2468   InstanceOf* i = new InstanceOf(klass, apop(), state_before);
2469   ipush(append_split(i));
2470   i-&gt;set_direct_compare(direct_compare(klass));
2471 
2472   if (is_profiling()) {
2473     // Note that we&#39;d collect profile data in this method if we wanted it.
2474     compilation()-&gt;set_would_profile(true);
2475 
2476     if (profile_checkcasts()) {
2477       i-&gt;set_profiled_method(method());
2478       i-&gt;set_profiled_bci(bci());
2479       i-&gt;set_should_profile(true);
2480     }
2481   }
2482 }
2483 
2484 
2485 void GraphBuilder::monitorenter(Value x, int bci) {
<span class="line-added">2486   bool maybe_valuetype = false;</span>
<span class="line-added">2487   if (bci == InvocationEntryBci) {</span>
<span class="line-added">2488     // Called by GraphBuilder::inline_sync_entry.</span>
<span class="line-added">2489 #ifdef ASSERT</span>
<span class="line-added">2490     ciType* obj_type = x-&gt;declared_type();</span>
<span class="line-added">2491     assert(obj_type == NULL || !obj_type-&gt;is_valuetype(), &quot;valuetypes cannot have synchronized methods&quot;);</span>
<span class="line-added">2492 #endif</span>
<span class="line-added">2493   } else {</span>
<span class="line-added">2494     // We are compiling a monitorenter bytecode</span>
<span class="line-added">2495     if (EnableValhalla) {</span>
<span class="line-added">2496       ciType* obj_type = x-&gt;declared_type();</span>
<span class="line-added">2497       if (obj_type == NULL || obj_type-&gt;as_klass()-&gt;can_be_value_klass()) {</span>
<span class="line-added">2498         // If we&#39;re (possibly) locking on a valuetype, check for markWord::always_locked_pattern</span>
<span class="line-added">2499         // and throw IMSE. (obj_type is null for Phi nodes, so let&#39;s just be conservative).</span>
<span class="line-added">2500         maybe_valuetype = true;</span>
<span class="line-added">2501       }</span>
<span class="line-added">2502     }</span>
<span class="line-added">2503   }</span>
<span class="line-added">2504 </span>
2505   // save state before locking in case of deoptimization after a NullPointerException
2506   ValueStack* state_before = copy_state_for_exception_with_bci(bci);
<span class="line-modified">2507   append_with_bci(new MonitorEnter(x, state()-&gt;lock(x), state_before, maybe_valuetype), bci);</span>
2508   kill_all();
2509 }
2510 
2511 
2512 void GraphBuilder::monitorexit(Value x, int bci) {
2513   append_with_bci(new MonitorExit(x, state()-&gt;unlock()), bci);
2514   kill_all();
2515 }
2516 
2517 
2518 void GraphBuilder::new_multi_array(int dimensions) {
2519   bool will_link;
2520   ciKlass* klass = stream()-&gt;get_klass(will_link);
2521   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
2522 
2523   Values* dims = new Values(dimensions, dimensions, NULL);
2524   // fill in all dimensions
2525   int i = dimensions;
2526   while (i-- &gt; 0) dims-&gt;at_put(i, ipop());
2527   // create array
</pre>
<hr />
<pre>
3149       case Bytecodes::_invokevirtual  : // fall through
3150       case Bytecodes::_invokespecial  : // fall through
3151       case Bytecodes::_invokestatic   : // fall through
3152       case Bytecodes::_invokedynamic  : // fall through
3153       case Bytecodes::_invokeinterface: invoke(code); break;
3154       case Bytecodes::_new            : new_instance(s.get_index_u2()); break;
3155       case Bytecodes::_newarray       : new_type_array(); break;
3156       case Bytecodes::_anewarray      : new_object_array(); break;
3157       case Bytecodes::_arraylength    : { ValueStack* state_before = copy_state_for_exception(); ipush(append(new ArrayLength(apop(), state_before))); break; }
3158       case Bytecodes::_athrow         : throw_op(s.cur_bci()); break;
3159       case Bytecodes::_checkcast      : check_cast(s.get_index_u2()); break;
3160       case Bytecodes::_instanceof     : instance_of(s.get_index_u2()); break;
3161       case Bytecodes::_monitorenter   : monitorenter(apop(), s.cur_bci()); break;
3162       case Bytecodes::_monitorexit    : monitorexit (apop(), s.cur_bci()); break;
3163       case Bytecodes::_wide           : ShouldNotReachHere(); break;
3164       case Bytecodes::_multianewarray : new_multi_array(s.cur_bcp()[3]); break;
3165       case Bytecodes::_ifnull         : if_null(objectType, If::eql); break;
3166       case Bytecodes::_ifnonnull      : if_null(objectType, If::neq); break;
3167       case Bytecodes::_goto_w         : _goto(s.cur_bci(), s.get_far_dest()); break;
3168       case Bytecodes::_jsr_w          : jsr(s.get_far_dest()); break;
<span class="line-added">3169       case Bytecodes::_defaultvalue   : default_value(s.get_index_u2()); break;</span>
<span class="line-added">3170       case Bytecodes::_withfield      : withfield(s.get_index_u2()); break;</span>
3171       case Bytecodes::_breakpoint     : BAILOUT_(&quot;concurrent setting of breakpoint&quot;, NULL);
3172       default                         : ShouldNotReachHere(); break;
3173     }
3174 
3175     if (log != NULL)
3176       log-&gt;clear_context(); // skip marker if nothing was printed
3177 
3178     // save current bci to setup Goto at the end
3179     prev_bci = s.cur_bci();
3180 
3181   }
3182   CHECK_BAILOUT_(NULL);
3183   // stop processing of this block (see try_inline_full)
3184   if (_skip_block) {
3185     _skip_block = false;
3186     assert(_last &amp;&amp; _last-&gt;as_BlockEnd(), &quot;&quot;);
3187     return _last-&gt;as_BlockEnd();
3188   }
3189   // if there are any, check if last instruction is a BlockEnd instruction
3190   BlockEnd* end = last()-&gt;as_BlockEnd();
</pre>
<hr />
<pre>
3436   // the storage for the OSR buffer is freed manually in the LIRGenerator.
3437 
3438   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3439   state-&gt;clear_locals();
3440   Goto* g = new Goto(target, false);
3441   append(g);
3442   _osr_entry-&gt;set_end(g);
3443   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3444 
3445   scope_data()-&gt;set_stream(NULL);
3446 }
3447 
3448 
3449 ValueStack* GraphBuilder::state_at_entry() {
3450   ValueStack* state = new ValueStack(scope(), NULL);
3451 
3452   // Set up locals for receiver
3453   int idx = 0;
3454   if (!method()-&gt;is_static()) {
3455     // we should always see the receiver
<span class="line-modified">3456     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,</span>
<span class="line-added">3457              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_value_array_klass()));</span>
3458     idx = 1;
3459   }
3460 
3461   // Set up locals for incoming arguments
3462   ciSignature* sig = method()-&gt;signature();
3463   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3464     ciType* type = sig-&gt;type_at(i);
3465     BasicType basic_type = type-&gt;basic_type();
3466     // don&#39;t allow T_ARRAY to propagate into locals types
3467     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3468     ValueType* vt = as_ValueType(basic_type);
<span class="line-modified">3469     state-&gt;store_local(idx, new Local(type, vt, idx, false, sig-&gt;is_never_null_at(i)));</span>
3470     idx += type-&gt;size();
3471   }
3472 
3473   // lock synchronized method
3474   if (method()-&gt;is_synchronized()) {
3475     state-&gt;lock(NULL);
3476   }
3477 
3478   return state;
3479 }
3480 
3481 
3482 GraphBuilder::GraphBuilder(Compilation* compilation, IRScope* scope)
3483   : _scope_data(NULL)
3484   , _compilation(compilation)
3485   , _memory(new MemoryBuffer())
3486   , _inline_bailout_msg(NULL)
3487   , _instruction_count(0)
3488   , _osr_entry(NULL)
3489 {
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_IR.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_LinearScan.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;code/vmreg.inline.hpp&quot;
  35 #include &quot;runtime/timerTrace.hpp&quot;
  36 #include &quot;utilities/bitMap.inline.hpp&quot;
  37 
  38 #ifndef PRODUCT
  39 
  40   static LinearScanStatistic _stat_before_alloc;
  41   static LinearScanStatistic _stat_after_asign;
  42   static LinearScanStatistic _stat_final;
  43 
  44   static LinearScanTimers _total_timer;
  45 
  46   // helper macro for short definition of timer
  47   #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(&quot;&quot;, _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);
  48 
  49   // helper macro for short definition of trace-output inside code
  50   #define TRACE_LINEAR_SCAN(level, code)       \
  51     if (TraceLinearScanLevel &gt;= level) {       \
  52       code;                                    \
  53     }
  54 
  55 #else
  56 
  57   #define TIME_LINEAR_SCAN(timer_name)
  58   #define TRACE_LINEAR_SCAN(level, code)
  59 
  60 #endif
  61 
  62 // Map BasicType to spill size in 32-bit words, matching VMReg&#39;s notion of words
  63 #ifdef _LP64
  64 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};
  65 #else
  66 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};
  67 #endif
  68 
  69 
  70 // Implementation of LinearScan
  71 
  72 LinearScan::LinearScan(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
  93 #ifdef IA32
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
 114 
 115 int LinearScan::reg_num(LIR_Opr opr) {
 116   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 117 
 118   if (opr-&gt;is_virtual_register()) {
 119     assert(opr-&gt;vreg_number() &gt;= nof_regs, &quot;found a virtual register with a fixed-register number&quot;);
 120     return opr-&gt;vreg_number();
 121   } else if (opr-&gt;is_single_cpu()) {
 122     return opr-&gt;cpu_regnr();
 123   } else if (opr-&gt;is_double_cpu()) {
 124     return opr-&gt;cpu_regnrLo();
 125 #ifdef X86
 126   } else if (opr-&gt;is_single_xmm()) {
 127     return opr-&gt;fpu_regnr() + pd_first_xmm_reg;
 128   } else if (opr-&gt;is_double_xmm()) {
 129     return opr-&gt;fpu_regnrLo() + pd_first_xmm_reg;
 130 #endif
 131   } else if (opr-&gt;is_single_fpu()) {
 132     return opr-&gt;fpu_regnr() + pd_first_fpu_reg;
 133   } else if (opr-&gt;is_double_fpu()) {
 134     return opr-&gt;fpu_regnrLo() + pd_first_fpu_reg;
 135   } else {
 136     ShouldNotReachHere();
 137     return -1;
 138   }
 139 }
 140 
 141 int LinearScan::reg_numHi(LIR_Opr opr) {
 142   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 143 
 144   if (opr-&gt;is_virtual_register()) {
 145     return -1;
 146   } else if (opr-&gt;is_single_cpu()) {
 147     return -1;
 148   } else if (opr-&gt;is_double_cpu()) {
 149     return opr-&gt;cpu_regnrHi();
 150 #ifdef X86
 151   } else if (opr-&gt;is_single_xmm()) {
 152     return -1;
 153   } else if (opr-&gt;is_double_xmm()) {
 154     return -1;
 155 #endif
 156   } else if (opr-&gt;is_single_fpu()) {
 157     return -1;
 158   } else if (opr-&gt;is_double_fpu()) {
 159     return opr-&gt;fpu_regnrHi() + pd_first_fpu_reg;
 160   } else {
 161     ShouldNotReachHere();
 162     return -1;
 163   }
 164 }
 165 
 166 
 167 // ********** functions for classification of intervals
 168 
 169 bool LinearScan::is_precolored_interval(const Interval* i) {
 170   return i-&gt;reg_num() &lt; LinearScan::nof_regs;
 171 }
 172 
 173 bool LinearScan::is_virtual_interval(const Interval* i) {
 174   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 175 }
 176 
 177 bool LinearScan::is_precolored_cpu_interval(const Interval* i) {
 178   return i-&gt;reg_num() &lt; LinearScan::nof_cpu_regs;
 179 }
 180 
 181 bool LinearScan::is_virtual_cpu_interval(const Interval* i) {
 182 #if defined(__SOFTFP__) || defined(E500V2)
 183   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 184 #else
 185   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() != T_FLOAT &amp;&amp; i-&gt;type() != T_DOUBLE);
 186 #endif // __SOFTFP__ or E500V2
 187 }
 188 
 189 bool LinearScan::is_precolored_fpu_interval(const Interval* i) {
 190   return i-&gt;reg_num() &gt;= LinearScan::nof_cpu_regs &amp;&amp; i-&gt;reg_num() &lt; LinearScan::nof_regs;
 191 }
 192 
 193 bool LinearScan::is_virtual_fpu_interval(const Interval* i) {
 194 #if defined(__SOFTFP__) || defined(E500V2)
 195   return false;
 196 #else
 197   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() == T_FLOAT || i-&gt;type() == T_DOUBLE);
 198 #endif // __SOFTFP__ or E500V2
 199 }
 200 
 201 bool LinearScan::is_in_fpu_register(const Interval* i) {
 202   // fixed intervals not needed for FPU stack allocation
 203   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; pd_first_fpu_reg &lt;= i-&gt;assigned_reg() &amp;&amp; i-&gt;assigned_reg() &lt;= pd_last_fpu_reg;
 204 }
 205 
 206 bool LinearScan::is_oop_interval(const Interval* i) {
 207   // fixed intervals never contain oops
 208   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; i-&gt;type() == T_OBJECT;
 209 }
 210 
 211 
 212 // ********** General helper functions
 213 
 214 // compute next unused stack index that can be used for spilling
 215 int LinearScan::allocate_spill_slot(bool double_word) {
 216   int spill_slot;
 217   if (double_word) {
 218     if ((_max_spills &amp; 1) == 1) {
 219       // alignment of double-word values
 220       // the hole because of the alignment is filled with the next single-word value
 221       assert(_unused_spill_slot == -1, &quot;wasting a spill slot&quot;);
 222       _unused_spill_slot = _max_spills;
 223       _max_spills++;
 224     }
 225     spill_slot = _max_spills;
 226     _max_spills += 2;
 227 
 228   } else if (_unused_spill_slot != -1) {
 229     // re-use hole that was the result of a previous double-word alignment
 230     spill_slot = _unused_spill_slot;
 231     _unused_spill_slot = -1;
 232 
 233   } else {
 234     spill_slot = _max_spills;
 235     _max_spills++;
 236   }
 237 
 238   int result = spill_slot + LinearScan::nof_regs + frame_map()-&gt;argcount();
 239 
 240   // if too many slots used, bailout compilation.
 241   if (result &gt; 2000) {
 242     bailout(&quot;too many stack slots used&quot;);
 243   }
 244 
 245   return result;
 246 }
 247 
 248 void LinearScan::assign_spill_slot(Interval* it) {
 249   // assign the canonical spill slot of the parent (if a part of the interval
 250   // is already spilled) or allocate a new spill slot
 251   if (it-&gt;canonical_spill_slot() &gt;= 0) {
 252     it-&gt;assign_reg(it-&gt;canonical_spill_slot());
 253   } else {
 254     int spill = allocate_spill_slot(type2spill_size[it-&gt;type()] == 2);
 255     it-&gt;set_canonical_spill_slot(spill);
 256     it-&gt;assign_reg(spill);
 257   }
 258 }
 259 
 260 void LinearScan::propagate_spill_slots() {
 261   if (!frame_map()-&gt;finalize_frame(max_spills())) {
 262     bailout(&quot;frame too large&quot;);
 263   }
 264 }
 265 
 266 // create a new interval with a predefined reg_num
 267 // (only used for parent intervals that are created during the building phase)
 268 Interval* LinearScan::create_interval(int reg_num) {
 269   assert(_intervals.at(reg_num) == NULL, &quot;overwriting exisiting interval&quot;);
 270 
 271   Interval* interval = new Interval(reg_num);
 272   _intervals.at_put(reg_num, interval);
 273 
 274   // assign register number for precolored intervals
 275   if (reg_num &lt; LIR_OprDesc::vreg_base) {
 276     interval-&gt;assign_reg(reg_num);
 277   }
 278   return interval;
 279 }
 280 
 281 // assign a new reg_num to the interval and append it to the list of intervals
 282 // (only used for child intervals that are created during register allocation)
 283 void LinearScan::append_interval(Interval* it) {
 284   it-&gt;set_reg_num(_intervals.length());
 285   _intervals.append(it);
 286   IntervalList* new_intervals = _new_intervals_from_allocation;
 287   if (new_intervals == NULL) {
 288     new_intervals = _new_intervals_from_allocation = new IntervalList();
 289   }
 290   new_intervals-&gt;append(it);
 291 }
 292 
 293 // copy the vreg-flags if an interval is split
 294 void LinearScan::copy_register_flags(Interval* from, Interval* to) {
 295   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::byte_reg)) {
 296     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::byte_reg);
 297   }
 298   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::callee_saved)) {
 299     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::callee_saved);
 300   }
 301 
 302   // Note: do not copy the must_start_in_memory flag because it is not necessary for child
 303   //       intervals (only the very beginning of the interval must be in memory)
 304 }
 305 
 306 
 307 // ********** spill move optimization
 308 // eliminate moves from register to stack if stack slot is known to be correct
 309 
 310 // called during building of intervals
 311 void LinearScan::change_spill_definition_pos(Interval* interval, int def_pos) {
 312   assert(interval-&gt;is_split_parent(), &quot;can only be called for split parents&quot;);
 313 
 314   switch (interval-&gt;spill_state()) {
 315     case noDefinitionFound:
 316       assert(interval-&gt;spill_definition_pos() == -1, &quot;must no be set before&quot;);
 317       interval-&gt;set_spill_definition_pos(def_pos);
 318       interval-&gt;set_spill_state(oneDefinitionFound);
 319       break;
 320 
 321     case oneDefinitionFound:
 322       assert(def_pos &lt;= interval-&gt;spill_definition_pos(), &quot;positions are processed in reverse order when intervals are created&quot;);
 323       if (def_pos &lt; interval-&gt;spill_definition_pos() - 2) {
 324         // second definition found, so no spill optimization possible for this interval
 325         interval-&gt;set_spill_state(noOptimization);
 326       } else {
 327         // two consecutive definitions (because of two-operand LIR form)
 328         assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval-&gt;spill_definition_pos()), &quot;block must be equal&quot;);
 329       }
 330       break;
 331 
 332     case noOptimization:
 333       // nothing to do
 334       break;
 335 
 336     default:
 337       assert(false, &quot;other states not allowed at this time&quot;);
 338   }
 339 }
 340 
 341 // called during register allocation
 342 void LinearScan::change_spill_state(Interval* interval, int spill_pos) {
 343   switch (interval-&gt;spill_state()) {
 344     case oneDefinitionFound: {
 345       int def_loop_depth = block_of_op_with_id(interval-&gt;spill_definition_pos())-&gt;loop_depth();
 346       int spill_loop_depth = block_of_op_with_id(spill_pos)-&gt;loop_depth();
 347 
 348       if (def_loop_depth &lt; spill_loop_depth) {
 349         // the loop depth of the spilling position is higher then the loop depth
 350         // at the definition of the interval -&gt; move write to memory out of loop
 351         // by storing at definitin of the interval
 352         interval-&gt;set_spill_state(storeAtDefinition);
 353       } else {
 354         // the interval is currently spilled only once, so for now there is no
 355         // reason to store the interval at the definition
 356         interval-&gt;set_spill_state(oneMoveInserted);
 357       }
 358       break;
 359     }
 360 
 361     case oneMoveInserted: {
 362       // the interval is spilled more then once, so it is better to store it to
 363       // memory at the definition
 364       interval-&gt;set_spill_state(storeAtDefinition);
 365       break;
 366     }
 367 
 368     case storeAtDefinition:
 369     case startInMemory:
 370     case noOptimization:
 371     case noDefinitionFound:
 372       // nothing to do
 373       break;
 374 
 375     default:
 376       assert(false, &quot;other states not allowed at this time&quot;);
 377   }
 378 }
 379 
 380 
 381 bool LinearScan::must_store_at_definition(const Interval* i) {
 382   return i-&gt;is_split_parent() &amp;&amp; i-&gt;spill_state() == storeAtDefinition;
 383 }
 384 
 385 // called once before asignment of register numbers
 386 void LinearScan::eliminate_spill_moves() {
 387   TIME_LINEAR_SCAN(timer_eliminate_spill_moves);
 388   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;***** Eliminating unnecessary spill moves&quot;));
 389 
 390   // collect all intervals that must be stored after their definion.
 391   // the list is sorted by Interval::spill_definition_pos
 392   Interval* interval;
 393   Interval* temp_list;
 394   create_unhandled_lists(&amp;interval, &amp;temp_list, must_store_at_definition, NULL);
 395 
 396 #ifdef ASSERT
 397   Interval* prev = NULL;
 398   Interval* temp = interval;
 399   while (temp != Interval::end()) {
 400     assert(temp-&gt;spill_definition_pos() &gt; 0, &quot;invalid spill definition pos&quot;);
 401     if (prev != NULL) {
 402       assert(temp-&gt;from() &gt;= prev-&gt;from(), &quot;intervals not sorted&quot;);
 403       assert(temp-&gt;spill_definition_pos() &gt;= prev-&gt;spill_definition_pos(), &quot;when intervals are sorted by from, then they must also be sorted by spill_definition_pos&quot;);
 404     }
 405 
 406     assert(temp-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;interval has no spill slot assigned&quot;);
 407     assert(temp-&gt;spill_definition_pos() &gt;= temp-&gt;from(), &quot;invalid order&quot;);
 408     assert(temp-&gt;spill_definition_pos() &lt;= temp-&gt;from() + 2, &quot;only intervals defined once at their start-pos can be optimized&quot;);
 409 
 410     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;interval %d (from %d to %d) must be stored at %d&quot;, temp-&gt;reg_num(), temp-&gt;from(), temp-&gt;to(), temp-&gt;spill_definition_pos()));
 411 
 412     temp = temp-&gt;next();
 413   }
 414 #endif
 415 
 416   LIR_InsertionBuffer insertion_buffer;
 417   int num_blocks = block_count();
 418   for (int i = 0; i &lt; num_blocks; i++) {
 419     BlockBegin* block = block_at(i);
 420     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 421     int         num_inst = instructions-&gt;length();
 422     bool        has_new = false;
 423 
 424     // iterate all instructions of the block. skip the first because it is always a label
 425     for (int j = 1; j &lt; num_inst; j++) {
 426       LIR_Op* op = instructions-&gt;at(j);
 427       int op_id = op-&gt;id();
 428 
 429       if (op_id == -1) {
 430         // remove move from register to stack if the stack slot is guaranteed to be correct.
 431         // only moves that have been inserted by LinearScan can be removed.
 432         assert(op-&gt;code() == lir_move, &quot;only moves can have a op_id of -1&quot;);
 433         assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
 434         assert(op-&gt;as_Op1()-&gt;result_opr()-&gt;is_virtual(), &quot;LinearScan inserts only moves to virtual registers&quot;);
 435 
 436         LIR_Op1* op1 = (LIR_Op1*)op;
 437         Interval* interval = interval_at(op1-&gt;result_opr()-&gt;vreg_number());
 438 
 439         if (interval-&gt;assigned_reg() &gt;= LinearScan::nof_regs &amp;&amp; interval-&gt;always_in_memory()) {
 440           // move target is a stack slot that is always correct, so eliminate instruction
 441           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;eliminating move from interval %d to %d&quot;, op1-&gt;in_opr()-&gt;vreg_number(), op1-&gt;result_opr()-&gt;vreg_number()));
 442           instructions-&gt;at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
 443         }
 444 
 445       } else {
 446         // insert move from register to stack just after the beginning of the interval
 447         assert(interval == Interval::end() || interval-&gt;spill_definition_pos() &gt;= op_id, &quot;invalid order&quot;);
 448         assert(interval == Interval::end() || (interval-&gt;is_split_parent() &amp;&amp; interval-&gt;spill_state() == storeAtDefinition), &quot;invalid interval&quot;);
 449 
 450         while (interval != Interval::end() &amp;&amp; interval-&gt;spill_definition_pos() == op_id) {
 451           if (!has_new) {
 452             // prepare insertion buffer (appended when all instructions of the block are processed)
 453             insertion_buffer.init(block-&gt;lir());
 454             has_new = true;
 455           }
 456 
 457           LIR_Opr from_opr = operand_for_interval(interval);
 458           LIR_Opr to_opr = canonical_spill_opr(interval);
 459           assert(from_opr-&gt;is_fixed_cpu() || from_opr-&gt;is_fixed_fpu(), &quot;from operand must be a register&quot;);
 460           assert(to_opr-&gt;is_stack(), &quot;to operand must be a stack slot&quot;);
 461 
 462           insertion_buffer.move(j, from_opr, to_opr);
 463           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting move after definition of interval %d to stack slot %d at op_id %d&quot;, interval-&gt;reg_num(), interval-&gt;canonical_spill_slot() - LinearScan::nof_regs, op_id));
 464 
 465           interval = interval-&gt;next();
 466         }
 467       }
 468     } // end of instruction iteration
 469 
 470     if (has_new) {
 471       block-&gt;lir()-&gt;append(&amp;insertion_buffer);
 472     }
 473   } // end of block iteration
 474 
 475   assert(interval == Interval::end(), &quot;missed an interval&quot;);
 476 }
 477 
 478 
 479 // ********** Phase 1: number all instructions in all blocks
 480 // Compute depth-first and linear scan block orders, and number LIR_Op nodes for linear scan.
 481 
 482 void LinearScan::number_instructions() {
 483   {
 484     // dummy-timer to measure the cost of the timer itself
 485     // (this time is then subtracted from all other timers to get the real value)
 486     TIME_LINEAR_SCAN(timer_do_nothing);
 487   }
 488   TIME_LINEAR_SCAN(timer_number_instructions);
 489 
 490   // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
 491   int num_blocks = block_count();
 492   int num_instructions = 0;
 493   int i;
 494   for (i = 0; i &lt; num_blocks; i++) {
 495     num_instructions += block_at(i)-&gt;lir()-&gt;instructions_list()-&gt;length();
 496   }
 497 
 498   // initialize with correct length
 499   _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);
 500   _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);
 501 
 502   int op_id = 0;
 503   int idx = 0;
 504 
 505   for (i = 0; i &lt; num_blocks; i++) {
 506     BlockBegin* block = block_at(i);
 507     block-&gt;set_first_lir_instruction_id(op_id);
 508     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 509 
 510     int num_inst = instructions-&gt;length();
 511     for (int j = 0; j &lt; num_inst; j++) {
 512       LIR_Op* op = instructions-&gt;at(j);
 513       op-&gt;set_id(op_id);
 514 
 515       _lir_ops.at_put(idx, op);
 516       _block_of_op.at_put(idx, block);
 517       assert(lir_op_with_id(op_id) == op, &quot;must match&quot;);
 518 
 519       idx++;
 520       op_id += 2; // numbering of lir_ops by two
 521     }
 522     block-&gt;set_last_lir_instruction_id(op_id - 2);
 523   }
 524   assert(idx == num_instructions, &quot;must match&quot;);
 525   assert(idx * 2 == op_id, &quot;must match&quot;);
 526 
 527   _has_call.initialize(num_instructions);
 528   _has_info.initialize(num_instructions);
 529 }
 530 
 531 
 532 // ********** Phase 2: compute local live sets separately for each block
 533 // (sets live_gen and live_kill for each block)
 534 
 535 void LinearScan::set_live_gen_kill(Value value, LIR_Op* op, BitMap&amp; live_gen, BitMap&amp; live_kill) {
 536   LIR_Opr opr = value-&gt;operand();
 537   Constant* con = value-&gt;as_Constant();
 538 
 539   // check some asumptions about debug information
 540   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this local is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 541   assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands&quot;);
 542   assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
 543 
 544   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 545     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 546     int reg = opr-&gt;vreg_number();
 547     if (!live_kill.at(reg)) {
 548       live_gen.set_bit(reg);
 549       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for value %c%d, LIR op_id %d, register number %d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id(), op-&gt;id(), reg));
 550     }
 551   }
 552 }
 553 
 554 
 555 void LinearScan::compute_local_live_sets() {
 556   TIME_LINEAR_SCAN(timer_compute_local_live_sets);
 557 
 558   int  num_blocks = block_count();
 559   int  live_size = live_set_size();
 560   bool local_has_fpu_registers = false;
 561   int  local_num_calls = 0;
 562   LIR_OpVisitState visitor;
 563 
 564   BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
 565 
 566   // iterate all blocks
 567   for (int i = 0; i &lt; num_blocks; i++) {
 568     BlockBegin* block = block_at(i);
 569 
 570     ResourceBitMap live_gen(live_size);
 571     ResourceBitMap live_kill(live_size);
 572 
 573     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 574       // Phi functions at the begin of an exception handler are
 575       // implicitly defined (= killed) at the beginning of the block.
 576       for_each_phi_fun(block, phi,
 577         if (!phi-&gt;is_illegal()) { live_kill.set_bit(phi-&gt;operand()-&gt;vreg_number()); }
 578       );
 579     }
 580 
 581     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 582     int num_inst = instructions-&gt;length();
 583 
 584     // iterate all instructions of the block. skip the first because it is always a label
 585     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
 586     for (int j = 1; j &lt; num_inst; j++) {
 587       LIR_Op* op = instructions-&gt;at(j);
 588 
 589       // visit operation to collect all operands
 590       visitor.visit(op);
 591 
 592       if (visitor.has_call()) {
 593         _has_call.set_bit(op-&gt;id() &gt;&gt; 1);
 594         local_num_calls++;
 595       }
 596       if (visitor.info_count() &gt; 0) {
 597         _has_info.set_bit(op-&gt;id() &gt;&gt; 1);
 598       }
 599 
 600       // iterate input operands of instruction
 601       int k, n, reg;
 602       n = visitor.opr_count(LIR_OpVisitState::inputMode);
 603       for (k = 0; k &lt; n; k++) {
 604         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
 605         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 606 
 607         if (opr-&gt;is_virtual_register()) {
 608           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 609           reg = opr-&gt;vreg_number();
 610           if (!live_kill.at(reg)) {
 611             live_gen.set_bit(reg);
 612             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for register %d at instruction %d&quot;, reg, op-&gt;id()));
 613           }
 614           if (block-&gt;loop_index() &gt;= 0) {
 615             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 616           }
 617           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 618         }
 619 
 620 #ifdef ASSERT
 621         // fixed intervals are never live at block boundaries, so
 622         // they need not be processed in live sets.
 623         // this is checked by these assertions to be sure about it.
 624         // the entry block may have incoming values in registers, which is ok.
 625         if (!opr-&gt;is_virtual_register() &amp;&amp; block != ir()-&gt;start()) {
 626           reg = reg_num(opr);
 627           if (is_processed_reg_num(reg)) {
 628             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 629           }
 630           reg = reg_numHi(opr);
 631           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 632             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 633           }
 634         }
 635 #endif
 636       }
 637 
 638       // Add uses of live locals from interpreter&#39;s point of view for proper debug information generation
 639       n = visitor.info_count();
 640       for (k = 0; k &lt; n; k++) {
 641         CodeEmitInfo* info = visitor.info_at(k);
 642         ValueStack* stack = info-&gt;stack();
 643         for_each_state_value(stack, value,
 644           set_live_gen_kill(value, op, live_gen, live_kill)
 645         );
 646       }
 647 
 648       // iterate temp operands of instruction
 649       n = visitor.opr_count(LIR_OpVisitState::tempMode);
 650       for (k = 0; k &lt; n; k++) {
 651         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
 652         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 653 
 654         if (opr-&gt;is_virtual_register()) {
 655           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 656           reg = opr-&gt;vreg_number();
 657           live_kill.set_bit(reg);
 658           if (block-&gt;loop_index() &gt;= 0) {
 659             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 660           }
 661           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 662         }
 663 
 664 #ifdef ASSERT
 665         // fixed intervals are never live at block boundaries, so
 666         // they need not be processed in live sets
 667         // process them only in debug mode so that this can be checked
 668         if (!opr-&gt;is_virtual_register()) {
 669           reg = reg_num(opr);
 670           if (is_processed_reg_num(reg)) {
 671             live_kill.set_bit(reg_num(opr));
 672           }
 673           reg = reg_numHi(opr);
 674           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 675             live_kill.set_bit(reg);
 676           }
 677         }
 678 #endif
 679       }
 680 
 681       // iterate output operands of instruction
 682       n = visitor.opr_count(LIR_OpVisitState::outputMode);
 683       for (k = 0; k &lt; n; k++) {
 684         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
 685         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 686 
 687         if (opr-&gt;is_virtual_register()) {
 688           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 689           reg = opr-&gt;vreg_number();
 690           live_kill.set_bit(reg);
 691           if (block-&gt;loop_index() &gt;= 0) {
 692             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 693           }
 694           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 695         }
 696 
 697 #ifdef ASSERT
 698         // fixed intervals are never live at block boundaries, so
 699         // they need not be processed in live sets
 700         // process them only in debug mode so that this can be checked
 701         if (!opr-&gt;is_virtual_register()) {
 702           reg = reg_num(opr);
 703           if (is_processed_reg_num(reg)) {
 704             live_kill.set_bit(reg_num(opr));
 705           }
 706           reg = reg_numHi(opr);
 707           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 708             live_kill.set_bit(reg);
 709           }
 710         }
 711 #endif
 712       }
 713     } // end of instruction iteration
 714 
 715     block-&gt;set_live_gen (live_gen);
 716     block-&gt;set_live_kill(live_kill);
 717     block-&gt;set_live_in  (ResourceBitMap(live_size));
 718     block-&gt;set_live_out (ResourceBitMap(live_size));
 719 
 720     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_gen  B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_gen()));
 721     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_kill B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_kill()));
 722   } // end of block iteration
 723 
 724   // propagate local calculated information into LinearScan object
 725   _has_fpu_registers = local_has_fpu_registers;
 726   compilation()-&gt;set_has_fpu_code(local_has_fpu_registers);
 727 
 728   _num_calls = local_num_calls;
 729   _interval_in_loop = local_interval_in_loop;
 730 }
 731 
 732 
 733 // ********** Phase 3: perform a backward dataflow analysis to compute global live sets
 734 // (sets live_in and live_out for each block)
 735 
 736 void LinearScan::compute_global_live_sets() {
 737   TIME_LINEAR_SCAN(timer_compute_global_live_sets);
 738 
 739   int  num_blocks = block_count();
 740   bool change_occurred;
 741   bool change_occurred_in_block;
 742   int  iteration_count = 0;
 743   ResourceBitMap live_out(live_set_size()); // scratch set for calculations
 744 
 745   // Perform a backward dataflow analysis to compute live_out and live_in for each block.
 746   // The loop is executed until a fixpoint is reached (no changes in an iteration)
 747   // Exception handlers must be processed because not all live values are
 748   // present in the state array, e.g. because of global value numbering
 749   do {
 750     change_occurred = false;
 751 
 752     // iterate all blocks in reverse order
 753     for (int i = num_blocks - 1; i &gt;= 0; i--) {
 754       BlockBegin* block = block_at(i);
 755 
 756       change_occurred_in_block = false;
 757 
 758       // live_out(block) is the union of live_in(sux), for successors sux of block
 759       int n = block-&gt;number_of_sux();
 760       int e = block-&gt;number_of_exception_handlers();
 761       if (n + e &gt; 0) {
 762         // block has successors
 763         if (n &gt; 0) {
 764           live_out.set_from(block-&gt;sux_at(0)-&gt;live_in());
 765           for (int j = 1; j &lt; n; j++) {
 766             live_out.set_union(block-&gt;sux_at(j)-&gt;live_in());
 767           }
 768         } else {
 769           live_out.clear();
 770         }
 771         for (int j = 0; j &lt; e; j++) {
 772           live_out.set_union(block-&gt;exception_handler_at(j)-&gt;live_in());
 773         }
 774 
 775         if (!block-&gt;live_out().is_same(live_out)) {
 776           // A change occurred.  Swap the old and new live out sets to avoid copying.
 777           ResourceBitMap temp = block-&gt;live_out();
 778           block-&gt;set_live_out(live_out);
 779           live_out = temp;
 780 
 781           change_occurred = true;
 782           change_occurred_in_block = true;
 783         }
 784       }
 785 
 786       if (iteration_count == 0 || change_occurred_in_block) {
 787         // live_in(block) is the union of live_gen(block) with (live_out(block) &amp; !live_kill(block))
 788         // note: live_in has to be computed only in first iteration or if live_out has changed!
 789         ResourceBitMap live_in = block-&gt;live_in();
 790         live_in.set_from(block-&gt;live_out());
 791         live_in.set_difference(block-&gt;live_kill());
 792         live_in.set_union(block-&gt;live_gen());
 793       }
 794 
 795 #ifndef PRODUCT
 796       if (TraceLinearScanLevel &gt;= 4) {
 797         char c = &#39; &#39;;
 798         if (iteration_count == 0 || change_occurred_in_block) {
 799           c = &#39;*&#39;;
 800         }
 801         tty-&gt;print(&quot;(%d) live_in%c  B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_in());
 802         tty-&gt;print(&quot;(%d) live_out%c B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_out());
 803       }
 804 #endif
 805     }
 806     iteration_count++;
 807 
 808     if (change_occurred &amp;&amp; iteration_count &gt; 50) {
 809       BAILOUT(&quot;too many iterations in compute_global_live_sets&quot;);
 810     }
 811   } while (change_occurred);
 812 
 813 
 814 #ifdef ASSERT
 815   // check that fixed intervals are not live at block boundaries
 816   // (live set must be empty at fixed intervals)
 817   for (int i = 0; i &lt; num_blocks; i++) {
 818     BlockBegin* block = block_at(i);
 819     for (int j = 0; j &lt; LIR_OprDesc::vreg_base; j++) {
 820       assert(block-&gt;live_in().at(j)  == false, &quot;live_in  set of fixed register must be empty&quot;);
 821       assert(block-&gt;live_out().at(j) == false, &quot;live_out set of fixed register must be empty&quot;);
 822       assert(block-&gt;live_gen().at(j) == false, &quot;live_gen set of fixed register must be empty&quot;);
 823     }
 824   }
 825 #endif
 826 
 827   // check that the live_in set of the first block is empty
 828   ResourceBitMap live_in_args(ir()-&gt;start()-&gt;live_in().size());
 829   if (!ir()-&gt;start()-&gt;live_in().is_same(live_in_args)) {
 830 #ifdef ASSERT
 831     tty-&gt;print_cr(&quot;Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)&quot;);
 832     tty-&gt;print_cr(&quot;affected registers:&quot;);
 833     print_bitmap(ir()-&gt;start()-&gt;live_in());
 834 
 835     // print some additional information to simplify debugging
 836     for (unsigned int i = 0; i &lt; ir()-&gt;start()-&gt;live_in().size(); i++) {
 837       if (ir()-&gt;start()-&gt;live_in().at(i)) {
 838         Instruction* instr = gen()-&gt;instruction_for_vreg(i);
 839         tty-&gt;print_cr(&quot;* vreg %d (HIR instruction %c%d)&quot;, i, instr == NULL ? &#39; &#39; : instr-&gt;type()-&gt;tchar(), instr == NULL ? 0 : instr-&gt;id());
 840 
 841         for (int j = 0; j &lt; num_blocks; j++) {
 842           BlockBegin* block = block_at(j);
 843           if (block-&gt;live_gen().at(i)) {
 844             tty-&gt;print_cr(&quot;  used in block B%d&quot;, block-&gt;block_id());
 845           }
 846           if (block-&gt;live_kill().at(i)) {
 847             tty-&gt;print_cr(&quot;  defined in block B%d&quot;, block-&gt;block_id());
 848           }
 849         }
 850       }
 851     }
 852 
 853 #endif
 854     // when this fails, virtual registers are used before they are defined.
 855     assert(false, &quot;live_in set of first block must be empty&quot;);
 856     // bailout of if this occurs in product mode.
 857     bailout(&quot;live_in set of first block not empty&quot;);
 858   }
 859 }
 860 
 861 
 862 // ********** Phase 4: build intervals
 863 // (fills the list _intervals)
 864 
 865 void LinearScan::add_use(Value value, int from, int to, IntervalUseKind use_kind) {
 866   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this value is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 867   LIR_Opr opr = value-&gt;operand();
 868   Constant* con = value-&gt;as_Constant();
 869 
 870   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 871     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 872     add_use(opr, from, to, use_kind);
 873   }
 874 }
 875 
 876 
 877 void LinearScan::add_def(LIR_Opr opr, int def_pos, IntervalUseKind use_kind) {
 878   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; def &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; def_pos %d (%d)&quot;, def_pos, use_kind));
 879   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 880 
 881   if (opr-&gt;is_virtual_register()) {
 882     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 883     add_def(opr-&gt;vreg_number(), def_pos, use_kind, opr-&gt;type_register());
 884 
 885   } else {
 886     int reg = reg_num(opr);
 887     if (is_processed_reg_num(reg)) {
 888       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 889     }
 890     reg = reg_numHi(opr);
 891     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 892       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 893     }
 894   }
 895 }
 896 
 897 void LinearScan::add_use(LIR_Opr opr, int from, int to, IntervalUseKind use_kind) {
 898   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; use &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; from %d to %d (%d)&quot;, from, to, use_kind));
 899   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 900 
 901   if (opr-&gt;is_virtual_register()) {
 902     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 903     add_use(opr-&gt;vreg_number(), from, to, use_kind, opr-&gt;type_register());
 904 
 905   } else {
 906     int reg = reg_num(opr);
 907     if (is_processed_reg_num(reg)) {
 908       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 909     }
 910     reg = reg_numHi(opr);
 911     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 912       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 913     }
 914   }
 915 }
 916 
 917 void LinearScan::add_temp(LIR_Opr opr, int temp_pos, IntervalUseKind use_kind) {
 918   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; temp &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; temp_pos %d (%d)&quot;, temp_pos, use_kind));
 919   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 920 
 921   if (opr-&gt;is_virtual_register()) {
 922     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 923     add_temp(opr-&gt;vreg_number(), temp_pos, use_kind, opr-&gt;type_register());
 924 
 925   } else {
 926     int reg = reg_num(opr);
 927     if (is_processed_reg_num(reg)) {
 928       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 929     }
 930     reg = reg_numHi(opr);
 931     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 932       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 933     }
 934   }
 935 }
 936 
 937 
 938 void LinearScan::add_def(int reg_num, int def_pos, IntervalUseKind use_kind, BasicType type) {
 939   Interval* interval = interval_at(reg_num);
 940   if (interval != NULL) {
 941     assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 942 
 943     if (type != T_ILLEGAL) {
 944       interval-&gt;set_type(type);
 945     }
 946 
 947     Range* r = interval-&gt;first();
 948     if (r-&gt;from() &lt;= def_pos) {
 949       // Update the starting point (when a range is first created for a use, its
 950       // start is the beginning of the current block until a def is encountered.)
 951       r-&gt;set_from(def_pos);
 952       interval-&gt;add_use_pos(def_pos, use_kind);
 953 
 954     } else {
 955       // Dead value - make vacuous interval
 956       // also add use_kind for dead intervals
 957       interval-&gt;add_range(def_pos, def_pos + 1);
 958       interval-&gt;add_use_pos(def_pos, use_kind);
 959       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: def of reg %d at %d occurs without use&quot;, reg_num, def_pos));
 960     }
 961 
 962   } else {
 963     // Dead value - make vacuous interval
 964     // also add use_kind for dead intervals
 965     interval = create_interval(reg_num);
 966     if (type != T_ILLEGAL) {
 967       interval-&gt;set_type(type);
 968     }
 969 
 970     interval-&gt;add_range(def_pos, def_pos + 1);
 971     interval-&gt;add_use_pos(def_pos, use_kind);
 972     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: dead value %d at %d in live intervals&quot;, reg_num, def_pos));
 973   }
 974 
 975   change_spill_definition_pos(interval, def_pos);
 976   if (use_kind == noUse &amp;&amp; interval-&gt;spill_state() &lt;= startInMemory) {
 977         // detection of method-parameters and roundfp-results
 978         // TODO: move this directly to position where use-kind is computed
 979     interval-&gt;set_spill_state(startInMemory);
 980   }
 981 }
 982 
 983 void LinearScan::add_use(int reg_num, int from, int to, IntervalUseKind use_kind, BasicType type) {
 984   Interval* interval = interval_at(reg_num);
 985   if (interval == NULL) {
 986     interval = create_interval(reg_num);
 987   }
 988   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 989 
 990   if (type != T_ILLEGAL) {
 991     interval-&gt;set_type(type);
 992   }
 993 
 994   interval-&gt;add_range(from, to);
 995   interval-&gt;add_use_pos(to, use_kind);
 996 }
 997 
 998 void LinearScan::add_temp(int reg_num, int temp_pos, IntervalUseKind use_kind, BasicType type) {
 999   Interval* interval = interval_at(reg_num);
1000   if (interval == NULL) {
1001     interval = create_interval(reg_num);
1002   }
1003   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
1004 
1005   if (type != T_ILLEGAL) {
1006     interval-&gt;set_type(type);
1007   }
1008 
1009   interval-&gt;add_range(temp_pos, temp_pos + 1);
1010   interval-&gt;add_use_pos(temp_pos, use_kind);
1011 }
1012 
1013 
1014 // the results of this functions are used for optimizing spilling and reloading
1015 // if the functions return shouldHaveRegister and the interval is spilled,
1016 // it is not reloaded to a register.
1017 IntervalUseKind LinearScan::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
1018   if (op-&gt;code() == lir_move) {
1019     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1020     LIR_Op1* move = (LIR_Op1*)op;
1021     LIR_Opr res = move-&gt;result_opr();
1022     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1023 
1024     if (result_in_memory) {
1025       // Begin of an interval with must_start_in_memory set.
1026       // This interval will always get a stack slot first, so return noUse.
1027       return noUse;
1028 
1029     } else if (move-&gt;in_opr()-&gt;is_stack()) {
1030       // method argument (condition must be equal to handle_method_arguments)
1031       return noUse;
1032 
1033     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1034       // Move from register to register
1035       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1036         // special handling of phi-function moves inside osr-entry blocks
1037         // input operand must have a register instead of output operand (leads to better register allocation)
1038         return shouldHaveRegister;
1039       }
1040     }
1041   }
1042 
1043   if (opr-&gt;is_virtual() &amp;&amp;
1044       gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::must_start_in_memory)) {
1045     // result is a stack-slot, so prevent immediate reloading
1046     return noUse;
1047   }
1048 
1049   // all other operands require a register
1050   return mustHaveRegister;
1051 }
1052 
1053 IntervalUseKind LinearScan::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
1054   if (op-&gt;code() == lir_move) {
1055     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1056     LIR_Op1* move = (LIR_Op1*)op;
1057     LIR_Opr res = move-&gt;result_opr();
1058     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1059 
1060     if (result_in_memory) {
1061       // Move to an interval with must_start_in_memory set.
1062       // To avoid moves from stack to stack (not allowed) force the input operand to a register
1063       return mustHaveRegister;
1064 
1065     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1066       // Move from register to register
1067       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1068         // special handling of phi-function moves inside osr-entry blocks
1069         // input operand must have a register instead of output operand (leads to better register allocation)
1070         return mustHaveRegister;
1071       }
1072 
1073       // The input operand is not forced to a register (moves from stack to register are allowed),
1074       // but it is faster if the input operand is in a register
1075       return shouldHaveRegister;
1076     }
1077   }
1078 
1079 
1080 #if defined(X86) || defined(S390)
1081   if (op-&gt;code() == lir_cmove) {
1082     // conditional moves can handle stack operands
1083     assert(op-&gt;result_opr()-&gt;is_register(), &quot;result must always be in a register&quot;);
1084     return shouldHaveRegister;
1085   }
1086 
1087   // optimizations for second input operand of arithmehtic operations on Intel
1088   // this operand is allowed to be on the stack in some cases
1089   BasicType opr_type = opr-&gt;type_register();
1090   if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
1091     if (IA32_ONLY( (UseSSE == 1 &amp;&amp; opr_type == T_FLOAT) || UseSSE &gt;= 2 ) NOT_IA32( true )) {
1092       // SSE float instruction (T_DOUBLE only supported with SSE2)
1093       switch (op-&gt;code()) {
1094         case lir_cmp:
1095         case lir_add:
1096         case lir_sub:
1097         case lir_mul:
1098         case lir_div:
1099         {
1100           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1101           LIR_Op2* op2 = (LIR_Op2*)op;
1102           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1103             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1104             return shouldHaveRegister;
1105           }
1106         }
1107         default:
1108           break;
1109       }
1110     } else {
1111       // FPU stack float instruction
1112       switch (op-&gt;code()) {
1113         case lir_add:
1114         case lir_sub:
1115         case lir_mul:
1116         case lir_div:
1117         {
1118           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1119           LIR_Op2* op2 = (LIR_Op2*)op;
1120           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1121             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1122             return shouldHaveRegister;
1123           }
1124         }
1125         default:
1126           break;
1127       }
1128     }
1129     // We want to sometimes use logical operations on pointers, in particular in GC barriers.
1130     // Since 64bit logical operations do not current support operands on stack, we have to make sure
1131     // T_OBJECT doesn&#39;t get spilled along with T_LONG.
1132   } else if (opr_type != T_LONG LP64_ONLY(&amp;&amp; opr_type != T_OBJECT)) {
1133     // integer instruction (note: long operands must always be in register)
1134     switch (op-&gt;code()) {
1135       case lir_cmp:
1136       case lir_add:
1137       case lir_sub:
1138       case lir_logic_and:
1139       case lir_logic_or:
1140       case lir_logic_xor:
1141       {
1142         assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1143         LIR_Op2* op2 = (LIR_Op2*)op;
1144         if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1145           assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1146           return shouldHaveRegister;
1147         }
1148       }
1149       default:
1150         break;
1151     }
1152   }
1153 #endif // X86 || S390
1154 
1155   // all other operands require a register
1156   return mustHaveRegister;
1157 }
1158 
1159 
1160 void LinearScan::handle_method_arguments(LIR_Op* op) {
1161   // special handling for method arguments (moves from stack to virtual register):
1162   // the interval gets no register assigned, but the stack slot.
1163   // it is split before the first use by the register allocator.
1164 
1165   if (op-&gt;code() == lir_move) {
1166     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1167     LIR_Op1* move = (LIR_Op1*)op;
1168 
1169     if (move-&gt;in_opr()-&gt;is_stack()) {
1170 #ifdef ASSERT
1171       int arg_size = compilation()-&gt;method()-&gt;arg_size();
1172       LIR_Opr o = move-&gt;in_opr();
1173       if (o-&gt;is_single_stack()) {
1174         assert(o-&gt;single_stack_ix() &gt;= 0 &amp;&amp; o-&gt;single_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1175       } else if (o-&gt;is_double_stack()) {
1176         assert(o-&gt;double_stack_ix() &gt;= 0 &amp;&amp; o-&gt;double_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1177       } else {
1178         ShouldNotReachHere();
1179       }
1180 
1181       assert(move-&gt;id() &gt; 0, &quot;invalid id&quot;);
1182       assert(block_of_op_with_id(move-&gt;id())-&gt;number_of_preds() == 0, &quot;move from stack must be in first block&quot;);
1183       assert(move-&gt;result_opr()-&gt;is_virtual(), &quot;result of move must be a virtual register&quot;);
1184 
1185       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;found move from stack slot %d to vreg %d&quot;, o-&gt;is_single_stack() ? o-&gt;single_stack_ix() : o-&gt;double_stack_ix(), reg_num(move-&gt;result_opr())));
1186 #endif
1187 
1188       Interval* interval = interval_at(reg_num(move-&gt;result_opr()));
1189 
1190       int stack_slot = LinearScan::nof_regs + (move-&gt;in_opr()-&gt;is_single_stack() ? move-&gt;in_opr()-&gt;single_stack_ix() : move-&gt;in_opr()-&gt;double_stack_ix());
1191       interval-&gt;set_canonical_spill_slot(stack_slot);
1192       interval-&gt;assign_reg(stack_slot);
1193     }
1194   }
1195 }
1196 
1197 void LinearScan::handle_doubleword_moves(LIR_Op* op) {
1198   // special handling for doubleword move from memory to register:
1199   // in this case the registers of the input address and the result
1200   // registers must not overlap -&gt; add a temp range for the input registers
1201   if (op-&gt;code() == lir_move) {
1202     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1203     LIR_Op1* move = (LIR_Op1*)op;
1204 
1205     if (move-&gt;result_opr()-&gt;is_double_cpu() &amp;&amp; move-&gt;in_opr()-&gt;is_pointer()) {
1206       LIR_Address* address = move-&gt;in_opr()-&gt;as_address_ptr();
1207       if (address != NULL) {
1208         if (address-&gt;base()-&gt;is_valid()) {
1209           add_temp(address-&gt;base(), op-&gt;id(), noUse);
1210         }
1211         if (address-&gt;index()-&gt;is_valid()) {
1212           add_temp(address-&gt;index(), op-&gt;id(), noUse);
1213         }
1214       }
1215     }
1216   }
1217 }
1218 
1219 void LinearScan::add_register_hints(LIR_Op* op) {
1220   switch (op-&gt;code()) {
1221     case lir_move:      // fall through
1222     case lir_convert: {
1223       assert(op-&gt;as_Op1() != NULL, &quot;lir_move, lir_convert must be LIR_Op1&quot;);
1224       LIR_Op1* move = (LIR_Op1*)op;
1225 
1226       LIR_Opr move_from = move-&gt;in_opr();
1227       LIR_Opr move_to = move-&gt;result_opr();
1228 
1229       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1230         Interval* from = interval_at(reg_num(move_from));
1231         Interval* to = interval_at(reg_num(move_to));
1232         if (from != NULL &amp;&amp; to != NULL) {
1233           to-&gt;set_register_hint(from);
1234           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, move-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1235         }
1236       }
1237       break;
1238     }
1239     case lir_cmove: {
1240       assert(op-&gt;as_Op2() != NULL, &quot;lir_cmove must be LIR_Op2&quot;);
1241       LIR_Op2* cmove = (LIR_Op2*)op;
1242 
1243       LIR_Opr move_from = cmove-&gt;in_opr1();
1244       LIR_Opr move_to = cmove-&gt;result_opr();
1245 
1246       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1247         Interval* from = interval_at(reg_num(move_from));
1248         Interval* to = interval_at(reg_num(move_to));
1249         if (from != NULL &amp;&amp; to != NULL) {
1250           to-&gt;set_register_hint(from);
1251           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, cmove-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1252         }
1253       }
1254       break;
1255     }
1256     default:
1257       break;
1258   }
1259 }
1260 
1261 
1262 void LinearScan::build_intervals() {
1263   TIME_LINEAR_SCAN(timer_build_intervals);
1264 
1265   // initialize interval list with expected number of intervals
1266   // (32 is added to have some space for split children without having to resize the list)
1267   _intervals = IntervalList(num_virtual_regs() + 32);
1268   // initialize all slots that are used by build_intervals
1269   _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
1270 
1271   // create a list with all caller-save registers (cpu, fpu, xmm)
1272   // when an instruction is a call, a temp range is created for all these registers
1273   int num_caller_save_registers = 0;
1274   int caller_save_registers[LinearScan::nof_regs];
1275 
1276   int i;
1277   for (i = 0; i &lt; FrameMap::nof_caller_save_cpu_regs(); i++) {
1278     LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
1279     assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1280     assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1281     caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1282   }
1283 
1284   // temp ranges for fpu registers are only created when the method has
1285   // virtual fpu operands. Otherwise no allocation for fpu registers is
1286   // performed and so the temp ranges would be useless
1287   if (has_fpu_registers()) {
1288 #ifdef X86
1289     if (UseSSE &lt; 2) {
1290 #endif // X86
1291       for (i = 0; i &lt; FrameMap::nof_caller_save_fpu_regs; i++) {
1292         LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
1293         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1294         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1295         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1296       }
1297 #ifdef X86
1298     }
1299 #endif // X86
1300 
1301 #ifdef X86
1302     if (UseSSE &gt; 0) {
1303       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
1304       for (i = 0; i &lt; num_caller_save_xmm_regs; i ++) {
1305         LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
1306         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1307         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1308         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1309       }
1310     }
1311 #endif // X86
1312   }
1313   assert(num_caller_save_registers &lt;= LinearScan::nof_regs, &quot;out of bounds&quot;);
1314 
1315 
1316   LIR_OpVisitState visitor;
1317 
1318   // iterate all blocks in reverse order
1319   for (i = block_count() - 1; i &gt;= 0; i--) {
1320     BlockBegin* block = block_at(i);
1321     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1322     int         block_from =   block-&gt;first_lir_instruction_id();
1323     int         block_to =     block-&gt;last_lir_instruction_id();
1324 
1325     assert(block_from == instructions-&gt;at(0)-&gt;id(), &quot;must be&quot;);
1326     assert(block_to   == instructions-&gt;at(instructions-&gt;length() - 1)-&gt;id(), &quot;must be&quot;);
1327 
1328     // Update intervals for registers live at the end of this block;
1329     ResourceBitMap live = block-&gt;live_out();
1330     int size = (int)live.size();
1331     for (int number = (int)live.get_next_one_offset(0, size); number &lt; size; number = (int)live.get_next_one_offset(number + 1, size)) {
1332       assert(live.at(number), &quot;should not stop here otherwise&quot;);
1333       assert(number &gt;= LIR_OprDesc::vreg_base, &quot;fixed intervals must not be live on block bounds&quot;);
1334       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;live in %d to %d&quot;, number, block_to + 2));
1335 
1336       add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
1337 
1338       // add special use positions for loop-end blocks when the
1339       // interval is used anywhere inside this loop.  It&#39;s possible
1340       // that the block was part of a non-natural loop, so it might
1341       // have an invalid loop index.
1342       if (block-&gt;is_set(BlockBegin::linear_scan_loop_end_flag) &amp;&amp;
1343           block-&gt;loop_index() != -1 &amp;&amp;
1344           is_interval_in_loop(number, block-&gt;loop_index())) {
1345         interval_at(number)-&gt;add_use_pos(block_to + 1, loopEndMarker);
1346       }
1347     }
1348 
1349     // iterate all instructions of the block in reverse order.
1350     // skip the first instruction because it is always a label
1351     // definitions of intervals are processed before uses
1352     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
1353     for (int j = instructions-&gt;length() - 1; j &gt;= 1; j--) {
1354       LIR_Op* op = instructions-&gt;at(j);
1355       int op_id = op-&gt;id();
1356 
1357       // visit operation to collect all operands
1358       visitor.visit(op);
1359 
1360       // add a temp range for each register if operation destroys caller-save registers
1361       if (visitor.has_call()) {
1362         for (int k = 0; k &lt; num_caller_save_registers; k++) {
1363           add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
1364         }
1365         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation destroys all caller-save registers&quot;));
1366       }
1367 
1368       // Add any platform dependent temps
1369       pd_add_temps(op);
1370 
1371       // visit definitions (output and temp operands)
1372       int k, n;
1373       n = visitor.opr_count(LIR_OpVisitState::outputMode);
1374       for (k = 0; k &lt; n; k++) {
1375         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
1376         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1377         add_def(opr, op_id, use_kind_of_output_operand(op, opr));
1378       }
1379 
1380       n = visitor.opr_count(LIR_OpVisitState::tempMode);
1381       for (k = 0; k &lt; n; k++) {
1382         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
1383         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1384         add_temp(opr, op_id, mustHaveRegister);
1385       }
1386 
1387       // visit uses (input operands)
1388       n = visitor.opr_count(LIR_OpVisitState::inputMode);
1389       for (k = 0; k &lt; n; k++) {
1390         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
1391         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1392         add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
1393       }
1394 
1395       // Add uses of live locals from interpreter&#39;s point of view for proper
1396       // debug information generation
1397       // Treat these operands as temp values (if the life range is extended
1398       // to a call site, the value would be in a register at the call otherwise)
1399       n = visitor.info_count();
1400       for (k = 0; k &lt; n; k++) {
1401         CodeEmitInfo* info = visitor.info_at(k);
1402         ValueStack* stack = info-&gt;stack();
1403         for_each_state_value(stack, value,
1404           add_use(value, block_from, op_id + 1, noUse);
1405         );
1406       }
1407 
1408       // special steps for some instructions (especially moves)
1409       handle_method_arguments(op);
1410       handle_doubleword_moves(op);
1411       add_register_hints(op);
1412 
1413     } // end of instruction iteration
1414   } // end of block iteration
1415 
1416 
1417   // add the range [0, 1[ to all fixed intervals
1418   // -&gt; the register allocator need not handle unhandled fixed intervals
1419   for (int n = 0; n &lt; LinearScan::nof_regs; n++) {
1420     Interval* interval = interval_at(n);
1421     if (interval != NULL) {
1422       interval-&gt;add_range(0, 1);
1423     }
1424   }
1425 }
1426 
1427 
1428 // ********** Phase 5: actual register allocation
1429 
1430 int LinearScan::interval_cmp(Interval** a, Interval** b) {
1431   if (*a != NULL) {
1432     if (*b != NULL) {
1433       return (*a)-&gt;from() - (*b)-&gt;from();
1434     } else {
1435       return -1;
1436     }
1437   } else {
1438     if (*b != NULL) {
1439       return 1;
1440     } else {
1441       return 0;
1442     }
1443   }
1444 }
1445 
1446 #ifndef PRODUCT
1447 int interval_cmp(Interval* const&amp; l, Interval* const&amp; r) {
1448   return l-&gt;from() - r-&gt;from();
1449 }
1450 
1451 bool find_interval(Interval* interval, IntervalArray* intervals) {
1452   bool found;
1453   int idx = intervals-&gt;find_sorted&lt;Interval*, interval_cmp&gt;(interval, found);
1454 
1455   if (!found) {
1456     return false;
1457   }
1458 
1459   int from = interval-&gt;from();
1460 
1461   // The index we&#39;ve found using binary search is pointing to an interval
1462   // that is defined in the same place as the interval we were looking for.
1463   // So now we have to look around that index and find exact interval.
1464   for (int i = idx; i &gt;= 0; i--) {
1465     if (intervals-&gt;at(i) == interval) {
1466       return true;
1467     }
1468     if (intervals-&gt;at(i)-&gt;from() != from) {
1469       break;
1470     }
1471   }
1472 
1473   for (int i = idx + 1; i &lt; intervals-&gt;length(); i++) {
1474     if (intervals-&gt;at(i) == interval) {
1475       return true;
1476     }
1477     if (intervals-&gt;at(i)-&gt;from() != from) {
1478       break;
1479     }
1480   }
1481 
1482   return false;
1483 }
1484 
1485 bool LinearScan::is_sorted(IntervalArray* intervals) {
1486   int from = -1;
1487   int null_count = 0;
1488 
1489   for (int i = 0; i &lt; intervals-&gt;length(); i++) {
1490     Interval* it = intervals-&gt;at(i);
1491     if (it != NULL) {
1492       assert(from &lt;= it-&gt;from(), &quot;Intervals are unordered&quot;);
1493       from = it-&gt;from();
1494     } else {
1495       null_count++;
1496     }
1497   }
1498 
1499   assert(null_count == 0, &quot;Sorted intervals should not contain nulls&quot;);
1500 
1501   null_count = 0;
1502 
1503   for (int i = 0; i &lt; interval_count(); i++) {
1504     Interval* interval = interval_at(i);
1505     if (interval != NULL) {
1506       assert(find_interval(interval, intervals), &quot;Lists do not contain same intervals&quot;);
1507     } else {
1508       null_count++;
1509     }
1510   }
1511 
1512   assert(interval_count() - null_count == intervals-&gt;length(),
1513       &quot;Sorted list should contain the same amount of non-NULL intervals as unsorted list&quot;);
1514 
1515   return true;
1516 }
1517 #endif
1518 
1519 void LinearScan::add_to_list(Interval** first, Interval** prev, Interval* interval) {
1520   if (*prev != NULL) {
1521     (*prev)-&gt;set_next(interval);
1522   } else {
1523     *first = interval;
1524   }
1525   *prev = interval;
1526 }
1527 
1528 void LinearScan::create_unhandled_lists(Interval** list1, Interval** list2, bool (is_list1)(const Interval* i), bool (is_list2)(const Interval* i)) {
1529   assert(is_sorted(_sorted_intervals), &quot;interval list is not sorted&quot;);
1530 
1531   *list1 = *list2 = Interval::end();
1532 
1533   Interval* list1_prev = NULL;
1534   Interval* list2_prev = NULL;
1535   Interval* v;
1536 
1537   const int n = _sorted_intervals-&gt;length();
1538   for (int i = 0; i &lt; n; i++) {
1539     v = _sorted_intervals-&gt;at(i);
1540     if (v == NULL) continue;
1541 
1542     if (is_list1(v)) {
1543       add_to_list(list1, &amp;list1_prev, v);
1544     } else if (is_list2 == NULL || is_list2(v)) {
1545       add_to_list(list2, &amp;list2_prev, v);
1546     }
1547   }
1548 
1549   if (list1_prev != NULL) list1_prev-&gt;set_next(Interval::end());
1550   if (list2_prev != NULL) list2_prev-&gt;set_next(Interval::end());
1551 
1552   assert(list1_prev == NULL || list1_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1553   assert(list2_prev == NULL || list2_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1554 }
1555 
1556 
1557 void LinearScan::sort_intervals_before_allocation() {
1558   TIME_LINEAR_SCAN(timer_sort_intervals_before);
1559 
1560   if (_needs_full_resort) {
1561     // There is no known reason why this should occur but just in case...
1562     assert(false, &quot;should never occur&quot;);
1563     // Re-sort existing interval list because an Interval::from() has changed
1564     _sorted_intervals-&gt;sort(interval_cmp);
1565     _needs_full_resort = false;
1566   }
1567 
1568   IntervalList* unsorted_list = &amp;_intervals;
1569   int unsorted_len = unsorted_list-&gt;length();
1570   int sorted_len = 0;
1571   int unsorted_idx;
1572   int sorted_idx = 0;
1573   int sorted_from_max = -1;
1574 
1575   // calc number of items for sorted list (sorted list must not contain NULL values)
1576   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1577     if (unsorted_list-&gt;at(unsorted_idx) != NULL) {
1578       sorted_len++;
1579     }
1580   }
1581   IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);
1582 
1583   // special sorting algorithm: the original interval-list is almost sorted,
1584   // only some intervals are swapped. So this is much faster than a complete QuickSort
1585   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1586     Interval* cur_interval = unsorted_list-&gt;at(unsorted_idx);
1587 
1588     if (cur_interval != NULL) {
1589       int cur_from = cur_interval-&gt;from();
1590 
1591       if (sorted_from_max &lt;= cur_from) {
1592         sorted_list-&gt;at_put(sorted_idx++, cur_interval);
1593         sorted_from_max = cur_interval-&gt;from();
1594       } else {
1595         // the asumption that the intervals are already sorted failed,
1596         // so this interval must be sorted in manually
1597         int j;
1598         for (j = sorted_idx - 1; j &gt;= 0 &amp;&amp; cur_from &lt; sorted_list-&gt;at(j)-&gt;from(); j--) {
1599           sorted_list-&gt;at_put(j + 1, sorted_list-&gt;at(j));
1600         }
1601         sorted_list-&gt;at_put(j + 1, cur_interval);
1602         sorted_idx++;
1603       }
1604     }
1605   }
1606   _sorted_intervals = sorted_list;
1607   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1608 }
1609 
1610 void LinearScan::sort_intervals_after_allocation() {
1611   TIME_LINEAR_SCAN(timer_sort_intervals_after);
1612 
1613   if (_needs_full_resort) {
1614     // Re-sort existing interval list because an Interval::from() has changed
1615     _sorted_intervals-&gt;sort(interval_cmp);
1616     _needs_full_resort = false;
1617   }
1618 
1619   IntervalArray* old_list = _sorted_intervals;
1620   IntervalList* new_list = _new_intervals_from_allocation;
1621   int old_len = old_list-&gt;length();
1622   int new_len = new_list == NULL ? 0 : new_list-&gt;length();
1623 
1624   if (new_len == 0) {
1625     // no intervals have been added during allocation, so sorted list is already up to date
1626     assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1627     return;
1628   }
1629 
1630   // conventional sort-algorithm for new intervals
1631   new_list-&gt;sort(interval_cmp);
1632 
1633   // merge old and new list (both already sorted) into one combined list
1634   int combined_list_len = old_len + new_len;
1635   IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);
1636   int old_idx = 0;
1637   int new_idx = 0;
1638 
1639   while (old_idx + new_idx &lt; old_len + new_len) {
1640     if (new_idx &gt;= new_len || (old_idx &lt; old_len &amp;&amp; old_list-&gt;at(old_idx)-&gt;from() &lt;= new_list-&gt;at(new_idx)-&gt;from())) {
1641       combined_list-&gt;at_put(old_idx + new_idx, old_list-&gt;at(old_idx));
1642       old_idx++;
1643     } else {
1644       combined_list-&gt;at_put(old_idx + new_idx, new_list-&gt;at(new_idx));
1645       new_idx++;
1646     }
1647   }
1648 
1649   _sorted_intervals = combined_list;
1650   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1651 }
1652 
1653 
1654 void LinearScan::allocate_registers() {
1655   TIME_LINEAR_SCAN(timer_allocate_registers);
1656 
1657   Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
1658   Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
1659 
1660   // allocate cpu registers
1661   create_unhandled_lists(&amp;precolored_cpu_intervals, &amp;not_precolored_cpu_intervals,
1662                          is_precolored_cpu_interval, is_virtual_cpu_interval);
1663 
1664   // allocate fpu registers
1665   create_unhandled_lists(&amp;precolored_fpu_intervals, &amp;not_precolored_fpu_intervals,
1666                          is_precolored_fpu_interval, is_virtual_fpu_interval);
1667 
1668   // the fpu interval allocation cannot be moved down below with the fpu section as
1669   // the cpu_lsw.walk() changes interval positions.
1670 
1671   LinearScanWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
1672   cpu_lsw.walk();
1673   cpu_lsw.finish_allocation();
1674 
1675   if (has_fpu_registers()) {
1676     LinearScanWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
1677     fpu_lsw.walk();
1678     fpu_lsw.finish_allocation();
1679   }
1680 }
1681 
1682 
1683 // ********** Phase 6: resolve data flow
1684 // (insert moves at edges between blocks if intervals have been split)
1685 
1686 // wrapper for Interval::split_child_at_op_id that performs a bailout in product mode
1687 // instead of returning NULL
1688 Interval* LinearScan::split_child_at_op_id(Interval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
1689   Interval* result = interval-&gt;split_child_at_op_id(op_id, mode);
1690   if (result != NULL) {
1691     return result;
1692   }
1693 
1694   assert(false, &quot;must find an interval, but do a clean bailout in product mode&quot;);
1695   result = new Interval(LIR_OprDesc::vreg_base);
1696   result-&gt;assign_reg(0);
1697   result-&gt;set_type(T_INT);
1698   BAILOUT_(&quot;LinearScan: interval is NULL&quot;, result);
1699 }
1700 
1701 
1702 Interval* LinearScan::interval_at_block_begin(BlockBegin* block, int reg_num) {
1703   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1704   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1705 
1706   return split_child_at_op_id(interval_at(reg_num), block-&gt;first_lir_instruction_id(), LIR_OpVisitState::outputMode);
1707 }
1708 
1709 Interval* LinearScan::interval_at_block_end(BlockBegin* block, int reg_num) {
1710   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1711   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1712 
1713   return split_child_at_op_id(interval_at(reg_num), block-&gt;last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
1714 }
1715 
1716 Interval* LinearScan::interval_at_op_id(int reg_num, int op_id) {
1717   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1718   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1719 
1720   return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
1721 }
1722 
1723 
1724 void LinearScan::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1725   DEBUG_ONLY(move_resolver.check_empty());
1726 
1727   const int size = live_set_size();
1728   const ResourceBitMap live_at_edge = to_block-&gt;live_in();
1729 
1730   // visit all registers where the live_at_edge bit is set
1731   for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
1732     assert(r &lt; num_virtual_regs(), &quot;live information set for not exisiting interval&quot;);
1733     assert(from_block-&gt;live_out().at(r) &amp;&amp; to_block-&gt;live_in().at(r), &quot;interval not live at this edge&quot;);
1734 
1735     Interval* from_interval = interval_at_block_end(from_block, r);
1736     Interval* to_interval = interval_at_block_begin(to_block, r);
1737 
1738     if (from_interval != to_interval &amp;&amp; (from_interval-&gt;assigned_reg() != to_interval-&gt;assigned_reg() || from_interval-&gt;assigned_regHi() != to_interval-&gt;assigned_regHi())) {
1739       // need to insert move instruction
1740       move_resolver.add_mapping(from_interval, to_interval);
1741     }
1742   }
1743 }
1744 
1745 
1746 void LinearScan::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1747   if (from_block-&gt;number_of_sux() &lt;= 1) {
1748     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at end of from_block B%d&quot;, from_block-&gt;block_id()));
1749 
1750     LIR_OpList* instructions = from_block-&gt;lir()-&gt;instructions_list();
1751     LIR_OpBranch* branch = instructions-&gt;last()-&gt;as_OpBranch();
1752     if (branch != NULL) {
1753       // insert moves before branch
1754       assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
1755       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 2);
1756     } else {
1757       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 1);
1758     }
1759 
1760   } else {
1761     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at beginning of to_block B%d&quot;, to_block-&gt;block_id()));
1762 #ifdef ASSERT
1763     assert(from_block-&gt;lir()-&gt;instructions_list()-&gt;at(0)-&gt;as_OpLabel() != NULL, &quot;block does not start with a label&quot;);
1764 
1765     // because the number of predecessor edges matches the number of
1766     // successor edges, blocks which are reached by switch statements
1767     // may have be more than one predecessor but it will be guaranteed
1768     // that all predecessors will be the same.
1769     for (int i = 0; i &lt; to_block-&gt;number_of_preds(); i++) {
1770       assert(from_block == to_block-&gt;pred_at(i), &quot;all critical edges must be broken&quot;);
1771     }
1772 #endif
1773 
1774     move_resolver.set_insert_position(to_block-&gt;lir(), 0);
1775   }
1776 }
1777 
1778 
1779 // insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
1780 void LinearScan::resolve_data_flow() {
1781   TIME_LINEAR_SCAN(timer_resolve_data_flow);
1782 
1783   int num_blocks = block_count();
1784   MoveResolver move_resolver(this);
1785   ResourceBitMap block_completed(num_blocks);
1786   ResourceBitMap already_resolved(num_blocks);
1787 
1788   int i;
1789   for (i = 0; i &lt; num_blocks; i++) {
1790     BlockBegin* block = block_at(i);
1791 
1792     // check if block has only one predecessor and only one successor
1793     if (block-&gt;number_of_preds() == 1 &amp;&amp; block-&gt;number_of_sux() == 1 &amp;&amp; block-&gt;number_of_exception_handlers() == 0) {
1794       LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1795       assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
1796       assert(instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successors must end with branch&quot;);
1797       assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block with successor must end with unconditional branch&quot;);
1798 
1799       // check if block is empty (only label and branch)
1800       if (instructions-&gt;length() == 2) {
1801         BlockBegin* pred = block-&gt;pred_at(0);
1802         BlockBegin* sux = block-&gt;sux_at(0);
1803 
1804         // prevent optimization of two consecutive blocks
1805         if (!block_completed.at(pred-&gt;linear_scan_number()) &amp;&amp; !block_completed.at(sux-&gt;linear_scan_number())) {
1806           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** optimizing empty block B%d (pred: B%d, sux: B%d)&quot;, block-&gt;block_id(), pred-&gt;block_id(), sux-&gt;block_id()));
1807           block_completed.set_bit(block-&gt;linear_scan_number());
1808 
1809           // directly resolve between pred and sux (without looking at the empty block between)
1810           resolve_collect_mappings(pred, sux, move_resolver);
1811           if (move_resolver.has_mappings()) {
1812             move_resolver.set_insert_position(block-&gt;lir(), 0);
1813             move_resolver.resolve_and_append_moves();
1814           }
1815         }
1816       }
1817     }
1818   }
1819 
1820 
1821   for (i = 0; i &lt; num_blocks; i++) {
1822     if (!block_completed.at(i)) {
1823       BlockBegin* from_block = block_at(i);
1824       already_resolved.set_from(block_completed);
1825 
1826       int num_sux = from_block-&gt;number_of_sux();
1827       for (int s = 0; s &lt; num_sux; s++) {
1828         BlockBegin* to_block = from_block-&gt;sux_at(s);
1829 
1830         // check for duplicate edges between the same blocks (can happen with switch blocks)
1831         if (!already_resolved.at(to_block-&gt;linear_scan_number())) {
1832           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** processing edge between B%d and B%d&quot;, from_block-&gt;block_id(), to_block-&gt;block_id()));
1833           already_resolved.set_bit(to_block-&gt;linear_scan_number());
1834 
1835           // collect all intervals that have been split between from_block and to_block
1836           resolve_collect_mappings(from_block, to_block, move_resolver);
1837           if (move_resolver.has_mappings()) {
1838             resolve_find_insert_pos(from_block, to_block, move_resolver);
1839             move_resolver.resolve_and_append_moves();
1840           }
1841         }
1842       }
1843     }
1844   }
1845 }
1846 
1847 
1848 void LinearScan::resolve_exception_entry(BlockBegin* block, int reg_num, MoveResolver &amp;move_resolver) {
1849   if (interval_at(reg_num) == NULL) {
1850     // if a phi function is never used, no interval is created -&gt; ignore this
1851     return;
1852   }
1853 
1854   Interval* interval = interval_at_block_begin(block, reg_num);
1855   int reg = interval-&gt;assigned_reg();
1856   int regHi = interval-&gt;assigned_regHi();
1857 
1858   if ((reg &lt; nof_regs &amp;&amp; interval-&gt;always_in_memory()) ||
1859       (use_fpu_stack_allocation() &amp;&amp; reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg)) {
1860     // the interval is split to get a short range that is located on the stack
1861     // in the following two cases:
1862     // * the interval started in memory (e.g. method parameter), but is currently in a register
1863     //   this is an optimization for exception handling that reduces the number of moves that
1864     //   are necessary for resolving the states when an exception uses this exception handler
1865     // * the interval would be on the fpu stack at the begin of the exception handler
1866     //   this is not allowed because of the complicated fpu stack handling on Intel
1867 
1868     // range that will be spilled to memory
1869     int from_op_id = block-&gt;first_lir_instruction_id();
1870     int to_op_id = from_op_id + 1;  // short live range of length 1
1871     assert(interval-&gt;from() &lt;= from_op_id &amp;&amp; interval-&gt;to() &gt;= to_op_id,
1872            &quot;no split allowed between exception entry and first instruction&quot;);
1873 
1874     if (interval-&gt;from() != from_op_id) {
1875       // the part before from_op_id is unchanged
1876       interval = interval-&gt;split(from_op_id);
1877       interval-&gt;assign_reg(reg, regHi);
1878       append_interval(interval);
1879     } else {
1880       _needs_full_resort = true;
1881     }
1882     assert(interval-&gt;from() == from_op_id, &quot;must be true now&quot;);
1883 
1884     Interval* spilled_part = interval;
1885     if (interval-&gt;to() != to_op_id) {
1886       // the part after to_op_id is unchanged
1887       spilled_part = interval-&gt;split_from_start(to_op_id);
1888       append_interval(spilled_part);
1889       move_resolver.add_mapping(spilled_part, interval);
1890     }
1891     assign_spill_slot(spilled_part);
1892 
1893     assert(spilled_part-&gt;from() == from_op_id &amp;&amp; spilled_part-&gt;to() == to_op_id, &quot;just checking&quot;);
1894   }
1895 }
1896 
1897 void LinearScan::resolve_exception_entry(BlockBegin* block, MoveResolver &amp;move_resolver) {
1898   assert(block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;should not call otherwise&quot;);
1899   DEBUG_ONLY(move_resolver.check_empty());
1900 
1901   // visit all registers where the live_in bit is set
1902   int size = live_set_size();
1903   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1904     resolve_exception_entry(block, r, move_resolver);
1905   }
1906 
1907   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1908   for_each_phi_fun(block, phi,
1909     if (!phi-&gt;is_illegal()) { resolve_exception_entry(block, phi-&gt;operand()-&gt;vreg_number(), move_resolver); }
1910   );
1911 
1912   if (move_resolver.has_mappings()) {
1913     // insert moves after first instruction
1914     move_resolver.set_insert_position(block-&gt;lir(), 0);
1915     move_resolver.resolve_and_append_moves();
1916   }
1917 }
1918 
1919 
1920 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, MoveResolver &amp;move_resolver) {
1921   if (interval_at(reg_num) == NULL) {
1922     // if a phi function is never used, no interval is created -&gt; ignore this
1923     return;
1924   }
1925 
1926   // the computation of to_interval is equal to resolve_collect_mappings,
1927   // but from_interval is more complicated because of phi functions
1928   BlockBegin* to_block = handler-&gt;entry_block();
1929   Interval* to_interval = interval_at_block_begin(to_block, reg_num);
1930 
1931   if (phi != NULL) {
1932     // phi function of the exception entry block
1933     // no moves are created for this phi function in the LIR_Generator, so the
1934     // interval at the throwing instruction must be searched using the operands
1935     // of the phi function
1936     Value from_value = phi-&gt;operand_at(handler-&gt;phi_operand());
1937 
1938     // with phi functions it can happen that the same from_value is used in
1939     // multiple mappings, so notify move-resolver that this is allowed
1940     move_resolver.set_multiple_reads_allowed();
1941 
1942     Constant* con = from_value-&gt;as_Constant();
1943     if (con != NULL &amp;&amp; !con-&gt;is_pinned()) {
1944       // unpinned constants may have no register, so add mapping from constant to interval
1945       move_resolver.add_mapping(LIR_OprFact::value_type(con-&gt;type()), to_interval);
1946     } else {
1947       // search split child at the throwing op_id
1948       Interval* from_interval = interval_at_op_id(from_value-&gt;operand()-&gt;vreg_number(), throwing_op_id);
1949       move_resolver.add_mapping(from_interval, to_interval);
1950     }
1951 
1952   } else {
1953     // no phi function, so use reg_num also for from_interval
1954     // search split child at the throwing op_id
1955     Interval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
1956     if (from_interval != to_interval) {
1957       // optimization to reduce number of moves: when to_interval is on stack and
1958       // the stack slot is known to be always correct, then no move is necessary
1959       if (!from_interval-&gt;always_in_memory() || from_interval-&gt;canonical_spill_slot() != to_interval-&gt;assigned_reg()) {
1960         move_resolver.add_mapping(from_interval, to_interval);
1961       }
1962     }
1963   }
1964 }
1965 
1966 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, MoveResolver &amp;move_resolver) {
1967   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;resolving exception handler B%d: throwing_op_id=%d&quot;, handler-&gt;entry_block()-&gt;block_id(), throwing_op_id));
1968 
1969   DEBUG_ONLY(move_resolver.check_empty());
1970   assert(handler-&gt;lir_op_id() == -1, &quot;already processed this xhandler&quot;);
1971   DEBUG_ONLY(handler-&gt;set_lir_op_id(throwing_op_id));
1972   assert(handler-&gt;entry_code() == NULL, &quot;code already present&quot;);
1973 
1974   // visit all registers where the live_in bit is set
1975   BlockBegin* block = handler-&gt;entry_block();
1976   int size = live_set_size();
1977   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1978     resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
1979   }
1980 
1981   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1982   for_each_phi_fun(block, phi,
1983     if (!phi-&gt;is_illegal()) { resolve_exception_edge(handler, throwing_op_id, phi-&gt;operand()-&gt;vreg_number(), phi, move_resolver); }
1984   );
1985 
1986   if (move_resolver.has_mappings()) {
1987     LIR_List* entry_code = new LIR_List(compilation());
1988     move_resolver.set_insert_position(entry_code, 0);
1989     move_resolver.resolve_and_append_moves();
1990 
1991     entry_code-&gt;jump(handler-&gt;entry_block());
1992     handler-&gt;set_entry_code(entry_code);
1993   }
1994 }
1995 
1996 
1997 void LinearScan::resolve_exception_handlers() {
1998   MoveResolver move_resolver(this);
1999   LIR_OpVisitState visitor;
2000   int num_blocks = block_count();
2001 
2002   int i;
2003   for (i = 0; i &lt; num_blocks; i++) {
2004     BlockBegin* block = block_at(i);
2005     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
2006       resolve_exception_entry(block, move_resolver);
2007     }
2008   }
2009 
2010   for (i = 0; i &lt; num_blocks; i++) {
2011     BlockBegin* block = block_at(i);
2012     LIR_List* ops = block-&gt;lir();
2013     int num_ops = ops-&gt;length();
2014 
2015     // iterate all instructions of the block. skip the first because it is always a label
2016     assert(visitor.no_operands(ops-&gt;at(0)), &quot;first operation must always be a label&quot;);
2017     for (int j = 1; j &lt; num_ops; j++) {
2018       LIR_Op* op = ops-&gt;at(j);
2019       int op_id = op-&gt;id();
2020 
2021       if (op_id != -1 &amp;&amp; has_info(op_id)) {
2022         // visit operation to collect all operands
2023         visitor.visit(op);
2024         assert(visitor.info_count() &gt; 0, &quot;should not visit otherwise&quot;);
2025 
2026         XHandlers* xhandlers = visitor.all_xhandler();
2027         int n = xhandlers-&gt;length();
2028         for (int k = 0; k &lt; n; k++) {
2029           resolve_exception_edge(xhandlers-&gt;handler_at(k), op_id, move_resolver);
2030         }
2031 
2032 #ifdef ASSERT
2033       } else {
2034         visitor.visit(op);
2035         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
2036 #endif
2037       }
2038     }
2039   }
2040 }
2041 
2042 
2043 // ********** Phase 7: assign register numbers back to LIR
2044 // (includes computation of debug information and oop maps)
2045 
2046 VMReg LinearScan::vm_reg_for_interval(Interval* interval) {
2047   VMReg reg = interval-&gt;cached_vm_reg();
2048   if (!reg-&gt;is_valid() ) {
2049     reg = vm_reg_for_operand(operand_for_interval(interval));
2050     interval-&gt;set_cached_vm_reg(reg);
2051   }
2052   assert(reg == vm_reg_for_operand(operand_for_interval(interval)), &quot;wrong cached value&quot;);
2053   return reg;
2054 }
2055 
2056 VMReg LinearScan::vm_reg_for_operand(LIR_Opr opr) {
2057   assert(opr-&gt;is_oop(), &quot;currently only implemented for oop operands&quot;);
2058   return frame_map()-&gt;regname(opr);
2059 }
2060 
2061 
2062 LIR_Opr LinearScan::operand_for_interval(Interval* interval) {
2063   LIR_Opr opr = interval-&gt;cached_opr();
2064   if (opr-&gt;is_illegal()) {
2065     opr = calc_operand_for_interval(interval);
2066     interval-&gt;set_cached_opr(opr);
2067   }
2068 
2069   assert(opr == calc_operand_for_interval(interval), &quot;wrong cached value&quot;);
2070   return opr;
2071 }
2072 
2073 LIR_Opr LinearScan::calc_operand_for_interval(const Interval* interval) {
2074   int assigned_reg = interval-&gt;assigned_reg();
2075   BasicType type = interval-&gt;type();
2076 
2077   if (assigned_reg &gt;= nof_regs) {
2078     // stack slot
2079     assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2080     return LIR_OprFact::stack(assigned_reg - nof_regs, type);
2081 
2082   } else {
2083     // register
2084     switch (type) {
2085       case T_OBJECT: {
2086         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2087         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2088         return LIR_OprFact::single_cpu_oop(assigned_reg);
2089       }
2090 
2091       case T_ADDRESS: {
2092         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2093         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2094         return LIR_OprFact::single_cpu_address(assigned_reg);
2095       }
2096 
2097       case T_METADATA: {
2098         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2099         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2100         return LIR_OprFact::single_cpu_metadata(assigned_reg);
2101       }
2102 
2103 #ifdef __SOFTFP__
2104       case T_FLOAT:  // fall through
2105 #endif // __SOFTFP__
2106       case T_INT: {
2107         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2108         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2109         return LIR_OprFact::single_cpu(assigned_reg);
2110       }
2111 
2112 #ifdef __SOFTFP__
2113       case T_DOUBLE:  // fall through
2114 #endif // __SOFTFP__
2115       case T_LONG: {
2116         int assigned_regHi = interval-&gt;assigned_regHi();
2117         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2118         assert(num_physical_regs(T_LONG) == 1 ||
2119                (assigned_regHi &gt;= pd_first_cpu_reg &amp;&amp; assigned_regHi &lt;= pd_last_cpu_reg), &quot;no cpu register&quot;);
2120 
2121         assert(assigned_reg != assigned_regHi, &quot;invalid allocation&quot;);
2122         assert(num_physical_regs(T_LONG) == 1 || assigned_reg &lt; assigned_regHi,
2123                &quot;register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)&quot;);
2124         assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), &quot;must be match&quot;);
2125         if (requires_adjacent_regs(T_LONG)) {
2126           assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == assigned_regHi, &quot;must be sequential and even&quot;);
2127         }
2128 
2129 #ifdef _LP64
2130         return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
2131 #else
2132 #if defined(PPC32)
2133         return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
2134 #else
2135         return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
2136 #endif // PPC32
2137 #endif // LP64
2138       }
2139 
2140 #ifndef __SOFTFP__
2141       case T_FLOAT: {
2142 #ifdef X86
2143         if (UseSSE &gt;= 1) {
2144           int last_xmm_reg = pd_last_xmm_reg;
2145 #ifdef _LP64
2146           if (UseAVX &lt; 3) {
2147             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2148           }
2149 #endif // LP64
2150           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2151           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2152           return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
2153         }
2154 #endif // X86
2155 
2156         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2157         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2158         return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
2159       }
2160 
2161       case T_DOUBLE: {
2162 #ifdef X86
2163         if (UseSSE &gt;= 2) {
2164           int last_xmm_reg = pd_last_xmm_reg;
2165 #ifdef _LP64
2166           if (UseAVX &lt; 3) {
2167             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2168           }
2169 #endif // LP64
2170           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2171           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double xmm values are stored in one register)&quot;);
2172           return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
2173         }
2174 #endif // X86
2175 
2176 #if defined(ARM32)
2177         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2178         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2179         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2180         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval-&gt;assigned_regHi() - pd_first_fpu_reg);
2181 #else
2182         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2183         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double fpu values are stored in one register on Intel)&quot;);
2184         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
2185 #endif
2186         return result;
2187       }
2188 #endif // __SOFTFP__
2189 
2190       default: {
2191         ShouldNotReachHere();
2192         return LIR_OprFact::illegalOpr;
2193       }
2194     }
2195   }
2196 }
2197 
2198 LIR_Opr LinearScan::canonical_spill_opr(Interval* interval) {
2199   assert(interval-&gt;canonical_spill_slot() &gt;= nof_regs, &quot;canonical spill slot not set&quot;);
2200   return LIR_OprFact::stack(interval-&gt;canonical_spill_slot() - nof_regs, interval-&gt;type());
2201 }
2202 
2203 LIR_Opr LinearScan::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
2204   assert(opr-&gt;is_virtual(), &quot;should not call this otherwise&quot;);
2205 
2206   Interval* interval = interval_at(opr-&gt;vreg_number());
2207   assert(interval != NULL, &quot;interval must exist&quot;);
2208 
2209   if (op_id != -1) {
2210 #ifdef ASSERT
2211     BlockBegin* block = block_of_op_with_id(op_id);
2212     if (block-&gt;number_of_sux() &lt;= 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2213       // check if spill moves could have been appended at the end of this block, but
2214       // before the branch instruction. So the split child information for this branch would
2215       // be incorrect.
2216       LIR_OpBranch* branch = block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch();
2217       if (branch != NULL) {
2218         if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2219           assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
2220           assert(false, &quot;can&#39;t get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)&quot;);
2221         }
2222       }
2223     }
2224 #endif
2225 
2226     // operands are not changed when an interval is split during allocation,
2227     // so search the right interval here
2228     interval = split_child_at_op_id(interval, op_id, mode);
2229   }
2230 
2231   LIR_Opr res = operand_for_interval(interval);
2232 
2233 #ifdef X86
2234   // new semantic for is_last_use: not only set on definite end of interval,
2235   // but also before hole
2236   // This may still miss some cases (e.g. for dead values), but it is not necessary that the
2237   // last use information is completely correct
2238   // information is only needed for fpu stack allocation
2239   if (res-&gt;is_fpu_register()) {
2240     if (opr-&gt;is_last_use() || op_id == interval-&gt;to() || (op_id != -1 &amp;&amp; interval-&gt;has_hole_between(op_id, op_id + 1))) {
2241       assert(op_id == -1 || !is_block_begin(op_id), &quot;holes at begin of block may also result from control flow&quot;);
2242       res = res-&gt;make_last_use();
2243     }
2244   }
2245 #endif
2246 
2247   assert(!gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), &quot;bad allocation&quot;);
2248 
2249   return res;
2250 }
2251 
2252 
2253 #ifdef ASSERT
2254 // some methods used to check correctness of debug information
2255 
2256 void assert_no_register_values(GrowableArray&lt;ScopeValue*&gt;* values) {
2257   if (values == NULL) {
2258     return;
2259   }
2260 
2261   for (int i = 0; i &lt; values-&gt;length(); i++) {
2262     ScopeValue* value = values-&gt;at(i);
2263 
2264     if (value-&gt;is_location()) {
2265       Location location = ((LocationValue*)value)-&gt;location();
2266       assert(location.where() == Location::on_stack, &quot;value is in register&quot;);
2267     }
2268   }
2269 }
2270 
2271 void assert_no_register_values(GrowableArray&lt;MonitorValue*&gt;* values) {
2272   if (values == NULL) {
2273     return;
2274   }
2275 
2276   for (int i = 0; i &lt; values-&gt;length(); i++) {
2277     MonitorValue* value = values-&gt;at(i);
2278 
2279     if (value-&gt;owner()-&gt;is_location()) {
2280       Location location = ((LocationValue*)value-&gt;owner())-&gt;location();
2281       assert(location.where() == Location::on_stack, &quot;owner is in register&quot;);
2282     }
2283     assert(value-&gt;basic_lock().where() == Location::on_stack, &quot;basic_lock is in register&quot;);
2284   }
2285 }
2286 
2287 void assert_equal(Location l1, Location l2) {
2288   assert(l1.where() == l2.where() &amp;&amp; l1.type() == l2.type() &amp;&amp; l1.offset() == l2.offset(), &quot;&quot;);
2289 }
2290 
2291 void assert_equal(ScopeValue* v1, ScopeValue* v2) {
2292   if (v1-&gt;is_location()) {
2293     assert(v2-&gt;is_location(), &quot;&quot;);
2294     assert_equal(((LocationValue*)v1)-&gt;location(), ((LocationValue*)v2)-&gt;location());
2295   } else if (v1-&gt;is_constant_int()) {
2296     assert(v2-&gt;is_constant_int(), &quot;&quot;);
2297     assert(((ConstantIntValue*)v1)-&gt;value() == ((ConstantIntValue*)v2)-&gt;value(), &quot;&quot;);
2298   } else if (v1-&gt;is_constant_double()) {
2299     assert(v2-&gt;is_constant_double(), &quot;&quot;);
2300     assert(((ConstantDoubleValue*)v1)-&gt;value() == ((ConstantDoubleValue*)v2)-&gt;value(), &quot;&quot;);
2301   } else if (v1-&gt;is_constant_long()) {
2302     assert(v2-&gt;is_constant_long(), &quot;&quot;);
2303     assert(((ConstantLongValue*)v1)-&gt;value() == ((ConstantLongValue*)v2)-&gt;value(), &quot;&quot;);
2304   } else if (v1-&gt;is_constant_oop()) {
2305     assert(v2-&gt;is_constant_oop(), &quot;&quot;);
2306     assert(((ConstantOopWriteValue*)v1)-&gt;value() == ((ConstantOopWriteValue*)v2)-&gt;value(), &quot;&quot;);
2307   } else {
2308     ShouldNotReachHere();
2309   }
2310 }
2311 
2312 void assert_equal(MonitorValue* m1, MonitorValue* m2) {
2313   assert_equal(m1-&gt;owner(), m2-&gt;owner());
2314   assert_equal(m1-&gt;basic_lock(), m2-&gt;basic_lock());
2315 }
2316 
2317 void assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
2318   assert(d1-&gt;scope() == d2-&gt;scope(), &quot;not equal&quot;);
2319   assert(d1-&gt;bci() == d2-&gt;bci(), &quot;not equal&quot;);
2320 
2321   if (d1-&gt;locals() != NULL) {
2322     assert(d1-&gt;locals() != NULL &amp;&amp; d2-&gt;locals() != NULL, &quot;not equal&quot;);
2323     assert(d1-&gt;locals()-&gt;length() == d2-&gt;locals()-&gt;length(), &quot;not equal&quot;);
2324     for (int i = 0; i &lt; d1-&gt;locals()-&gt;length(); i++) {
2325       assert_equal(d1-&gt;locals()-&gt;at(i), d2-&gt;locals()-&gt;at(i));
2326     }
2327   } else {
2328     assert(d1-&gt;locals() == NULL &amp;&amp; d2-&gt;locals() == NULL, &quot;not equal&quot;);
2329   }
2330 
2331   if (d1-&gt;expressions() != NULL) {
2332     assert(d1-&gt;expressions() != NULL &amp;&amp; d2-&gt;expressions() != NULL, &quot;not equal&quot;);
2333     assert(d1-&gt;expressions()-&gt;length() == d2-&gt;expressions()-&gt;length(), &quot;not equal&quot;);
2334     for (int i = 0; i &lt; d1-&gt;expressions()-&gt;length(); i++) {
2335       assert_equal(d1-&gt;expressions()-&gt;at(i), d2-&gt;expressions()-&gt;at(i));
2336     }
2337   } else {
2338     assert(d1-&gt;expressions() == NULL &amp;&amp; d2-&gt;expressions() == NULL, &quot;not equal&quot;);
2339   }
2340 
2341   if (d1-&gt;monitors() != NULL) {
2342     assert(d1-&gt;monitors() != NULL &amp;&amp; d2-&gt;monitors() != NULL, &quot;not equal&quot;);
2343     assert(d1-&gt;monitors()-&gt;length() == d2-&gt;monitors()-&gt;length(), &quot;not equal&quot;);
2344     for (int i = 0; i &lt; d1-&gt;monitors()-&gt;length(); i++) {
2345       assert_equal(d1-&gt;monitors()-&gt;at(i), d2-&gt;monitors()-&gt;at(i));
2346     }
2347   } else {
2348     assert(d1-&gt;monitors() == NULL &amp;&amp; d2-&gt;monitors() == NULL, &quot;not equal&quot;);
2349   }
2350 
2351   if (d1-&gt;caller() != NULL) {
2352     assert(d1-&gt;caller() != NULL &amp;&amp; d2-&gt;caller() != NULL, &quot;not equal&quot;);
2353     assert_equal(d1-&gt;caller(), d2-&gt;caller());
2354   } else {
2355     assert(d1-&gt;caller() == NULL &amp;&amp; d2-&gt;caller() == NULL, &quot;not equal&quot;);
2356   }
2357 }
2358 
2359 void check_stack_depth(CodeEmitInfo* info, int stack_end) {
2360   if (info-&gt;stack()-&gt;bci() != SynchronizationEntryBCI &amp;&amp; !info-&gt;scope()-&gt;method()-&gt;is_native()) {
2361     Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
2362     switch (code) {
2363       case Bytecodes::_ifnull    : // fall through
2364       case Bytecodes::_ifnonnull : // fall through
2365       case Bytecodes::_ifeq      : // fall through
2366       case Bytecodes::_ifne      : // fall through
2367       case Bytecodes::_iflt      : // fall through
2368       case Bytecodes::_ifge      : // fall through
2369       case Bytecodes::_ifgt      : // fall through
2370       case Bytecodes::_ifle      : // fall through
2371       case Bytecodes::_if_icmpeq : // fall through
2372       case Bytecodes::_if_icmpne : // fall through
2373       case Bytecodes::_if_icmplt : // fall through
2374       case Bytecodes::_if_icmpge : // fall through
2375       case Bytecodes::_if_icmpgt : // fall through
2376       case Bytecodes::_if_icmple : // fall through
2377       case Bytecodes::_if_acmpeq : // fall through
2378       case Bytecodes::_if_acmpne :
2379         assert(stack_end &gt;= -Bytecodes::depth(code), &quot;must have non-empty expression stack at if bytecode&quot;);
2380         break;
2381       default:
2382         break;
2383     }
2384   }
2385 }
2386 
2387 #endif // ASSERT
2388 
2389 
2390 IntervalWalker* LinearScan::init_compute_oop_maps() {
2391   // setup lists of potential oops for walking
2392   Interval* oop_intervals;
2393   Interval* non_oop_intervals;
2394 
2395   create_unhandled_lists(&amp;oop_intervals, &amp;non_oop_intervals, is_oop_interval, NULL);
2396 
2397   // intervals that have no oops inside need not to be processed
2398   // to ensure a walking until the last instruction id, add a dummy interval
2399   // with a high operation id
2400   non_oop_intervals = new Interval(any_reg);
2401   non_oop_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
2402 
2403   return new IntervalWalker(this, oop_intervals, non_oop_intervals);
2404 }
2405 
2406 
2407 OopMap* LinearScan::compute_oop_map(IntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
2408   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating oop map at op_id %d&quot;, op-&gt;id()));
2409 
2410   // walk before the current operation -&gt; intervals that start at
2411   // the operation (= output operands of the operation) are not
2412   // included in the oop map
2413   iw-&gt;walk_before(op-&gt;id());
2414 
2415   int frame_size = frame_map()-&gt;framesize();
2416   int arg_count = frame_map()-&gt;oop_map_arg_count();
2417   OopMap* map = new OopMap(frame_size, arg_count);
2418 
2419   // Iterate through active intervals
2420   for (Interval* interval = iw-&gt;active_first(fixedKind); interval != Interval::end(); interval = interval-&gt;next()) {
2421     int assigned_reg = interval-&gt;assigned_reg();
2422 
2423     assert(interval-&gt;current_from() &lt;= op-&gt;id() &amp;&amp; op-&gt;id() &lt;= interval-&gt;current_to(), &quot;interval should not be active otherwise&quot;);
2424     assert(interval-&gt;assigned_regHi() == any_reg, &quot;oop must be single word&quot;);
2425     assert(interval-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base, &quot;fixed interval found&quot;);
2426 
2427     // Check if this range covers the instruction. Intervals that
2428     // start or end at the current operation are not included in the
2429     // oop map, except in the case of patching moves.  For patching
2430     // moves, any intervals which end at this instruction are included
2431     // in the oop map since we may safepoint while doing the patch
2432     // before we&#39;ve consumed the inputs.
2433     if (op-&gt;is_patching() || op-&gt;id() &lt; interval-&gt;current_to()) {
2434 
2435       // caller-save registers must not be included into oop-maps at calls
2436       assert(!is_call_site || assigned_reg &gt;= nof_regs || !is_caller_save(assigned_reg), &quot;interval is in a caller-save register at a call -&gt; register will be overwritten&quot;);
2437 
2438       VMReg name = vm_reg_for_interval(interval);
2439       set_oop(map, name);
2440 
2441       // Spill optimization: when the stack value is guaranteed to be always correct,
2442       // then it must be added to the oop map even if the interval is currently in a register
2443       if (interval-&gt;always_in_memory() &amp;&amp;
2444           op-&gt;id() &gt; interval-&gt;spill_definition_pos() &amp;&amp;
2445           interval-&gt;assigned_reg() != interval-&gt;canonical_spill_slot()) {
2446         assert(interval-&gt;spill_definition_pos() &gt; 0, &quot;position not set correctly&quot;);
2447         assert(interval-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;no spill slot assigned&quot;);
2448         assert(interval-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;interval is on stack, so stack slot is registered twice&quot;);
2449 
2450         set_oop(map, frame_map()-&gt;slot_regname(interval-&gt;canonical_spill_slot() - LinearScan::nof_regs));
2451       }
2452     }
2453   }
2454 
2455   // add oops from lock stack
2456   assert(info-&gt;stack() != NULL, &quot;CodeEmitInfo must always have a stack&quot;);
2457   int locks_count = info-&gt;stack()-&gt;total_locks_size();
2458   for (int i = 0; i &lt; locks_count; i++) {
2459     set_oop(map, frame_map()-&gt;monitor_object_regname(i));
2460   }
2461 
2462   return map;
2463 }
2464 
2465 
2466 void LinearScan::compute_oop_map(IntervalWalker* iw, const LIR_OpVisitState &amp;visitor, LIR_Op* op) {
2467   assert(visitor.info_count() &gt; 0, &quot;no oop map needed&quot;);
2468 
2469   // compute oop_map only for first CodeEmitInfo
2470   // because it is (in most cases) equal for all other infos of the same operation
2471   CodeEmitInfo* first_info = visitor.info_at(0);
2472   OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
2473 
2474   for (int i = 0; i &lt; visitor.info_count(); i++) {
2475     CodeEmitInfo* info = visitor.info_at(i);
2476     OopMap* oop_map = first_oop_map;
2477 
2478     // compute worst case interpreter size in case of a deoptimization
2479     _compilation-&gt;update_interpreter_frame_size(info-&gt;interpreter_frame_size());
2480 
2481     if (info-&gt;stack()-&gt;locks_size() != first_info-&gt;stack()-&gt;locks_size()) {
2482       // this info has a different number of locks then the precomputed oop map
2483       // (possible for lock and unlock instructions) -&gt; compute oop map with
2484       // correct lock information
2485       oop_map = compute_oop_map(iw, op, info, visitor.has_call());
2486     }
2487 
2488     if (info-&gt;_oop_map == NULL) {
2489       info-&gt;_oop_map = oop_map;
2490     } else {
2491       // a CodeEmitInfo can not be shared between different LIR-instructions
2492       // because interval splitting can occur anywhere between two instructions
2493       // and so the oop maps must be different
2494       // -&gt; check if the already set oop_map is exactly the one calculated for this operation
2495       assert(info-&gt;_oop_map == oop_map, &quot;same CodeEmitInfo used for multiple LIR instructions&quot;);
2496     }
2497   }
2498 }
2499 
2500 
2501 // frequently used constants
2502 // Allocate them with new so they are never destroyed (otherwise, a
2503 // forced exit could destroy these objects while they are still in
2504 // use).
2505 ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
2506 ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
2507 ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);
2508 ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
2509 ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
2510 LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
2511 
2512 void LinearScan::init_compute_debug_info() {
2513   // cache for frequently used scope values
2514   // (cpu registers and stack slots)
2515   int cache_size = (LinearScan::nof_cpu_regs + frame_map()-&gt;argcount() + max_spills()) * 2;
2516   _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);
2517 }
2518 
2519 MonitorValue* LinearScan::location_for_monitor_index(int monitor_index) {
2520   Location loc;
2521   if (!frame_map()-&gt;location_for_monitor_object(monitor_index, &amp;loc)) {
2522     bailout(&quot;too large frame&quot;);
2523   }
2524   ScopeValue* object_scope_value = new LocationValue(loc);
2525 
2526   if (!frame_map()-&gt;location_for_monitor_lock(monitor_index, &amp;loc)) {
2527     bailout(&quot;too large frame&quot;);
2528   }
2529   return new MonitorValue(object_scope_value, loc);
2530 }
2531 
2532 LocationValue* LinearScan::location_for_name(int name, Location::Type loc_type) {
2533   Location loc;
2534   if (!frame_map()-&gt;locations_for_slot(name, loc_type, &amp;loc)) {
2535     bailout(&quot;too large frame&quot;);
2536   }
2537   return new LocationValue(loc);
2538 }
2539 
2540 
2541 int LinearScan::append_scope_value_for_constant(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2542   assert(opr-&gt;is_constant(), &quot;should not be called otherwise&quot;);
2543 
2544   LIR_Const* c = opr-&gt;as_constant_ptr();
2545   BasicType t = c-&gt;type();
2546   switch (t) {
2547     case T_OBJECT: {
2548       jobject value = c-&gt;as_jobject();
2549       if (value == NULL) {
2550         scope_values-&gt;append(_oop_null_scope_value);
2551       } else {
2552         scope_values-&gt;append(new ConstantOopWriteValue(c-&gt;as_jobject()));
2553       }
2554       return 1;
2555     }
2556 
2557     case T_INT: // fall through
2558     case T_FLOAT: {
2559       int value = c-&gt;as_jint_bits();
2560       switch (value) {
2561         case -1: scope_values-&gt;append(_int_m1_scope_value); break;
2562         case 0:  scope_values-&gt;append(_int_0_scope_value); break;
2563         case 1:  scope_values-&gt;append(_int_1_scope_value); break;
2564         case 2:  scope_values-&gt;append(_int_2_scope_value); break;
2565         default: scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_bits())); break;
2566       }
2567       return 1;
2568     }
2569 
2570     case T_LONG: // fall through
2571     case T_DOUBLE: {
2572 #ifdef _LP64
2573       scope_values-&gt;append(_int_0_scope_value);
2574       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jlong_bits()));
2575 #else
2576       if (hi_word_offset_in_bytes &gt; lo_word_offset_in_bytes) {
2577         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2578         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2579       } else {
2580         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2581         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2582       }
2583 #endif
2584       return 2;
2585     }
2586 
2587     case T_ADDRESS: {
2588 #ifdef _LP64
2589       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jint()));
2590 #else
2591       scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint()));
2592 #endif
2593       return 1;
2594     }
2595 
2596     default:
2597       ShouldNotReachHere();
2598       return -1;
2599   }
2600 }
2601 
2602 int LinearScan::append_scope_value_for_operand(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2603   if (opr-&gt;is_single_stack()) {
2604     int stack_idx = opr-&gt;single_stack_ix();
2605     bool is_oop = opr-&gt;is_oop_register();
2606     int cache_idx = (stack_idx + LinearScan::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
2607 
2608     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2609     if (sv == NULL) {
2610       Location::Type loc_type = is_oop ? Location::oop : Location::normal;
2611       sv = location_for_name(stack_idx, loc_type);
2612       _scope_value_cache.at_put(cache_idx, sv);
2613     }
2614 
2615     // check if cached value is correct
2616     DEBUG_ONLY(assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
2617 
2618     scope_values-&gt;append(sv);
2619     return 1;
2620 
2621   } else if (opr-&gt;is_single_cpu()) {
2622     bool is_oop = opr-&gt;is_oop_register();
2623     int cache_idx = opr-&gt;cpu_regnr() * 2 + (is_oop ? 1 : 0);
2624     Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
2625 
2626     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2627     if (sv == NULL) {
2628       Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
2629       VMReg rname = frame_map()-&gt;regname(opr);
2630       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2631       _scope_value_cache.at_put(cache_idx, sv);
2632     }
2633 
2634     // check if cached value is correct
2635     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2636 
2637     scope_values-&gt;append(sv);
2638     return 1;
2639 
2640 #ifdef X86
2641   } else if (opr-&gt;is_single_xmm()) {
2642     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2643     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2644 
2645     scope_values-&gt;append(sv);
2646     return 1;
2647 #endif
2648 
2649   } else if (opr-&gt;is_single_fpu()) {
2650 #ifdef IA32
2651     // the exact location of fpu stack values is only known
2652     // during fpu stack allocation, so the stack allocator object
2653     // must be present
2654     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2655     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2656     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2657 #elif defined(AMD64)
2658     assert(false, &quot;FPU not used on x86-64&quot;);
2659 #endif
2660 
2661     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2662     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2663 #ifndef __SOFTFP__
2664 #ifndef VM_LITTLE_ENDIAN
2665     // On S390 a (single precision) float value occupies only the high
2666     // word of the full double register. So when the double register is
2667     // stored to memory (e.g. by the RegisterSaver), then the float value
2668     // is found at offset 0. I.e. the code below is not needed on S390.
2669 #ifndef S390
2670     if (! float_saved_as_double) {
2671       // On big endian system, we may have an issue if float registers use only
2672       // the low half of the (same) double registers.
2673       // Both the float and the double could have the same regnr but would correspond
2674       // to two different addresses once saved.
2675 
2676       // get next safely (no assertion checks)
2677       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2678       if (next-&gt;is_reg() &amp;&amp;
2679           (next-&gt;as_FloatRegister() == rname-&gt;as_FloatRegister())) {
2680         // the back-end does use the same numbering for the double and the float
2681         rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
2682       }
2683     }
2684 #endif // !S390
2685 #endif
2686 #endif
2687     LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2688 
2689     scope_values-&gt;append(sv);
2690     return 1;
2691 
2692   } else {
2693     // double-size operands
2694 
2695     ScopeValue* first;
2696     ScopeValue* second;
2697 
2698     if (opr-&gt;is_double_stack()) {
2699 #ifdef _LP64
2700       Location loc1;
2701       Location::Type loc_type = opr-&gt;type() == T_LONG ? Location::lng : Location::dbl;
2702       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), loc_type, &amp;loc1, NULL)) {
2703         bailout(&quot;too large frame&quot;);
2704       }
2705       // Does this reverse on x86 vs. sparc?
2706       first =  new LocationValue(loc1);
2707       second = _int_0_scope_value;
2708 #else
2709       Location loc1, loc2;
2710       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), Location::normal, &amp;loc1, &amp;loc2)) {
2711         bailout(&quot;too large frame&quot;);
2712       }
2713       first =  new LocationValue(loc1);
2714       second = new LocationValue(loc2);
2715 #endif // _LP64
2716 
2717     } else if (opr-&gt;is_double_cpu()) {
2718 #ifdef _LP64
2719       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2720       first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
2721       second = _int_0_scope_value;
2722 #else
2723       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2724       VMReg rname_second = opr-&gt;as_register_hi()-&gt;as_VMReg();
2725 
2726       if (hi_word_offset_in_bytes &lt; lo_word_offset_in_bytes) {
2727         // lo/hi and swapped relative to first and second, so swap them
2728         VMReg tmp = rname_first;
2729         rname_first = rname_second;
2730         rname_second = tmp;
2731       }
2732 
2733       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2734       second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2735 #endif //_LP64
2736 
2737 
2738 #ifdef X86
2739     } else if (opr-&gt;is_double_xmm()) {
2740       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation&quot;);
2741       VMReg rname_first  = opr-&gt;as_xmm_double_reg()-&gt;as_VMReg();
2742 #  ifdef _LP64
2743       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2744       second = _int_0_scope_value;
2745 #  else
2746       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2747       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2748       if (true) {
2749         VMReg rname_second = rname_first-&gt;next();
2750         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2751       }
2752 #  endif
2753 #endif
2754 
2755     } else if (opr-&gt;is_double_fpu()) {
2756       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2757       // the double as float registers in the native ordering. On X86,
2758       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2759       // the low-order word of the double and fpu_regnrLo + 1 is the
2760       // name for the other half.  *first and *second must represent the
2761       // least and most significant words, respectively.
2762 
2763 #ifdef IA32
2764       // the exact location of fpu stack values is only known
2765       // during fpu stack allocation, so the stack allocator object
2766       // must be present
2767       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2768       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2769       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2770 
2771       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2772 #endif
2773 #ifdef AMD64
2774       assert(false, &quot;FPU not used on x86-64&quot;);
2775 #endif
2776 #ifdef ARM32
2777       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2778 #endif
2779 #ifdef PPC32
2780       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2781 #endif
2782 
2783 #ifdef VM_LITTLE_ENDIAN
2784       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2785 #else
2786       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2787 #endif
2788 
2789 #ifdef _LP64
2790       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2791       second = _int_0_scope_value;
2792 #else
2793       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2794       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2795       if (true) {
2796         VMReg rname_second = rname_first-&gt;next();
2797         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2798       }
2799 #endif
2800 
2801     } else {
2802       ShouldNotReachHere();
2803       first = NULL;
2804       second = NULL;
2805     }
2806 
2807     assert(first != NULL &amp;&amp; second != NULL, &quot;must be set&quot;);
2808     // The convention the interpreter uses is that the second local
2809     // holds the first raw word of the native double representation.
2810     // This is actually reasonable, since locals and stack arrays
2811     // grow downwards in all implementations.
2812     // (If, on some machine, the interpreter&#39;s Java locals or stack
2813     // were to grow upwards, the embedded doubles would be word-swapped.)
2814     scope_values-&gt;append(second);
2815     scope_values-&gt;append(first);
2816     return 2;
2817   }
2818 }
2819 
2820 
2821 int LinearScan::append_scope_value(int op_id, Value value, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2822   if (value != NULL) {
2823     LIR_Opr opr = value-&gt;operand();
2824     Constant* con = value-&gt;as_Constant();
2825 
2826     assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)&quot;);
2827     assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
2828 
2829     if (con != NULL &amp;&amp; !con-&gt;is_pinned() &amp;&amp; !opr-&gt;is_constant()) {
2830       // Unpinned constants may have a virtual operand for a part of the lifetime
2831       // or may be illegal when it was optimized away,
2832       // so always use a constant operand
2833       opr = LIR_OprFact::value_type(con-&gt;type());
2834     }
2835     assert(opr-&gt;is_virtual() || opr-&gt;is_constant(), &quot;other cases not allowed here&quot;);
2836 
2837     if (opr-&gt;is_virtual()) {
2838       LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
2839 
2840       BlockBegin* block = block_of_op_with_id(op_id);
2841       if (block-&gt;number_of_sux() == 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2842         // generating debug information for the last instruction of a block.
2843         // if this instruction is a branch, spill moves are inserted before this branch
2844         // and so the wrong operand would be returned (spill moves at block boundaries are not
2845         // considered in the live ranges of intervals)
2846         // Solution: use the first op_id of the branch target block instead.
2847         if (block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch() != NULL) {
2848           if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2849             op_id = block-&gt;sux_at(0)-&gt;first_lir_instruction_id();
2850             mode = LIR_OpVisitState::outputMode;
2851           }
2852         }
2853       }
2854 
2855       // Get current location of operand
2856       // The operand must be live because debug information is considered when building the intervals
2857       // if the interval is not live, color_lir_opr will cause an assertion failure
2858       opr = color_lir_opr(opr, op_id, mode);
2859       assert(!has_call(op_id) || opr-&gt;is_stack() || !is_caller_save(reg_num(opr)), &quot;can not have caller-save register operands at calls&quot;);
2860 
2861       // Append to ScopeValue array
2862       return append_scope_value_for_operand(opr, scope_values);
2863 
2864     } else {
2865       assert(value-&gt;as_Constant() != NULL, &quot;all other instructions have only virtual operands&quot;);
2866       assert(opr-&gt;is_constant(), &quot;operand must be constant&quot;);
2867 
2868       return append_scope_value_for_constant(opr, scope_values);
2869     }
2870   } else {
2871     // append a dummy value because real value not needed
2872     scope_values-&gt;append(_illegal_value);
2873     return 1;
2874   }
2875 }
2876 
2877 
2878 IRScopeDebugInfo* LinearScan::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
2879   IRScopeDebugInfo* caller_debug_info = NULL;
2880 
2881   ValueStack* caller_state = cur_state-&gt;caller_state();
2882   if (caller_state != NULL) {
2883     // process recursively to compute outermost scope first
2884     caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope-&gt;caller(), caller_state, innermost_state);
2885   }
2886 
2887   // initialize these to null.
2888   // If we don&#39;t need deopt info or there are no locals, expressions or monitors,
2889   // then these get recorded as no information and avoids the allocation of 0 length arrays.
2890   GrowableArray&lt;ScopeValue*&gt;*   locals      = NULL;
2891   GrowableArray&lt;ScopeValue*&gt;*   expressions = NULL;
2892   GrowableArray&lt;MonitorValue*&gt;* monitors    = NULL;
2893 
2894   // describe local variable values
2895   int nof_locals = cur_state-&gt;locals_size();
2896   if (nof_locals &gt; 0) {
2897     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2898 
2899     int pos = 0;
2900     while (pos &lt; nof_locals) {
2901       assert(pos &lt; cur_state-&gt;locals_size(), &quot;why not?&quot;);
2902 
2903       Value local = cur_state-&gt;local_at(pos);
2904       pos += append_scope_value(op_id, local, locals);
2905 
2906       assert(locals-&gt;length() == pos, &quot;must match&quot;);
2907     }
2908     assert(locals-&gt;length() == cur_scope-&gt;method()-&gt;max_locals(), &quot;wrong number of locals&quot;);
2909     assert(locals-&gt;length() == cur_state-&gt;locals_size(), &quot;wrong number of locals&quot;);
2910   } else if (cur_scope-&gt;method()-&gt;max_locals() &gt; 0) {
2911     assert(cur_state-&gt;kind() == ValueStack::EmptyExceptionState, &quot;should be&quot;);
2912     nof_locals = cur_scope-&gt;method()-&gt;max_locals();
2913     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2914     for(int i = 0; i &lt; nof_locals; i++) {
2915       locals-&gt;append(_illegal_value);
2916     }
2917   }
2918 
2919   // describe expression stack
2920   int nof_stack = cur_state-&gt;stack_size();
2921   if (nof_stack &gt; 0) {
2922     expressions = new GrowableArray&lt;ScopeValue*&gt;(nof_stack);
2923 
2924     int pos = 0;
2925     while (pos &lt; nof_stack) {
2926       Value expression = cur_state-&gt;stack_at_inc(pos);
2927       append_scope_value(op_id, expression, expressions);
2928 
2929       assert(expressions-&gt;length() == pos, &quot;must match&quot;);
2930     }
2931     assert(expressions-&gt;length() == cur_state-&gt;stack_size(), &quot;wrong number of stack entries&quot;);
2932   }
2933 
2934   // describe monitors
2935   int nof_locks = cur_state-&gt;locks_size();
2936   if (nof_locks &gt; 0) {
2937     int lock_offset = cur_state-&gt;caller_state() != NULL ? cur_state-&gt;caller_state()-&gt;total_locks_size() : 0;
2938     monitors = new GrowableArray&lt;MonitorValue*&gt;(nof_locks);
2939     for (int i = 0; i &lt; nof_locks; i++) {
2940       monitors-&gt;append(location_for_monitor_index(lock_offset + i));
2941     }
2942   }
2943 
2944   return new IRScopeDebugInfo(cur_scope, cur_state-&gt;bci(), locals, expressions, monitors, caller_debug_info);
2945 }
2946 
2947 
2948 void LinearScan::compute_debug_info(CodeEmitInfo* info, int op_id) {
2949   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating debug information at op_id %d&quot;, op_id));
2950 
2951   IRScope* innermost_scope = info-&gt;scope();
2952   ValueStack* innermost_state = info-&gt;stack();
2953 
2954   assert(innermost_scope != NULL &amp;&amp; innermost_state != NULL, &quot;why is it missing?&quot;);
2955 
2956   DEBUG_ONLY(check_stack_depth(info, innermost_state-&gt;stack_size()));
2957 
2958   if (info-&gt;_scope_debug_info == NULL) {
2959     // compute debug information
2960     info-&gt;_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
2961   } else {
2962     // debug information already set. Check that it is correct from the current point of view
2963     DEBUG_ONLY(assert_equal(info-&gt;_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
2964   }
2965 }
2966 
2967 
2968 void LinearScan::assign_reg_num(LIR_OpList* instructions, IntervalWalker* iw) {
2969   LIR_OpVisitState visitor;
2970   int num_inst = instructions-&gt;length();
2971   bool has_dead = false;
2972 
2973   for (int j = 0; j &lt; num_inst; j++) {
2974     LIR_Op* op = instructions-&gt;at(j);
2975     if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
2976       has_dead = true;
2977       continue;
2978     }
2979     int op_id = op-&gt;id();
2980 
2981     // visit instruction to get list of operands
2982     visitor.visit(op);
2983 
2984     // iterate all modes of the visitor and process all virtual operands
2985     for_each_visitor_mode(mode) {
2986       int n = visitor.opr_count(mode);
2987       for (int k = 0; k &lt; n; k++) {
2988         LIR_Opr opr = visitor.opr_at(mode, k);
2989         if (opr-&gt;is_virtual_register()) {
2990           visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
2991         }
2992       }
2993     }
2994 
2995     if (visitor.info_count() &gt; 0) {
2996       // exception handling
2997       if (compilation()-&gt;has_exception_handlers()) {
2998         XHandlers* xhandlers = visitor.all_xhandler();
2999         int n = xhandlers-&gt;length();
3000         for (int k = 0; k &lt; n; k++) {
3001           XHandler* handler = xhandlers-&gt;handler_at(k);
3002           if (handler-&gt;entry_code() != NULL) {
3003             assign_reg_num(handler-&gt;entry_code()-&gt;instructions_list(), NULL);
3004           }
3005         }
3006       } else {
3007         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
3008       }
3009 
3010       // compute oop map
3011       assert(iw != NULL, &quot;needed for compute_oop_map&quot;);
3012       compute_oop_map(iw, visitor, op);
3013 
3014       // compute debug information
3015       if (!use_fpu_stack_allocation()) {
3016         // compute debug information if fpu stack allocation is not needed.
3017         // when fpu stack allocation is needed, the debug information can not
3018         // be computed here because the exact location of fpu operands is not known
3019         // -&gt; debug information is created inside the fpu stack allocator
3020         int n = visitor.info_count();
3021         for (int k = 0; k &lt; n; k++) {
3022           compute_debug_info(visitor.info_at(k), op_id);
3023         }
3024       }
3025     }
3026 
3027 #ifdef ASSERT
3028     // make sure we haven&#39;t made the op invalid.
3029     op-&gt;verify();
3030 #endif
3031 
3032     // remove useless moves
3033     if (op-&gt;code() == lir_move) {
3034       assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
3035       LIR_Op1* move = (LIR_Op1*)op;
3036       LIR_Opr src = move-&gt;in_opr();
3037       LIR_Opr dst = move-&gt;result_opr();
3038       if (dst == src ||
3039           (!dst-&gt;is_pointer() &amp;&amp; !src-&gt;is_pointer() &amp;&amp;
3040            src-&gt;is_same_register(dst))) {
3041         instructions-&gt;at_put(j, NULL);
3042         has_dead = true;
3043       }
3044     }
3045   }
3046 
3047   if (has_dead) {
3048     // iterate all instructions of the block and remove all null-values.
3049     int insert_point = 0;
3050     for (int j = 0; j &lt; num_inst; j++) {
3051       LIR_Op* op = instructions-&gt;at(j);
3052       if (op != NULL) {
3053         if (insert_point != j) {
3054           instructions-&gt;at_put(insert_point, op);
3055         }
3056         insert_point++;
3057       }
3058     }
3059     instructions-&gt;trunc_to(insert_point);
3060   }
3061 }
3062 
3063 void LinearScan::assign_reg_num() {
3064   TIME_LINEAR_SCAN(timer_assign_reg_num);
3065 
3066   init_compute_debug_info();
3067   IntervalWalker* iw = init_compute_oop_maps();
3068 
3069   int num_blocks = block_count();
3070   for (int i = 0; i &lt; num_blocks; i++) {
3071     BlockBegin* block = block_at(i);
3072     assign_reg_num(block-&gt;lir()-&gt;instructions_list(), iw);
3073   }
3074 }
3075 
3076 
3077 void LinearScan::do_linear_scan() {
3078   NOT_PRODUCT(_total_timer.begin_method());
3079 
3080   number_instructions();
3081 
3082   NOT_PRODUCT(print_lir(1, &quot;Before Register Allocation&quot;));
3083 
3084   compute_local_live_sets();
3085   compute_global_live_sets();
3086   CHECK_BAILOUT();
3087 
3088   build_intervals();
3089   CHECK_BAILOUT();
3090   sort_intervals_before_allocation();
3091 
3092   NOT_PRODUCT(print_intervals(&quot;Before Register Allocation&quot;));
3093   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_before_alloc));
3094 
3095   allocate_registers();
3096   CHECK_BAILOUT();
3097 
3098   resolve_data_flow();
3099   if (compilation()-&gt;has_exception_handlers()) {
3100     resolve_exception_handlers();
3101   }
3102   // fill in number of spill slots into frame_map
3103   propagate_spill_slots();
3104   CHECK_BAILOUT();
3105 
3106   NOT_PRODUCT(print_intervals(&quot;After Register Allocation&quot;));
3107   NOT_PRODUCT(print_lir(2, &quot;LIR after register allocation:&quot;));
3108 
3109   sort_intervals_after_allocation();
3110 
3111   DEBUG_ONLY(verify());
3112 
3113   eliminate_spill_moves();
3114   assign_reg_num();
3115   CHECK_BAILOUT();
3116 
3117   NOT_PRODUCT(print_lir(2, &quot;LIR after assignment of register numbers:&quot;));
3118   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_after_asign));
3119 
3120   { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);
3121 
3122     if (use_fpu_stack_allocation()) {
3123       allocate_fpu_stack(); // Only has effect on Intel
3124       NOT_PRODUCT(print_lir(2, &quot;LIR after FPU stack allocation:&quot;));
3125     }
3126   }
3127 
3128   { TIME_LINEAR_SCAN(timer_optimize_lir);
3129 
3130     EdgeMoveOptimizer::optimize(ir()-&gt;code());
3131     ControlFlowOptimizer::optimize(ir()-&gt;code());
3132     // check that cfg is still correct after optimizations
3133     ir()-&gt;verify();
3134   }
3135 
3136   NOT_PRODUCT(print_lir(1, &quot;Before Code Generation&quot;, false));
3137   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_final));
3138   NOT_PRODUCT(_total_timer.end_method(this));
3139 }
3140 
3141 
3142 // ********** Printing functions
3143 
3144 #ifndef PRODUCT
3145 
3146 void LinearScan::print_timers(double total) {
3147   _total_timer.print(total);
3148 }
3149 
3150 void LinearScan::print_statistics() {
3151   _stat_before_alloc.print(&quot;before allocation&quot;);
3152   _stat_after_asign.print(&quot;after assignment of register&quot;);
3153   _stat_final.print(&quot;after optimization&quot;);
3154 }
3155 
3156 void LinearScan::print_bitmap(BitMap&amp; b) {
3157   for (unsigned int i = 0; i &lt; b.size(); i++) {
3158     if (b.at(i)) tty-&gt;print(&quot;%d &quot;, i);
3159   }
3160   tty-&gt;cr();
3161 }
3162 
3163 void LinearScan::print_intervals(const char* label) {
3164   if (TraceLinearScanLevel &gt;= 1) {
3165     int i;
3166     tty-&gt;cr();
3167     tty-&gt;print_cr(&quot;%s&quot;, label);
3168 
3169     for (i = 0; i &lt; interval_count(); i++) {
3170       Interval* interval = interval_at(i);
3171       if (interval != NULL) {
3172         interval-&gt;print();
3173       }
3174     }
3175 
3176     tty-&gt;cr();
3177     tty-&gt;print_cr(&quot;--- Basic Blocks ---&quot;);
3178     for (i = 0; i &lt; block_count(); i++) {
3179       BlockBegin* block = block_at(i);
3180       tty-&gt;print(&quot;B%d [%d, %d, %d, %d] &quot;, block-&gt;block_id(), block-&gt;first_lir_instruction_id(), block-&gt;last_lir_instruction_id(), block-&gt;loop_index(), block-&gt;loop_depth());
3181     }
3182     tty-&gt;cr();
3183     tty-&gt;cr();
3184   }
3185 
3186   if (PrintCFGToFile) {
3187     CFGPrinter::print_intervals(&amp;_intervals, label);
3188   }
3189 }
3190 
3191 void LinearScan::print_lir(int level, const char* label, bool hir_valid) {
3192   if (TraceLinearScanLevel &gt;= level) {
3193     tty-&gt;cr();
3194     tty-&gt;print_cr(&quot;%s&quot;, label);
3195     print_LIR(ir()-&gt;linear_scan_order());
3196     tty-&gt;cr();
3197   }
3198 
3199   if (level == 1 &amp;&amp; PrintCFGToFile) {
3200     CFGPrinter::print_cfg(ir()-&gt;linear_scan_order(), label, hir_valid, true);
3201   }
3202 }
3203 
3204 #endif //PRODUCT
3205 
3206 
3207 // ********** verification functions for allocation
3208 // (check that all intervals have a correct register and that no registers are overwritten)
3209 #ifdef ASSERT
3210 
3211 void LinearScan::verify() {
3212   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying intervals ******************************************&quot;));
3213   verify_intervals();
3214 
3215   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that no oops are in fixed intervals ****************&quot;));
3216   verify_no_oops_in_fixed_intervals();
3217 
3218   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that unpinned constants are not alive across block boundaries&quot;));
3219   verify_constants();
3220 
3221   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying register allocation ********************************&quot;));
3222   verify_registers();
3223 
3224   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* no errors found **********************************************&quot;));
3225 }
3226 
3227 void LinearScan::verify_intervals() {
3228   int len = interval_count();
3229   bool has_error = false;
3230 
3231   for (int i = 0; i &lt; len; i++) {
3232     Interval* i1 = interval_at(i);
3233     if (i1 == NULL) continue;
3234 
3235     i1-&gt;check_split_children();
3236 
3237     if (i1-&gt;reg_num() != i) {
3238       tty-&gt;print_cr(&quot;Interval %d is on position %d in list&quot;, i1-&gt;reg_num(), i); i1-&gt;print(); tty-&gt;cr();
3239       has_error = true;
3240     }
3241 
3242     if (i1-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; i1-&gt;type() == T_ILLEGAL) {
3243       tty-&gt;print_cr(&quot;Interval %d has no type assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3244       has_error = true;
3245     }
3246 
3247     if (i1-&gt;assigned_reg() == any_reg) {
3248       tty-&gt;print_cr(&quot;Interval %d has no register assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3249       has_error = true;
3250     }
3251 
3252     if (i1-&gt;assigned_reg() == i1-&gt;assigned_regHi()) {
3253       tty-&gt;print_cr(&quot;Interval %d: low and high register equal&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3254       has_error = true;
3255     }
3256 
3257     if (!is_processed_reg_num(i1-&gt;assigned_reg())) {
3258       tty-&gt;print_cr(&quot;Can not have an Interval for an ignored register&quot;); i1-&gt;print(); tty-&gt;cr();
3259       has_error = true;
3260     }
3261 
3262     // special intervals that are created in MoveResolver
3263     // -&gt; ignore them because the range information has no meaning there
3264     if (i1-&gt;from() == 1 &amp;&amp; i1-&gt;to() == 2) continue;
3265 
3266     if (i1-&gt;first() == Range::end()) {
3267       tty-&gt;print_cr(&quot;Interval %d has no Range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3268       has_error = true;
3269     }
3270 
3271     for (Range* r = i1-&gt;first(); r != Range::end(); r = r-&gt;next()) {
3272       if (r-&gt;from() &gt;= r-&gt;to()) {
3273         tty-&gt;print_cr(&quot;Interval %d has zero length range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3274         has_error = true;
3275       }
3276     }
3277 
3278     for (int j = i + 1; j &lt; len; j++) {
3279       Interval* i2 = interval_at(j);
3280       if (i2 == NULL || (i2-&gt;from() == 1 &amp;&amp; i2-&gt;to() == 2)) continue;
3281 
3282       int r1 = i1-&gt;assigned_reg();
3283       int r1Hi = i1-&gt;assigned_regHi();
3284       int r2 = i2-&gt;assigned_reg();
3285       int r2Hi = i2-&gt;assigned_regHi();
3286       if ((r1 == r2 || r1 == r2Hi || (r1Hi != any_reg &amp;&amp; (r1Hi == r2 || r1Hi == r2Hi))) &amp;&amp; i1-&gt;intersects(i2)) {
3287         tty-&gt;print_cr(&quot;Intervals %d and %d overlap and have the same register assigned&quot;, i1-&gt;reg_num(), i2-&gt;reg_num());
3288         i1-&gt;print(); tty-&gt;cr();
3289         i2-&gt;print(); tty-&gt;cr();
3290         has_error = true;
3291       }
3292     }
3293   }
3294 
3295   assert(has_error == false, &quot;register allocation invalid&quot;);
3296 }
3297 
3298 
3299 void LinearScan::verify_no_oops_in_fixed_intervals() {
3300   Interval* fixed_intervals;
3301   Interval* other_intervals;
3302   create_unhandled_lists(&amp;fixed_intervals, &amp;other_intervals, is_precolored_cpu_interval, NULL);
3303 
3304   // to ensure a walking until the last instruction id, add a dummy interval
3305   // with a high operation id
3306   other_intervals = new Interval(any_reg);
3307   other_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
3308   IntervalWalker* iw = new IntervalWalker(this, fixed_intervals, other_intervals);
3309 
3310   LIR_OpVisitState visitor;
3311   for (int i = 0; i &lt; block_count(); i++) {
3312     BlockBegin* block = block_at(i);
3313 
3314     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
3315 
3316     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
3317       LIR_Op* op = instructions-&gt;at(j);
3318       int op_id = op-&gt;id();
3319 
3320       visitor.visit(op);
3321 
3322       if (visitor.info_count() &gt; 0) {
3323         iw-&gt;walk_before(op-&gt;id());
3324         bool check_live = true;
3325         if (op-&gt;code() == lir_move) {
3326           LIR_Op1* move = (LIR_Op1*)op;
3327           check_live = (move-&gt;patch_code() == lir_patch_none);
3328         }
3329         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3330         if (branch != NULL &amp;&amp; branch-&gt;stub() != NULL &amp;&amp; branch-&gt;stub()-&gt;is_exception_throw_stub()) {
3331           // Don&#39;t bother checking the stub in this case since the
3332           // exception stub will never return to normal control flow.
3333           check_live = false;
3334         }
3335 
3336         // Make sure none of the fixed registers is live across an
3337         // oopmap since we can&#39;t handle that correctly.
3338         if (check_live) {
3339           for (Interval* interval = iw-&gt;active_first(fixedKind);
3340                interval != Interval::end();
3341                interval = interval-&gt;next()) {
3342             if (interval-&gt;current_to() &gt; op-&gt;id() + 1) {
3343               // This interval is live out of this op so make sure
3344               // that this interval represents some value that&#39;s
3345               // referenced by this op either as an input or output.
3346               bool ok = false;
3347               for_each_visitor_mode(mode) {
3348                 int n = visitor.opr_count(mode);
3349                 for (int k = 0; k &lt; n; k++) {
3350                   LIR_Opr opr = visitor.opr_at(mode, k);
3351                   if (opr-&gt;is_fixed_cpu()) {
3352                     if (interval_at(reg_num(opr)) == interval) {
3353                       ok = true;
3354                       break;
3355                     }
3356                     int hi = reg_numHi(opr);
3357                     if (hi != -1 &amp;&amp; interval_at(hi) == interval) {
3358                       ok = true;
3359                       break;
3360                     }
3361                   }
3362                 }
3363               }
3364               assert(ok, &quot;fixed intervals should never be live across an oopmap point&quot;);
3365             }
3366           }
3367         }
3368       }
3369 
3370       // oop-maps at calls do not contain registers, so check is not needed
3371       if (!visitor.has_call()) {
3372 
3373         for_each_visitor_mode(mode) {
3374           int n = visitor.opr_count(mode);
3375           for (int k = 0; k &lt; n; k++) {
3376             LIR_Opr opr = visitor.opr_at(mode, k);
3377 
3378             if (opr-&gt;is_fixed_cpu() &amp;&amp; opr-&gt;is_oop()) {
3379               // operand is a non-virtual cpu register and contains an oop
3380               TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty); tty-&gt;print(&quot;checking operand &quot;); opr-&gt;print(); tty-&gt;cr());
3381 
3382               Interval* interval = interval_at(reg_num(opr));
3383               assert(interval != NULL, &quot;no interval&quot;);
3384 
3385               if (mode == LIR_OpVisitState::inputMode) {
3386                 if (interval-&gt;to() &gt;= op_id + 1) {
3387                   assert(interval-&gt;to() &lt; op_id + 2 ||
3388                          interval-&gt;has_hole_between(op_id, op_id + 2),
3389                          &quot;oop input operand live after instruction&quot;);
3390                 }
3391               } else if (mode == LIR_OpVisitState::outputMode) {
3392                 if (interval-&gt;from() &lt;= op_id - 1) {
3393                   assert(interval-&gt;has_hole_between(op_id - 1, op_id),
3394                          &quot;oop input operand live after instruction&quot;);
3395                 }
3396               }
3397             }
3398           }
3399         }
3400       }
3401     }
3402   }
3403 }
3404 
3405 
3406 void LinearScan::verify_constants() {
3407   int num_regs = num_virtual_regs();
3408   int size = live_set_size();
3409   int num_blocks = block_count();
3410 
3411   for (int i = 0; i &lt; num_blocks; i++) {
3412     BlockBegin* block = block_at(i);
3413     ResourceBitMap live_at_edge = block-&gt;live_in();
3414 
3415     // visit all registers where the live_at_edge bit is set
3416     for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
3417       TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;checking interval %d of block B%d&quot;, r, block-&gt;block_id()));
3418 
3419       Value value = gen()-&gt;instruction_for_vreg(r);
3420 
3421       assert(value != NULL, &quot;all intervals live across block boundaries must have Value&quot;);
3422       assert(value-&gt;operand()-&gt;is_register() &amp;&amp; value-&gt;operand()-&gt;is_virtual(), &quot;value must have virtual operand&quot;);
3423       assert(value-&gt;operand()-&gt;vreg_number() == r, &quot;register number must match&quot;);
3424       // TKR assert(value-&gt;as_Constant() == NULL || value-&gt;is_pinned(), &quot;only pinned constants can be alive accross block boundaries&quot;);
3425     }
3426   }
3427 }
3428 
3429 
3430 class RegisterVerifier: public StackObj {
3431  private:
3432   LinearScan*   _allocator;
3433   BlockList     _work_list;      // all blocks that must be processed
3434   IntervalsList _saved_states;   // saved information of previous check
3435 
3436   // simplified access to methods of LinearScan
3437   Compilation*  compilation() const              { return _allocator-&gt;compilation(); }
3438   Interval*     interval_at(int reg_num) const   { return _allocator-&gt;interval_at(reg_num); }
3439   int           reg_num(LIR_Opr opr) const       { return _allocator-&gt;reg_num(opr); }
3440 
3441   // currently, only registers are processed
3442   int           state_size()                     { return LinearScan::nof_regs; }
3443 
3444   // accessors
3445   IntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block-&gt;block_id()); }
3446   void          set_state_for_block(BlockBegin* block, IntervalList* saved_state) { _saved_states.at_put(block-&gt;block_id(), saved_state); }
3447   void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
3448 
3449   // helper functions
3450   IntervalList* copy(IntervalList* input_state);
3451   void          state_put(IntervalList* input_state, int reg, Interval* interval);
3452   bool          check_state(IntervalList* input_state, int reg, Interval* interval);
3453 
3454   void process_block(BlockBegin* block);
3455   void process_xhandler(XHandler* xhandler, IntervalList* input_state);
3456   void process_successor(BlockBegin* block, IntervalList* input_state);
3457   void process_operations(LIR_List* ops, IntervalList* input_state);
3458 
3459  public:
3460   RegisterVerifier(LinearScan* allocator)
3461     : _allocator(allocator)
3462     , _work_list(16)
3463     , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
3464   { }
3465 
3466   void verify(BlockBegin* start);
3467 };
3468 
3469 
3470 // entry function from LinearScan that starts the verification
3471 void LinearScan::verify_registers() {
3472   RegisterVerifier verifier(this);
3473   verifier.verify(block_at(0));
3474 }
3475 
3476 
3477 void RegisterVerifier::verify(BlockBegin* start) {
3478   // setup input registers (method arguments) for first block
3479   int input_state_len = state_size();
3480   IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);
3481   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3482   for (int n = 0; n &lt; args-&gt;length(); n++) {
3483     LIR_Opr opr = args-&gt;at(n);
3484     if (opr-&gt;is_register()) {
3485       Interval* interval = interval_at(reg_num(opr));
3486 
3487       if (interval-&gt;assigned_reg() &lt; state_size()) {
3488         input_state-&gt;at_put(interval-&gt;assigned_reg(), interval);
3489       }
3490       if (interval-&gt;assigned_regHi() != LinearScan::any_reg &amp;&amp; interval-&gt;assigned_regHi() &lt; state_size()) {
3491         input_state-&gt;at_put(interval-&gt;assigned_regHi(), interval);
3492       }
3493     }
3494   }
3495 
3496   set_state_for_block(start, input_state);
3497   add_to_work_list(start);
3498 
3499   // main loop for verification
3500   do {
3501     BlockBegin* block = _work_list.at(0);
3502     _work_list.remove_at(0);
3503 
3504     process_block(block);
3505   } while (!_work_list.is_empty());
3506 }
3507 
3508 void RegisterVerifier::process_block(BlockBegin* block) {
3509   TRACE_LINEAR_SCAN(2, tty-&gt;cr(); tty-&gt;print_cr(&quot;process_block B%d&quot;, block-&gt;block_id()));
3510 
3511   // must copy state because it is modified
3512   IntervalList* input_state = copy(state_for_block(block));
3513 
3514   if (TraceLinearScanLevel &gt;= 4) {
3515     tty-&gt;print_cr(&quot;Input-State of intervals:&quot;);
3516     tty-&gt;print(&quot;    &quot;);
3517     for (int i = 0; i &lt; state_size(); i++) {
3518       if (input_state-&gt;at(i) != NULL) {
3519         tty-&gt;print(&quot; %4d&quot;, input_state-&gt;at(i)-&gt;reg_num());
3520       } else {
3521         tty-&gt;print(&quot;   __&quot;);
3522       }
3523     }
3524     tty-&gt;cr();
3525     tty-&gt;cr();
3526   }
3527 
3528   // process all operations of the block
3529   process_operations(block-&gt;lir(), input_state);
3530 
3531   // iterate all successors
3532   for (int i = 0; i &lt; block-&gt;number_of_sux(); i++) {
3533     process_successor(block-&gt;sux_at(i), input_state);
3534   }
3535 }
3536 
3537 void RegisterVerifier::process_xhandler(XHandler* xhandler, IntervalList* input_state) {
3538   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_xhandler B%d&quot;, xhandler-&gt;entry_block()-&gt;block_id()));
3539 
3540   // must copy state because it is modified
3541   input_state = copy(input_state);
3542 
3543   if (xhandler-&gt;entry_code() != NULL) {
3544     process_operations(xhandler-&gt;entry_code(), input_state);
3545   }
3546   process_successor(xhandler-&gt;entry_block(), input_state);
3547 }
3548 
3549 void RegisterVerifier::process_successor(BlockBegin* block, IntervalList* input_state) {
3550   IntervalList* saved_state = state_for_block(block);
3551 
3552   if (saved_state != NULL) {
3553     // this block was already processed before.
3554     // check if new input_state is consistent with saved_state
3555 
3556     bool saved_state_correct = true;
3557     for (int i = 0; i &lt; state_size(); i++) {
3558       if (input_state-&gt;at(i) != saved_state-&gt;at(i)) {
3559         // current input_state and previous saved_state assume a different
3560         // interval in this register -&gt; assume that this register is invalid
3561         if (saved_state-&gt;at(i) != NULL) {
3562           // invalidate old calculation only if it assumed that
3563           // register was valid. when the register was already invalid,
3564           // then the old calculation was correct.
3565           saved_state_correct = false;
3566           saved_state-&gt;at_put(i, NULL);
3567 
3568           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;process_successor B%d: invalidating slot %d&quot;, block-&gt;block_id(), i));
3569         }
3570       }
3571     }
3572 
3573     if (saved_state_correct) {
3574       // already processed block with correct input_state
3575       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: previous visit already correct&quot;, block-&gt;block_id()));
3576     } else {
3577       // must re-visit this block
3578       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: must re-visit because input state changed&quot;, block-&gt;block_id()));
3579       add_to_work_list(block);
3580     }
3581 
3582   } else {
3583     // block was not processed before, so set initial input_state
3584     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: initial visit&quot;, block-&gt;block_id()));
3585 
3586     set_state_for_block(block, copy(input_state));
3587     add_to_work_list(block);
3588   }
3589 }
3590 
3591 
3592 IntervalList* RegisterVerifier::copy(IntervalList* input_state) {
3593   IntervalList* copy_state = new IntervalList(input_state-&gt;length());
3594   copy_state-&gt;appendAll(input_state);
3595   return copy_state;
3596 }
3597 
3598 void RegisterVerifier::state_put(IntervalList* input_state, int reg, Interval* interval) {
3599   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3600     if (interval != NULL) {
3601       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = %d&quot;, reg, interval-&gt;reg_num()));
3602     } else if (input_state-&gt;at(reg) != NULL) {
3603       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = NULL&quot;, reg));
3604     }
3605 
3606     input_state-&gt;at_put(reg, interval);
3607   }
3608 }
3609 
3610 bool RegisterVerifier::check_state(IntervalList* input_state, int reg, Interval* interval) {
3611   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3612     if (input_state-&gt;at(reg) != interval) {
3613       tty-&gt;print_cr(&quot;!! Error in register allocation: register %d does not contain interval %d&quot;, reg, interval-&gt;reg_num());
3614       return true;
3615     }
3616   }
3617   return false;
3618 }
3619 
3620 void RegisterVerifier::process_operations(LIR_List* ops, IntervalList* input_state) {
3621   // visit all instructions of the block
3622   LIR_OpVisitState visitor;
3623   bool has_error = false;
3624 
3625   for (int i = 0; i &lt; ops-&gt;length(); i++) {
3626     LIR_Op* op = ops-&gt;at(i);
3627     visitor.visit(op);
3628 
3629     TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty));
3630 
3631     // check if input operands are correct
3632     int j;
3633     int n = visitor.opr_count(LIR_OpVisitState::inputMode);
3634     for (j = 0; j &lt; n; j++) {
3635       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
3636       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3637         Interval* interval = interval_at(reg_num(opr));
3638         if (op-&gt;id() != -1) {
3639           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::inputMode);
3640         }
3641 
3642         has_error |= check_state(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3643         has_error |= check_state(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3644 
3645         // When an operand is marked with is_last_use, then the fpu stack allocator
3646         // removes the register from the fpu stack -&gt; the register contains no value
3647         if (opr-&gt;is_last_use()) {
3648           state_put(input_state, interval-&gt;assigned_reg(),   NULL);
3649           state_put(input_state, interval-&gt;assigned_regHi(), NULL);
3650         }
3651       }
3652     }
3653 
3654     // invalidate all caller save registers at calls
3655     if (visitor.has_call()) {
3656       for (j = 0; j &lt; FrameMap::nof_caller_save_cpu_regs(); j++) {
3657         state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
3658       }
3659       for (j = 0; j &lt; FrameMap::nof_caller_save_fpu_regs; j++) {
3660         state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
3661       }
3662 
3663 #ifdef X86
3664       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
3665       for (j = 0; j &lt; num_caller_save_xmm_regs; j++) {
3666         state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
3667       }
3668 #endif
3669     }
3670 
3671     // process xhandler before output and temp operands
3672     XHandlers* xhandlers = visitor.all_xhandler();
3673     n = xhandlers-&gt;length();
3674     for (int k = 0; k &lt; n; k++) {
3675       process_xhandler(xhandlers-&gt;handler_at(k), input_state);
3676     }
3677 
3678     // set temp operands (some operations use temp operands also as output operands, so can&#39;t set them NULL)
3679     n = visitor.opr_count(LIR_OpVisitState::tempMode);
3680     for (j = 0; j &lt; n; j++) {
3681       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
3682       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3683         Interval* interval = interval_at(reg_num(opr));
3684         if (op-&gt;id() != -1) {
3685           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::tempMode);
3686         }
3687 
3688         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3689         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3690       }
3691     }
3692 
3693     // set output operands
3694     n = visitor.opr_count(LIR_OpVisitState::outputMode);
3695     for (j = 0; j &lt; n; j++) {
3696       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
3697       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3698         Interval* interval = interval_at(reg_num(opr));
3699         if (op-&gt;id() != -1) {
3700           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::outputMode);
3701         }
3702 
3703         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3704         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3705       }
3706     }
3707   }
3708   assert(has_error == false, &quot;Error in register allocation&quot;);
3709 }
3710 
3711 #endif // ASSERT
3712 
3713 
3714 
3715 // **** Implementation of MoveResolver ******************************
3716 
3717 MoveResolver::MoveResolver(LinearScan* allocator) :
3718   _allocator(allocator),
3719   _insert_list(NULL),
3720   _insert_idx(-1),
3721   _insertion_buffer(),
3722   _mapping_from(8),
3723   _mapping_from_opr(8),
3724   _mapping_to(8),
3725   _multiple_reads_allowed(false)
3726 {
3727   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3728     _register_blocked[i] = 0;
3729   }
3730   DEBUG_ONLY(check_empty());
3731 }
3732 
3733 
3734 #ifdef ASSERT
3735 
3736 void MoveResolver::check_empty() {
3737   assert(_mapping_from.length() == 0 &amp;&amp; _mapping_from_opr.length() == 0 &amp;&amp; _mapping_to.length() == 0, &quot;list must be empty before and after processing&quot;);
3738   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3739     assert(register_blocked(i) == 0, &quot;register map must be empty before and after processing&quot;);
3740   }
3741   assert(_multiple_reads_allowed == false, &quot;must have default value&quot;);
3742 }
3743 
3744 void MoveResolver::verify_before_resolve() {
3745   assert(_mapping_from.length() == _mapping_from_opr.length(), &quot;length must be equal&quot;);
3746   assert(_mapping_from.length() == _mapping_to.length(), &quot;length must be equal&quot;);
3747   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;insert position not set&quot;);
3748 
3749   int i, j;
3750   if (!_multiple_reads_allowed) {
3751     for (i = 0; i &lt; _mapping_from.length(); i++) {
3752       for (j = i + 1; j &lt; _mapping_from.length(); j++) {
3753         assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), &quot;cannot read from same interval twice&quot;);
3754       }
3755     }
3756   }
3757 
3758   for (i = 0; i &lt; _mapping_to.length(); i++) {
3759     for (j = i + 1; j &lt; _mapping_to.length(); j++) {
3760       assert(_mapping_to.at(i) != _mapping_to.at(j), &quot;cannot write to same interval twice&quot;);
3761     }
3762   }
3763 
3764 
3765   ResourceBitMap used_regs(LinearScan::nof_regs + allocator()-&gt;frame_map()-&gt;argcount() + allocator()-&gt;max_spills());
3766   if (!_multiple_reads_allowed) {
3767     for (i = 0; i &lt; _mapping_from.length(); i++) {
3768       Interval* it = _mapping_from.at(i);
3769       if (it != NULL) {
3770         assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot read from same register twice&quot;);
3771         used_regs.set_bit(it-&gt;assigned_reg());
3772 
3773         if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3774           assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot read from same register twice&quot;);
3775           used_regs.set_bit(it-&gt;assigned_regHi());
3776         }
3777       }
3778     }
3779   }
3780 
3781   used_regs.clear();
3782   for (i = 0; i &lt; _mapping_to.length(); i++) {
3783     Interval* it = _mapping_to.at(i);
3784     assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot write to same register twice&quot;);
3785     used_regs.set_bit(it-&gt;assigned_reg());
3786 
3787     if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3788       assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot write to same register twice&quot;);
3789       used_regs.set_bit(it-&gt;assigned_regHi());
3790     }
3791   }
3792 
3793   used_regs.clear();
3794   for (i = 0; i &lt; _mapping_from.length(); i++) {
3795     Interval* it = _mapping_from.at(i);
3796     if (it != NULL &amp;&amp; it-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
3797       used_regs.set_bit(it-&gt;assigned_reg());
3798     }
3799   }
3800   for (i = 0; i &lt; _mapping_to.length(); i++) {
3801     Interval* it = _mapping_to.at(i);
3802     assert(!used_regs.at(it-&gt;assigned_reg()) || it-&gt;assigned_reg() == _mapping_from.at(i)-&gt;assigned_reg(), &quot;stack slots used in _mapping_from must be disjoint to _mapping_to&quot;);
3803   }
3804 }
3805 
3806 #endif // ASSERT
3807 
3808 
3809 // mark assigned_reg and assigned_regHi of the interval as blocked
3810 void MoveResolver::block_registers(Interval* it) {
3811   int reg = it-&gt;assigned_reg();
3812   if (reg &lt; LinearScan::nof_regs) {
3813     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3814     set_register_blocked(reg, 1);
3815   }
3816   reg = it-&gt;assigned_regHi();
3817   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3818     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3819     set_register_blocked(reg, 1);
3820   }
3821 }
3822 
3823 // mark assigned_reg and assigned_regHi of the interval as unblocked
3824 void MoveResolver::unblock_registers(Interval* it) {
3825   int reg = it-&gt;assigned_reg();
3826   if (reg &lt; LinearScan::nof_regs) {
3827     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3828     set_register_blocked(reg, -1);
3829   }
3830   reg = it-&gt;assigned_regHi();
3831   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3832     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3833     set_register_blocked(reg, -1);
3834   }
3835 }
3836 
3837 // check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
3838 bool MoveResolver::save_to_process_move(Interval* from, Interval* to) {
3839   int from_reg = -1;
3840   int from_regHi = -1;
3841   if (from != NULL) {
3842     from_reg = from-&gt;assigned_reg();
3843     from_regHi = from-&gt;assigned_regHi();
3844   }
3845 
3846   int reg = to-&gt;assigned_reg();
3847   if (reg &lt; LinearScan::nof_regs) {
3848     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3849       return false;
3850     }
3851   }
3852   reg = to-&gt;assigned_regHi();
3853   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3854     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3855       return false;
3856     }
3857   }
3858 
3859   return true;
3860 }
3861 
3862 
3863 void MoveResolver::create_insertion_buffer(LIR_List* list) {
3864   assert(!_insertion_buffer.initialized(), &quot;overwriting existing buffer&quot;);
3865   _insertion_buffer.init(list);
3866 }
3867 
3868 void MoveResolver::append_insertion_buffer() {
3869   if (_insertion_buffer.initialized()) {
3870     _insertion_buffer.lir_list()-&gt;append(&amp;_insertion_buffer);
3871   }
3872   assert(!_insertion_buffer.initialized(), &quot;must be uninitialized now&quot;);
3873 
3874   _insert_list = NULL;
3875   _insert_idx = -1;
3876 }
3877 
3878 void MoveResolver::insert_move(Interval* from_interval, Interval* to_interval) {
3879   assert(from_interval-&gt;reg_num() != to_interval-&gt;reg_num(), &quot;from and to interval equal&quot;);
3880   assert(from_interval-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3881   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3882   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3883 
3884   LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval-&gt;reg_num(), from_interval-&gt;type());
3885   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3886 
3887   if (!_multiple_reads_allowed) {
3888     // the last_use flag is an optimization for FPU stack allocation. When the same
3889     // input interval is used in more than one move, then it is too difficult to determine
3890     // if this move is really the last use.
3891     from_opr = from_opr-&gt;make_last_use();
3892   }
3893   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3894 
3895   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3896 }
3897 
3898 void MoveResolver::insert_move(LIR_Opr from_opr, Interval* to_interval) {
3899   assert(from_opr-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3900   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3901   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3902 
3903   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3904   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3905 
3906   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: inserted move from constant &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot;  to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3907 }
3908 
3909 
3910 void MoveResolver::resolve_mappings() {
3911   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: resolving mappings for Block B%d, index %d&quot;, _insert_list-&gt;block() != NULL ? _insert_list-&gt;block()-&gt;block_id() : -1, _insert_idx));
3912   DEBUG_ONLY(verify_before_resolve());
3913 
3914   // Block all registers that are used as input operands of a move.
3915   // When a register is blocked, no move to this register is emitted.
3916   // This is necessary for detecting cycles in moves.
3917   int i;
3918   for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3919     Interval* from_interval = _mapping_from.at(i);
3920     if (from_interval != NULL) {
3921       block_registers(from_interval);
3922     }
3923   }
3924 
3925   int spill_candidate = -1;
3926   while (_mapping_from.length() &gt; 0) {
3927     bool processed_interval = false;
3928 
3929     for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3930       Interval* from_interval = _mapping_from.at(i);
3931       Interval* to_interval = _mapping_to.at(i);
3932 
3933       if (save_to_process_move(from_interval, to_interval)) {
3934         // this inverval can be processed because target is free
3935         if (from_interval != NULL) {
3936           insert_move(from_interval, to_interval);
3937           unblock_registers(from_interval);
3938         } else {
3939           insert_move(_mapping_from_opr.at(i), to_interval);
3940         }
3941         _mapping_from.remove_at(i);
3942         _mapping_from_opr.remove_at(i);
3943         _mapping_to.remove_at(i);
3944 
3945         processed_interval = true;
3946       } else if (from_interval != NULL &amp;&amp; from_interval-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
3947         // this interval cannot be processed now because target is not free
3948         // it starts in a register, so it is a possible candidate for spilling
3949         spill_candidate = i;
3950       }
3951     }
3952 
3953     if (!processed_interval) {
3954       // no move could be processed because there is a cycle in the move list
3955       // (e.g. r1 -&gt; r2, r2 -&gt; r1), so one interval must be spilled to memory
3956       guarantee(spill_candidate != -1, &quot;no interval in register for spilling found&quot;);
3957 
3958       // create a new spill interval and assign a stack slot to it
3959       Interval* from_interval = _mapping_from.at(spill_candidate);
3960       Interval* spill_interval = new Interval(-1);
3961       spill_interval-&gt;set_type(from_interval-&gt;type());
3962 
3963       // add a dummy range because real position is difficult to calculate
3964       // Note: this range is a special case when the integrity of the allocation is checked
3965       spill_interval-&gt;add_range(1, 2);
3966 
3967       //       do not allocate a new spill slot for temporary interval, but
3968       //       use spill slot assigned to from_interval. Otherwise moves from
3969       //       one stack slot to another can happen (not allowed by LIR_Assembler
3970       int spill_slot = from_interval-&gt;canonical_spill_slot();
3971       if (spill_slot &lt; 0) {
3972         spill_slot = allocator()-&gt;allocate_spill_slot(type2spill_size[spill_interval-&gt;type()] == 2);
3973         from_interval-&gt;set_canonical_spill_slot(spill_slot);
3974       }
3975       spill_interval-&gt;assign_reg(spill_slot);
3976       allocator()-&gt;append_interval(spill_interval);
3977 
3978       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;created new Interval %d for spilling&quot;, spill_interval-&gt;reg_num()));
3979 
3980       // insert a move from register to stack and update the mapping
3981       insert_move(from_interval, spill_interval);
3982       _mapping_from.at_put(spill_candidate, spill_interval);
3983       unblock_registers(from_interval);
3984     }
3985   }
3986 
3987   // reset to default value
3988   _multiple_reads_allowed = false;
3989 
3990   // check that all intervals have been processed
3991   DEBUG_ONLY(check_empty());
3992 }
3993 
3994 
3995 void MoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
3996   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: setting insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
3997   assert(_insert_list == NULL &amp;&amp; _insert_idx == -1, &quot;use move_insert_position instead of set_insert_position when data already set&quot;);
3998 
3999   create_insertion_buffer(insert_list);
4000   _insert_list = insert_list;
4001   _insert_idx = insert_idx;
4002 }
4003 
4004 void MoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
4005   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: moving insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4006 
4007   if (_insert_list != NULL &amp;&amp; (insert_list != _insert_list || insert_idx != _insert_idx)) {
4008     // insert position changed -&gt; resolve current mappings
4009     resolve_mappings();
4010   }
4011 
4012   if (insert_list != _insert_list) {
4013     // block changed -&gt; append insertion_buffer because it is
4014     // bound to a specific block and create a new insertion_buffer
4015     append_insertion_buffer();
4016     create_insertion_buffer(insert_list);
4017   }
4018 
4019   _insert_list = insert_list;
4020   _insert_idx = insert_idx;
4021 }
4022 
4023 void MoveResolver::add_mapping(Interval* from_interval, Interval* to_interval) {
4024   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4025 
4026   _mapping_from.append(from_interval);
4027   _mapping_from_opr.append(LIR_OprFact::illegalOpr);
4028   _mapping_to.append(to_interval);
4029 }
4030 
4031 
4032 void MoveResolver::add_mapping(LIR_Opr from_opr, Interval* to_interval) {
4033   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: adding mapping from &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot; to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4034   assert(from_opr-&gt;is_constant(), &quot;only for constants&quot;);
4035 
4036   _mapping_from.append(NULL);
4037   _mapping_from_opr.append(from_opr);
4038   _mapping_to.append(to_interval);
4039 }
4040 
4041 void MoveResolver::resolve_and_append_moves() {
4042   if (has_mappings()) {
4043     resolve_mappings();
4044   }
4045   append_insertion_buffer();
4046 }
4047 
4048 
4049 
4050 // **** Implementation of Range *************************************
4051 
4052 Range::Range(int from, int to, Range* next) :
4053   _from(from),
4054   _to(to),
4055   _next(next)
4056 {
4057 }
4058 
4059 // initialize sentinel
4060 Range* Range::_end = NULL;
4061 void Range::initialize(Arena* arena) {
4062   _end = new (arena) Range(max_jint, max_jint, NULL);
4063 }
4064 
4065 int Range::intersects_at(Range* r2) const {
4066   const Range* r1 = this;
4067 
4068   assert(r1 != NULL &amp;&amp; r2 != NULL, &quot;null ranges not allowed&quot;);
4069   assert(r1 != _end &amp;&amp; r2 != _end, &quot;empty ranges not allowed&quot;);
4070 
4071   do {
4072     if (r1-&gt;from() &lt; r2-&gt;from()) {
4073       if (r1-&gt;to() &lt;= r2-&gt;from()) {
4074         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4075       } else {
4076         return r2-&gt;from();
4077       }
4078     } else if (r2-&gt;from() &lt; r1-&gt;from()) {
4079       if (r2-&gt;to() &lt;= r1-&gt;from()) {
4080         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4081       } else {
4082         return r1-&gt;from();
4083       }
4084     } else { // r1-&gt;from() == r2-&gt;from()
4085       if (r1-&gt;from() == r1-&gt;to()) {
4086         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4087       } else if (r2-&gt;from() == r2-&gt;to()) {
4088         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4089       } else {
4090         return r1-&gt;from();
4091       }
4092     }
4093   } while (true);
4094 }
4095 
4096 #ifndef PRODUCT
4097 void Range::print(outputStream* out) const {
4098   out-&gt;print(&quot;[%d, %d[ &quot;, _from, _to);
4099 }
4100 #endif
4101 
4102 
4103 
4104 // **** Implementation of Interval **********************************
4105 
4106 // initialize sentinel
4107 Interval* Interval::_end = NULL;
4108 void Interval::initialize(Arena* arena) {
4109   Range::initialize(arena);
4110   _end = new (arena) Interval(-1);
4111 }
4112 
4113 Interval::Interval(int reg_num) :
4114   _reg_num(reg_num),
4115   _type(T_ILLEGAL),
4116   _first(Range::end()),
4117   _use_pos_and_kinds(12),
4118   _current(Range::end()),
4119   _next(_end),
4120   _state(invalidState),
4121   _assigned_reg(LinearScan::any_reg),
4122   _assigned_regHi(LinearScan::any_reg),
4123   _cached_to(-1),
4124   _cached_opr(LIR_OprFact::illegalOpr),
4125   _cached_vm_reg(VMRegImpl::Bad()),
4126   _split_children(NULL),
4127   _canonical_spill_slot(-1),
4128   _insert_move_when_activated(false),
4129   _spill_state(noDefinitionFound),
4130   _spill_definition_pos(-1),
4131   _register_hint(NULL)
4132 {
4133   _split_parent = this;
4134   _current_split_child = this;
4135 }
4136 
4137 int Interval::calc_to() {
4138   assert(_first != Range::end(), &quot;interval has no range&quot;);
4139 
4140   Range* r = _first;
4141   while (r-&gt;next() != Range::end()) {
4142     r = r-&gt;next();
4143   }
4144   return r-&gt;to();
4145 }
4146 
4147 
4148 #ifdef ASSERT
4149 // consistency check of split-children
4150 void Interval::check_split_children() {
4151   if (_split_children != NULL &amp;&amp; _split_children-&gt;length() &gt; 0) {
4152     assert(is_split_parent(), &quot;only split parents can have children&quot;);
4153 
4154     for (int i = 0; i &lt; _split_children-&gt;length(); i++) {
4155       Interval* i1 = _split_children-&gt;at(i);
4156 
4157       assert(i1-&gt;split_parent() == this, &quot;not a split child of this interval&quot;);
4158       assert(i1-&gt;type() == type(), &quot;must be equal for all split children&quot;);
4159       assert(i1-&gt;canonical_spill_slot() == canonical_spill_slot(), &quot;must be equal for all split children&quot;);
4160 
4161       for (int j = i + 1; j &lt; _split_children-&gt;length(); j++) {
4162         Interval* i2 = _split_children-&gt;at(j);
4163 
4164         assert(i1-&gt;reg_num() != i2-&gt;reg_num(), &quot;same register number&quot;);
4165 
4166         if (i1-&gt;from() &lt; i2-&gt;from()) {
4167           assert(i1-&gt;to() &lt;= i2-&gt;from() &amp;&amp; i1-&gt;to() &lt; i2-&gt;to(), &quot;intervals overlapping&quot;);
4168         } else {
4169           assert(i2-&gt;from() &lt; i1-&gt;from(), &quot;intervals start at same op_id&quot;);
4170           assert(i2-&gt;to() &lt;= i1-&gt;from() &amp;&amp; i2-&gt;to() &lt; i1-&gt;to(), &quot;intervals overlapping&quot;);
4171         }
4172       }
4173     }
4174   }
4175 }
4176 #endif // ASSERT
4177 
4178 Interval* Interval::register_hint(bool search_split_child) const {
4179   if (!search_split_child) {
4180     return _register_hint;
4181   }
4182 
4183   if (_register_hint != NULL) {
4184     assert(_register_hint-&gt;is_split_parent(), &quot;ony split parents are valid hint registers&quot;);
4185 
4186     if (_register_hint-&gt;assigned_reg() &gt;= 0 &amp;&amp; _register_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4187       return _register_hint;
4188 
4189     } else if (_register_hint-&gt;_split_children != NULL &amp;&amp; _register_hint-&gt;_split_children-&gt;length() &gt; 0) {
4190       // search the first split child that has a register assigned
4191       int len = _register_hint-&gt;_split_children-&gt;length();
4192       for (int i = 0; i &lt; len; i++) {
4193         Interval* cur = _register_hint-&gt;_split_children-&gt;at(i);
4194 
4195         if (cur-&gt;assigned_reg() &gt;= 0 &amp;&amp; cur-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4196           return cur;
4197         }
4198       }
4199     }
4200   }
4201 
4202   // no hint interval found that has a register assigned
4203   return NULL;
4204 }
4205 
4206 
4207 Interval* Interval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
4208   assert(is_split_parent(), &quot;can only be called for split parents&quot;);
4209   assert(op_id &gt;= 0, &quot;invalid op_id (method can not be called for spill moves)&quot;);
4210 
4211   Interval* result;
4212   if (_split_children == NULL || _split_children-&gt;length() == 0) {
4213     result = this;
4214   } else {
4215     result = NULL;
4216     int len = _split_children-&gt;length();
4217 
4218     // in outputMode, the end of the interval (op_id == cur-&gt;to()) is not valid
4219     int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
4220 
4221     int i;
4222     for (i = 0; i &lt; len; i++) {
4223       Interval* cur = _split_children-&gt;at(i);
4224       if (cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to() + to_offset) {
4225         if (i &gt; 0) {
4226           // exchange current split child to start of list (faster access for next call)
4227           _split_children-&gt;at_put(i, _split_children-&gt;at(0));
4228           _split_children-&gt;at_put(0, cur);
4229         }
4230 
4231         // interval found
4232         result = cur;
4233         break;
4234       }
4235     }
4236 
4237 #ifdef ASSERT
4238     for (i = 0; i &lt; len; i++) {
4239       Interval* tmp = _split_children-&gt;at(i);
4240       if (tmp != result &amp;&amp; tmp-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; tmp-&gt;to() + to_offset) {
4241         tty-&gt;print_cr(&quot;two valid result intervals found for op_id %d: %d and %d&quot;, op_id, result-&gt;reg_num(), tmp-&gt;reg_num());
4242         result-&gt;print();
4243         tmp-&gt;print();
4244         assert(false, &quot;two valid result intervals found&quot;);
4245       }
4246     }
4247 #endif
4248   }
4249 
4250   assert(result != NULL, &quot;no matching interval found&quot;);
4251   assert(result-&gt;covers(op_id, mode), &quot;op_id not covered by interval&quot;);
4252 
4253   return result;
4254 }
4255 
4256 
4257 // returns the last split child that ends before the given op_id
4258 Interval* Interval::split_child_before_op_id(int op_id) {
4259   assert(op_id &gt;= 0, &quot;invalid op_id&quot;);
4260 
4261   Interval* parent = split_parent();
4262   Interval* result = NULL;
4263 
4264   assert(parent-&gt;_split_children != NULL, &quot;no split children available&quot;);
4265   int len = parent-&gt;_split_children-&gt;length();
4266   assert(len &gt; 0, &quot;no split children available&quot;);
4267 
4268   for (int i = len - 1; i &gt;= 0; i--) {
4269     Interval* cur = parent-&gt;_split_children-&gt;at(i);
4270     if (cur-&gt;to() &lt;= op_id &amp;&amp; (result == NULL || result-&gt;to() &lt; cur-&gt;to())) {
4271       result = cur;
4272     }
4273   }
4274 
4275   assert(result != NULL, &quot;no split child found&quot;);
4276   return result;
4277 }
4278 
4279 
4280 // Note: use positions are sorted descending -&gt; first use has highest index
4281 int Interval::first_usage(IntervalUseKind min_use_kind) const {
4282   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4283 
4284   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4285     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4286       return _use_pos_and_kinds.at(i);
4287     }
4288   }
4289   return max_jint;
4290 }
4291 
4292 int Interval::next_usage(IntervalUseKind min_use_kind, int from) const {
4293   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4294 
4295   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4296     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4297       return _use_pos_and_kinds.at(i);
4298     }
4299   }
4300   return max_jint;
4301 }
4302 
4303 int Interval::next_usage_exact(IntervalUseKind exact_use_kind, int from) const {
4304   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4305 
4306   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4307     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
4308       return _use_pos_and_kinds.at(i);
4309     }
4310   }
4311   return max_jint;
4312 }
4313 
4314 int Interval::previous_usage(IntervalUseKind min_use_kind, int from) const {
4315   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4316 
4317   int prev = 0;
4318   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4319     if (_use_pos_and_kinds.at(i) &gt; from) {
4320       return prev;
4321     }
4322     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4323       prev = _use_pos_and_kinds.at(i);
4324     }
4325   }
4326   return prev;
4327 }
4328 
4329 void Interval::add_use_pos(int pos, IntervalUseKind use_kind) {
4330   assert(covers(pos, LIR_OpVisitState::inputMode), &quot;use position not covered by live range&quot;);
4331 
4332   // do not add use positions for precolored intervals because
4333   // they are never used
4334   if (use_kind != noUse &amp;&amp; reg_num() &gt;= LIR_OprDesc::vreg_base) {
4335 #ifdef ASSERT
4336     assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4337     for (int i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4338       assert(pos &lt;= _use_pos_and_kinds.at(i), &quot;already added a use-position with lower position&quot;);
4339       assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4340       if (i &gt; 0) {
4341         assert(_use_pos_and_kinds.at(i) &lt; _use_pos_and_kinds.at(i - 2), &quot;not sorted descending&quot;);
4342       }
4343     }
4344 #endif
4345 
4346     // Note: add_use is called in descending order, so list gets sorted
4347     //       automatically by just appending new use positions
4348     int len = _use_pos_and_kinds.length();
4349     if (len == 0 || _use_pos_and_kinds.at(len - 2) &gt; pos) {
4350       _use_pos_and_kinds.append(pos);
4351       _use_pos_and_kinds.append(use_kind);
4352     } else if (_use_pos_and_kinds.at(len - 1) &lt; use_kind) {
4353       assert(_use_pos_and_kinds.at(len - 2) == pos, &quot;list not sorted correctly&quot;);
4354       _use_pos_and_kinds.at_put(len - 1, use_kind);
4355     }
4356   }
4357 }
4358 
4359 void Interval::add_range(int from, int to) {
4360   assert(from &lt; to, &quot;invalid range&quot;);
4361   assert(first() == Range::end() || to &lt; first()-&gt;next()-&gt;from(), &quot;not inserting at begin of interval&quot;);
4362   assert(from &lt;= first()-&gt;to(), &quot;not inserting at begin of interval&quot;);
4363 
4364   if (first()-&gt;from() &lt;= to) {
4365     // join intersecting ranges
4366     first()-&gt;set_from(MIN2(from, first()-&gt;from()));
4367     first()-&gt;set_to  (MAX2(to,   first()-&gt;to()));
4368   } else {
4369     // insert new range
4370     _first = new Range(from, to, first());
4371   }
4372 }
4373 
4374 Interval* Interval::new_split_child() {
4375   // allocate new interval
4376   Interval* result = new Interval(-1);
4377   result-&gt;set_type(type());
4378 
4379   Interval* parent = split_parent();
4380   result-&gt;_split_parent = parent;
4381   result-&gt;set_register_hint(parent);
4382 
4383   // insert new interval in children-list of parent
4384   if (parent-&gt;_split_children == NULL) {
4385     assert(is_split_parent(), &quot;list must be initialized at first split&quot;);
4386 
4387     parent-&gt;_split_children = new IntervalList(4);
4388     parent-&gt;_split_children-&gt;append(this);
4389   }
4390   parent-&gt;_split_children-&gt;append(result);
4391 
4392   return result;
4393 }
4394 
4395 // split this interval at the specified position and return
4396 // the remainder as a new interval.
4397 //
4398 // when an interval is split, a bi-directional link is established between the original interval
4399 // (the split parent) and the intervals that are split off this interval (the split children)
4400 // When a split child is split again, the new created interval is also a direct child
4401 // of the original parent (there is no tree of split children stored, but a flat list)
4402 // All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
4403 //
4404 // Note: The new interval has no valid reg_num
4405 Interval* Interval::split(int split_pos) {
4406   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4407 
4408   // allocate new interval
4409   Interval* result = new_split_child();
4410 
4411   // split the ranges
4412   Range* prev = NULL;
4413   Range* cur = _first;
4414   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt;= split_pos) {
4415     prev = cur;
4416     cur = cur-&gt;next();
4417   }
4418   assert(cur != Range::end(), &quot;split interval after end of last range&quot;);
4419 
4420   if (cur-&gt;from() &lt; split_pos) {
4421     result-&gt;_first = new Range(split_pos, cur-&gt;to(), cur-&gt;next());
4422     cur-&gt;set_to(split_pos);
4423     cur-&gt;set_next(Range::end());
4424 
4425   } else {
4426     assert(prev != NULL, &quot;split before start of first range&quot;);
4427     result-&gt;_first = cur;
4428     prev-&gt;set_next(Range::end());
4429   }
4430   result-&gt;_current = result-&gt;_first;
4431   _cached_to = -1; // clear cached value
4432 
4433   // split list of use positions
4434   int total_len = _use_pos_and_kinds.length();
4435   int start_idx = total_len - 2;
4436   while (start_idx &gt;= 0 &amp;&amp; _use_pos_and_kinds.at(start_idx) &lt; split_pos) {
4437     start_idx -= 2;
4438   }
4439 
4440   intStack new_use_pos_and_kinds(total_len - start_idx);
4441   int i;
4442   for (i = start_idx + 2; i &lt; total_len; i++) {
4443     new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
4444   }
4445 
4446   _use_pos_and_kinds.trunc_to(start_idx + 2);
4447   result-&gt;_use_pos_and_kinds = _use_pos_and_kinds;
4448   _use_pos_and_kinds = new_use_pos_and_kinds;
4449 
4450 #ifdef ASSERT
4451   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4452   assert(result-&gt;_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4453   assert(_use_pos_and_kinds.length() + result-&gt;_use_pos_and_kinds.length() == total_len, &quot;missed some entries&quot;);
4454 
4455   for (i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4456     assert(_use_pos_and_kinds.at(i) &lt; split_pos, &quot;must be&quot;);
4457     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4458   }
4459   for (i = 0; i &lt; result-&gt;_use_pos_and_kinds.length(); i += 2) {
4460     assert(result-&gt;_use_pos_and_kinds.at(i) &gt;= split_pos, &quot;must be&quot;);
4461     assert(result-&gt;_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; result-&gt;_use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4462   }
4463 #endif
4464 
4465   return result;
4466 }
4467 
4468 // split this interval at the specified position and return
4469 // the head as a new interval (the original interval is the tail)
4470 //
4471 // Currently, only the first range can be split, and the new interval
4472 // must not have split positions
4473 Interval* Interval::split_from_start(int split_pos) {
4474   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4475   assert(split_pos &gt; from() &amp;&amp; split_pos &lt; to(), &quot;can only split inside interval&quot;);
4476   assert(split_pos &gt; _first-&gt;from() &amp;&amp; split_pos &lt;= _first-&gt;to(), &quot;can only split inside first range&quot;);
4477   assert(first_usage(noUse) &gt; split_pos, &quot;can not split when use positions are present&quot;);
4478 
4479   // allocate new interval
4480   Interval* result = new_split_child();
4481 
4482   // the new created interval has only one range (checked by assertion above),
4483   // so the splitting of the ranges is very simple
4484   result-&gt;add_range(_first-&gt;from(), split_pos);
4485 
4486   if (split_pos == _first-&gt;to()) {
4487     assert(_first-&gt;next() != Range::end(), &quot;must not be at end&quot;);
4488     _first = _first-&gt;next();
4489   } else {
4490     _first-&gt;set_from(split_pos);
4491   }
4492 
4493   return result;
4494 }
4495 
4496 
4497 // returns true if the op_id is inside the interval
4498 bool Interval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
4499   Range* cur  = _first;
4500 
4501   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt; op_id) {
4502     cur = cur-&gt;next();
4503   }
4504   if (cur != Range::end()) {
4505     assert(cur-&gt;to() != cur-&gt;next()-&gt;from(), &quot;ranges not separated&quot;);
4506 
4507     if (mode == LIR_OpVisitState::outputMode) {
4508       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to();
4509     } else {
4510       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt;= cur-&gt;to();
4511     }
4512   }
4513   return false;
4514 }
4515 
4516 // returns true if the interval has any hole between hole_from and hole_to
4517 // (even if the hole has only the length 1)
4518 bool Interval::has_hole_between(int hole_from, int hole_to) {
4519   assert(hole_from &lt; hole_to, &quot;check&quot;);
4520   assert(from() &lt;= hole_from &amp;&amp; hole_to &lt;= to(), &quot;index out of interval&quot;);
4521 
4522   Range* cur  = _first;
4523   while (cur != Range::end()) {
4524     assert(cur-&gt;to() &lt; cur-&gt;next()-&gt;from(), &quot;no space between ranges&quot;);
4525 
4526     // hole-range starts before this range -&gt; hole
4527     if (hole_from &lt; cur-&gt;from()) {
4528       return true;
4529 
4530     // hole-range completely inside this range -&gt; no hole
4531     } else if (hole_to &lt;= cur-&gt;to()) {
4532       return false;
4533 
4534     // overlapping of hole-range with this range -&gt; hole
4535     } else if (hole_from &lt;= cur-&gt;to()) {
4536       return true;
4537     }
4538 
4539     cur = cur-&gt;next();
4540   }
4541 
4542   return false;
4543 }
4544 
4545 
4546 #ifndef PRODUCT
4547 void Interval::print(outputStream* out) const {
4548   const char* SpillState2Name[] = { &quot;no definition&quot;, &quot;no spill store&quot;, &quot;one spill store&quot;, &quot;store at definition&quot;, &quot;start in memory&quot;, &quot;no optimization&quot; };
4549   const char* UseKind2Name[] = { &quot;N&quot;, &quot;L&quot;, &quot;S&quot;, &quot;M&quot; };
4550 
4551   const char* type_name;
4552   LIR_Opr opr = LIR_OprFact::illegal();
4553   if (reg_num() &lt; LIR_OprDesc::vreg_base) {
4554     type_name = &quot;fixed&quot;;
4555     // need a temporary operand for fixed intervals because type() cannot be called
4556 #ifdef X86
4557     int last_xmm_reg = pd_last_xmm_reg;
4558 #ifdef _LP64
4559     if (UseAVX &lt; 3) {
4560       last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
4561     }
4562 #endif
4563 #endif
4564     if (assigned_reg() &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_cpu_reg) {
4565       opr = LIR_OprFact::single_cpu(assigned_reg());
4566     } else if (assigned_reg() &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_fpu_reg) {
4567       opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
4568 #ifdef X86
4569     } else if (assigned_reg() &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg() &lt;= last_xmm_reg) {
4570       opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
4571 #endif
4572     } else {
4573       ShouldNotReachHere();
4574     }
4575   } else {
4576     type_name = type2name(type());
4577     if (assigned_reg() != -1 &amp;&amp;
4578         (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
4579       opr = LinearScan::calc_operand_for_interval(this);
4580     }
4581   }
4582 
4583   out-&gt;print(&quot;%d %s &quot;, reg_num(), type_name);
4584   if (opr-&gt;is_valid()) {
4585     out-&gt;print(&quot;\&quot;&quot;);
4586     opr-&gt;print(out);
4587     out-&gt;print(&quot;\&quot; &quot;);
4588   }
4589   out-&gt;print(&quot;%d %d &quot;, split_parent()-&gt;reg_num(), (register_hint(false) != NULL ? register_hint(false)-&gt;reg_num() : -1));
4590 
4591   // print ranges
4592   Range* cur = _first;
4593   while (cur != Range::end()) {
4594     cur-&gt;print(out);
4595     cur = cur-&gt;next();
4596     assert(cur != NULL, &quot;range list not closed with range sentinel&quot;);
4597   }
4598 
4599   // print use positions
4600   int prev = 0;
4601   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4602   for (int i =_use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4603     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4604     assert(prev &lt; _use_pos_and_kinds.at(i), &quot;use positions not sorted&quot;);
4605 
4606     out-&gt;print(&quot;%d %s &quot;, _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
4607     prev = _use_pos_and_kinds.at(i);
4608   }
4609 
4610   out-&gt;print(&quot; \&quot;%s\&quot;&quot;, SpillState2Name[spill_state()]);
4611   out-&gt;cr();
4612 }
4613 #endif
4614 
4615 
4616 
4617 // **** Implementation of IntervalWalker ****************************
4618 
4619 IntervalWalker::IntervalWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4620  : _compilation(allocator-&gt;compilation())
4621  , _allocator(allocator)
4622 {
4623   _unhandled_first[fixedKind] = unhandled_fixed_first;
4624   _unhandled_first[anyKind]   = unhandled_any_first;
4625   _active_first[fixedKind]    = Interval::end();
4626   _inactive_first[fixedKind]  = Interval::end();
4627   _active_first[anyKind]      = Interval::end();
4628   _inactive_first[anyKind]    = Interval::end();
4629   _current_position = -1;
4630   _current = NULL;
4631   next_interval();
4632 }
4633 
4634 
4635 // append interval in order of current range from()
4636 void IntervalWalker::append_sorted(Interval** list, Interval* interval) {
4637   Interval* prev = NULL;
4638   Interval* cur  = *list;
4639   while (cur-&gt;current_from() &lt; interval-&gt;current_from()) {
4640     prev = cur; cur = cur-&gt;next();
4641   }
4642   if (prev == NULL) {
4643     *list = interval;
4644   } else {
4645     prev-&gt;set_next(interval);
4646   }
4647   interval-&gt;set_next(cur);
4648 }
4649 
4650 void IntervalWalker::append_to_unhandled(Interval** list, Interval* interval) {
4651   assert(interval-&gt;from() &gt;= current()-&gt;current_from(), &quot;cannot append new interval before current walk position&quot;);
4652 
4653   Interval* prev = NULL;
4654   Interval* cur  = *list;
4655   while (cur-&gt;from() &lt; interval-&gt;from() || (cur-&gt;from() == interval-&gt;from() &amp;&amp; cur-&gt;first_usage(noUse) &lt; interval-&gt;first_usage(noUse))) {
4656     prev = cur; cur = cur-&gt;next();
4657   }
4658   if (prev == NULL) {
4659     *list = interval;
4660   } else {
4661     prev-&gt;set_next(interval);
4662   }
4663   interval-&gt;set_next(cur);
4664 }
4665 
4666 
4667 inline bool IntervalWalker::remove_from_list(Interval** list, Interval* i) {
4668   while (*list != Interval::end() &amp;&amp; *list != i) {
4669     list = (*list)-&gt;next_addr();
4670   }
4671   if (*list != Interval::end()) {
4672     assert(*list == i, &quot;check&quot;);
4673     *list = (*list)-&gt;next();
4674     return true;
4675   } else {
4676     return false;
4677   }
4678 }
4679 
4680 void IntervalWalker::remove_from_list(Interval* i) {
4681   bool deleted;
4682 
4683   if (i-&gt;state() == activeState) {
4684     deleted = remove_from_list(active_first_addr(anyKind), i);
4685   } else {
4686     assert(i-&gt;state() == inactiveState, &quot;invalid state&quot;);
4687     deleted = remove_from_list(inactive_first_addr(anyKind), i);
4688   }
4689 
4690   assert(deleted, &quot;interval has not been found in list&quot;);
4691 }
4692 
4693 
4694 void IntervalWalker::walk_to(IntervalState state, int from) {
4695   assert (state == activeState || state == inactiveState, &quot;wrong state&quot;);
4696   for_each_interval_kind(kind) {
4697     Interval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
4698     Interval* next   = *prev;
4699     while (next-&gt;current_from() &lt;= from) {
4700       Interval* cur = next;
4701       next = cur-&gt;next();
4702 
4703       bool range_has_changed = false;
4704       while (cur-&gt;current_to() &lt;= from) {
4705         cur-&gt;next_range();
4706         range_has_changed = true;
4707       }
4708 
4709       // also handle move from inactive list to active list
4710       range_has_changed = range_has_changed || (state == inactiveState &amp;&amp; cur-&gt;current_from() &lt;= from);
4711 
4712       if (range_has_changed) {
4713         // remove cur from list
4714         *prev = next;
4715         if (cur-&gt;current_at_end()) {
4716           // move to handled state (not maintained as a list)
4717           cur-&gt;set_state(handledState);
4718           interval_moved(cur, kind, state, handledState);
4719         } else if (cur-&gt;current_from() &lt;= from){
4720           // sort into active list
4721           append_sorted(active_first_addr(kind), cur);
4722           cur-&gt;set_state(activeState);
4723           if (*prev == cur) {
4724             assert(state == activeState, &quot;check&quot;);
4725             prev = cur-&gt;next_addr();
4726           }
4727           interval_moved(cur, kind, state, activeState);
4728         } else {
4729           // sort into inactive list
4730           append_sorted(inactive_first_addr(kind), cur);
4731           cur-&gt;set_state(inactiveState);
4732           if (*prev == cur) {
4733             assert(state == inactiveState, &quot;check&quot;);
4734             prev = cur-&gt;next_addr();
4735           }
4736           interval_moved(cur, kind, state, inactiveState);
4737         }
4738       } else {
4739         prev = cur-&gt;next_addr();
4740         continue;
4741       }
4742     }
4743   }
4744 }
4745 
4746 
4747 void IntervalWalker::next_interval() {
4748   IntervalKind kind;
4749   Interval* any   = _unhandled_first[anyKind];
4750   Interval* fixed = _unhandled_first[fixedKind];
4751 
4752   if (any != Interval::end()) {
4753     // intervals may start at same position -&gt; prefer fixed interval
4754     kind = fixed != Interval::end() &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ? fixedKind : anyKind;
4755 
4756     assert (kind == fixedKind &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ||
4757             kind == anyKind   &amp;&amp; any-&gt;from() &lt;= fixed-&gt;from(), &quot;wrong interval!!!&quot;);
4758     assert(any == Interval::end() || fixed == Interval::end() || any-&gt;from() != fixed-&gt;from() || kind == fixedKind, &quot;if fixed and any-Interval start at same position, fixed must be processed first&quot;);
4759 
4760   } else if (fixed != Interval::end()) {
4761     kind = fixedKind;
4762   } else {
4763     _current = NULL; return;
4764   }
4765   _current_kind = kind;
4766   _current = _unhandled_first[kind];
4767   _unhandled_first[kind] = _current-&gt;next();
4768   _current-&gt;set_next(Interval::end());
4769   _current-&gt;rewind_range();
4770 }
4771 
4772 
4773 void IntervalWalker::walk_to(int lir_op_id) {
4774   assert(_current_position &lt;= lir_op_id, &quot;can not walk backwards&quot;);
4775   while (current() != NULL) {
4776     bool is_active = current()-&gt;from() &lt;= lir_op_id;
4777     int id = is_active ? current()-&gt;from() : lir_op_id;
4778 
4779     TRACE_LINEAR_SCAN(2, if (_current_position &lt; id) { tty-&gt;cr(); tty-&gt;print_cr(&quot;walk_to(%d) **************************************************************&quot;, id); })
4780 
4781     // set _current_position prior to call of walk_to
4782     _current_position = id;
4783 
4784     // call walk_to even if _current_position == id
4785     walk_to(activeState, id);
4786     walk_to(inactiveState, id);
4787 
4788     if (is_active) {
4789       current()-&gt;set_state(activeState);
4790       if (activate_current()) {
4791         append_sorted(active_first_addr(current_kind()), current());
4792         interval_moved(current(), current_kind(), unhandledState, activeState);
4793       }
4794 
4795       next_interval();
4796     } else {
4797       return;
4798     }
4799   }
4800 }
4801 
4802 void IntervalWalker::interval_moved(Interval* interval, IntervalKind kind, IntervalState from, IntervalState to) {
4803 #ifndef PRODUCT
4804   if (TraceLinearScanLevel &gt;= 4) {
4805     #define print_state(state) \
4806     switch(state) {\
4807       case unhandledState: tty-&gt;print(&quot;unhandled&quot;); break;\
4808       case activeState: tty-&gt;print(&quot;active&quot;); break;\
4809       case inactiveState: tty-&gt;print(&quot;inactive&quot;); break;\
4810       case handledState: tty-&gt;print(&quot;handled&quot;); break;\
4811       default: ShouldNotReachHere(); \
4812     }
4813 
4814     print_state(from); tty-&gt;print(&quot; to &quot;); print_state(to);
4815     tty-&gt;fill_to(23);
4816     interval-&gt;print();
4817 
4818     #undef print_state
4819   }
4820 #endif
4821 }
4822 
4823 
4824 
4825 // **** Implementation of LinearScanWalker **************************
4826 
4827 LinearScanWalker::LinearScanWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4828   : IntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
4829   , _move_resolver(allocator)
4830 {
4831   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
4832     _spill_intervals[i] = new IntervalList(2);
4833   }
4834 }
4835 
4836 
4837 inline void LinearScanWalker::init_use_lists(bool only_process_use_pos) {
4838   for (int i = _first_reg; i &lt;= _last_reg; i++) {
4839     _use_pos[i] = max_jint;
4840 
4841     if (!only_process_use_pos) {
4842       _block_pos[i] = max_jint;
4843       _spill_intervals[i]-&gt;clear();
4844     }
4845   }
4846 }
4847 
4848 inline void LinearScanWalker::exclude_from_use(int reg) {
4849   assert(reg &lt; LinearScan::nof_regs, &quot;interval must have a register assigned (stack slots not allowed)&quot;);
4850   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4851     _use_pos[reg] = 0;
4852   }
4853 }
4854 inline void LinearScanWalker::exclude_from_use(Interval* i) {
4855   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4856 
4857   exclude_from_use(i-&gt;assigned_reg());
4858   exclude_from_use(i-&gt;assigned_regHi());
4859 }
4860 
4861 inline void LinearScanWalker::set_use_pos(int reg, Interval* i, int use_pos, bool only_process_use_pos) {
4862   assert(use_pos != 0, &quot;must use exclude_from_use to set use_pos to 0&quot;);
4863 
4864   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4865     if (_use_pos[reg] &gt; use_pos) {
4866       _use_pos[reg] = use_pos;
4867     }
4868     if (!only_process_use_pos) {
4869       _spill_intervals[reg]-&gt;append(i);
4870     }
4871   }
4872 }
4873 inline void LinearScanWalker::set_use_pos(Interval* i, int use_pos, bool only_process_use_pos) {
4874   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4875   if (use_pos != -1) {
4876     set_use_pos(i-&gt;assigned_reg(), i, use_pos, only_process_use_pos);
4877     set_use_pos(i-&gt;assigned_regHi(), i, use_pos, only_process_use_pos);
4878   }
4879 }
4880 
4881 inline void LinearScanWalker::set_block_pos(int reg, Interval* i, int block_pos) {
4882   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4883     if (_block_pos[reg] &gt; block_pos) {
4884       _block_pos[reg] = block_pos;
4885     }
4886     if (_use_pos[reg] &gt; block_pos) {
4887       _use_pos[reg] = block_pos;
4888     }
4889   }
4890 }
4891 inline void LinearScanWalker::set_block_pos(Interval* i, int block_pos) {
4892   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4893   if (block_pos != -1) {
4894     set_block_pos(i-&gt;assigned_reg(), i, block_pos);
4895     set_block_pos(i-&gt;assigned_regHi(), i, block_pos);
4896   }
4897 }
4898 
4899 
4900 void LinearScanWalker::free_exclude_active_fixed() {
4901   Interval* list = active_first(fixedKind);
4902   while (list != Interval::end()) {
4903     assert(list-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;active interval must have a register assigned&quot;);
4904     exclude_from_use(list);
4905     list = list-&gt;next();
4906   }
4907 }
4908 
4909 void LinearScanWalker::free_exclude_active_any() {
4910   Interval* list = active_first(anyKind);
4911   while (list != Interval::end()) {
4912     exclude_from_use(list);
4913     list = list-&gt;next();
4914   }
4915 }
4916 
4917 void LinearScanWalker::free_collect_inactive_fixed(Interval* cur) {
4918   Interval* list = inactive_first(fixedKind);
4919   while (list != Interval::end()) {
4920     if (cur-&gt;to() &lt;= list-&gt;current_from()) {
4921       assert(list-&gt;current_intersects_at(cur) == -1, &quot;must not intersect&quot;);
4922       set_use_pos(list, list-&gt;current_from(), true);
4923     } else {
4924       set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4925     }
4926     list = list-&gt;next();
4927   }
4928 }
4929 
4930 void LinearScanWalker::free_collect_inactive_any(Interval* cur) {
4931   Interval* list = inactive_first(anyKind);
4932   while (list != Interval::end()) {
4933     set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4934     list = list-&gt;next();
4935   }
4936 }
4937 
4938 void LinearScanWalker::spill_exclude_active_fixed() {
4939   Interval* list = active_first(fixedKind);
4940   while (list != Interval::end()) {
4941     exclude_from_use(list);
4942     list = list-&gt;next();
4943   }
4944 }
4945 
4946 void LinearScanWalker::spill_block_inactive_fixed(Interval* cur) {
4947   Interval* list = inactive_first(fixedKind);
4948   while (list != Interval::end()) {
4949     if (cur-&gt;to() &gt; list-&gt;current_from()) {
4950       set_block_pos(list, list-&gt;current_intersects_at(cur));
4951     } else {
4952       assert(list-&gt;current_intersects_at(cur) == -1, &quot;invalid optimization: intervals intersect&quot;);
4953     }
4954 
4955     list = list-&gt;next();
4956   }
4957 }
4958 
4959 void LinearScanWalker::spill_collect_active_any() {
4960   Interval* list = active_first(anyKind);
4961   while (list != Interval::end()) {
4962     set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4963     list = list-&gt;next();
4964   }
4965 }
4966 
4967 void LinearScanWalker::spill_collect_inactive_any(Interval* cur) {
4968   Interval* list = inactive_first(anyKind);
4969   while (list != Interval::end()) {
4970     if (list-&gt;current_intersects(cur)) {
4971       set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4972     }
4973     list = list-&gt;next();
4974   }
4975 }
4976 
4977 
4978 void LinearScanWalker::insert_move(int op_id, Interval* src_it, Interval* dst_it) {
4979   // output all moves here. When source and target are equal, the move is
4980   // optimized away later in assign_reg_nums
4981 
4982   op_id = (op_id + 1) &amp; ~1;
4983   BlockBegin* op_block = allocator()-&gt;block_of_op_with_id(op_id);
4984   assert(op_id &gt; 0 &amp;&amp; allocator()-&gt;block_of_op_with_id(op_id - 2) == op_block, &quot;cannot insert move at block boundary&quot;);
4985 
4986   // calculate index of instruction inside instruction list of current block
4987   // the minimal index (for a block with no spill moves) can be calculated because the
4988   // numbering of instructions is known.
4989   // When the block already contains spill moves, the index must be increased until the
4990   // correct index is reached.
4991   LIR_OpList* list = op_block-&gt;lir()-&gt;instructions_list();
4992   int index = (op_id - list-&gt;at(0)-&gt;id()) / 2;
4993   assert(list-&gt;at(index)-&gt;id() &lt;= op_id, &quot;error in calculation&quot;);
4994 
4995   while (list-&gt;at(index)-&gt;id() != op_id) {
4996     index++;
4997     assert(0 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
4998   }
4999   assert(1 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5000   assert(list-&gt;at(index)-&gt;id() == op_id, &quot;error in calculation&quot;);
5001 
5002   // insert new instruction before instruction at position index
5003   _move_resolver.move_insert_position(op_block-&gt;lir(), index - 1);
5004   _move_resolver.add_mapping(src_it, dst_it);
5005 }
5006 
5007 
5008 int LinearScanWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
5009   int from_block_nr = min_block-&gt;linear_scan_number();
5010   int to_block_nr = max_block-&gt;linear_scan_number();
5011 
5012   assert(0 &lt;= from_block_nr &amp;&amp; from_block_nr &lt; block_count(), &quot;out of range&quot;);
5013   assert(0 &lt;= to_block_nr &amp;&amp; to_block_nr &lt; block_count(), &quot;out of range&quot;);
5014   assert(from_block_nr &lt; to_block_nr, &quot;must cross block boundary&quot;);
5015 
5016   // Try to split at end of max_block. If this would be after
5017   // max_split_pos, then use the begin of max_block
5018   int optimal_split_pos = max_block-&gt;last_lir_instruction_id() + 2;
5019   if (optimal_split_pos &gt; max_split_pos) {
5020     optimal_split_pos = max_block-&gt;first_lir_instruction_id();
5021   }
5022 
5023   int min_loop_depth = max_block-&gt;loop_depth();
5024   for (int i = to_block_nr - 1; i &gt;= from_block_nr; i--) {
5025     BlockBegin* cur = block_at(i);
5026 
5027     if (cur-&gt;loop_depth() &lt; min_loop_depth) {
5028       // block with lower loop-depth found -&gt; split at the end of this block
5029       min_loop_depth = cur-&gt;loop_depth();
5030       optimal_split_pos = cur-&gt;last_lir_instruction_id() + 2;
5031     }
5032   }
5033   assert(optimal_split_pos &gt; allocator()-&gt;max_lir_op_id() || allocator()-&gt;is_block_begin(optimal_split_pos), &quot;algorithm must move split pos to block boundary&quot;);
5034 
5035   return optimal_split_pos;
5036 }
5037 
5038 
5039 int LinearScanWalker::find_optimal_split_pos(Interval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
5040   int optimal_split_pos = -1;
5041   if (min_split_pos == max_split_pos) {
5042     // trivial case, no optimization of split position possible
5043     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      min-pos and max-pos are equal, no optimization possible&quot;));
5044     optimal_split_pos = min_split_pos;
5045 
5046   } else {
5047     assert(min_split_pos &lt; max_split_pos, &quot;must be true then&quot;);
5048     assert(min_split_pos &gt; 0, &quot;cannot access min_split_pos - 1 otherwise&quot;);
5049 
5050     // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
5051     // beginning of a block, then min_split_pos is also a possible split position.
5052     // Use the block before as min_block, because then min_block-&gt;last_lir_instruction_id() + 2 == min_split_pos
5053     BlockBegin* min_block = allocator()-&gt;block_of_op_with_id(min_split_pos - 1);
5054 
5055     // reason for using max_split_pos - 1: otherwise there would be an assertion failure
5056     // when an interval ends at the end of the last block of the method
5057     // (in this case, max_split_pos == allocator()-&gt;max_lir_op_id() + 2, and there is no
5058     // block at this op_id)
5059     BlockBegin* max_block = allocator()-&gt;block_of_op_with_id(max_split_pos - 1);
5060 
5061     assert(min_block-&gt;linear_scan_number() &lt;= max_block-&gt;linear_scan_number(), &quot;invalid order&quot;);
5062     if (min_block == max_block) {
5063       // split position cannot be moved to block boundary, so split as late as possible
5064       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      cannot move split pos to block boundary because min_pos and max_pos are in same block&quot;));
5065       optimal_split_pos = max_split_pos;
5066 
5067     } else if (it-&gt;has_hole_between(max_split_pos - 1, max_split_pos) &amp;&amp; !allocator()-&gt;is_block_begin(max_split_pos)) {
5068       // Do not move split position if the interval has a hole before max_split_pos.
5069       // Intervals resulting from Phi-Functions have more than one definition (marked
5070       // as mustHaveRegister) with a hole before each definition. When the register is needed
5071       // for the second definition, an earlier reloading is unnecessary.
5072       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has hole just before max_split_pos, so splitting at max_split_pos&quot;));
5073       optimal_split_pos = max_split_pos;
5074 
5075     } else {
5076       // seach optimal block boundary between min_split_pos and max_split_pos
5077       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      moving split pos to optimal block boundary between block B%d and B%d&quot;, min_block-&gt;block_id(), max_block-&gt;block_id()));
5078 
5079       if (do_loop_optimization) {
5080         // Loop optimization: if a loop-end marker is found between min- and max-position,
5081         // then split before this loop
5082         int loop_end_pos = it-&gt;next_usage_exact(loopEndMarker, min_block-&gt;last_lir_instruction_id() + 2);
5083         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization: loop end found at pos %d&quot;, loop_end_pos));
5084 
5085         assert(loop_end_pos &gt; min_split_pos, &quot;invalid order&quot;);
5086         if (loop_end_pos &lt; max_split_pos) {
5087           // loop-end marker found between min- and max-position
5088           // if it is not the end marker for the same loop as the min-position, then move
5089           // the max-position to this loop block.
5090           // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
5091           // of the interval (normally, only mustHaveRegister causes a reloading)
5092           BlockBegin* loop_block = allocator()-&gt;block_of_op_with_id(loop_end_pos);
5093 
5094           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d&quot;, loop_block-&gt;block_id(), max_block-&gt;block_id(), loop_block-&gt;block_id()));
5095           assert(loop_block != min_block, &quot;loop_block and min_block must be different because block boundary is needed between&quot;);
5096 
5097           optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block-&gt;last_lir_instruction_id() + 2);
5098           if (optimal_split_pos == loop_block-&gt;last_lir_instruction_id() + 2) {
5099             optimal_split_pos = -1;
5100             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization not necessary&quot;));
5101           } else {
5102             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization successful&quot;));
5103           }
5104         }
5105       }
5106 
5107       if (optimal_split_pos == -1) {
5108         // not calculated by loop optimization
5109         optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
5110       }
5111     }
5112   }
5113   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      optimal split position: %d&quot;, optimal_split_pos));
5114 
5115   return optimal_split_pos;
5116 }
5117 
5118 
5119 /*
5120   split an interval at the optimal position between min_split_pos and
5121   max_split_pos in two parts:
5122   1) the left part has already a location assigned
5123   2) the right part is sorted into to the unhandled-list
5124 */
5125 void LinearScanWalker::split_before_usage(Interval* it, int min_split_pos, int max_split_pos) {
5126   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting interval: &quot;); it-&gt;print());
5127   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5128 
5129   assert(it-&gt;from() &lt; min_split_pos,         &quot;cannot split at start of interval&quot;);
5130   assert(current_position() &lt; min_split_pos, &quot;cannot split before current position&quot;);
5131   assert(min_split_pos &lt;= max_split_pos,     &quot;invalid order&quot;);
5132   assert(max_split_pos &lt;= it-&gt;to(),          &quot;cannot split after end of interval&quot;);
5133 
5134   int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
5135 
5136   assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5137   assert(optimal_split_pos &lt;= it-&gt;to(),  &quot;cannot split after end of interval&quot;);
5138   assert(optimal_split_pos &gt; it-&gt;from(), &quot;cannot split at start of interval&quot;);
5139 
5140   if (optimal_split_pos == it-&gt;to() &amp;&amp; it-&gt;next_usage(mustHaveRegister, min_split_pos) == max_jint) {
5141     // the split position would be just before the end of the interval
5142     // -&gt; no split at all necessary
5143     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      no split necessary because optimal split position is at end of interval&quot;));
5144     return;
5145   }
5146 
5147   // must calculate this before the actual split is performed and before split position is moved to odd op_id
5148   bool move_necessary = !allocator()-&gt;is_block_begin(optimal_split_pos) &amp;&amp; !it-&gt;has_hole_between(optimal_split_pos - 1, optimal_split_pos);
5149 
5150   if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5151     // move position before actual instruction (odd op_id)
5152     optimal_split_pos = (optimal_split_pos - 1) | 1;
5153   }
5154 
5155   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5156   assert(allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5157   assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5158 
5159   Interval* split_part = it-&gt;split(optimal_split_pos);
5160 
5161   allocator()-&gt;append_interval(split_part);
5162   allocator()-&gt;copy_register_flags(it, split_part);
5163   split_part-&gt;set_insert_move_when_activated(move_necessary);
5164   append_to_unhandled(unhandled_first_addr(anyKind), split_part);
5165 
5166   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts (insert_move_when_activated: %d)&quot;, move_necessary));
5167   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5168   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); split_part-&gt;print());
5169 }
5170 
5171 /*
5172   split an interval at the optimal position between min_split_pos and
5173   max_split_pos in two parts:
5174   1) the left part has already a location assigned
5175   2) the right part is always on the stack and therefore ignored in further processing
5176 */
5177 void LinearScanWalker::split_for_spilling(Interval* it) {
5178   // calculate allowed range of splitting position
5179   int max_split_pos = current_position();
5180   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, max_split_pos) + 1, it-&gt;from());
5181 
5182   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting and spilling interval: &quot;); it-&gt;print());
5183   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5184 
5185   assert(it-&gt;state() == activeState,     &quot;why spill interval that is not active?&quot;);
5186   assert(it-&gt;from() &lt;= min_split_pos,    &quot;cannot split before start of interval&quot;);
5187   assert(min_split_pos &lt;= max_split_pos, &quot;invalid order&quot;);
5188   assert(max_split_pos &lt; it-&gt;to(),       &quot;cannot split at end end of interval&quot;);
5189   assert(current_position() &lt; it-&gt;to(),  &quot;interval must not end before current position&quot;);
5190 
5191   if (min_split_pos == it-&gt;from()) {
5192     // the whole interval is never used, so spill it entirely to memory
5193     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      spilling entire interval because split pos is at beginning of interval&quot;));
5194     assert(it-&gt;first_usage(shouldHaveRegister) &gt; current_position(), &quot;interval must not have use position before current_position&quot;);
5195 
5196     allocator()-&gt;assign_spill_slot(it);
5197     allocator()-&gt;change_spill_state(it, min_split_pos);
5198 
5199     // Also kick parent intervals out of register to memory when they have no use
5200     // position. This avoids short interval in register surrounded by intervals in
5201     // memory -&gt; avoid useless moves from memory to register and back
5202     Interval* parent = it;
5203     while (parent != NULL &amp;&amp; parent-&gt;is_split_child()) {
5204       parent = parent-&gt;split_child_before_op_id(parent-&gt;from());
5205 
5206       if (parent-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5207         if (parent-&gt;first_usage(shouldHaveRegister) == max_jint) {
5208           // parent is never used, so kick it out of its assigned register
5209           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      kicking out interval %d out of its register because it is never used&quot;, parent-&gt;reg_num()));
5210           allocator()-&gt;assign_spill_slot(parent);
5211         } else {
5212           // do not go further back because the register is actually used by the interval
5213           parent = NULL;
5214         }
5215       }
5216     }
5217 
5218   } else {
5219     // search optimal split pos, split interval and spill only the right hand part
5220     int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
5221 
5222     assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5223     assert(optimal_split_pos &lt; it-&gt;to(), &quot;cannot split at end of interval&quot;);
5224     assert(optimal_split_pos &gt;= it-&gt;from(), &quot;cannot split before start of interval&quot;);
5225 
5226     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5227       // move position before actual instruction (odd op_id)
5228       optimal_split_pos = (optimal_split_pos - 1) | 1;
5229     }
5230 
5231     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5232     assert(allocator()-&gt;is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5233     assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5234 
5235     Interval* spilled_part = it-&gt;split(optimal_split_pos);
5236     allocator()-&gt;append_interval(spilled_part);
5237     allocator()-&gt;assign_spill_slot(spilled_part);
5238     allocator()-&gt;change_spill_state(spilled_part, optimal_split_pos);
5239 
5240     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5241       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      inserting move from interval %d to %d&quot;, it-&gt;reg_num(), spilled_part-&gt;reg_num()));
5242       insert_move(optimal_split_pos, it, spilled_part);
5243     }
5244 
5245     // the current_split_child is needed later when moves are inserted for reloading
5246     assert(spilled_part-&gt;current_split_child() == it, &quot;overwriting wrong current_split_child&quot;);
5247     spilled_part-&gt;make_current_split_child();
5248 
5249     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts&quot;));
5250     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5251     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); spilled_part-&gt;print());
5252   }
5253 }
5254 
5255 
5256 void LinearScanWalker::split_stack_interval(Interval* it) {
5257   int min_split_pos = current_position() + 1;
5258   int max_split_pos = MIN2(it-&gt;first_usage(shouldHaveRegister), it-&gt;to());
5259 
5260   split_before_usage(it, min_split_pos, max_split_pos);
5261 }
5262 
5263 void LinearScanWalker::split_when_partial_register_available(Interval* it, int register_available_until) {
5264   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, register_available_until), it-&gt;from() + 1);
5265   int max_split_pos = register_available_until;
5266 
5267   split_before_usage(it, min_split_pos, max_split_pos);
5268 }
5269 
5270 void LinearScanWalker::split_and_spill_interval(Interval* it) {
5271   assert(it-&gt;state() == activeState || it-&gt;state() == inactiveState, &quot;other states not allowed&quot;);
5272 
5273   int current_pos = current_position();
5274   if (it-&gt;state() == inactiveState) {
5275     // the interval is currently inactive, so no spill slot is needed for now.
5276     // when the split part is activated, the interval has a new chance to get a register,
5277     // so in the best case no stack slot is necessary
5278     assert(it-&gt;has_hole_between(current_pos - 1, current_pos + 1), &quot;interval can not be inactive otherwise&quot;);
5279     split_before_usage(it, current_pos + 1, current_pos + 1);
5280 
5281   } else {
5282     // search the position where the interval must have a register and split
5283     // at the optimal position before.
5284     // The new created part is added to the unhandled list and will get a register
5285     // when it is activated
5286     int min_split_pos = current_pos + 1;
5287     int max_split_pos = MIN2(it-&gt;next_usage(mustHaveRegister, min_split_pos), it-&gt;to());
5288 
5289     split_before_usage(it, min_split_pos, max_split_pos);
5290 
5291     assert(it-&gt;next_usage(mustHaveRegister, current_pos) == max_jint, &quot;the remaining part is spilled to stack and therefore has no register&quot;);
5292     split_for_spilling(it);
5293   }
5294 }
5295 
5296 
5297 int LinearScanWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
5298   int min_full_reg = any_reg;
5299   int max_partial_reg = any_reg;
5300 
5301   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5302     if (i == ignore_reg) {
5303       // this register must be ignored
5304 
5305     } else if (_use_pos[i] &gt;= interval_to) {
5306       // this register is free for the full interval
5307       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5308         min_full_reg = i;
5309       }
5310     } else if (_use_pos[i] &gt; reg_needed_until) {
5311       // this register is at least free until reg_needed_until
5312       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5313         max_partial_reg = i;
5314       }
5315     }
5316   }
5317 
5318   if (min_full_reg != any_reg) {
5319     return min_full_reg;
5320   } else if (max_partial_reg != any_reg) {
5321     *need_split = true;
5322     return max_partial_reg;
5323   } else {
5324     return any_reg;
5325   }
5326 }
5327 
5328 int LinearScanWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
5329   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5330 
5331   int min_full_reg = any_reg;
5332   int max_partial_reg = any_reg;
5333 
5334   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5335     if (_use_pos[i] &gt;= interval_to &amp;&amp; _use_pos[i + 1] &gt;= interval_to) {
5336       // this register is free for the full interval
5337       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5338         min_full_reg = i;
5339       }
5340     } else if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5341       // this register is at least free until reg_needed_until
5342       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5343         max_partial_reg = i;
5344       }
5345     }
5346   }
5347 
5348   if (min_full_reg != any_reg) {
5349     return min_full_reg;
5350   } else if (max_partial_reg != any_reg) {
5351     *need_split = true;
5352     return max_partial_reg;
5353   } else {
5354     return any_reg;
5355   }
5356 }
5357 
5358 
5359 bool LinearScanWalker::alloc_free_reg(Interval* cur) {
5360   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;trying to find free register for &quot;); cur-&gt;print());
5361 
5362   init_use_lists(true);
5363   free_exclude_active_fixed();
5364   free_exclude_active_any();
5365   free_collect_inactive_fixed(cur);
5366   free_collect_inactive_any(cur);
5367   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5368 
5369   // _use_pos contains the start of the next interval that has this register assigned
5370   // (either as a fixed register or a normal allocated register in the past)
5371   // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
5372   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      state of registers:&quot;));
5373   TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i &lt;= _last_reg; i++) tty-&gt;print_cr(&quot;      reg %d: use_pos: %d&quot;, i, _use_pos[i]));
5374 
5375   int hint_reg, hint_regHi;
5376   Interval* register_hint = cur-&gt;register_hint();
5377   if (register_hint != NULL) {
5378     hint_reg = register_hint-&gt;assigned_reg();
5379     hint_regHi = register_hint-&gt;assigned_regHi();
5380 
5381     if (allocator()-&gt;is_precolored_cpu_interval(register_hint)) {
5382       assert(hint_reg != any_reg &amp;&amp; hint_regHi == any_reg, &quot;must be for fixed intervals&quot;);
5383       hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
5384     }
5385     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;      hint registers %d, %d from interval &quot;, hint_reg, hint_regHi); register_hint-&gt;print());
5386 
5387   } else {
5388     hint_reg = any_reg;
5389     hint_regHi = any_reg;
5390   }
5391   assert(hint_reg == any_reg || hint_reg != hint_regHi, &quot;hint reg and regHi equal&quot;);
5392   assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned to interval&quot;);
5393 
5394   // the register must be free at least until this position
5395   int reg_needed_until = cur-&gt;from() + 1;
5396   int interval_to = cur-&gt;to();
5397 
5398   bool need_split = false;
5399   int split_pos;
5400   int reg;
5401   int regHi = any_reg;
5402 
5403   if (_adjacent_regs) {
5404     reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &amp;need_split);
5405     regHi = reg + 1;
5406     if (reg == any_reg) {
5407       return false;
5408     }
5409     split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5410 
5411   } else {
5412     reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &amp;need_split);
5413     if (reg == any_reg) {
5414       return false;
5415     }
5416     split_pos = _use_pos[reg];
5417 
5418     if (_num_phys_regs == 2) {
5419       regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &amp;need_split);
5420 
5421       if (_use_pos[reg] &lt; interval_to &amp;&amp; regHi == any_reg) {
5422         // do not split interval if only one register can be assigned until the split pos
5423         // (when one register is found for the whole interval, split&amp;spill is only
5424         // performed for the hi register)
5425         return false;
5426 
5427       } else if (regHi != any_reg) {
5428         split_pos = MIN2(split_pos, _use_pos[regHi]);
5429 
5430         // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5431         if (reg &gt; regHi) {
5432           int temp = reg;
5433           reg = regHi;
5434           regHi = temp;
5435         }
5436       }
5437     }
5438   }
5439 
5440   cur-&gt;assign_reg(reg, regHi);
5441   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;selected register %d, %d&quot;, reg, regHi));
5442 
5443   assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5444   if (need_split) {
5445     // register not available for full interval, so split it
5446     split_when_partial_register_available(cur, split_pos);
5447   }
5448 
5449   // only return true if interval is completely assigned
5450   return _num_phys_regs == 1 || regHi != any_reg;
5451 }
5452 
5453 
5454 int LinearScanWalker::find_locked_reg(int reg_needed_until, int interval_to, int ignore_reg, bool* need_split) {
5455   int max_reg = any_reg;
5456 
5457   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5458     if (i == ignore_reg) {
5459       // this register must be ignored
5460 
5461     } else if (_use_pos[i] &gt; reg_needed_until) {
5462       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5463         max_reg = i;
5464       }
5465     }
5466   }
5467 
5468   if (max_reg != any_reg &amp;&amp; _block_pos[max_reg] &lt;= interval_to) {
5469     *need_split = true;
5470   }
5471 
5472   return max_reg;
5473 }
5474 
5475 int LinearScanWalker::find_locked_double_reg(int reg_needed_until, int interval_to, bool* need_split) {
5476   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5477 
5478   int max_reg = any_reg;
5479 
5480   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5481     if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5482       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5483         max_reg = i;
5484       }
5485     }
5486   }
5487 
5488   if (max_reg != any_reg &amp;&amp;
5489       (_block_pos[max_reg] &lt;= interval_to || _block_pos[max_reg + 1] &lt;= interval_to)) {
5490     *need_split = true;
5491   }
5492 
5493   return max_reg;
5494 }
5495 
5496 void LinearScanWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
5497   assert(reg != any_reg, &quot;no register assigned&quot;);
5498 
5499   for (int i = 0; i &lt; _spill_intervals[reg]-&gt;length(); i++) {
5500     Interval* it = _spill_intervals[reg]-&gt;at(i);
5501     remove_from_list(it);
5502     split_and_spill_interval(it);
5503   }
5504 
5505   if (regHi != any_reg) {
5506     IntervalList* processed = _spill_intervals[reg];
5507     for (int i = 0; i &lt; _spill_intervals[regHi]-&gt;length(); i++) {
5508       Interval* it = _spill_intervals[regHi]-&gt;at(i);
5509       if (processed-&gt;find(it) == -1) {
5510         remove_from_list(it);
5511         split_and_spill_interval(it);
5512       }
5513     }
5514   }
5515 }
5516 
5517 
5518 // Split an Interval and spill it to memory so that cur can be placed in a register
5519 void LinearScanWalker::alloc_locked_reg(Interval* cur) {
5520   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;need to split and spill to get register for &quot;); cur-&gt;print());
5521 
5522   // collect current usage of registers
5523   init_use_lists(false);
5524   spill_exclude_active_fixed();
5525   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5526   spill_block_inactive_fixed(cur);
5527   spill_collect_active_any();
5528   spill_collect_inactive_any(cur);
5529 
5530 #ifndef PRODUCT
5531   if (TraceLinearScanLevel &gt;= 4) {
5532     tty-&gt;print_cr(&quot;      state of registers:&quot;);
5533     for (int i = _first_reg; i &lt;= _last_reg; i++) {
5534       tty-&gt;print(&quot;      reg %d: use_pos: %d, block_pos: %d, intervals: &quot;, i, _use_pos[i], _block_pos[i]);
5535       for (int j = 0; j &lt; _spill_intervals[i]-&gt;length(); j++) {
5536         tty-&gt;print(&quot;%d &quot;, _spill_intervals[i]-&gt;at(j)-&gt;reg_num());
5537       }
5538       tty-&gt;cr();
5539     }
5540   }
5541 #endif
5542 
5543   // the register must be free at least until this position
5544   int reg_needed_until = MIN2(cur-&gt;first_usage(mustHaveRegister), cur-&gt;from() + 1);
5545   int interval_to = cur-&gt;to();
5546   assert (reg_needed_until &gt; 0 &amp;&amp; reg_needed_until &lt; max_jint, &quot;interval has no use&quot;);
5547 
5548   int split_pos = 0;
5549   int use_pos = 0;
5550   bool need_split = false;
5551   int reg, regHi;
5552 
5553   if (_adjacent_regs) {
5554     reg = find_locked_double_reg(reg_needed_until, interval_to, &amp;need_split);
5555     regHi = reg + 1;
5556 
5557     if (reg != any_reg) {
5558       use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5559       split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
5560     }
5561   } else {
5562     reg = find_locked_reg(reg_needed_until, interval_to, cur-&gt;assigned_reg(), &amp;need_split);
5563     regHi = any_reg;
5564 
5565     if (reg != any_reg) {
5566       use_pos = _use_pos[reg];
5567       split_pos = _block_pos[reg];
5568 
5569       if (_num_phys_regs == 2) {
5570         if (cur-&gt;assigned_reg() != any_reg) {
5571           regHi = reg;
5572           reg = cur-&gt;assigned_reg();
5573         } else {
5574           regHi = find_locked_reg(reg_needed_until, interval_to, reg, &amp;need_split);
5575           if (regHi != any_reg) {
5576             use_pos = MIN2(use_pos, _use_pos[regHi]);
5577             split_pos = MIN2(split_pos, _block_pos[regHi]);
5578           }
5579         }
5580 
5581         if (regHi != any_reg &amp;&amp; reg &gt; regHi) {
5582           // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5583           int temp = reg;
5584           reg = regHi;
5585           regHi = temp;
5586         }
5587       }
5588     }
5589   }
5590 
5591   if (reg == any_reg || (_num_phys_regs == 2 &amp;&amp; regHi == any_reg) || use_pos &lt;= cur-&gt;first_usage(mustHaveRegister)) {
5592     // the first use of cur is later than the spilling position -&gt; spill cur
5593     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;able to spill current interval. first_usage(register): %d, use_pos: %d&quot;, cur-&gt;first_usage(mustHaveRegister), use_pos));
5594 
5595     if (cur-&gt;first_usage(mustHaveRegister) &lt;= cur-&gt;from() + 1) {
5596       assert(false, &quot;cannot spill interval that is used in first instruction (possible reason: no register found)&quot;);
5597       // assign a reasonable register and do a bailout in product mode to avoid errors
5598       allocator()-&gt;assign_spill_slot(cur);
5599       BAILOUT(&quot;LinearScan: no register found&quot;);
5600     }
5601 
5602     split_and_spill_interval(cur);
5603   } else {
5604     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;decided to use register %d, %d&quot;, reg, regHi));
5605     assert(reg != any_reg &amp;&amp; (_num_phys_regs == 1 || regHi != any_reg), &quot;no register found&quot;);
5606     assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5607     assert(need_split == false || split_pos &gt; cur-&gt;from(), &quot;splitting interval at from&quot;);
5608 
5609     cur-&gt;assign_reg(reg, regHi);
5610     if (need_split) {
5611       // register not available for full interval, so split it
5612       split_when_partial_register_available(cur, split_pos);
5613     }
5614 
5615     // perform splitting and spilling for all affected intervalls
5616     split_and_spill_intersecting_intervals(reg, regHi);
5617   }
5618 }
5619 
5620 bool LinearScanWalker::no_allocation_possible(Interval* cur) {
5621 #ifdef X86
5622   // fast calculation of intervals that can never get a register because the
5623   // the next instruction is a call that blocks all registers
5624   // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
5625 
5626   // check if this interval is the result of a split operation
5627   // (an interval got a register until this position)
5628   int pos = cur-&gt;from();
5629   if ((pos &amp; 1) == 1) {
5630     // the current instruction is a call that blocks all registers
5631     if (pos &lt; allocator()-&gt;max_lir_op_id() &amp;&amp; allocator()-&gt;has_call(pos + 1)) {
5632       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      free register cannot be available because all registers blocked by following call&quot;));
5633 
5634       // safety check that there is really no register available
5635       assert(alloc_free_reg(cur) == false, &quot;found a register for this interval&quot;);
5636       return true;
5637     }
5638 
5639   }
5640 #endif
5641   return false;
5642 }
5643 
5644 void LinearScanWalker::init_vars_for_alloc(Interval* cur) {
5645   BasicType type = cur-&gt;type();
5646   _num_phys_regs = LinearScan::num_physical_regs(type);
5647   _adjacent_regs = LinearScan::requires_adjacent_regs(type);
5648 
5649   if (pd_init_regs_for_alloc(cur)) {
5650     // the appropriate register range was selected.
5651   } else if (type == T_FLOAT || type == T_DOUBLE) {
5652     _first_reg = pd_first_fpu_reg;
5653     _last_reg = pd_last_fpu_reg;
5654   } else {
5655     _first_reg = pd_first_cpu_reg;
5656     _last_reg = FrameMap::last_cpu_reg();
5657   }
5658 
5659   assert(0 &lt;= _first_reg &amp;&amp; _first_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5660   assert(0 &lt;= _last_reg &amp;&amp; _last_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5661 }
5662 
5663 
5664 bool LinearScanWalker::is_move(LIR_Op* op, Interval* from, Interval* to) {
5665   if (op-&gt;code() != lir_move) {
5666     return false;
5667   }
5668   assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5669 
5670   LIR_Opr in = ((LIR_Op1*)op)-&gt;in_opr();
5671   LIR_Opr res = ((LIR_Op1*)op)-&gt;result_opr();
5672   return in-&gt;is_virtual() &amp;&amp; res-&gt;is_virtual() &amp;&amp; in-&gt;vreg_number() == from-&gt;reg_num() &amp;&amp; res-&gt;vreg_number() == to-&gt;reg_num();
5673 }
5674 
5675 // optimization (especially for phi functions of nested loops):
5676 // assign same spill slot to non-intersecting intervals
5677 void LinearScanWalker::combine_spilled_intervals(Interval* cur) {
5678   if (cur-&gt;is_split_child()) {
5679     // optimization is only suitable for split parents
5680     return;
5681   }
5682 
5683   Interval* register_hint = cur-&gt;register_hint(false);
5684   if (register_hint == NULL) {
5685     // cur is not the target of a move, otherwise register_hint would be set
5686     return;
5687   }
5688   assert(register_hint-&gt;is_split_parent(), &quot;register hint must be split parent&quot;);
5689 
5690   if (cur-&gt;spill_state() != noOptimization || register_hint-&gt;spill_state() != noOptimization) {
5691     // combining the stack slots for intervals where spill move optimization is applied
5692     // is not benefitial and would cause problems
5693     return;
5694   }
5695 
5696   int begin_pos = cur-&gt;from();
5697   int end_pos = cur-&gt;to();
5698   if (end_pos &gt; allocator()-&gt;max_lir_op_id() || (begin_pos &amp; 1) != 0 || (end_pos &amp; 1) != 0) {
5699     // safety check that lir_op_with_id is allowed
5700     return;
5701   }
5702 
5703   if (!is_move(allocator()-&gt;lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()-&gt;lir_op_with_id(end_pos), cur, register_hint)) {
5704     // cur and register_hint are not connected with two moves
5705     return;
5706   }
5707 
5708   Interval* begin_hint = register_hint-&gt;split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
5709   Interval* end_hint = register_hint-&gt;split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
5710   if (begin_hint == end_hint || begin_hint-&gt;to() != begin_pos || end_hint-&gt;from() != end_pos) {
5711     // register_hint must be split, otherwise the re-writing of use positions does not work
5712     return;
5713   }
5714 
5715   assert(begin_hint-&gt;assigned_reg() != any_reg, &quot;must have register assigned&quot;);
5716   assert(end_hint-&gt;assigned_reg() == any_reg, &quot;must not have register assigned&quot;);
5717   assert(cur-&gt;first_usage(mustHaveRegister) == begin_pos, &quot;must have use position at begin of interval because of move&quot;);
5718   assert(end_hint-&gt;first_usage(mustHaveRegister) == end_pos, &quot;must have use position at begin of interval because of move&quot;);
5719 
5720   if (begin_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5721     // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
5722     return;
5723   }
5724   assert(register_hint-&gt;canonical_spill_slot() != -1, &quot;must be set when part of interval was spilled&quot;);
5725 
5726   // modify intervals such that cur gets the same stack slot as register_hint
5727   // delete use positions to prevent the intervals to get a register at beginning
5728   cur-&gt;set_canonical_spill_slot(register_hint-&gt;canonical_spill_slot());
5729   cur-&gt;remove_first_use_pos();
5730   end_hint-&gt;remove_first_use_pos();
5731 }
5732 
5733 
5734 // allocate a physical register or memory location to an interval
5735 bool LinearScanWalker::activate_current() {
5736   Interval* cur = current();
5737   bool result = true;
5738 
5739   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;+++++ activating interval &quot;); cur-&gt;print());
5740   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      split_parent: %d, insert_move_when_activated: %d&quot;, cur-&gt;split_parent()-&gt;reg_num(), cur-&gt;insert_move_when_activated()));
5741 
5742   if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5743     // activating an interval that has a stack slot assigned -&gt; split it at first use position
5744     // used for method parameters
5745     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has spill slot assigned (method parameter) -&gt; split it before first use&quot;));
5746 
5747     split_stack_interval(cur);
5748     result = false;
5749 
5750   } else if (allocator()-&gt;gen()-&gt;is_vreg_flag_set(cur-&gt;reg_num(), LIRGenerator::must_start_in_memory)) {
5751     // activating an interval that must start in a stack slot, but may get a register later
5752     // used for lir_roundfp: rounding is done by store to stack and reload later
5753     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval must start in stack slot -&gt; split it before first use&quot;));
5754     assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned&quot;);
5755 
5756     allocator()-&gt;assign_spill_slot(cur);
5757     split_stack_interval(cur);
5758     result = false;
5759 
5760   } else if (cur-&gt;assigned_reg() == any_reg) {
5761     // interval has not assigned register -&gt; normal allocation
5762     // (this is the normal case for most intervals)
5763     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      normal allocation of register&quot;));
5764 
5765     // assign same spill slot to non-intersecting intervals
5766     combine_spilled_intervals(cur);
5767 
5768     init_vars_for_alloc(cur);
5769     if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
5770       // no empty register available.
5771       // split and spill another interval so that this interval gets a register
5772       alloc_locked_reg(cur);
5773     }
5774 
5775     // spilled intervals need not be move to active-list
5776     if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5777       result = false;
5778     }
5779   }
5780 
5781   // load spilled values that become active from stack slot to register
5782   if (cur-&gt;insert_move_when_activated()) {
5783     assert(cur-&gt;is_split_child(), &quot;must be&quot;);
5784     assert(cur-&gt;current_split_child() != NULL, &quot;must be&quot;);
5785     assert(cur-&gt;current_split_child()-&gt;reg_num() != cur-&gt;reg_num(), &quot;cannot insert move between same interval&quot;);
5786     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;Inserting move from interval %d to %d because insert_move_when_activated is set&quot;, cur-&gt;current_split_child()-&gt;reg_num(), cur-&gt;reg_num()));
5787 
5788     insert_move(cur-&gt;from(), cur-&gt;current_split_child(), cur);
5789   }
5790   cur-&gt;make_current_split_child();
5791 
5792   return result; // true = interval is moved to active list
5793 }
5794 
5795 
5796 // Implementation of EdgeMoveOptimizer
5797 
5798 EdgeMoveOptimizer::EdgeMoveOptimizer() :
5799   _edge_instructions(4),
5800   _edge_instructions_idx(4)
5801 {
5802 }
5803 
5804 void EdgeMoveOptimizer::optimize(BlockList* code) {
5805   EdgeMoveOptimizer optimizer = EdgeMoveOptimizer();
5806 
5807   // ignore the first block in the list (index 0 is not processed)
5808   for (int i = code-&gt;length() - 1; i &gt;= 1; i--) {
5809     BlockBegin* block = code-&gt;at(i);
5810 
5811     if (block-&gt;number_of_preds() &gt; 1 &amp;&amp; !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
5812       optimizer.optimize_moves_at_block_end(block);
5813     }
5814     if (block-&gt;number_of_sux() == 2) {
5815       optimizer.optimize_moves_at_block_begin(block);
5816     }
5817   }
5818 }
5819 
5820 
5821 // clear all internal data structures
5822 void EdgeMoveOptimizer::init_instructions() {
5823   _edge_instructions.clear();
5824   _edge_instructions_idx.clear();
5825 }
5826 
5827 // append a lir-instruction-list and the index of the current operation in to the list
5828 void EdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
5829   _edge_instructions.append(instructions);
5830   _edge_instructions_idx.append(instructions_idx);
5831 }
5832 
5833 // return the current operation of the given edge (predecessor or successor)
5834 LIR_Op* EdgeMoveOptimizer::instruction_at(int edge) {
5835   LIR_OpList* instructions = _edge_instructions.at(edge);
5836   int idx = _edge_instructions_idx.at(edge);
5837 
5838   if (idx &lt; instructions-&gt;length()) {
5839     return instructions-&gt;at(idx);
5840   } else {
5841     return NULL;
5842   }
5843 }
5844 
5845 // removes the current operation of the given edge (predecessor or successor)
5846 void EdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
5847   LIR_OpList* instructions = _edge_instructions.at(edge);
5848   int idx = _edge_instructions_idx.at(edge);
5849   instructions-&gt;remove_at(idx);
5850 
5851   if (decrement_index) {
5852     _edge_instructions_idx.at_put(edge, idx - 1);
5853   }
5854 }
5855 
5856 
5857 bool EdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
5858   if (op1 == NULL || op2 == NULL) {
5859     // at least one block is already empty -&gt; no optimization possible
5860     return true;
5861   }
5862 
5863   if (op1-&gt;code() == lir_move &amp;&amp; op2-&gt;code() == lir_move) {
5864     assert(op1-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5865     assert(op2-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5866     LIR_Op1* move1 = (LIR_Op1*)op1;
5867     LIR_Op1* move2 = (LIR_Op1*)op2;
5868     if (move1-&gt;info() == move2-&gt;info() &amp;&amp; move1-&gt;in_opr() == move2-&gt;in_opr() &amp;&amp; move1-&gt;result_opr() == move2-&gt;result_opr()) {
5869       // these moves are exactly equal and can be optimized
5870       return false;
5871     }
5872 
5873   } else if (op1-&gt;code() == lir_fxch &amp;&amp; op2-&gt;code() == lir_fxch) {
5874     assert(op1-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5875     assert(op2-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5876     LIR_Op1* fxch1 = (LIR_Op1*)op1;
5877     LIR_Op1* fxch2 = (LIR_Op1*)op2;
5878     if (fxch1-&gt;in_opr()-&gt;as_jint() == fxch2-&gt;in_opr()-&gt;as_jint()) {
5879       // equal FPU stack operations can be optimized
5880       return false;
5881     }
5882 
5883   } else if (op1-&gt;code() == lir_fpop_raw &amp;&amp; op2-&gt;code() == lir_fpop_raw) {
5884     // equal FPU stack operations can be optimized
5885     return false;
5886   }
5887 
5888   // no optimization possible
5889   return true;
5890 }
5891 
5892 void EdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
5893   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimizing moves at end of block B%d&quot;, block-&gt;block_id()));
5894 
5895   if (block-&gt;is_predecessor(block)) {
5896     // currently we can&#39;t handle this correctly.
5897     return;
5898   }
5899 
5900   init_instructions();
5901   int num_preds = block-&gt;number_of_preds();
5902   assert(num_preds &gt; 1, &quot;do not call otherwise&quot;);
5903   assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
5904 
5905   // setup a list with the lir-instructions of all predecessors
5906   int i;
5907   for (i = 0; i &lt; num_preds; i++) {
5908     BlockBegin* pred = block-&gt;pred_at(i);
5909     LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
5910 
5911     if (pred-&gt;number_of_sux() != 1) {
5912       // this can happen with switch-statements where multiple edges are between
5913       // the same blocks.
5914       return;
5915     }
5916 
5917     assert(pred-&gt;number_of_sux() == 1, &quot;can handle only one successor&quot;);
5918     assert(pred-&gt;sux_at(0) == block, &quot;invalid control flow&quot;);
5919     assert(pred_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5920     assert(pred_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5921     assert(pred_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5922 
5923     if (pred_instructions-&gt;last()-&gt;info() != NULL) {
5924       // can not optimize instructions when debug info is needed
5925       return;
5926     }
5927 
5928     // ignore the unconditional branch at the end of the block
5929     append_instructions(pred_instructions, pred_instructions-&gt;length() - 2);
5930   }
5931 
5932 
5933   // process lir-instructions while all predecessors end with the same instruction
5934   while (true) {
5935     LIR_Op* op = instruction_at(0);
5936     for (i = 1; i &lt; num_preds; i++) {
5937       if (operations_different(op, instruction_at(i))) {
5938         // these instructions are different and cannot be optimized -&gt;
5939         // no further optimization possible
5940         return;
5941       }
5942     }
5943 
5944     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;found instruction that is equal in all %d predecessors: &quot;, num_preds); op-&gt;print());
5945 
5946     // insert the instruction at the beginning of the current block
5947     block-&gt;lir()-&gt;insert_before(1, op);
5948 
5949     // delete the instruction at the end of all predecessors
5950     for (i = 0; i &lt; num_preds; i++) {
5951       remove_cur_instruction(i, true);
5952     }
5953   }
5954 }
5955 
5956 
5957 void EdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
5958   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimization moves at begin of block B%d&quot;, block-&gt;block_id()));
5959 
5960   init_instructions();
5961   int num_sux = block-&gt;number_of_sux();
5962 
5963   LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
5964 
5965   assert(num_sux == 2, &quot;method should not be called otherwise&quot;);
5966   assert(cur_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5967   assert(cur_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5968   assert(cur_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5969 
5970   if (cur_instructions-&gt;last()-&gt;info() != NULL) {
5971     // can no optimize instructions when debug info is needed
5972     return;
5973   }
5974 
5975   LIR_Op* branch = cur_instructions-&gt;at(cur_instructions-&gt;length() - 2);
5976   if (branch-&gt;info() != NULL || (branch-&gt;code() != lir_branch &amp;&amp; branch-&gt;code() != lir_cond_float_branch)) {
5977     // not a valid case for optimization
5978     // currently, only blocks that end with two branches (conditional branch followed
5979     // by unconditional branch) are optimized
5980     return;
5981   }
5982 
5983   // now it is guaranteed that the block ends with two branch instructions.
5984   // the instructions are inserted at the end of the block before these two branches
5985   int insert_idx = cur_instructions-&gt;length() - 2;
5986 
5987   int i;
5988 #ifdef ASSERT
5989   for (i = insert_idx - 1; i &gt;= 0; i--) {
5990     LIR_Op* op = cur_instructions-&gt;at(i);
5991     if ((op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) &amp;&amp; ((LIR_OpBranch*)op)-&gt;block() != NULL) {
5992       assert(false, &quot;block with two successors can have only two branch instructions&quot;);
5993     }
5994   }
5995 #endif
5996 
5997   // setup a list with the lir-instructions of all successors
5998   for (i = 0; i &lt; num_sux; i++) {
5999     BlockBegin* sux = block-&gt;sux_at(i);
6000     LIR_OpList* sux_instructions = sux-&gt;lir()-&gt;instructions_list();
6001 
6002     assert(sux_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
6003 
6004     if (sux-&gt;number_of_preds() != 1) {
6005       // this can happen with switch-statements where multiple edges are between
6006       // the same blocks.
6007       return;
6008     }
6009     assert(sux-&gt;pred_at(0) == block, &quot;invalid control flow&quot;);
6010     assert(!sux-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
6011 
6012     // ignore the label at the beginning of the block
6013     append_instructions(sux_instructions, 1);
6014   }
6015 
6016   // process lir-instructions while all successors begin with the same instruction
6017   while (true) {
6018     LIR_Op* op = instruction_at(0);
6019     for (i = 1; i &lt; num_sux; i++) {
6020       if (operations_different(op, instruction_at(i))) {
6021         // these instructions are different and cannot be optimized -&gt;
6022         // no further optimization possible
6023         return;
6024       }
6025     }
6026 
6027     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;----- found instruction that is equal in all %d successors: &quot;, num_sux); op-&gt;print());
6028 
6029     // insert instruction at end of current block
6030     block-&gt;lir()-&gt;insert_before(insert_idx, op);
6031     insert_idx++;
6032 
6033     // delete the instructions at the beginning of all successors
6034     for (i = 0; i &lt; num_sux; i++) {
6035       remove_cur_instruction(i, false);
6036     }
6037   }
6038 }
6039 
6040 
6041 // Implementation of ControlFlowOptimizer
6042 
6043 ControlFlowOptimizer::ControlFlowOptimizer() :
6044   _original_preds(4)
6045 {
6046 }
6047 
6048 void ControlFlowOptimizer::optimize(BlockList* code) {
6049   ControlFlowOptimizer optimizer = ControlFlowOptimizer();
6050 
6051   // push the OSR entry block to the end so that we&#39;re not jumping over it.
6052   BlockBegin* osr_entry = code-&gt;at(0)-&gt;end()-&gt;as_Base()-&gt;osr_entry();
6053   if (osr_entry) {
6054     int index = osr_entry-&gt;linear_scan_number();
6055     assert(code-&gt;at(index) == osr_entry, &quot;wrong index&quot;);
6056     code-&gt;remove_at(index);
6057     code-&gt;append(osr_entry);
6058   }
6059 
6060   optimizer.reorder_short_loops(code);
6061   optimizer.delete_empty_blocks(code);
6062   optimizer.delete_unnecessary_jumps(code);
6063   optimizer.delete_jumps_to_return(code);
6064 }
6065 
6066 void ControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
6067   int i = header_idx + 1;
6068   int max_end = MIN2(header_idx + ShortLoopSize, code-&gt;length());
6069   while (i &lt; max_end &amp;&amp; code-&gt;at(i)-&gt;loop_depth() &gt;= header_block-&gt;loop_depth()) {
6070     i++;
6071   }
6072 
6073   if (i == code-&gt;length() || code-&gt;at(i)-&gt;loop_depth() &lt; header_block-&gt;loop_depth()) {
6074     int end_idx = i - 1;
6075     BlockBegin* end_block = code-&gt;at(end_idx);
6076 
6077     if (end_block-&gt;number_of_sux() == 1 &amp;&amp; end_block-&gt;sux_at(0) == header_block) {
6078       // short loop from header_idx to end_idx found -&gt; reorder blocks such that
6079       // the header_block is the last block instead of the first block of the loop
6080       TRACE_LINEAR_SCAN(1, tty-&gt;print_cr(&quot;Reordering short loop: length %d, header B%d, end B%d&quot;,
6081                                          end_idx - header_idx + 1,
6082                                          header_block-&gt;block_id(), end_block-&gt;block_id()));
6083 
6084       for (int j = header_idx; j &lt; end_idx; j++) {
6085         code-&gt;at_put(j, code-&gt;at(j + 1));
6086       }
6087       code-&gt;at_put(end_idx, header_block);
6088 
6089       // correct the flags so that any loop alignment occurs in the right place.
6090       assert(code-&gt;at(end_idx)-&gt;is_set(BlockBegin::backward_branch_target_flag), &quot;must be backward branch target&quot;);
6091       code-&gt;at(end_idx)-&gt;clear(BlockBegin::backward_branch_target_flag);
6092       code-&gt;at(header_idx)-&gt;set(BlockBegin::backward_branch_target_flag);
6093     }
6094   }
6095 }
6096 
6097 void ControlFlowOptimizer::reorder_short_loops(BlockList* code) {
6098   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6099     BlockBegin* block = code-&gt;at(i);
6100 
6101     if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
6102       reorder_short_loop(code, block, i);
6103     }
6104   }
6105 
6106   DEBUG_ONLY(verify(code));
6107 }
6108 
6109 // only blocks with exactly one successor can be deleted. Such blocks
6110 // must always end with an unconditional branch to this successor
6111 bool ControlFlowOptimizer::can_delete_block(BlockBegin* block) {
6112   if (block-&gt;number_of_sux() != 1 || block-&gt;number_of_exception_handlers() != 0 || block-&gt;is_entry_block()) {
6113     return false;
6114   }
6115 
6116   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6117 
6118   assert(instructions-&gt;length() &gt;= 2, &quot;block must have label and branch&quot;);
6119   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6120   assert(instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;last instrcution must always be a branch&quot;);
6121   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;branch must be unconditional&quot;);
6122   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;block() == block-&gt;sux_at(0), &quot;branch target must be the successor&quot;);
6123 
6124   // block must have exactly one successor
6125 
6126   if (instructions-&gt;length() == 2 &amp;&amp; instructions-&gt;last()-&gt;info() == NULL) {
6127     return true;
6128   }
6129   return false;
6130 }
6131 
6132 // substitute branch targets in all branch-instructions of this blocks
6133 void ControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
6134   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting empty block: substituting from B%d to B%d inside B%d&quot;, target_from-&gt;block_id(), target_to-&gt;block_id(), block-&gt;block_id()));
6135 
6136   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6137 
6138   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6139   for (int i = instructions-&gt;length() - 1; i &gt;= 1; i--) {
6140     LIR_Op* op = instructions-&gt;at(i);
6141 
6142     if (op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) {
6143       assert(op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6144       LIR_OpBranch* branch = (LIR_OpBranch*)op;
6145 
6146       if (branch-&gt;block() == target_from) {
6147         branch-&gt;change_block(target_to);
6148       }
6149       if (branch-&gt;ublock() == target_from) {
6150         branch-&gt;change_ublock(target_to);
6151       }
6152     }
6153   }
6154 }
6155 
6156 void ControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
6157   int old_pos = 0;
6158   int new_pos = 0;
6159   int num_blocks = code-&gt;length();
6160 
6161   while (old_pos &lt; num_blocks) {
6162     BlockBegin* block = code-&gt;at(old_pos);
6163 
6164     if (can_delete_block(block)) {
6165       BlockBegin* new_target = block-&gt;sux_at(0);
6166 
6167       // propagate backward branch target flag for correct code alignment
6168       if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
6169         new_target-&gt;set(BlockBegin::backward_branch_target_flag);
6170       }
6171 
6172       // collect a list with all predecessors that contains each predecessor only once
6173       // the predecessors of cur are changed during the substitution, so a copy of the
6174       // predecessor list is necessary
6175       int j;
6176       _original_preds.clear();
6177       for (j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6178         BlockBegin* pred = block-&gt;pred_at(j);
6179         if (_original_preds.find(pred) == -1) {
6180           _original_preds.append(pred);
6181         }
6182       }
6183 
6184       for (j = _original_preds.length() - 1; j &gt;= 0; j--) {
6185         BlockBegin* pred = _original_preds.at(j);
6186         substitute_branch_target(pred, block, new_target);
6187         pred-&gt;substitute_sux(block, new_target);
6188       }
6189     } else {
6190       // adjust position of this block in the block list if blocks before
6191       // have been deleted
6192       if (new_pos != old_pos) {
6193         code-&gt;at_put(new_pos, code-&gt;at(old_pos));
6194       }
6195       new_pos++;
6196     }
6197     old_pos++;
6198   }
6199   code-&gt;trunc_to(new_pos);
6200 
6201   DEBUG_ONLY(verify(code));
6202 }
6203 
6204 void ControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
6205   // skip the last block because there a branch is always necessary
6206   for (int i = code-&gt;length() - 2; i &gt;= 0; i--) {
6207     BlockBegin* block = code-&gt;at(i);
6208     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6209 
6210     LIR_Op* last_op = instructions-&gt;last();
6211     if (last_op-&gt;code() == lir_branch) {
6212       assert(last_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6213       LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
6214 
6215       assert(last_branch-&gt;block() != NULL, &quot;last branch must always have a block as target&quot;);
6216       assert(last_branch-&gt;label() == last_branch-&gt;block()-&gt;label(), &quot;must be equal&quot;);
6217 
6218       if (last_branch-&gt;info() == NULL) {
6219         if (last_branch-&gt;block() == code-&gt;at(i + 1)) {
6220 
6221           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6222 
6223           // delete last branch instruction
6224           instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6225 
6226         } else {
6227           LIR_Op* prev_op = instructions-&gt;at(instructions-&gt;length() - 2);
6228           if (prev_op-&gt;code() == lir_branch || prev_op-&gt;code() == lir_cond_float_branch) {
6229             assert(prev_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6230             LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
6231 
6232             if (prev_branch-&gt;stub() == NULL) {
6233 
6234               LIR_Op2* prev_cmp = NULL;
6235               // There might be a cmove inserted for profiling which depends on the same
6236               // compare. If we change the condition of the respective compare, we have
6237               // to take care of this cmove as well.
6238               LIR_Op2* prev_cmove = NULL;
6239 
6240               for(int j = instructions-&gt;length() - 3; j &gt;= 0 &amp;&amp; prev_cmp == NULL; j--) {
6241                 prev_op = instructions-&gt;at(j);
6242                 // check for the cmove
6243                 if (prev_op-&gt;code() == lir_cmove) {
6244                   assert(prev_op-&gt;as_Op2() != NULL, &quot;cmove must be of type LIR_Op2&quot;);
6245                   prev_cmove = (LIR_Op2*)prev_op;
6246                   assert(prev_branch-&gt;cond() == prev_cmove-&gt;condition(), &quot;should be the same&quot;);
6247                 }
6248                 if (prev_op-&gt;code() == lir_cmp) {
6249                   assert(prev_op-&gt;as_Op2() != NULL, &quot;branch must be of type LIR_Op2&quot;);
6250                   prev_cmp = (LIR_Op2*)prev_op;
6251                   assert(prev_branch-&gt;cond() == prev_cmp-&gt;condition(), &quot;should be the same&quot;);
6252                 }
6253               }
6254               // Guarantee because it is dereferenced below.
6255               guarantee(prev_cmp != NULL, &quot;should have found comp instruction for branch&quot;);
6256               if (prev_branch-&gt;block() == code-&gt;at(i + 1) &amp;&amp; prev_branch-&gt;info() == NULL) {
6257 
6258                 TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Negating conditional branch and deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6259 
6260                 // eliminate a conditional branch to the immediate successor
6261                 prev_branch-&gt;change_block(last_branch-&gt;block());
6262                 prev_branch-&gt;negate_cond();
6263                 prev_cmp-&gt;set_condition(prev_branch-&gt;cond());
6264                 instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6265                 // if we do change the condition, we have to change the cmove as well
6266                 if (prev_cmove != NULL) {
6267                   prev_cmove-&gt;set_condition(prev_branch-&gt;cond());
6268                   LIR_Opr t = prev_cmove-&gt;in_opr1();
6269                   prev_cmove-&gt;set_in_opr1(prev_cmove-&gt;in_opr2());
6270                   prev_cmove-&gt;set_in_opr2(t);
6271                 }
6272               }
6273             }
6274           }
6275         }
6276       }
6277     }
6278   }
6279 
6280   DEBUG_ONLY(verify(code));
6281 }
6282 
6283 void ControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
6284 #ifdef ASSERT
6285   ResourceBitMap return_converted(BlockBegin::number_of_blocks());
6286 #endif
6287 
6288   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6289     BlockBegin* block = code-&gt;at(i);
6290     LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
6291     LIR_Op*     cur_last_op = cur_instructions-&gt;last();
6292 
6293     assert(cur_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6294     if (cur_instructions-&gt;length() == 2 &amp;&amp; cur_last_op-&gt;code() == lir_return) {
6295       // the block contains only a label and a return
6296       // if a predecessor ends with an unconditional jump to this block, then the jump
6297       // can be replaced with a return instruction
6298       //
6299       // Note: the original block with only a return statement cannot be deleted completely
6300       //       because the predecessors might have other (conditional) jumps to this block
6301       //       -&gt; this may lead to unnecesary return instructions in the final code
6302 
6303       assert(cur_last_op-&gt;info() == NULL, &quot;return instructions do not have debug information&quot;);
6304       assert(block-&gt;number_of_sux() == 0 ||
6305              (return_converted.at(block-&gt;block_id()) &amp;&amp; block-&gt;number_of_sux() == 1),
6306              &quot;blocks that end with return must not have successors&quot;);
6307 
6308       assert(cur_last_op-&gt;as_Op1() != NULL, &quot;return must be LIR_Op1&quot;);
6309       LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)-&gt;in_opr();
6310 
6311       for (int j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6312         BlockBegin* pred = block-&gt;pred_at(j);
6313         LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
6314         LIR_Op*     pred_last_op = pred_instructions-&gt;last();
6315 
6316         if (pred_last_op-&gt;code() == lir_branch) {
6317           assert(pred_last_op-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
6318           LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
6319 
6320           if (pred_last_branch-&gt;block() == block &amp;&amp; pred_last_branch-&gt;cond() == lir_cond_always &amp;&amp; pred_last_branch-&gt;info() == NULL) {
6321             // replace the jump to a return with a direct return
6322             // Note: currently the edge between the blocks is not deleted
6323             pred_instructions-&gt;at_put(pred_instructions-&gt;length() - 1, new LIR_Op1(lir_return, return_opr));
6324 #ifdef ASSERT
6325             return_converted.set_bit(pred-&gt;block_id());
6326 #endif
6327           }
6328         }
6329       }
6330     }
6331   }
6332 }
6333 
6334 
6335 #ifdef ASSERT
6336 void ControlFlowOptimizer::verify(BlockList* code) {
6337   for (int i = 0; i &lt; code-&gt;length(); i++) {
6338     BlockBegin* block = code-&gt;at(i);
6339     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6340 
6341     int j;
6342     for (j = 0; j &lt; instructions-&gt;length(); j++) {
6343       LIR_OpBranch* op_branch = instructions-&gt;at(j)-&gt;as_OpBranch();
6344 
6345       if (op_branch != NULL) {
6346         assert(op_branch-&gt;block() == NULL || code-&gt;find(op_branch-&gt;block()) != -1, &quot;branch target not valid&quot;);
6347         assert(op_branch-&gt;ublock() == NULL || code-&gt;find(op_branch-&gt;ublock()) != -1, &quot;branch target not valid&quot;);
6348       }
6349     }
6350 
6351     for (j = 0; j &lt; block-&gt;number_of_sux() - 1; j++) {
6352       BlockBegin* sux = block-&gt;sux_at(j);
6353       assert(code-&gt;find(sux) != -1, &quot;successor not valid&quot;);
6354     }
6355 
6356     for (j = 0; j &lt; block-&gt;number_of_preds() - 1; j++) {
6357       BlockBegin* pred = block-&gt;pred_at(j);
6358       assert(code-&gt;find(pred) != -1, &quot;successor not valid&quot;);
6359     }
6360   }
6361 }
6362 #endif
6363 
6364 
6365 #ifndef PRODUCT
6366 
6367 // Implementation of LinearStatistic
6368 
6369 const char* LinearScanStatistic::counter_name(int counter_idx) {
6370   switch (counter_idx) {
6371     case counter_method:          return &quot;compiled methods&quot;;
6372     case counter_fpu_method:      return &quot;methods using fpu&quot;;
6373     case counter_loop_method:     return &quot;methods with loops&quot;;
6374     case counter_exception_method:return &quot;methods with xhandler&quot;;
6375 
6376     case counter_loop:            return &quot;loops&quot;;
6377     case counter_block:           return &quot;blocks&quot;;
6378     case counter_loop_block:      return &quot;blocks inside loop&quot;;
6379     case counter_exception_block: return &quot;exception handler entries&quot;;
6380     case counter_interval:        return &quot;intervals&quot;;
6381     case counter_fixed_interval:  return &quot;fixed intervals&quot;;
6382     case counter_range:           return &quot;ranges&quot;;
6383     case counter_fixed_range:     return &quot;fixed ranges&quot;;
6384     case counter_use_pos:         return &quot;use positions&quot;;
6385     case counter_fixed_use_pos:   return &quot;fixed use positions&quot;;
6386     case counter_spill_slots:     return &quot;spill slots&quot;;
6387 
6388     // counter for classes of lir instructions
6389     case counter_instruction:     return &quot;total instructions&quot;;
6390     case counter_label:           return &quot;labels&quot;;
6391     case counter_entry:           return &quot;method entries&quot;;
6392     case counter_return:          return &quot;method returns&quot;;
6393     case counter_call:            return &quot;method calls&quot;;
6394     case counter_move:            return &quot;moves&quot;;
6395     case counter_cmp:             return &quot;compare&quot;;
6396     case counter_cond_branch:     return &quot;conditional branches&quot;;
6397     case counter_uncond_branch:   return &quot;unconditional branches&quot;;
6398     case counter_stub_branch:     return &quot;branches to stub&quot;;
6399     case counter_alu:             return &quot;artithmetic + logic&quot;;
6400     case counter_alloc:           return &quot;allocations&quot;;
6401     case counter_sync:            return &quot;synchronisation&quot;;
6402     case counter_throw:           return &quot;throw&quot;;
6403     case counter_unwind:          return &quot;unwind&quot;;
6404     case counter_typecheck:       return &quot;type+null-checks&quot;;
6405     case counter_fpu_stack:       return &quot;fpu-stack&quot;;
6406     case counter_misc_inst:       return &quot;other instructions&quot;;
6407     case counter_other_inst:      return &quot;misc. instructions&quot;;
6408 
6409     // counter for different types of moves
6410     case counter_move_total:      return &quot;total moves&quot;;
6411     case counter_move_reg_reg:    return &quot;register-&gt;register&quot;;
6412     case counter_move_reg_stack:  return &quot;register-&gt;stack&quot;;
6413     case counter_move_stack_reg:  return &quot;stack-&gt;register&quot;;
6414     case counter_move_stack_stack:return &quot;stack-&gt;stack&quot;;
6415     case counter_move_reg_mem:    return &quot;register-&gt;memory&quot;;
6416     case counter_move_mem_reg:    return &quot;memory-&gt;register&quot;;
6417     case counter_move_const_any:  return &quot;constant-&gt;any&quot;;
6418 
6419     case blank_line_1:            return &quot;&quot;;
6420     case blank_line_2:            return &quot;&quot;;
6421 
6422     default: ShouldNotReachHere(); return &quot;&quot;;
6423   }
6424 }
6425 
6426 LinearScanStatistic::Counter LinearScanStatistic::base_counter(int counter_idx) {
6427   if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
6428     return counter_method;
6429   } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
6430     return counter_block;
6431   } else if (counter_idx &gt;= counter_instruction &amp;&amp; counter_idx &lt;= counter_other_inst) {
6432     return counter_instruction;
6433   } else if (counter_idx &gt;= counter_move_total &amp;&amp; counter_idx &lt;= counter_move_const_any) {
6434     return counter_move_total;
6435   }
6436   return invalid_counter;
6437 }
6438 
6439 LinearScanStatistic::LinearScanStatistic() {
6440   for (int i = 0; i &lt; number_of_counters; i++) {
6441     _counters_sum[i] = 0;
6442     _counters_max[i] = -1;
6443   }
6444 
6445 }
6446 
6447 // add the method-local numbers to the total sum
6448 void LinearScanStatistic::sum_up(LinearScanStatistic &amp;method_statistic) {
6449   for (int i = 0; i &lt; number_of_counters; i++) {
6450     _counters_sum[i] += method_statistic._counters_sum[i];
6451     _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
6452   }
6453 }
6454 
6455 void LinearScanStatistic::print(const char* title) {
6456   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6457     tty-&gt;cr();
6458     tty-&gt;print_cr(&quot;***** LinearScan statistic - %s *****&quot;, title);
6459 
6460     for (int i = 0; i &lt; number_of_counters; i++) {
6461       if (_counters_sum[i] &gt; 0 || _counters_max[i] &gt;= 0) {
6462         tty-&gt;print(&quot;%25s: %8d&quot;, counter_name(i), _counters_sum[i]);
6463 
6464         LinearScanStatistic::Counter cntr = base_counter(i);
6465         if (cntr != invalid_counter) {
6466           tty-&gt;print(&quot;  (%5.1f%%) &quot;, _counters_sum[i] * 100.0 / _counters_sum[cntr]);
6467         } else {
6468           tty-&gt;print(&quot;           &quot;);
6469         }
6470 
6471         if (_counters_max[i] &gt;= 0) {
6472           tty-&gt;print(&quot;%8d&quot;, _counters_max[i]);
6473         }
6474       }
6475       tty-&gt;cr();
6476     }
6477   }
6478 }
6479 
6480 void LinearScanStatistic::collect(LinearScan* allocator) {
6481   inc_counter(counter_method);
6482   if (allocator-&gt;has_fpu_registers()) {
6483     inc_counter(counter_fpu_method);
6484   }
6485   if (allocator-&gt;num_loops() &gt; 0) {
6486     inc_counter(counter_loop_method);
6487   }
6488   inc_counter(counter_loop, allocator-&gt;num_loops());
6489   inc_counter(counter_spill_slots, allocator-&gt;max_spills());
6490 
6491   int i;
6492   for (i = 0; i &lt; allocator-&gt;interval_count(); i++) {
6493     Interval* cur = allocator-&gt;interval_at(i);
6494 
6495     if (cur != NULL) {
6496       inc_counter(counter_interval);
6497       inc_counter(counter_use_pos, cur-&gt;num_use_positions());
6498       if (LinearScan::is_precolored_interval(cur)) {
6499         inc_counter(counter_fixed_interval);
6500         inc_counter(counter_fixed_use_pos, cur-&gt;num_use_positions());
6501       }
6502 
6503       Range* range = cur-&gt;first();
6504       while (range != Range::end()) {
6505         inc_counter(counter_range);
6506         if (LinearScan::is_precolored_interval(cur)) {
6507           inc_counter(counter_fixed_range);
6508         }
6509         range = range-&gt;next();
6510       }
6511     }
6512   }
6513 
6514   bool has_xhandlers = false;
6515   // Note: only count blocks that are in code-emit order
6516   for (i = 0; i &lt; allocator-&gt;ir()-&gt;code()-&gt;length(); i++) {
6517     BlockBegin* cur = allocator-&gt;ir()-&gt;code()-&gt;at(i);
6518 
6519     inc_counter(counter_block);
6520     if (cur-&gt;loop_depth() &gt; 0) {
6521       inc_counter(counter_loop_block);
6522     }
6523     if (cur-&gt;is_set(BlockBegin::exception_entry_flag)) {
6524       inc_counter(counter_exception_block);
6525       has_xhandlers = true;
6526     }
6527 
6528     LIR_OpList* instructions = cur-&gt;lir()-&gt;instructions_list();
6529     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
6530       LIR_Op* op = instructions-&gt;at(j);
6531 
6532       inc_counter(counter_instruction);
6533 
6534       switch (op-&gt;code()) {
6535         case lir_label:           inc_counter(counter_label); break;
6536         case lir_std_entry:
6537         case lir_osr_entry:       inc_counter(counter_entry); break;
6538         case lir_return:          inc_counter(counter_return); break;
6539 
6540         case lir_rtcall:
6541         case lir_static_call:
6542         case lir_optvirtual_call:
6543         case lir_virtual_call:    inc_counter(counter_call); break;
6544 
6545         case lir_move: {
6546           inc_counter(counter_move);
6547           inc_counter(counter_move_total);
6548 
6549           LIR_Opr in = op-&gt;as_Op1()-&gt;in_opr();
6550           LIR_Opr res = op-&gt;as_Op1()-&gt;result_opr();
6551           if (in-&gt;is_register()) {
6552             if (res-&gt;is_register()) {
6553               inc_counter(counter_move_reg_reg);
6554             } else if (res-&gt;is_stack()) {
6555               inc_counter(counter_move_reg_stack);
6556             } else if (res-&gt;is_address()) {
6557               inc_counter(counter_move_reg_mem);
6558             } else {
6559               ShouldNotReachHere();
6560             }
6561           } else if (in-&gt;is_stack()) {
6562             if (res-&gt;is_register()) {
6563               inc_counter(counter_move_stack_reg);
6564             } else {
6565               inc_counter(counter_move_stack_stack);
6566             }
6567           } else if (in-&gt;is_address()) {
6568             assert(res-&gt;is_register(), &quot;must be&quot;);
6569             inc_counter(counter_move_mem_reg);
6570           } else if (in-&gt;is_constant()) {
6571             inc_counter(counter_move_const_any);
6572           } else {
6573             ShouldNotReachHere();
6574           }
6575           break;
6576         }
6577 
6578         case lir_cmp:             inc_counter(counter_cmp); break;
6579 
6580         case lir_branch:
6581         case lir_cond_float_branch: {
6582           LIR_OpBranch* branch = op-&gt;as_OpBranch();
6583           if (branch-&gt;block() == NULL) {
6584             inc_counter(counter_stub_branch);
6585           } else if (branch-&gt;cond() == lir_cond_always) {
6586             inc_counter(counter_uncond_branch);
6587           } else {
6588             inc_counter(counter_cond_branch);
6589           }
6590           break;
6591         }
6592 
6593         case lir_neg:
6594         case lir_add:
6595         case lir_sub:
6596         case lir_mul:
6597         case lir_mul_strictfp:
6598         case lir_div:
6599         case lir_div_strictfp:
6600         case lir_rem:
6601         case lir_sqrt:
6602         case lir_abs:
6603         case lir_log10:
6604         case lir_logic_and:
6605         case lir_logic_or:
6606         case lir_logic_xor:
6607         case lir_shl:
6608         case lir_shr:
6609         case lir_ushr:            inc_counter(counter_alu); break;
6610 
6611         case lir_alloc_object:
6612         case lir_alloc_array:     inc_counter(counter_alloc); break;
6613 
6614         case lir_monaddr:
6615         case lir_lock:
6616         case lir_unlock:          inc_counter(counter_sync); break;
6617 
6618         case lir_throw:           inc_counter(counter_throw); break;
6619 
6620         case lir_unwind:          inc_counter(counter_unwind); break;
6621 
6622         case lir_null_check:
6623         case lir_leal:
6624         case lir_instanceof:
6625         case lir_checkcast:
6626         case lir_store_check:     inc_counter(counter_typecheck); break;
6627 
6628         case lir_fpop_raw:
6629         case lir_fxch:
6630         case lir_fld:             inc_counter(counter_fpu_stack); break;
6631 
6632         case lir_nop:
6633         case lir_push:
6634         case lir_pop:
6635         case lir_convert:
6636         case lir_roundfp:
6637         case lir_cmove:           inc_counter(counter_misc_inst); break;
6638 
6639         default:                  inc_counter(counter_other_inst); break;
6640       }
6641     }
6642   }
6643 
6644   if (has_xhandlers) {
6645     inc_counter(counter_exception_method);
6646   }
6647 }
6648 
6649 void LinearScanStatistic::compute(LinearScan* allocator, LinearScanStatistic &amp;global_statistic) {
6650   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6651 
6652     LinearScanStatistic local_statistic = LinearScanStatistic();
6653 
6654     local_statistic.collect(allocator);
6655     global_statistic.sum_up(local_statistic);
6656 
6657     if (TraceLinearScanLevel &gt; 2) {
6658       local_statistic.print(&quot;current local statistic&quot;);
6659     }
6660   }
6661 }
6662 
6663 
6664 // Implementation of LinearTimers
6665 
6666 LinearScanTimers::LinearScanTimers() {
6667   for (int i = 0; i &lt; number_of_timers; i++) {
6668     timer(i)-&gt;reset();
6669   }
6670 }
6671 
6672 const char* LinearScanTimers::timer_name(int idx) {
6673   switch (idx) {
6674     case timer_do_nothing:               return &quot;Nothing (Time Check)&quot;;
6675     case timer_number_instructions:      return &quot;Number Instructions&quot;;
6676     case timer_compute_local_live_sets:  return &quot;Local Live Sets&quot;;
6677     case timer_compute_global_live_sets: return &quot;Global Live Sets&quot;;
6678     case timer_build_intervals:          return &quot;Build Intervals&quot;;
6679     case timer_sort_intervals_before:    return &quot;Sort Intervals Before&quot;;
6680     case timer_allocate_registers:       return &quot;Allocate Registers&quot;;
6681     case timer_resolve_data_flow:        return &quot;Resolve Data Flow&quot;;
6682     case timer_sort_intervals_after:     return &quot;Sort Intervals After&quot;;
6683     case timer_eliminate_spill_moves:    return &quot;Spill optimization&quot;;
6684     case timer_assign_reg_num:           return &quot;Assign Reg Num&quot;;
6685     case timer_allocate_fpu_stack:       return &quot;Allocate FPU Stack&quot;;
6686     case timer_optimize_lir:             return &quot;Optimize LIR&quot;;
6687     default: ShouldNotReachHere();       return &quot;&quot;;
6688   }
6689 }
6690 
6691 void LinearScanTimers::begin_method() {
6692   if (TimeEachLinearScan) {
6693     // reset all timers to measure only current method
6694     for (int i = 0; i &lt; number_of_timers; i++) {
6695       timer(i)-&gt;reset();
6696     }
6697   }
6698 }
6699 
6700 void LinearScanTimers::end_method(LinearScan* allocator) {
6701   if (TimeEachLinearScan) {
6702 
6703     double c = timer(timer_do_nothing)-&gt;seconds();
6704     double total = 0;
6705     for (int i = 1; i &lt; number_of_timers; i++) {
6706       total += timer(i)-&gt;seconds() - c;
6707     }
6708 
6709     if (total &gt;= 0.0005) {
6710       // print all information in one line for automatic processing
6711       tty-&gt;print(&quot;@&quot;); allocator-&gt;compilation()-&gt;method()-&gt;print_name();
6712 
6713       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;compilation()-&gt;method()-&gt;code_size());
6714       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_at(allocator-&gt;block_count() - 1)-&gt;last_lir_instruction_id() / 2);
6715       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_count());
6716       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_virtual_regs());
6717       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;interval_count());
6718       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;_num_calls);
6719       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_loops());
6720 
6721       tty-&gt;print(&quot;@ %6.6f &quot;, total);
6722       for (int i = 1; i &lt; number_of_timers; i++) {
6723         tty-&gt;print(&quot;@ %4.1f &quot;, ((timer(i)-&gt;seconds() - c) / total) * 100);
6724       }
6725       tty-&gt;cr();
6726     }
6727   }
6728 }
6729 
6730 void LinearScanTimers::print(double total_time) {
6731   if (TimeLinearScan) {
6732     // correction value: sum of dummy-timer that only measures the time that
6733     // is necesary to start and stop itself
6734     double c = timer(timer_do_nothing)-&gt;seconds();
6735 
6736     for (int i = 0; i &lt; number_of_timers; i++) {
6737       double t = timer(i)-&gt;seconds();
6738       tty-&gt;print_cr(&quot;    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)&quot;, timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
6739     }
6740   }
6741 }
6742 
6743 #endif // #ifndef PRODUCT
    </pre>
  </body>
</html>
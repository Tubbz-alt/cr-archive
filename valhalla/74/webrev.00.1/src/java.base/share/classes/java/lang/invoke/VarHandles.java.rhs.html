<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 
 30 import java.lang.reflect.Constructor;
 31 import java.lang.reflect.Field;
 32 import java.lang.reflect.Method;
 33 import java.lang.reflect.Modifier;
 34 import java.nio.ByteOrder;
 35 import java.util.ArrayList;
 36 import java.util.List;
 37 import java.util.Map;
 38 import java.util.Objects;
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.ConcurrentMap;
 41 import java.util.stream.Stream;
 42 
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 44 import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_IDENTITY_ADAPT;
 45 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
 46 
 47 final class VarHandles {
 48 
 49     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 50         @Override
 51         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 52             return new ConcurrentHashMap&lt;&gt;();
 53         }
 54     };
 55 
 56     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 57         if (!f.isStatic()) {
 58             long foffset = MethodHandleNatives.objectFieldOffset(f);
 59             if (!type.isPrimitive()) {
<a name="1" id="anc1"></a><span class="line-modified"> 60                 if (f.isFlattened()) {</span>
<span class="line-added"> 61                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="line-added"> 62                         ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)</span>
<span class="line-added"> 63                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type));</span>
<span class="line-added"> 64                 } else {</span>
<span class="line-added"> 65                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 66                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
 67                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));
<a name="2" id="anc2"></a><span class="line-added"> 68                 }</span>
 69             }
 70             else if (type == boolean.class) {
 71                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 72                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
 73                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset));
 74             }
 75             else if (type == byte.class) {
 76                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 77                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
 78                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset));
 79             }
 80             else if (type == short.class) {
 81                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 82                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
 83                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset));
 84             }
 85             else if (type == char.class) {
 86                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 87                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
 88                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset));
 89             }
 90             else if (type == int.class) {
 91                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 92                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
 93                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset));
 94             }
 95             else if (type == long.class) {
 96                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 97                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
 98                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset));
 99             }
100             else if (type == float.class) {
101                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
102                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
103                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset));
104             }
105             else if (type == double.class) {
106                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
107                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
108                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset));
109             }
110             else {
111                 throw new UnsupportedOperationException();
112             }
113         }
114         else {
115             // TODO This is not lazy on first invocation
116             // and might cause some circular initialization issues
117 
118             // Replace with something similar to direct method handles
119             // where a barrier is used then elided after use
120 
121             if (UNSAFE.shouldBeInitialized(refc))
122                 UNSAFE.ensureClassInitialized(refc);
123 
124             Object base = MethodHandleNatives.staticFieldBase(f);
125             long foffset = MethodHandleNatives.staticFieldOffset(f);
126             if (!type.isPrimitive()) {
<a name="3" id="anc3"></a><span class="line-modified">127                 if (f.isFlattened()) {</span>
<span class="line-modified">128                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="line-modified">129                             ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)</span>
<span class="line-added">130                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type));</span>
<span class="line-added">131                 } else {</span>
<span class="line-added">132                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="line-added">133                             ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)</span>
<span class="line-added">134                             : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);</span>
<span class="line-added">135                 }</span>
136             }
137             else if (type == boolean.class) {
138                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
139                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
140                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));
141             }
142             else if (type == byte.class) {
143                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
144                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
145                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset));
146             }
147             else if (type == short.class) {
148                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
149                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
150                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset));
151             }
152             else if (type == char.class) {
153                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
154                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
155                        : new VarHandleChars.FieldStaticReadWrite(base, foffset));
156             }
157             else if (type == int.class) {
158                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
159                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
160                        : new VarHandleInts.FieldStaticReadWrite(base, foffset));
161             }
162             else if (type == long.class) {
163                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
164                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
165                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset));
166             }
167             else if (type == float.class) {
168                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
169                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
170                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset));
171             }
172             else if (type == double.class) {
173                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
174                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
175                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));
176             }
177             else {
178                 throw new UnsupportedOperationException();
179             }
180         }
181     }
182 
183     // Required by instance field handles
184     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
185                                                long offset,
186                                                Class&lt;?&gt; fieldType) {
187         for (Field f : receiverType.getDeclaredFields()) {
188             if (Modifier.isStatic(f.getModifiers())) continue;
189 
190             if (offset == UNSAFE.objectFieldOffset(f)) {
191                 assert f.getType() == fieldType;
192                 return f;
193             }
194         }
195         throw new InternalError(&quot;Field not found at offset&quot;);
196     }
197 
198     // Required by instance static field handles
199     static Field getStaticFieldFromBaseAndOffset(Object base,
200                                                  long offset,
201                                                  Class&lt;?&gt; fieldType) {
202         // @@@ This is a little fragile assuming the base is the class
203         Class&lt;?&gt; receiverType = (Class&lt;?&gt;) base;
204         for (Field f : receiverType.getDeclaredFields()) {
205             if (!Modifier.isStatic(f.getModifiers())) continue;
206 
207             if (offset == UNSAFE.staticFieldOffset(f)) {
208                 assert f.getType() == fieldType;
209                 return f;
210             }
211         }
212         throw new InternalError(&quot;Static field not found at offset&quot;);
213     }
214 
215     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
216         if (!arrayClass.isArray())
217             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
218 
219         Class&lt;?&gt; componentType = arrayClass.getComponentType();
220 
221         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
222         int ascale = UNSAFE.arrayIndexScale(arrayClass);
223         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
224 
225         if (!componentType.isPrimitive()) {
<a name="4" id="anc4"></a><span class="line-modified">226             // the redundant componentType.isValue() check is there to</span>
<span class="line-added">227             // minimize the performance impact to non-value array.</span>
<span class="line-added">228             // It should be removed when Unsafe::isFlattenedArray is intrinsified.</span>
<span class="line-added">229 </span>
<span class="line-added">230             return maybeAdapt(componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)</span>
<span class="line-added">231                 ? new VarHandleValues.Array(aoffset, ashift, arrayClass)</span>
<span class="line-added">232                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass));</span>
233         }
234         else if (componentType == boolean.class) {
235             return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));
236         }
237         else if (componentType == byte.class) {
238             return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));
239         }
240         else if (componentType == short.class) {
241             return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));
242         }
243         else if (componentType == char.class) {
244             return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));
245         }
246         else if (componentType == int.class) {
247             return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));
248         }
249         else if (componentType == long.class) {
250             return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));
251         }
252         else if (componentType == float.class) {
253             return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));
254         }
255         else if (componentType == double.class) {
256             return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));
257         }
258         else {
259             throw new UnsupportedOperationException();
260         }
261     }
262 
263     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
264                                          boolean be) {
265         if (!viewArrayClass.isArray())
266             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
267 
268         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
269 
270         if (viewComponentType == long.class) {
271             return maybeAdapt(new VarHandleByteArrayAsLongs.ArrayHandle(be));
272         }
273         else if (viewComponentType == int.class) {
274             return maybeAdapt(new VarHandleByteArrayAsInts.ArrayHandle(be));
275         }
276         else if (viewComponentType == short.class) {
277             return maybeAdapt(new VarHandleByteArrayAsShorts.ArrayHandle(be));
278         }
279         else if (viewComponentType == char.class) {
280             return maybeAdapt(new VarHandleByteArrayAsChars.ArrayHandle(be));
281         }
282         else if (viewComponentType == double.class) {
283             return maybeAdapt(new VarHandleByteArrayAsDoubles.ArrayHandle(be));
284         }
285         else if (viewComponentType == float.class) {
286             return maybeAdapt(new VarHandleByteArrayAsFloats.ArrayHandle(be));
287         }
288 
289         throw new UnsupportedOperationException();
290     }
291 
292     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
293                                               boolean be) {
294         if (!viewArrayClass.isArray())
295             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
296 
297         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
298 
299         if (viewComponentType == long.class) {
300             return maybeAdapt(new VarHandleByteArrayAsLongs.ByteBufferHandle(be));
301         }
302         else if (viewComponentType == int.class) {
303             return maybeAdapt(new VarHandleByteArrayAsInts.ByteBufferHandle(be));
304         }
305         else if (viewComponentType == short.class) {
306             return maybeAdapt(new VarHandleByteArrayAsShorts.ByteBufferHandle(be));
307         }
308         else if (viewComponentType == char.class) {
309             return maybeAdapt(new VarHandleByteArrayAsChars.ByteBufferHandle(be));
310         }
311         else if (viewComponentType == double.class) {
312             return maybeAdapt(new VarHandleByteArrayAsDoubles.ByteBufferHandle(be));
313         }
314         else if (viewComponentType == float.class) {
315             return maybeAdapt(new VarHandleByteArrayAsFloats.ByteBufferHandle(be));
316         }
317 
318         throw new UnsupportedOperationException();
319     }
320 
321     /**
322      * Creates a memory access VarHandle.
323      *
324      * Resulting VarHandle will take a memory address as first argument,
325      * and a certain number of coordinate {@code long} parameters, depending on the length
326      * of the {@code strides} argument array.
327      *
328      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
329      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
330      *
331      * @param carrier the Java carrier type.
332      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
333      * @param byteOrder the byte order.
334      * @param offset a constant offset for the access.
335      * @param strides the scale factors with which to multiply given access coordinates.
336      * @return the created VarHandle.
337      */
338     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
339                                                  ByteOrder byteOrder, long offset, long[] strides) {
340         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
341             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
342         }
343         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
344         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
345 
346         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
347         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
348                 dims -&gt; new MemoryAccessVarHandleGenerator(carrier, dims)
349                             .generateHandleFactory());
350 
351         try {
352             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));
353         } catch (Throwable ex) {
354             throw new IllegalStateException(ex);
355         }
356     }
357 
358     private static VarHandle maybeAdapt(VarHandle target) {
359         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;
360         target = filterValue(target,
361                         MethodHandles.identity(target.varType()), MethodHandles.identity(target.varType()));
362         MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);
363         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {
364             target = filterCoordinates(target, i, MethodHandles.identity(mtype.parameterType(i)));
365         }
366         return target;
367     }
368 
369     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {
370         Objects.nonNull(target);
371         Objects.nonNull(filterToTarget);
372         Objects.nonNull(filterFromTarget);
373         //check that from/to filters do not throw checked exceptions
374         noCheckedExceptions(filterToTarget);
375         noCheckedExceptions(filterFromTarget);
376 
377         //check that from/to filters have right signatures
378         if (filterFromTarget.type().parameterCount() != 1) {
379             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());
380         } else if (filterToTarget.type().parameterCount() != 1) {
381             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());
382         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||
383                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {
384             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());
385         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {
386             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());
387         } else if (target.varType() != filterToTarget.type().returnType()) {
388             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());
389         }
390 
391         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),
392                 (mode, modeHandle) -&gt; {
393                     int lastParameterPos = modeHandle.type().parameterCount() - 1;
394                     return switch (mode.at) {
395                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
396                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
397                         case GET_AND_UPDATE -&gt; {
398                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
399                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
400                         }
401                         case COMPARE_AND_EXCHANGE -&gt; {
402                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);
403                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);
404                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
405                         }
406                         case COMPARE_AND_SET -&gt; {
407                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);
408                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);
409                         }
410                     };
411                 });
412     }
413 
414     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {
415         Objects.nonNull(target);
416         Objects.nonNull(filters);
417 
418         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
419         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
420             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
421         } else if (pos + filters.length &gt; targetCoordinates.size()) {
422             throw new IllegalArgumentException(&quot;Too many filters&quot;);
423         }
424 
425         if (filters.length == 0) return target;
426 
427         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
428         for (int i = 0 ; i &lt; filters.length ; i++) {
429             noCheckedExceptions(filters[i]);
430             MethodType filterType = filters[i].type();
431             if (filterType.parameterCount() != 1) {
432                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);
433             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {
434                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));
435             }
436             newCoordinates.set(pos + i, filters[i].type().parameterType(0));
437         }
438 
439         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
440                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));
441     }
442 
443     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {
444         Objects.nonNull(target);
445         Objects.nonNull(values);
446 
447         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
448         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
449             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
450         } else if (pos + values.length &gt; targetCoordinates.size()) {
451             throw new IllegalArgumentException(&quot;Too many values&quot;);
452         }
453 
454         if (values.length == 0) return target;
455 
456         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
457         for (int i = 0 ; i &lt; values.length ; i++) {
458             Class&lt;?&gt; pt = newCoordinates.get(pos);
459             if (pt.isPrimitive()) {
460                 Wrapper w = Wrapper.forPrimitiveType(pt);
461                 w.convert(values[i], pt);
462             } else {
463                 pt.cast(values[i]);
464             }
465             newCoordinates.remove(pos);
466         }
467 
468         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
469                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));
470     }
471 
472     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {
473         Objects.nonNull(target);
474         Objects.nonNull(newCoordinates);
475         Objects.nonNull(reorder);
476 
477         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
478         MethodHandles.permuteArgumentChecks(reorder,
479                 MethodType.methodType(void.class, newCoordinates),
480                 MethodType.methodType(void.class, targetCoordinates));
481 
482         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
483                 (mode, modeHandle) -&gt;
484                         MethodHandles.permuteArguments(modeHandle,
485                                 methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),
486                                 reorderArrayFor(mode.at, newCoordinates, reorder)));
487     }
488 
489     private static int numTrailingArgs(VarHandle.AccessType at) {
490         return switch (at) {
491             case GET -&gt; 0;
492             case GET_AND_UPDATE, SET -&gt; 1;
493             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;
494         };
495     }
496 
497     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {
498         int numTrailingArgs = numTrailingArgs(at);
499         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];
500         adjustedReorder[0] = 0;
501         for (int i = 0 ; i &lt; reorder.length ; i++) {
502             adjustedReorder[i + 1] = reorder[i] + 1;
503         }
504         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
505             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;
506         }
507         return adjustedReorder;
508     }
509 
510     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {
511         int numTrailingArgs = numTrailingArgs(at);
512         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));
513         adjustedType = adjustedType.appendParameterTypes(newCoordinates);
514         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {
515             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));
516         }
517         return adjustedType;
518     }
519 
520     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {
521         Objects.nonNull(target);
522         Objects.nonNull(filter);
523         noCheckedExceptions(filter);
524 
525         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
526         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {
527             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
528         } else if (filter.type().returnType() == void.class) {
529             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);
530         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {
531             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));
532         }
533 
534         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
535         newCoordinates.remove(pos);
536         newCoordinates.addAll(pos, filter.type().parameterList());
537 
538         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
539                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));
540     }
541 
542     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {
543         Objects.nonNull(target);
544         Objects.nonNull(valueTypes);
545 
546         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();
547         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {
548             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);
549         }
550 
551         if (valueTypes.length == 0) return target;
552 
553         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);
554         newCoordinates.addAll(pos, List.of(valueTypes));
555 
556         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),
557                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));
558     }
559 
560     private static void noCheckedExceptions(MethodHandle handle) {
561         if (handle instanceof DirectMethodHandle) {
562             DirectMethodHandle directHandle = (DirectMethodHandle)handle;
563             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);
564             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {
565                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,
566                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;
567                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
568                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;
569                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();
570                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,
571                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;
572                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);
573             };
574             if (exceptionTypes != null) {
575                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {
576                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);
577                 }
578             }
579         } else if (handle instanceof DelegatingMethodHandle) {
580             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());
581         } else {
582             //bound
583             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;
584             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {
585                 Object arg = boundHandle.arg(i);
586                 if (arg instanceof MethodHandle){
587                     noCheckedExceptions((MethodHandle) arg);
588                 }
589             }
590         }
591     }
592 
593     private static boolean isCheckedException(Class&lt;?&gt; clazz) {
594         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;
595                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;
596                 !Error.class.isAssignableFrom(clazz);
597     }
598 
599 //    /**
600 //     * A helper program to generate the VarHandleGuards class with a set of
601 //     * static guard methods each of which corresponds to a particular shape and
602 //     * performs a type check of the symbolic type descriptor with the VarHandle
603 //     * type descriptor before linking/invoking to the underlying operation as
604 //     * characterized by the operation member name on the VarForm of the
605 //     * VarHandle.
606 //     * &lt;p&gt;
607 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
608 //     * one for each method, for the most set of common method signatures.
609 //     * This reduces static initialization costs, footprint costs, and circular
610 //     * dependencies that may arise if a class is generated per LambdaForm.
611 //     * &lt;p&gt;
612 //     * A maximum of L*T*S methods will be generated where L is the number of
613 //     * access modes kinds (or unique operation signatures) and T is the number
614 //     * of variable types and S is the number of shapes (such as instance field,
615 //     * static field, or array access).
616 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
617 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
618 //     * generated.  However, the number is likely to be less since there
619 //     * be duplicate signatures.
620 //     * &lt;p&gt;
621 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
622 //     * that such methods should be treated as if a method of a class that is the
623 //     * result of compiling a LambdaForm.  Annotation of such methods is
624 //     * important for correct evaluation of certain assertions and method return
625 //     * type profiling in HotSpot.
626 //     */
627 //    public static class GuardMethodGenerator {
628 //
629 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
630 //
631 //        static final String GUARD_METHOD_TEMPLATE =
632 //                &quot;@ForceInline\n&quot; +
633 //                &quot;@LambdaForm.Compiled\n&quot; +
634 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
635 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
636 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
637 //                &quot;    }\n&quot; +
638 //                &quot;    else {\n&quot; +
639 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
640 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
641 //                &quot;    }\n&quot; +
642 //                &quot;}&quot;;
643 //
644 //        static final String GUARD_METHOD_TEMPLATE_V =
645 //                &quot;@ForceInline\n&quot; +
646 //                &quot;@LambdaForm.Compiled\n&quot; +
647 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
648 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
649 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
650 //                &quot;    }\n&quot; +
651 //                &quot;    else if (handle.isDirect() &amp;&amp; handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +
652 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
653 //                &quot;    }\n&quot; +
654 //                &quot;    else {\n&quot; +
655 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
656 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
657 //                &quot;    }\n&quot; +
658 //                &quot;}&quot;;
659 //
660 //        // A template for deriving the operations
661 //        // could be supported by annotating VarHandle directly with the
662 //        // operation kind and shape
663 //        interface VarHandleTemplate {
664 //            Object get();
665 //
666 //            void set(Object value);
667 //
668 //            boolean compareAndSet(Object actualValue, Object expectedValue);
669 //
670 //            Object compareAndExchange(Object actualValue, Object expectedValue);
671 //
672 //            Object getAndUpdate(Object value);
673 //        }
674 //
675 //        static class HandleType {
676 //            final Class&lt;?&gt; receiver;
677 //            final Class&lt;?&gt;[] intermediates;
678 //            final Class&lt;?&gt; value;
679 //
680 //            HandleType(Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
681 //                this.receiver = receiver;
682 //                this.intermediates = intermediates;
683 //                this.value = value;
684 //            }
685 //        }
686 //
687 //        /**
688 //         * @param args parameters
689 //         */
690 //        public static void main(String[] args) {
691 //            System.out.println(&quot;package java.lang.invoke;&quot;);
692 //            System.out.println();
693 //            System.out.println(&quot;import jdk.internal.vm.annotation.ForceInline;&quot;);
694 //            System.out.println();
695 //            System.out.println(&quot;// This class is auto-generated by &quot; +
696 //                               GuardMethodGenerator.class.getName() +
697 //                               &quot;. Do not edit.&quot;);
698 //            System.out.println(&quot;final class VarHandleGuards {&quot;);
699 //
700 //            System.out.println();
701 //
702 //            // Declare the stream of shapes
703 //            Stream&lt;HandleType&gt; hts = Stream.of(
704 //                    // Object-&gt;Object
705 //                    new HandleType(Object.class, Object.class),
706 //                    // Object-&gt;int
707 //                    new HandleType(Object.class, int.class),
708 //                    // Object-&gt;long
709 //                    new HandleType(Object.class, long.class),
710 //                    // Object-&gt;float
711 //                    new HandleType(Object.class, float.class),
712 //                    // Object-&gt;double
713 //                    new HandleType(Object.class, double.class),
714 //
715 //                    // &lt;static&gt;-&gt;Object
716 //                    new HandleType(null, Object.class),
717 //                    // &lt;static&gt;-&gt;int
718 //                    new HandleType(null, int.class),
719 //                    // &lt;static&gt;-&gt;long
720 //                    new HandleType(null, long.class),
721 //                    // &lt;static&gt;-&gt;float
722 //                    new HandleType(null, float.class),
723 //                    // &lt;static&gt;-&gt;double
724 //                    new HandleType(null, double.class),
725 //
726 //                    // Array[int]-&gt;Object
727 //                    new HandleType(Object.class, Object.class, int.class),
728 //                    // Array[int]-&gt;int
729 //                    new HandleType(Object.class, int.class, int.class),
730 //                    // Array[int]-&gt;long
731 //                    new HandleType(Object.class, long.class, int.class),
732 //                    // Array[int]-&gt;float
733 //                    new HandleType(Object.class, float.class, int.class),
734 //                    // Array[int]-&gt;double
735 //                    new HandleType(Object.class, double.class, int.class),
736 //
737 //                    // Array[long]-&gt;int
738 //                    new HandleType(Object.class, int.class, long.class),
739 //                    // Array[long]-&gt;long
740 //                    new HandleType(Object.class, long.class, long.class)
741 //            );
742 //
743 //            hts.flatMap(ht -&gt; Stream.of(VarHandleTemplate.class.getMethods()).
744 //                    map(m -&gt; generateMethodType(m, ht.receiver, ht.value, ht.intermediates))).
745 //                    distinct().
746 //                    map(mt -&gt; generateMethod(mt)).
747 //                    forEach(s -&gt; {
748 //                        System.out.println(s);
749 //                        System.out.println();
750 //                    });
751 //
752 //            System.out.println(&quot;}&quot;);
753 //        }
754 //
755 //        static MethodType generateMethodType(Method m, Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
756 //            Class&lt;?&gt; returnType = m.getReturnType() == Object.class
757 //                                  ? value : m.getReturnType();
758 //
759 //            List&lt;Class&lt;?&gt;&gt; params = new ArrayList&lt;&gt;();
760 //            if (receiver != null)
761 //                params.add(receiver);
762 //            for (int i = 0; i &lt; intermediates.length; i++) {
763 //                params.add(intermediates[i]);
764 //            }
765 //            for (Parameter p : m.getParameters()) {
766 //                params.add(value);
767 //            }
768 //            return MethodType.methodType(returnType, params);
769 //        }
770 //
771 //        static String generateMethod(MethodType mt) {
772 //            Class&lt;?&gt; returnType = mt.returnType();
773 //
774 //            LinkedHashMap&lt;String, Class&lt;?&gt;&gt; params = new LinkedHashMap&lt;&gt;();
775 //            params.put(&quot;handle&quot;, VarHandle.class);
776 //            for (int i = 0; i &lt; mt.parameterCount(); i++) {
777 //                params.put(&quot;arg&quot; + i, mt.parameterType(i));
778 //            }
779 //            params.put(&quot;ad&quot;, VarHandle.AccessDescriptor.class);
780 //
781 //            // Generate method signature line
782 //            String RETURN = className(returnType);
783 //            String NAME = &quot;guard&quot;;
784 //            String SIGNATURE = getSignature(mt);
785 //            String PARAMS = params.entrySet().stream().
786 //                    map(e -&gt; className(e.getValue()) + &quot; &quot; + e.getKey()).
787 //                    collect(joining(&quot;, &quot;));
788 //            String METHOD = GUARD_METHOD_SIG_TEMPLATE.
789 //                    replace(&quot;&lt;RETURN&gt;&quot;, RETURN).
790 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
791 //                    replace(&quot;&lt;SIGNATURE&gt;&quot;, SIGNATURE).
792 //                    replace(&quot;&lt;PARAMS&gt;&quot;, PARAMS);
793 //
794 //            // Generate method
795 //            params.remove(&quot;ad&quot;);
796 //
797 //            List&lt;String&gt; LINK_TO_STATIC_ARGS = params.keySet().stream().
798 //                    collect(toList());
799 //            LINK_TO_STATIC_ARGS.add(&quot;handle.vform.getMemberName(ad.mode)&quot;);
800 //            List&lt;String&gt; LINK_TO_STATIC_ARGS_V = params.keySet().stream().
801 //                    collect(toList());
802 //            LINK_TO_STATIC_ARGS_V.add(&quot;handle.vform.getMemberName_V(ad.mode)&quot;);
803 //
804 //            List&lt;String&gt; LINK_TO_INVOKER_ARGS = params.keySet().stream().
805 //                    collect(toList());
806 //
807 //            RETURN = returnType == void.class
808 //                     ? &quot;&quot;
809 //                     : returnType == Object.class
810 //                       ? &quot;return &quot;
811 //                       : &quot;return (&quot; + returnType.getName() + &quot;) &quot;;
812 //
813 //            String RESULT_ERASED = returnType == void.class
814 //                                   ? &quot;&quot;
815 //                                   : returnType != Object.class
816 //                                     ? &quot;return (&quot; + returnType.getName() + &quot;) &quot;
817 //                                     : &quot;Object r = &quot;;
818 //
819 //            String RETURN_ERASED = returnType != Object.class
820 //                                   ? &quot;&quot;
821 //                                   : &quot; return ad.returnType.cast(r);&quot;;
822 //
823 //            String template = returnType == void.class
824 //                              ? GUARD_METHOD_TEMPLATE_V
825 //                              : GUARD_METHOD_TEMPLATE;
826 //            return template.
827 //                    replace(&quot;&lt;METHOD&gt;&quot;, METHOD).
828 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
829 //                    replaceAll(&quot;&lt;RETURN&gt;&quot;, RETURN).
830 //                    replace(&quot;&lt;RESULT_ERASED&gt;&quot;, RESULT_ERASED).
831 //                    replace(&quot;&lt;RETURN_ERASED&gt;&quot;, RETURN_ERASED).
832 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS&gt;&quot;, LINK_TO_STATIC_ARGS.stream().
833 //                            collect(joining(&quot;, &quot;))).
834 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS_V&gt;&quot;, LINK_TO_STATIC_ARGS_V.stream().
835 //                            collect(joining(&quot;, &quot;))).
836 //                    replace(&quot;&lt;LINK_TO_INVOKER_ARGS&gt;&quot;, LINK_TO_INVOKER_ARGS.stream().
837 //                            collect(joining(&quot;, &quot;)))
838 //                    ;
839 //        }
840 //
841 //        static String className(Class&lt;?&gt; c) {
842 //            String n = c.getName();
843 //            if (n.startsWith(&quot;java.lang.&quot;)) {
844 //                n = n.replace(&quot;java.lang.&quot;, &quot;&quot;);
845 //                if (n.startsWith(&quot;invoke.&quot;)) {
846 //                    n = n.replace(&quot;invoke.&quot;, &quot;&quot;);
847 //                }
848 //            }
849 //            return n.replace(&#39;$&#39;, &#39;.&#39;);
850 //        }
851 //
852 //        static String getSignature(MethodType m) {
853 //            StringBuilder sb = new StringBuilder(m.parameterCount() + 1);
854 //
855 //            for (int i = 0; i &lt; m.parameterCount(); i++) {
856 //                Class&lt;?&gt; pt = m.parameterType(i);
857 //                sb.append(getCharType(pt));
858 //            }
859 //
860 //            sb.append(&#39;_&#39;).append(getCharType(m.returnType()));
861 //
862 //            return sb.toString();
863 //        }
864 //
865 //        static char getCharType(Class&lt;?&gt; pt) {
866 //            if (pt == void.class) {
867 //                return &#39;V&#39;;
868 //            }
869 //            else if (!pt.isPrimitive()) {
870 //                return &#39;L&#39;;
871 //            }
872 //            else if (pt == boolean.class) {
873 //                return &#39;Z&#39;;
874 //            }
875 //            else if (pt == int.class) {
876 //                return &#39;I&#39;;
877 //            }
878 //            else if (pt == long.class) {
879 //                return &#39;J&#39;;
880 //            }
881 //            else if (pt == float.class) {
882 //                return &#39;F&#39;;
883 //            }
884 //            else if (pt == double.class) {
885 //                return &#39;D&#39;;
886 //            }
887 //            else {
888 //                throw new IllegalStateException(pt.getName());
889 //            }
890 //        }
891 //    }
892 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
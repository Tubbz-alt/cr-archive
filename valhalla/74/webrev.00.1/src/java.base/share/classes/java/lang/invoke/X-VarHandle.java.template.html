<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang.invoke;
  26 
  27 import jdk.internal.util.Preconditions;
  28 import jdk.internal.vm.annotation.ForceInline;
  29 
  30 import java.lang.invoke.VarHandle.VarHandleDesc;
  31 import java.util.Objects;
  32 import java.util.Optional;
  33 
  34 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  35 
  36 #warn
  37 
  38 final class VarHandle$Type$s {
  39 
  40     static class FieldInstanceReadOnly extends VarHandle {
  41         final long fieldOffset;
  42         final Class&lt;?&gt; receiverType;
  43 #if[Object]
  44         final Class&lt;?&gt; fieldType;
  45 #end[Object]
  46 
  47         FieldInstanceReadOnly(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
  48             this(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadOnly.FORM);
  49         }
  50 
  51         protected FieldInstanceReadOnly(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType},
  52                                         VarForm form) {
  53             super(form);
  54             this.fieldOffset = fieldOffset;
  55             this.receiverType = receiverType;
  56 #if[Object]
  57             this.fieldType = fieldType;
  58 #end[Object]
  59         }
  60 
  61         @Override
  62         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  63             return accessMode.at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});
  64         }
  65 
  66         @Override
  67         public Optional&lt;VarHandleDesc&gt; describeConstable() {
  68             var receiverTypeRef = receiverType.describeConstable();
  69             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
  70             if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())
  71                 return Optional.empty();
  72 
  73             // Reflect on this VarHandle to extract the field name
  74             String name = VarHandles.getFieldFromReceiverAndOffset(
  75                 receiverType, fieldOffset, {#if[Object]?fieldType:$type$.class}).getName();
  76             return Optional.of(VarHandleDesc.ofField(receiverTypeRef.get(), name, fieldTypeRef.get()));
  77         }
  78 
  79         @ForceInline
  80         static $type$ get(VarHandle ob, Object holder) {
  81             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;
  82             return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
  83                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  84         }
  85 
  86         @ForceInline
  87         static $type$ getVolatile(VarHandle ob, Object holder) {
  88             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;
  89             return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
  90                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  91         }
  92 
  93         @ForceInline
  94         static $type$ getOpaque(VarHandle ob, Object holder) {
  95             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;
  96             return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
  97                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  98         }
  99 
 100         @ForceInline
 101         static $type$ getAcquire(VarHandle ob, Object holder) {
 102             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;
 103             return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 104                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 105         }
 106 
 107         static final VarForm FORM = new VarForm(FieldInstanceReadOnly.class, Object.class, $type$.class);
 108     }
 109 
 110     static final class FieldInstanceReadWrite extends FieldInstanceReadOnly {
 111         FieldInstanceReadWrite(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 112             super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);
 113         }
 114 
 115 #if[Object]
 116         @ForceInline
 117         static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {
 118             if (handle.fieldType.isInlineClass())
 119                 Objects.requireNonNull(value);
 120             return handle.fieldType.cast(value);
 121         }
 122 #end[Object]
 123 
 124         @ForceInline
 125         static void set(VarHandle ob, Object holder, $type$ value) {
 126             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 127             UNSAFE.put$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 128                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 129                              {#if[Object]?checkCast(handle, value):value});
 130         }
 131 
 132         @ForceInline
 133         static void setVolatile(VarHandle ob, Object holder, $type$ value) {
 134             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 135             UNSAFE.put$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
 136                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 137                                      {#if[Object]?checkCast(handle, value):value});
 138         }
 139 
 140         @ForceInline
 141         static void setOpaque(VarHandle ob, Object holder, $type$ value) {
 142             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 143             UNSAFE.put$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
 144                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 145                                    {#if[Object]?checkCast(handle, value):value});
 146         }
 147 
 148         @ForceInline
 149         static void setRelease(VarHandle ob, Object holder, $type$ value) {
 150             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 151             UNSAFE.put$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 152                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 153                                     {#if[Object]?checkCast(handle, value):value});
 154         }
 155 #if[CAS]
 156 
 157         @ForceInline
 158         static boolean compareAndSet(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 159             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 160             return UNSAFE.compareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 161                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 162                                                {#if[Object]?checkCast(handle, expected):expected},
 163                                                {#if[Object]?checkCast(handle, value):value});
 164         }
 165 
 166         @ForceInline
 167         static $type$ compareAndExchange(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 168             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 169             return UNSAFE.compareAndExchange$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 170                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 171                                                {#if[Object]?checkCast(handle, expected):expected},
 172                                                {#if[Object]?checkCast(handle, value):value});
 173         }
 174 
 175         @ForceInline
 176         static $type$ compareAndExchangeAcquire(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 177             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 178             return UNSAFE.compareAndExchange$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 179                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 180                                                {#if[Object]?checkCast(handle, expected):expected},
 181                                                {#if[Object]?checkCast(handle, value):value});
 182         }
 183 
 184         @ForceInline
 185         static $type$ compareAndExchangeRelease(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 186             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 187             return UNSAFE.compareAndExchange$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 188                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 189                                                {#if[Object]?checkCast(handle, expected):expected},
 190                                                {#if[Object]?checkCast(handle, value):value});
 191         }
 192 
 193         @ForceInline
 194         static boolean weakCompareAndSetPlain(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 195             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 196             return UNSAFE.weakCompareAndSet$Type$Plain(Objects.requireNonNull(handle.receiverType.cast(holder)),
 197                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 198                                                {#if[Object]?checkCast(handle, expected):expected},
 199                                                {#if[Object]?checkCast(handle, value):value});
 200         }
 201 
 202         @ForceInline
 203         static boolean weakCompareAndSet(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 204             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 205             return UNSAFE.weakCompareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 206                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 207                                                {#if[Object]?checkCast(handle, expected):expected},
 208                                                {#if[Object]?checkCast(handle, value):value});
 209         }
 210 
 211         @ForceInline
 212         static boolean weakCompareAndSetAcquire(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 213             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 214             return UNSAFE.weakCompareAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 215                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 216                                                {#if[Object]?checkCast(handle, expected):expected},
 217                                                {#if[Object]?checkCast(handle, value):value});
 218         }
 219 
 220         @ForceInline
 221         static boolean weakCompareAndSetRelease(VarHandle ob, Object holder, $type$ expected, $type$ value) {
 222             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 223             return UNSAFE.weakCompareAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 224                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 225                                                {#if[Object]?checkCast(handle, expected):expected},
 226                                                {#if[Object]?checkCast(handle, value):value});
 227         }
 228 
 229         @ForceInline
 230         static $type$ getAndSet(VarHandle ob, Object holder, $type$ value) {
 231             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 232             return UNSAFE.getAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 233                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 234                                           {#if[Object]?checkCast(handle, value):value});
 235         }
 236 
 237         @ForceInline
 238         static $type$ getAndSetAcquire(VarHandle ob, Object holder, $type$ value) {
 239             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 240             return UNSAFE.getAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 241                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 242                                           {#if[Object]?checkCast(handle, value):value});
 243         }
 244 
 245         @ForceInline
 246         static $type$ getAndSetRelease(VarHandle ob, Object holder, $type$ value) {
 247             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 248             return UNSAFE.getAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 249                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 250                                           {#if[Object]?checkCast(handle, value):value});
 251         }
 252 #end[CAS]
 253 #if[AtomicAdd]
 254 
 255         @ForceInline
 256         static $type$ getAndAdd(VarHandle ob, Object holder, $type$ value) {
 257             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 258             return UNSAFE.getAndAdd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 259                                        handle.fieldOffset,
 260                                        value);
 261         }
 262 
 263         @ForceInline
 264         static $type$ getAndAddAcquire(VarHandle ob, Object holder, $type$ value) {
 265             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 266             return UNSAFE.getAndAdd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 267                                        handle.fieldOffset,
 268                                        value);
 269         }
 270 
 271         @ForceInline
 272         static $type$ getAndAddRelease(VarHandle ob, Object holder, $type$ value) {
 273             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 274             return UNSAFE.getAndAdd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 275                                        handle.fieldOffset,
 276                                        value);
 277         }
 278 
 279 #end[AtomicAdd]
 280 #if[Bitwise]
 281 
 282         @ForceInline
 283         static $type$ getAndBitwiseOr(VarHandle ob, Object holder, $type$ value) {
 284             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 285             return UNSAFE.getAndBitwiseOr$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 286                                        handle.fieldOffset,
 287                                        value);
 288         }
 289 
 290         @ForceInline
 291         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object holder, $type$ value) {
 292             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 293             return UNSAFE.getAndBitwiseOr$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 294                                        handle.fieldOffset,
 295                                        value);
 296         }
 297 
 298         @ForceInline
 299         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object holder, $type$ value) {
 300             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 301             return UNSAFE.getAndBitwiseOr$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 302                                        handle.fieldOffset,
 303                                        value);
 304         }
 305 
 306         @ForceInline
 307         static $type$ getAndBitwiseAnd(VarHandle ob, Object holder, $type$ value) {
 308             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 309             return UNSAFE.getAndBitwiseAnd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 310                                        handle.fieldOffset,
 311                                        value);
 312         }
 313 
 314         @ForceInline
 315         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object holder, $type$ value) {
 316             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 317             return UNSAFE.getAndBitwiseAnd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 318                                        handle.fieldOffset,
 319                                        value);
 320         }
 321 
 322         @ForceInline
 323         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object holder, $type$ value) {
 324             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 325             return UNSAFE.getAndBitwiseAnd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 326                                        handle.fieldOffset,
 327                                        value);
 328         }
 329 
 330         @ForceInline
 331         static $type$ getAndBitwiseXor(VarHandle ob, Object holder, $type$ value) {
 332             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 333             return UNSAFE.getAndBitwiseXor$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 334                                        handle.fieldOffset,
 335                                        value);
 336         }
 337 
 338         @ForceInline
 339         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object holder, $type$ value) {
 340             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 341             return UNSAFE.getAndBitwiseXor$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 342                                        handle.fieldOffset,
 343                                        value);
 344         }
 345 
 346         @ForceInline
 347         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object holder, $type$ value) {
 348             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;
 349             return UNSAFE.getAndBitwiseXor$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 350                                        handle.fieldOffset,
 351                                        value);
 352         }
 353 #end[Bitwise]
 354 
 355         static final VarForm FORM = new VarForm(FieldInstanceReadWrite.class, Object.class, $type$.class);
 356     }
 357 
 358 
 359     static class FieldStaticReadOnly extends VarHandle {
 360         final Object base;
 361         final long fieldOffset;
 362 #if[Object]
 363         final Class&lt;?&gt; fieldType;
 364 #end[Object]
 365 
 366         FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 367             this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);
 368         }
 369 
 370         protected FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType},
 371                                       VarForm form) {
 372             super(form);
 373             this.base = base;
 374             this.fieldOffset = fieldOffset;
 375 #if[Object]
 376             this.fieldType = fieldType;
 377 #end[Object]
 378         }
 379 
 380         @Override
 381         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 382             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
 383             if (!fieldTypeRef.isPresent())
 384                 return Optional.empty();
 385 
 386             // Reflect on this VarHandle to extract the field name
 387             var staticField = VarHandles.getStaticFieldFromBaseAndOffset(
 388                 base, fieldOffset, {#if[Object]?fieldType:$type$.class});
 389             var receiverTypeRef = staticField.getDeclaringClass().describeConstable();
 390             if (!receiverTypeRef.isPresent())
 391                 return Optional.empty();
 392             return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));
 393         }
 394 
 395         @Override
 396         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 397             return accessMode.at.accessModeType(null, {#if[Object]?fieldType:$type$.class});
 398         }
 399 
 400         @ForceInline
 401         static $type$ get(VarHandle ob) {
 402             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;
 403             return UNSAFE.get$Type$(handle.base,
 404                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 405         }
 406 
 407         @ForceInline
 408         static $type$ getVolatile(VarHandle ob) {
 409             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;
 410             return UNSAFE.get$Type$Volatile(handle.base,
 411                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 412         }
 413 
 414         @ForceInline
 415         static $type$ getOpaque(VarHandle ob) {
 416             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;
 417             return UNSAFE.get$Type$Opaque(handle.base,
 418                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 419         }
 420 
 421         @ForceInline
 422         static $type$ getAcquire(VarHandle ob) {
 423             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;
 424             return UNSAFE.get$Type$Acquire(handle.base,
 425                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 426         }
 427 
 428         static final VarForm FORM = new VarForm(FieldStaticReadOnly.class, null, $type$.class);
 429     }
 430 
 431     static final class FieldStaticReadWrite extends FieldStaticReadOnly {
 432         FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 433             super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);
 434         }
 435 
 436 #if[Object]
 437         static Object checkCast(FieldStaticReadWrite handle, $type$ value) {
 438             if (handle.fieldType.isInlineClass())
 439                 Objects.requireNonNull(value);
 440             return handle.fieldType.cast(value);
 441         }
 442 #end[Object]
 443 
 444         @ForceInline
 445         static void set(VarHandle ob, $type$ value) {
 446             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 447             UNSAFE.put$Type$(handle.base,
 448                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 449                              {#if[Object]?checkCast(handle, value):value});
 450         }
 451 
 452         @ForceInline
 453         static void setVolatile(VarHandle ob, $type$ value) {
 454             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 455             UNSAFE.put$Type$Volatile(handle.base,
 456                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 457                                      {#if[Object]?checkCast(handle, value):value});
 458         }
 459 
 460         @ForceInline
 461         static void setOpaque(VarHandle ob, $type$ value) {
 462             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 463             UNSAFE.put$Type$Opaque(handle.base,
 464                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 465                                    {#if[Object]?checkCast(handle, value):value});
 466         }
 467 
 468         @ForceInline
 469         static void setRelease(VarHandle ob, $type$ value) {
 470             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 471             UNSAFE.put$Type$Release(handle.base,
 472                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 473                                     {#if[Object]?checkCast(handle, value):value});
 474         }
 475 #if[CAS]
 476 
 477         @ForceInline
 478         static boolean compareAndSet(VarHandle ob, $type$ expected, $type$ value) {
 479             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 480             return UNSAFE.compareAndSet$Type$(handle.base,
 481                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 482                                                {#if[Object]?checkCast(handle, expected):expected},
 483                                                {#if[Object]?checkCast(handle, value):value});
 484         }
 485 
 486 
 487         @ForceInline
 488         static $type$ compareAndExchange(VarHandle ob, $type$ expected, $type$ value) {
 489             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 490             return UNSAFE.compareAndExchange$Type$(handle.base,
 491                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 492                                                {#if[Object]?checkCast(handle, expected):expected},
 493                                                {#if[Object]?checkCast(handle, value):value});
 494         }
 495 
 496         @ForceInline
 497         static $type$ compareAndExchangeAcquire(VarHandle ob, $type$ expected, $type$ value) {
 498             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 499             return UNSAFE.compareAndExchange$Type$Acquire(handle.base,
 500                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 501                                                {#if[Object]?checkCast(handle, expected):expected},
 502                                                {#if[Object]?checkCast(handle, value):value});
 503         }
 504 
 505         @ForceInline
 506         static $type$ compareAndExchangeRelease(VarHandle ob, $type$ expected, $type$ value) {
 507             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 508             return UNSAFE.compareAndExchange$Type$Release(handle.base,
 509                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 510                                                {#if[Object]?checkCast(handle, expected):expected},
 511                                                {#if[Object]?checkCast(handle, value):value});
 512         }
 513 
 514         @ForceInline
 515         static boolean weakCompareAndSetPlain(VarHandle ob, $type$ expected, $type$ value) {
 516             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 517             return UNSAFE.weakCompareAndSet$Type$Plain(handle.base,
 518                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 519                                                {#if[Object]?checkCast(handle, expected):expected},
 520                                                {#if[Object]?checkCast(handle, value):value});
 521         }
 522 
 523         @ForceInline
 524         static boolean weakCompareAndSet(VarHandle ob, $type$ expected, $type$ value) {
 525             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 526             return UNSAFE.weakCompareAndSet$Type$(handle.base,
 527                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 528                                                {#if[Object]?checkCast(handle, expected):expected},
 529                                                {#if[Object]?checkCast(handle, value):value});
 530         }
 531 
 532         @ForceInline
 533         static boolean weakCompareAndSetAcquire(VarHandle ob, $type$ expected, $type$ value) {
 534             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 535             return UNSAFE.weakCompareAndSet$Type$Acquire(handle.base,
 536                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 537                                                {#if[Object]?checkCast(handle, expected):expected},
 538                                                {#if[Object]?checkCast(handle, value):value});
 539         }
 540 
 541         @ForceInline
 542         static boolean weakCompareAndSetRelease(VarHandle ob, $type$ expected, $type$ value) {
 543             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 544             return UNSAFE.weakCompareAndSet$Type$Release(handle.base,
 545                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 546                                                {#if[Object]?checkCast(handle, expected):expected},
 547                                                {#if[Object]?checkCast(handle, value):value});
 548         }
 549 
 550         @ForceInline
 551         static $type$ getAndSet(VarHandle ob, $type$ value) {
 552             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 553             return UNSAFE.getAndSet$Type$(handle.base,
 554                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 555                                           {#if[Object]?checkCast(handle, value):value});
 556         }
 557 
 558         @ForceInline
 559         static $type$ getAndSetAcquire(VarHandle ob, $type$ value) {
 560             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 561             return UNSAFE.getAndSet$Type$Acquire(handle.base,
 562                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 563                                           {#if[Object]?checkCast(handle, value):value});
 564         }
 565 
 566         @ForceInline
 567         static $type$ getAndSetRelease(VarHandle ob, $type$ value) {
 568             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 569             return UNSAFE.getAndSet$Type$Release(handle.base,
 570                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 571                                           {#if[Object]?checkCast(handle, value):value});
 572         }
 573 #end[CAS]
 574 #if[AtomicAdd]
 575 
 576         @ForceInline
 577         static $type$ getAndAdd(VarHandle ob, $type$ value) {
 578             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 579             return UNSAFE.getAndAdd$Type$(handle.base,
 580                                        handle.fieldOffset,
 581                                        value);
 582         }
 583 
 584         @ForceInline
 585         static $type$ getAndAddAcquire(VarHandle ob, $type$ value) {
 586             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 587             return UNSAFE.getAndAdd$Type$Acquire(handle.base,
 588                                        handle.fieldOffset,
 589                                        value);
 590         }
 591 
 592         @ForceInline
 593         static $type$ getAndAddRelease(VarHandle ob, $type$ value) {
 594             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 595             return UNSAFE.getAndAdd$Type$Release(handle.base,
 596                                        handle.fieldOffset,
 597                                        value);
 598         }
 599 #end[AtomicAdd]
 600 #if[Bitwise]
 601 
 602         @ForceInline
 603         static $type$ getAndBitwiseOr(VarHandle ob, $type$ value) {
 604             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 605             return UNSAFE.getAndBitwiseOr$Type$(handle.base,
 606                                        handle.fieldOffset,
 607                                        value);
 608         }
 609 
 610         @ForceInline
 611         static $type$ getAndBitwiseOrRelease(VarHandle ob, $type$ value) {
 612             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 613             return UNSAFE.getAndBitwiseOr$Type$Release(handle.base,
 614                                        handle.fieldOffset,
 615                                        value);
 616         }
 617 
 618         @ForceInline
 619         static $type$ getAndBitwiseOrAcquire(VarHandle ob, $type$ value) {
 620             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 621             return UNSAFE.getAndBitwiseOr$Type$Acquire(handle.base,
 622                                        handle.fieldOffset,
 623                                        value);
 624         }
 625 
 626         @ForceInline
 627         static $type$ getAndBitwiseAnd(VarHandle ob, $type$ value) {
 628             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 629             return UNSAFE.getAndBitwiseAnd$Type$(handle.base,
 630                                        handle.fieldOffset,
 631                                        value);
 632         }
 633 
 634         @ForceInline
 635         static $type$ getAndBitwiseAndRelease(VarHandle ob, $type$ value) {
 636             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 637             return UNSAFE.getAndBitwiseAnd$Type$Release(handle.base,
 638                                        handle.fieldOffset,
 639                                        value);
 640         }
 641 
 642         @ForceInline
 643         static $type$ getAndBitwiseAndAcquire(VarHandle ob, $type$ value) {
 644             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 645             return UNSAFE.getAndBitwiseAnd$Type$Acquire(handle.base,
 646                                        handle.fieldOffset,
 647                                        value);
 648         }
 649 
 650         @ForceInline
 651         static $type$ getAndBitwiseXor(VarHandle ob, $type$ value) {
 652             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 653             return UNSAFE.getAndBitwiseXor$Type$(handle.base,
 654                                        handle.fieldOffset,
 655                                        value);
 656         }
 657 
 658         @ForceInline
 659         static $type$ getAndBitwiseXorRelease(VarHandle ob, $type$ value) {
 660             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 661             return UNSAFE.getAndBitwiseXor$Type$Release(handle.base,
 662                                        handle.fieldOffset,
 663                                        value);
 664         }
 665 
 666         @ForceInline
 667         static $type$ getAndBitwiseXorAcquire(VarHandle ob, $type$ value) {
 668             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;
 669             return UNSAFE.getAndBitwiseXor$Type$Acquire(handle.base,
 670                                        handle.fieldOffset,
 671                                        value);
 672         }
 673 #end[Bitwise]
 674 
 675         static final VarForm FORM = new VarForm(FieldStaticReadWrite.class, null, $type$.class);
 676     }
 677 
 678 #if[Reference]
 679     static VarHandle makeVarHandleValuesArray(Class&lt;?&gt; arrayClass) {
 680         Class&lt;?&gt; componentType = arrayClass.getComponentType();
 681         assert componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass);
 682         // should cache these VarHandle for performance
 683         return VarHandles.makeArrayElementHandle(arrayClass);
 684     }
 685 #end[Reference]
 686 
 687     static final class Array extends VarHandle {
 688         final int abase;
 689         final int ashift;
 690 #if[Object]
 691         final Class&lt;{#if[Object]??:$type$[]}&gt; arrayType;
 692         final Class&lt;?&gt; componentType;
 693 #end[Object]
 694 
 695         Array(int abase, int ashift{#if[Object]?, Class&lt;?&gt; arrayType}) {
 696             super(Array.FORM);
 697             this.abase = abase;
 698             this.ashift = ashift;
 699 #if[Object]
 700             this.arrayType = {#if[Object]?arrayType:$type$[].class};
 701             this.componentType = arrayType.getComponentType();
 702 #end[Object]
 703         }
 704 
 705         @Override
 706         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 707             var arrayTypeRef = {#if[Object]?arrayType:$type$[].class}.describeConstable();
 708             if (!arrayTypeRef.isPresent())
 709                 return Optional.empty();
 710 
 711             return Optional.of(VarHandleDesc.ofArray(arrayTypeRef.get()));
 712         }
 713 
 714         @Override
 715         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 716             return accessMode.at.accessModeType({#if[Object]?arrayType:$type$[].class}, {#if[Object]?arrayType.getComponentType():$type$.class}, int.class);
 717         }
 718 
 719 #if[Object]
 720         @ForceInline
 721         static Object runtimeTypeCheck(Array handle, Object[] oarray, Object value) {
 722             if (handle.componentType.isInlineClass())
 723                  Objects.requireNonNull(value);
 724 
 725             if (handle.arrayType == oarray.getClass()) {
 726                 // Fast path: static array type same as argument array type
 727                 return handle.componentType.cast(value);
 728             } else {
 729                 // Slow path: check value against argument array component type
 730                 return reflectiveTypeCheck(oarray, value);
 731             }
 732         }
 733 
 734         @ForceInline
 735         static Object reflectiveTypeCheck(Object[] oarray, Object value) {
 736             try {
 737                 return oarray.getClass().getComponentType().cast(value);
 738             } catch (ClassCastException e) {
 739                 throw new ArrayStoreException();
 740             }
 741         }
 742 #end[Object]
 743 
 744         @ForceInline
 745         static $type$ get(VarHandle ob, Object oarray, int index) {
 746             Array handle = (Array)ob;
 747 #if[Object]
 748             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 749 #else[Object]
 750             $type$[] array = ($type$[]) oarray;
 751 #end[Object]
 752             return array[index];
 753         }
 754 
 755         @ForceInline
 756         static void set(VarHandle ob, Object oarray, int index, $type$ value) {
 757             Array handle = (Array)ob;
 758 #if[Object]
 759             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 760 #else[Object]
 761             $type$[] array = ($type$[]) oarray;
 762 #end[Object]
 763 #if[Reference]
 764             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 765                 // for flattened array, delegate to VarHandle of the inline type array
 766                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 767                 vh.set(oarray, index, reflectiveTypeCheck(array, value));
 768                 return;
 769             }
 770 #end[Reference]
 771             array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};
 772         }
 773 
 774         @ForceInline
 775         static $type$ getVolatile(VarHandle ob, Object oarray, int index) {
 776             Array handle = (Array)ob;
 777 #if[Object]
 778             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 779 #else[Object]
 780             $type$[] array = ($type$[]) oarray;
 781 #end[Object]
 782 #if[Reference]
 783             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 784                 // for flattened array, delegate to VarHandle of the inline type array
 785                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 786                 return vh.getVolatile(oarray, index);
 787             }
 788 #end[Reference]
 789             return UNSAFE.get$Type$Volatile(array,
 790                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 791         }
 792 
 793         @ForceInline
 794         static void setVolatile(VarHandle ob, Object oarray, int index, $type$ value) {
 795             Array handle = (Array)ob;
 796 #if[Object]
 797             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 798 #else[Object]
 799             $type$[] array = ($type$[]) oarray;
 800 #end[Object]
 801 #if[Reference]
 802             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 803                 // for flattened array, delegate to VarHandle of the inline type array
 804                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 805                 vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));
 806                 return;
 807             }
 808 #end[Reference]
 809             UNSAFE.put$Type$Volatile(array,
 810                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 811                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 812         }
 813 
 814         @ForceInline
 815         static $type$ getOpaque(VarHandle ob, Object oarray, int index) {
 816             Array handle = (Array)ob;
 817 #if[Object]
 818             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 819 #else[Object]
 820             $type$[] array = ($type$[]) oarray;
 821 #end[Object]
 822 #if[Reference]
 823             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 824                 // for flattened array, delegate to VarHandle of the inline type array
 825                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 826                 return vh.getOpaque(oarray, index);
 827             }
 828 #end[Reference]
 829             return UNSAFE.get$Type$Opaque(array,
 830                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 831         }
 832 
 833         @ForceInline
 834         static void setOpaque(VarHandle ob, Object oarray, int index, $type$ value) {
 835             Array handle = (Array)ob;
 836 #if[Object]
 837             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 838 #else[Object]
 839             $type$[] array = ($type$[]) oarray;
 840 #end[Object]
 841 #if[Reference]
 842             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 843                 // for flattened array, delegate to VarHandle of the inline type array
 844                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 845                 vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));
 846                 return;
 847             }
 848 #end[Reference]
 849             UNSAFE.put$Type$Opaque(array,
 850                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 851                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 852         }
 853 
 854         @ForceInline
 855         static $type$ getAcquire(VarHandle ob, Object oarray, int index) {
 856             Array handle = (Array)ob;
 857 #if[Object]
 858             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 859 #else[Object]
 860             $type$[] array = ($type$[]) oarray;
 861 #end[Object]
 862 #if[Reference]
 863             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 864                 // for flattened array, delegate to VarHandle of the inline type array
 865                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 866                 return vh.getAcquire(oarray, index);
 867             }
 868 #end[Reference]
 869             return UNSAFE.get$Type$Acquire(array,
 870                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 871         }
 872 
 873         @ForceInline
 874         static void setRelease(VarHandle ob, Object oarray, int index, $type$ value) {
 875             Array handle = (Array)ob;
 876 #if[Object]
 877             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 878 #else[Object]
 879             $type$[] array = ($type$[]) oarray;
 880 #end[Object]
 881 #if[Reference]
 882             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 883                 // for flattened array, delegate to VarHandle of the inline type array
 884                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 885                 vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));
 886                 return;
 887             }
 888 #end[Reference]
 889             UNSAFE.put$Type$Release(array,
 890                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 891                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 892         }
 893 #if[CAS]
 894 
 895         @ForceInline
 896         static boolean compareAndSet(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
 897             Array handle = (Array)ob;
 898 #if[Object]
 899             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 900 #else[Object]
 901             $type$[] array = ($type$[]) oarray;
 902 #end[Object]
 903 #if[Reference]
 904             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 905                 // for flattened array, delegate to VarHandle of the inline type array
 906                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 907                 return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 908             }
 909 #end[Reference]
 910             return UNSAFE.compareAndSet$Type$(array,
 911                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 912                     {#if[Object]?handle.componentType.cast(expected):expected},
 913                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 914         }
 915 
 916         @ForceInline
 917         static $type$ compareAndExchange(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
 918             Array handle = (Array)ob;
 919 #if[Object]
 920             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 921 #else[Object]
 922             $type$[] array = ($type$[]) oarray;
 923 #end[Object]
 924 #if[Reference]
 925             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 926                 // for flattened array, delegate to VarHandle of the inline type array
 927                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 928                 return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));
 929             }
 930 #end[Reference]
 931             return UNSAFE.compareAndExchange$Type$(array,
 932                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 933                     {#if[Object]?handle.componentType.cast(expected):expected},
 934                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 935         }
 936 
 937         @ForceInline
 938         static $type$ compareAndExchangeAcquire(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
 939             Array handle = (Array)ob;
 940 #if[Object]
 941             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 942 #else[Object]
 943             $type$[] array = ($type$[]) oarray;
 944 #end[Object]
 945 #if[Reference]
 946             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 947                 // for flattened array, delegate to VarHandle of the inline type array
 948                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 949                 return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 950             }
 951 #end[Reference]
 952             return UNSAFE.compareAndExchange$Type$Acquire(array,
 953                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 954                     {#if[Object]?handle.componentType.cast(expected):expected},
 955                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 956         }
 957 
 958         @ForceInline
 959         static $type$ compareAndExchangeRelease(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
 960             Array handle = (Array)ob;
 961 #if[Object]
 962             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 963 #else[Object]
 964             $type$[] array = ($type$[]) oarray;
 965 #end[Object]
 966 #if[Reference]
 967             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 968                 // for flattened array, delegate to VarHandle of the inline type array
 969                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 970                 return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 971             }
 972 #end[Reference]
 973             return UNSAFE.compareAndExchange$Type$Release(array,
 974                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 975                     {#if[Object]?handle.componentType.cast(expected):expected},
 976                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 977         }
 978 
 979         @ForceInline
 980         static boolean weakCompareAndSetPlain(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
 981             Array handle = (Array)ob;
 982 #if[Object]
 983             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 984 #else[Object]
 985             $type$[] array = ($type$[]) oarray;
 986 #end[Object]
 987 #if[Reference]
 988             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 989                 // for flattened array, delegate to VarHandle of the inline type array
 990                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 991                 return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));
 992             }
 993 #end[Reference]
 994             return UNSAFE.weakCompareAndSet$Type$Plain(array,
 995                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 996                     {#if[Object]?handle.componentType.cast(expected):expected},
 997                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 998         }
 999 
1000         @ForceInline
1001         static boolean weakCompareAndSet(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
1002             Array handle = (Array)ob;
1003 #if[Object]
1004             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1005 #else[Object]
1006             $type$[] array = ($type$[]) oarray;
1007 #end[Object]
1008 #if[Reference]
1009             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1010                 // for flattened array, delegate to VarHandle of the inline type array
1011                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1012                 return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
1013             }
1014 #end[Reference]
1015             return UNSAFE.weakCompareAndSet$Type$(array,
1016                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1017                     {#if[Object]?handle.componentType.cast(expected):expected},
1018                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1019         }
1020 
1021         @ForceInline
1022         static boolean weakCompareAndSetAcquire(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
1023             Array handle = (Array)ob;
1024 #if[Object]
1025             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1026 #else[Object]
1027             $type$[] array = ($type$[]) oarray;
1028 #end[Object]
1029 #if[Reference]
1030             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1031                 // for flattened array, delegate to VarHandle of the inline type array
1032                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1033                 return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
1034             }
1035 #end[Reference]
1036             return UNSAFE.weakCompareAndSet$Type$Acquire(array,
1037                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1038                     {#if[Object]?handle.componentType.cast(expected):expected},
1039                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1040         }
1041 
1042         @ForceInline
1043         static boolean weakCompareAndSetRelease(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {
1044             Array handle = (Array)ob;
1045 #if[Object]
1046             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1047 #else[Object]
1048             $type$[] array = ($type$[]) oarray;
1049 #end[Object]
1050 #if[Reference]
1051             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1052                 // for flattened array, delegate to VarHandle of the inline type array
1053                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1054                 return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
1055             }
1056 #end[Reference]
1057             return UNSAFE.weakCompareAndSet$Type$Release(array,
1058                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1059                     {#if[Object]?handle.componentType.cast(expected):expected},
1060                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1061         }
1062 
1063         @ForceInline
1064         static $type$ getAndSet(VarHandle ob, Object oarray, int index, $type$ value) {
1065             Array handle = (Array)ob;
1066 #if[Object]
1067             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1068 #else[Object]
1069             $type$[] array = ($type$[]) oarray;
1070 #end[Object]
1071 #if[Reference]
1072             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1073                 // for flattened array, delegate to VarHandle of the inline type array
1074                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1075                 return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));
1076             }
1077 #end[Reference]
1078             return UNSAFE.getAndSet$Type$(array,
1079                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1080                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1081         }
1082 
1083         @ForceInline
1084         static $type$ getAndSetAcquire(VarHandle ob, Object oarray, int index, $type$ value) {
1085             Array handle = (Array)ob;
1086 #if[Object]
1087             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1088 #else[Object]
1089             $type$[] array = ($type$[]) oarray;
1090 #end[Object]
1091 #if[Reference]
1092             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1093                 // for flattened array, delegate to VarHandle of the inline type array
1094                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1095                 return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));
1096             }
1097 #end[Reference]
1098             return UNSAFE.getAndSet$Type$Acquire(array,
1099                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1100                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1101         }
1102 
1103         @ForceInline
1104         static $type$ getAndSetRelease(VarHandle ob, Object oarray, int index, $type$ value) {
1105             Array handle = (Array)ob;
1106 #if[Object]
1107             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1108 #else[Object]
1109             $type$[] array = ($type$[]) oarray;
1110 #end[Object]
1111 #if[Reference]
1112             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1113                 // for flattened array, delegate to VarHandle of the inline type array
1114                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1115                 return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));
1116             }
1117 #end[Reference]
1118             return UNSAFE.getAndSet$Type$Release(array,
1119                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1120                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1121         }
1122 #end[CAS]
1123 #if[AtomicAdd]
1124 
1125         @ForceInline
1126         static $type$ getAndAdd(VarHandle ob, Object oarray, int index, $type$ value) {
1127             Array handle = (Array)ob;
1128             $type$[] array = ($type$[]) oarray;
1129             return UNSAFE.getAndAdd$Type$(array,
1130                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1131                     value);
1132         }
1133 
1134         @ForceInline
1135         static $type$ getAndAddAcquire(VarHandle ob, Object oarray, int index, $type$ value) {
1136             Array handle = (Array)ob;
1137             $type$[] array = ($type$[]) oarray;
1138             return UNSAFE.getAndAdd$Type$Acquire(array,
1139                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1140                     value);
1141         }
1142 
1143         @ForceInline
1144         static $type$ getAndAddRelease(VarHandle ob, Object oarray, int index, $type$ value) {
1145             Array handle = (Array)ob;
1146             $type$[] array = ($type$[]) oarray;
1147             return UNSAFE.getAndAdd$Type$Release(array,
1148                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1149                     value);
1150         }
1151 #end[AtomicAdd]
1152 #if[Bitwise]
1153 
1154         @ForceInline
1155         static $type$ getAndBitwiseOr(VarHandle ob, Object oarray, int index, $type$ value) {
1156             Array handle = (Array)ob;
1157             $type$[] array = ($type$[]) oarray;
1158             return UNSAFE.getAndBitwiseOr$Type$(array,
1159                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1160                                        value);
1161         }
1162 
1163         @ForceInline
1164         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object oarray, int index, $type$ value) {
1165             Array handle = (Array)ob;
1166             $type$[] array = ($type$[]) oarray;
1167             return UNSAFE.getAndBitwiseOr$Type$Release(array,
1168                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1169                                        value);
1170         }
1171 
1172         @ForceInline
1173         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object oarray, int index, $type$ value) {
1174             Array handle = (Array)ob;
1175             $type$[] array = ($type$[]) oarray;
1176             return UNSAFE.getAndBitwiseOr$Type$Acquire(array,
1177                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1178                                        value);
1179         }
1180 
1181         @ForceInline
1182         static $type$ getAndBitwiseAnd(VarHandle ob, Object oarray, int index, $type$ value) {
1183             Array handle = (Array)ob;
1184             $type$[] array = ($type$[]) oarray;
1185             return UNSAFE.getAndBitwiseAnd$Type$(array,
1186                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1187                                        value);
1188         }
1189 
1190         @ForceInline
1191         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object oarray, int index, $type$ value) {
1192             Array handle = (Array)ob;
1193             $type$[] array = ($type$[]) oarray;
1194             return UNSAFE.getAndBitwiseAnd$Type$Release(array,
1195                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1196                                        value);
1197         }
1198 
1199         @ForceInline
1200         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object oarray, int index, $type$ value) {
1201             Array handle = (Array)ob;
1202             $type$[] array = ($type$[]) oarray;
1203             return UNSAFE.getAndBitwiseAnd$Type$Acquire(array,
1204                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1205                                        value);
1206         }
1207 
1208         @ForceInline
1209         static $type$ getAndBitwiseXor(VarHandle ob, Object oarray, int index, $type$ value) {
1210             Array handle = (Array)ob;
1211             $type$[] array = ($type$[]) oarray;
1212             return UNSAFE.getAndBitwiseXor$Type$(array,
1213                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1214                                        value);
1215         }
1216 
1217         @ForceInline
1218         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object oarray, int index, $type$ value) {
1219             Array handle = (Array)ob;
1220             $type$[] array = ($type$[]) oarray;
1221             return UNSAFE.getAndBitwiseXor$Type$Release(array,
1222                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1223                                        value);
1224         }
1225 
1226         @ForceInline
1227         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object oarray, int index, $type$ value) {
1228             Array handle = (Array)ob;
1229             $type$[] array = ($type$[]) oarray;
1230             return UNSAFE.getAndBitwiseXor$Type$Acquire(array,
1231                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1232                                        value);
1233         }
1234 #end[Bitwise]
1235 
1236         static final VarForm FORM = new VarForm(Array.class, {#if[Object]?Object[].class:$type$[].class}, {#if[Object]?Object.class:$type$.class}, int.class);
1237     }
1238 }
    </pre>
  </body>
</html>
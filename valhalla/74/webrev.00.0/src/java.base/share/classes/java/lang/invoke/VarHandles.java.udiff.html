<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/VarHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,18 +25,26 @@</span>
  
  package java.lang.invoke;
  
  import sun.invoke.util.Wrapper;
  
<span class="udiff-line-added">+ import java.lang.reflect.Constructor;</span>
  import java.lang.reflect.Field;
<span class="udiff-line-added">+ import java.lang.reflect.Method;</span>
  import java.lang.reflect.Modifier;
  import java.nio.ByteOrder;
<span class="udiff-line-added">+ import java.util.ArrayList;</span>
<span class="udiff-line-added">+ import java.util.List;</span>
  import java.util.Map;
<span class="udiff-line-added">+ import java.util.Objects;</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
<span class="udiff-line-added">+ import java.util.stream.Stream;</span>
  
  import static java.lang.invoke.MethodHandleStatics.UNSAFE;
<span class="udiff-line-added">+ import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_IDENTITY_ADAPT;</span>
<span class="udiff-line-added">+ import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;</span>
  
  final class VarHandles {
  
      static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48,58 +56,58 @@</span>
      static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
          if (!f.isStatic()) {
              long foffset = MethodHandleNatives.objectFieldOffset(f);
              if (!type.isPrimitive()) {
                  if (f.isFlattened()) {
<span class="udiff-line-modified-removed">-                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                          ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)
<span class="udiff-line-modified-removed">-                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type);</span>
<span class="udiff-line-modified-added">+                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type));</span>
                  } else {
<span class="udiff-line-modified-removed">-                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
<span class="udiff-line-modified-removed">-                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));</span>
                  }
              }
              else if (type == boolean.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == byte.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == short.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == char.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == int.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == long.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == float.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else if (type == double.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset));</span>
              }
              else {
                  throw new UnsupportedOperationException();
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -115,58 +123,58 @@</span>
  
              Object base = MethodHandleNatives.staticFieldBase(f);
              long foffset = MethodHandleNatives.staticFieldOffset(f);
              if (!type.isPrimitive()) {
                  if (f.isFlattened()) {
<span class="udiff-line-modified-removed">-                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                              ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)
<span class="udiff-line-modified-removed">-                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type);</span>
<span class="udiff-line-modified-added">+                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type));</span>
                  } else {
                      return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
                              ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
                              : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);
                  }
              }
              else if (type == boolean.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == byte.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == short.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == char.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleChars.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleChars.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == int.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleInts.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleInts.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == long.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == float.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset));</span>
              }
              else if (type == double.class) {
<span class="udiff-line-modified-removed">-                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
<span class="udiff-line-modified-added">+                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
                         ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
<span class="udiff-line-modified-removed">-                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset);</span>
<span class="udiff-line-modified-added">+                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));</span>
              }
              else {
                  throw new UnsupportedOperationException();
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,37 +225,37 @@</span>
          if (!componentType.isPrimitive()) {
              // the redundant componentType.isValue() check is there to
              // minimize the performance impact to non-value array.
              // It should be removed when Unsafe::isFlattenedArray is intrinsified.
  
<span class="udiff-line-modified-removed">-             return componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)</span>
                  ? new VarHandleValues.Array(aoffset, ashift, arrayClass)
<span class="udiff-line-modified-removed">-                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass);</span>
<span class="udiff-line-modified-added">+                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass));</span>
          }
          else if (componentType == boolean.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleBooleans.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));</span>
          }
          else if (componentType == byte.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleBytes.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));</span>
          }
          else if (componentType == short.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleShorts.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));</span>
          }
          else if (componentType == char.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleChars.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));</span>
          }
          else if (componentType == int.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleInts.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));</span>
          }
          else if (componentType == long.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleLongs.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));</span>
          }
          else if (componentType == float.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleFloats.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));</span>
          }
          else if (componentType == double.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleDoubles.Array(aoffset, ashift);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));</span>
          }
          else {
              throw new UnsupportedOperationException();
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -258,26 +266,26 @@</span>
              throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
  
          Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
  
          if (viewComponentType == long.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsLongs.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsLongs.ArrayHandle(be));</span>
          }
          else if (viewComponentType == int.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsInts.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsInts.ArrayHandle(be));</span>
          }
          else if (viewComponentType == short.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsShorts.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsShorts.ArrayHandle(be));</span>
          }
          else if (viewComponentType == char.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsChars.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsChars.ArrayHandle(be));</span>
          }
          else if (viewComponentType == double.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsDoubles.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsDoubles.ArrayHandle(be));</span>
          }
          else if (viewComponentType == float.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsFloats.ArrayHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsFloats.ArrayHandle(be));</span>
          }
  
          throw new UnsupportedOperationException();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -287,26 +295,26 @@</span>
              throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
  
          Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
  
          if (viewComponentType == long.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsLongs.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsLongs.ByteBufferHandle(be));</span>
          }
          else if (viewComponentType == int.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsInts.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsInts.ByteBufferHandle(be));</span>
          }
          else if (viewComponentType == short.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsShorts.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsShorts.ByteBufferHandle(be));</span>
          }
          else if (viewComponentType == char.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsChars.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsChars.ByteBufferHandle(be));</span>
          }
          else if (viewComponentType == double.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsDoubles.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsDoubles.ByteBufferHandle(be));</span>
          }
          else if (viewComponentType == float.class) {
<span class="udiff-line-modified-removed">-             return new VarHandleByteArrayAsFloats.ByteBufferHandle(be);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt(new VarHandleByteArrayAsFloats.ByteBufferHandle(be));</span>
          }
  
          throw new UnsupportedOperationException();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -335,20 +343,261 @@</span>
          long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
          boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
  
          Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
          MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
<span class="udiff-line-modified-removed">-                 dims -&gt; new AddressVarHandleGenerator(carrier, dims)</span>
<span class="udiff-line-modified-added">+                 dims -&gt; new MemoryAccessVarHandleGenerator(carrier, dims)</span>
                              .generateHandleFactory());
  
          try {
<span class="udiff-line-modified-removed">-             return (VarHandle)fac.invoke(be, size, offset, alignmentMask, strides);</span>
<span class="udiff-line-modified-added">+             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));</span>
          } catch (Throwable ex) {
              throw new IllegalStateException(ex);
          }
      }
  
<span class="udiff-line-added">+     private static VarHandle maybeAdapt(VarHandle target) {</span>
<span class="udiff-line-added">+         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;</span>
<span class="udiff-line-added">+         target = filterValue(target,</span>
<span class="udiff-line-added">+                         MethodHandles.identity(target.varType()), MethodHandles.identity(target.varType()));</span>
<span class="udiff-line-added">+         MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {</span>
<span class="udiff-line-added">+             target = filterCoordinates(target, i, MethodHandles.identity(mtype.parameterType(i)));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return target;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(filterToTarget);</span>
<span class="udiff-line-added">+         Objects.nonNull(filterFromTarget);</span>
<span class="udiff-line-added">+         //check that from/to filters do not throw checked exceptions</span>
<span class="udiff-line-added">+         noCheckedExceptions(filterToTarget);</span>
<span class="udiff-line-added">+         noCheckedExceptions(filterFromTarget);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         //check that from/to filters have right signatures</span>
<span class="udiff-line-added">+         if (filterFromTarget.type().parameterCount() != 1) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="udiff-line-added">+         } else if (filterToTarget.type().parameterCount() != 1) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="udiff-line-added">+         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||</span>
<span class="udiff-line-added">+                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());</span>
<span class="udiff-line-added">+         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());</span>
<span class="udiff-line-added">+         } else if (target.varType() != filterToTarget.type().returnType()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt; {</span>
<span class="udiff-line-added">+                     int lastParameterPos = modeHandle.type().parameterCount() - 1;</span>
<span class="udiff-line-added">+                     return switch (mode.at) {</span>
<span class="udiff-line-added">+                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-added">+                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-added">+                         case GET_AND_UPDATE -&gt; {</span>
<span class="udiff-line-added">+                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-added">+                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         case COMPARE_AND_EXCHANGE -&gt; {</span>
<span class="udiff-line-added">+                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="udiff-line-added">+                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-added">+                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         case COMPARE_AND_SET -&gt; {</span>
<span class="udiff-line-added">+                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="udiff-line-added">+                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     };</span>
<span class="udiff-line-added">+                 });</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(filters);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-added">+         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-added">+         } else if (pos + filters.length &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(&quot;Too many filters&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (filters.length == 0) return target;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; filters.length ; i++) {</span>
<span class="udiff-line-added">+             noCheckedExceptions(filters[i]);</span>
<span class="udiff-line-added">+             MethodType filterType = filters[i].type();</span>
<span class="udiff-line-added">+             if (filterType.parameterCount() != 1) {</span>
<span class="udiff-line-added">+                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);</span>
<span class="udiff-line-added">+             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {</span>
<span class="udiff-line-added">+                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             newCoordinates.set(pos + i, filters[i].type().parameterType(0));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(values);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-added">+         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-added">+         } else if (pos + values.length &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw new IllegalArgumentException(&quot;Too many values&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (values.length == 0) return target;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; values.length ; i++) {</span>
<span class="udiff-line-added">+             Class&lt;?&gt; pt = newCoordinates.get(pos);</span>
<span class="udiff-line-added">+             if (pt.isPrimitive()) {</span>
<span class="udiff-line-added">+                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="udiff-line-added">+                 w.convert(values[i], pt);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 pt.cast(values[i]);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             newCoordinates.remove(pos);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(newCoordinates);</span>
<span class="udiff-line-added">+         Objects.nonNull(reorder);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-added">+         MethodHandles.permuteArgumentChecks(reorder,</span>
<span class="udiff-line-added">+                 MethodType.methodType(void.class, newCoordinates),</span>
<span class="udiff-line-added">+                 MethodType.methodType(void.class, targetCoordinates));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt;</span>
<span class="udiff-line-added">+                         MethodHandles.permuteArguments(modeHandle,</span>
<span class="udiff-line-added">+                                 methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),</span>
<span class="udiff-line-added">+                                 reorderArrayFor(mode.at, newCoordinates, reorder)));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static int numTrailingArgs(VarHandle.AccessType at) {</span>
<span class="udiff-line-added">+         return switch (at) {</span>
<span class="udiff-line-added">+             case GET -&gt; 0;</span>
<span class="udiff-line-added">+             case GET_AND_UPDATE, SET -&gt; 1;</span>
<span class="udiff-line-added">+             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {</span>
<span class="udiff-line-added">+         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="udiff-line-added">+         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];</span>
<span class="udiff-line-added">+         adjustedReorder[0] = 0;</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; reorder.length ; i++) {</span>
<span class="udiff-line-added">+             adjustedReorder[i + 1] = reorder[i] + 1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="udiff-line-added">+             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return adjustedReorder;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {</span>
<span class="udiff-line-added">+         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="udiff-line-added">+         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));</span>
<span class="udiff-line-added">+         adjustedType = adjustedType.appendParameterTypes(newCoordinates);</span>
<span class="udiff-line-added">+         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="udiff-line-added">+             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return adjustedType;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(filter);</span>
<span class="udiff-line-added">+         noCheckedExceptions(filter);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-added">+         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-added">+         } else if (filter.type().returnType() == void.class) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);</span>
<span class="udiff-line-added">+         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-added">+         newCoordinates.remove(pos);</span>
<span class="udiff-line-added">+         newCoordinates.addAll(pos, filter.type().parameterList());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="udiff-line-added">+         Objects.nonNull(target);</span>
<span class="udiff-line-added">+         Objects.nonNull(valueTypes);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="udiff-line-added">+         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {</span>
<span class="udiff-line-added">+             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (valueTypes.length == 0) return target;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="udiff-line-added">+         newCoordinates.addAll(pos, List.of(valueTypes));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="udiff-line-added">+                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static void noCheckedExceptions(MethodHandle handle) {</span>
<span class="udiff-line-added">+         if (handle instanceof DirectMethodHandle) {</span>
<span class="udiff-line-added">+             DirectMethodHandle directHandle = (DirectMethodHandle)handle;</span>
<span class="udiff-line-added">+             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);</span>
<span class="udiff-line-added">+             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {</span>
<span class="udiff-line-added">+                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,</span>
<span class="udiff-line-added">+                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;</span>
<span class="udiff-line-added">+                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="udiff-line-added">+                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;</span>
<span class="udiff-line-added">+                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="udiff-line-added">+                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,</span>
<span class="udiff-line-added">+                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;</span>
<span class="udiff-line-added">+                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             if (exceptionTypes != null) {</span>
<span class="udiff-line-added">+                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {</span>
<span class="udiff-line-added">+                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (handle instanceof DelegatingMethodHandle) {</span>
<span class="udiff-line-added">+             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             //bound</span>
<span class="udiff-line-added">+             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;</span>
<span class="udiff-line-added">+             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {</span>
<span class="udiff-line-added">+                 Object arg = boundHandle.arg(i);</span>
<span class="udiff-line-added">+                 if (arg instanceof MethodHandle){</span>
<span class="udiff-line-added">+                     noCheckedExceptions((MethodHandle) arg);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static boolean isCheckedException(Class&lt;?&gt; clazz) {</span>
<span class="udiff-line-added">+         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="udiff-line-added">+                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="udiff-line-added">+                 !Error.class.isAssignableFrom(clazz);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  //    /**
  //     * A helper program to generate the VarHandleGuards class with a set of
  //     * static guard methods each of which corresponds to a particular shape and
  //     * performs a type check of the symbolic type descriptor with the VarHandle
  //     * type descriptor before linking/invoking to the underlying operation as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -381,11 +630,11 @@</span>
  //
  //        static final String GUARD_METHOD_TEMPLATE =
  //                &quot;@ForceInline\n&quot; +
  //                &quot;@LambdaForm.Compiled\n&quot; +
  //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="udiff-line-modified-removed">- //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
<span class="udiff-line-modified-added">+ //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
  //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
  //                &quot;    }\n&quot; +
  //                &quot;    else {\n&quot; +
  //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
  //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,14 +643,14 @@</span>
  //
  //        static final String GUARD_METHOD_TEMPLATE_V =
  //                &quot;@ForceInline\n&quot; +
  //                &quot;@LambdaForm.Compiled\n&quot; +
  //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="udiff-line-modified-removed">- //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
<span class="udiff-line-modified-added">+ //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
  //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
  //                &quot;    }\n&quot; +
<span class="udiff-line-modified-removed">- //                &quot;    else if (handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
<span class="udiff-line-modified-added">+ //                &quot;    else if (handle.isDirect() &amp;&amp; handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
  //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
  //                &quot;    }\n&quot; +
  //                &quot;    else {\n&quot; +
  //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
  //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
</pre>
<center><a href="MethodHandles.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
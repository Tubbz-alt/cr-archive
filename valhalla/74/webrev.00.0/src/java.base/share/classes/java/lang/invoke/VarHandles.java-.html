<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 
 30 import java.lang.reflect.Field;
 31 import java.lang.reflect.Modifier;
 32 import java.nio.ByteOrder;
 33 import java.util.Map;
 34 import java.util.concurrent.ConcurrentHashMap;
 35 import java.util.concurrent.ConcurrentMap;
 36 
 37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 38 
 39 final class VarHandles {
 40 
 41     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 42         @Override
 43         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 44             return new ConcurrentHashMap&lt;&gt;();
 45         }
 46     };
 47 
 48     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 49         if (!f.isStatic()) {
 50             long foffset = MethodHandleNatives.objectFieldOffset(f);
 51             if (!type.isPrimitive()) {
 52                 if (f.isFlattened()) {
 53                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 54                         ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)
 55                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type);
 56                 } else {
 57                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 58                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
 59                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type);
 60                 }
 61             }
 62             else if (type == boolean.class) {
 63                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 64                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
 65                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset);
 66             }
 67             else if (type == byte.class) {
 68                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 69                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
 70                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset);
 71             }
 72             else if (type == short.class) {
 73                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 74                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
 75                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset);
 76             }
 77             else if (type == char.class) {
 78                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 79                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
 80                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset);
 81             }
 82             else if (type == int.class) {
 83                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 84                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
 85                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset);
 86             }
 87             else if (type == long.class) {
 88                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 89                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
 90                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset);
 91             }
 92             else if (type == float.class) {
 93                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 94                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
 95                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset);
 96             }
 97             else if (type == double.class) {
 98                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
 99                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
100                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset);
101             }
102             else {
103                 throw new UnsupportedOperationException();
104             }
105         }
106         else {
107             // TODO This is not lazy on first invocation
108             // and might cause some circular initialization issues
109 
110             // Replace with something similar to direct method handles
111             // where a barrier is used then elided after use
112 
113             if (UNSAFE.shouldBeInitialized(refc))
114                 UNSAFE.ensureClassInitialized(refc);
115 
116             Object base = MethodHandleNatives.staticFieldBase(f);
117             long foffset = MethodHandleNatives.staticFieldOffset(f);
118             if (!type.isPrimitive()) {
119                 if (f.isFlattened()) {
120                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
121                             ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)
122                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type);
123                 } else {
124                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
125                             ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
126                             : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);
127                 }
128             }
129             else if (type == boolean.class) {
130                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
131                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
132                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset);
133             }
134             else if (type == byte.class) {
135                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
136                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
137                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset);
138             }
139             else if (type == short.class) {
140                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
141                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
142                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset);
143             }
144             else if (type == char.class) {
145                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
146                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
147                        : new VarHandleChars.FieldStaticReadWrite(base, foffset);
148             }
149             else if (type == int.class) {
150                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
151                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
152                        : new VarHandleInts.FieldStaticReadWrite(base, foffset);
153             }
154             else if (type == long.class) {
155                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
156                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
157                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset);
158             }
159             else if (type == float.class) {
160                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
161                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
162                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset);
163             }
164             else if (type == double.class) {
165                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
166                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
167                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset);
168             }
169             else {
170                 throw new UnsupportedOperationException();
171             }
172         }
173     }
174 
175     // Required by instance field handles
176     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
177                                                long offset,
178                                                Class&lt;?&gt; fieldType) {
179         for (Field f : receiverType.getDeclaredFields()) {
180             if (Modifier.isStatic(f.getModifiers())) continue;
181 
182             if (offset == UNSAFE.objectFieldOffset(f)) {
183                 assert f.getType() == fieldType;
184                 return f;
185             }
186         }
187         throw new InternalError(&quot;Field not found at offset&quot;);
188     }
189 
190     // Required by instance static field handles
191     static Field getStaticFieldFromBaseAndOffset(Object base,
192                                                  long offset,
193                                                  Class&lt;?&gt; fieldType) {
194         // @@@ This is a little fragile assuming the base is the class
195         Class&lt;?&gt; receiverType = (Class&lt;?&gt;) base;
196         for (Field f : receiverType.getDeclaredFields()) {
197             if (!Modifier.isStatic(f.getModifiers())) continue;
198 
199             if (offset == UNSAFE.staticFieldOffset(f)) {
200                 assert f.getType() == fieldType;
201                 return f;
202             }
203         }
204         throw new InternalError(&quot;Static field not found at offset&quot;);
205     }
206 
207     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
208         if (!arrayClass.isArray())
209             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
210 
211         Class&lt;?&gt; componentType = arrayClass.getComponentType();
212 
213         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
214         int ascale = UNSAFE.arrayIndexScale(arrayClass);
215         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
216 
217         if (!componentType.isPrimitive()) {
218             // the redundant componentType.isValue() check is there to
219             // minimize the performance impact to non-value array.
220             // It should be removed when Unsafe::isFlattenedArray is intrinsified.
221 
222             return componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)
223                 ? new VarHandleValues.Array(aoffset, ashift, arrayClass)
224                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass);
225         }
226         else if (componentType == boolean.class) {
227             return new VarHandleBooleans.Array(aoffset, ashift);
228         }
229         else if (componentType == byte.class) {
230             return new VarHandleBytes.Array(aoffset, ashift);
231         }
232         else if (componentType == short.class) {
233             return new VarHandleShorts.Array(aoffset, ashift);
234         }
235         else if (componentType == char.class) {
236             return new VarHandleChars.Array(aoffset, ashift);
237         }
238         else if (componentType == int.class) {
239             return new VarHandleInts.Array(aoffset, ashift);
240         }
241         else if (componentType == long.class) {
242             return new VarHandleLongs.Array(aoffset, ashift);
243         }
244         else if (componentType == float.class) {
245             return new VarHandleFloats.Array(aoffset, ashift);
246         }
247         else if (componentType == double.class) {
248             return new VarHandleDoubles.Array(aoffset, ashift);
249         }
250         else {
251             throw new UnsupportedOperationException();
252         }
253     }
254 
255     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
256                                          boolean be) {
257         if (!viewArrayClass.isArray())
258             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
259 
260         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
261 
262         if (viewComponentType == long.class) {
263             return new VarHandleByteArrayAsLongs.ArrayHandle(be);
264         }
265         else if (viewComponentType == int.class) {
266             return new VarHandleByteArrayAsInts.ArrayHandle(be);
267         }
268         else if (viewComponentType == short.class) {
269             return new VarHandleByteArrayAsShorts.ArrayHandle(be);
270         }
271         else if (viewComponentType == char.class) {
272             return new VarHandleByteArrayAsChars.ArrayHandle(be);
273         }
274         else if (viewComponentType == double.class) {
275             return new VarHandleByteArrayAsDoubles.ArrayHandle(be);
276         }
277         else if (viewComponentType == float.class) {
278             return new VarHandleByteArrayAsFloats.ArrayHandle(be);
279         }
280 
281         throw new UnsupportedOperationException();
282     }
283 
284     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
285                                               boolean be) {
286         if (!viewArrayClass.isArray())
287             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
288 
289         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
290 
291         if (viewComponentType == long.class) {
292             return new VarHandleByteArrayAsLongs.ByteBufferHandle(be);
293         }
294         else if (viewComponentType == int.class) {
295             return new VarHandleByteArrayAsInts.ByteBufferHandle(be);
296         }
297         else if (viewComponentType == short.class) {
298             return new VarHandleByteArrayAsShorts.ByteBufferHandle(be);
299         }
300         else if (viewComponentType == char.class) {
301             return new VarHandleByteArrayAsChars.ByteBufferHandle(be);
302         }
303         else if (viewComponentType == double.class) {
304             return new VarHandleByteArrayAsDoubles.ByteBufferHandle(be);
305         }
306         else if (viewComponentType == float.class) {
307             return new VarHandleByteArrayAsFloats.ByteBufferHandle(be);
308         }
309 
310         throw new UnsupportedOperationException();
311     }
312 
313     /**
314      * Creates a memory access VarHandle.
315      *
316      * Resulting VarHandle will take a memory address as first argument,
317      * and a certain number of coordinate {@code long} parameters, depending on the length
318      * of the {@code strides} argument array.
319      *
320      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
321      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
322      *
323      * @param carrier the Java carrier type.
324      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
325      * @param byteOrder the byte order.
326      * @param offset a constant offset for the access.
327      * @param strides the scale factors with which to multiply given access coordinates.
328      * @return the created VarHandle.
329      */
330     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
331                                                  ByteOrder byteOrder, long offset, long[] strides) {
332         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
333             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
334         }
335         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
336         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
337 
338         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
339         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
340                 dims -&gt; new AddressVarHandleGenerator(carrier, dims)
341                             .generateHandleFactory());
342 
343         try {
344             return (VarHandle)fac.invoke(be, size, offset, alignmentMask, strides);
345         } catch (Throwable ex) {
346             throw new IllegalStateException(ex);
347         }
348     }
349 
350 //    /**
351 //     * A helper program to generate the VarHandleGuards class with a set of
352 //     * static guard methods each of which corresponds to a particular shape and
353 //     * performs a type check of the symbolic type descriptor with the VarHandle
354 //     * type descriptor before linking/invoking to the underlying operation as
355 //     * characterized by the operation member name on the VarForm of the
356 //     * VarHandle.
357 //     * &lt;p&gt;
358 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
359 //     * one for each method, for the most set of common method signatures.
360 //     * This reduces static initialization costs, footprint costs, and circular
361 //     * dependencies that may arise if a class is generated per LambdaForm.
362 //     * &lt;p&gt;
363 //     * A maximum of L*T*S methods will be generated where L is the number of
364 //     * access modes kinds (or unique operation signatures) and T is the number
365 //     * of variable types and S is the number of shapes (such as instance field,
366 //     * static field, or array access).
367 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
368 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
369 //     * generated.  However, the number is likely to be less since there
370 //     * be duplicate signatures.
371 //     * &lt;p&gt;
372 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
373 //     * that such methods should be treated as if a method of a class that is the
374 //     * result of compiling a LambdaForm.  Annotation of such methods is
375 //     * important for correct evaluation of certain assertions and method return
376 //     * type profiling in HotSpot.
377 //     */
378 //    public static class GuardMethodGenerator {
379 //
380 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
381 //
382 //        static final String GUARD_METHOD_TEMPLATE =
383 //                &quot;@ForceInline\n&quot; +
384 //                &quot;@LambdaForm.Compiled\n&quot; +
385 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
386 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
387 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
388 //                &quot;    }\n&quot; +
389 //                &quot;    else {\n&quot; +
390 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
391 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
392 //                &quot;    }\n&quot; +
393 //                &quot;}&quot;;
394 //
395 //        static final String GUARD_METHOD_TEMPLATE_V =
396 //                &quot;@ForceInline\n&quot; +
397 //                &quot;@LambdaForm.Compiled\n&quot; +
398 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
399 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +
400 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
401 //                &quot;    }\n&quot; +
402 //                &quot;    else if (handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +
403 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
404 //                &quot;    }\n&quot; +
405 //                &quot;    else {\n&quot; +
406 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
407 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
408 //                &quot;    }\n&quot; +
409 //                &quot;}&quot;;
410 //
411 //        // A template for deriving the operations
412 //        // could be supported by annotating VarHandle directly with the
413 //        // operation kind and shape
414 //        interface VarHandleTemplate {
415 //            Object get();
416 //
417 //            void set(Object value);
418 //
419 //            boolean compareAndSet(Object actualValue, Object expectedValue);
420 //
421 //            Object compareAndExchange(Object actualValue, Object expectedValue);
422 //
423 //            Object getAndUpdate(Object value);
424 //        }
425 //
426 //        static class HandleType {
427 //            final Class&lt;?&gt; receiver;
428 //            final Class&lt;?&gt;[] intermediates;
429 //            final Class&lt;?&gt; value;
430 //
431 //            HandleType(Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
432 //                this.receiver = receiver;
433 //                this.intermediates = intermediates;
434 //                this.value = value;
435 //            }
436 //        }
437 //
438 //        /**
439 //         * @param args parameters
440 //         */
441 //        public static void main(String[] args) {
442 //            System.out.println(&quot;package java.lang.invoke;&quot;);
443 //            System.out.println();
444 //            System.out.println(&quot;import jdk.internal.vm.annotation.ForceInline;&quot;);
445 //            System.out.println();
446 //            System.out.println(&quot;// This class is auto-generated by &quot; +
447 //                               GuardMethodGenerator.class.getName() +
448 //                               &quot;. Do not edit.&quot;);
449 //            System.out.println(&quot;final class VarHandleGuards {&quot;);
450 //
451 //            System.out.println();
452 //
453 //            // Declare the stream of shapes
454 //            Stream&lt;HandleType&gt; hts = Stream.of(
455 //                    // Object-&gt;Object
456 //                    new HandleType(Object.class, Object.class),
457 //                    // Object-&gt;int
458 //                    new HandleType(Object.class, int.class),
459 //                    // Object-&gt;long
460 //                    new HandleType(Object.class, long.class),
461 //                    // Object-&gt;float
462 //                    new HandleType(Object.class, float.class),
463 //                    // Object-&gt;double
464 //                    new HandleType(Object.class, double.class),
465 //
466 //                    // &lt;static&gt;-&gt;Object
467 //                    new HandleType(null, Object.class),
468 //                    // &lt;static&gt;-&gt;int
469 //                    new HandleType(null, int.class),
470 //                    // &lt;static&gt;-&gt;long
471 //                    new HandleType(null, long.class),
472 //                    // &lt;static&gt;-&gt;float
473 //                    new HandleType(null, float.class),
474 //                    // &lt;static&gt;-&gt;double
475 //                    new HandleType(null, double.class),
476 //
477 //                    // Array[int]-&gt;Object
478 //                    new HandleType(Object.class, Object.class, int.class),
479 //                    // Array[int]-&gt;int
480 //                    new HandleType(Object.class, int.class, int.class),
481 //                    // Array[int]-&gt;long
482 //                    new HandleType(Object.class, long.class, int.class),
483 //                    // Array[int]-&gt;float
484 //                    new HandleType(Object.class, float.class, int.class),
485 //                    // Array[int]-&gt;double
486 //                    new HandleType(Object.class, double.class, int.class),
487 //
488 //                    // Array[long]-&gt;int
489 //                    new HandleType(Object.class, int.class, long.class),
490 //                    // Array[long]-&gt;long
491 //                    new HandleType(Object.class, long.class, long.class)
492 //            );
493 //
494 //            hts.flatMap(ht -&gt; Stream.of(VarHandleTemplate.class.getMethods()).
495 //                    map(m -&gt; generateMethodType(m, ht.receiver, ht.value, ht.intermediates))).
496 //                    distinct().
497 //                    map(mt -&gt; generateMethod(mt)).
498 //                    forEach(s -&gt; {
499 //                        System.out.println(s);
500 //                        System.out.println();
501 //                    });
502 //
503 //            System.out.println(&quot;}&quot;);
504 //        }
505 //
506 //        static MethodType generateMethodType(Method m, Class&lt;?&gt; receiver, Class&lt;?&gt; value, Class&lt;?&gt;... intermediates) {
507 //            Class&lt;?&gt; returnType = m.getReturnType() == Object.class
508 //                                  ? value : m.getReturnType();
509 //
510 //            List&lt;Class&lt;?&gt;&gt; params = new ArrayList&lt;&gt;();
511 //            if (receiver != null)
512 //                params.add(receiver);
513 //            for (int i = 0; i &lt; intermediates.length; i++) {
514 //                params.add(intermediates[i]);
515 //            }
516 //            for (Parameter p : m.getParameters()) {
517 //                params.add(value);
518 //            }
519 //            return MethodType.methodType(returnType, params);
520 //        }
521 //
522 //        static String generateMethod(MethodType mt) {
523 //            Class&lt;?&gt; returnType = mt.returnType();
524 //
525 //            LinkedHashMap&lt;String, Class&lt;?&gt;&gt; params = new LinkedHashMap&lt;&gt;();
526 //            params.put(&quot;handle&quot;, VarHandle.class);
527 //            for (int i = 0; i &lt; mt.parameterCount(); i++) {
528 //                params.put(&quot;arg&quot; + i, mt.parameterType(i));
529 //            }
530 //            params.put(&quot;ad&quot;, VarHandle.AccessDescriptor.class);
531 //
532 //            // Generate method signature line
533 //            String RETURN = className(returnType);
534 //            String NAME = &quot;guard&quot;;
535 //            String SIGNATURE = getSignature(mt);
536 //            String PARAMS = params.entrySet().stream().
537 //                    map(e -&gt; className(e.getValue()) + &quot; &quot; + e.getKey()).
538 //                    collect(joining(&quot;, &quot;));
539 //            String METHOD = GUARD_METHOD_SIG_TEMPLATE.
540 //                    replace(&quot;&lt;RETURN&gt;&quot;, RETURN).
541 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
542 //                    replace(&quot;&lt;SIGNATURE&gt;&quot;, SIGNATURE).
543 //                    replace(&quot;&lt;PARAMS&gt;&quot;, PARAMS);
544 //
545 //            // Generate method
546 //            params.remove(&quot;ad&quot;);
547 //
548 //            List&lt;String&gt; LINK_TO_STATIC_ARGS = params.keySet().stream().
549 //                    collect(toList());
550 //            LINK_TO_STATIC_ARGS.add(&quot;handle.vform.getMemberName(ad.mode)&quot;);
551 //            List&lt;String&gt; LINK_TO_STATIC_ARGS_V = params.keySet().stream().
552 //                    collect(toList());
553 //            LINK_TO_STATIC_ARGS_V.add(&quot;handle.vform.getMemberName_V(ad.mode)&quot;);
554 //
555 //            List&lt;String&gt; LINK_TO_INVOKER_ARGS = params.keySet().stream().
556 //                    collect(toList());
557 //
558 //            RETURN = returnType == void.class
559 //                     ? &quot;&quot;
560 //                     : returnType == Object.class
561 //                       ? &quot;return &quot;
562 //                       : &quot;return (&quot; + returnType.getName() + &quot;) &quot;;
563 //
564 //            String RESULT_ERASED = returnType == void.class
565 //                                   ? &quot;&quot;
566 //                                   : returnType != Object.class
567 //                                     ? &quot;return (&quot; + returnType.getName() + &quot;) &quot;
568 //                                     : &quot;Object r = &quot;;
569 //
570 //            String RETURN_ERASED = returnType != Object.class
571 //                                   ? &quot;&quot;
572 //                                   : &quot; return ad.returnType.cast(r);&quot;;
573 //
574 //            String template = returnType == void.class
575 //                              ? GUARD_METHOD_TEMPLATE_V
576 //                              : GUARD_METHOD_TEMPLATE;
577 //            return template.
578 //                    replace(&quot;&lt;METHOD&gt;&quot;, METHOD).
579 //                    replace(&quot;&lt;NAME&gt;&quot;, NAME).
580 //                    replaceAll(&quot;&lt;RETURN&gt;&quot;, RETURN).
581 //                    replace(&quot;&lt;RESULT_ERASED&gt;&quot;, RESULT_ERASED).
582 //                    replace(&quot;&lt;RETURN_ERASED&gt;&quot;, RETURN_ERASED).
583 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS&gt;&quot;, LINK_TO_STATIC_ARGS.stream().
584 //                            collect(joining(&quot;, &quot;))).
585 //                    replaceAll(&quot;&lt;LINK_TO_STATIC_ARGS_V&gt;&quot;, LINK_TO_STATIC_ARGS_V.stream().
586 //                            collect(joining(&quot;, &quot;))).
587 //                    replace(&quot;&lt;LINK_TO_INVOKER_ARGS&gt;&quot;, LINK_TO_INVOKER_ARGS.stream().
588 //                            collect(joining(&quot;, &quot;)))
589 //                    ;
590 //        }
591 //
592 //        static String className(Class&lt;?&gt; c) {
593 //            String n = c.getName();
594 //            if (n.startsWith(&quot;java.lang.&quot;)) {
595 //                n = n.replace(&quot;java.lang.&quot;, &quot;&quot;);
596 //                if (n.startsWith(&quot;invoke.&quot;)) {
597 //                    n = n.replace(&quot;invoke.&quot;, &quot;&quot;);
598 //                }
599 //            }
600 //            return n.replace(&#39;$&#39;, &#39;.&#39;);
601 //        }
602 //
603 //        static String getSignature(MethodType m) {
604 //            StringBuilder sb = new StringBuilder(m.parameterCount() + 1);
605 //
606 //            for (int i = 0; i &lt; m.parameterCount(); i++) {
607 //                Class&lt;?&gt; pt = m.parameterType(i);
608 //                sb.append(getCharType(pt));
609 //            }
610 //
611 //            sb.append(&#39;_&#39;).append(getCharType(m.returnType()));
612 //
613 //            return sb.toString();
614 //        }
615 //
616 //        static char getCharType(Class&lt;?&gt; pt) {
617 //            if (pt == void.class) {
618 //                return &#39;V&#39;;
619 //            }
620 //            else if (!pt.isPrimitive()) {
621 //                return &#39;L&#39;;
622 //            }
623 //            else if (pt == boolean.class) {
624 //                return &#39;Z&#39;;
625 //            }
626 //            else if (pt == int.class) {
627 //                return &#39;I&#39;;
628 //            }
629 //            else if (pt == long.class) {
630 //                return &#39;J&#39;;
631 //            }
632 //            else if (pt == float.class) {
633 //                return &#39;F&#39;;
634 //            }
635 //            else if (pt == double.class) {
636 //                return &#39;D&#39;;
637 //            }
638 //            else {
639 //                throw new IllegalStateException(pt.getName());
640 //            }
641 //        }
642 //    }
643 }
    </pre>
  </body>
</html>
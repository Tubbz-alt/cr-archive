<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandle.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 
  61         @Override
  62         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  63             return accessMode.at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});
  64         }
  65 
  66         @Override
  67         public Optional&lt;VarHandleDesc&gt; describeConstable() {
  68             var receiverTypeRef = receiverType.describeConstable();
  69             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
  70             if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())
  71                 return Optional.empty();
  72 
  73             // Reflect on this VarHandle to extract the field name
  74             String name = VarHandles.getFieldFromReceiverAndOffset(
  75                 receiverType, fieldOffset, {#if[Object]?fieldType:$type$.class}).getName();
  76             return Optional.of(VarHandleDesc.ofField(receiverTypeRef.get(), name, fieldTypeRef.get()));
  77         }
  78 
  79         @ForceInline
<span class="line-modified">  80         static $type$ get(FieldInstanceReadOnly handle, Object holder) {</span>

  81             return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
  82                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  83         }
  84 
  85         @ForceInline
<span class="line-modified">  86         static $type$ getVolatile(FieldInstanceReadOnly handle, Object holder) {</span>

  87             return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
  88                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  89         }
  90 
  91         @ForceInline
<span class="line-modified">  92         static $type$ getOpaque(FieldInstanceReadOnly handle, Object holder) {</span>

  93             return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
  94                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  95         }
  96 
  97         @ForceInline
<span class="line-modified">  98         static $type$ getAcquire(FieldInstanceReadOnly handle, Object holder) {</span>

  99             return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 100                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 101         }
 102 
 103         static final VarForm FORM = new VarForm(FieldInstanceReadOnly.class, Object.class, $type$.class);
 104     }
 105 
 106     static final class FieldInstanceReadWrite extends FieldInstanceReadOnly {
 107         FieldInstanceReadWrite(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 108             super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);
 109         }
 110 
 111 #if[Object]
 112         @ForceInline
 113         static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {
 114             if (handle.fieldType.isInlineClass())
 115                 Objects.requireNonNull(value);
 116             return handle.fieldType.cast(value);
 117         }
 118 #end[Object]
 119 
 120         @ForceInline
<span class="line-modified"> 121         static void set(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 122             UNSAFE.put$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 123                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 124                              {#if[Object]?checkCast(handle, value):value});
 125         }
 126 
 127         @ForceInline
<span class="line-modified"> 128         static void setVolatile(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 129             UNSAFE.put$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
 130                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 131                                      {#if[Object]?checkCast(handle, value):value});
 132         }
 133 
 134         @ForceInline
<span class="line-modified"> 135         static void setOpaque(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 136             UNSAFE.put$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
 137                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 138                                    {#if[Object]?checkCast(handle, value):value});
 139         }
 140 
 141         @ForceInline
<span class="line-modified"> 142         static void setRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 143             UNSAFE.put$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 144                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 145                                     {#if[Object]?checkCast(handle, value):value});
 146         }
 147 #if[CAS]
 148 
 149         @ForceInline
<span class="line-modified"> 150         static boolean compareAndSet(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 151             return UNSAFE.compareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 152                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 153                                                {#if[Object]?checkCast(handle, expected):expected},
 154                                                {#if[Object]?checkCast(handle, value):value});
 155         }
 156 
 157         @ForceInline
<span class="line-modified"> 158         static $type$ compareAndExchange(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 159             return UNSAFE.compareAndExchange$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 160                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 161                                                {#if[Object]?checkCast(handle, expected):expected},
 162                                                {#if[Object]?checkCast(handle, value):value});
 163         }
 164 
 165         @ForceInline
<span class="line-modified"> 166         static $type$ compareAndExchangeAcquire(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 167             return UNSAFE.compareAndExchange$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 168                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 169                                                {#if[Object]?checkCast(handle, expected):expected},
 170                                                {#if[Object]?checkCast(handle, value):value});
 171         }
 172 
 173         @ForceInline
<span class="line-modified"> 174         static $type$ compareAndExchangeRelease(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 175             return UNSAFE.compareAndExchange$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 176                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 177                                                {#if[Object]?checkCast(handle, expected):expected},
 178                                                {#if[Object]?checkCast(handle, value):value});
 179         }
 180 
 181         @ForceInline
<span class="line-modified"> 182         static boolean weakCompareAndSetPlain(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 183             return UNSAFE.weakCompareAndSet$Type$Plain(Objects.requireNonNull(handle.receiverType.cast(holder)),
 184                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 185                                                {#if[Object]?checkCast(handle, expected):expected},
 186                                                {#if[Object]?checkCast(handle, value):value});
 187         }
 188 
 189         @ForceInline
<span class="line-modified"> 190         static boolean weakCompareAndSet(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 191             return UNSAFE.weakCompareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 192                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 193                                                {#if[Object]?checkCast(handle, expected):expected},
 194                                                {#if[Object]?checkCast(handle, value):value});
 195         }
 196 
 197         @ForceInline
<span class="line-modified"> 198         static boolean weakCompareAndSetAcquire(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 199             return UNSAFE.weakCompareAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 200                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 201                                                {#if[Object]?checkCast(handle, expected):expected},
 202                                                {#if[Object]?checkCast(handle, value):value});
 203         }
 204 
 205         @ForceInline
<span class="line-modified"> 206         static boolean weakCompareAndSetRelease(FieldInstanceReadWrite handle, Object holder, $type$ expected, $type$ value) {</span>

 207             return UNSAFE.weakCompareAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 208                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 209                                                {#if[Object]?checkCast(handle, expected):expected},
 210                                                {#if[Object]?checkCast(handle, value):value});
 211         }
 212 
 213         @ForceInline
<span class="line-modified"> 214         static $type$ getAndSet(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 215             return UNSAFE.getAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 216                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 217                                           {#if[Object]?checkCast(handle, value):value});
 218         }
 219 
 220         @ForceInline
<span class="line-modified"> 221         static $type$ getAndSetAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 222             return UNSAFE.getAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 223                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 224                                           {#if[Object]?checkCast(handle, value):value});
 225         }
 226 
 227         @ForceInline
<span class="line-modified"> 228         static $type$ getAndSetRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 229             return UNSAFE.getAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 230                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 231                                           {#if[Object]?checkCast(handle, value):value});
 232         }
 233 #end[CAS]
 234 #if[AtomicAdd]
 235 
 236         @ForceInline
<span class="line-modified"> 237         static $type$ getAndAdd(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 238             return UNSAFE.getAndAdd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 239                                        handle.fieldOffset,
 240                                        value);
 241         }
 242 
 243         @ForceInline
<span class="line-modified"> 244         static $type$ getAndAddAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 245             return UNSAFE.getAndAdd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 246                                        handle.fieldOffset,
 247                                        value);
 248         }
 249 
 250         @ForceInline
<span class="line-modified"> 251         static $type$ getAndAddRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 252             return UNSAFE.getAndAdd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 253                                        handle.fieldOffset,
 254                                        value);
 255         }
 256 
 257 #end[AtomicAdd]
 258 #if[Bitwise]
 259 
 260         @ForceInline
<span class="line-modified"> 261         static $type$ getAndBitwiseOr(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 262             return UNSAFE.getAndBitwiseOr$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 263                                        handle.fieldOffset,
 264                                        value);
 265         }
 266 
 267         @ForceInline
<span class="line-modified"> 268         static $type$ getAndBitwiseOrRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 269             return UNSAFE.getAndBitwiseOr$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 270                                        handle.fieldOffset,
 271                                        value);
 272         }
 273 
 274         @ForceInline
<span class="line-modified"> 275         static $type$ getAndBitwiseOrAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 276             return UNSAFE.getAndBitwiseOr$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 277                                        handle.fieldOffset,
 278                                        value);
 279         }
 280 
 281         @ForceInline
<span class="line-modified"> 282         static $type$ getAndBitwiseAnd(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 283             return UNSAFE.getAndBitwiseAnd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 284                                        handle.fieldOffset,
 285                                        value);
 286         }
 287 
 288         @ForceInline
<span class="line-modified"> 289         static $type$ getAndBitwiseAndRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 290             return UNSAFE.getAndBitwiseAnd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 291                                        handle.fieldOffset,
 292                                        value);
 293         }
 294 
 295         @ForceInline
<span class="line-modified"> 296         static $type$ getAndBitwiseAndAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 297             return UNSAFE.getAndBitwiseAnd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 298                                        handle.fieldOffset,
 299                                        value);
 300         }
 301 
 302         @ForceInline
<span class="line-modified"> 303         static $type$ getAndBitwiseXor(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 304             return UNSAFE.getAndBitwiseXor$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 305                                        handle.fieldOffset,
 306                                        value);
 307         }
 308 
 309         @ForceInline
<span class="line-modified"> 310         static $type$ getAndBitwiseXorRelease(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 311             return UNSAFE.getAndBitwiseXor$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 312                                        handle.fieldOffset,
 313                                        value);
 314         }
 315 
 316         @ForceInline
<span class="line-modified"> 317         static $type$ getAndBitwiseXorAcquire(FieldInstanceReadWrite handle, Object holder, $type$ value) {</span>

 318             return UNSAFE.getAndBitwiseXor$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 319                                        handle.fieldOffset,
 320                                        value);
 321         }
 322 #end[Bitwise]
 323 
 324         static final VarForm FORM = new VarForm(FieldInstanceReadWrite.class, Object.class, $type$.class);
 325     }
 326 
 327 
 328     static class FieldStaticReadOnly extends VarHandle {
 329         final Object base;
 330         final long fieldOffset;
 331 #if[Object]
 332         final Class&lt;?&gt; fieldType;
 333 #end[Object]
 334 
 335         FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 336             this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);
 337         }
</pre>
<hr />
<pre>
 350         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 351             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
 352             if (!fieldTypeRef.isPresent())
 353                 return Optional.empty();
 354 
 355             // Reflect on this VarHandle to extract the field name
 356             var staticField = VarHandles.getStaticFieldFromBaseAndOffset(
 357                 base, fieldOffset, {#if[Object]?fieldType:$type$.class});
 358             var receiverTypeRef = staticField.getDeclaringClass().describeConstable();
 359             if (!receiverTypeRef.isPresent())
 360                 return Optional.empty();
 361             return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));
 362         }
 363 
 364         @Override
 365         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 366             return accessMode.at.accessModeType(null, {#if[Object]?fieldType:$type$.class});
 367         }
 368 
 369         @ForceInline
<span class="line-modified"> 370         static $type$ get(FieldStaticReadOnly handle) {</span>

 371             return UNSAFE.get$Type$(handle.base,
 372                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 373         }
 374 
 375         @ForceInline
<span class="line-modified"> 376         static $type$ getVolatile(FieldStaticReadOnly handle) {</span>

 377             return UNSAFE.get$Type$Volatile(handle.base,
 378                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 379         }
 380 
 381         @ForceInline
<span class="line-modified"> 382         static $type$ getOpaque(FieldStaticReadOnly handle) {</span>

 383             return UNSAFE.get$Type$Opaque(handle.base,
 384                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 385         }
 386 
 387         @ForceInline
<span class="line-modified"> 388         static $type$ getAcquire(FieldStaticReadOnly handle) {</span>

 389             return UNSAFE.get$Type$Acquire(handle.base,
 390                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 391         }
 392 
 393         static final VarForm FORM = new VarForm(FieldStaticReadOnly.class, null, $type$.class);
 394     }
 395 
 396     static final class FieldStaticReadWrite extends FieldStaticReadOnly {
 397         FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 398             super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);
 399         }
 400 
 401 #if[Object]
 402         static Object checkCast(FieldStaticReadWrite handle, $type$ value) {
 403             if (handle.fieldType.isInlineClass())
 404                 Objects.requireNonNull(value);
 405             return handle.fieldType.cast(value);
 406         }
 407 #end[Object]
 408 
 409         @ForceInline
<span class="line-modified"> 410         static void set(FieldStaticReadWrite handle, $type$ value) {</span>

 411             UNSAFE.put$Type$(handle.base,
 412                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 413                              {#if[Object]?checkCast(handle, value):value});
 414         }
 415 
 416         @ForceInline
<span class="line-modified"> 417         static void setVolatile(FieldStaticReadWrite handle, $type$ value) {</span>

 418             UNSAFE.put$Type$Volatile(handle.base,
 419                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 420                                      {#if[Object]?checkCast(handle, value):value});
 421         }
 422 
 423         @ForceInline
<span class="line-modified"> 424         static void setOpaque(FieldStaticReadWrite handle, $type$ value) {</span>

 425             UNSAFE.put$Type$Opaque(handle.base,
 426                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 427                                    {#if[Object]?checkCast(handle, value):value});
 428         }
 429 
 430         @ForceInline
<span class="line-modified"> 431         static void setRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 432             UNSAFE.put$Type$Release(handle.base,
 433                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 434                                     {#if[Object]?checkCast(handle, value):value});
 435         }
 436 #if[CAS]
 437 
 438         @ForceInline
<span class="line-modified"> 439         static boolean compareAndSet(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 440             return UNSAFE.compareAndSet$Type$(handle.base,
 441                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 442                                                {#if[Object]?checkCast(handle, expected):expected},
 443                                                {#if[Object]?checkCast(handle, value):value});
 444         }
 445 
 446 
 447         @ForceInline
<span class="line-modified"> 448         static $type$ compareAndExchange(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 449             return UNSAFE.compareAndExchange$Type$(handle.base,
 450                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 451                                                {#if[Object]?checkCast(handle, expected):expected},
 452                                                {#if[Object]?checkCast(handle, value):value});
 453         }
 454 
 455         @ForceInline
<span class="line-modified"> 456         static $type$ compareAndExchangeAcquire(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 457             return UNSAFE.compareAndExchange$Type$Acquire(handle.base,
 458                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 459                                                {#if[Object]?checkCast(handle, expected):expected},
 460                                                {#if[Object]?checkCast(handle, value):value});
 461         }
 462 
 463         @ForceInline
<span class="line-modified"> 464         static $type$ compareAndExchangeRelease(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 465             return UNSAFE.compareAndExchange$Type$Release(handle.base,
 466                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 467                                                {#if[Object]?checkCast(handle, expected):expected},
 468                                                {#if[Object]?checkCast(handle, value):value});
 469         }
 470 
 471         @ForceInline
<span class="line-modified"> 472         static boolean weakCompareAndSetPlain(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 473             return UNSAFE.weakCompareAndSet$Type$Plain(handle.base,
 474                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 475                                                {#if[Object]?checkCast(handle, expected):expected},
 476                                                {#if[Object]?checkCast(handle, value):value});
 477         }
 478 
 479         @ForceInline
<span class="line-modified"> 480         static boolean weakCompareAndSet(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 481             return UNSAFE.weakCompareAndSet$Type$(handle.base,
 482                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 483                                                {#if[Object]?checkCast(handle, expected):expected},
 484                                                {#if[Object]?checkCast(handle, value):value});
 485         }
 486 
 487         @ForceInline
<span class="line-modified"> 488         static boolean weakCompareAndSetAcquire(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 489             return UNSAFE.weakCompareAndSet$Type$Acquire(handle.base,
 490                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 491                                                {#if[Object]?checkCast(handle, expected):expected},
 492                                                {#if[Object]?checkCast(handle, value):value});
 493         }
 494 
 495         @ForceInline
<span class="line-modified"> 496         static boolean weakCompareAndSetRelease(FieldStaticReadWrite handle, $type$ expected, $type$ value) {</span>

 497             return UNSAFE.weakCompareAndSet$Type$Release(handle.base,
 498                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 499                                                {#if[Object]?checkCast(handle, expected):expected},
 500                                                {#if[Object]?checkCast(handle, value):value});
 501         }
 502 
 503         @ForceInline
<span class="line-modified"> 504         static $type$ getAndSet(FieldStaticReadWrite handle, $type$ value) {</span>

 505             return UNSAFE.getAndSet$Type$(handle.base,
 506                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 507                                           {#if[Object]?checkCast(handle, value):value});
 508         }
 509 
 510         @ForceInline
<span class="line-modified"> 511         static $type$ getAndSetAcquire(FieldStaticReadWrite handle, $type$ value) {</span>

 512             return UNSAFE.getAndSet$Type$Acquire(handle.base,
 513                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 514                                           {#if[Object]?checkCast(handle, value):value});
 515         }
 516 
 517         @ForceInline
<span class="line-modified"> 518         static $type$ getAndSetRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 519             return UNSAFE.getAndSet$Type$Release(handle.base,
 520                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 521                                           {#if[Object]?checkCast(handle, value):value});
 522         }
 523 #end[CAS]
 524 #if[AtomicAdd]
 525 
 526         @ForceInline
<span class="line-modified"> 527         static $type$ getAndAdd(FieldStaticReadWrite handle, $type$ value) {</span>

 528             return UNSAFE.getAndAdd$Type$(handle.base,
 529                                        handle.fieldOffset,
 530                                        value);
 531         }
 532 
 533         @ForceInline
<span class="line-modified"> 534         static $type$ getAndAddAcquire(FieldStaticReadWrite handle, $type$ value) {</span>

 535             return UNSAFE.getAndAdd$Type$Acquire(handle.base,
 536                                        handle.fieldOffset,
 537                                        value);
 538         }
 539 
 540         @ForceInline
<span class="line-modified"> 541         static $type$ getAndAddRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 542             return UNSAFE.getAndAdd$Type$Release(handle.base,
 543                                        handle.fieldOffset,
 544                                        value);
 545         }
 546 #end[AtomicAdd]
 547 #if[Bitwise]
 548 
 549         @ForceInline
<span class="line-modified"> 550         static $type$ getAndBitwiseOr(FieldStaticReadWrite handle, $type$ value) {</span>

 551             return UNSAFE.getAndBitwiseOr$Type$(handle.base,
 552                                        handle.fieldOffset,
 553                                        value);
 554         }
 555 
 556         @ForceInline
<span class="line-modified"> 557         static $type$ getAndBitwiseOrRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 558             return UNSAFE.getAndBitwiseOr$Type$Release(handle.base,
 559                                        handle.fieldOffset,
 560                                        value);
 561         }
 562 
 563         @ForceInline
<span class="line-modified"> 564         static $type$ getAndBitwiseOrAcquire(FieldStaticReadWrite handle, $type$ value) {</span>

 565             return UNSAFE.getAndBitwiseOr$Type$Acquire(handle.base,
 566                                        handle.fieldOffset,
 567                                        value);
 568         }
 569 
 570         @ForceInline
<span class="line-modified"> 571         static $type$ getAndBitwiseAnd(FieldStaticReadWrite handle, $type$ value) {</span>

 572             return UNSAFE.getAndBitwiseAnd$Type$(handle.base,
 573                                        handle.fieldOffset,
 574                                        value);
 575         }
 576 
 577         @ForceInline
<span class="line-modified"> 578         static $type$ getAndBitwiseAndRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 579             return UNSAFE.getAndBitwiseAnd$Type$Release(handle.base,
 580                                        handle.fieldOffset,
 581                                        value);
 582         }
 583 
 584         @ForceInline
<span class="line-modified"> 585         static $type$ getAndBitwiseAndAcquire(FieldStaticReadWrite handle, $type$ value) {</span>

 586             return UNSAFE.getAndBitwiseAnd$Type$Acquire(handle.base,
 587                                        handle.fieldOffset,
 588                                        value);
 589         }
 590 
 591         @ForceInline
<span class="line-modified"> 592         static $type$ getAndBitwiseXor(FieldStaticReadWrite handle, $type$ value) {</span>

 593             return UNSAFE.getAndBitwiseXor$Type$(handle.base,
 594                                        handle.fieldOffset,
 595                                        value);
 596         }
 597 
 598         @ForceInline
<span class="line-modified"> 599         static $type$ getAndBitwiseXorRelease(FieldStaticReadWrite handle, $type$ value) {</span>

 600             return UNSAFE.getAndBitwiseXor$Type$Release(handle.base,
 601                                        handle.fieldOffset,
 602                                        value);
 603         }
 604 
 605         @ForceInline
<span class="line-modified"> 606         static $type$ getAndBitwiseXorAcquire(FieldStaticReadWrite handle, $type$ value) {</span>

 607             return UNSAFE.getAndBitwiseXor$Type$Acquire(handle.base,
 608                                        handle.fieldOffset,
 609                                        value);
 610         }
 611 #end[Bitwise]
 612 
 613         static final VarForm FORM = new VarForm(FieldStaticReadWrite.class, null, $type$.class);
 614     }
 615 
 616 #if[Reference]
 617     static VarHandle makeVarHandleValuesArray(Class&lt;?&gt; arrayClass) {
 618         Class&lt;?&gt; componentType = arrayClass.getComponentType();
 619         assert componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass);
 620         // should cache these VarHandle for performance
 621         return VarHandles.makeArrayElementHandle(arrayClass);
 622     }
 623 #end[Reference]
 624 
 625     static final class Array extends VarHandle {
 626         final int abase;
</pre>
<hr />
<pre>
 663             if (handle.arrayType == oarray.getClass()) {
 664                 // Fast path: static array type same as argument array type
 665                 return handle.componentType.cast(value);
 666             } else {
 667                 // Slow path: check value against argument array component type
 668                 return reflectiveTypeCheck(oarray, value);
 669             }
 670         }
 671 
 672         @ForceInline
 673         static Object reflectiveTypeCheck(Object[] oarray, Object value) {
 674             try {
 675                 return oarray.getClass().getComponentType().cast(value);
 676             } catch (ClassCastException e) {
 677                 throw new ArrayStoreException();
 678             }
 679         }
 680 #end[Object]
 681 
 682         @ForceInline
<span class="line-modified"> 683         static $type$ get(Array handle, Object oarray, int index) {</span>

 684 #if[Object]
 685             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 686 #else[Object]
 687             $type$[] array = ($type$[]) oarray;
 688 #end[Object]
 689             return array[index];
 690         }
 691 
 692         @ForceInline
<span class="line-modified"> 693         static void set(Array handle, Object oarray, int index, $type$ value) {</span>

 694 #if[Object]
 695             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 696 #else[Object]
 697             $type$[] array = ($type$[]) oarray;
 698 #end[Object]
 699 #if[Reference]
 700             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 701                 // for flattened array, delegate to VarHandle of the inline type array
 702                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 703                 vh.set(oarray, index, reflectiveTypeCheck(array, value));
 704                 return;
 705             }
 706 #end[Reference]
 707             array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};
 708         }
 709 
 710         @ForceInline
<span class="line-modified"> 711         static $type$ getVolatile(Array handle, Object oarray, int index) {</span>

 712 #if[Object]
 713             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 714 #else[Object]
 715             $type$[] array = ($type$[]) oarray;
 716 #end[Object]
 717 #if[Reference]
 718             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 719                 // for flattened array, delegate to VarHandle of the inline type array
 720                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 721                 return vh.getVolatile(oarray, index);
 722             }
 723 #end[Reference]
 724             return UNSAFE.get$Type$Volatile(array,
 725                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 726         }
 727 
 728         @ForceInline
<span class="line-modified"> 729         static void setVolatile(Array handle, Object oarray, int index, $type$ value) {</span>

 730 #if[Object]
 731             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 732 #else[Object]
 733             $type$[] array = ($type$[]) oarray;
 734 #end[Object]
 735 #if[Reference]
 736             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 737                 // for flattened array, delegate to VarHandle of the inline type array
 738                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 739                 vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));
 740                 return;
 741             }
 742 #end[Reference]
 743             UNSAFE.put$Type$Volatile(array,
 744                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 745                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 746         }
 747 
 748         @ForceInline
<span class="line-modified"> 749         static $type$ getOpaque(Array handle, Object oarray, int index) {</span>

 750 #if[Object]
 751             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 752 #else[Object]
 753             $type$[] array = ($type$[]) oarray;
 754 #end[Object]
 755 #if[Reference]
 756             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 757                 // for flattened array, delegate to VarHandle of the inline type array
 758                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 759                 return vh.getOpaque(oarray, index);
 760             }
 761 #end[Reference]
 762             return UNSAFE.get$Type$Opaque(array,
 763                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 764         }
 765 
 766         @ForceInline
<span class="line-modified"> 767         static void setOpaque(Array handle, Object oarray, int index, $type$ value) {</span>

 768 #if[Object]
 769             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 770 #else[Object]
 771             $type$[] array = ($type$[]) oarray;
 772 #end[Object]
 773 #if[Reference]
 774             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 775                 // for flattened array, delegate to VarHandle of the inline type array
 776                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 777                 vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));
 778                 return;
 779             }
 780 #end[Reference]
 781             UNSAFE.put$Type$Opaque(array,
 782                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 783                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 784         }
 785 
 786         @ForceInline
<span class="line-modified"> 787         static $type$ getAcquire(Array handle, Object oarray, int index) {</span>

 788 #if[Object]
 789             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 790 #else[Object]
 791             $type$[] array = ($type$[]) oarray;
 792 #end[Object]
 793 #if[Reference]
 794             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 795                 // for flattened array, delegate to VarHandle of the inline type array
 796                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 797                 return vh.getAcquire(oarray, index);
 798             }
 799 #end[Reference]
 800             return UNSAFE.get$Type$Acquire(array,
 801                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 802         }
 803 
 804         @ForceInline
<span class="line-modified"> 805         static void setRelease(Array handle, Object oarray, int index, $type$ value) {</span>

 806 #if[Object]
 807             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 808 #else[Object]
 809             $type$[] array = ($type$[]) oarray;
 810 #end[Object]
 811 #if[Reference]
 812             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 813                 // for flattened array, delegate to VarHandle of the inline type array
 814                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 815                 vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));
 816                 return;
 817             }
 818 #end[Reference]
 819             UNSAFE.put$Type$Release(array,
 820                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 821                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 822         }
 823 #if[CAS]
 824 
 825         @ForceInline
<span class="line-modified"> 826         static boolean compareAndSet(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 827 #if[Object]
 828             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 829 #else[Object]
 830             $type$[] array = ($type$[]) oarray;
 831 #end[Object]
 832 #if[Reference]
 833             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 834                 // for flattened array, delegate to VarHandle of the inline type array
 835                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 836                 return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 837             }
 838 #end[Reference]
 839             return UNSAFE.compareAndSet$Type$(array,
 840                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 841                     {#if[Object]?handle.componentType.cast(expected):expected},
 842                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 843         }
 844 
 845         @ForceInline
<span class="line-modified"> 846         static $type$ compareAndExchange(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 847 #if[Object]
 848             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 849 #else[Object]
 850             $type$[] array = ($type$[]) oarray;
 851 #end[Object]
 852 #if[Reference]
 853             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 854                 // for flattened array, delegate to VarHandle of the inline type array
 855                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 856                 return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));
 857             }
 858 #end[Reference]
 859             return UNSAFE.compareAndExchange$Type$(array,
 860                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 861                     {#if[Object]?handle.componentType.cast(expected):expected},
 862                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 863         }
 864 
 865         @ForceInline
<span class="line-modified"> 866         static $type$ compareAndExchangeAcquire(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 867 #if[Object]
 868             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 869 #else[Object]
 870             $type$[] array = ($type$[]) oarray;
 871 #end[Object]
 872 #if[Reference]
 873             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 874                 // for flattened array, delegate to VarHandle of the inline type array
 875                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 876                 return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 877             }
 878 #end[Reference]
 879             return UNSAFE.compareAndExchange$Type$Acquire(array,
 880                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 881                     {#if[Object]?handle.componentType.cast(expected):expected},
 882                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 883         }
 884 
 885         @ForceInline
<span class="line-modified"> 886         static $type$ compareAndExchangeRelease(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 887 #if[Object]
 888             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 889 #else[Object]
 890             $type$[] array = ($type$[]) oarray;
 891 #end[Object]
 892 #if[Reference]
 893             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 894                 // for flattened array, delegate to VarHandle of the inline type array
 895                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 896                 return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 897             }
 898 #end[Reference]
 899             return UNSAFE.compareAndExchange$Type$Release(array,
 900                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 901                     {#if[Object]?handle.componentType.cast(expected):expected},
 902                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 903         }
 904 
 905         @ForceInline
<span class="line-modified"> 906         static boolean weakCompareAndSetPlain(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 907 #if[Object]
 908             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 909 #else[Object]
 910             $type$[] array = ($type$[]) oarray;
 911 #end[Object]
 912 #if[Reference]
 913             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 914                 // for flattened array, delegate to VarHandle of the inline type array
 915                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 916                 return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));
 917             }
 918 #end[Reference]
 919             return UNSAFE.weakCompareAndSet$Type$Plain(array,
 920                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 921                     {#if[Object]?handle.componentType.cast(expected):expected},
 922                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 923         }
 924 
 925         @ForceInline
<span class="line-modified"> 926         static boolean weakCompareAndSet(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 927 #if[Object]
 928             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 929 #else[Object]
 930             $type$[] array = ($type$[]) oarray;
 931 #end[Object]
 932 #if[Reference]
 933             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 934                 // for flattened array, delegate to VarHandle of the inline type array
 935                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 936                 return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 937             }
 938 #end[Reference]
 939             return UNSAFE.weakCompareAndSet$Type$(array,
 940                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 941                     {#if[Object]?handle.componentType.cast(expected):expected},
 942                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 943         }
 944 
 945         @ForceInline
<span class="line-modified"> 946         static boolean weakCompareAndSetAcquire(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 947 #if[Object]
 948             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 949 #else[Object]
 950             $type$[] array = ($type$[]) oarray;
 951 #end[Object]
 952 #if[Reference]
 953             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 954                 // for flattened array, delegate to VarHandle of the inline type array
 955                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 956                 return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 957             }
 958 #end[Reference]
 959             return UNSAFE.weakCompareAndSet$Type$Acquire(array,
 960                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 961                     {#if[Object]?handle.componentType.cast(expected):expected},
 962                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 963         }
 964 
 965         @ForceInline
<span class="line-modified"> 966         static boolean weakCompareAndSetRelease(Array handle, Object oarray, int index, $type$ expected, $type$ value) {</span>

 967 #if[Object]
 968             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 969 #else[Object]
 970             $type$[] array = ($type$[]) oarray;
 971 #end[Object]
 972 #if[Reference]
 973             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 974                 // for flattened array, delegate to VarHandle of the inline type array
 975                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 976                 return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 977             }
 978 #end[Reference]
 979             return UNSAFE.weakCompareAndSet$Type$Release(array,
 980                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 981                     {#if[Object]?handle.componentType.cast(expected):expected},
 982                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 983         }
 984 
 985         @ForceInline
<span class="line-modified"> 986         static $type$ getAndSet(Array handle, Object oarray, int index, $type$ value) {</span>

 987 #if[Object]
 988             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 989 #else[Object]
 990             $type$[] array = ($type$[]) oarray;
 991 #end[Object]
 992 #if[Reference]
 993             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 994                 // for flattened array, delegate to VarHandle of the inline type array
 995                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 996                 return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));
 997             }
 998 #end[Reference]
 999             return UNSAFE.getAndSet$Type$(array,
1000                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1001                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1002         }
1003 
1004         @ForceInline
<span class="line-modified">1005         static $type$ getAndSetAcquire(Array handle, Object oarray, int index, $type$ value) {</span>

1006 #if[Object]
1007             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1008 #else[Object]
1009             $type$[] array = ($type$[]) oarray;
1010 #end[Object]
1011 #if[Reference]
1012             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1013                 // for flattened array, delegate to VarHandle of the inline type array
1014                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1015                 return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));
1016             }
1017 #end[Reference]
1018             return UNSAFE.getAndSet$Type$Acquire(array,
1019                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1020                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1021         }
1022 
1023         @ForceInline
<span class="line-modified">1024         static $type$ getAndSetRelease(Array handle, Object oarray, int index, $type$ value) {</span>

1025 #if[Object]
1026             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1027 #else[Object]
1028             $type$[] array = ($type$[]) oarray;
1029 #end[Object]
1030 #if[Reference]
1031             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1032                 // for flattened array, delegate to VarHandle of the inline type array
1033                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1034                 return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));
1035             }
1036 #end[Reference]
1037             return UNSAFE.getAndSet$Type$Release(array,
1038                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1039                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1040         }
1041 #end[CAS]
1042 #if[AtomicAdd]
1043 
1044         @ForceInline
<span class="line-modified">1045         static $type$ getAndAdd(Array handle, Object oarray, int index, $type$ value) {</span>

1046             $type$[] array = ($type$[]) oarray;
1047             return UNSAFE.getAndAdd$Type$(array,
1048                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1049                     value);
1050         }
1051 
1052         @ForceInline
<span class="line-modified">1053         static $type$ getAndAddAcquire(Array handle, Object oarray, int index, $type$ value) {</span>

1054             $type$[] array = ($type$[]) oarray;
1055             return UNSAFE.getAndAdd$Type$Acquire(array,
1056                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1057                     value);
1058         }
1059 
1060         @ForceInline
<span class="line-modified">1061         static $type$ getAndAddRelease(Array handle, Object oarray, int index, $type$ value) {</span>

1062             $type$[] array = ($type$[]) oarray;
1063             return UNSAFE.getAndAdd$Type$Release(array,
1064                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1065                     value);
1066         }
1067 #end[AtomicAdd]
1068 #if[Bitwise]
1069 
1070         @ForceInline
<span class="line-modified">1071         static $type$ getAndBitwiseOr(Array handle, Object oarray, int index, $type$ value) {</span>

1072             $type$[] array = ($type$[]) oarray;
1073             return UNSAFE.getAndBitwiseOr$Type$(array,
1074                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1075                                        value);
1076         }
1077 
1078         @ForceInline
<span class="line-modified">1079         static $type$ getAndBitwiseOrRelease(Array handle, Object oarray, int index, $type$ value) {</span>

1080             $type$[] array = ($type$[]) oarray;
1081             return UNSAFE.getAndBitwiseOr$Type$Release(array,
1082                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1083                                        value);
1084         }
1085 
1086         @ForceInline
<span class="line-modified">1087         static $type$ getAndBitwiseOrAcquire(Array handle, Object oarray, int index, $type$ value) {</span>

1088             $type$[] array = ($type$[]) oarray;
1089             return UNSAFE.getAndBitwiseOr$Type$Acquire(array,
1090                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1091                                        value);
1092         }
1093 
1094         @ForceInline
<span class="line-modified">1095         static $type$ getAndBitwiseAnd(Array handle, Object oarray, int index, $type$ value) {</span>

1096             $type$[] array = ($type$[]) oarray;
1097             return UNSAFE.getAndBitwiseAnd$Type$(array,
1098                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1099                                        value);
1100         }
1101 
1102         @ForceInline
<span class="line-modified">1103         static $type$ getAndBitwiseAndRelease(Array handle, Object oarray, int index, $type$ value) {</span>

1104             $type$[] array = ($type$[]) oarray;
1105             return UNSAFE.getAndBitwiseAnd$Type$Release(array,
1106                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1107                                        value);
1108         }
1109 
1110         @ForceInline
<span class="line-modified">1111         static $type$ getAndBitwiseAndAcquire(Array handle, Object oarray, int index, $type$ value) {</span>

1112             $type$[] array = ($type$[]) oarray;
1113             return UNSAFE.getAndBitwiseAnd$Type$Acquire(array,
1114                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1115                                        value);
1116         }
1117 
1118         @ForceInline
<span class="line-modified">1119         static $type$ getAndBitwiseXor(Array handle, Object oarray, int index, $type$ value) {</span>

1120             $type$[] array = ($type$[]) oarray;
1121             return UNSAFE.getAndBitwiseXor$Type$(array,
1122                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1123                                        value);
1124         }
1125 
1126         @ForceInline
<span class="line-modified">1127         static $type$ getAndBitwiseXorRelease(Array handle, Object oarray, int index, $type$ value) {</span>

1128             $type$[] array = ($type$[]) oarray;
1129             return UNSAFE.getAndBitwiseXor$Type$Release(array,
1130                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1131                                        value);
1132         }
1133 
1134         @ForceInline
<span class="line-modified">1135         static $type$ getAndBitwiseXorAcquire(Array handle, Object oarray, int index, $type$ value) {</span>

1136             $type$[] array = ($type$[]) oarray;
1137             return UNSAFE.getAndBitwiseXor$Type$Acquire(array,
1138                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1139                                        value);
1140         }
1141 #end[Bitwise]
1142 
1143         static final VarForm FORM = new VarForm(Array.class, {#if[Object]?Object[].class:$type$[].class}, {#if[Object]?Object.class:$type$.class}, int.class);
1144     }
1145 }
</pre>
</td>
<td>
<hr />
<pre>
  60 
  61         @Override
  62         final MethodType accessModeTypeUncached(AccessMode accessMode) {
  63             return accessMode.at.accessModeType(receiverType, {#if[Object]?fieldType:$type$.class});
  64         }
  65 
  66         @Override
  67         public Optional&lt;VarHandleDesc&gt; describeConstable() {
  68             var receiverTypeRef = receiverType.describeConstable();
  69             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
  70             if (!receiverTypeRef.isPresent() || !fieldTypeRef.isPresent())
  71                 return Optional.empty();
  72 
  73             // Reflect on this VarHandle to extract the field name
  74             String name = VarHandles.getFieldFromReceiverAndOffset(
  75                 receiverType, fieldOffset, {#if[Object]?fieldType:$type$.class}).getName();
  76             return Optional.of(VarHandleDesc.ofField(receiverTypeRef.get(), name, fieldTypeRef.get()));
  77         }
  78 
  79         @ForceInline
<span class="line-modified">  80         static $type$ get(VarHandle ob, Object holder) {</span>
<span class="line-added">  81             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;</span>
  82             return UNSAFE.get$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
  83                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  84         }
  85 
  86         @ForceInline
<span class="line-modified">  87         static $type$ getVolatile(VarHandle ob, Object holder) {</span>
<span class="line-added">  88             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;</span>
  89             return UNSAFE.get$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
  90                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  91         }
  92 
  93         @ForceInline
<span class="line-modified">  94         static $type$ getOpaque(VarHandle ob, Object holder) {</span>
<span class="line-added">  95             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;</span>
  96             return UNSAFE.get$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
  97                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
  98         }
  99 
 100         @ForceInline
<span class="line-modified"> 101         static $type$ getAcquire(VarHandle ob, Object holder) {</span>
<span class="line-added"> 102             FieldInstanceReadOnly handle = (FieldInstanceReadOnly)ob;</span>
 103             return UNSAFE.get$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 104                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 105         }
 106 
 107         static final VarForm FORM = new VarForm(FieldInstanceReadOnly.class, Object.class, $type$.class);
 108     }
 109 
 110     static final class FieldInstanceReadWrite extends FieldInstanceReadOnly {
 111         FieldInstanceReadWrite(Class&lt;?&gt; receiverType, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 112             super(receiverType, fieldOffset{#if[Object]?, fieldType}, FieldInstanceReadWrite.FORM);
 113         }
 114 
 115 #if[Object]
 116         @ForceInline
 117         static Object checkCast(FieldInstanceReadWrite handle, $type$ value) {
 118             if (handle.fieldType.isInlineClass())
 119                 Objects.requireNonNull(value);
 120             return handle.fieldType.cast(value);
 121         }
 122 #end[Object]
 123 
 124         @ForceInline
<span class="line-modified"> 125         static void set(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 126             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 127             UNSAFE.put$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 128                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 129                              {#if[Object]?checkCast(handle, value):value});
 130         }
 131 
 132         @ForceInline
<span class="line-modified"> 133         static void setVolatile(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 134             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 135             UNSAFE.put$Type$Volatile(Objects.requireNonNull(handle.receiverType.cast(holder)),
 136                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 137                                      {#if[Object]?checkCast(handle, value):value});
 138         }
 139 
 140         @ForceInline
<span class="line-modified"> 141         static void setOpaque(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 142             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 143             UNSAFE.put$Type$Opaque(Objects.requireNonNull(handle.receiverType.cast(holder)),
 144                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 145                                    {#if[Object]?checkCast(handle, value):value});
 146         }
 147 
 148         @ForceInline
<span class="line-modified"> 149         static void setRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 150             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 151             UNSAFE.put$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 152                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 153                                     {#if[Object]?checkCast(handle, value):value});
 154         }
 155 #if[CAS]
 156 
 157         @ForceInline
<span class="line-modified"> 158         static boolean compareAndSet(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 159             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 160             return UNSAFE.compareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 161                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 162                                                {#if[Object]?checkCast(handle, expected):expected},
 163                                                {#if[Object]?checkCast(handle, value):value});
 164         }
 165 
 166         @ForceInline
<span class="line-modified"> 167         static $type$ compareAndExchange(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 168             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 169             return UNSAFE.compareAndExchange$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 170                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 171                                                {#if[Object]?checkCast(handle, expected):expected},
 172                                                {#if[Object]?checkCast(handle, value):value});
 173         }
 174 
 175         @ForceInline
<span class="line-modified"> 176         static $type$ compareAndExchangeAcquire(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 177             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 178             return UNSAFE.compareAndExchange$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 179                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 180                                                {#if[Object]?checkCast(handle, expected):expected},
 181                                                {#if[Object]?checkCast(handle, value):value});
 182         }
 183 
 184         @ForceInline
<span class="line-modified"> 185         static $type$ compareAndExchangeRelease(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 186             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 187             return UNSAFE.compareAndExchange$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 188                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 189                                                {#if[Object]?checkCast(handle, expected):expected},
 190                                                {#if[Object]?checkCast(handle, value):value});
 191         }
 192 
 193         @ForceInline
<span class="line-modified"> 194         static boolean weakCompareAndSetPlain(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 195             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 196             return UNSAFE.weakCompareAndSet$Type$Plain(Objects.requireNonNull(handle.receiverType.cast(holder)),
 197                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 198                                                {#if[Object]?checkCast(handle, expected):expected},
 199                                                {#if[Object]?checkCast(handle, value):value});
 200         }
 201 
 202         @ForceInline
<span class="line-modified"> 203         static boolean weakCompareAndSet(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 204             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 205             return UNSAFE.weakCompareAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 206                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 207                                                {#if[Object]?checkCast(handle, expected):expected},
 208                                                {#if[Object]?checkCast(handle, value):value});
 209         }
 210 
 211         @ForceInline
<span class="line-modified"> 212         static boolean weakCompareAndSetAcquire(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 213             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 214             return UNSAFE.weakCompareAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 215                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 216                                                {#if[Object]?checkCast(handle, expected):expected},
 217                                                {#if[Object]?checkCast(handle, value):value});
 218         }
 219 
 220         @ForceInline
<span class="line-modified"> 221         static boolean weakCompareAndSetRelease(VarHandle ob, Object holder, $type$ expected, $type$ value) {</span>
<span class="line-added"> 222             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 223             return UNSAFE.weakCompareAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 224                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 225                                                {#if[Object]?checkCast(handle, expected):expected},
 226                                                {#if[Object]?checkCast(handle, value):value});
 227         }
 228 
 229         @ForceInline
<span class="line-modified"> 230         static $type$ getAndSet(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 231             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 232             return UNSAFE.getAndSet$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 233                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 234                                           {#if[Object]?checkCast(handle, value):value});
 235         }
 236 
 237         @ForceInline
<span class="line-modified"> 238         static $type$ getAndSetAcquire(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 239             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 240             return UNSAFE.getAndSet$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 241                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 242                                           {#if[Object]?checkCast(handle, value):value});
 243         }
 244 
 245         @ForceInline
<span class="line-modified"> 246         static $type$ getAndSetRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 247             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 248             return UNSAFE.getAndSet$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 249                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 250                                           {#if[Object]?checkCast(handle, value):value});
 251         }
 252 #end[CAS]
 253 #if[AtomicAdd]
 254 
 255         @ForceInline
<span class="line-modified"> 256         static $type$ getAndAdd(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 257             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 258             return UNSAFE.getAndAdd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 259                                        handle.fieldOffset,
 260                                        value);
 261         }
 262 
 263         @ForceInline
<span class="line-modified"> 264         static $type$ getAndAddAcquire(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 265             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 266             return UNSAFE.getAndAdd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 267                                        handle.fieldOffset,
 268                                        value);
 269         }
 270 
 271         @ForceInline
<span class="line-modified"> 272         static $type$ getAndAddRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 273             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 274             return UNSAFE.getAndAdd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 275                                        handle.fieldOffset,
 276                                        value);
 277         }
 278 
 279 #end[AtomicAdd]
 280 #if[Bitwise]
 281 
 282         @ForceInline
<span class="line-modified"> 283         static $type$ getAndBitwiseOr(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 284             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 285             return UNSAFE.getAndBitwiseOr$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 286                                        handle.fieldOffset,
 287                                        value);
 288         }
 289 
 290         @ForceInline
<span class="line-modified"> 291         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 292             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 293             return UNSAFE.getAndBitwiseOr$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 294                                        handle.fieldOffset,
 295                                        value);
 296         }
 297 
 298         @ForceInline
<span class="line-modified"> 299         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 300             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 301             return UNSAFE.getAndBitwiseOr$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 302                                        handle.fieldOffset,
 303                                        value);
 304         }
 305 
 306         @ForceInline
<span class="line-modified"> 307         static $type$ getAndBitwiseAnd(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 308             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 309             return UNSAFE.getAndBitwiseAnd$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 310                                        handle.fieldOffset,
 311                                        value);
 312         }
 313 
 314         @ForceInline
<span class="line-modified"> 315         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 316             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 317             return UNSAFE.getAndBitwiseAnd$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 318                                        handle.fieldOffset,
 319                                        value);
 320         }
 321 
 322         @ForceInline
<span class="line-modified"> 323         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 324             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 325             return UNSAFE.getAndBitwiseAnd$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 326                                        handle.fieldOffset,
 327                                        value);
 328         }
 329 
 330         @ForceInline
<span class="line-modified"> 331         static $type$ getAndBitwiseXor(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 332             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 333             return UNSAFE.getAndBitwiseXor$Type$(Objects.requireNonNull(handle.receiverType.cast(holder)),
 334                                        handle.fieldOffset,
 335                                        value);
 336         }
 337 
 338         @ForceInline
<span class="line-modified"> 339         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 340             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 341             return UNSAFE.getAndBitwiseXor$Type$Release(Objects.requireNonNull(handle.receiverType.cast(holder)),
 342                                        handle.fieldOffset,
 343                                        value);
 344         }
 345 
 346         @ForceInline
<span class="line-modified"> 347         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object holder, $type$ value) {</span>
<span class="line-added"> 348             FieldInstanceReadWrite handle = (FieldInstanceReadWrite)ob;</span>
 349             return UNSAFE.getAndBitwiseXor$Type$Acquire(Objects.requireNonNull(handle.receiverType.cast(holder)),
 350                                        handle.fieldOffset,
 351                                        value);
 352         }
 353 #end[Bitwise]
 354 
 355         static final VarForm FORM = new VarForm(FieldInstanceReadWrite.class, Object.class, $type$.class);
 356     }
 357 
 358 
 359     static class FieldStaticReadOnly extends VarHandle {
 360         final Object base;
 361         final long fieldOffset;
 362 #if[Object]
 363         final Class&lt;?&gt; fieldType;
 364 #end[Object]
 365 
 366         FieldStaticReadOnly(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 367             this(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadOnly.FORM);
 368         }
</pre>
<hr />
<pre>
 381         public Optional&lt;VarHandleDesc&gt; describeConstable() {
 382             var fieldTypeRef = {#if[Object]?fieldType:$type$.class}.describeConstable();
 383             if (!fieldTypeRef.isPresent())
 384                 return Optional.empty();
 385 
 386             // Reflect on this VarHandle to extract the field name
 387             var staticField = VarHandles.getStaticFieldFromBaseAndOffset(
 388                 base, fieldOffset, {#if[Object]?fieldType:$type$.class});
 389             var receiverTypeRef = staticField.getDeclaringClass().describeConstable();
 390             if (!receiverTypeRef.isPresent())
 391                 return Optional.empty();
 392             return Optional.of(VarHandleDesc.ofStaticField(receiverTypeRef.get(), staticField.getName(), fieldTypeRef.get()));
 393         }
 394 
 395         @Override
 396         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 397             return accessMode.at.accessModeType(null, {#if[Object]?fieldType:$type$.class});
 398         }
 399 
 400         @ForceInline
<span class="line-modified"> 401         static $type$ get(VarHandle ob) {</span>
<span class="line-added"> 402             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;</span>
 403             return UNSAFE.get$Type$(handle.base,
 404                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 405         }
 406 
 407         @ForceInline
<span class="line-modified"> 408         static $type$ getVolatile(VarHandle ob) {</span>
<span class="line-added"> 409             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;</span>
 410             return UNSAFE.get$Type$Volatile(handle.base,
 411                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 412         }
 413 
 414         @ForceInline
<span class="line-modified"> 415         static $type$ getOpaque(VarHandle ob) {</span>
<span class="line-added"> 416             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;</span>
 417             return UNSAFE.get$Type$Opaque(handle.base,
 418                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 419         }
 420 
 421         @ForceInline
<span class="line-modified"> 422         static $type$ getAcquire(VarHandle ob) {</span>
<span class="line-added"> 423             FieldStaticReadOnly handle = (FieldStaticReadOnly)ob;</span>
 424             return UNSAFE.get$Type$Acquire(handle.base,
 425                                  handle.fieldOffset{#if[Value]?, handle.fieldType});
 426         }
 427 
 428         static final VarForm FORM = new VarForm(FieldStaticReadOnly.class, null, $type$.class);
 429     }
 430 
 431     static final class FieldStaticReadWrite extends FieldStaticReadOnly {
 432         FieldStaticReadWrite(Object base, long fieldOffset{#if[Object]?, Class&lt;?&gt; fieldType}) {
 433             super(base, fieldOffset{#if[Object]?, fieldType}, FieldStaticReadWrite.FORM);
 434         }
 435 
 436 #if[Object]
 437         static Object checkCast(FieldStaticReadWrite handle, $type$ value) {
 438             if (handle.fieldType.isInlineClass())
 439                 Objects.requireNonNull(value);
 440             return handle.fieldType.cast(value);
 441         }
 442 #end[Object]
 443 
 444         @ForceInline
<span class="line-modified"> 445         static void set(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 446             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 447             UNSAFE.put$Type$(handle.base,
 448                              handle.fieldOffset{#if[Value]?, handle.fieldType},
 449                              {#if[Object]?checkCast(handle, value):value});
 450         }
 451 
 452         @ForceInline
<span class="line-modified"> 453         static void setVolatile(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 454             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 455             UNSAFE.put$Type$Volatile(handle.base,
 456                                      handle.fieldOffset{#if[Value]?, handle.fieldType},
 457                                      {#if[Object]?checkCast(handle, value):value});
 458         }
 459 
 460         @ForceInline
<span class="line-modified"> 461         static void setOpaque(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 462             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 463             UNSAFE.put$Type$Opaque(handle.base,
 464                                    handle.fieldOffset{#if[Value]?, handle.fieldType},
 465                                    {#if[Object]?checkCast(handle, value):value});
 466         }
 467 
 468         @ForceInline
<span class="line-modified"> 469         static void setRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 470             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 471             UNSAFE.put$Type$Release(handle.base,
 472                                     handle.fieldOffset{#if[Value]?, handle.fieldType},
 473                                     {#if[Object]?checkCast(handle, value):value});
 474         }
 475 #if[CAS]
 476 
 477         @ForceInline
<span class="line-modified"> 478         static boolean compareAndSet(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 479             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 480             return UNSAFE.compareAndSet$Type$(handle.base,
 481                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 482                                                {#if[Object]?checkCast(handle, expected):expected},
 483                                                {#if[Object]?checkCast(handle, value):value});
 484         }
 485 
 486 
 487         @ForceInline
<span class="line-modified"> 488         static $type$ compareAndExchange(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 489             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 490             return UNSAFE.compareAndExchange$Type$(handle.base,
 491                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 492                                                {#if[Object]?checkCast(handle, expected):expected},
 493                                                {#if[Object]?checkCast(handle, value):value});
 494         }
 495 
 496         @ForceInline
<span class="line-modified"> 497         static $type$ compareAndExchangeAcquire(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 498             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 499             return UNSAFE.compareAndExchange$Type$Acquire(handle.base,
 500                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 501                                                {#if[Object]?checkCast(handle, expected):expected},
 502                                                {#if[Object]?checkCast(handle, value):value});
 503         }
 504 
 505         @ForceInline
<span class="line-modified"> 506         static $type$ compareAndExchangeRelease(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 507             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 508             return UNSAFE.compareAndExchange$Type$Release(handle.base,
 509                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 510                                                {#if[Object]?checkCast(handle, expected):expected},
 511                                                {#if[Object]?checkCast(handle, value):value});
 512         }
 513 
 514         @ForceInline
<span class="line-modified"> 515         static boolean weakCompareAndSetPlain(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 516             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 517             return UNSAFE.weakCompareAndSet$Type$Plain(handle.base,
 518                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 519                                                {#if[Object]?checkCast(handle, expected):expected},
 520                                                {#if[Object]?checkCast(handle, value):value});
 521         }
 522 
 523         @ForceInline
<span class="line-modified"> 524         static boolean weakCompareAndSet(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 525             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 526             return UNSAFE.weakCompareAndSet$Type$(handle.base,
 527                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 528                                                {#if[Object]?checkCast(handle, expected):expected},
 529                                                {#if[Object]?checkCast(handle, value):value});
 530         }
 531 
 532         @ForceInline
<span class="line-modified"> 533         static boolean weakCompareAndSetAcquire(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 534             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 535             return UNSAFE.weakCompareAndSet$Type$Acquire(handle.base,
 536                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 537                                                {#if[Object]?checkCast(handle, expected):expected},
 538                                                {#if[Object]?checkCast(handle, value):value});
 539         }
 540 
 541         @ForceInline
<span class="line-modified"> 542         static boolean weakCompareAndSetRelease(VarHandle ob, $type$ expected, $type$ value) {</span>
<span class="line-added"> 543             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 544             return UNSAFE.weakCompareAndSet$Type$Release(handle.base,
 545                                                handle.fieldOffset{#if[Object]?, handle.fieldType},
 546                                                {#if[Object]?checkCast(handle, expected):expected},
 547                                                {#if[Object]?checkCast(handle, value):value});
 548         }
 549 
 550         @ForceInline
<span class="line-modified"> 551         static $type$ getAndSet(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 552             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 553             return UNSAFE.getAndSet$Type$(handle.base,
 554                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 555                                           {#if[Object]?checkCast(handle, value):value});
 556         }
 557 
 558         @ForceInline
<span class="line-modified"> 559         static $type$ getAndSetAcquire(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 560             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 561             return UNSAFE.getAndSet$Type$Acquire(handle.base,
 562                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 563                                           {#if[Object]?checkCast(handle, value):value});
 564         }
 565 
 566         @ForceInline
<span class="line-modified"> 567         static $type$ getAndSetRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 568             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 569             return UNSAFE.getAndSet$Type$Release(handle.base,
 570                                           handle.fieldOffset{#if[Value]?, handle.fieldType},
 571                                           {#if[Object]?checkCast(handle, value):value});
 572         }
 573 #end[CAS]
 574 #if[AtomicAdd]
 575 
 576         @ForceInline
<span class="line-modified"> 577         static $type$ getAndAdd(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 578             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 579             return UNSAFE.getAndAdd$Type$(handle.base,
 580                                        handle.fieldOffset,
 581                                        value);
 582         }
 583 
 584         @ForceInline
<span class="line-modified"> 585         static $type$ getAndAddAcquire(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 586             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 587             return UNSAFE.getAndAdd$Type$Acquire(handle.base,
 588                                        handle.fieldOffset,
 589                                        value);
 590         }
 591 
 592         @ForceInline
<span class="line-modified"> 593         static $type$ getAndAddRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 594             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 595             return UNSAFE.getAndAdd$Type$Release(handle.base,
 596                                        handle.fieldOffset,
 597                                        value);
 598         }
 599 #end[AtomicAdd]
 600 #if[Bitwise]
 601 
 602         @ForceInline
<span class="line-modified"> 603         static $type$ getAndBitwiseOr(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 604             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 605             return UNSAFE.getAndBitwiseOr$Type$(handle.base,
 606                                        handle.fieldOffset,
 607                                        value);
 608         }
 609 
 610         @ForceInline
<span class="line-modified"> 611         static $type$ getAndBitwiseOrRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 612             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 613             return UNSAFE.getAndBitwiseOr$Type$Release(handle.base,
 614                                        handle.fieldOffset,
 615                                        value);
 616         }
 617 
 618         @ForceInline
<span class="line-modified"> 619         static $type$ getAndBitwiseOrAcquire(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 620             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 621             return UNSAFE.getAndBitwiseOr$Type$Acquire(handle.base,
 622                                        handle.fieldOffset,
 623                                        value);
 624         }
 625 
 626         @ForceInline
<span class="line-modified"> 627         static $type$ getAndBitwiseAnd(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 628             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 629             return UNSAFE.getAndBitwiseAnd$Type$(handle.base,
 630                                        handle.fieldOffset,
 631                                        value);
 632         }
 633 
 634         @ForceInline
<span class="line-modified"> 635         static $type$ getAndBitwiseAndRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 636             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 637             return UNSAFE.getAndBitwiseAnd$Type$Release(handle.base,
 638                                        handle.fieldOffset,
 639                                        value);
 640         }
 641 
 642         @ForceInline
<span class="line-modified"> 643         static $type$ getAndBitwiseAndAcquire(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 644             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 645             return UNSAFE.getAndBitwiseAnd$Type$Acquire(handle.base,
 646                                        handle.fieldOffset,
 647                                        value);
 648         }
 649 
 650         @ForceInline
<span class="line-modified"> 651         static $type$ getAndBitwiseXor(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 652             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 653             return UNSAFE.getAndBitwiseXor$Type$(handle.base,
 654                                        handle.fieldOffset,
 655                                        value);
 656         }
 657 
 658         @ForceInline
<span class="line-modified"> 659         static $type$ getAndBitwiseXorRelease(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 660             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 661             return UNSAFE.getAndBitwiseXor$Type$Release(handle.base,
 662                                        handle.fieldOffset,
 663                                        value);
 664         }
 665 
 666         @ForceInline
<span class="line-modified"> 667         static $type$ getAndBitwiseXorAcquire(VarHandle ob, $type$ value) {</span>
<span class="line-added"> 668             FieldStaticReadWrite handle = (FieldStaticReadWrite)ob;</span>
 669             return UNSAFE.getAndBitwiseXor$Type$Acquire(handle.base,
 670                                        handle.fieldOffset,
 671                                        value);
 672         }
 673 #end[Bitwise]
 674 
 675         static final VarForm FORM = new VarForm(FieldStaticReadWrite.class, null, $type$.class);
 676     }
 677 
 678 #if[Reference]
 679     static VarHandle makeVarHandleValuesArray(Class&lt;?&gt; arrayClass) {
 680         Class&lt;?&gt; componentType = arrayClass.getComponentType();
 681         assert componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass);
 682         // should cache these VarHandle for performance
 683         return VarHandles.makeArrayElementHandle(arrayClass);
 684     }
 685 #end[Reference]
 686 
 687     static final class Array extends VarHandle {
 688         final int abase;
</pre>
<hr />
<pre>
 725             if (handle.arrayType == oarray.getClass()) {
 726                 // Fast path: static array type same as argument array type
 727                 return handle.componentType.cast(value);
 728             } else {
 729                 // Slow path: check value against argument array component type
 730                 return reflectiveTypeCheck(oarray, value);
 731             }
 732         }
 733 
 734         @ForceInline
 735         static Object reflectiveTypeCheck(Object[] oarray, Object value) {
 736             try {
 737                 return oarray.getClass().getComponentType().cast(value);
 738             } catch (ClassCastException e) {
 739                 throw new ArrayStoreException();
 740             }
 741         }
 742 #end[Object]
 743 
 744         @ForceInline
<span class="line-modified"> 745         static $type$ get(VarHandle ob, Object oarray, int index) {</span>
<span class="line-added"> 746             Array handle = (Array)ob;</span>
 747 #if[Object]
 748             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 749 #else[Object]
 750             $type$[] array = ($type$[]) oarray;
 751 #end[Object]
 752             return array[index];
 753         }
 754 
 755         @ForceInline
<span class="line-modified"> 756         static void set(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added"> 757             Array handle = (Array)ob;</span>
 758 #if[Object]
 759             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 760 #else[Object]
 761             $type$[] array = ($type$[]) oarray;
 762 #end[Object]
 763 #if[Reference]
 764             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 765                 // for flattened array, delegate to VarHandle of the inline type array
 766                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 767                 vh.set(oarray, index, reflectiveTypeCheck(array, value));
 768                 return;
 769             }
 770 #end[Reference]
 771             array[index] = {#if[Object]?runtimeTypeCheck(handle, array, value):value};
 772         }
 773 
 774         @ForceInline
<span class="line-modified"> 775         static $type$ getVolatile(VarHandle ob, Object oarray, int index) {</span>
<span class="line-added"> 776             Array handle = (Array)ob;</span>
 777 #if[Object]
 778             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 779 #else[Object]
 780             $type$[] array = ($type$[]) oarray;
 781 #end[Object]
 782 #if[Reference]
 783             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 784                 // for flattened array, delegate to VarHandle of the inline type array
 785                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 786                 return vh.getVolatile(oarray, index);
 787             }
 788 #end[Reference]
 789             return UNSAFE.get$Type$Volatile(array,
 790                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 791         }
 792 
 793         @ForceInline
<span class="line-modified"> 794         static void setVolatile(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added"> 795             Array handle = (Array)ob;</span>
 796 #if[Object]
 797             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 798 #else[Object]
 799             $type$[] array = ($type$[]) oarray;
 800 #end[Object]
 801 #if[Reference]
 802             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 803                 // for flattened array, delegate to VarHandle of the inline type array
 804                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 805                 vh.setVolatile(oarray, index, reflectiveTypeCheck(array, value));
 806                 return;
 807             }
 808 #end[Reference]
 809             UNSAFE.put$Type$Volatile(array,
 810                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 811                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 812         }
 813 
 814         @ForceInline
<span class="line-modified"> 815         static $type$ getOpaque(VarHandle ob, Object oarray, int index) {</span>
<span class="line-added"> 816             Array handle = (Array)ob;</span>
 817 #if[Object]
 818             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 819 #else[Object]
 820             $type$[] array = ($type$[]) oarray;
 821 #end[Object]
 822 #if[Reference]
 823             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 824                 // for flattened array, delegate to VarHandle of the inline type array
 825                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 826                 return vh.getOpaque(oarray, index);
 827             }
 828 #end[Reference]
 829             return UNSAFE.get$Type$Opaque(array,
 830                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 831         }
 832 
 833         @ForceInline
<span class="line-modified"> 834         static void setOpaque(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added"> 835             Array handle = (Array)ob;</span>
 836 #if[Object]
 837             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 838 #else[Object]
 839             $type$[] array = ($type$[]) oarray;
 840 #end[Object]
 841 #if[Reference]
 842             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 843                 // for flattened array, delegate to VarHandle of the inline type array
 844                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 845                 vh.setOpaque(oarray, index, reflectiveTypeCheck(array, value));
 846                 return;
 847             }
 848 #end[Reference]
 849             UNSAFE.put$Type$Opaque(array,
 850                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 851                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 852         }
 853 
 854         @ForceInline
<span class="line-modified"> 855         static $type$ getAcquire(VarHandle ob, Object oarray, int index) {</span>
<span class="line-added"> 856             Array handle = (Array)ob;</span>
 857 #if[Object]
 858             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 859 #else[Object]
 860             $type$[] array = ($type$[]) oarray;
 861 #end[Object]
 862 #if[Reference]
 863             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 864                 // for flattened array, delegate to VarHandle of the inline type array
 865                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 866                 return vh.getAcquire(oarray, index);
 867             }
 868 #end[Reference]
 869             return UNSAFE.get$Type$Acquire(array,
 870                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType});
 871         }
 872 
 873         @ForceInline
<span class="line-modified"> 874         static void setRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added"> 875             Array handle = (Array)ob;</span>
 876 #if[Object]
 877             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 878 #else[Object]
 879             $type$[] array = ($type$[]) oarray;
 880 #end[Object]
 881 #if[Reference]
 882             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 883                 // for flattened array, delegate to VarHandle of the inline type array
 884                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 885                 vh.setRelease(oarray, index, reflectiveTypeCheck(array, value));
 886                 return;
 887             }
 888 #end[Reference]
 889             UNSAFE.put$Type$Release(array,
 890                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
 891                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 892         }
 893 #if[CAS]
 894 
 895         @ForceInline
<span class="line-modified"> 896         static boolean compareAndSet(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 897             Array handle = (Array)ob;</span>
 898 #if[Object]
 899             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 900 #else[Object]
 901             $type$[] array = ($type$[]) oarray;
 902 #end[Object]
 903 #if[Reference]
 904             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 905                 // for flattened array, delegate to VarHandle of the inline type array
 906                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 907                 return vh.compareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
 908             }
 909 #end[Reference]
 910             return UNSAFE.compareAndSet$Type$(array,
 911                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 912                     {#if[Object]?handle.componentType.cast(expected):expected},
 913                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 914         }
 915 
 916         @ForceInline
<span class="line-modified"> 917         static $type$ compareAndExchange(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 918             Array handle = (Array)ob;</span>
 919 #if[Object]
 920             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 921 #else[Object]
 922             $type$[] array = ($type$[]) oarray;
 923 #end[Object]
 924 #if[Reference]
 925             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 926                 // for flattened array, delegate to VarHandle of the inline type array
 927                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 928                 return vh.compareAndExchange(oarray, index, expected, reflectiveTypeCheck(array, value));
 929             }
 930 #end[Reference]
 931             return UNSAFE.compareAndExchange$Type$(array,
 932                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 933                     {#if[Object]?handle.componentType.cast(expected):expected},
 934                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 935         }
 936 
 937         @ForceInline
<span class="line-modified"> 938         static $type$ compareAndExchangeAcquire(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 939             Array handle = (Array)ob;</span>
 940 #if[Object]
 941             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 942 #else[Object]
 943             $type$[] array = ($type$[]) oarray;
 944 #end[Object]
 945 #if[Reference]
 946             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 947                 // for flattened array, delegate to VarHandle of the inline type array
 948                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 949                 return vh.compareAndExchangeAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
 950             }
 951 #end[Reference]
 952             return UNSAFE.compareAndExchange$Type$Acquire(array,
 953                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 954                     {#if[Object]?handle.componentType.cast(expected):expected},
 955                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 956         }
 957 
 958         @ForceInline
<span class="line-modified"> 959         static $type$ compareAndExchangeRelease(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 960             Array handle = (Array)ob;</span>
 961 #if[Object]
 962             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 963 #else[Object]
 964             $type$[] array = ($type$[]) oarray;
 965 #end[Object]
 966 #if[Reference]
 967             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 968                 // for flattened array, delegate to VarHandle of the inline type array
 969                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 970                 return vh.compareAndExchangeRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
 971             }
 972 #end[Reference]
 973             return UNSAFE.compareAndExchange$Type$Release(array,
 974                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 975                     {#if[Object]?handle.componentType.cast(expected):expected},
 976                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 977         }
 978 
 979         @ForceInline
<span class="line-modified"> 980         static boolean weakCompareAndSetPlain(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added"> 981             Array handle = (Array)ob;</span>
 982 #if[Object]
 983             Object[] array = (Object[]) handle.arrayType.cast(oarray);
 984 #else[Object]
 985             $type$[] array = ($type$[]) oarray;
 986 #end[Object]
 987 #if[Reference]
 988             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
 989                 // for flattened array, delegate to VarHandle of the inline type array
 990                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
 991                 return vh.weakCompareAndSetPlain(oarray, index, expected, reflectiveTypeCheck(array, value));
 992             }
 993 #end[Reference]
 994             return UNSAFE.weakCompareAndSet$Type$Plain(array,
 995                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
 996                     {#if[Object]?handle.componentType.cast(expected):expected},
 997                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
 998         }
 999 
1000         @ForceInline
<span class="line-modified">1001         static boolean weakCompareAndSet(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added">1002             Array handle = (Array)ob;</span>
1003 #if[Object]
1004             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1005 #else[Object]
1006             $type$[] array = ($type$[]) oarray;
1007 #end[Object]
1008 #if[Reference]
1009             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1010                 // for flattened array, delegate to VarHandle of the inline type array
1011                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1012                 return vh.weakCompareAndSet(oarray, index, expected, reflectiveTypeCheck(array, value));
1013             }
1014 #end[Reference]
1015             return UNSAFE.weakCompareAndSet$Type$(array,
1016                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1017                     {#if[Object]?handle.componentType.cast(expected):expected},
1018                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1019         }
1020 
1021         @ForceInline
<span class="line-modified">1022         static boolean weakCompareAndSetAcquire(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added">1023             Array handle = (Array)ob;</span>
1024 #if[Object]
1025             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1026 #else[Object]
1027             $type$[] array = ($type$[]) oarray;
1028 #end[Object]
1029 #if[Reference]
1030             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1031                 // for flattened array, delegate to VarHandle of the inline type array
1032                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1033                 return vh.weakCompareAndSetAcquire(oarray, index, expected, reflectiveTypeCheck(array, value));
1034             }
1035 #end[Reference]
1036             return UNSAFE.weakCompareAndSet$Type$Acquire(array,
1037                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1038                     {#if[Object]?handle.componentType.cast(expected):expected},
1039                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1040         }
1041 
1042         @ForceInline
<span class="line-modified">1043         static boolean weakCompareAndSetRelease(VarHandle ob, Object oarray, int index, $type$ expected, $type$ value) {</span>
<span class="line-added">1044             Array handle = (Array)ob;</span>
1045 #if[Object]
1046             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1047 #else[Object]
1048             $type$[] array = ($type$[]) oarray;
1049 #end[Object]
1050 #if[Reference]
1051             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1052                 // for flattened array, delegate to VarHandle of the inline type array
1053                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1054                 return vh.weakCompareAndSetRelease(oarray, index, expected, reflectiveTypeCheck(array, value));
1055             }
1056 #end[Reference]
1057             return UNSAFE.weakCompareAndSet$Type$Release(array,
1058                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Object]?, handle.componentType},
1059                     {#if[Object]?handle.componentType.cast(expected):expected},
1060                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1061         }
1062 
1063         @ForceInline
<span class="line-modified">1064         static $type$ getAndSet(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1065             Array handle = (Array)ob;</span>
1066 #if[Object]
1067             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1068 #else[Object]
1069             $type$[] array = ($type$[]) oarray;
1070 #end[Object]
1071 #if[Reference]
1072             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1073                 // for flattened array, delegate to VarHandle of the inline type array
1074                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1075                 return vh.getAndSet(oarray, index, reflectiveTypeCheck(array, value));
1076             }
1077 #end[Reference]
1078             return UNSAFE.getAndSet$Type$(array,
1079                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1080                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1081         }
1082 
1083         @ForceInline
<span class="line-modified">1084         static $type$ getAndSetAcquire(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1085             Array handle = (Array)ob;</span>
1086 #if[Object]
1087             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1088 #else[Object]
1089             $type$[] array = ($type$[]) oarray;
1090 #end[Object]
1091 #if[Reference]
1092             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1093                 // for flattened array, delegate to VarHandle of the inline type array
1094                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1095                 return vh.getAndSetAcquire(oarray, index, reflectiveTypeCheck(array, value));
1096             }
1097 #end[Reference]
1098             return UNSAFE.getAndSet$Type$Acquire(array,
1099                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1100                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1101         }
1102 
1103         @ForceInline
<span class="line-modified">1104         static $type$ getAndSetRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1105             Array handle = (Array)ob;</span>
1106 #if[Object]
1107             Object[] array = (Object[]) handle.arrayType.cast(oarray);
1108 #else[Object]
1109             $type$[] array = ($type$[]) oarray;
1110 #end[Object]
1111 #if[Reference]
1112             if (UNSAFE.isFlattenedArray(oarray.getClass())) {
1113                 // for flattened array, delegate to VarHandle of the inline type array
1114                 VarHandle vh = makeVarHandleValuesArray(oarray.getClass());
1115                 return vh.getAndSetRelease(oarray, index, reflectiveTypeCheck(array, value));
1116             }
1117 #end[Reference]
1118             return UNSAFE.getAndSet$Type$Release(array,
1119                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase{#if[Value]?, handle.componentType},
1120                     {#if[Object]?runtimeTypeCheck(handle, array, value):value});
1121         }
1122 #end[CAS]
1123 #if[AtomicAdd]
1124 
1125         @ForceInline
<span class="line-modified">1126         static $type$ getAndAdd(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1127             Array handle = (Array)ob;</span>
1128             $type$[] array = ($type$[]) oarray;
1129             return UNSAFE.getAndAdd$Type$(array,
1130                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1131                     value);
1132         }
1133 
1134         @ForceInline
<span class="line-modified">1135         static $type$ getAndAddAcquire(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1136             Array handle = (Array)ob;</span>
1137             $type$[] array = ($type$[]) oarray;
1138             return UNSAFE.getAndAdd$Type$Acquire(array,
1139                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1140                     value);
1141         }
1142 
1143         @ForceInline
<span class="line-modified">1144         static $type$ getAndAddRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1145             Array handle = (Array)ob;</span>
1146             $type$[] array = ($type$[]) oarray;
1147             return UNSAFE.getAndAdd$Type$Release(array,
1148                     (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1149                     value);
1150         }
1151 #end[AtomicAdd]
1152 #if[Bitwise]
1153 
1154         @ForceInline
<span class="line-modified">1155         static $type$ getAndBitwiseOr(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1156             Array handle = (Array)ob;</span>
1157             $type$[] array = ($type$[]) oarray;
1158             return UNSAFE.getAndBitwiseOr$Type$(array,
1159                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1160                                        value);
1161         }
1162 
1163         @ForceInline
<span class="line-modified">1164         static $type$ getAndBitwiseOrRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1165             Array handle = (Array)ob;</span>
1166             $type$[] array = ($type$[]) oarray;
1167             return UNSAFE.getAndBitwiseOr$Type$Release(array,
1168                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1169                                        value);
1170         }
1171 
1172         @ForceInline
<span class="line-modified">1173         static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1174             Array handle = (Array)ob;</span>
1175             $type$[] array = ($type$[]) oarray;
1176             return UNSAFE.getAndBitwiseOr$Type$Acquire(array,
1177                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1178                                        value);
1179         }
1180 
1181         @ForceInline
<span class="line-modified">1182         static $type$ getAndBitwiseAnd(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1183             Array handle = (Array)ob;</span>
1184             $type$[] array = ($type$[]) oarray;
1185             return UNSAFE.getAndBitwiseAnd$Type$(array,
1186                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1187                                        value);
1188         }
1189 
1190         @ForceInline
<span class="line-modified">1191         static $type$ getAndBitwiseAndRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1192             Array handle = (Array)ob;</span>
1193             $type$[] array = ($type$[]) oarray;
1194             return UNSAFE.getAndBitwiseAnd$Type$Release(array,
1195                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1196                                        value);
1197         }
1198 
1199         @ForceInline
<span class="line-modified">1200         static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1201             Array handle = (Array)ob;</span>
1202             $type$[] array = ($type$[]) oarray;
1203             return UNSAFE.getAndBitwiseAnd$Type$Acquire(array,
1204                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1205                                        value);
1206         }
1207 
1208         @ForceInline
<span class="line-modified">1209         static $type$ getAndBitwiseXor(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1210             Array handle = (Array)ob;</span>
1211             $type$[] array = ($type$[]) oarray;
1212             return UNSAFE.getAndBitwiseXor$Type$(array,
1213                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1214                                        value);
1215         }
1216 
1217         @ForceInline
<span class="line-modified">1218         static $type$ getAndBitwiseXorRelease(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1219             Array handle = (Array)ob;</span>
1220             $type$[] array = ($type$[]) oarray;
1221             return UNSAFE.getAndBitwiseXor$Type$Release(array,
1222                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1223                                        value);
1224         }
1225 
1226         @ForceInline
<span class="line-modified">1227         static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object oarray, int index, $type$ value) {</span>
<span class="line-added">1228             Array handle = (Array)ob;</span>
1229             $type$[] array = ($type$[]) oarray;
1230             return UNSAFE.getAndBitwiseXor$Type$Acquire(array,
1231                                        (((long) Preconditions.checkIndex(index, array.length, AIOOBE_SUPPLIER)) &lt;&lt; handle.ashift) + handle.abase,
1232                                        value);
1233         }
1234 #end[Bitwise]
1235 
1236         static final VarForm FORM = new VarForm(Array.class, {#if[Object]?Object[].class:$type$[].class}, {#if[Object]?Object.class:$type$.class}, int.class);
1237     }
1238 }
</pre>
</td>
</tr>
</table>
<center><a href="VarHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
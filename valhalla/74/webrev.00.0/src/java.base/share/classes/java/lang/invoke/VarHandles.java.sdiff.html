<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/VarHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/VarHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 

 30 import java.lang.reflect.Field;

 31 import java.lang.reflect.Modifier;
 32 import java.nio.ByteOrder;


 33 import java.util.Map;

 34 import java.util.concurrent.ConcurrentHashMap;
 35 import java.util.concurrent.ConcurrentMap;

 36 
 37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;


 38 
 39 final class VarHandles {
 40 
 41     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 42         @Override
 43         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 44             return new ConcurrentHashMap&lt;&gt;();
 45         }
 46     };
 47 
 48     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 49         if (!f.isStatic()) {
 50             long foffset = MethodHandleNatives.objectFieldOffset(f);
 51             if (!type.isPrimitive()) {
 52                 if (f.isFlattened()) {
<span class="line-modified"> 53                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 54                         ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 55                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type);</span>
 56                 } else {
<span class="line-modified"> 57                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 58                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 59                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type);</span>
 60                 }
 61             }
 62             else if (type == boolean.class) {
<span class="line-modified"> 63                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 64                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 65                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset);</span>
 66             }
 67             else if (type == byte.class) {
<span class="line-modified"> 68                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 69                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 70                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset);</span>
 71             }
 72             else if (type == short.class) {
<span class="line-modified"> 73                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 74                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 75                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset);</span>
 76             }
 77             else if (type == char.class) {
<span class="line-modified"> 78                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 79                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 80                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset);</span>
 81             }
 82             else if (type == int.class) {
<span class="line-modified"> 83                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 84                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 85                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset);</span>
 86             }
 87             else if (type == long.class) {
<span class="line-modified"> 88                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 89                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 90                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset);</span>
 91             }
 92             else if (type == float.class) {
<span class="line-modified"> 93                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 94                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 95                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset);</span>
 96             }
 97             else if (type == double.class) {
<span class="line-modified"> 98                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 99                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified">100                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset);</span>
101             }
102             else {
103                 throw new UnsupportedOperationException();
104             }
105         }
106         else {
107             // TODO This is not lazy on first invocation
108             // and might cause some circular initialization issues
109 
110             // Replace with something similar to direct method handles
111             // where a barrier is used then elided after use
112 
113             if (UNSAFE.shouldBeInitialized(refc))
114                 UNSAFE.ensureClassInitialized(refc);
115 
116             Object base = MethodHandleNatives.staticFieldBase(f);
117             long foffset = MethodHandleNatives.staticFieldOffset(f);
118             if (!type.isPrimitive()) {
119                 if (f.isFlattened()) {
<span class="line-modified">120                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
121                             ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)
<span class="line-modified">122                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type);</span>
123                 } else {
124                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
125                             ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
126                             : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);
127                 }
128             }
129             else if (type == boolean.class) {
<span class="line-modified">130                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
131                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
<span class="line-modified">132                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset);</span>
133             }
134             else if (type == byte.class) {
<span class="line-modified">135                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
136                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
<span class="line-modified">137                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset);</span>
138             }
139             else if (type == short.class) {
<span class="line-modified">140                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
141                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">142                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset);</span>
143             }
144             else if (type == char.class) {
<span class="line-modified">145                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
146                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
<span class="line-modified">147                        : new VarHandleChars.FieldStaticReadWrite(base, foffset);</span>
148             }
149             else if (type == int.class) {
<span class="line-modified">150                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
151                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">152                        : new VarHandleInts.FieldStaticReadWrite(base, foffset);</span>
153             }
154             else if (type == long.class) {
<span class="line-modified">155                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
156                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
<span class="line-modified">157                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset);</span>
158             }
159             else if (type == float.class) {
<span class="line-modified">160                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
161                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
<span class="line-modified">162                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset);</span>
163             }
164             else if (type == double.class) {
<span class="line-modified">165                 return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
166                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
<span class="line-modified">167                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset);</span>
168             }
169             else {
170                 throw new UnsupportedOperationException();
171             }
172         }
173     }
174 
175     // Required by instance field handles
176     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
177                                                long offset,
178                                                Class&lt;?&gt; fieldType) {
179         for (Field f : receiverType.getDeclaredFields()) {
180             if (Modifier.isStatic(f.getModifiers())) continue;
181 
182             if (offset == UNSAFE.objectFieldOffset(f)) {
183                 assert f.getType() == fieldType;
184                 return f;
185             }
186         }
187         throw new InternalError(&quot;Field not found at offset&quot;);
</pre>
<hr />
<pre>
202             }
203         }
204         throw new InternalError(&quot;Static field not found at offset&quot;);
205     }
206 
207     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
208         if (!arrayClass.isArray())
209             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
210 
211         Class&lt;?&gt; componentType = arrayClass.getComponentType();
212 
213         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
214         int ascale = UNSAFE.arrayIndexScale(arrayClass);
215         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
216 
217         if (!componentType.isPrimitive()) {
218             // the redundant componentType.isValue() check is there to
219             // minimize the performance impact to non-value array.
220             // It should be removed when Unsafe::isFlattenedArray is intrinsified.
221 
<span class="line-modified">222             return componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)</span>
223                 ? new VarHandleValues.Array(aoffset, ashift, arrayClass)
<span class="line-modified">224                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass);</span>
225         }
226         else if (componentType == boolean.class) {
<span class="line-modified">227             return new VarHandleBooleans.Array(aoffset, ashift);</span>
228         }
229         else if (componentType == byte.class) {
<span class="line-modified">230             return new VarHandleBytes.Array(aoffset, ashift);</span>
231         }
232         else if (componentType == short.class) {
<span class="line-modified">233             return new VarHandleShorts.Array(aoffset, ashift);</span>
234         }
235         else if (componentType == char.class) {
<span class="line-modified">236             return new VarHandleChars.Array(aoffset, ashift);</span>
237         }
238         else if (componentType == int.class) {
<span class="line-modified">239             return new VarHandleInts.Array(aoffset, ashift);</span>
240         }
241         else if (componentType == long.class) {
<span class="line-modified">242             return new VarHandleLongs.Array(aoffset, ashift);</span>
243         }
244         else if (componentType == float.class) {
<span class="line-modified">245             return new VarHandleFloats.Array(aoffset, ashift);</span>
246         }
247         else if (componentType == double.class) {
<span class="line-modified">248             return new VarHandleDoubles.Array(aoffset, ashift);</span>
249         }
250         else {
251             throw new UnsupportedOperationException();
252         }
253     }
254 
255     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
256                                          boolean be) {
257         if (!viewArrayClass.isArray())
258             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
259 
260         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
261 
262         if (viewComponentType == long.class) {
<span class="line-modified">263             return new VarHandleByteArrayAsLongs.ArrayHandle(be);</span>
264         }
265         else if (viewComponentType == int.class) {
<span class="line-modified">266             return new VarHandleByteArrayAsInts.ArrayHandle(be);</span>
267         }
268         else if (viewComponentType == short.class) {
<span class="line-modified">269             return new VarHandleByteArrayAsShorts.ArrayHandle(be);</span>
270         }
271         else if (viewComponentType == char.class) {
<span class="line-modified">272             return new VarHandleByteArrayAsChars.ArrayHandle(be);</span>
273         }
274         else if (viewComponentType == double.class) {
<span class="line-modified">275             return new VarHandleByteArrayAsDoubles.ArrayHandle(be);</span>
276         }
277         else if (viewComponentType == float.class) {
<span class="line-modified">278             return new VarHandleByteArrayAsFloats.ArrayHandle(be);</span>
279         }
280 
281         throw new UnsupportedOperationException();
282     }
283 
284     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
285                                               boolean be) {
286         if (!viewArrayClass.isArray())
287             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
288 
289         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
290 
291         if (viewComponentType == long.class) {
<span class="line-modified">292             return new VarHandleByteArrayAsLongs.ByteBufferHandle(be);</span>
293         }
294         else if (viewComponentType == int.class) {
<span class="line-modified">295             return new VarHandleByteArrayAsInts.ByteBufferHandle(be);</span>
296         }
297         else if (viewComponentType == short.class) {
<span class="line-modified">298             return new VarHandleByteArrayAsShorts.ByteBufferHandle(be);</span>
299         }
300         else if (viewComponentType == char.class) {
<span class="line-modified">301             return new VarHandleByteArrayAsChars.ByteBufferHandle(be);</span>
302         }
303         else if (viewComponentType == double.class) {
<span class="line-modified">304             return new VarHandleByteArrayAsDoubles.ByteBufferHandle(be);</span>
305         }
306         else if (viewComponentType == float.class) {
<span class="line-modified">307             return new VarHandleByteArrayAsFloats.ByteBufferHandle(be);</span>
308         }
309 
310         throw new UnsupportedOperationException();
311     }
312 
313     /**
314      * Creates a memory access VarHandle.
315      *
316      * Resulting VarHandle will take a memory address as first argument,
317      * and a certain number of coordinate {@code long} parameters, depending on the length
318      * of the {@code strides} argument array.
319      *
320      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
321      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
322      *
323      * @param carrier the Java carrier type.
324      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
325      * @param byteOrder the byte order.
326      * @param offset a constant offset for the access.
327      * @param strides the scale factors with which to multiply given access coordinates.
328      * @return the created VarHandle.
329      */
330     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
331                                                  ByteOrder byteOrder, long offset, long[] strides) {
332         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
333             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
334         }
335         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
336         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
337 
338         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
339         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
<span class="line-modified">340                 dims -&gt; new AddressVarHandleGenerator(carrier, dims)</span>
341                             .generateHandleFactory());
342 
343         try {
<span class="line-modified">344             return (VarHandle)fac.invoke(be, size, offset, alignmentMask, strides);</span>
345         } catch (Throwable ex) {
346             throw new IllegalStateException(ex);
347         }
348     }
349 

















































































































































































































































350 //    /**
351 //     * A helper program to generate the VarHandleGuards class with a set of
352 //     * static guard methods each of which corresponds to a particular shape and
353 //     * performs a type check of the symbolic type descriptor with the VarHandle
354 //     * type descriptor before linking/invoking to the underlying operation as
355 //     * characterized by the operation member name on the VarForm of the
356 //     * VarHandle.
357 //     * &lt;p&gt;
358 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
359 //     * one for each method, for the most set of common method signatures.
360 //     * This reduces static initialization costs, footprint costs, and circular
361 //     * dependencies that may arise if a class is generated per LambdaForm.
362 //     * &lt;p&gt;
363 //     * A maximum of L*T*S methods will be generated where L is the number of
364 //     * access modes kinds (or unique operation signatures) and T is the number
365 //     * of variable types and S is the number of shapes (such as instance field,
366 //     * static field, or array access).
367 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
368 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
369 //     * generated.  However, the number is likely to be less since there
370 //     * be duplicate signatures.
371 //     * &lt;p&gt;
372 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
373 //     * that such methods should be treated as if a method of a class that is the
374 //     * result of compiling a LambdaForm.  Annotation of such methods is
375 //     * important for correct evaluation of certain assertions and method return
376 //     * type profiling in HotSpot.
377 //     */
378 //    public static class GuardMethodGenerator {
379 //
380 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
381 //
382 //        static final String GUARD_METHOD_TEMPLATE =
383 //                &quot;@ForceInline\n&quot; +
384 //                &quot;@LambdaForm.Compiled\n&quot; +
385 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">386 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
387 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
388 //                &quot;    }\n&quot; +
389 //                &quot;    else {\n&quot; +
390 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
391 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
392 //                &quot;    }\n&quot; +
393 //                &quot;}&quot;;
394 //
395 //        static final String GUARD_METHOD_TEMPLATE_V =
396 //                &quot;@ForceInline\n&quot; +
397 //                &quot;@LambdaForm.Compiled\n&quot; +
398 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">399 //                &quot;    if (handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
400 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
401 //                &quot;    }\n&quot; +
<span class="line-modified">402 //                &quot;    else if (handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
403 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
404 //                &quot;    }\n&quot; +
405 //                &quot;    else {\n&quot; +
406 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
407 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
408 //                &quot;    }\n&quot; +
409 //                &quot;}&quot;;
410 //
411 //        // A template for deriving the operations
412 //        // could be supported by annotating VarHandle directly with the
413 //        // operation kind and shape
414 //        interface VarHandleTemplate {
415 //            Object get();
416 //
417 //            void set(Object value);
418 //
419 //            boolean compareAndSet(Object actualValue, Object expectedValue);
420 //
421 //            Object compareAndExchange(Object actualValue, Object expectedValue);
422 //
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import sun.invoke.util.Wrapper;
 29 
<span class="line-added"> 30 import java.lang.reflect.Constructor;</span>
 31 import java.lang.reflect.Field;
<span class="line-added"> 32 import java.lang.reflect.Method;</span>
 33 import java.lang.reflect.Modifier;
 34 import java.nio.ByteOrder;
<span class="line-added"> 35 import java.util.ArrayList;</span>
<span class="line-added"> 36 import java.util.List;</span>
 37 import java.util.Map;
<span class="line-added"> 38 import java.util.Objects;</span>
 39 import java.util.concurrent.ConcurrentHashMap;
 40 import java.util.concurrent.ConcurrentMap;
<span class="line-added"> 41 import java.util.stream.Stream;</span>
 42 
 43 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
<span class="line-added"> 44 import static java.lang.invoke.MethodHandleStatics.VAR_HANDLE_IDENTITY_ADAPT;</span>
<span class="line-added"> 45 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;</span>
 46 
 47 final class VarHandles {
 48 
 49     static ClassValue&lt;ConcurrentMap&lt;Integer, MethodHandle&gt;&gt; ADDRESS_FACTORIES = new ClassValue&lt;&gt;() {
 50         @Override
 51         protected ConcurrentMap&lt;Integer, MethodHandle&gt; computeValue(Class&lt;?&gt; type) {
 52             return new ConcurrentHashMap&lt;&gt;();
 53         }
 54     };
 55 
 56     static VarHandle makeFieldHandle(MemberName f, Class&lt;?&gt; refc, Class&lt;?&gt; type, boolean isWriteAllowedOnFinalFields) {
 57         if (!f.isStatic()) {
 58             long foffset = MethodHandleNatives.objectFieldOffset(f);
 59             if (!type.isPrimitive()) {
 60                 if (f.isFlattened()) {
<span class="line-modified"> 61                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 62                         ? new VarHandleValues.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 63                         : new VarHandleValues.FieldInstanceReadWrite(refc, foffset, type));</span>
 64                 } else {
<span class="line-modified"> 65                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 66                        ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type)
<span class="line-modified"> 67                        : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type));</span>
 68                 }
 69             }
 70             else if (type == boolean.class) {
<span class="line-modified"> 71                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 72                        ? new VarHandleBooleans.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 73                        : new VarHandleBooleans.FieldInstanceReadWrite(refc, foffset));</span>
 74             }
 75             else if (type == byte.class) {
<span class="line-modified"> 76                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 77                        ? new VarHandleBytes.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 78                        : new VarHandleBytes.FieldInstanceReadWrite(refc, foffset));</span>
 79             }
 80             else if (type == short.class) {
<span class="line-modified"> 81                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 82                        ? new VarHandleShorts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 83                        : new VarHandleShorts.FieldInstanceReadWrite(refc, foffset));</span>
 84             }
 85             else if (type == char.class) {
<span class="line-modified"> 86                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 87                        ? new VarHandleChars.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 88                        : new VarHandleChars.FieldInstanceReadWrite(refc, foffset));</span>
 89             }
 90             else if (type == int.class) {
<span class="line-modified"> 91                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 92                        ? new VarHandleInts.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 93                        : new VarHandleInts.FieldInstanceReadWrite(refc, foffset));</span>
 94             }
 95             else if (type == long.class) {
<span class="line-modified"> 96                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
 97                        ? new VarHandleLongs.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified"> 98                        : new VarHandleLongs.FieldInstanceReadWrite(refc, foffset));</span>
 99             }
100             else if (type == float.class) {
<span class="line-modified">101                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
102                        ? new VarHandleFloats.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified">103                        : new VarHandleFloats.FieldInstanceReadWrite(refc, foffset));</span>
104             }
105             else if (type == double.class) {
<span class="line-modified">106                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
107                        ? new VarHandleDoubles.FieldInstanceReadOnly(refc, foffset)
<span class="line-modified">108                        : new VarHandleDoubles.FieldInstanceReadWrite(refc, foffset));</span>
109             }
110             else {
111                 throw new UnsupportedOperationException();
112             }
113         }
114         else {
115             // TODO This is not lazy on first invocation
116             // and might cause some circular initialization issues
117 
118             // Replace with something similar to direct method handles
119             // where a barrier is used then elided after use
120 
121             if (UNSAFE.shouldBeInitialized(refc))
122                 UNSAFE.ensureClassInitialized(refc);
123 
124             Object base = MethodHandleNatives.staticFieldBase(f);
125             long foffset = MethodHandleNatives.staticFieldOffset(f);
126             if (!type.isPrimitive()) {
127                 if (f.isFlattened()) {
<span class="line-modified">128                     return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
129                             ? new VarHandleValues.FieldStaticReadOnly(refc, foffset, type)
<span class="line-modified">130                             : new VarHandleValues.FieldStaticReadWrite(refc, foffset, type));</span>
131                 } else {
132                     return f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields
133                             ? new VarHandleReferences.FieldStaticReadOnly(base, foffset, type)
134                             : new VarHandleReferences.FieldStaticReadWrite(base, foffset, type);
135                 }
136             }
137             else if (type == boolean.class) {
<span class="line-modified">138                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
139                        ? new VarHandleBooleans.FieldStaticReadOnly(base, foffset)
<span class="line-modified">140                        : new VarHandleBooleans.FieldStaticReadWrite(base, foffset));</span>
141             }
142             else if (type == byte.class) {
<span class="line-modified">143                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
144                        ? new VarHandleBytes.FieldStaticReadOnly(base, foffset)
<span class="line-modified">145                        : new VarHandleBytes.FieldStaticReadWrite(base, foffset));</span>
146             }
147             else if (type == short.class) {
<span class="line-modified">148                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
149                        ? new VarHandleShorts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">150                        : new VarHandleShorts.FieldStaticReadWrite(base, foffset));</span>
151             }
152             else if (type == char.class) {
<span class="line-modified">153                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
154                        ? new VarHandleChars.FieldStaticReadOnly(base, foffset)
<span class="line-modified">155                        : new VarHandleChars.FieldStaticReadWrite(base, foffset));</span>
156             }
157             else if (type == int.class) {
<span class="line-modified">158                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
159                        ? new VarHandleInts.FieldStaticReadOnly(base, foffset)
<span class="line-modified">160                        : new VarHandleInts.FieldStaticReadWrite(base, foffset));</span>
161             }
162             else if (type == long.class) {
<span class="line-modified">163                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
164                        ? new VarHandleLongs.FieldStaticReadOnly(base, foffset)
<span class="line-modified">165                        : new VarHandleLongs.FieldStaticReadWrite(base, foffset));</span>
166             }
167             else if (type == float.class) {
<span class="line-modified">168                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
169                        ? new VarHandleFloats.FieldStaticReadOnly(base, foffset)
<span class="line-modified">170                        : new VarHandleFloats.FieldStaticReadWrite(base, foffset));</span>
171             }
172             else if (type == double.class) {
<span class="line-modified">173                 return maybeAdapt(f.isFinal() &amp;&amp; !isWriteAllowedOnFinalFields</span>
174                        ? new VarHandleDoubles.FieldStaticReadOnly(base, foffset)
<span class="line-modified">175                        : new VarHandleDoubles.FieldStaticReadWrite(base, foffset));</span>
176             }
177             else {
178                 throw new UnsupportedOperationException();
179             }
180         }
181     }
182 
183     // Required by instance field handles
184     static Field getFieldFromReceiverAndOffset(Class&lt;?&gt; receiverType,
185                                                long offset,
186                                                Class&lt;?&gt; fieldType) {
187         for (Field f : receiverType.getDeclaredFields()) {
188             if (Modifier.isStatic(f.getModifiers())) continue;
189 
190             if (offset == UNSAFE.objectFieldOffset(f)) {
191                 assert f.getType() == fieldType;
192                 return f;
193             }
194         }
195         throw new InternalError(&quot;Field not found at offset&quot;);
</pre>
<hr />
<pre>
210             }
211         }
212         throw new InternalError(&quot;Static field not found at offset&quot;);
213     }
214 
215     static VarHandle makeArrayElementHandle(Class&lt;?&gt; arrayClass) {
216         if (!arrayClass.isArray())
217             throw new IllegalArgumentException(&quot;not an array: &quot; + arrayClass);
218 
219         Class&lt;?&gt; componentType = arrayClass.getComponentType();
220 
221         int aoffset = UNSAFE.arrayBaseOffset(arrayClass);
222         int ascale = UNSAFE.arrayIndexScale(arrayClass);
223         int ashift = 31 - Integer.numberOfLeadingZeros(ascale);
224 
225         if (!componentType.isPrimitive()) {
226             // the redundant componentType.isValue() check is there to
227             // minimize the performance impact to non-value array.
228             // It should be removed when Unsafe::isFlattenedArray is intrinsified.
229 
<span class="line-modified">230             return maybeAdapt(componentType.isInlineClass() &amp;&amp; UNSAFE.isFlattenedArray(arrayClass)</span>
231                 ? new VarHandleValues.Array(aoffset, ashift, arrayClass)
<span class="line-modified">232                 : new VarHandleReferences.Array(aoffset, ashift, arrayClass));</span>
233         }
234         else if (componentType == boolean.class) {
<span class="line-modified">235             return maybeAdapt(new VarHandleBooleans.Array(aoffset, ashift));</span>
236         }
237         else if (componentType == byte.class) {
<span class="line-modified">238             return maybeAdapt(new VarHandleBytes.Array(aoffset, ashift));</span>
239         }
240         else if (componentType == short.class) {
<span class="line-modified">241             return maybeAdapt(new VarHandleShorts.Array(aoffset, ashift));</span>
242         }
243         else if (componentType == char.class) {
<span class="line-modified">244             return maybeAdapt(new VarHandleChars.Array(aoffset, ashift));</span>
245         }
246         else if (componentType == int.class) {
<span class="line-modified">247             return maybeAdapt(new VarHandleInts.Array(aoffset, ashift));</span>
248         }
249         else if (componentType == long.class) {
<span class="line-modified">250             return maybeAdapt(new VarHandleLongs.Array(aoffset, ashift));</span>
251         }
252         else if (componentType == float.class) {
<span class="line-modified">253             return maybeAdapt(new VarHandleFloats.Array(aoffset, ashift));</span>
254         }
255         else if (componentType == double.class) {
<span class="line-modified">256             return maybeAdapt(new VarHandleDoubles.Array(aoffset, ashift));</span>
257         }
258         else {
259             throw new UnsupportedOperationException();
260         }
261     }
262 
263     static VarHandle byteArrayViewHandle(Class&lt;?&gt; viewArrayClass,
264                                          boolean be) {
265         if (!viewArrayClass.isArray())
266             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
267 
268         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
269 
270         if (viewComponentType == long.class) {
<span class="line-modified">271             return maybeAdapt(new VarHandleByteArrayAsLongs.ArrayHandle(be));</span>
272         }
273         else if (viewComponentType == int.class) {
<span class="line-modified">274             return maybeAdapt(new VarHandleByteArrayAsInts.ArrayHandle(be));</span>
275         }
276         else if (viewComponentType == short.class) {
<span class="line-modified">277             return maybeAdapt(new VarHandleByteArrayAsShorts.ArrayHandle(be));</span>
278         }
279         else if (viewComponentType == char.class) {
<span class="line-modified">280             return maybeAdapt(new VarHandleByteArrayAsChars.ArrayHandle(be));</span>
281         }
282         else if (viewComponentType == double.class) {
<span class="line-modified">283             return maybeAdapt(new VarHandleByteArrayAsDoubles.ArrayHandle(be));</span>
284         }
285         else if (viewComponentType == float.class) {
<span class="line-modified">286             return maybeAdapt(new VarHandleByteArrayAsFloats.ArrayHandle(be));</span>
287         }
288 
289         throw new UnsupportedOperationException();
290     }
291 
292     static VarHandle makeByteBufferViewHandle(Class&lt;?&gt; viewArrayClass,
293                                               boolean be) {
294         if (!viewArrayClass.isArray())
295             throw new IllegalArgumentException(&quot;not an array: &quot; + viewArrayClass);
296 
297         Class&lt;?&gt; viewComponentType = viewArrayClass.getComponentType();
298 
299         if (viewComponentType == long.class) {
<span class="line-modified">300             return maybeAdapt(new VarHandleByteArrayAsLongs.ByteBufferHandle(be));</span>
301         }
302         else if (viewComponentType == int.class) {
<span class="line-modified">303             return maybeAdapt(new VarHandleByteArrayAsInts.ByteBufferHandle(be));</span>
304         }
305         else if (viewComponentType == short.class) {
<span class="line-modified">306             return maybeAdapt(new VarHandleByteArrayAsShorts.ByteBufferHandle(be));</span>
307         }
308         else if (viewComponentType == char.class) {
<span class="line-modified">309             return maybeAdapt(new VarHandleByteArrayAsChars.ByteBufferHandle(be));</span>
310         }
311         else if (viewComponentType == double.class) {
<span class="line-modified">312             return maybeAdapt(new VarHandleByteArrayAsDoubles.ByteBufferHandle(be));</span>
313         }
314         else if (viewComponentType == float.class) {
<span class="line-modified">315             return maybeAdapt(new VarHandleByteArrayAsFloats.ByteBufferHandle(be));</span>
316         }
317 
318         throw new UnsupportedOperationException();
319     }
320 
321     /**
322      * Creates a memory access VarHandle.
323      *
324      * Resulting VarHandle will take a memory address as first argument,
325      * and a certain number of coordinate {@code long} parameters, depending on the length
326      * of the {@code strides} argument array.
327      *
328      * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added
329      * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.
330      *
331      * @param carrier the Java carrier type.
332      * @param alignmentMask alignment requirement to be checked upon access. In bytes. Expressed as a mask.
333      * @param byteOrder the byte order.
334      * @param offset a constant offset for the access.
335      * @param strides the scale factors with which to multiply given access coordinates.
336      * @return the created VarHandle.
337      */
338     static VarHandle makeMemoryAddressViewHandle(Class&lt;?&gt; carrier, long alignmentMask,
339                                                  ByteOrder byteOrder, long offset, long[] strides) {
340         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
341             throw new IllegalArgumentException(&quot;Invalid carrier: &quot; + carrier.getName());
342         }
343         long size = Wrapper.forPrimitiveType(carrier).bitWidth() / 8;
344         boolean be = byteOrder == ByteOrder.BIG_ENDIAN;
345 
346         Map&lt;Integer, MethodHandle&gt; carrierFactory = ADDRESS_FACTORIES.get(carrier);
347         MethodHandle fac = carrierFactory.computeIfAbsent(strides.length,
<span class="line-modified">348                 dims -&gt; new MemoryAccessVarHandleGenerator(carrier, dims)</span>
349                             .generateHandleFactory());
350 
351         try {
<span class="line-modified">352             return maybeAdapt((VarHandle)fac.invoke(be, size, offset, alignmentMask, strides));</span>
353         } catch (Throwable ex) {
354             throw new IllegalStateException(ex);
355         }
356     }
357 
<span class="line-added">358     private static VarHandle maybeAdapt(VarHandle target) {</span>
<span class="line-added">359         if (!VAR_HANDLE_IDENTITY_ADAPT) return target;</span>
<span class="line-added">360         target = filterValue(target,</span>
<span class="line-added">361                         MethodHandles.identity(target.varType()), MethodHandles.identity(target.varType()));</span>
<span class="line-added">362         MethodType mtype = target.accessModeType(VarHandle.AccessMode.GET).dropParameterTypes(0, 1);</span>
<span class="line-added">363         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {</span>
<span class="line-added">364             target = filterCoordinates(target, i, MethodHandles.identity(mtype.parameterType(i)));</span>
<span class="line-added">365         }</span>
<span class="line-added">366         return target;</span>
<span class="line-added">367     }</span>
<span class="line-added">368 </span>
<span class="line-added">369     public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {</span>
<span class="line-added">370         Objects.nonNull(target);</span>
<span class="line-added">371         Objects.nonNull(filterToTarget);</span>
<span class="line-added">372         Objects.nonNull(filterFromTarget);</span>
<span class="line-added">373         //check that from/to filters do not throw checked exceptions</span>
<span class="line-added">374         noCheckedExceptions(filterToTarget);</span>
<span class="line-added">375         noCheckedExceptions(filterFromTarget);</span>
<span class="line-added">376 </span>
<span class="line-added">377         //check that from/to filters have right signatures</span>
<span class="line-added">378         if (filterFromTarget.type().parameterCount() != 1) {</span>
<span class="line-added">379             throw newIllegalArgumentException(&quot;filterFromTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-added">380         } else if (filterToTarget.type().parameterCount() != 1) {</span>
<span class="line-added">381             throw newIllegalArgumentException(&quot;filterToTarget filter type has wrong arity&quot;, filterFromTarget.type());</span>
<span class="line-added">382         } else if (filterFromTarget.type().parameterType(0) != filterToTarget.type().returnType() ||</span>
<span class="line-added">383                 filterToTarget.type().parameterType(0) != filterFromTarget.type().returnType()) {</span>
<span class="line-added">384             throw newIllegalArgumentException(&quot;filterFromTarget and filterToTarget filter types do not match&quot;, filterFromTarget.type(), filterToTarget.type());</span>
<span class="line-added">385         } else if (target.varType() != filterFromTarget.type().parameterType(0)) {</span>
<span class="line-added">386             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterFromTarget.type(), target.varType());</span>
<span class="line-added">387         } else if (target.varType() != filterToTarget.type().returnType()) {</span>
<span class="line-added">388             throw newIllegalArgumentException(&quot;filterFromTarget filter type does not match target var handle type&quot;, filterToTarget.type(), target.varType());</span>
<span class="line-added">389         }</span>
<span class="line-added">390 </span>
<span class="line-added">391         return new IndirectVarHandle(target, filterFromTarget.type().returnType(), target.coordinateTypes().toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">392                 (mode, modeHandle) -&gt; {</span>
<span class="line-added">393                     int lastParameterPos = modeHandle.type().parameterCount() - 1;</span>
<span class="line-added">394                     return switch (mode.at) {</span>
<span class="line-added">395                         case GET -&gt; MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">396                         case SET -&gt; MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-added">397                         case GET_AND_UPDATE -&gt; {</span>
<span class="line-added">398                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">399                             yield MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-added">400                         }</span>
<span class="line-added">401                         case COMPARE_AND_EXCHANGE -&gt; {</span>
<span class="line-added">402                             MethodHandle adapter = MethodHandles.filterReturnValue(modeHandle, filterFromTarget);</span>
<span class="line-added">403                             adapter = MethodHandles.filterArgument(adapter, lastParameterPos, filterToTarget);</span>
<span class="line-added">404                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-added">405                         }</span>
<span class="line-added">406                         case COMPARE_AND_SET -&gt; {</span>
<span class="line-added">407                             MethodHandle adapter = MethodHandles.filterArgument(modeHandle, lastParameterPos, filterToTarget);</span>
<span class="line-added">408                             yield MethodHandles.filterArgument(adapter, lastParameterPos - 1, filterToTarget);</span>
<span class="line-added">409                         }</span>
<span class="line-added">410                     };</span>
<span class="line-added">411                 });</span>
<span class="line-added">412     }</span>
<span class="line-added">413 </span>
<span class="line-added">414     public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters) {</span>
<span class="line-added">415         Objects.nonNull(target);</span>
<span class="line-added">416         Objects.nonNull(filters);</span>
<span class="line-added">417 </span>
<span class="line-added">418         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">419         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">420             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">421         } else if (pos + filters.length &gt; targetCoordinates.size()) {</span>
<span class="line-added">422             throw new IllegalArgumentException(&quot;Too many filters&quot;);</span>
<span class="line-added">423         }</span>
<span class="line-added">424 </span>
<span class="line-added">425         if (filters.length == 0) return target;</span>
<span class="line-added">426 </span>
<span class="line-added">427         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">428         for (int i = 0 ; i &lt; filters.length ; i++) {</span>
<span class="line-added">429             noCheckedExceptions(filters[i]);</span>
<span class="line-added">430             MethodType filterType = filters[i].type();</span>
<span class="line-added">431             if (filterType.parameterCount() != 1) {</span>
<span class="line-added">432                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType);</span>
<span class="line-added">433             } else if (newCoordinates.get(pos + i) != filterType.returnType()) {</span>
<span class="line-added">434                 throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filterType + &quot; for coordinate type &quot; + newCoordinates.get(i));</span>
<span class="line-added">435             }</span>
<span class="line-added">436             newCoordinates.set(pos + i, filters[i].type().parameterType(0));</span>
<span class="line-added">437         }</span>
<span class="line-added">438 </span>
<span class="line-added">439         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">440                 (mode, modeHandle) -&gt; MethodHandles.filterArguments(modeHandle, 1 + pos, filters));</span>
<span class="line-added">441     }</span>
<span class="line-added">442 </span>
<span class="line-added">443     public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values) {</span>
<span class="line-added">444         Objects.nonNull(target);</span>
<span class="line-added">445         Objects.nonNull(values);</span>
<span class="line-added">446 </span>
<span class="line-added">447         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">448         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">449             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">450         } else if (pos + values.length &gt; targetCoordinates.size()) {</span>
<span class="line-added">451             throw new IllegalArgumentException(&quot;Too many values&quot;);</span>
<span class="line-added">452         }</span>
<span class="line-added">453 </span>
<span class="line-added">454         if (values.length == 0) return target;</span>
<span class="line-added">455 </span>
<span class="line-added">456         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">457         for (int i = 0 ; i &lt; values.length ; i++) {</span>
<span class="line-added">458             Class&lt;?&gt; pt = newCoordinates.get(pos);</span>
<span class="line-added">459             if (pt.isPrimitive()) {</span>
<span class="line-added">460                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="line-added">461                 w.convert(values[i], pt);</span>
<span class="line-added">462             } else {</span>
<span class="line-added">463                 pt.cast(values[i]);</span>
<span class="line-added">464             }</span>
<span class="line-added">465             newCoordinates.remove(pos);</span>
<span class="line-added">466         }</span>
<span class="line-added">467 </span>
<span class="line-added">468         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">469                 (mode, modeHandle) -&gt; MethodHandles.insertArguments(modeHandle, 1 + pos, values));</span>
<span class="line-added">470     }</span>
<span class="line-added">471 </span>
<span class="line-added">472     public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder) {</span>
<span class="line-added">473         Objects.nonNull(target);</span>
<span class="line-added">474         Objects.nonNull(newCoordinates);</span>
<span class="line-added">475         Objects.nonNull(reorder);</span>
<span class="line-added">476 </span>
<span class="line-added">477         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">478         MethodHandles.permuteArgumentChecks(reorder,</span>
<span class="line-added">479                 MethodType.methodType(void.class, newCoordinates),</span>
<span class="line-added">480                 MethodType.methodType(void.class, targetCoordinates));</span>
<span class="line-added">481 </span>
<span class="line-added">482         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">483                 (mode, modeHandle) -&gt;</span>
<span class="line-added">484                         MethodHandles.permuteArguments(modeHandle,</span>
<span class="line-added">485                                 methodTypeFor(mode.at, modeHandle.type(), targetCoordinates, newCoordinates),</span>
<span class="line-added">486                                 reorderArrayFor(mode.at, newCoordinates, reorder)));</span>
<span class="line-added">487     }</span>
<span class="line-added">488 </span>
<span class="line-added">489     private static int numTrailingArgs(VarHandle.AccessType at) {</span>
<span class="line-added">490         return switch (at) {</span>
<span class="line-added">491             case GET -&gt; 0;</span>
<span class="line-added">492             case GET_AND_UPDATE, SET -&gt; 1;</span>
<span class="line-added">493             case COMPARE_AND_SET, COMPARE_AND_EXCHANGE -&gt; 2;</span>
<span class="line-added">494         };</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497     private static int[] reorderArrayFor(VarHandle.AccessType at, List&lt;Class&lt;?&gt;&gt; newCoordinates, int[] reorder) {</span>
<span class="line-added">498         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-added">499         int[] adjustedReorder = new int[reorder.length + 1 + numTrailingArgs];</span>
<span class="line-added">500         adjustedReorder[0] = 0;</span>
<span class="line-added">501         for (int i = 0 ; i &lt; reorder.length ; i++) {</span>
<span class="line-added">502             adjustedReorder[i + 1] = reorder[i] + 1;</span>
<span class="line-added">503         }</span>
<span class="line-added">504         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-added">505             adjustedReorder[i + reorder.length + 1] = i + newCoordinates.size() + 1;</span>
<span class="line-added">506         }</span>
<span class="line-added">507         return adjustedReorder;</span>
<span class="line-added">508     }</span>
<span class="line-added">509 </span>
<span class="line-added">510     private static MethodType methodTypeFor(VarHandle.AccessType at, MethodType oldType, List&lt;Class&lt;?&gt;&gt; oldCoordinates, List&lt;Class&lt;?&gt;&gt; newCoordinates) {</span>
<span class="line-added">511         int numTrailingArgs = numTrailingArgs(at);</span>
<span class="line-added">512         MethodType adjustedType = MethodType.methodType(oldType.returnType(), oldType.parameterType(0));</span>
<span class="line-added">513         adjustedType = adjustedType.appendParameterTypes(newCoordinates);</span>
<span class="line-added">514         for (int i = 0 ; i &lt; numTrailingArgs ; i++) {</span>
<span class="line-added">515             adjustedType = adjustedType.appendParameterTypes(oldType.parameterType(1 + oldCoordinates.size() + i));</span>
<span class="line-added">516         }</span>
<span class="line-added">517         return adjustedType;</span>
<span class="line-added">518     }</span>
<span class="line-added">519 </span>
<span class="line-added">520     public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {</span>
<span class="line-added">521         Objects.nonNull(target);</span>
<span class="line-added">522         Objects.nonNull(filter);</span>
<span class="line-added">523         noCheckedExceptions(filter);</span>
<span class="line-added">524 </span>
<span class="line-added">525         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">526         if (pos &lt; 0 || pos &gt;= targetCoordinates.size()) {</span>
<span class="line-added">527             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">528         } else if (filter.type().returnType() == void.class) {</span>
<span class="line-added">529             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; ; filter cannot be void&quot;);</span>
<span class="line-added">530         } else if (filter.type().returnType() != targetCoordinates.get(pos)) {</span>
<span class="line-added">531             throw newIllegalArgumentException(&quot;Invalid filter type &quot; + filter.type() + &quot; for coordinate type &quot; + targetCoordinates.get(pos));</span>
<span class="line-added">532         }</span>
<span class="line-added">533 </span>
<span class="line-added">534         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">535         newCoordinates.remove(pos);</span>
<span class="line-added">536         newCoordinates.addAll(pos, filter.type().parameterList());</span>
<span class="line-added">537 </span>
<span class="line-added">538         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">539                 (mode, modeHandle) -&gt; MethodHandles.collectArguments(modeHandle, 1 + pos, filter));</span>
<span class="line-added">540     }</span>
<span class="line-added">541 </span>
<span class="line-added">542     public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="line-added">543         Objects.nonNull(target);</span>
<span class="line-added">544         Objects.nonNull(valueTypes);</span>
<span class="line-added">545 </span>
<span class="line-added">546         List&lt;Class&lt;?&gt;&gt; targetCoordinates = target.coordinateTypes();</span>
<span class="line-added">547         if (pos &lt; 0 || pos &gt; targetCoordinates.size()) {</span>
<span class="line-added">548             throw newIllegalArgumentException(&quot;Invalid position &quot; + pos + &quot; for coordinate types&quot;, targetCoordinates);</span>
<span class="line-added">549         }</span>
<span class="line-added">550 </span>
<span class="line-added">551         if (valueTypes.length == 0) return target;</span>
<span class="line-added">552 </span>
<span class="line-added">553         List&lt;Class&lt;?&gt;&gt; newCoordinates = new ArrayList&lt;&gt;(targetCoordinates);</span>
<span class="line-added">554         newCoordinates.addAll(pos, List.of(valueTypes));</span>
<span class="line-added">555 </span>
<span class="line-added">556         return new IndirectVarHandle(target, target.varType(), newCoordinates.toArray(new Class&lt;?&gt;[0]),</span>
<span class="line-added">557                 (mode, modeHandle) -&gt; MethodHandles.dropArguments(modeHandle, 1 + pos, valueTypes));</span>
<span class="line-added">558     }</span>
<span class="line-added">559 </span>
<span class="line-added">560     private static void noCheckedExceptions(MethodHandle handle) {</span>
<span class="line-added">561         if (handle instanceof DirectMethodHandle) {</span>
<span class="line-added">562             DirectMethodHandle directHandle = (DirectMethodHandle)handle;</span>
<span class="line-added">563             MethodHandleInfo info = MethodHandles.Lookup.IMPL_LOOKUP.revealDirect(directHandle);</span>
<span class="line-added">564             Class&lt;?&gt;[] exceptionTypes = switch (info.getReferenceKind()) {</span>
<span class="line-added">565                 case MethodHandleInfo.REF_invokeInterface, MethodHandleInfo.REF_invokeSpecial,</span>
<span class="line-added">566                         MethodHandleInfo.REF_invokeStatic, MethodHandleInfo.REF_invokeVirtual -&gt;</span>
<span class="line-added">567                         info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-added">568                 case MethodHandleInfo.REF_newInvokeSpecial -&gt;</span>
<span class="line-added">569                         info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP).getExceptionTypes();</span>
<span class="line-added">570                 case MethodHandleInfo.REF_getField, MethodHandleInfo.REF_getStatic,</span>
<span class="line-added">571                         MethodHandleInfo.REF_putField, MethodHandleInfo.REF_putStatic -&gt; null;</span>
<span class="line-added">572                 default -&gt; throw new AssertionError(&quot;Cannot get here&quot;);</span>
<span class="line-added">573             };</span>
<span class="line-added">574             if (exceptionTypes != null) {</span>
<span class="line-added">575                 if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {</span>
<span class="line-added">576                     throw newIllegalArgumentException(&quot;Cannot adapt a var handle with a method handle which throws checked exceptions&quot;);</span>
<span class="line-added">577                 }</span>
<span class="line-added">578             }</span>
<span class="line-added">579         } else if (handle instanceof DelegatingMethodHandle) {</span>
<span class="line-added">580             noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());</span>
<span class="line-added">581         } else {</span>
<span class="line-added">582             //bound</span>
<span class="line-added">583             BoundMethodHandle boundHandle = (BoundMethodHandle)handle;</span>
<span class="line-added">584             for (int i = 0 ; i &lt; boundHandle.fieldCount() ; i++) {</span>
<span class="line-added">585                 Object arg = boundHandle.arg(i);</span>
<span class="line-added">586                 if (arg instanceof MethodHandle){</span>
<span class="line-added">587                     noCheckedExceptions((MethodHandle) arg);</span>
<span class="line-added">588                 }</span>
<span class="line-added">589             }</span>
<span class="line-added">590         }</span>
<span class="line-added">591     }</span>
<span class="line-added">592 </span>
<span class="line-added">593     private static boolean isCheckedException(Class&lt;?&gt; clazz) {</span>
<span class="line-added">594         return Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-added">595                 !RuntimeException.class.isAssignableFrom(clazz) &amp;&amp;</span>
<span class="line-added">596                 !Error.class.isAssignableFrom(clazz);</span>
<span class="line-added">597     }</span>
<span class="line-added">598 </span>
599 //    /**
600 //     * A helper program to generate the VarHandleGuards class with a set of
601 //     * static guard methods each of which corresponds to a particular shape and
602 //     * performs a type check of the symbolic type descriptor with the VarHandle
603 //     * type descriptor before linking/invoking to the underlying operation as
604 //     * characterized by the operation member name on the VarForm of the
605 //     * VarHandle.
606 //     * &lt;p&gt;
607 //     * The generated class essentially encapsulates pre-compiled LambdaForms,
608 //     * one for each method, for the most set of common method signatures.
609 //     * This reduces static initialization costs, footprint costs, and circular
610 //     * dependencies that may arise if a class is generated per LambdaForm.
611 //     * &lt;p&gt;
612 //     * A maximum of L*T*S methods will be generated where L is the number of
613 //     * access modes kinds (or unique operation signatures) and T is the number
614 //     * of variable types and S is the number of shapes (such as instance field,
615 //     * static field, or array access).
616 //     * If there are 4 unique operation signatures, 5 basic types (Object, int,
617 //     * long, float, double), and 3 shapes then a maximum of 60 methods will be
618 //     * generated.  However, the number is likely to be less since there
619 //     * be duplicate signatures.
620 //     * &lt;p&gt;
621 //     * Each method is annotated with @LambdaForm.Compiled to inform the runtime
622 //     * that such methods should be treated as if a method of a class that is the
623 //     * result of compiling a LambdaForm.  Annotation of such methods is
624 //     * important for correct evaluation of certain assertions and method return
625 //     * type profiling in HotSpot.
626 //     */
627 //    public static class GuardMethodGenerator {
628 //
629 //        static final String GUARD_METHOD_SIG_TEMPLATE = &quot;&lt;RETURN&gt; &lt;NAME&gt;_&lt;SIGNATURE&gt;(&lt;PARAMS&gt;)&quot;;
630 //
631 //        static final String GUARD_METHOD_TEMPLATE =
632 //                &quot;@ForceInline\n&quot; +
633 //                &quot;@LambdaForm.Compiled\n&quot; +
634 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">635 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
636 //                &quot;        &lt;RESULT_ERASED&gt;MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);&lt;RETURN_ERASED&gt;\n&quot; +
637 //                &quot;    }\n&quot; +
638 //                &quot;    else {\n&quot; +
639 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
640 //                &quot;        &lt;RETURN&gt;mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
641 //                &quot;    }\n&quot; +
642 //                &quot;}&quot;;
643 //
644 //        static final String GUARD_METHOD_TEMPLATE_V =
645 //                &quot;@ForceInline\n&quot; +
646 //                &quot;@LambdaForm.Compiled\n&quot; +
647 //                &quot;final static &lt;METHOD&gt; throws Throwable {\n&quot; +
<span class="line-modified">648 //                &quot;    if (handle.isDirect() &amp;&amp; handle.vform.methodType_table[ad.type] == ad.symbolicMethodType) {\n&quot; +</span>
649 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
650 //                &quot;    }\n&quot; +
<span class="line-modified">651 //                &quot;    else if (handle.isDirect() &amp;&amp; handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodType) {\n&quot; +</span>
652 //                &quot;        MethodHandle.linkToStatic(&lt;LINK_TO_STATIC_ARGS&gt;);\n&quot; +
653 //                &quot;    }\n&quot; +
654 //                &quot;    else {\n&quot; +
655 //                &quot;        MethodHandle mh = handle.getMethodHandle(ad.mode);\n&quot; +
656 //                &quot;        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(&lt;LINK_TO_INVOKER_ARGS&gt;);\n&quot; +
657 //                &quot;    }\n&quot; +
658 //                &quot;}&quot;;
659 //
660 //        // A template for deriving the operations
661 //        // could be supported by annotating VarHandle directly with the
662 //        // operation kind and shape
663 //        interface VarHandleTemplate {
664 //            Object get();
665 //
666 //            void set(Object value);
667 //
668 //            boolean compareAndSet(Object actualValue, Object expectedValue);
669 //
670 //            Object compareAndExchange(Object actualValue, Object expectedValue);
671 //
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X-VarHandle.java.template.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
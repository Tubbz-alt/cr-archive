<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 271   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 272   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 273   typeArrayOop buffer = value(h_obj());
 274   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 275   if (is_latin1) {
 276     for (int index = 0; index &lt; length; index++) {
 277       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 278     }
 279   } else {
 280     for (int index = 0; index &lt; length; index++) {
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
<span class="line-modified"> 291       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);</span>
<span class="line-removed"> 292       ShouldNotReachHere();</span>
 293     }
 294   }
 295 #endif
 296 
 297   return h_obj;
 298 }
 299 
 300 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 301   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 302   return h_obj();
 303 }
 304 
 305 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 306   if (utf8_str == NULL) {
 307     return Handle();
 308   }
 309   bool has_multibyte, is_latin1;
 310   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 311   if (!CompactStrings) {
 312     has_multibyte = true;
 313     is_latin1 = false;
 314   }
 315 
 316   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 317   if (length &gt; 0) {
 318     if (!has_multibyte) {
 319       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 320       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 321     } else if (is_latin1) {
 322       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 323     } else {
 324       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 325     }
 326   }
 327 
 328 #ifdef ASSERT
<span class="line-modified"> 329   // This check is too strict because the input string is not necessarily valid UTF8.</span>
 330   // For example, it may be created with arbitrary content via jni_NewStringUTF.
<span class="line-modified"> 331   /*</span>
<span class="line-removed"> 332   {</span>
 333     ResourceMark rm;
 334     const char* expected = utf8_str;
 335     char* actual = as_utf8_string(h_obj());
 336     if (strcmp(expected, actual) != 0) {
<span class="line-modified"> 337       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);</span>
<span class="line-removed"> 338       ShouldNotReachHere();</span>
 339     }
 340   }
<span class="line-removed"> 341   */</span>
 342 #endif
 343 
 344   return h_obj;
 345 }
 346 
 347 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 348   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 349   return h_obj();
 350 }
 351 
 352 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 353   const char* utf8_str = (char*)symbol-&gt;bytes();
 354   int utf8_len = symbol-&gt;utf8_length();
 355 
 356   bool has_multibyte, is_latin1;
 357   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 358   if (!CompactStrings) {
 359     has_multibyte = true;
 360     is_latin1 = false;
 361   }
 362 
 363   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 364   if (length &gt; 0) {
 365     if (!has_multibyte) {
 366       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 367       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 368     } else if (is_latin1) {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 370     } else {
 371       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 372     }
 373   }
 374 
 375 #ifdef ASSERT
 376   {
 377     ResourceMark rm;
 378     const char* expected = symbol-&gt;as_utf8();
 379     char* actual = as_utf8_string(h_obj());
 380     if (strncmp(expected, actual, utf8_len) != 0) {
<span class="line-modified"> 381       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);</span>
<span class="line-removed"> 382       ShouldNotReachHere();</span>
 383     }
 384   }
 385 #endif
 386 
 387   return h_obj;
 388 }
 389 
 390 // Converts a C string to a Java String based on current encoding
 391 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 392   assert(str != NULL, &quot;bad arguments&quot;);
 393 
 394   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 395   static to_java_string_fn_t _to_java_string_fn = NULL;
 396 
 397   if (_to_java_string_fn == NULL) {
 398     void *lib_handle = os::native_java_library();
 399     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 400 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 401     if (_to_java_string_fn == NULL) {
 402       // On 32 bit Windows, also try __stdcall decorated name
</pre>
</td>
<td>
<hr />
<pre>
 271   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 272   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 273   typeArrayOop buffer = value(h_obj());
 274   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 275   if (is_latin1) {
 276     for (int index = 0; index &lt; length; index++) {
 277       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 278     }
 279   } else {
 280     for (int index = 0; index &lt; length; index++) {
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
<span class="line-modified"> 291       fatal(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);</span>

 292     }
 293   }
 294 #endif
 295 
 296   return h_obj;
 297 }
 298 
 299 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 300   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 301   return h_obj();
 302 }
 303 
 304 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 305   if (utf8_str == NULL) {
 306     return Handle();
 307   }
 308   bool has_multibyte, is_latin1;
 309   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 310   if (!CompactStrings) {
 311     has_multibyte = true;
 312     is_latin1 = false;
 313   }
 314 
 315   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 316   if (length &gt; 0) {
 317     if (!has_multibyte) {
 318       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 319       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 320     } else if (is_latin1) {
 321       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 322     } else {
 323       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 324     }
 325   }
 326 
 327 #ifdef ASSERT
<span class="line-modified"> 328   // This check is too strict when the input string is not a valid UTF8.</span>
 329   // For example, it may be created with arbitrary content via jni_NewStringUTF.
<span class="line-modified"> 330   if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {</span>

 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
<span class="line-modified"> 335       fatal(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);</span>

 336     }
 337   }

 338 #endif
 339 
 340   return h_obj;
 341 }
 342 
 343 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 344   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 345   return h_obj();
 346 }
 347 
 348 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 349   const char* utf8_str = (char*)symbol-&gt;bytes();
 350   int utf8_len = symbol-&gt;utf8_length();
 351 
 352   bool has_multibyte, is_latin1;
 353   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 354   if (!CompactStrings) {
 355     has_multibyte = true;
 356     is_latin1 = false;
 357   }
 358 
 359   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 360   if (length &gt; 0) {
 361     if (!has_multibyte) {
 362       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 363       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 364     } else if (is_latin1) {
 365       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 366     } else {
 367       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 368     }
 369   }
 370 
 371 #ifdef ASSERT
 372   {
 373     ResourceMark rm;
 374     const char* expected = symbol-&gt;as_utf8();
 375     char* actual = as_utf8_string(h_obj());
 376     if (strncmp(expected, actual, utf8_len) != 0) {
<span class="line-modified"> 377       fatal(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);</span>

 378     }
 379   }
 380 #endif
 381 
 382   return h_obj;
 383 }
 384 
 385 // Converts a C string to a Java String based on current encoding
 386 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 387   assert(str != NULL, &quot;bad arguments&quot;);
 388 
 389   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 390   static to_java_string_fn_t _to_java_string_fn = NULL;
 391 
 392   if (_to_java_string_fn == NULL) {
 393     void *lib_handle = os::native_java_library();
 394     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 395 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 396     if (_to_java_string_fn == NULL) {
 397       // On 32 bit Windows, also try __stdcall decorated name
</pre>
</td>
</tr>
</table>
<center><a href="classListParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
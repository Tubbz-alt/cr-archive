<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/addnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/castnode.hpp&quot;
  29 #include &quot;opto/cfgnode.hpp&quot;
  30 #include &quot;opto/connode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;
  32 #include &quot;opto/mulnode.hpp&quot;
  33 #include &quot;opto/phaseX.hpp&quot;
  34 #include &quot;opto/subnode.hpp&quot;
  35 
  36 // Portions of code courtesy of Clifford Click
  37 
  38 // Classic Add functionality.  This covers all the usual &#39;add&#39; behaviors for
  39 // an algebraic ring.  Add-integer, add-float, add-double, and binary-or are
  40 // all inherited from this class.  The various identity values are supplied
  41 // by virtual functions.
  42 
  43 
  44 //=============================================================================
  45 //------------------------------hash-------------------------------------------
  46 // Hash function over AddNodes.  Needs to be commutative; i.e., I swap
  47 // (commute) inputs to AddNodes willy-nilly so the hash function must return
  48 // the same value in the presence of edge swapping.
  49 uint AddNode::hash() const {
  50   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  51 }
  52 
  53 //------------------------------Identity---------------------------------------
  54 // If either input is a constant 0, return the other input.
  55 Node* AddNode::Identity(PhaseGVN* phase) {
  56   const Type *zero = add_id();  // The additive identity
  57   if( phase-&gt;type( in(1) )-&gt;higher_equal( zero ) ) return in(2);
  58   if( phase-&gt;type( in(2) )-&gt;higher_equal( zero ) ) return in(1);
  59   return this;
  60 }
  61 
  62 //------------------------------commute----------------------------------------
  63 // Commute operands to move loads and constants to the right.
  64 static bool commute(Node *add, bool con_left, bool con_right) {
  65   Node *in1 = add-&gt;in(1);
  66   Node *in2 = add-&gt;in(2);
  67 
  68   // Convert &quot;1+x&quot; into &quot;x+1&quot;.
  69   // Right is a constant; leave it
  70   if( con_right ) return false;
  71   // Left is a constant; move it right.
  72   if( con_left ) {
  73     add-&gt;swap_edges(1, 2);
  74     return true;
  75   }
  76 
  77   // Convert &quot;Load+x&quot; into &quot;x+Load&quot;.
  78   // Now check for loads
  79   if (in2-&gt;is_Load()) {
  80     if (!in1-&gt;is_Load()) {
  81       // already x+Load to return
  82       return false;
  83     }
  84     // both are loads, so fall through to sort inputs by idx
  85   } else if( in1-&gt;is_Load() ) {
  86     // Left is a Load and Right is not; move it right.
  87     add-&gt;swap_edges(1, 2);
  88     return true;
  89   }
  90 
  91   PhiNode *phi;
  92   // Check for tight loop increments: Loop-phi of Add of loop-phi
  93   if( in1-&gt;is_Phi() &amp;&amp; (phi = in1-&gt;as_Phi()) &amp;&amp; !phi-&gt;is_copy() &amp;&amp; phi-&gt;region()-&gt;is_Loop() &amp;&amp; phi-&gt;in(2)==add)
  94     return false;
  95   if( in2-&gt;is_Phi() &amp;&amp; (phi = in2-&gt;as_Phi()) &amp;&amp; !phi-&gt;is_copy() &amp;&amp; phi-&gt;region()-&gt;is_Loop() &amp;&amp; phi-&gt;in(2)==add){
  96     add-&gt;swap_edges(1, 2);
  97     return true;
  98   }
  99 
 100   // Otherwise, sort inputs (commutativity) to help value numbering.
 101   if( in1-&gt;_idx &gt; in2-&gt;_idx ) {
 102     add-&gt;swap_edges(1, 2);
 103     return true;
 104   }
 105   return false;
 106 }
 107 
 108 //------------------------------Idealize---------------------------------------
 109 // If we get here, we assume we are associative!
 110 Node *AddNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 111   const Type *t1 = phase-&gt;type( in(1) );
 112   const Type *t2 = phase-&gt;type( in(2) );
 113   bool con_left  = t1-&gt;singleton();
 114   bool con_right = t2-&gt;singleton();
 115 
 116   // Check for commutative operation desired
 117   if( commute(this,con_left,con_right) ) return this;
 118 
 119   AddNode *progress = NULL;             // Progress flag
 120 
 121   // Convert &quot;(x+1)+2&quot; into &quot;x+(1+2)&quot;.  If the right input is a
 122   // constant, and the left input is an add of a constant, flatten the
 123   // expression tree.
 124   Node *add1 = in(1);
 125   Node *add2 = in(2);
 126   int add1_op = add1-&gt;Opcode();
 127   int this_op = Opcode();
 128   if( con_right &amp;&amp; t2 != Type::TOP &amp;&amp; // Right input is a constant?
 129       add1_op == this_op ) { // Left input is an Add?
 130 
 131     // Type of left _in right input
 132     const Type *t12 = phase-&gt;type( add1-&gt;in(2) );
 133     if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP ) { // Left input is an add of a constant?
 134       // Check for rare case of closed data cycle which can happen inside
 135       // unreachable loops. In these cases the computation is undefined.
 136 #ifdef ASSERT
 137       Node *add11    = add1-&gt;in(1);
 138       int   add11_op = add11-&gt;Opcode();
 139       if( (add1 == add1-&gt;in(1))
 140          || (add11_op == this_op &amp;&amp; add11-&gt;in(1) == add1) ) {
 141         assert(false, &quot;dead loop in AddNode::Ideal&quot;);
 142       }
 143 #endif
 144       // The Add of the flattened expression
 145       Node *x1 = add1-&gt;in(1);
 146       Node *x2 = phase-&gt;makecon( add1-&gt;as_Add()-&gt;add_ring( t2, t12 ));
 147       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 148       if( igvn ) {
 149         set_req_X(2,x2,igvn);
 150         set_req_X(1,x1,igvn);
 151       } else {
 152         set_req(2,x2);
 153         set_req(1,x1);
 154       }
 155       progress = this;            // Made progress
 156       add1 = in(1);
 157       add1_op = add1-&gt;Opcode();
 158     }
 159   }
 160 
 161   // Convert &quot;(x+1)+y&quot; into &quot;(x+y)+1&quot;.  Push constants down the expression tree.
 162   if( add1_op == this_op &amp;&amp; !con_right ) {
 163     Node *a12 = add1-&gt;in(2);
 164     const Type *t12 = phase-&gt;type( a12 );
 165     if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP &amp;&amp; (add1 != add1-&gt;in(1)) &amp;&amp;
 166        !(add1-&gt;in(1)-&gt;is_Phi() &amp;&amp; add1-&gt;in(1)-&gt;as_Phi()-&gt;is_tripcount()) ) {
 167       assert(add1-&gt;in(1) != this, &quot;dead loop in AddNode::Ideal&quot;);
 168       add2 = add1-&gt;clone();
 169       add2-&gt;set_req(2, in(2));
 170       add2 = phase-&gt;transform(add2);
 171       set_req(1, add2);
 172       set_req(2, a12);
 173       progress = this;
 174       add2 = a12;
 175     }
 176   }
 177 
 178   // Convert &quot;x+(y+1)&quot; into &quot;(x+y)+1&quot;.  Push constants down the expression tree.
 179   int add2_op = add2-&gt;Opcode();
 180   if( add2_op == this_op &amp;&amp; !con_left ) {
 181     Node *a22 = add2-&gt;in(2);
 182     const Type *t22 = phase-&gt;type( a22 );
 183     if( t22-&gt;singleton() &amp;&amp; t22 != Type::TOP &amp;&amp; (add2 != add2-&gt;in(1)) &amp;&amp;
 184        !(add2-&gt;in(1)-&gt;is_Phi() &amp;&amp; add2-&gt;in(1)-&gt;as_Phi()-&gt;is_tripcount()) ) {
 185       assert(add2-&gt;in(1) != this, &quot;dead loop in AddNode::Ideal&quot;);
 186       Node *addx = add2-&gt;clone();
 187       addx-&gt;set_req(1, in(1));
 188       addx-&gt;set_req(2, add2-&gt;in(1));
 189       addx = phase-&gt;transform(addx);
 190       set_req(1, addx);
 191       set_req(2, a22);
 192       progress = this;
 193       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 194       if (add2-&gt;outcnt() == 0 &amp;&amp; igvn) {
 195         // add disconnected.
 196         igvn-&gt;_worklist.push(add2);
 197       }
 198     }
 199   }
 200 
 201   return progress;
 202 }
 203 
 204 //------------------------------Value-----------------------------------------
 205 // An add node sums it&#39;s two _in.  If one input is an RSD, we must mixin
 206 // the other input&#39;s symbols.
 207 const Type* AddNode::Value(PhaseGVN* phase) const {
 208   // Either input is TOP ==&gt; the result is TOP
 209   const Type *t1 = phase-&gt;type( in(1) );
 210   const Type *t2 = phase-&gt;type( in(2) );
 211   if( t1 == Type::TOP ) return Type::TOP;
 212   if( t2 == Type::TOP ) return Type::TOP;
 213 
 214   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 215   const Type *bot = bottom_type();
 216   if( (t1 == bot) || (t2 == bot) ||
 217       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 218     return bot;
 219 
 220   // Check for an addition involving the additive identity
 221   const Type *tadd = add_of_identity( t1, t2 );
 222   if( tadd ) return tadd;
 223 
 224   return add_ring(t1,t2);               // Local flavor of type addition
 225 }
 226 
 227 //------------------------------add_identity-----------------------------------
 228 // Check for addition of the identity
 229 const Type *AddNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 230   const Type *zero = add_id();  // The additive identity
 231   if( t1-&gt;higher_equal( zero ) ) return t2;
 232   if( t2-&gt;higher_equal( zero ) ) return t1;
 233 
 234   return NULL;
 235 }
 236 
 237 
 238 //=============================================================================
 239 //------------------------------Idealize---------------------------------------
 240 Node *AddINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 241   Node* in1 = in(1);
 242   Node* in2 = in(2);
 243   int op1 = in1-&gt;Opcode();
 244   int op2 = in2-&gt;Opcode();
 245   // Fold (con1-x)+con2 into (con1+con2)-x
 246   if ( op1 == Op_AddI &amp;&amp; op2 == Op_SubI ) {
 247     // Swap edges to try optimizations below
 248     in1 = in2;
 249     in2 = in(1);
 250     op1 = op2;
 251     op2 = in2-&gt;Opcode();
 252   }
 253   if( op1 == Op_SubI ) {
 254     const Type *t_sub1 = phase-&gt;type( in1-&gt;in(1) );
 255     const Type *t_2    = phase-&gt;type( in2        );
 256     if( t_sub1-&gt;singleton() &amp;&amp; t_2-&gt;singleton() &amp;&amp; t_sub1 != Type::TOP &amp;&amp; t_2 != Type::TOP )
 257       return new SubINode(phase-&gt;makecon( add_ring( t_sub1, t_2 ) ), in1-&gt;in(2) );
 258     // Convert &quot;(a-b)+(c-d)&quot; into &quot;(a+c)-(b+d)&quot;
 259     if( op2 == Op_SubI ) {
 260       // Check for dead cycle: d = (a-b)+(c-d)
 261       assert( in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(2) != this,
 262               &quot;dead loop in AddINode::Ideal&quot; );
 263       Node *sub  = new SubINode(NULL, NULL);
 264       sub-&gt;init_req(1, phase-&gt;transform(new AddINode(in1-&gt;in(1), in2-&gt;in(1) ) ));
 265       sub-&gt;init_req(2, phase-&gt;transform(new AddINode(in1-&gt;in(2), in2-&gt;in(2) ) ));
 266       return sub;
 267     }
 268     // Convert &quot;(a-b)+(b+c)&quot; into &quot;(a+c)&quot;
 269     if( op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 270       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddINode::Ideal&quot;);
 271       return new AddINode(in1-&gt;in(1), in2-&gt;in(2));
 272     }
 273     // Convert &quot;(a-b)+(c+b)&quot; into &quot;(a+c)&quot;
 274     if( op2 == Op_AddI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) ) {
 275       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddINode::Ideal&quot;);
 276       return new AddINode(in1-&gt;in(1), in2-&gt;in(1));
 277     }
 278     // Convert &quot;(a-b)+(b-c)&quot; into &quot;(a-c)&quot;
 279     if( op2 == Op_SubI &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 280       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddINode::Ideal&quot;);
 281       return new SubINode(in1-&gt;in(1), in2-&gt;in(2));
 282     }
 283     // Convert &quot;(a-b)+(c-a)&quot; into &quot;(c-b)&quot;
 284     if( op2 == Op_SubI &amp;&amp; in1-&gt;in(1) == in2-&gt;in(2) ) {
 285       assert(in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddINode::Ideal&quot;);
 286       return new SubINode(in2-&gt;in(1), in1-&gt;in(2));
 287     }
 288   }
 289 
 290   // Convert &quot;x+(0-y)&quot; into &quot;(x-y)&quot;
 291   if( op2 == Op_SubI &amp;&amp; phase-&gt;type(in2-&gt;in(1)) == TypeInt::ZERO )
 292     return new SubINode(in1, in2-&gt;in(2) );
 293 
 294   // Convert &quot;(0-y)+x&quot; into &quot;(x-y)&quot;
 295   if( op1 == Op_SubI &amp;&amp; phase-&gt;type(in1-&gt;in(1)) == TypeInt::ZERO )
 296     return new SubINode( in2, in1-&gt;in(2) );
 297 
 298   // Convert (x&gt;&gt;&gt;z)+y into (x+(y&lt;&lt;z))&gt;&gt;&gt;z for small constant z and y.
 299   // Helps with array allocation math constant folding
 300   // See 4790063:
 301   // Unrestricted transformation is unsafe for some runtime values of &#39;x&#39;
 302   // ( x ==  0, z == 1, y == -1 ) fails
 303   // ( x == -5, z == 1, y ==  1 ) fails
 304   // Transform works for small z and small negative y when the addition
 305   // (x + (y &lt;&lt; z)) does not cross zero.
 306   // Implement support for negative y and (x &gt;= -(y &lt;&lt; z))
 307   // Have not observed cases where type information exists to support
 308   // positive y and (x &lt;= -(y &lt;&lt; z))
 309   if( op1 == Op_URShiftI &amp;&amp; op2 == Op_ConI &amp;&amp;
 310       in1-&gt;in(2)-&gt;Opcode() == Op_ConI ) {
 311     jint z = phase-&gt;type( in1-&gt;in(2) )-&gt;is_int()-&gt;get_con() &amp; 0x1f; // only least significant 5 bits matter
 312     jint y = phase-&gt;type( in2 )-&gt;is_int()-&gt;get_con();
 313 
 314     if( z &lt; 5 &amp;&amp; -5 &lt; y &amp;&amp; y &lt; 0 ) {
 315       const Type *t_in11 = phase-&gt;type(in1-&gt;in(1));
 316       if( t_in11 != Type::TOP &amp;&amp; (t_in11-&gt;is_int()-&gt;_lo &gt;= -(y &lt;&lt; z)) ) {
 317         Node *a = phase-&gt;transform( new AddINode( in1-&gt;in(1), phase-&gt;intcon(y&lt;&lt;z) ) );
 318         return new URShiftINode( a, in1-&gt;in(2) );
 319       }
 320     }
 321   }
 322 
 323   return AddNode::Ideal(phase, can_reshape);
 324 }
 325 
 326 
 327 //------------------------------Identity---------------------------------------
 328 // Fold (x-y)+y  OR  y+(x-y)  into  x
 329 Node* AddINode::Identity(PhaseGVN* phase) {
 330   if( in(1)-&gt;Opcode() == Op_SubI &amp;&amp; phase-&gt;eqv(in(1)-&gt;in(2),in(2)) ) {
 331     return in(1)-&gt;in(1);
 332   }
 333   else if( in(2)-&gt;Opcode() == Op_SubI &amp;&amp; phase-&gt;eqv(in(2)-&gt;in(2),in(1)) ) {
 334     return in(2)-&gt;in(1);
 335   }
 336   return AddNode::Identity(phase);
 337 }
 338 
 339 
 340 //------------------------------add_ring---------------------------------------
 341 // Supplied function returns the sum of the inputs.  Guaranteed never
 342 // to be passed a TOP or BOTTOM type, these are filtered out by
 343 // pre-check.
 344 const Type *AddINode::add_ring( const Type *t0, const Type *t1 ) const {
 345   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 346   const TypeInt *r1 = t1-&gt;is_int();
 347   int lo = java_add(r0-&gt;_lo, r1-&gt;_lo);
 348   int hi = java_add(r0-&gt;_hi, r1-&gt;_hi);
 349   if( !(r0-&gt;is_con() &amp;&amp; r1-&gt;is_con()) ) {
 350     // Not both constants, compute approximate result
 351     if( (r0-&gt;_lo &amp; r1-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0 ) {
 352       lo = min_jint; hi = max_jint; // Underflow on the low side
 353     }
 354     if( (~(r0-&gt;_hi | r1-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0 ) {
 355       lo = min_jint; hi = max_jint; // Overflow on the high side
 356     }
 357     if( lo &gt; hi ) {               // Handle overflow
 358       lo = min_jint; hi = max_jint;
 359     }
 360   } else {
 361     // both constants, compute precise result using &#39;lo&#39; and &#39;hi&#39;
 362     // Semantics define overflow and underflow for integer addition
 363     // as expected.  In particular: 0x80000000 + 0x80000000 --&gt; 0x0
 364   }
 365   return TypeInt::make( lo, hi, MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 366 }
 367 
 368 
 369 //=============================================================================
 370 //------------------------------Idealize---------------------------------------
 371 Node *AddLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 372   Node* in1 = in(1);
 373   Node* in2 = in(2);
 374   int op1 = in1-&gt;Opcode();
 375   int op2 = in2-&gt;Opcode();
 376   // Fold (con1-x)+con2 into (con1+con2)-x
 377   if ( op1 == Op_AddL &amp;&amp; op2 == Op_SubL ) {
 378     // Swap edges to try optimizations below
 379     in1 = in2;
 380     in2 = in(1);
 381     op1 = op2;
 382     op2 = in2-&gt;Opcode();
 383   }
 384   // Fold (con1-x)+con2 into (con1+con2)-x
 385   if( op1 == Op_SubL ) {
 386     const Type *t_sub1 = phase-&gt;type( in1-&gt;in(1) );
 387     const Type *t_2    = phase-&gt;type( in2        );
 388     if( t_sub1-&gt;singleton() &amp;&amp; t_2-&gt;singleton() &amp;&amp; t_sub1 != Type::TOP &amp;&amp; t_2 != Type::TOP )
 389       return new SubLNode(phase-&gt;makecon( add_ring( t_sub1, t_2 ) ), in1-&gt;in(2) );
 390     // Convert &quot;(a-b)+(c-d)&quot; into &quot;(a+c)-(b+d)&quot;
 391     if( op2 == Op_SubL ) {
 392       // Check for dead cycle: d = (a-b)+(c-d)
 393       assert( in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(2) != this,
 394               &quot;dead loop in AddLNode::Ideal&quot; );
 395       Node *sub  = new SubLNode(NULL, NULL);
 396       sub-&gt;init_req(1, phase-&gt;transform(new AddLNode(in1-&gt;in(1), in2-&gt;in(1) ) ));
 397       sub-&gt;init_req(2, phase-&gt;transform(new AddLNode(in1-&gt;in(2), in2-&gt;in(2) ) ));
 398       return sub;
 399     }
 400     // Convert &quot;(a-b)+(b+c)&quot; into &quot;(a+c)&quot;
 401     if( op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 402       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 403       return new AddLNode(in1-&gt;in(1), in2-&gt;in(2));
 404     }
 405     // Convert &quot;(a-b)+(c+b)&quot; into &quot;(a+c)&quot;
 406     if( op2 == Op_AddL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(2) ) {
 407       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 408       return new AddLNode(in1-&gt;in(1), in2-&gt;in(1));
 409     }
 410     // Convert &quot;(a-b)+(b-c)&quot; into &quot;(a-c)&quot;
 411     if( op2 == Op_SubL &amp;&amp; in1-&gt;in(2) == in2-&gt;in(1) ) {
 412       assert(in1-&gt;in(1) != this &amp;&amp; in2-&gt;in(2) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 413       return new SubLNode(in1-&gt;in(1), in2-&gt;in(2));
 414     }
 415     // Convert &quot;(a-b)+(c-a)&quot; into &quot;(c-b)&quot;
 416     if( op2 == Op_SubL &amp;&amp; in1-&gt;in(1) == in1-&gt;in(2) ) {
 417       assert(in1-&gt;in(2) != this &amp;&amp; in2-&gt;in(1) != this,&quot;dead loop in AddLNode::Ideal&quot;);
 418       return new SubLNode(in2-&gt;in(1), in1-&gt;in(2));
 419     }
 420   }
 421 
 422   // Convert &quot;x+(0-y)&quot; into &quot;(x-y)&quot;
 423   if( op2 == Op_SubL &amp;&amp; phase-&gt;type(in2-&gt;in(1)) == TypeLong::ZERO )
 424     return new SubLNode( in1, in2-&gt;in(2) );
 425 
 426   // Convert &quot;(0-y)+x&quot; into &quot;(x-y)&quot;
 427   if( op1 == Op_SubL &amp;&amp; phase-&gt;type(in1-&gt;in(1)) == TypeInt::ZERO )
 428     return new SubLNode( in2, in1-&gt;in(2) );
 429 
 430   // Convert &quot;X+X+X+X+X...+X+Y&quot; into &quot;k*X+Y&quot; or really convert &quot;X+(X+Y)&quot;
 431   // into &quot;(X&lt;&lt;1)+Y&quot; and let shift-folding happen.
 432   if( op2 == Op_AddL &amp;&amp;
 433       in2-&gt;in(1) == in1 &amp;&amp;
 434       op1 != Op_ConL &amp;&amp;
 435       0 ) {
 436     Node *shift = phase-&gt;transform(new LShiftLNode(in1,phase-&gt;intcon(1)));
 437     return new AddLNode(shift,in2-&gt;in(2));
 438   }
 439 
 440   return AddNode::Ideal(phase, can_reshape);
 441 }
 442 
 443 
 444 //------------------------------Identity---------------------------------------
 445 // Fold (x-y)+y  OR  y+(x-y)  into  x
 446 Node* AddLNode::Identity(PhaseGVN* phase) {
 447   if( in(1)-&gt;Opcode() == Op_SubL &amp;&amp; phase-&gt;eqv(in(1)-&gt;in(2),in(2)) ) {
 448     return in(1)-&gt;in(1);
 449   }
 450   else if( in(2)-&gt;Opcode() == Op_SubL &amp;&amp; phase-&gt;eqv(in(2)-&gt;in(2),in(1)) ) {
 451     return in(2)-&gt;in(1);
 452   }
 453   return AddNode::Identity(phase);
 454 }
 455 
 456 
 457 //------------------------------add_ring---------------------------------------
 458 // Supplied function returns the sum of the inputs.  Guaranteed never
 459 // to be passed a TOP or BOTTOM type, these are filtered out by
 460 // pre-check.
 461 const Type *AddLNode::add_ring( const Type *t0, const Type *t1 ) const {
 462   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 463   const TypeLong *r1 = t1-&gt;is_long();
 464   jlong lo = java_add(r0-&gt;_lo, r1-&gt;_lo);
 465   jlong hi = java_add(r0-&gt;_hi, r1-&gt;_hi);
 466   if( !(r0-&gt;is_con() &amp;&amp; r1-&gt;is_con()) ) {
 467     // Not both constants, compute approximate result
 468     if( (r0-&gt;_lo &amp; r1-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0 ) {
 469       lo =min_jlong; hi = max_jlong; // Underflow on the low side
 470     }
 471     if( (~(r0-&gt;_hi | r1-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0 ) {
 472       lo = min_jlong; hi = max_jlong; // Overflow on the high side
 473     }
 474     if( lo &gt; hi ) {               // Handle overflow
 475       lo = min_jlong; hi = max_jlong;
 476     }
 477   } else {
 478     // both constants, compute precise result using &#39;lo&#39; and &#39;hi&#39;
 479     // Semantics define overflow and underflow for integer addition
 480     // as expected.  In particular: 0x80000000 + 0x80000000 --&gt; 0x0
 481   }
 482   return TypeLong::make( lo, hi, MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 483 }
 484 
 485 
 486 //=============================================================================
 487 //------------------------------add_of_identity--------------------------------
 488 // Check for addition of the identity
 489 const Type *AddFNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 490   // x ADD 0  should return x unless &#39;x&#39; is a -zero
 491   //
 492   // const Type *zero = add_id();     // The additive identity
 493   // jfloat f1 = t1-&gt;getf();
 494   // jfloat f2 = t2-&gt;getf();
 495   //
 496   // if( t1-&gt;higher_equal( zero ) ) return t2;
 497   // if( t2-&gt;higher_equal( zero ) ) return t1;
 498 
 499   return NULL;
 500 }
 501 
 502 //------------------------------add_ring---------------------------------------
 503 // Supplied function returns the sum of the inputs.
 504 // This also type-checks the inputs for sanity.  Guaranteed never to
 505 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 506 const Type *AddFNode::add_ring( const Type *t0, const Type *t1 ) const {
 507   // We must be adding 2 float constants.
 508   return TypeF::make( t0-&gt;getf() + t1-&gt;getf() );
 509 }
 510 
 511 //------------------------------Ideal------------------------------------------
 512 Node *AddFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 513   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 514     return AddNode::Ideal(phase, can_reshape); // commutative and associative transforms
 515   }
 516 
 517   // Floating point additions are not associative because of boundary conditions (infinity)
 518   return commute(this,
 519                  phase-&gt;type( in(1) )-&gt;singleton(),
 520                  phase-&gt;type( in(2) )-&gt;singleton() ) ? this : NULL;
 521 }
 522 
 523 
 524 //=============================================================================
 525 //------------------------------add_of_identity--------------------------------
 526 // Check for addition of the identity
 527 const Type *AddDNode::add_of_identity( const Type *t1, const Type *t2 ) const {
 528   // x ADD 0  should return x unless &#39;x&#39; is a -zero
 529   //
 530   // const Type *zero = add_id();     // The additive identity
 531   // jfloat f1 = t1-&gt;getf();
 532   // jfloat f2 = t2-&gt;getf();
 533   //
 534   // if( t1-&gt;higher_equal( zero ) ) return t2;
 535   // if( t2-&gt;higher_equal( zero ) ) return t1;
 536 
 537   return NULL;
 538 }
 539 //------------------------------add_ring---------------------------------------
 540 // Supplied function returns the sum of the inputs.
 541 // This also type-checks the inputs for sanity.  Guaranteed never to
 542 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 543 const Type *AddDNode::add_ring( const Type *t0, const Type *t1 ) const {
 544   // We must be adding 2 double constants.
 545   return TypeD::make( t0-&gt;getd() + t1-&gt;getd() );
 546 }
 547 
 548 //------------------------------Ideal------------------------------------------
 549 Node *AddDNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 550   if( IdealizedNumerics &amp;&amp; !phase-&gt;C-&gt;method()-&gt;is_strict() ) {
 551     return AddNode::Ideal(phase, can_reshape); // commutative and associative transforms
 552   }
 553 
 554   // Floating point additions are not associative because of boundary conditions (infinity)
 555   return commute(this,
 556                  phase-&gt;type( in(1) )-&gt;singleton(),
 557                  phase-&gt;type( in(2) )-&gt;singleton() ) ? this : NULL;
 558 }
 559 
 560 
 561 //=============================================================================
 562 //------------------------------Identity---------------------------------------
 563 // If one input is a constant 0, return the other input.
 564 Node* AddPNode::Identity(PhaseGVN* phase) {
 565   return ( phase-&gt;type( in(Offset) )-&gt;higher_equal( TypeX_ZERO ) ) ? in(Address) : this;
 566 }
 567 
 568 //------------------------------Idealize---------------------------------------
 569 Node *AddPNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 570   // Bail out if dead inputs
 571   if( phase-&gt;type( in(Address) ) == Type::TOP ) return NULL;
 572 
 573   // If the left input is an add of a constant, flatten the expression tree.
 574   const Node *n = in(Address);
 575   if (n-&gt;is_AddP() &amp;&amp; n-&gt;in(Base) == in(Base)) {
 576     const AddPNode *addp = n-&gt;as_AddP(); // Left input is an AddP
 577     assert( !addp-&gt;in(Address)-&gt;is_AddP() ||
 578              addp-&gt;in(Address)-&gt;as_AddP() != addp,
 579             &quot;dead loop in AddPNode::Ideal&quot; );
 580     // Type of left input&#39;s right input
 581     const Type *t = phase-&gt;type( addp-&gt;in(Offset) );
 582     if( t == Type::TOP ) return NULL;
 583     const TypeX *t12 = t-&gt;is_intptr_t();
 584     if( t12-&gt;is_con() ) {       // Left input is an add of a constant?
 585       // If the right input is a constant, combine constants
 586       const Type *temp_t2 = phase-&gt;type( in(Offset) );
 587       if( temp_t2 == Type::TOP ) return NULL;
 588       const TypeX *t2 = temp_t2-&gt;is_intptr_t();
 589       Node* address;
 590       Node* offset;
 591       if( t2-&gt;is_con() ) {
 592         // The Add of the flattened expression
 593         address = addp-&gt;in(Address);
 594         offset  = phase-&gt;MakeConX(t2-&gt;get_con() + t12-&gt;get_con());
 595       } else {
 596         // Else move the constant to the right.  ((A+con)+B) into ((A+B)+con)
 597         address = phase-&gt;transform(new AddPNode(in(Base),addp-&gt;in(Address),in(Offset)));
 598         offset  = addp-&gt;in(Offset);
 599       }
 600       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 601       if( igvn ) {
 602         set_req_X(Address,address,igvn);
 603         set_req_X(Offset,offset,igvn);
 604       } else {
 605         set_req(Address,address);
 606         set_req(Offset,offset);
 607       }
 608       return this;
 609     }
 610   }
 611 
 612   // Raw pointers?
 613   if( in(Base)-&gt;bottom_type() == Type::TOP ) {
 614     // If this is a NULL+long form (from unsafe accesses), switch to a rawptr.
 615     if (phase-&gt;type(in(Address)) == TypePtr::NULL_PTR) {
 616       Node* offset = in(Offset);
 617       return new CastX2PNode(offset);
 618     }
 619   }
 620 
 621   // If the right is an add of a constant, push the offset down.
 622   // Convert: (ptr + (offset+con)) into (ptr+offset)+con.
 623   // The idea is to merge array_base+scaled_index groups together,
 624   // and only have different constant offsets from the same base.
 625   const Node *add = in(Offset);
 626   if( add-&gt;Opcode() == Op_AddX &amp;&amp; add-&gt;in(1) != add ) {
 627     const Type *t22 = phase-&gt;type( add-&gt;in(2) );
 628     if( t22-&gt;singleton() &amp;&amp; (t22 != Type::TOP) ) {  // Right input is an add of a constant?
 629       set_req(Address, phase-&gt;transform(new AddPNode(in(Base),in(Address),add-&gt;in(1))));
 630       set_req(Offset, add-&gt;in(2));
 631       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
 632       if (add-&gt;outcnt() == 0 &amp;&amp; igvn) {
 633         // add disconnected.
 634         igvn-&gt;_worklist.push((Node*)add);
 635       }
 636       return this;              // Made progress
 637     }
 638   }
 639 
 640   return NULL;                  // No progress
 641 }
 642 
 643 //------------------------------bottom_type------------------------------------
 644 // Bottom-type is the pointer-type with unknown offset.
 645 const Type *AddPNode::bottom_type() const {
 646   if (in(Address) == NULL)  return TypePtr::BOTTOM;
 647   const TypePtr *tp = in(Address)-&gt;bottom_type()-&gt;isa_ptr();
 648   if( !tp ) return Type::TOP;   // TOP input means TOP output
 649   assert( in(Offset)-&gt;Opcode() != Op_ConP, &quot;&quot; );
 650   const Type *t = in(Offset)-&gt;bottom_type();
 651   if( t == Type::TOP )
 652     return tp-&gt;add_offset(Type::OffsetTop);
 653   const TypeX *tx = t-&gt;is_intptr_t();
 654   intptr_t txoffset = Type::OffsetBot;
 655   if (tx-&gt;is_con()) {   // Left input is an add of a constant?
 656     txoffset = tx-&gt;get_con();
 657   }
 658   if (tp-&gt;isa_aryptr()) {
 659     // In the case of a flattened value type array, each field has its
 660     // own slice so we need to extract the field being accessed from
 661     // the address computation
 662     return tp-&gt;is_aryptr()-&gt;add_field_offset_and_offset(txoffset);
 663   }
 664   return tp-&gt;add_offset(txoffset);
 665 }
 666 
 667 //------------------------------Value------------------------------------------
 668 const Type* AddPNode::Value(PhaseGVN* phase) const {
 669   // Either input is TOP ==&gt; the result is TOP
 670   const Type *t1 = phase-&gt;type( in(Address) );
 671   const Type *t2 = phase-&gt;type( in(Offset) );
 672   if( t1 == Type::TOP ) return Type::TOP;
 673   if( t2 == Type::TOP ) return Type::TOP;
 674 
 675   // Left input is a pointer
 676   const TypePtr *p1 = t1-&gt;isa_ptr();
 677   // Right input is an int
 678   const TypeX *p2 = t2-&gt;is_intptr_t();
 679   // Add &#39;em
 680   intptr_t p2offset = Type::OffsetBot;
 681   if (p2-&gt;is_con()) {   // Left input is an add of a constant?
 682     p2offset = p2-&gt;get_con();
 683   }
 684   if (p1-&gt;isa_aryptr()) {
 685     // In the case of a flattened value type array, each field has its
 686     // own slice so we need to extract the field being accessed from
 687     // the address computation
 688     return p1-&gt;is_aryptr()-&gt;add_field_offset_and_offset(p2offset);
 689   }
 690   return p1-&gt;add_offset(p2offset);
 691 }
 692 
 693 //------------------------Ideal_base_and_offset--------------------------------
 694 // Split an oop pointer into a base and offset.
 695 // (The offset might be Type::OffsetBot in the case of an array.)
 696 // Return the base, or NULL if failure.
 697 Node* AddPNode::Ideal_base_and_offset(Node* ptr, PhaseTransform* phase,
 698                                       // second return value:
 699                                       intptr_t&amp; offset) {
 700   if (ptr-&gt;is_AddP()) {
 701     Node* base = ptr-&gt;in(AddPNode::Base);
 702     Node* addr = ptr-&gt;in(AddPNode::Address);
 703     Node* offs = ptr-&gt;in(AddPNode::Offset);
 704     if (base == addr || base-&gt;is_top()) {
 705       offset = phase-&gt;find_intptr_t_con(offs, Type::OffsetBot);
 706       if (offset != Type::OffsetBot) {
 707         return addr;
 708       }
 709     }
 710   }
 711   offset = Type::OffsetBot;
 712   return NULL;
 713 }
 714 
 715 //------------------------------unpack_offsets----------------------------------
 716 // Collect the AddP offset values into the elements array, giving up
 717 // if there are more than length.
 718 int AddPNode::unpack_offsets(Node* elements[], int length) {
 719   int count = 0;
 720   Node* addr = this;
 721   Node* base = addr-&gt;in(AddPNode::Base);
 722   while (addr-&gt;is_AddP()) {
 723     if (addr-&gt;in(AddPNode::Base) != base) {
 724       // give up
 725       return -1;
 726     }
 727     elements[count++] = addr-&gt;in(AddPNode::Offset);
 728     if (count == length) {
 729       // give up
 730       return -1;
 731     }
 732     addr = addr-&gt;in(AddPNode::Address);
 733   }
 734   if (addr != base) {
 735     return -1;
 736   }
 737   return count;
 738 }
 739 
 740 //------------------------------match_edge-------------------------------------
 741 // Do we Match on this edge index or not?  Do not match base pointer edge
 742 uint AddPNode::match_edge(uint idx) const {
 743   return idx &gt; Base;
 744 }
 745 
 746 //=============================================================================
 747 //------------------------------Identity---------------------------------------
 748 Node* OrINode::Identity(PhaseGVN* phase) {
 749   // x | x =&gt; x
 750   if (phase-&gt;eqv(in(1), in(2))) {
 751     return in(1);
 752   }
 753 
 754   return AddNode::Identity(phase);
 755 }
 756 
 757 //------------------------------add_ring---------------------------------------
 758 // Supplied function returns the sum of the inputs IN THE CURRENT RING.  For
 759 // the logical operations the ring&#39;s ADD is really a logical OR function.
 760 // This also type-checks the inputs for sanity.  Guaranteed never to
 761 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 762 const Type *OrINode::add_ring( const Type *t0, const Type *t1 ) const {
 763   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 764   const TypeInt *r1 = t1-&gt;is_int();
 765 
 766   // If both args are bool, can figure out better types
 767   if ( r0 == TypeInt::BOOL ) {
 768     if ( r1 == TypeInt::ONE) {
 769       return TypeInt::ONE;
 770     } else if ( r1 == TypeInt::BOOL ) {
 771       return TypeInt::BOOL;
 772     }
 773   } else if ( r0 == TypeInt::ONE ) {
 774     if ( r1 == TypeInt::BOOL ) {
 775       return TypeInt::ONE;
 776     }
 777   }
 778 
 779   // If either input is not a constant, just return all integers.
 780   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 781     return TypeInt::INT;        // Any integer, but still no symbols.
 782 
 783   // Otherwise just OR them bits.
 784   return TypeInt::make( r0-&gt;get_con() | r1-&gt;get_con() );
 785 }
 786 
 787 //=============================================================================
 788 //------------------------------Identity---------------------------------------
 789 Node* OrLNode::Identity(PhaseGVN* phase) {
 790   // x | x =&gt; x
 791   if (phase-&gt;eqv(in(1), in(2))) {
 792     return in(1);
 793   }
 794 
 795   return AddNode::Identity(phase);
 796 }
 797 
 798 //------------------------------add_ring---------------------------------------
 799 const Type *OrLNode::add_ring( const Type *t0, const Type *t1 ) const {
 800   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 801   const TypeLong *r1 = t1-&gt;is_long();
 802 
 803   // If either input is not a constant, just return all integers.
 804   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 805     return TypeLong::LONG;      // Any integer, but still no symbols.
 806 
 807   // Otherwise just OR them bits.
 808   return TypeLong::make( r0-&gt;get_con() | r1-&gt;get_con() );
 809 }
 810 
 811 //=============================================================================
 812 //------------------------------add_ring---------------------------------------
 813 // Supplied function returns the sum of the inputs IN THE CURRENT RING.  For
 814 // the logical operations the ring&#39;s ADD is really a logical OR function.
 815 // This also type-checks the inputs for sanity.  Guaranteed never to
 816 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 817 const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {
 818   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 819   const TypeInt *r1 = t1-&gt;is_int();
 820 
 821   // Complementing a boolean?
 822   if( r0 == TypeInt::BOOL &amp;&amp; ( r1 == TypeInt::ONE
 823                                || r1 == TypeInt::BOOL))
 824     return TypeInt::BOOL;
 825 
 826   if( !r0-&gt;is_con() || !r1-&gt;is_con() ) // Not constants
 827     return TypeInt::INT;        // Any integer, but still no symbols.
 828 
 829   // Otherwise just XOR them bits.
 830   return TypeInt::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 831 }
 832 
 833 //=============================================================================
 834 //------------------------------add_ring---------------------------------------
 835 const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {
 836   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 837   const TypeLong *r1 = t1-&gt;is_long();
 838 
 839   // If either input is not a constant, just return all integers.
 840   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 841     return TypeLong::LONG;      // Any integer, but still no symbols.
 842 
 843   // Otherwise just OR them bits.
 844   return TypeLong::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 845 }
 846 
 847 //=============================================================================
 848 //------------------------------add_ring---------------------------------------
 849 // Supplied function returns the sum of the inputs.
 850 const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {
 851   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 852   const TypeInt *r1 = t1-&gt;is_int();
 853 
 854   // Otherwise just MAX them bits.
 855   return TypeInt::make( MAX2(r0-&gt;_lo,r1-&gt;_lo), MAX2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 856 }
 857 
 858 //=============================================================================
 859 //------------------------------Idealize---------------------------------------
 860 // MINs show up in range-check loop limit calculations.  Look for
 861 // &quot;MIN2(x+c0,MIN2(y,x+c1))&quot;.  Pick the smaller constant: &quot;MIN2(x+c0,y)&quot;
 862 Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 863   Node *progress = NULL;
 864   // Force a right-spline graph
 865   Node *l = in(1);
 866   Node *r = in(2);
 867   // Transform  MinI1( MinI2(a,b), c)  into  MinI1( a, MinI2(b,c) )
 868   // to force a right-spline graph for the rest of MinINode::Ideal().
 869   if( l-&gt;Opcode() == Op_MinI ) {
 870     assert( l != l-&gt;in(1), &quot;dead loop in MinINode::Ideal&quot; );
 871     r = phase-&gt;transform(new MinINode(l-&gt;in(2),r));
 872     l = l-&gt;in(1);
 873     set_req(1, l);
 874     set_req(2, r);
 875     return this;
 876   }
 877 
 878   // Get left input &amp; constant
 879   Node *x = l;
 880   int x_off = 0;
 881   if( x-&gt;Opcode() == Op_AddI &amp;&amp; // Check for &quot;x+c0&quot; and collect constant
 882       x-&gt;in(2)-&gt;is_Con() ) {
 883     const Type *t = x-&gt;in(2)-&gt;bottom_type();
 884     if( t == Type::TOP ) return NULL;  // No progress
 885     x_off = t-&gt;is_int()-&gt;get_con();
 886     x = x-&gt;in(1);
 887   }
 888 
 889   // Scan a right-spline-tree for MINs
 890   Node *y = r;
 891   int y_off = 0;
 892   // Check final part of MIN tree
 893   if( y-&gt;Opcode() == Op_AddI &amp;&amp; // Check for &quot;y+c1&quot; and collect constant
 894       y-&gt;in(2)-&gt;is_Con() ) {
 895     const Type *t = y-&gt;in(2)-&gt;bottom_type();
 896     if( t == Type::TOP ) return NULL;  // No progress
 897     y_off = t-&gt;is_int()-&gt;get_con();
 898     y = y-&gt;in(1);
 899   }
 900   if( x-&gt;_idx &gt; y-&gt;_idx &amp;&amp; r-&gt;Opcode() != Op_MinI ) {
 901     swap_edges(1, 2);
 902     return this;
 903   }
 904 
 905 
 906   if( r-&gt;Opcode() == Op_MinI ) {
 907     assert( r != r-&gt;in(2), &quot;dead loop in MinINode::Ideal&quot; );
 908     y = r-&gt;in(1);
 909     // Check final part of MIN tree
 910     if( y-&gt;Opcode() == Op_AddI &amp;&amp;// Check for &quot;y+c1&quot; and collect constant
 911         y-&gt;in(2)-&gt;is_Con() ) {
 912       const Type *t = y-&gt;in(2)-&gt;bottom_type();
 913       if( t == Type::TOP ) return NULL;  // No progress
 914       y_off = t-&gt;is_int()-&gt;get_con();
 915       y = y-&gt;in(1);
 916     }
 917 
 918     if( x-&gt;_idx &gt; y-&gt;_idx )
 919       return new MinINode(r-&gt;in(1),phase-&gt;transform(new MinINode(l,r-&gt;in(2))));
 920 
 921     // See if covers: MIN2(x+c0,MIN2(y+c1,z))
 922     if( !phase-&gt;eqv(x,y) ) return NULL;
 923     // If (y == x) transform MIN2(x+c0, MIN2(x+c1,z)) into
 924     // MIN2(x+c0 or x+c1 which less, z).
 925     return new MinINode(phase-&gt;transform(new AddINode(x,phase-&gt;intcon(MIN2(x_off,y_off)))),r-&gt;in(2));
 926   } else {
 927     // See if covers: MIN2(x+c0,y+c1)
 928     if( !phase-&gt;eqv(x,y) ) return NULL;
 929     // If (y == x) transform MIN2(x+c0,x+c1) into x+c0 or x+c1 which less.
 930     return new AddINode(x,phase-&gt;intcon(MIN2(x_off,y_off)));
 931   }
 932 
 933 }
 934 
 935 //------------------------------add_ring---------------------------------------
 936 // Supplied function returns the sum of the inputs.
 937 const Type *MinINode::add_ring( const Type *t0, const Type *t1 ) const {
 938   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 939   const TypeInt *r1 = t1-&gt;is_int();
 940 
 941   // Otherwise just MIN them bits.
 942   return TypeInt::make( MIN2(r0-&gt;_lo,r1-&gt;_lo), MIN2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 943 }
 944 
 945 //------------------------------add_ring---------------------------------------
 946 const Type *MinFNode::add_ring( const Type *t0, const Type *t1 ) const {
 947   const TypeF *r0 = t0-&gt;is_float_constant();
 948   const TypeF *r1 = t1-&gt;is_float_constant();
 949 
 950   if (r0-&gt;is_nan()) {
 951     return r0;
 952   }
 953   if (r1-&gt;is_nan()) {
 954     return r1;
 955   }
 956 
 957   float f0 = r0-&gt;getf();
 958   float f1 = r1-&gt;getf();
 959   if (f0 != 0.0f || f1 != 0.0f) {
 960     return f0 &lt; f1 ? r0 : r1;
 961   }
 962 
 963   // handle min of 0.0, -0.0 case.
 964   return (jint_cast(f0) &lt; jint_cast(f1)) ? r0 : r1;
 965 }
 966 
 967 //------------------------------add_ring---------------------------------------
 968 const Type *MinDNode::add_ring( const Type *t0, const Type *t1 ) const {
 969   const TypeD *r0 = t0-&gt;is_double_constant();
 970   const TypeD *r1 = t1-&gt;is_double_constant();
 971 
 972   if (r0-&gt;is_nan()) {
 973     return r0;
 974   }
 975   if (r1-&gt;is_nan()) {
 976     return r1;
 977   }
 978 
 979   double d0 = r0-&gt;getd();
 980   double d1 = r1-&gt;getd();
 981   if (d0 != 0.0 || d1 != 0.0) {
 982     return d0 &lt; d1 ? r0 : r1;
 983   }
 984 
 985   // handle min of 0.0, -0.0 case.
 986   return (jlong_cast(d0) &lt; jlong_cast(d1)) ? r0 : r1;
 987 }
 988 
 989 //------------------------------add_ring---------------------------------------
 990 const Type *MaxFNode::add_ring( const Type *t0, const Type *t1 ) const {
 991   const TypeF *r0 = t0-&gt;is_float_constant();
 992   const TypeF *r1 = t1-&gt;is_float_constant();
 993 
 994   if (r0-&gt;is_nan()) {
 995     return r0;
 996   }
 997   if (r1-&gt;is_nan()) {
 998     return r1;
 999   }
1000 
1001   float f0 = r0-&gt;getf();
1002   float f1 = r1-&gt;getf();
1003   if (f0 != 0.0f || f1 != 0.0f) {
1004     return f0 &gt; f1 ? r0 : r1;
1005   }
1006 
1007   // handle max of 0.0,-0.0 case.
1008   return (jint_cast(f0) &gt; jint_cast(f1)) ? r0 : r1;
1009 }
1010 
1011 //------------------------------add_ring---------------------------------------
1012 const Type *MaxDNode::add_ring( const Type *t0, const Type *t1 ) const {
1013   const TypeD *r0 = t0-&gt;is_double_constant();
1014   const TypeD *r1 = t1-&gt;is_double_constant();
1015 
1016   if (r0-&gt;is_nan()) {
1017     return r0;
1018   }
1019   if (r1-&gt;is_nan()) {
1020     return r1;
1021   }
1022 
1023   double d0 = r0-&gt;getd();
1024   double d1 = r1-&gt;getd();
1025   if (d0 != 0.0 || d1 != 0.0) {
1026     return d0 &gt; d1 ? r0 : r1;
1027   }
1028 
1029   // handle max of 0.0, -0.0 case.
1030   return (jlong_cast(d0) &gt; jlong_cast(d1)) ? r0 : r1;
1031 }
    </pre>
  </body>
</html>
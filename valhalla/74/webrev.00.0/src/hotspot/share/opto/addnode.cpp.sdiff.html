<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/addnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/addnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/castnode.hpp&quot;
  29 #include &quot;opto/cfgnode.hpp&quot;
  30 #include &quot;opto/connode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;

  32 #include &quot;opto/mulnode.hpp&quot;
  33 #include &quot;opto/phaseX.hpp&quot;
  34 #include &quot;opto/subnode.hpp&quot;
  35 
  36 // Portions of code courtesy of Clifford Click
  37 
  38 // Classic Add functionality.  This covers all the usual &#39;add&#39; behaviors for
  39 // an algebraic ring.  Add-integer, add-float, add-double, and binary-or are
  40 // all inherited from this class.  The various identity values are supplied
  41 // by virtual functions.
  42 
  43 
  44 //=============================================================================
  45 //------------------------------hash-------------------------------------------
  46 // Hash function over AddNodes.  Needs to be commutative; i.e., I swap
  47 // (commute) inputs to AddNodes willy-nilly so the hash function must return
  48 // the same value in the presence of edge swapping.
  49 uint AddNode::hash() const {
  50   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  51 }
</pre>
<hr />
<pre>
 827     return TypeInt::INT;        // Any integer, but still no symbols.
 828 
 829   // Otherwise just XOR them bits.
 830   return TypeInt::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 831 }
 832 
 833 //=============================================================================
 834 //------------------------------add_ring---------------------------------------
 835 const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {
 836   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 837   const TypeLong *r1 = t1-&gt;is_long();
 838 
 839   // If either input is not a constant, just return all integers.
 840   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 841     return TypeLong::LONG;      // Any integer, but still no symbols.
 842 
 843   // Otherwise just OR them bits.
 844   return TypeLong::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 845 }
 846 

























































































 847 //=============================================================================
 848 //------------------------------add_ring---------------------------------------
 849 // Supplied function returns the sum of the inputs.
 850 const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {
 851   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 852   const TypeInt *r1 = t1-&gt;is_int();
 853 
 854   // Otherwise just MAX them bits.
 855   return TypeInt::make( MAX2(r0-&gt;_lo,r1-&gt;_lo), MAX2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 856 }
 857 
 858 //=============================================================================
 859 //------------------------------Idealize---------------------------------------
 860 // MINs show up in range-check loop limit calculations.  Look for
 861 // &quot;MIN2(x+c0,MIN2(y,x+c1))&quot;.  Pick the smaller constant: &quot;MIN2(x+c0,y)&quot;
 862 Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 863   Node *progress = NULL;
 864   // Force a right-spline graph
 865   Node *l = in(1);
 866   Node *r = in(2);
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/castnode.hpp&quot;
  29 #include &quot;opto/cfgnode.hpp&quot;
  30 #include &quot;opto/connode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;
<span class="line-added">  32 #include &quot;opto/movenode.hpp&quot;</span>
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/phaseX.hpp&quot;
  35 #include &quot;opto/subnode.hpp&quot;
  36 
  37 // Portions of code courtesy of Clifford Click
  38 
  39 // Classic Add functionality.  This covers all the usual &#39;add&#39; behaviors for
  40 // an algebraic ring.  Add-integer, add-float, add-double, and binary-or are
  41 // all inherited from this class.  The various identity values are supplied
  42 // by virtual functions.
  43 
  44 
  45 //=============================================================================
  46 //------------------------------hash-------------------------------------------
  47 // Hash function over AddNodes.  Needs to be commutative; i.e., I swap
  48 // (commute) inputs to AddNodes willy-nilly so the hash function must return
  49 // the same value in the presence of edge swapping.
  50 uint AddNode::hash() const {
  51   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  52 }
</pre>
<hr />
<pre>
 828     return TypeInt::INT;        // Any integer, but still no symbols.
 829 
 830   // Otherwise just XOR them bits.
 831   return TypeInt::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 832 }
 833 
 834 //=============================================================================
 835 //------------------------------add_ring---------------------------------------
 836 const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {
 837   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 838   const TypeLong *r1 = t1-&gt;is_long();
 839 
 840   // If either input is not a constant, just return all integers.
 841   if( !r0-&gt;is_con() || !r1-&gt;is_con() )
 842     return TypeLong::LONG;      // Any integer, but still no symbols.
 843 
 844   // Otherwise just OR them bits.
 845   return TypeLong::make( r0-&gt;get_con() ^ r1-&gt;get_con() );
 846 }
 847 
<span class="line-added"> 848 </span>
<span class="line-added"> 849 Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added"> 850   bool is_int = gvn.type(a)-&gt;isa_int();</span>
<span class="line-added"> 851   assert(is_int || gvn.type(a)-&gt;isa_long(), &quot;int or long inputs&quot;);</span>
<span class="line-added"> 852   assert(is_int == (gvn.type(b)-&gt;isa_int() != NULL), &quot;inconsistent inputs&quot;);</span>
<span class="line-added"> 853   if (!is_unsigned) {</span>
<span class="line-added"> 854     if (is_max) {</span>
<span class="line-added"> 855       if (is_int) {</span>
<span class="line-added"> 856         Node* res =  gvn.transform(new MaxINode(a, b));</span>
<span class="line-added"> 857         assert(gvn.type(res)-&gt;is_int()-&gt;_lo &gt;= t-&gt;is_int()-&gt;_lo &amp;&amp; gvn.type(res)-&gt;is_int()-&gt;_hi &lt;= t-&gt;is_int()-&gt;_hi, &quot;type doesn&#39;t match&quot;);</span>
<span class="line-added"> 858         return res;</span>
<span class="line-added"> 859       } else {</span>
<span class="line-added"> 860         Node* cmp = gvn.transform(new CmpLNode(a, b));</span>
<span class="line-added"> 861         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 862         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));</span>
<span class="line-added"> 863       }</span>
<span class="line-added"> 864     } else {</span>
<span class="line-added"> 865       if (is_int) {</span>
<span class="line-added"> 866         Node* res =  gvn.transform(new MinINode(a, b));</span>
<span class="line-added"> 867         assert(gvn.type(res)-&gt;is_int()-&gt;_lo &gt;= t-&gt;is_int()-&gt;_lo &amp;&amp; gvn.type(res)-&gt;is_int()-&gt;_hi &lt;= t-&gt;is_int()-&gt;_hi, &quot;type doesn&#39;t match&quot;);</span>
<span class="line-added"> 868         return res;</span>
<span class="line-added"> 869       } else {</span>
<span class="line-added"> 870         Node* cmp = gvn.transform(new CmpLNode(b, a));</span>
<span class="line-added"> 871         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 872         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));</span>
<span class="line-added"> 873       }</span>
<span class="line-added"> 874     }</span>
<span class="line-added"> 875   } else {</span>
<span class="line-added"> 876     if (is_max) {</span>
<span class="line-added"> 877       if (is_int) {</span>
<span class="line-added"> 878         Node* cmp = gvn.transform(new CmpUNode(a, b));</span>
<span class="line-added"> 879         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 880         return gvn.transform(new CMoveINode(bol, a, b, t-&gt;is_int()));</span>
<span class="line-added"> 881       } else {</span>
<span class="line-added"> 882         Node* cmp = gvn.transform(new CmpULNode(a, b));</span>
<span class="line-added"> 883         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 884         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));</span>
<span class="line-added"> 885       }</span>
<span class="line-added"> 886     } else {</span>
<span class="line-added"> 887       if (is_int) {</span>
<span class="line-added"> 888         Node* cmp = gvn.transform(new CmpUNode(b, a));</span>
<span class="line-added"> 889         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 890         return gvn.transform(new CMoveINode(bol, a, b, t-&gt;is_int()));</span>
<span class="line-added"> 891       } else {</span>
<span class="line-added"> 892         Node* cmp = gvn.transform(new CmpULNode(b, a));</span>
<span class="line-added"> 893         Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 894         return gvn.transform(new CMoveLNode(bol, a, b, t-&gt;is_long()));</span>
<span class="line-added"> 895       }</span>
<span class="line-added"> 896     }</span>
<span class="line-added"> 897   }</span>
<span class="line-added"> 898 }</span>
<span class="line-added"> 899 </span>
<span class="line-added"> 900 Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN&amp; gvn) {</span>
<span class="line-added"> 901   bool is_int = gvn.type(a)-&gt;isa_int();</span>
<span class="line-added"> 902   assert(is_int || gvn.type(a)-&gt;isa_long(), &quot;int or long inputs&quot;);</span>
<span class="line-added"> 903   assert(is_int == (gvn.type(b)-&gt;isa_int() != NULL), &quot;inconsistent inputs&quot;);</span>
<span class="line-added"> 904   Node* zero = NULL;</span>
<span class="line-added"> 905   if (is_int) {</span>
<span class="line-added"> 906     zero = gvn.intcon(0);</span>
<span class="line-added"> 907   } else {</span>
<span class="line-added"> 908     zero = gvn.longcon(0);</span>
<span class="line-added"> 909   }</span>
<span class="line-added"> 910   if (is_max) {</span>
<span class="line-added"> 911     if (is_int) {</span>
<span class="line-added"> 912       Node* cmp = gvn.transform(new CmpINode(a, b));</span>
<span class="line-added"> 913       Node* sub = gvn.transform(new SubINode(a, b));</span>
<span class="line-added"> 914       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 915       return gvn.transform(new CMoveINode(bol, sub, zero, t-&gt;is_int()));</span>
<span class="line-added"> 916     } else {</span>
<span class="line-added"> 917       Node* cmp = gvn.transform(new CmpLNode(a, b));</span>
<span class="line-added"> 918       Node* sub = gvn.transform(new SubLNode(a, b));</span>
<span class="line-added"> 919       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 920       return gvn.transform(new CMoveLNode(bol, sub, zero, t-&gt;is_long()));</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922   } else {</span>
<span class="line-added"> 923     if (is_int) {</span>
<span class="line-added"> 924       Node* cmp = gvn.transform(new CmpINode(b, a));</span>
<span class="line-added"> 925       Node* sub = gvn.transform(new SubINode(a, b));</span>
<span class="line-added"> 926       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 927       return gvn.transform(new CMoveINode(bol, sub, zero, t-&gt;is_int()));</span>
<span class="line-added"> 928     } else {</span>
<span class="line-added"> 929       Node* cmp = gvn.transform(new CmpLNode(b, a));</span>
<span class="line-added"> 930       Node* sub = gvn.transform(new SubLNode(a, b));</span>
<span class="line-added"> 931       Node* bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
<span class="line-added"> 932       return gvn.transform(new CMoveLNode(bol, sub, zero, t-&gt;is_long()));</span>
<span class="line-added"> 933     }</span>
<span class="line-added"> 934   }</span>
<span class="line-added"> 935 }</span>
<span class="line-added"> 936 </span>
 937 //=============================================================================
 938 //------------------------------add_ring---------------------------------------
 939 // Supplied function returns the sum of the inputs.
 940 const Type *MaxINode::add_ring( const Type *t0, const Type *t1 ) const {
 941   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 942   const TypeInt *r1 = t1-&gt;is_int();
 943 
 944   // Otherwise just MAX them bits.
 945   return TypeInt::make( MAX2(r0-&gt;_lo,r1-&gt;_lo), MAX2(r0-&gt;_hi,r1-&gt;_hi), MAX2(r0-&gt;_widen,r1-&gt;_widen) );
 946 }
 947 
 948 //=============================================================================
 949 //------------------------------Idealize---------------------------------------
 950 // MINs show up in range-check loop limit calculations.  Look for
 951 // &quot;MIN2(x+c0,MIN2(y,x+c1))&quot;.  Pick the smaller constant: &quot;MIN2(x+c0,y)&quot;
 952 Node *MinINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 953   Node *progress = NULL;
 954   // Force a right-spline graph
 955   Node *l = in(1);
 956   Node *r = in(2);
</pre>
</td>
</tr>
</table>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
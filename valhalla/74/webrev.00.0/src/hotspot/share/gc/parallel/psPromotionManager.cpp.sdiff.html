<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psPromotionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../compiler/oopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c2/shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psPromotionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/parallel/psOldGen.hpp&quot;
 30 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 31 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;logging/logStream.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;memory/iterator.inline.hpp&quot;
 39 #include &quot;memory/memRegion.hpp&quot;
 40 #include &quot;memory/padded.inline.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;oops/access.inline.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/valueArrayKlass.inline.hpp&quot;
 45 
 46 PaddedEnd&lt;PSPromotionManager&gt;* PSPromotionManager::_manager_array = NULL;
<span class="line-modified"> 47 PSPromotionManager::OopStarTaskQueueSet* PSPromotionManager::_stack_array_depth = NULL;</span>
 48 PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;
 49 PSOldGen*                      PSPromotionManager::_old_gen = NULL;
 50 MutableSpace*                  PSPromotionManager::_young_space = NULL;
 51 
 52 void PSPromotionManager::initialize() {
 53   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 54 
 55   _old_gen = heap-&gt;old_gen();
 56   _young_space = heap-&gt;young_gen()-&gt;to_space();
 57 
 58   const uint promotion_manager_num = ParallelGCThreads + 1;
 59 
 60   // To prevent false sharing, we pad the PSPromotionManagers
 61   // and make sure that the first instance starts at a cache line.
 62   assert(_manager_array == NULL, &quot;Attempt to initialize twice&quot;);
 63   _manager_array = PaddedArray&lt;PSPromotionManager, mtGC&gt;::create_unfreeable(promotion_manager_num);
 64 
<span class="line-modified"> 65   _stack_array_depth = new OopStarTaskQueueSet(ParallelGCThreads);</span>
 66 
 67   // Create and register the PSPromotionManager(s) for the worker threads.
 68   for(uint i=0; i&lt;ParallelGCThreads; i++) {
 69     stack_array_depth()-&gt;register_queue(i, _manager_array[i].claimed_stack_depth());
 70   }
 71   // The VMThread gets its own PSPromotionManager, which is not available
 72   // for work stealing.
 73 
 74   assert(_preserved_marks_set == NULL, &quot;Attempt to initialize twice&quot;);
 75   _preserved_marks_set = new PreservedMarksSet(true /* in_c_heap */);
 76   _preserved_marks_set-&gt;init(promotion_manager_num);
 77   for (uint i = 0; i &lt; promotion_manager_num; i += 1) {
 78     _manager_array[i].register_preserved_marks(_preserved_marks_set-&gt;get(i));
 79   }
 80 }
 81 
 82 // Helper functions to get around the circular dependency between
 83 // psScavenge.inline.hpp and psPromotionManager.inline.hpp.
 84 bool PSPromotionManager::should_scavenge(oop* p, bool check_to_space) {
 85   return PSScavenge::should_scavenge(p, check_to_space);
</pre>
<hr />
<pre>
118     PSPromotionManager* manager = manager_array(i);
119     assert(manager-&gt;claimed_stack_depth()-&gt;is_empty(), &quot;should be empty&quot;);
120     if (manager-&gt;_promotion_failed_info.has_failed()) {
121       gc_tracer.report_promotion_failed(manager-&gt;_promotion_failed_info);
122       promotion_failure_occurred = true;
123     }
124     manager-&gt;flush_labs();
125   }
126   if (!promotion_failure_occurred) {
127     // If there was no promotion failure, the preserved mark stacks
128     // should be empty.
129     _preserved_marks_set-&gt;assert_empty();
130   }
131   return promotion_failure_occurred;
132 }
133 
134 #if TASKQUEUE_STATS
135 void
136 PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {
137   #define FMT &quot; &quot; SIZE_FORMAT_W(10)
<span class="line-modified">138   out-&gt;print_cr(&quot;%3u&quot; FMT FMT FMT FMT, i, _masked_pushes, _masked_steals,</span>

139                 _arrays_chunked, _array_chunks_processed);
140   #undef FMT
141 }
142 
143 static const char* const pm_stats_hdr[] = {
<span class="line-modified">144   &quot;    --------masked-------     arrays      array&quot;,</span>
145   &quot;thr       push      steal    chunked     chunks&quot;,
146   &quot;--- ---------- ---------- ---------- ----------&quot;
147 };
148 
149 void
150 PSPromotionManager::print_taskqueue_stats() {
151   if (!log_is_enabled(Trace, gc, task, stats)) {
152     return;
153   }
154   Log(gc, task, stats) log;
155   ResourceMark rm;
156   LogStream ls(log.trace());
157   outputStream* out = &amp;ls;
158   out-&gt;print_cr(&quot;== GC Tasks Stats, GC %3d&quot;,
159                 ParallelScavengeHeap::heap()-&gt;total_collections());
160 
161   TaskQueueStats totals;
162   out-&gt;print(&quot;thr &quot;); TaskQueueStats::print_header(1, out); out-&gt;cr();
163   out-&gt;print(&quot;--- &quot;); TaskQueueStats::print_header(2, out); out-&gt;cr();
164   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
165     TaskQueueStats&amp; next = manager_array(i)-&gt;_claimed_stack_depth.stats;
166     out-&gt;print(&quot;%3d &quot;, i); next.print(out); out-&gt;cr();
167     totals += next;
168   }
169   out-&gt;print(&quot;tot &quot;); totals.print(out); out-&gt;cr();
170 
171   const uint hlines = sizeof(pm_stats_hdr) / sizeof(pm_stats_hdr[0]);
172   for (uint i = 0; i &lt; hlines; ++i) out-&gt;print_cr(&quot;%s&quot;, pm_stats_hdr[i]);
173   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
174     manager_array(i)-&gt;print_local_stats(out, i);
175   }
176 }
177 
178 void
179 PSPromotionManager::reset_stats() {
180   claimed_stack_depth()-&gt;stats.reset();
<span class="line-modified">181   _masked_pushes = _masked_steals = 0;</span>
182   _arrays_chunked = _array_chunks_processed = 0;
183 }
184 #endif // TASKQUEUE_STATS
185 
186 PSPromotionManager::PSPromotionManager() {
187   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
188 
189   // We set the old lab&#39;s start array.
190   _old_lab.set_start_array(old_gen()-&gt;start_array());
191 
192   uint queue_size;
193   claimed_stack_depth()-&gt;initialize();
194   queue_size = claimed_stack_depth()-&gt;max_elems();
195 
196   _totally_drain = (ParallelGCThreads == 1) || (GCDrainStackTargetSize == 0);
197   if (_totally_drain) {
198     _target_stack_size = 0;
199   } else {
200     // don&#39;t let the target stack size to be more than 1/4 of the entries
201     _target_stack_size = (uint) MIN2((uint) GCDrainStackTargetSize,
</pre>
<hr />
<pre>
233 }
234 
235 void PSPromotionManager::register_preserved_marks(PreservedMarks* preserved_marks) {
236   assert(_preserved_marks == NULL, &quot;do not set it twice&quot;);
237   _preserved_marks = preserved_marks;
238 }
239 
240 void PSPromotionManager::restore_preserved_marks() {
241   _preserved_marks_set-&gt;restore(&amp;ParallelScavengeHeap::heap()-&gt;workers());
242 }
243 
244 void PSPromotionManager::drain_stacks_depth(bool totally_drain) {
245   totally_drain = totally_drain || _totally_drain;
246 
247 #ifdef ASSERT
248   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
249   MutableSpace* to_space = heap-&gt;young_gen()-&gt;to_space();
250   MutableSpace* old_space = heap-&gt;old_gen()-&gt;object_space();
251 #endif /* ASSERT */
252 
<span class="line-modified">253   OopStarTaskQueue* const tq = claimed_stack_depth();</span>
254   do {
<span class="line-modified">255     StarTask p;</span>
256 
257     // Drain overflow stack first, so other threads can steal from
258     // claimed stack while we work.
<span class="line-modified">259     while (tq-&gt;pop_overflow(p)) {</span>
<span class="line-modified">260       process_popped_location_depth(p);</span>
261     }
262 
263     if (totally_drain) {
<span class="line-modified">264       while (tq-&gt;pop_local(p)) {</span>
<span class="line-modified">265         process_popped_location_depth(p);</span>
266       }
267     } else {
<span class="line-modified">268       while (tq-&gt;size() &gt; _target_stack_size &amp;&amp; tq-&gt;pop_local(p)) {</span>
<span class="line-modified">269         process_popped_location_depth(p);</span>
270       }
271     }
272   } while ((totally_drain &amp;&amp; !tq-&gt;taskqueue_empty()) || !tq-&gt;overflow_empty());
273 
274   assert(!totally_drain || tq-&gt;taskqueue_empty(), &quot;Sanity&quot;);
275   assert(totally_drain || tq-&gt;size() &lt;= _target_stack_size, &quot;Sanity&quot;);
276   assert(tq-&gt;overflow_empty(), &quot;Sanity&quot;);
277 }
278 
279 void PSPromotionManager::flush_labs() {
280   assert(stacks_empty(), &quot;Attempt to flush lab with live stack&quot;);
281 
282   // If either promotion lab fills up, we can flush the
283   // lab but not refill it, so check first.
284   assert(!_young_lab.is_flushed() || _young_gen_is_full, &quot;Sanity&quot;);
285   if (!_young_lab.is_flushed())
286     _young_lab.flush();
287 
288   assert(!_old_lab.is_flushed() || _old_gen_is_full, &quot;Sanity&quot;);
289   if (!_old_lab.is_flushed())
</pre>
<hr />
<pre>
293   if (_young_gen_is_full) {
294     PSScavenge::set_survivor_overflow(true);
295   }
296 }
297 
298 template &lt;class T&gt; void PSPromotionManager::process_array_chunk_work(
299                                                  oop obj,
300                                                  int start, int end) {
301   assert(start &lt;= end, &quot;invariant&quot;);
302   T* const base      = (T*)objArrayOop(obj)-&gt;base();
303   T* p               = base + start;
304   T* const chunk_end = base + end;
305   while (p &lt; chunk_end) {
306     if (PSScavenge::should_scavenge(p)) {
307       claim_or_forward_depth(p);
308     }
309     ++p;
310   }
311 }
312 
<span class="line-modified">313 void PSPromotionManager::process_array_chunk(oop old) {</span>
314   assert(PSChunkLargeArrays, &quot;invariant&quot;);


315   assert(old-&gt;is_objArray(), &quot;invariant&quot;);
316   assert(old-&gt;is_forwarded(), &quot;invariant&quot;);
317 
318   TASKQUEUE_STATS_ONLY(++_array_chunks_processed);
319 
320   oop const obj = old-&gt;forwardee();
321 
322   int start;
323   int const end = arrayOop(old)-&gt;length();
324   if (end &gt; (int) _min_array_size_for_chunking) {
325     // we&#39;ll chunk more
326     start = end - _array_chunk_size;
327     assert(start &gt; 0, &quot;invariant&quot;);
328     arrayOop(old)-&gt;set_length(start);
<span class="line-modified">329     push_depth(mask_chunked_array_oop(old));</span>
<span class="line-modified">330     TASKQUEUE_STATS_ONLY(++_masked_pushes);</span>
331   } else {
332     // this is the final chunk for this array
333     start = 0;
334     int const actual_length = arrayOop(obj)-&gt;length();
335     arrayOop(old)-&gt;set_length(actual_length);
336   }
337 
338   if (UseCompressedOops) {
339     process_array_chunk_work&lt;narrowOop&gt;(obj, start, end);
340   } else {
341     process_array_chunk_work&lt;oop&gt;(obj, start, end);
342   }
343 }
344 
345 oop PSPromotionManager::oop_promotion_failed(oop obj, markWord obj_mark) {
346   assert(_old_gen_is_full || PromotionFailureALot, &quot;Sanity&quot;);
347 
348   // Attempt to CAS in the header.
349   // This tests if the header is still the same as when
350   // this started.  If it is the same (i.e., no forwarding
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 28 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 29 #include &quot;gc/parallel/psOldGen.hpp&quot;
 30 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
 31 #include &quot;gc/parallel/psScavenge.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTrace.hpp&quot;
 33 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;logging/logStream.hpp&quot;
 37 #include &quot;memory/allocation.inline.hpp&quot;
 38 #include &quot;memory/iterator.inline.hpp&quot;
 39 #include &quot;memory/memRegion.hpp&quot;
 40 #include &quot;memory/padded.inline.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;oops/access.inline.hpp&quot;
 43 #include &quot;oops/compressedOops.inline.hpp&quot;
 44 #include &quot;oops/valueArrayKlass.inline.hpp&quot;
 45 
 46 PaddedEnd&lt;PSPromotionManager&gt;* PSPromotionManager::_manager_array = NULL;
<span class="line-modified"> 47 PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = NULL;</span>
 48 PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;
 49 PSOldGen*                      PSPromotionManager::_old_gen = NULL;
 50 MutableSpace*                  PSPromotionManager::_young_space = NULL;
 51 
 52 void PSPromotionManager::initialize() {
 53   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
 54 
 55   _old_gen = heap-&gt;old_gen();
 56   _young_space = heap-&gt;young_gen()-&gt;to_space();
 57 
 58   const uint promotion_manager_num = ParallelGCThreads + 1;
 59 
 60   // To prevent false sharing, we pad the PSPromotionManagers
 61   // and make sure that the first instance starts at a cache line.
 62   assert(_manager_array == NULL, &quot;Attempt to initialize twice&quot;);
 63   _manager_array = PaddedArray&lt;PSPromotionManager, mtGC&gt;::create_unfreeable(promotion_manager_num);
 64 
<span class="line-modified"> 65   _stack_array_depth = new PSScannerTasksQueueSet(ParallelGCThreads);</span>
 66 
 67   // Create and register the PSPromotionManager(s) for the worker threads.
 68   for(uint i=0; i&lt;ParallelGCThreads; i++) {
 69     stack_array_depth()-&gt;register_queue(i, _manager_array[i].claimed_stack_depth());
 70   }
 71   // The VMThread gets its own PSPromotionManager, which is not available
 72   // for work stealing.
 73 
 74   assert(_preserved_marks_set == NULL, &quot;Attempt to initialize twice&quot;);
 75   _preserved_marks_set = new PreservedMarksSet(true /* in_c_heap */);
 76   _preserved_marks_set-&gt;init(promotion_manager_num);
 77   for (uint i = 0; i &lt; promotion_manager_num; i += 1) {
 78     _manager_array[i].register_preserved_marks(_preserved_marks_set-&gt;get(i));
 79   }
 80 }
 81 
 82 // Helper functions to get around the circular dependency between
 83 // psScavenge.inline.hpp and psPromotionManager.inline.hpp.
 84 bool PSPromotionManager::should_scavenge(oop* p, bool check_to_space) {
 85   return PSScavenge::should_scavenge(p, check_to_space);
</pre>
<hr />
<pre>
118     PSPromotionManager* manager = manager_array(i);
119     assert(manager-&gt;claimed_stack_depth()-&gt;is_empty(), &quot;should be empty&quot;);
120     if (manager-&gt;_promotion_failed_info.has_failed()) {
121       gc_tracer.report_promotion_failed(manager-&gt;_promotion_failed_info);
122       promotion_failure_occurred = true;
123     }
124     manager-&gt;flush_labs();
125   }
126   if (!promotion_failure_occurred) {
127     // If there was no promotion failure, the preserved mark stacks
128     // should be empty.
129     _preserved_marks_set-&gt;assert_empty();
130   }
131   return promotion_failure_occurred;
132 }
133 
134 #if TASKQUEUE_STATS
135 void
136 PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {
137   #define FMT &quot; &quot; SIZE_FORMAT_W(10)
<span class="line-modified">138   out-&gt;print_cr(&quot;%3u&quot; FMT FMT FMT FMT,</span>
<span class="line-added">139                 i, _array_chunk_pushes, _array_chunk_steals,</span>
140                 _arrays_chunked, _array_chunks_processed);
141   #undef FMT
142 }
143 
144 static const char* const pm_stats_hdr[] = {
<span class="line-modified">145   &quot;    ----partial array----     arrays      array&quot;,</span>
146   &quot;thr       push      steal    chunked     chunks&quot;,
147   &quot;--- ---------- ---------- ---------- ----------&quot;
148 };
149 
150 void
151 PSPromotionManager::print_taskqueue_stats() {
152   if (!log_is_enabled(Trace, gc, task, stats)) {
153     return;
154   }
155   Log(gc, task, stats) log;
156   ResourceMark rm;
157   LogStream ls(log.trace());
158   outputStream* out = &amp;ls;
159   out-&gt;print_cr(&quot;== GC Tasks Stats, GC %3d&quot;,
160                 ParallelScavengeHeap::heap()-&gt;total_collections());
161 
162   TaskQueueStats totals;
163   out-&gt;print(&quot;thr &quot;); TaskQueueStats::print_header(1, out); out-&gt;cr();
164   out-&gt;print(&quot;--- &quot;); TaskQueueStats::print_header(2, out); out-&gt;cr();
165   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
166     TaskQueueStats&amp; next = manager_array(i)-&gt;_claimed_stack_depth.stats;
167     out-&gt;print(&quot;%3d &quot;, i); next.print(out); out-&gt;cr();
168     totals += next;
169   }
170   out-&gt;print(&quot;tot &quot;); totals.print(out); out-&gt;cr();
171 
172   const uint hlines = sizeof(pm_stats_hdr) / sizeof(pm_stats_hdr[0]);
173   for (uint i = 0; i &lt; hlines; ++i) out-&gt;print_cr(&quot;%s&quot;, pm_stats_hdr[i]);
174   for (uint i = 0; i &lt; ParallelGCThreads + 1; ++i) {
175     manager_array(i)-&gt;print_local_stats(out, i);
176   }
177 }
178 
179 void
180 PSPromotionManager::reset_stats() {
181   claimed_stack_depth()-&gt;stats.reset();
<span class="line-modified">182   _array_chunk_pushes = _array_chunk_steals = 0;</span>
183   _arrays_chunked = _array_chunks_processed = 0;
184 }
185 #endif // TASKQUEUE_STATS
186 
187 PSPromotionManager::PSPromotionManager() {
188   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
189 
190   // We set the old lab&#39;s start array.
191   _old_lab.set_start_array(old_gen()-&gt;start_array());
192 
193   uint queue_size;
194   claimed_stack_depth()-&gt;initialize();
195   queue_size = claimed_stack_depth()-&gt;max_elems();
196 
197   _totally_drain = (ParallelGCThreads == 1) || (GCDrainStackTargetSize == 0);
198   if (_totally_drain) {
199     _target_stack_size = 0;
200   } else {
201     // don&#39;t let the target stack size to be more than 1/4 of the entries
202     _target_stack_size = (uint) MIN2((uint) GCDrainStackTargetSize,
</pre>
<hr />
<pre>
234 }
235 
236 void PSPromotionManager::register_preserved_marks(PreservedMarks* preserved_marks) {
237   assert(_preserved_marks == NULL, &quot;do not set it twice&quot;);
238   _preserved_marks = preserved_marks;
239 }
240 
241 void PSPromotionManager::restore_preserved_marks() {
242   _preserved_marks_set-&gt;restore(&amp;ParallelScavengeHeap::heap()-&gt;workers());
243 }
244 
245 void PSPromotionManager::drain_stacks_depth(bool totally_drain) {
246   totally_drain = totally_drain || _totally_drain;
247 
248 #ifdef ASSERT
249   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
250   MutableSpace* to_space = heap-&gt;young_gen()-&gt;to_space();
251   MutableSpace* old_space = heap-&gt;old_gen()-&gt;object_space();
252 #endif /* ASSERT */
253 
<span class="line-modified">254   PSScannerTasksQueue* const tq = claimed_stack_depth();</span>
255   do {
<span class="line-modified">256     ScannerTask task;</span>
257 
258     // Drain overflow stack first, so other threads can steal from
259     // claimed stack while we work.
<span class="line-modified">260     while (tq-&gt;pop_overflow(task)) {</span>
<span class="line-modified">261       process_popped_location_depth(task);</span>
262     }
263 
264     if (totally_drain) {
<span class="line-modified">265       while (tq-&gt;pop_local(task)) {</span>
<span class="line-modified">266         process_popped_location_depth(task);</span>
267       }
268     } else {
<span class="line-modified">269       while (tq-&gt;size() &gt; _target_stack_size &amp;&amp; tq-&gt;pop_local(task)) {</span>
<span class="line-modified">270         process_popped_location_depth(task);</span>
271       }
272     }
273   } while ((totally_drain &amp;&amp; !tq-&gt;taskqueue_empty()) || !tq-&gt;overflow_empty());
274 
275   assert(!totally_drain || tq-&gt;taskqueue_empty(), &quot;Sanity&quot;);
276   assert(totally_drain || tq-&gt;size() &lt;= _target_stack_size, &quot;Sanity&quot;);
277   assert(tq-&gt;overflow_empty(), &quot;Sanity&quot;);
278 }
279 
280 void PSPromotionManager::flush_labs() {
281   assert(stacks_empty(), &quot;Attempt to flush lab with live stack&quot;);
282 
283   // If either promotion lab fills up, we can flush the
284   // lab but not refill it, so check first.
285   assert(!_young_lab.is_flushed() || _young_gen_is_full, &quot;Sanity&quot;);
286   if (!_young_lab.is_flushed())
287     _young_lab.flush();
288 
289   assert(!_old_lab.is_flushed() || _old_gen_is_full, &quot;Sanity&quot;);
290   if (!_old_lab.is_flushed())
</pre>
<hr />
<pre>
294   if (_young_gen_is_full) {
295     PSScavenge::set_survivor_overflow(true);
296   }
297 }
298 
299 template &lt;class T&gt; void PSPromotionManager::process_array_chunk_work(
300                                                  oop obj,
301                                                  int start, int end) {
302   assert(start &lt;= end, &quot;invariant&quot;);
303   T* const base      = (T*)objArrayOop(obj)-&gt;base();
304   T* p               = base + start;
305   T* const chunk_end = base + end;
306   while (p &lt; chunk_end) {
307     if (PSScavenge::should_scavenge(p)) {
308       claim_or_forward_depth(p);
309     }
310     ++p;
311   }
312 }
313 
<span class="line-modified">314 void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {</span>
315   assert(PSChunkLargeArrays, &quot;invariant&quot;);
<span class="line-added">316 </span>
<span class="line-added">317   oop old = task.to_source_array();</span>
318   assert(old-&gt;is_objArray(), &quot;invariant&quot;);
319   assert(old-&gt;is_forwarded(), &quot;invariant&quot;);
320 
321   TASKQUEUE_STATS_ONLY(++_array_chunks_processed);
322 
323   oop const obj = old-&gt;forwardee();
324 
325   int start;
326   int const end = arrayOop(old)-&gt;length();
327   if (end &gt; (int) _min_array_size_for_chunking) {
328     // we&#39;ll chunk more
329     start = end - _array_chunk_size;
330     assert(start &gt; 0, &quot;invariant&quot;);
331     arrayOop(old)-&gt;set_length(start);
<span class="line-modified">332     push_depth(ScannerTask(PartialArrayScanTask(old)));</span>
<span class="line-modified">333     TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);</span>
334   } else {
335     // this is the final chunk for this array
336     start = 0;
337     int const actual_length = arrayOop(obj)-&gt;length();
338     arrayOop(old)-&gt;set_length(actual_length);
339   }
340 
341   if (UseCompressedOops) {
342     process_array_chunk_work&lt;narrowOop&gt;(obj, start, end);
343   } else {
344     process_array_chunk_work&lt;oop&gt;(obj, start, end);
345   }
346 }
347 
348 oop PSPromotionManager::oop_promotion_failed(oop obj, markWord obj_mark) {
349   assert(_old_gen_is_full || PromotionFailureALot, &quot;Sanity&quot;);
350 
351   // Attempt to CAS in the header.
352   // This tests if the header is still the same as when
353   // this started.  If it is the same (i.e., no forwarding
</pre>
</td>
</tr>
</table>
<center><a href="../../compiler/oopMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/c2/shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2304   // jsr/ret pairs which are not associated with finally clauses and
2305   // do not have exception handlers in the containing method, and are
2306   // therefore not caught early enough to abort the inlining without
2307   // corrupting the graph. (We currently bail out with a non-empty
2308   // stack at a ret in these situations.)
2309   CHECK_BAILOUT();
2310 
2311   // inlining not successful =&gt; standard invoke
2312   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2313   ValueStack* state_before = copy_state_exhandling();
2314 
2315   // The bytecode (code) might change in this method so we are checking this very late.
2316   const bool has_receiver =
2317     code == Bytecodes::_invokespecial   ||
2318     code == Bytecodes::_invokevirtual   ||
2319     code == Bytecodes::_invokeinterface;
2320   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2321   Value recv = has_receiver ? apop() : NULL;
2322   int vtable_index = Method::invalid_vtable_index;
2323 
<span class="line-removed">2324 #ifdef SPARC</span>
<span class="line-removed">2325   // Currently only supported on Sparc.</span>
<span class="line-removed">2326   // The UseInlineCaches only controls dispatch to invokevirtuals for</span>
<span class="line-removed">2327   // loaded classes which we weren&#39;t able to statically bind.</span>
<span class="line-removed">2328   if (!UseInlineCaches &amp;&amp; target-&gt;is_loaded() &amp;&amp; code == Bytecodes::_invokevirtual</span>
<span class="line-removed">2329       &amp;&amp; !target-&gt;can_be_statically_bound()) {</span>
<span class="line-removed">2330     // Find a vtable index if one is available</span>
<span class="line-removed">2331     // For arrays, callee_holder is Object. Resolving the call with</span>
<span class="line-removed">2332     // Object would allow an illegal call to finalize() on an</span>
<span class="line-removed">2333     // array. We use holder instead: illegal calls to finalize() won&#39;t</span>
<span class="line-removed">2334     // be compiled as vtable calls (IC call resolution will catch the</span>
<span class="line-removed">2335     // illegal call) and the few legal calls on array types won&#39;t be</span>
<span class="line-removed">2336     // either.</span>
<span class="line-removed">2337     vtable_index = target-&gt;resolve_vtable_index(calling_klass, holder);</span>
<span class="line-removed">2338   }</span>
<span class="line-removed">2339 #endif</span>
<span class="line-removed">2340 </span>
2341   // A null check is required here (when there is a receiver) for any of the following cases
2342   // - invokespecial, always need a null check.
2343   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2344   //   and require null checking. If the target is loaded a null check is emitted here.
2345   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2346   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2347   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2348   //   potentially fail, and can&#39;t have the null check before the resolution.)
2349   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2350   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2351   //
2352   // Normal invokevirtual will perform the null check during lookup
2353 
2354   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2355       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2356 
2357   if (need_null_check) {
2358     if (recv != NULL) {
2359       null_check(recv);
2360     }
</pre>
</td>
<td>
<hr />
<pre>
2304   // jsr/ret pairs which are not associated with finally clauses and
2305   // do not have exception handlers in the containing method, and are
2306   // therefore not caught early enough to abort the inlining without
2307   // corrupting the graph. (We currently bail out with a non-empty
2308   // stack at a ret in these situations.)
2309   CHECK_BAILOUT();
2310 
2311   // inlining not successful =&gt; standard invoke
2312   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2313   ValueStack* state_before = copy_state_exhandling();
2314 
2315   // The bytecode (code) might change in this method so we are checking this very late.
2316   const bool has_receiver =
2317     code == Bytecodes::_invokespecial   ||
2318     code == Bytecodes::_invokevirtual   ||
2319     code == Bytecodes::_invokeinterface;
2320   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2321   Value recv = has_receiver ? apop() : NULL;
2322   int vtable_index = Method::invalid_vtable_index;
2323 

















2324   // A null check is required here (when there is a receiver) for any of the following cases
2325   // - invokespecial, always need a null check.
2326   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2327   //   and require null checking. If the target is loaded a null check is emitted here.
2328   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2329   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2330   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2331   //   potentially fail, and can&#39;t have the null check before the resolution.)
2332   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2333   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2334   //
2335   // Normal invokevirtual will perform the null check during lookup
2336 
2337   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2338       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2339 
2340   if (need_null_check) {
2341     if (recv != NULL) {
2342       null_check(recv);
2343     }
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
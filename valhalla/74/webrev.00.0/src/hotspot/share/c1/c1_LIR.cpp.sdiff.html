<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 475 // LIR_OpLabel
 476     case lir_label:                    // result and info always invalid
 477     {
 478       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 479       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 480       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 481       break;
 482     }
 483 
 484 
 485 // LIR_Op1
 486     case lir_fxch:           // input always valid, result and info always invalid
 487     case lir_fld:            // input always valid, result and info always invalid
 488     case lir_push:           // input always valid, result and info always invalid
 489     case lir_pop:            // input always valid, result and info always invalid
 490     case lir_return:         // input always valid, result and info always invalid
 491     case lir_leal:           // input and result always valid, info always invalid
 492     case lir_monaddr:        // input and result always valid, info always invalid
 493     case lir_null_check:     // input and info always valid, result always invalid
 494     case lir_move:           // input and result always valid, may have info
<span class="line-removed"> 495     case lir_pack64:         // input and result always valid</span>
<span class="line-removed"> 496     case lir_unpack64:       // input and result always valid</span>
 497     {
 498       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 499       LIR_Op1* op1 = (LIR_Op1*)op;
 500 
 501       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 502       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 503       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 504 
 505       break;
 506     }
 507 
 508     case lir_safepoint:
 509     {
 510       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 511       LIR_Op1* op1 = (LIR_Op1*)op;
 512 
 513       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 514       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 515       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 516 
</pre>
<hr />
<pre>
1802      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;
1803      // LIR_Op1
1804      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1805      case lir_fld:                   s = &quot;fld&quot;;           break;
1806      case lir_push:                  s = &quot;push&quot;;          break;
1807      case lir_pop:                   s = &quot;pop&quot;;           break;
1808      case lir_null_check:            s = &quot;null_check&quot;;    break;
1809      case lir_return:                s = &quot;return&quot;;        break;
1810      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1811      case lir_leal:                  s = &quot;leal&quot;;          break;
1812      case lir_branch:                s = &quot;branch&quot;;        break;
1813      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1814      case lir_move:                  s = &quot;move&quot;;          break;
1815      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1816      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1817      case lir_throw:                 s = &quot;throw&quot;;         break;
1818      case lir_unwind:                s = &quot;unwind&quot;;        break;
1819      case lir_convert:               s = &quot;convert&quot;;       break;
1820      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1821      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
<span class="line-removed">1822      case lir_pack64:                s = &quot;pack64&quot;;        break;</span>
<span class="line-removed">1823      case lir_unpack64:              s = &quot;unpack64&quot;;      break;</span>
1824      // LIR_Op2
1825      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1826      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1827      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1828      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1829      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1830      case lir_add:                   s = &quot;add&quot;;           break;
1831      case lir_sub:                   s = &quot;sub&quot;;           break;
1832      case lir_mul:                   s = &quot;mul&quot;;           break;
1833      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1834      case lir_div:                   s = &quot;div&quot;;           break;
1835      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1836      case lir_rem:                   s = &quot;rem&quot;;           break;
1837      case lir_abs:                   s = &quot;abs&quot;;           break;
1838      case lir_neg:                   s = &quot;neg&quot;;           break;
1839      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1840      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1841      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1842      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1843      case lir_shl:                   s = &quot;shift_left&quot;;    break;
</pre>
</td>
<td>
<hr />
<pre>
 475 // LIR_OpLabel
 476     case lir_label:                    // result and info always invalid
 477     {
 478       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 479       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 480       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 481       break;
 482     }
 483 
 484 
 485 // LIR_Op1
 486     case lir_fxch:           // input always valid, result and info always invalid
 487     case lir_fld:            // input always valid, result and info always invalid
 488     case lir_push:           // input always valid, result and info always invalid
 489     case lir_pop:            // input always valid, result and info always invalid
 490     case lir_return:         // input always valid, result and info always invalid
 491     case lir_leal:           // input and result always valid, info always invalid
 492     case lir_monaddr:        // input and result always valid, info always invalid
 493     case lir_null_check:     // input and info always valid, result always invalid
 494     case lir_move:           // input and result always valid, may have info


 495     {
 496       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 497       LIR_Op1* op1 = (LIR_Op1*)op;
 498 
 499       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 500       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 501       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 502 
 503       break;
 504     }
 505 
 506     case lir_safepoint:
 507     {
 508       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 509       LIR_Op1* op1 = (LIR_Op1*)op;
 510 
 511       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 512       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 513       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 514 
</pre>
<hr />
<pre>
1800      case lir_check_orig_pc:         s = &quot;check_orig_pc&quot;; break;
1801      // LIR_Op1
1802      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1803      case lir_fld:                   s = &quot;fld&quot;;           break;
1804      case lir_push:                  s = &quot;push&quot;;          break;
1805      case lir_pop:                   s = &quot;pop&quot;;           break;
1806      case lir_null_check:            s = &quot;null_check&quot;;    break;
1807      case lir_return:                s = &quot;return&quot;;        break;
1808      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1809      case lir_leal:                  s = &quot;leal&quot;;          break;
1810      case lir_branch:                s = &quot;branch&quot;;        break;
1811      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1812      case lir_move:                  s = &quot;move&quot;;          break;
1813      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1814      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1815      case lir_throw:                 s = &quot;throw&quot;;         break;
1816      case lir_unwind:                s = &quot;unwind&quot;;        break;
1817      case lir_convert:               s = &quot;convert&quot;;       break;
1818      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1819      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;


1820      // LIR_Op2
1821      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1822      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1823      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1824      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1825      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1826      case lir_add:                   s = &quot;add&quot;;           break;
1827      case lir_sub:                   s = &quot;sub&quot;;           break;
1828      case lir_mul:                   s = &quot;mul&quot;;           break;
1829      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1830      case lir_div:                   s = &quot;div&quot;;           break;
1831      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1832      case lir_rem:                   s = &quot;rem&quot;;           break;
1833      case lir_abs:                   s = &quot;abs&quot;;           break;
1834      case lir_neg:                   s = &quot;neg&quot;;           break;
1835      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1836      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1837      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1838      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1839      case lir_shl:                   s = &quot;shift_left&quot;;    break;
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
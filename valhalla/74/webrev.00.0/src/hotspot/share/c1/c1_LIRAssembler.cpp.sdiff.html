<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIRAssembler.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRAssembler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
565 
566     case lir_leal:
567       leal(op-&gt;in_opr(), op-&gt;result_opr(), op-&gt;patch_code(), op-&gt;info());
568       break;
569 
570     case lir_null_check: {
571       ImplicitNullCheckStub* stub = add_debug_info_for_null_check_here(op-&gt;info());
572 
573       if (op-&gt;in_opr()-&gt;is_single_cpu()) {
574         _masm-&gt;null_check(op-&gt;in_opr()-&gt;as_register(), stub-&gt;entry());
575       } else {
576         Unimplemented();
577       }
578       break;
579     }
580 
581     case lir_monaddr:
582       monitor_address(op-&gt;in_opr()-&gt;as_constant_ptr()-&gt;as_jint(), op-&gt;result_opr());
583       break;
584 
<span class="line-removed">585 #ifdef SPARC</span>
<span class="line-removed">586     case lir_pack64:</span>
<span class="line-removed">587       pack64(op-&gt;in_opr(), op-&gt;result_opr());</span>
<span class="line-removed">588       break;</span>
<span class="line-removed">589 </span>
<span class="line-removed">590     case lir_unpack64:</span>
<span class="line-removed">591       unpack64(op-&gt;in_opr(), op-&gt;result_opr());</span>
<span class="line-removed">592       break;</span>
<span class="line-removed">593 #endif</span>
<span class="line-removed">594 </span>
595     case lir_unwind:
596       unwind_op(op-&gt;in_opr());
597       break;
598 
599     default:
600       Unimplemented();
601       break;
602   }
603 }
604 
605 void LIR_Assembler::add_scalarized_entry_info(int pc_offset) {
606   flush_debug_info(pc_offset);
607   DebugInformationRecorder* debug_info = compilation()-&gt;debug_info_recorder();
608   // The VEP and VVEP(RO) of a C1-compiled method call buffer_value_args_xxx()
609   // before doing any argument shuffling. This call may cause GC. When GC happens,
610   // all the parameters are still as passed by the caller, so we just use
611   // map-&gt;set_include_argument_oops() inside frame::sender_for_compiled_frame(RegisterMap* map).
612   // There&#39;s no need to build a GC map here.
613   OopMap* oop_map = new OopMap(0, 0);
614   debug_info-&gt;add_safepoint(pc_offset, oop_map);
</pre>
<hr />
<pre>
956   } else if (src-&gt;is_address()) {
957     mem2reg(src, dest, type, patch_code, info, wide, unaligned);
958 
959   } else {
960     ShouldNotReachHere();
961   }
962 }
963 
964 
965 void LIR_Assembler::verify_oop_map(CodeEmitInfo* info) {
966 #ifndef PRODUCT
967   if (VerifyOops) {
968     OopMapStream s(info-&gt;oop_map());
969     while (!s.is_done()) {
970       OopMapValue v = s.current();
971       if (v.is_oop()) {
972         VMReg r = v.reg();
973         if (!r-&gt;is_stack()) {
974           stringStream st;
975           st.print(&quot;bad oop %s at %d&quot;, r-&gt;as_Register()-&gt;name(), _masm-&gt;offset());
<span class="line-removed">976 #ifdef SPARC</span>
<span class="line-removed">977           _masm-&gt;_verify_oop(r-&gt;as_Register(), os::strdup(st.as_string(), mtCompiler), __FILE__, __LINE__);</span>
<span class="line-removed">978 #else</span>
<span class="line-removed">979           _masm-&gt;verify_oop(r-&gt;as_Register());</span>
980 #endif
981         } else {
982           _masm-&gt;verify_stack_oop(r-&gt;reg2stack() * VMRegImpl::stack_slot_size);
983         }
984       }
985       check_codespace();
986       CHECK_BAILOUT();
987 
988       s.next();
989     }
990   }
991 #endif
992 }
</pre>
</td>
<td>
<hr />
<pre>
565 
566     case lir_leal:
567       leal(op-&gt;in_opr(), op-&gt;result_opr(), op-&gt;patch_code(), op-&gt;info());
568       break;
569 
570     case lir_null_check: {
571       ImplicitNullCheckStub* stub = add_debug_info_for_null_check_here(op-&gt;info());
572 
573       if (op-&gt;in_opr()-&gt;is_single_cpu()) {
574         _masm-&gt;null_check(op-&gt;in_opr()-&gt;as_register(), stub-&gt;entry());
575       } else {
576         Unimplemented();
577       }
578       break;
579     }
580 
581     case lir_monaddr:
582       monitor_address(op-&gt;in_opr()-&gt;as_constant_ptr()-&gt;as_jint(), op-&gt;result_opr());
583       break;
584 










585     case lir_unwind:
586       unwind_op(op-&gt;in_opr());
587       break;
588 
589     default:
590       Unimplemented();
591       break;
592   }
593 }
594 
595 void LIR_Assembler::add_scalarized_entry_info(int pc_offset) {
596   flush_debug_info(pc_offset);
597   DebugInformationRecorder* debug_info = compilation()-&gt;debug_info_recorder();
598   // The VEP and VVEP(RO) of a C1-compiled method call buffer_value_args_xxx()
599   // before doing any argument shuffling. This call may cause GC. When GC happens,
600   // all the parameters are still as passed by the caller, so we just use
601   // map-&gt;set_include_argument_oops() inside frame::sender_for_compiled_frame(RegisterMap* map).
602   // There&#39;s no need to build a GC map here.
603   OopMap* oop_map = new OopMap(0, 0);
604   debug_info-&gt;add_safepoint(pc_offset, oop_map);
</pre>
<hr />
<pre>
946   } else if (src-&gt;is_address()) {
947     mem2reg(src, dest, type, patch_code, info, wide, unaligned);
948 
949   } else {
950     ShouldNotReachHere();
951   }
952 }
953 
954 
955 void LIR_Assembler::verify_oop_map(CodeEmitInfo* info) {
956 #ifndef PRODUCT
957   if (VerifyOops) {
958     OopMapStream s(info-&gt;oop_map());
959     while (!s.is_done()) {
960       OopMapValue v = s.current();
961       if (v.is_oop()) {
962         VMReg r = v.reg();
963         if (!r-&gt;is_stack()) {
964           stringStream st;
965           st.print(&quot;bad oop %s at %d&quot;, r-&gt;as_Register()-&gt;name(), _masm-&gt;offset());




966           _masm-&gt;verify_oop(r-&gt;as_Register());
967         } else {
968           _masm-&gt;verify_stack_oop(r-&gt;reg2stack() * VMRegImpl::stack_slot_size);
969         }
970       }
971       check_codespace();
972       CHECK_BAILOUT();
973 
974       s.next();
975     }
976   }
977 #endif
978 }
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
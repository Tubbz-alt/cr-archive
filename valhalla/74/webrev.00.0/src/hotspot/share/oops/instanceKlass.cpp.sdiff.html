<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3215         if (!(*trace_name_printed)) {
3216           log_info(redefine, class, update)
3217             (&quot;adjust: klassname=%s default methods from name=%s&quot;,
3218              external_name(), old_method-&gt;method_holder()-&gt;external_name());
3219           *trace_name_printed = true;
3220         }
3221         log_debug(redefine, class, update, vtables)
3222           (&quot;default method update: %s(%s) &quot;,
3223            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
3224       }
3225     }
3226   }
3227 }
3228 #endif // INCLUDE_JVMTI
3229 
3230 // On-stack replacement stuff
3231 void InstanceKlass::add_osr_nmethod(nmethod* n) {
3232   assert_lock_strong(CompiledMethod_lock);
3233 #ifndef PRODUCT
3234   if (TieredCompilation) {
<span class="line-modified">3235       nmethod * prev = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), n-&gt;comp_level(), true);</span>
<span class="line-modified">3236       assert(prev == NULL || !prev-&gt;is_in_use(),</span>
<span class="line-modified">3237       &quot;redundunt OSR recompilation detected. memory leak in CodeCache!&quot;);</span>
3238   }
3239 #endif
3240   // only one compilation can be active
3241   {
3242     assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
3243     n-&gt;set_osr_link(osr_nmethods_head());
3244     set_osr_nmethods_head(n);
3245     // Raise the highest osr level if necessary
3246     if (TieredCompilation) {
3247       Method* m = n-&gt;method();
3248       m-&gt;set_highest_osr_comp_level(MAX2(m-&gt;highest_osr_comp_level(), n-&gt;comp_level()));
3249     }
3250   }
3251 
3252   // Get rid of the osr methods for the same bci that have lower levels.
3253   if (TieredCompilation) {
3254     for (int l = CompLevel_limited_profile; l &lt; n-&gt;comp_level(); l++) {
3255       nmethod *inv = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), l, true);
3256       if (inv != NULL &amp;&amp; inv-&gt;is_in_use()) {
3257         inv-&gt;make_not_entrant();
</pre>
</td>
<td>
<hr />
<pre>
3215         if (!(*trace_name_printed)) {
3216           log_info(redefine, class, update)
3217             (&quot;adjust: klassname=%s default methods from name=%s&quot;,
3218              external_name(), old_method-&gt;method_holder()-&gt;external_name());
3219           *trace_name_printed = true;
3220         }
3221         log_debug(redefine, class, update, vtables)
3222           (&quot;default method update: %s(%s) &quot;,
3223            new_method-&gt;name()-&gt;as_C_string(), new_method-&gt;signature()-&gt;as_C_string());
3224       }
3225     }
3226   }
3227 }
3228 #endif // INCLUDE_JVMTI
3229 
3230 // On-stack replacement stuff
3231 void InstanceKlass::add_osr_nmethod(nmethod* n) {
3232   assert_lock_strong(CompiledMethod_lock);
3233 #ifndef PRODUCT
3234   if (TieredCompilation) {
<span class="line-modified">3235     nmethod* prev = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), n-&gt;comp_level(), true);</span>
<span class="line-modified">3236     assert(prev == NULL || !prev-&gt;is_in_use() COMPILER2_PRESENT(|| StressRecompilation),</span>
<span class="line-modified">3237            &quot;redundant OSR recompilation detected. memory leak in CodeCache!&quot;);</span>
3238   }
3239 #endif
3240   // only one compilation can be active
3241   {
3242     assert(n-&gt;is_osr_method(), &quot;wrong kind of nmethod&quot;);
3243     n-&gt;set_osr_link(osr_nmethods_head());
3244     set_osr_nmethods_head(n);
3245     // Raise the highest osr level if necessary
3246     if (TieredCompilation) {
3247       Method* m = n-&gt;method();
3248       m-&gt;set_highest_osr_comp_level(MAX2(m-&gt;highest_osr_comp_level(), n-&gt;comp_level()));
3249     }
3250   }
3251 
3252   // Get rid of the osr methods for the same bci that have lower levels.
3253   if (TieredCompilation) {
3254     for (int l = CompLevel_limited_profile; l &lt; n-&gt;comp_level(); l++) {
3255       nmethod *inv = lookup_osr_nmethod(n-&gt;method(), n-&gt;osr_entry_bci(), l, true);
3256       if (inv != NULL &amp;&amp; inv-&gt;is_in_use()) {
3257         inv-&gt;make_not_entrant();
</pre>
</td>
</tr>
</table>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1563 
1564   MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
1565   void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
1566 
1567 #if INCLUDE_JVMCI
1568   int  pending_deoptimization() const             { return _pending_deoptimization; }
1569   jlong pending_failed_speculation() const        { return _pending_failed_speculation; }
1570   bool has_pending_monitorenter() const           { return _pending_monitorenter; }
1571   void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
1572   void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
1573   void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }
1574   void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
1575   void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
1576   void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
1577 
1578   virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
1579   void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }
1580 #endif // INCLUDE_JVMCI
1581 
1582   // Exception handling for compiled methods
<span class="line-modified">1583   oop      exception_oop() const                 { return _exception_oop; }</span>
1584   address  exception_pc() const                  { return _exception_pc; }
1585   address  exception_handler_pc() const          { return _exception_handler_pc; }
1586   bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }
1587 
<span class="line-modified">1588   void set_exception_oop(oop o)                  { (void)const_cast&lt;oop&amp;&gt;(_exception_oop = o); }</span>
1589   void set_exception_pc(address a)               { _exception_pc = a; }
1590   void set_exception_handler_pc(address a)       { _exception_handler_pc = a; }
1591   void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }
1592 
1593   void clear_exception_oop_and_pc() {
1594     set_exception_oop(NULL);
1595     set_exception_pc(NULL);
1596   }
1597 
1598   // Stack overflow support
1599   //
1600   //  (small addresses)
1601   //
1602   //  --  &lt;-- stack_end()                   ---
1603   //  |                                      |
1604   //  |  red pages                           |
1605   //  |                                      |
1606   //  --  &lt;-- stack_red_zone_base()          |
1607   //  |                                      |
1608   //  |                                     guard
</pre>
</td>
<td>
<hr />
<pre>
1563 
1564   MemRegion deferred_card_mark() const           { return _deferred_card_mark; }
1565   void set_deferred_card_mark(MemRegion mr)      { _deferred_card_mark = mr;   }
1566 
1567 #if INCLUDE_JVMCI
1568   int  pending_deoptimization() const             { return _pending_deoptimization; }
1569   jlong pending_failed_speculation() const        { return _pending_failed_speculation; }
1570   bool has_pending_monitorenter() const           { return _pending_monitorenter; }
1571   void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }
1572   void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }
1573   void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }
1574   void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }
1575   void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, &quot;must be&quot;); _jvmci._alternate_call_target = a; }
1576   void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;); _jvmci._implicit_exception_pc = a; }
1577 
1578   virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }
1579   void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }
1580 #endif // INCLUDE_JVMCI
1581 
1582   // Exception handling for compiled methods
<span class="line-modified">1583   oop      exception_oop() const;</span>
1584   address  exception_pc() const                  { return _exception_pc; }
1585   address  exception_handler_pc() const          { return _exception_handler_pc; }
1586   bool     is_method_handle_return() const       { return _is_method_handle_return == 1; }
1587 
<span class="line-modified">1588   void set_exception_oop(oop o);</span>
1589   void set_exception_pc(address a)               { _exception_pc = a; }
1590   void set_exception_handler_pc(address a)       { _exception_handler_pc = a; }
1591   void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }
1592 
1593   void clear_exception_oop_and_pc() {
1594     set_exception_oop(NULL);
1595     set_exception_pc(NULL);
1596   }
1597 
1598   // Stack overflow support
1599   //
1600   //  (small addresses)
1601   //
1602   //  --  &lt;-- stack_end()                   ---
1603   //  |                                      |
1604   //  |  red pages                           |
1605   //  |                                      |
1606   //  --  &lt;-- stack_red_zone_base()          |
1607   //  |                                      |
1608   //  |                                     guard
</pre>
</td>
</tr>
</table>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
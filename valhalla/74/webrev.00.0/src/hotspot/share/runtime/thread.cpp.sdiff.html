<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="init.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());
 353   set_stack_size(os::current_stack_size());
 354 
<span class="line-removed"> 355 #ifdef SOLARIS</span>
<span class="line-removed"> 356   if (os::is_primordial_thread()) {</span>
<span class="line-removed"> 357     os::Solaris::correct_stack_boundaries_for_primordial_thread(this);</span>
<span class="line-removed"> 358   }</span>
<span class="line-removed"> 359 #endif</span>
<span class="line-removed"> 360 </span>
 361   // Set stack limits after thread is initialized.
 362   if (is_Java_thread()) {
 363     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 364     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 365   }
 366 }
 367 
 368 #if INCLUDE_NMT
 369 void Thread::register_thread_stack_with_NMT() {
 370   MemTracker::record_thread_stack(stack_end(), stack_size());
 371 }
 372 #endif // INCLUDE_NMT
 373 
 374 void Thread::call_run() {
 375   DEBUG_ONLY(_run_state = CALL_RUN;)
 376 
 377   // At this point, Thread object should be fully initialized and
 378   // Thread::current() should be set.
 379 
 380   assert(Thread::current_or_null() != NULL, &quot;current thread is unset&quot;);
</pre>
<hr />
<pre>
1656   _terminated = _not_terminated;
1657   _array_for_gc = NULL;
1658   _suspend_equivalent = false;
1659   _in_deopt_handler = 0;
1660   _doing_unsafe_access = false;
1661   _stack_guard_state = stack_guard_unused;
1662 #if INCLUDE_JVMCI
1663   _pending_monitorenter = false;
1664   _pending_deoptimization = -1;
1665   _pending_failed_speculation = 0;
1666   _pending_transfer_to_interpreter = false;
1667   _in_retryable_allocation = false;
1668   _jvmci._alternate_call_target = NULL;
1669   assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;);
1670   _jvmci_counters = NULL;
1671   if (JVMCICounterSize &gt; 0) {
1672     resize_counters(0, (int) JVMCICounterSize);
1673   }
1674 #endif // INCLUDE_JVMCI
1675   _reserved_stack_activation = NULL;  // stack base not known yet
<span class="line-modified">1676   (void)const_cast&lt;oop&amp;&gt;(_exception_oop = oop(NULL));</span>
1677   _exception_pc  = 0;
1678   _exception_handler_pc = 0;
1679   _is_method_handle_return = 0;
1680   _jvmti_thread_state= NULL;
1681   _should_post_on_exceptions_flag = JNI_FALSE;
1682   _interp_only_mode    = 0;
1683   _special_runtime_exit_condition = _no_async_condition;
1684   _pending_async_exception = NULL;
1685   _thread_stat = NULL;
1686   _thread_stat = new ThreadStatistics();
1687   _jni_active_critical = 0;
1688   _pending_jni_exception_check_fn = NULL;
1689   _do_not_unlock_if_synchronized = false;
1690   _cached_monitor_info = NULL;
1691   _parker = Parker::Allocate(this);
1692   _SleepEvent = ParkEvent::Allocate(this);
1693   // Setup safepoint state info for this thread
1694   ThreadSafepointState::create(this);
1695   _handshake.set_handshakee(this);
1696 
</pre>
<hr />
<pre>
2243     return (JavaThread*) thread;
2244   } else {
2245     assert(thread-&gt;is_VM_thread(), &quot;this must be a vm thread&quot;);
2246     VM_Operation* op = ((VMThread*) thread)-&gt;vm_operation();
2247     JavaThread *ret=op == NULL ? NULL : (JavaThread *)op-&gt;calling_thread();
2248     assert(ret-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
2249     return ret;
2250   }
2251 }
2252 
2253 bool JavaThread::is_lock_owned(address adr) const {
2254   if (Thread::is_lock_owned(adr)) return true;
2255 
2256   for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk-&gt;next()) {
2257     if (chunk-&gt;contains(adr)) return true;
2258   }
2259 
2260   return false;
2261 }
2262 







2263 
2264 void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {
2265   chunk-&gt;set_next(monitor_chunks());
2266   set_monitor_chunks(chunk);
2267 }
2268 
2269 void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {
2270   guarantee(monitor_chunks() != NULL, &quot;must be non empty&quot;);
2271   if (monitor_chunks() == chunk) {
2272     set_monitor_chunks(chunk-&gt;next());
2273   } else {
2274     MonitorChunk* prev = monitor_chunks();
2275     while (prev-&gt;next() != chunk) prev = prev-&gt;next();
2276     prev-&gt;set_next(chunk-&gt;next());
2277   }
2278 }
2279 
2280 // JVM support.
2281 
2282 // Note: this function shouldn&#39;t block if it&#39;s called in
</pre>
</td>
<td>
<hr />
<pre>
 335   ThreadLocalStorage::set_thread(this);
 336   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 337 }
 338 
 339 void Thread::clear_thread_current() {
 340   assert(Thread::current() == ThreadLocalStorage::thread(), &quot;TLS mismatch!&quot;);
 341 #ifndef USE_LIBRARY_BASED_TLS_ONLY
 342   _thr_current = NULL;
 343 #endif
 344   ThreadLocalStorage::set_thread(NULL);
 345 }
 346 
 347 void Thread::record_stack_base_and_size() {
 348   // Note: at this point, Thread object is not yet initialized. Do not rely on
 349   // any members being initialized. Do not rely on Thread::current() being set.
 350   // If possible, refrain from doing anything which may crash or assert since
 351   // quite probably those crash dumps will be useless.
 352   set_stack_base(os::current_stack_base());
 353   set_stack_size(os::current_stack_size());
 354 






 355   // Set stack limits after thread is initialized.
 356   if (is_Java_thread()) {
 357     ((JavaThread*) this)-&gt;set_stack_overflow_limit();
 358     ((JavaThread*) this)-&gt;set_reserved_stack_activation(stack_base());
 359   }
 360 }
 361 
 362 #if INCLUDE_NMT
 363 void Thread::register_thread_stack_with_NMT() {
 364   MemTracker::record_thread_stack(stack_end(), stack_size());
 365 }
 366 #endif // INCLUDE_NMT
 367 
 368 void Thread::call_run() {
 369   DEBUG_ONLY(_run_state = CALL_RUN;)
 370 
 371   // At this point, Thread object should be fully initialized and
 372   // Thread::current() should be set.
 373 
 374   assert(Thread::current_or_null() != NULL, &quot;current thread is unset&quot;);
</pre>
<hr />
<pre>
1650   _terminated = _not_terminated;
1651   _array_for_gc = NULL;
1652   _suspend_equivalent = false;
1653   _in_deopt_handler = 0;
1654   _doing_unsafe_access = false;
1655   _stack_guard_state = stack_guard_unused;
1656 #if INCLUDE_JVMCI
1657   _pending_monitorenter = false;
1658   _pending_deoptimization = -1;
1659   _pending_failed_speculation = 0;
1660   _pending_transfer_to_interpreter = false;
1661   _in_retryable_allocation = false;
1662   _jvmci._alternate_call_target = NULL;
1663   assert(_jvmci._implicit_exception_pc == NULL, &quot;must be&quot;);
1664   _jvmci_counters = NULL;
1665   if (JVMCICounterSize &gt; 0) {
1666     resize_counters(0, (int) JVMCICounterSize);
1667   }
1668 #endif // INCLUDE_JVMCI
1669   _reserved_stack_activation = NULL;  // stack base not known yet
<span class="line-modified">1670   set_exception_oop(oop());</span>
1671   _exception_pc  = 0;
1672   _exception_handler_pc = 0;
1673   _is_method_handle_return = 0;
1674   _jvmti_thread_state= NULL;
1675   _should_post_on_exceptions_flag = JNI_FALSE;
1676   _interp_only_mode    = 0;
1677   _special_runtime_exit_condition = _no_async_condition;
1678   _pending_async_exception = NULL;
1679   _thread_stat = NULL;
1680   _thread_stat = new ThreadStatistics();
1681   _jni_active_critical = 0;
1682   _pending_jni_exception_check_fn = NULL;
1683   _do_not_unlock_if_synchronized = false;
1684   _cached_monitor_info = NULL;
1685   _parker = Parker::Allocate(this);
1686   _SleepEvent = ParkEvent::Allocate(this);
1687   // Setup safepoint state info for this thread
1688   ThreadSafepointState::create(this);
1689   _handshake.set_handshakee(this);
1690 
</pre>
<hr />
<pre>
2237     return (JavaThread*) thread;
2238   } else {
2239     assert(thread-&gt;is_VM_thread(), &quot;this must be a vm thread&quot;);
2240     VM_Operation* op = ((VMThread*) thread)-&gt;vm_operation();
2241     JavaThread *ret=op == NULL ? NULL : (JavaThread *)op-&gt;calling_thread();
2242     assert(ret-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
2243     return ret;
2244   }
2245 }
2246 
2247 bool JavaThread::is_lock_owned(address adr) const {
2248   if (Thread::is_lock_owned(adr)) return true;
2249 
2250   for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk-&gt;next()) {
2251     if (chunk-&gt;contains(adr)) return true;
2252   }
2253 
2254   return false;
2255 }
2256 
<span class="line-added">2257 oop JavaThread::exception_oop() const {</span>
<span class="line-added">2258   return Atomic::load(&amp;_exception_oop);</span>
<span class="line-added">2259 }</span>
<span class="line-added">2260 </span>
<span class="line-added">2261 void JavaThread::set_exception_oop(oop o) {</span>
<span class="line-added">2262   Atomic::store(&amp;_exception_oop, o);</span>
<span class="line-added">2263 }</span>
2264 
2265 void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {
2266   chunk-&gt;set_next(monitor_chunks());
2267   set_monitor_chunks(chunk);
2268 }
2269 
2270 void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {
2271   guarantee(monitor_chunks() != NULL, &quot;must be non empty&quot;);
2272   if (monitor_chunks() == chunk) {
2273     set_monitor_chunks(chunk-&gt;next());
2274   } else {
2275     MonitorChunk* prev = monitor_chunks();
2276     while (prev-&gt;next() != chunk) prev = prev-&gt;next();
2277     prev-&gt;set_next(chunk-&gt;next());
2278   }
2279 }
2280 
2281 // JVM support.
2282 
2283 // Note: this function shouldn&#39;t block if it&#39;s called in
</pre>
</td>
</tr>
</table>
<center><a href="init.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
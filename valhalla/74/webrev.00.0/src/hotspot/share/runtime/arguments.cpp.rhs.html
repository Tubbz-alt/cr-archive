<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/javaAssertions.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;gc/shared/gcArguments.hpp&quot;
  33 #include &quot;gc/shared/gcConfig.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logConfiguration.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;logging/logTag.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/filemap.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;runtime/arguments.hpp&quot;
  43 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  44 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  45 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  46 #include &quot;runtime/globals_extension.hpp&quot;
  47 #include &quot;runtime/java.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/safepoint.hpp&quot;
  50 #include &quot;runtime/safepointMechanism.hpp&quot;
  51 #include &quot;runtime/vm_version.hpp&quot;
  52 #include &quot;services/management.hpp&quot;
  53 #include &quot;services/memTracker.hpp&quot;
  54 #include &quot;utilities/align.hpp&quot;
  55 #include &quot;utilities/defaultStream.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
  57 #include &quot;utilities/powerOfTwo.hpp&quot;
  58 #include &quot;utilities/stringUtils.hpp&quot;
  59 #if INCLUDE_JFR
  60 #include &quot;jfr/jfr.hpp&quot;
  61 #endif
  62 
  63 #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  64 
  65 char*  Arguments::_jvm_flags_file               = NULL;
  66 char** Arguments::_jvm_flags_array              = NULL;
  67 int    Arguments::_num_jvm_flags                = 0;
  68 char** Arguments::_jvm_args_array               = NULL;
  69 int    Arguments::_num_jvm_args                 = 0;
  70 char*  Arguments::_java_command                 = NULL;
  71 SystemProperty* Arguments::_system_properties   = NULL;
  72 const char*  Arguments::_gc_log_filename        = NULL;
  73 size_t Arguments::_conservative_max_heap_alignment = 0;
  74 Arguments::Mode Arguments::_mode                = _mixed;
  75 bool   Arguments::_java_compiler                = false;
  76 bool   Arguments::_xdebug_mode                  = false;
  77 const char*  Arguments::_java_vendor_url_bug    = NULL;
  78 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
  79 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  80 
  81 // These parameters are reset in method parse_vm_init_args()
  82 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  83 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  84 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  85 bool   Arguments::_ClipInlining                 = ClipInlining;
  86 intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  87 intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;
  88 size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;
  89 
  90 bool   Arguments::_enable_preview               = false;
  91 
  92 char*  Arguments::SharedArchivePath             = NULL;
  93 char*  Arguments::SharedDynamicArchivePath      = NULL;
  94 
  95 AgentLibraryList Arguments::_libraryList;
  96 AgentLibraryList Arguments::_agentList;
  97 
  98 // These are not set by the JDK&#39;s built-in launchers, but they can be set by
  99 // programs that embed the JVM using JNI_CreateJavaVM. See comments around
 100 // JavaVMOption in jni.h.
 101 abort_hook_t     Arguments::_abort_hook         = NULL;
 102 exit_hook_t      Arguments::_exit_hook          = NULL;
 103 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 104 
 105 
 106 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 107 SystemProperty *Arguments::_java_library_path = NULL;
 108 SystemProperty *Arguments::_java_home = NULL;
 109 SystemProperty *Arguments::_java_class_path = NULL;
 110 SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;
 111 SystemProperty *Arguments::_vm_info = NULL;
 112 
 113 GrowableArray&lt;ModulePatchPath*&gt; *Arguments::_patch_mod_prefix = NULL;
 114 PathString *Arguments::_system_boot_class_path = NULL;
 115 bool Arguments::_has_jimage = false;
 116 
 117 char* Arguments::_ext_dirs = NULL;
 118 
 119 bool PathString::set_value(const char *value) {
 120   if (_value != NULL) {
 121     FreeHeap(_value);
 122   }
 123   _value = AllocateHeap(strlen(value)+1, mtArguments);
 124   assert(_value != NULL, &quot;Unable to allocate space for new path value&quot;);
 125   if (_value != NULL) {
 126     strcpy(_value, value);
 127   } else {
 128     // not able to allocate
 129     return false;
 130   }
 131   return true;
 132 }
 133 
 134 void PathString::append_value(const char *value) {
 135   char *sp;
 136   size_t len = 0;
 137   if (value != NULL) {
 138     len = strlen(value);
 139     if (_value != NULL) {
 140       len += strlen(_value);
 141     }
 142     sp = AllocateHeap(len+2, mtArguments);
 143     assert(sp != NULL, &quot;Unable to allocate space for new append path value&quot;);
 144     if (sp != NULL) {
 145       if (_value != NULL) {
 146         strcpy(sp, _value);
 147         strcat(sp, os::path_separator());
 148         strcat(sp, value);
 149         FreeHeap(_value);
 150       } else {
 151         strcpy(sp, value);
 152       }
 153       _value = sp;
 154     }
 155   }
 156 }
 157 
 158 PathString::PathString(const char* value) {
 159   if (value == NULL) {
 160     _value = NULL;
 161   } else {
 162     _value = AllocateHeap(strlen(value)+1, mtArguments);
 163     strcpy(_value, value);
 164   }
 165 }
 166 
 167 PathString::~PathString() {
 168   if (_value != NULL) {
 169     FreeHeap(_value);
 170     _value = NULL;
 171   }
 172 }
 173 
 174 ModulePatchPath::ModulePatchPath(const char* module_name, const char* path) {
 175   assert(module_name != NULL &amp;&amp; path != NULL, &quot;Invalid module name or path value&quot;);
 176   size_t len = strlen(module_name) + 1;
 177   _module_name = AllocateHeap(len, mtInternal);
 178   strncpy(_module_name, module_name, len); // copy the trailing null
 179   _path =  new PathString(path);
 180 }
 181 
 182 ModulePatchPath::~ModulePatchPath() {
 183   if (_module_name != NULL) {
 184     FreeHeap(_module_name);
 185     _module_name = NULL;
 186   }
 187   if (_path != NULL) {
 188     delete _path;
 189     _path = NULL;
 190   }
 191 }
 192 
 193 SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal) : PathString(value) {
 194   if (key == NULL) {
 195     _key = NULL;
 196   } else {
 197     _key = AllocateHeap(strlen(key)+1, mtArguments);
 198     strcpy(_key, key);
 199   }
 200   _next = NULL;
 201   _internal = internal;
 202   _writeable = writeable;
 203 }
 204 
 205 AgentLibrary::AgentLibrary(const char* name, const char* options,
 206                bool is_absolute_path, void* os_lib,
 207                bool instrument_lib) {
 208   _name = AllocateHeap(strlen(name)+1, mtArguments);
 209   strcpy(_name, name);
 210   if (options == NULL) {
 211     _options = NULL;
 212   } else {
 213     _options = AllocateHeap(strlen(options)+1, mtArguments);
 214     strcpy(_options, options);
 215   }
 216   _is_absolute_path = is_absolute_path;
 217   _os_lib = os_lib;
 218   _next = NULL;
 219   _state = agent_invalid;
 220   _is_static_lib = false;
 221   _is_instrument_lib = instrument_lib;
 222 }
 223 
 224 // Check if head of &#39;option&#39; matches &#39;name&#39;, and sets &#39;tail&#39; to the remaining
 225 // part of the option string.
 226 static bool match_option(const JavaVMOption *option, const char* name,
 227                          const char** tail) {
 228   size_t len = strlen(name);
 229   if (strncmp(option-&gt;optionString, name, len) == 0) {
 230     *tail = option-&gt;optionString + len;
 231     return true;
 232   } else {
 233     return false;
 234   }
 235 }
 236 
 237 // Check if &#39;option&#39; matches &#39;name&#39;. No &quot;tail&quot; is allowed.
 238 static bool match_option(const JavaVMOption *option, const char* name) {
 239   const char* tail = NULL;
 240   bool result = match_option(option, name, &amp;tail);
 241   if (tail != NULL &amp;&amp; *tail == &#39;\0&#39;) {
 242     return result;
 243   } else {
 244     return false;
 245   }
 246 }
 247 
 248 // Return true if any of the strings in null-terminated array &#39;names&#39; matches.
 249 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
 250 // the option must match exactly.
 251 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
 252   bool tail_allowed) {
 253   for (/* empty */; *names != NULL; ++names) {
 254   if (match_option(option, *names, tail)) {
 255       if (**tail == &#39;\0&#39; || (tail_allowed &amp;&amp; **tail == &#39;:&#39;)) {
 256         return true;
 257       }
 258     }
 259   }
 260   return false;
 261 }
 262 
 263 #if INCLUDE_JFR
 264 static bool _has_jfr_option = false;  // is using JFR
 265 
 266 // return true on failure
 267 static bool match_jfr_option(const JavaVMOption** option) {
 268   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
 269   char* tail = NULL;
 270   if (match_option(*option, &quot;-XX:StartFlightRecording&quot;, (const char**)&amp;tail)) {
 271     _has_jfr_option = true;
 272     return Jfr::on_start_flight_recording_option(option, tail);
 273   } else if (match_option(*option, &quot;-XX:FlightRecorderOptions&quot;, (const char**)&amp;tail)) {
 274     _has_jfr_option = true;
 275     return Jfr::on_flight_recorder_option(option, tail);
 276   }
 277   return false;
 278 }
 279 
 280 bool Arguments::has_jfr_option() {
 281   return _has_jfr_option;
 282 }
 283 #endif
 284 
 285 static void logOption(const char* opt) {
 286   if (PrintVMOptions) {
 287     jio_fprintf(defaultStream::output_stream(), &quot;VM option &#39;%s&#39;\n&quot;, opt);
 288   }
 289 }
 290 
 291 bool needs_module_property_warning = false;
 292 
 293 #define MODULE_PROPERTY_PREFIX &quot;jdk.module.&quot;
 294 #define MODULE_PROPERTY_PREFIX_LEN 11
 295 #define ADDEXPORTS &quot;addexports&quot;
 296 #define ADDEXPORTS_LEN 10
 297 #define ADDREADS &quot;addreads&quot;
 298 #define ADDREADS_LEN 8
 299 #define ADDOPENS &quot;addopens&quot;
 300 #define ADDOPENS_LEN 8
 301 #define PATCH &quot;patch&quot;
 302 #define PATCH_LEN 5
 303 #define ADDMODS &quot;addmods&quot;
 304 #define ADDMODS_LEN 7
 305 #define LIMITMODS &quot;limitmods&quot;
 306 #define LIMITMODS_LEN 9
 307 #define PATH &quot;path&quot;
 308 #define PATH_LEN 4
 309 #define UPGRADE_PATH &quot;upgrade.path&quot;
 310 #define UPGRADE_PATH_LEN 12
 311 
 312 void Arguments::add_init_library(const char* name, char* options) {
 313   _libraryList.add(new AgentLibrary(name, options, false, NULL));
 314 }
 315 
 316 void Arguments::add_init_agent(const char* name, char* options, bool absolute_path) {
 317   _agentList.add(new AgentLibrary(name, options, absolute_path, NULL));
 318 }
 319 
 320 void Arguments::add_instrument_agent(const char* name, char* options, bool absolute_path) {
 321   _agentList.add(new AgentLibrary(name, options, absolute_path, NULL, true));
 322 }
 323 
 324 // Late-binding agents not started via arguments
 325 void Arguments::add_loaded_agent(AgentLibrary *agentLib) {
 326   _agentList.add(agentLib);
 327 }
 328 
 329 // Return TRUE if option matches &#39;property&#39;, or &#39;property=&#39;, or &#39;property.&#39;.
 330 static bool matches_property_suffix(const char* option, const char* property, size_t len) {
 331   return ((strncmp(option, property, len) == 0) &amp;&amp;
 332           (option[len] == &#39;=&#39; || option[len] == &#39;.&#39; || option[len] == &#39;\0&#39;));
 333 }
 334 
 335 // Return true if property starts with &quot;jdk.module.&quot; and its ensuing chars match
 336 // any of the reserved module properties.
 337 // property should be passed without the leading &quot;-D&quot;.
 338 bool Arguments::is_internal_module_property(const char* property) {
 339   assert((strncmp(property, &quot;-D&quot;, 2) != 0), &quot;Unexpected leading -D&quot;);
 340   if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {
 341     const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;
 342     if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||
 343         matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||
 344         matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||
 345         matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||
 346         matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||
 347         matches_property_suffix(property_suffix, LIMITMODS, LIMITMODS_LEN) ||
 348         matches_property_suffix(property_suffix, PATH, PATH_LEN) ||
 349         matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {
 350       return true;
 351     }
 352   }
 353   return false;
 354 }
 355 
 356 // Process java launcher properties.
 357 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
 358   // See if sun.java.launcher or sun.java.launcher.is_altjvm is defined.
 359   // Must do this before setting up other system properties,
 360   // as some of them may depend on launcher type.
 361   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 362     const JavaVMOption* option = args-&gt;options + index;
 363     const char* tail;
 364 
 365     if (match_option(option, &quot;-Dsun.java.launcher=&quot;, &amp;tail)) {
 366       process_java_launcher_argument(tail, option-&gt;extraInfo);
 367       continue;
 368     }
 369     if (match_option(option, &quot;-Dsun.java.launcher.is_altjvm=&quot;, &amp;tail)) {
 370       if (strcmp(tail, &quot;true&quot;) == 0) {
 371         _sun_java_launcher_is_altjvm = true;
 372       }
 373       continue;
 374     }
 375   }
 376 }
 377 
 378 // Initialize system properties key and value.
 379 void Arguments::init_system_properties() {
 380 
 381   // Set up _system_boot_class_path which is not a property but
 382   // relies heavily on argument processing and the jdk.boot.class.path.append
 383   // property. It is used to store the underlying system boot class path.
 384   _system_boot_class_path = new PathString(NULL);
 385 
 386   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.specification.name&quot;,
 387                                                            &quot;Java Virtual Machine Specification&quot;,  false));
 388   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.version&quot;, VM_Version::vm_release(),  false));
 389   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.name&quot;, VM_Version::vm_name(),  false));
 390   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;jdk.debug&quot;, VM_Version::jdk_debug_level(),  false));
 391 
 392   // Initialize the vm.info now, but it will need updating after argument parsing.
 393   _vm_info = new SystemProperty(&quot;java.vm.info&quot;, VM_Version::vm_info_string(), true);
 394 
 395   // Following are JVMTI agent writable properties.
 396   // Properties values are set to NULL and they are
 397   // os specific they are initialized in os::init_system_properties_values().
 398   _sun_boot_library_path = new SystemProperty(&quot;sun.boot.library.path&quot;, NULL,  true);
 399   _java_library_path = new SystemProperty(&quot;java.library.path&quot;, NULL,  true);
 400   _java_home =  new SystemProperty(&quot;java.home&quot;, NULL,  true);
 401   _java_class_path = new SystemProperty(&quot;java.class.path&quot;, &quot;&quot;,  true);
 402   // jdk.boot.class.path.append is a non-writeable, internal property.
 403   // It can only be set by either:
 404   //    - -Xbootclasspath/a:
 405   //    - AddToBootstrapClassLoaderSearch during JVMTI OnLoad phase
 406   _jdk_boot_class_path_append = new SystemProperty(&quot;jdk.boot.class.path.append&quot;, &quot;&quot;, false, true);
 407 
 408   // Add to System Property list.
 409   PropertyList_add(&amp;_system_properties, _sun_boot_library_path);
 410   PropertyList_add(&amp;_system_properties, _java_library_path);
 411   PropertyList_add(&amp;_system_properties, _java_home);
 412   PropertyList_add(&amp;_system_properties, _java_class_path);
 413   PropertyList_add(&amp;_system_properties, _jdk_boot_class_path_append);
 414   PropertyList_add(&amp;_system_properties, _vm_info);
 415 
 416   // Set OS specific system properties values
 417   os::init_system_properties_values();
 418 }
 419 
 420 // Update/Initialize System properties after JDK version number is known
 421 void Arguments::init_version_specific_system_properties() {
 422   enum { bufsz = 16 };
 423   char buffer[bufsz];
 424   const char* spec_vendor = &quot;Oracle Corporation&quot;;
 425   uint32_t spec_version = JDK_Version::current().major_version();
 426 
 427   jio_snprintf(buffer, bufsz, UINT32_FORMAT, spec_version);
 428 
 429   PropertyList_add(&amp;_system_properties,
 430       new SystemProperty(&quot;java.vm.specification.vendor&quot;,  spec_vendor, false));
 431   PropertyList_add(&amp;_system_properties,
 432       new SystemProperty(&quot;java.vm.specification.version&quot;, buffer, false));
 433   PropertyList_add(&amp;_system_properties,
 434       new SystemProperty(&quot;java.vm.vendor&quot;, VM_Version::vm_vendor(),  false));
 435 }
 436 
 437 /*
 438  *  -XX argument processing:
 439  *
 440  *  -XX arguments are defined in several places, such as:
 441  *      globals.hpp, globals_&lt;cpu&gt;.hpp, globals_&lt;os&gt;.hpp, &lt;compiler&gt;_globals.hpp, or &lt;gc&gt;_globals.hpp.
 442  *  -XX arguments are parsed in parse_argument().
 443  *  -XX argument bounds checking is done in check_vm_args_consistency().
 444  *
 445  * Over time -XX arguments may change. There are mechanisms to handle common cases:
 446  *
 447  *      ALIASED: An option that is simply another name for another option. This is often
 448  *               part of the process of deprecating a flag, but not all aliases need
 449  *               to be deprecated.
 450  *
 451  *               Create an alias for an option by adding the old and new option names to the
 452  *               &quot;aliased_jvm_flags&quot; table. Delete the old variable from globals.hpp (etc).
 453  *
 454  *   DEPRECATED: An option that is supported, but a warning is printed to let the user know that
 455  *               support may be removed in the future. Both regular and aliased options may be
 456  *               deprecated.
 457  *
 458  *               Add a deprecation warning for an option (or alias) by adding an entry in the
 459  *               &quot;special_jvm_flags&quot; table and setting the &quot;deprecated_in&quot; field.
 460  *               Often an option &quot;deprecated&quot; in one major release will
 461  *               be made &quot;obsolete&quot; in the next. In this case the entry should also have its
 462  *               &quot;obsolete_in&quot; field set.
 463  *
 464  *     OBSOLETE: An option that has been removed (and deleted from globals.hpp), but is still accepted
 465  *               on the command line. A warning is printed to let the user know that option might not
 466  *               be accepted in the future.
 467  *
 468  *               Add an obsolete warning for an option by adding an entry in the &quot;special_jvm_flags&quot;
 469  *               table and setting the &quot;obsolete_in&quot; field.
 470  *
 471  *      EXPIRED: A deprecated or obsolete option that has an &quot;accept_until&quot; version less than or equal
 472  *               to the current JDK version. The system will flatly refuse to admit the existence of
 473  *               the flag. This allows a flag to die automatically over JDK releases.
 474  *
 475  *               Note that manual cleanup of expired options should be done at major JDK version upgrades:
 476  *                  - Newly expired options should be removed from the special_jvm_flags and aliased_jvm_flags tables.
 477  *                  - Newly obsolete or expired deprecated options should have their global variable
 478  *                    definitions removed (from globals.hpp, etc) and related implementations removed.
 479  *
 480  * Recommended approach for removing options:
 481  *
 482  * To remove options commonly used by customers (e.g. product -XX options), use
 483  * the 3-step model adding major release numbers to the deprecate, obsolete and expire columns.
 484  *
 485  * To remove internal options (e.g. diagnostic, experimental, develop options), use
 486  * a 2-step model adding major release numbers to the obsolete and expire columns.
 487  *
 488  * To change the name of an option, use the alias table as well as a 2-step
 489  * model adding major release numbers to the deprecate and expire columns.
 490  * Think twice about aliasing commonly used customer options.
 491  *
 492  * There are times when it is appropriate to leave a future release number as undefined.
 493  *
 494  * Tests:  Aliases should be tested in VMAliasOptions.java.
 495  *         Deprecated options should be tested in VMDeprecatedOptions.java.
 496  */
 497 
 498 // The special_jvm_flags table declares options that are being deprecated and/or obsoleted. The
 499 // &quot;deprecated_in&quot; or &quot;obsolete_in&quot; fields may be set to &quot;undefined&quot;, but not both.
 500 // When the JDK version reaches &#39;deprecated_in&#39; limit, the JVM will process this flag on
 501 // the command-line as usual, but will issue a warning.
 502 // When the JDK version reaches &#39;obsolete_in&#39; limit, the JVM will continue accepting this flag on
 503 // the command-line, while issuing a warning and ignoring the flag value.
 504 // Once the JDK version reaches &#39;expired_in&#39; limit, the JVM will flatly refuse to admit the
 505 // existence of the flag.
 506 //
 507 // MANUAL CLEANUP ON JDK VERSION UPDATES:
 508 // This table ensures that the handling of options will update automatically when the JDK
 509 // version is incremented, but the source code needs to be cleanup up manually:
 510 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 511 //   variable should be removed, as well as users of the variable.
 512 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 513 //   &quot;Obsolete Flags&quot; section of the table.
 514 // - All expired options should be removed from the table.
 515 static SpecialFlag const special_jvm_flags[] = {
 516   // -------------- Deprecated Flags --------------
 517   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 518   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
 519   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 520   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 521   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 522   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
 523   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 524   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 525   { &quot;PrintVMQWaitTime&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 526   { &quot;UseNewFieldLayout&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 527   { &quot;ForceNUMA&quot;,                    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 528   { &quot;UseBiasedLocking&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 529   { &quot;BiasedLockingStartupDelay&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 530   { &quot;PrintBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 531   { &quot;BiasedLockingBulkRebiasThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 532   { &quot;BiasedLockingBulkRevokeThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 533   { &quot;BiasedLockingDecayTime&quot;,              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 534   { &quot;UseOptoBiasInlining&quot;,                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 535   { &quot;PrintPreciseBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 536   { &quot;InitialBootClassLoaderMetaspaceSize&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 537   { &quot;UseLargePagesInMetaspace&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 538 
 539   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 540   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 541   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 542   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 558 #ifndef X86
 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 560 #endif // !X86
 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
<a name="1" id="anc1"></a><span class="line-added"> 563 #ifdef AARCH64</span>
<span class="line-added"> 564   { &quot;UseBarriersForVolatile&quot;,        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 565 #endif</span>
<span class="line-added"> 566   { &quot;UseLWPSynchronization&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
 567 
 568 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 569   // These entries will generate build errors.  Their purpose is to test the macros.
 570   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 571   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 572   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 573   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 574   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 575   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 576   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 577 #endif
 578 
 579 #ifndef COMPILER2
 580   // These flags were generally available, but are C2 only, now.
 581   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 582   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 583   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 584   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 585   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 586   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 587 #endif
 588 
 589   { NULL, JDK_Version(0), JDK_Version(0) }
 590 };
 591 
 592 // Flags that are aliases for other flags.
 593 typedef struct {
 594   const char* alias_name;
 595   const char* real_name;
 596 } AliasedFlag;
 597 
 598 static AliasedFlag const aliased_jvm_flags[] = {
 599   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 600   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 601   { NULL, NULL}
 602 };
 603 
 604 // NOTE: A compatibility request will be necessary for each alias to be removed.
 605 static AliasedLoggingFlag const aliased_logging_flags[] = {
<a name="2" id="anc2"></a>
 606   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 607   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 608   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 609   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 610   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 611   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 612   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 613   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 614   { &quot;TraceInvokeDynamic&quot;,        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
 615   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 616   { &quot;TraceMethodHandles&quot;,        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
 617   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 618   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 619   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 620   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 621   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 622   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 623 };
 624 
 625 #ifndef PRODUCT
 626 // These options are removed in jdk9. Remove this code for jdk10.
 627 static AliasedFlag const removed_develop_logging_flags[] = {
 628   { &quot;TraceClassInitialization&quot;,   &quot;-Xlog:class+init&quot; },
 629   { &quot;TraceClassLoaderData&quot;,       &quot;-Xlog:class+loader+data&quot; },
 630   { &quot;TraceDefaultMethods&quot;,        &quot;-Xlog:defaultmethods=debug&quot; },
 631   { &quot;TraceItables&quot;,               &quot;-Xlog:itables=debug&quot; },
 632   { &quot;TraceMonitorMismatch&quot;,       &quot;-Xlog:monitormismatch=info&quot; },
 633   { &quot;TraceSafepoint&quot;,             &quot;-Xlog:safepoint=debug&quot; },
 634   { &quot;TraceStartupTime&quot;,           &quot;-Xlog:startuptime&quot; },
 635   { &quot;TraceVMOperation&quot;,           &quot;-Xlog:vmoperation=debug&quot; },
 636   { &quot;PrintVtables&quot;,               &quot;-Xlog:vtables=debug&quot; },
 637   { &quot;VerboseVerification&quot;,        &quot;-Xlog:verification&quot; },
 638   { NULL, NULL }
 639 };
 640 #endif //PRODUCT
 641 
 642 // Return true if &quot;v&quot; is less than &quot;other&quot;, where &quot;other&quot; may be &quot;undefined&quot;.
 643 static bool version_less_than(JDK_Version v, JDK_Version other) {
 644   assert(!v.is_undefined(), &quot;must be defined&quot;);
 645   if (!other.is_undefined() &amp;&amp; v.compare(other) &gt;= 0) {
 646     return false;
 647   } else {
 648     return true;
 649   }
 650 }
 651 
 652 static bool lookup_special_flag(const char *flag_name, SpecialFlag&amp; flag) {
 653   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 654     if ((strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 655       flag = special_jvm_flags[i];
 656       return true;
 657     }
 658   }
 659   return false;
 660 }
 661 
 662 bool Arguments::is_obsolete_flag(const char *flag_name, JDK_Version* version) {
 663   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 664   SpecialFlag flag;
 665   if (lookup_special_flag(flag_name, flag)) {
 666     if (!flag.obsolete_in.is_undefined()) {
 667       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 668         *version = flag.obsolete_in;
 669         // This flag may have been marked for obsoletion in this version, but we may not
 670         // have actually removed it yet. Rather than ignoring it as soon as we reach
 671         // this version we allow some time for the removal to happen. So if the flag
 672         // still actually exists we process it as normal, but issue an adjusted warning.
 673         const JVMFlag *real_flag = JVMFlag::find_declared_flag(flag_name);
 674         if (real_flag != NULL) {
 675           char version_str[256];
 676           version-&gt;to_string(version_str, sizeof(version_str));
 677           warning(&quot;Temporarily processing option %s; support is scheduled for removal in %s&quot;,
 678                   flag_name, version_str);
 679           return false;
 680         }
 681         return true;
 682       }
 683     }
 684   }
 685   return false;
 686 }
 687 
 688 int Arguments::is_deprecated_flag(const char *flag_name, JDK_Version* version) {
 689   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 690   SpecialFlag flag;
 691   if (lookup_special_flag(flag_name, flag)) {
 692     if (!flag.deprecated_in.is_undefined()) {
 693       if (version_less_than(JDK_Version::current(), flag.obsolete_in) &amp;&amp;
 694           version_less_than(JDK_Version::current(), flag.expired_in)) {
 695         *version = flag.deprecated_in;
 696         return 1;
 697       } else {
 698         return -1;
 699       }
 700     }
 701   }
 702   return 0;
 703 }
 704 
 705 #ifndef PRODUCT
 706 const char* Arguments::removed_develop_logging_flag_name(const char* name){
 707   for (size_t i = 0; removed_develop_logging_flags[i].alias_name != NULL; i++) {
 708     const AliasedFlag&amp; flag = removed_develop_logging_flags[i];
 709     if (strcmp(flag.alias_name, name) == 0) {
 710       return flag.real_name;
 711     }
 712   }
 713   return NULL;
 714 }
 715 #endif // PRODUCT
 716 
 717 const char* Arguments::real_flag_name(const char *flag_name) {
 718   for (size_t i = 0; aliased_jvm_flags[i].alias_name != NULL; i++) {
 719     const AliasedFlag&amp; flag_status = aliased_jvm_flags[i];
 720     if (strcmp(flag_status.alias_name, flag_name) == 0) {
 721         return flag_status.real_name;
 722     }
 723   }
 724   return flag_name;
 725 }
 726 
 727 #ifdef ASSERT
 728 static bool lookup_special_flag(const char *flag_name, size_t skip_index) {
 729   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 730     if ((i != skip_index) &amp;&amp; (strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 731       return true;
 732     }
 733   }
 734   return false;
 735 }
 736 
 737 // Verifies the correctness of the entries in the special_jvm_flags table.
 738 // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
 739 // version being earlier than the deprecation version, then a warning is issued
 740 // and verification fails - by returning false. If it is detected that the table
 741 // is out of date, with respect to the current version, then ideally a warning is
 742 // issued but verification does not fail. This allows the VM to operate when the
 743 // version is first updated, without needing to update all the impacted flags at
 744 // the same time. In practice we can&#39;t issue the warning immediately when the version
 745 // is updated as it occurs for every test and some tests are not prepared to handle
 746 // unexpected output - see 8196739. Instead we only check if the table is up-to-date
 747 // if the check_globals flag is true, and in addition allow a grace period and only
 748 // check for stale flags when we hit build 25 (which is far enough into the 6 month
 749 // release cycle that all flag updates should have been processed, whilst still
 750 // leaving time to make the change before RDP2).
 751 // We use a gtest to call this, passing true, so that we can detect stale flags before
 752 // the end of the release cycle.
 753 
 754 static const int SPECIAL_FLAG_VALIDATION_BUILD = 25;
 755 
 756 bool Arguments::verify_special_jvm_flags(bool check_globals) {
 757   bool success = true;
 758   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 759     const SpecialFlag&amp; flag = special_jvm_flags[i];
 760     if (lookup_special_flag(flag.name, i)) {
 761       warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
 762       success = false;
 763     }
 764     if (flag.deprecated_in.is_undefined() &amp;&amp;
 765         flag.obsolete_in.is_undefined()) {
 766       warning(&quot;Special flag entry \&quot;%s\&quot; must declare version deprecated and/or obsoleted in.&quot;, flag.name);
 767       success = false;
 768     }
 769 
 770     if (!flag.deprecated_in.is_undefined()) {
 771       if (!version_less_than(flag.deprecated_in, flag.obsolete_in)) {
 772         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before obsoleted.&quot;, flag.name);
 773         success = false;
 774       }
 775 
 776       if (!version_less_than(flag.deprecated_in, flag.expired_in)) {
 777         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before expired.&quot;, flag.name);
 778         success = false;
 779       }
 780     }
 781 
 782     if (!flag.obsolete_in.is_undefined()) {
 783       if (!version_less_than(flag.obsolete_in, flag.expired_in)) {
 784         warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
 785         success = false;
 786       }
 787 
 788       // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
 789       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;
 790           !version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 791         if (JVMFlag::find_declared_flag(flag.name) != NULL) {
 792           warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);
 793           success = false;
 794         }
 795       }
 796 
 797     } else if (!flag.expired_in.is_undefined()) {
 798       warning(&quot;Special flag entry \&quot;%s\&quot; must be explicitly obsoleted before expired.&quot;, flag.name);
 799       success = false;
 800     }
 801 
 802     if (!flag.expired_in.is_undefined()) {
 803       // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
 804       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;
 805           !version_less_than(JDK_Version::current(), flag.expired_in)) {
 806         if (JVMFlag::find_declared_flag(flag.name) != NULL) {
 807           warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);
 808           success = false;
 809         }
 810       }
 811     }
 812   }
 813   return success;
 814 }
 815 #endif
 816 
 817 // Parses a size specification string.
 818 bool Arguments::atojulong(const char *s, julong* result) {
 819   julong n = 0;
 820 
 821   // First char must be a digit. Don&#39;t allow negative numbers or leading spaces.
 822   if (!isdigit(*s)) {
 823     return false;
 824   }
 825 
 826   bool is_hex = (s[0] == &#39;0&#39; &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;));
 827   char* remainder;
 828   errno = 0;
 829   n = strtoull(s, &amp;remainder, (is_hex ? 16 : 10));
 830   if (errno != 0) {
 831     return false;
 832   }
 833 
 834   // Fail if no number was read at all or if the remainder contains more than a single non-digit character.
 835   if (remainder == s || strlen(remainder) &gt; 1) {
 836     return false;
 837   }
 838 
 839   switch (*remainder) {
 840     case &#39;T&#39;: case &#39;t&#39;:
 841       *result = n * G * K;
 842       // Check for overflow.
 843       if (*result/((julong)G * K) != n) return false;
 844       return true;
 845     case &#39;G&#39;: case &#39;g&#39;:
 846       *result = n * G;
 847       if (*result/G != n) return false;
 848       return true;
 849     case &#39;M&#39;: case &#39;m&#39;:
 850       *result = n * M;
 851       if (*result/M != n) return false;
 852       return true;
 853     case &#39;K&#39;: case &#39;k&#39;:
 854       *result = n * K;
 855       if (*result/K != n) return false;
 856       return true;
 857     case &#39;\0&#39;:
 858       *result = n;
 859       return true;
 860     default:
 861       return false;
 862   }
 863 }
 864 
 865 Arguments::ArgsRange Arguments::check_memory_size(julong size, julong min_size, julong max_size) {
 866   if (size &lt; min_size) return arg_too_small;
 867   if (size &gt; max_size) return arg_too_big;
 868   return arg_in_range;
 869 }
 870 
 871 // Describe an argument out of range error
 872 void Arguments::describe_range_error(ArgsRange errcode) {
 873   switch(errcode) {
 874   case arg_too_big:
 875     jio_fprintf(defaultStream::error_stream(),
 876                 &quot;The specified size exceeds the maximum &quot;
 877                 &quot;representable size.\n&quot;);
 878     break;
 879   case arg_too_small:
 880   case arg_unreadable:
 881   case arg_in_range:
 882     // do nothing for now
 883     break;
 884   default:
 885     ShouldNotReachHere();
 886   }
 887 }
 888 
 889 static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {
 890   if (JVMFlag::boolAtPut(flag, &amp;value, origin) == JVMFlag::SUCCESS) {
 891     return true;
 892   } else {
 893     return false;
 894   }
 895 }
 896 
 897 static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {
 898   char* end;
 899   errno = 0;
 900   double v = strtod(value, &amp;end);
 901   if ((errno != 0) || (*end != 0)) {
 902     return false;
 903   }
 904 
 905   if (JVMFlag::doubleAtPut(flag, &amp;v, origin) == JVMFlag::SUCCESS) {
 906     return true;
 907   }
 908   return false;
 909 }
 910 
 911 static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {
 912   julong v;
 913   int int_v;
 914   intx intx_v;
 915   bool is_neg = false;
 916 
 917   if (flag == NULL) {
 918     return false;
 919   }
 920 
 921   // Check the sign first since atojulong() parses only unsigned values.
 922   if (*value == &#39;-&#39;) {
 923     if (!flag-&gt;is_intx() &amp;&amp; !flag-&gt;is_int()) {
 924       return false;
 925     }
 926     value++;
 927     is_neg = true;
 928   }
 929   if (!Arguments::atojulong(value, &amp;v)) {
 930     return false;
 931   }
 932   if (flag-&gt;is_int()) {
 933     int_v = (int) v;
 934     if (is_neg) {
 935       int_v = -int_v;
 936     }
 937     return JVMFlag::intAtPut(flag, &amp;int_v, origin) == JVMFlag::SUCCESS;
 938   } else if (flag-&gt;is_uint()) {
 939     uint uint_v = (uint) v;
 940     return JVMFlag::uintAtPut(flag, &amp;uint_v, origin) == JVMFlag::SUCCESS;
 941   } else if (flag-&gt;is_intx()) {
 942     intx_v = (intx) v;
 943     if (is_neg) {
 944       intx_v = -intx_v;
 945     }
 946     return JVMFlag::intxAtPut(flag, &amp;intx_v, origin) == JVMFlag::SUCCESS;
 947   } else if (flag-&gt;is_uintx()) {
 948     uintx uintx_v = (uintx) v;
 949     return JVMFlag::uintxAtPut(flag, &amp;uintx_v, origin) == JVMFlag::SUCCESS;
 950   } else if (flag-&gt;is_uint64_t()) {
 951     uint64_t uint64_t_v = (uint64_t) v;
 952     return JVMFlag::uint64_tAtPut(flag, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;
 953   } else if (flag-&gt;is_size_t()) {
 954     size_t size_t_v = (size_t) v;
 955     return JVMFlag::size_tAtPut(flag, &amp;size_t_v, origin) == JVMFlag::SUCCESS;
 956   } else if (flag-&gt;is_double()) {
 957     double double_v = (double) v;
 958     return JVMFlag::doubleAtPut(flag, &amp;double_v, origin) == JVMFlag::SUCCESS;
 959   } else {
 960     return false;
 961   }
 962 }
 963 
 964 static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {
 965   if (JVMFlag::ccstrAtPut(flag, &amp;value, origin) != JVMFlag::SUCCESS) return false;
 966   // Contract:  JVMFlag always returns a pointer that needs freeing.
 967   FREE_C_HEAP_ARRAY(char, value);
 968   return true;
 969 }
 970 
 971 static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {
 972   const char* old_value = &quot;&quot;;
 973   if (JVMFlag::ccstrAt(flag, &amp;old_value) != JVMFlag::SUCCESS) return false;
 974   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 975   size_t new_len = strlen(new_value);
 976   const char* value;
 977   char* free_this_too = NULL;
 978   if (old_len == 0) {
 979     value = new_value;
 980   } else if (new_len == 0) {
 981     value = old_value;
 982   } else {
 983      size_t length = old_len + 1 + new_len + 1;
 984      char* buf = NEW_C_HEAP_ARRAY(char, length, mtArguments);
 985     // each new setting adds another LINE to the switch:
 986     jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
 987     value = buf;
 988     free_this_too = buf;
 989   }
 990   (void) JVMFlag::ccstrAtPut(flag, &amp;value, origin);
 991   // JVMFlag always returns a pointer that needs freeing.
 992   FREE_C_HEAP_ARRAY(char, value);
 993   // JVMFlag made its own copy, so I must delete my own temp. buffer.
 994   FREE_C_HEAP_ARRAY(char, free_this_too);
 995   return true;
 996 }
 997 
 998 const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
 999   const char* real_name = real_flag_name(arg);
1000   JDK_Version since = JDK_Version();
1001   switch (is_deprecated_flag(arg, &amp;since)) {
1002   case -1: {
1003       // Obsolete or expired, so don&#39;t process normally,
1004       // but allow for an obsolete flag we&#39;re still
1005       // temporarily allowing.
1006       if (!is_obsolete_flag(arg, &amp;since)) {
1007         return real_name;
1008       }
1009       // Note if we&#39;re not considered obsolete then we can&#39;t be expired either
1010       // as obsoletion must come first.
1011       return NULL;
1012     }
1013     case 0:
1014       return real_name;
1015     case 1: {
1016       if (warn) {
1017         char version[256];
1018         since.to_string(version, sizeof(version));
1019         if (real_name != arg) {
1020           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.&quot;,
1021                   arg, version, real_name);
1022         } else {
1023           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release.&quot;,
1024                   arg, version);
1025         }
1026       }
1027       return real_name;
1028     }
1029   }
1030   ShouldNotReachHere();
1031   return NULL;
1032 }
1033 
1034 void log_deprecated_flag(const char* name, bool on, AliasedLoggingFlag alf) {
1035   LogTagType tagSet[] = {alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5};
1036   // Set tagset string buffer at max size of 256, large enough for any alias tagset
1037   const int max_tagset_size = 256;
1038   int max_tagset_len = max_tagset_size - 1;
1039   char tagset_buffer[max_tagset_size];
1040   tagset_buffer[0] = &#39;\0&#39;;
1041 
1042   // Write tag-set for aliased logging option, in string list form
1043   int max_tags = sizeof(tagSet)/sizeof(tagSet[0]);
1044   for (int i = 0; i &lt; max_tags &amp;&amp; tagSet[i] != LogTag::__NO_TAG; i++) {
1045     if (i &gt; 0) {
1046       strncat(tagset_buffer, &quot;+&quot;, max_tagset_len - strlen(tagset_buffer));
1047     }
1048     strncat(tagset_buffer, LogTag::name(tagSet[i]), max_tagset_len - strlen(tagset_buffer));
1049   }
1050   if (!alf.exactMatch) {
1051       strncat(tagset_buffer, &quot;*&quot;, max_tagset_len - strlen(tagset_buffer));
1052   }
1053   log_warning(arguments)(&quot;-XX:%s%s is deprecated. Will use -Xlog:%s=%s instead.&quot;,
1054                          (on) ? &quot;+&quot; : &quot;-&quot;,
1055                          name,
1056                          tagset_buffer,
1057                          (on) ? LogLevel::name(alf.level) : &quot;off&quot;);
1058 }
1059 
1060 AliasedLoggingFlag Arguments::catch_logging_aliases(const char* name, bool on){
1061   for (size_t i = 0; aliased_logging_flags[i].alias_name != NULL; i++) {
1062     const AliasedLoggingFlag&amp; alf = aliased_logging_flags[i];
1063     if (strcmp(alf.alias_name, name) == 0) {
1064       log_deprecated_flag(name, on, alf);
1065       return alf;
1066     }
1067   }
1068   AliasedLoggingFlag a = {NULL, LogLevel::Off, false, LOG_TAGS(_NO_TAG)};
1069   return a;
1070 }
1071 
1072 bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {
1073 
1074   // range of acceptable characters spelled out for portability reasons
1075 #define NAME_RANGE  &quot;[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]&quot;
1076 #define BUFLEN 255
1077   char name[BUFLEN+1];
1078   char dummy;
1079   const char* real_name;
1080   bool warn_if_deprecated = true;
1081 
1082   if (sscanf(arg, &quot;-%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1083     AliasedLoggingFlag alf = catch_logging_aliases(name, false);
1084     if (alf.alias_name != NULL){
1085       LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1086       return true;
1087     }
1088     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1089     if (real_name == NULL) {
1090       return false;
1091     }
1092     JVMFlag* flag = JVMFlag::find_flag(real_name);
1093     return set_bool_flag(flag, false, origin);
1094   }
1095   if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1096     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1097     if (alf.alias_name != NULL){
1098       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1099       return true;
1100     }
1101     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1102     if (real_name == NULL) {
1103       return false;
1104     }
1105     JVMFlag* flag = JVMFlag::find_flag(real_name);
1106     return set_bool_flag(flag, true, origin);
1107   }
1108 
1109   char punct;
1110   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1111     const char* value = strchr(arg, &#39;=&#39;) + 1;
1112 
1113     // this scanf pattern matches both strings (handled here) and numbers (handled later))
1114     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1115     if (alf.alias_name != NULL) {
1116       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1117       return true;
1118     }
1119     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1120     if (real_name == NULL) {
1121       return false;
1122     }
1123     JVMFlag* flag = JVMFlag::find_flag(real_name);
1124     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
1125       if (flag-&gt;ccstr_accumulates()) {
1126         return append_to_string_flag(flag, value, origin);
1127       } else {
1128         if (value[0] == &#39;\0&#39;) {
1129           value = NULL;
1130         }
1131         return set_string_flag(flag, value, origin);
1132       }
1133     } else {
1134       warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
1135     }
1136   }
1137 
1138   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;:%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1139     const char* value = strchr(arg, &#39;=&#39;) + 1;
1140     // -XX:Foo:=xxx will reset the string flag to the given value.
1141     if (value[0] == &#39;\0&#39;) {
1142       value = NULL;
1143     }
1144     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1145     if (real_name == NULL) {
1146       return false;
1147     }
1148     JVMFlag* flag = JVMFlag::find_flag(real_name);
1149     return set_string_flag(flag, value, origin);
1150   }
1151 
1152 #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
1153 #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
1154 #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
1155   char value[BUFLEN + 1];
1156   char value2[BUFLEN + 1];
1157   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_NUMBER_RANGE &quot;.&quot; &quot;%&quot; XSTR(BUFLEN) NUMBER_RANGE &quot;%c&quot;, name, value, value2, &amp;dummy) == 3) {
1158     // Looks like a floating-point number -- try again with more lenient format string
1159     if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1160       real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1161       if (real_name == NULL) {
1162         return false;
1163       }
1164       JVMFlag* flag = JVMFlag::find_flag(real_name);
1165       return set_fp_numeric_flag(flag, value, origin);
1166     }
1167   }
1168 
1169 #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
1170   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1171     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1172     if (real_name == NULL) {
1173       return false;
1174     }
1175     JVMFlag* flag = JVMFlag::find_flag(real_name);
1176     return set_numeric_flag(flag, value, origin);
1177   }
1178 
1179   return false;
1180 }
1181 
1182 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
1183   assert(bldarray != NULL, &quot;illegal argument&quot;);
1184 
1185   if (arg == NULL) {
1186     return;
1187   }
1188 
1189   int new_count = *count + 1;
1190 
1191   // expand the array and add arg to the last element
1192   if (*bldarray == NULL) {
1193     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtArguments);
1194   } else {
1195     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtArguments);
1196   }
1197   (*bldarray)[*count] = os::strdup_check_oom(arg);
1198   *count = new_count;
1199 }
1200 
1201 void Arguments::build_jvm_args(const char* arg) {
1202   add_string(&amp;_jvm_args_array, &amp;_num_jvm_args, arg);
1203 }
1204 
1205 void Arguments::build_jvm_flags(const char* arg) {
1206   add_string(&amp;_jvm_flags_array, &amp;_num_jvm_flags, arg);
1207 }
1208 
1209 // utility function to return a string that concatenates all
1210 // strings in a given char** array
1211 const char* Arguments::build_resource_string(char** args, int count) {
1212   if (args == NULL || count == 0) {
1213     return NULL;
1214   }
1215   size_t length = 0;
1216   for (int i = 0; i &lt; count; i++) {
1217     length += strlen(args[i]) + 1; // add 1 for a space or NULL terminating character
1218   }
1219   char* s = NEW_RESOURCE_ARRAY(char, length);
1220   char* dst = s;
1221   for (int j = 0; j &lt; count; j++) {
1222     size_t offset = strlen(args[j]) + 1; // add 1 for a space or NULL terminating character
1223     jio_snprintf(dst, length, &quot;%s &quot;, args[j]); // jio_snprintf will replace the last space character with NULL character
1224     dst += offset;
1225     length -= offset;
1226   }
1227   return (const char*) s;
1228 }
1229 
1230 void Arguments::print_on(outputStream* st) {
1231   st-&gt;print_cr(&quot;VM Arguments:&quot;);
1232   if (num_jvm_flags() &gt; 0) {
1233     st-&gt;print(&quot;jvm_flags: &quot;); print_jvm_flags_on(st);
1234     st-&gt;cr();
1235   }
1236   if (num_jvm_args() &gt; 0) {
1237     st-&gt;print(&quot;jvm_args: &quot;); print_jvm_args_on(st);
1238     st-&gt;cr();
1239   }
1240   st-&gt;print_cr(&quot;java_command: %s&quot;, java_command() ? java_command() : &quot;&lt;unknown&gt;&quot;);
1241   if (_java_class_path != NULL) {
1242     char* path = _java_class_path-&gt;value();
1243     st-&gt;print_cr(&quot;java_class_path (initial): %s&quot;, strlen(path) == 0 ? &quot;&lt;not set&gt;&quot; : path );
1244   }
1245   st-&gt;print_cr(&quot;Launcher Type: %s&quot;, _sun_java_launcher);
1246 }
1247 
1248 void Arguments::print_summary_on(outputStream* st) {
1249   // Print the command line.  Environment variables that are helpful for
1250   // reproducing the problem are written later in the hs_err file.
1251   // flags are from setting file
1252   if (num_jvm_flags() &gt; 0) {
1253     st-&gt;print_raw(&quot;Settings File: &quot;);
1254     print_jvm_flags_on(st);
1255     st-&gt;cr();
1256   }
1257   // args are the command line and environment variable arguments.
1258   st-&gt;print_raw(&quot;Command Line: &quot;);
1259   if (num_jvm_args() &gt; 0) {
1260     print_jvm_args_on(st);
1261   }
1262   // this is the classfile and any arguments to the java program
1263   if (java_command() != NULL) {
1264     st-&gt;print(&quot;%s&quot;, java_command());
1265   }
1266   st-&gt;cr();
1267 }
1268 
1269 void Arguments::print_jvm_flags_on(outputStream* st) {
1270   if (_num_jvm_flags &gt; 0) {
1271     for (int i=0; i &lt; _num_jvm_flags; i++) {
1272       st-&gt;print(&quot;%s &quot;, _jvm_flags_array[i]);
1273     }
1274   }
1275 }
1276 
1277 void Arguments::print_jvm_args_on(outputStream* st) {
1278   if (_num_jvm_args &gt; 0) {
1279     for (int i=0; i &lt; _num_jvm_args; i++) {
1280       st-&gt;print(&quot;%s &quot;, _jvm_args_array[i]);
1281     }
1282   }
1283 }
1284 
1285 bool Arguments::process_argument(const char* arg,
1286                                  jboolean ignore_unrecognized,
1287                                  JVMFlag::Flags origin) {
1288   JDK_Version since = JDK_Version();
1289 
1290   if (parse_argument(arg, origin)) {
1291     return true;
1292   }
1293 
1294   // Determine if the flag has &#39;+&#39;, &#39;-&#39;, or &#39;=&#39; characters.
1295   bool has_plus_minus = (*arg == &#39;+&#39; || *arg == &#39;-&#39;);
1296   const char* const argname = has_plus_minus ? arg + 1 : arg;
1297 
1298   size_t arg_len;
1299   const char* equal_sign = strchr(argname, &#39;=&#39;);
1300   if (equal_sign == NULL) {
1301     arg_len = strlen(argname);
1302   } else {
1303     arg_len = equal_sign - argname;
1304   }
1305 
1306   // Only make the obsolete check for valid arguments.
1307   if (arg_len &lt;= BUFLEN) {
1308     // Construct a string which consists only of the argument name without &#39;+&#39;, &#39;-&#39;, or &#39;=&#39;.
1309     char stripped_argname[BUFLEN+1]; // +1 for &#39;\0&#39;
1310     jio_snprintf(stripped_argname, arg_len+1, &quot;%s&quot;, argname); // +1 for &#39;\0&#39;
1311     if (is_obsolete_flag(stripped_argname, &amp;since)) {
1312       char version[256];
1313       since.to_string(version, sizeof(version));
1314       warning(&quot;Ignoring option %s; support was removed in %s&quot;, stripped_argname, version);
1315       return true;
1316     }
1317 #ifndef PRODUCT
1318     else {
1319       const char* replacement;
1320       if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){
1321         log_warning(arguments)(&quot;%s has been removed. Please use %s instead.&quot;,
1322                                stripped_argname,
1323                                replacement);
1324         return false;
1325       }
1326     }
1327 #endif //PRODUCT
1328   }
1329 
1330   // For locked flags, report a custom error message if available.
1331   // Otherwise, report the standard unrecognized VM option.
1332   const JVMFlag* found_flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);
1333   if (found_flag != NULL) {
1334     char locked_message_buf[BUFLEN];
1335     JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
1336     if (strlen(locked_message_buf) == 0) {
1337       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
1338         jio_fprintf(defaultStream::error_stream(),
1339           &quot;Missing +/- setting for VM option &#39;%s&#39;\n&quot;, argname);
1340       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
1341         jio_fprintf(defaultStream::error_stream(),
1342           &quot;Unexpected +/- setting in VM option &#39;%s&#39;\n&quot;, argname);
1343       } else {
1344         jio_fprintf(defaultStream::error_stream(),
1345           &quot;Improperly specified VM option &#39;%s&#39;\n&quot;, argname);
1346       }
1347     } else {
1348 #ifdef PRODUCT
1349       bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||
1350                          (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));
1351       if (ignore_unrecognized &amp;&amp; mismatched) {
1352         return true;
1353       }
1354 #endif
1355       jio_fprintf(defaultStream::error_stream(), &quot;%s&quot;, locked_message_buf);
1356     }
1357   } else {
1358     if (ignore_unrecognized) {
1359       return true;
1360     }
1361     jio_fprintf(defaultStream::error_stream(),
1362                 &quot;Unrecognized VM option &#39;%s&#39;\n&quot;, argname);
1363     JVMFlag* fuzzy_matched = JVMFlag::fuzzy_match((const char*)argname, arg_len, true);
1364     if (fuzzy_matched != NULL) {
1365       jio_fprintf(defaultStream::error_stream(),
1366                   &quot;Did you mean &#39;%s%s%s&#39;? &quot;,
1367                   (fuzzy_matched-&gt;is_bool()) ? &quot;(+/-)&quot; : &quot;&quot;,
1368                   fuzzy_matched-&gt;_name,
1369                   (fuzzy_matched-&gt;is_bool()) ? &quot;&quot; : &quot;=&lt;value&gt;&quot;);
1370     }
1371   }
1372 
1373   // allow for commandline &quot;commenting out&quot; options like -XX:#+Verbose
1374   return arg[0] == &#39;#&#39;;
1375 }
1376 
1377 bool Arguments::process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized) {
1378   FILE* stream = fopen(file_name, &quot;rb&quot;);
1379   if (stream == NULL) {
1380     if (should_exist) {
1381       jio_fprintf(defaultStream::error_stream(),
1382                   &quot;Could not open settings file %s\n&quot;, file_name);
1383       return false;
1384     } else {
1385       return true;
1386     }
1387   }
1388 
1389   char token[1024];
1390   int  pos = 0;
1391 
1392   bool in_white_space = true;
1393   bool in_comment     = false;
1394   bool in_quote       = false;
1395   char quote_c        = 0;
1396   bool result         = true;
1397 
1398   int c = getc(stream);
1399   while(c != EOF &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
1400     if (in_white_space) {
1401       if (in_comment) {
1402         if (c == &#39;\n&#39;) in_comment = false;
1403       } else {
1404         if (c == &#39;#&#39;) in_comment = true;
1405         else if (!isspace(c)) {
1406           in_white_space = false;
1407           token[pos++] = c;
1408         }
1409       }
1410     } else {
1411       if (c == &#39;\n&#39; || (!in_quote &amp;&amp; isspace(c))) {
1412         // token ends at newline, or at unquoted whitespace
1413         // this allows a way to include spaces in string-valued options
1414         token[pos] = &#39;\0&#39;;
1415         logOption(token);
1416         result &amp;= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);
1417         build_jvm_flags(token);
1418         pos = 0;
1419         in_white_space = true;
1420         in_quote = false;
1421       } else if (!in_quote &amp;&amp; (c == &#39;\&#39;&#39; || c == &#39;&quot;&#39;)) {
1422         in_quote = true;
1423         quote_c = c;
1424       } else if (in_quote &amp;&amp; (c == quote_c)) {
1425         in_quote = false;
1426       } else {
1427         token[pos++] = c;
1428       }
1429     }
1430     c = getc(stream);
1431   }
1432   if (pos &gt; 0) {
1433     token[pos] = &#39;\0&#39;;
1434     result &amp;= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);
1435     build_jvm_flags(token);
1436   }
1437   fclose(stream);
1438   return result;
1439 }
1440 
1441 //=============================================================================================================
1442 // Parsing of properties (-D)
1443 
1444 const char* Arguments::get_property(const char* key) {
1445   return PropertyList_get_value(system_properties(), key);
1446 }
1447 
1448 bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {
1449   const char* eq = strchr(prop, &#39;=&#39;);
1450   const char* key;
1451   const char* value = &quot;&quot;;
1452 
1453   if (eq == NULL) {
1454     // property doesn&#39;t have a value, thus use passed string
1455     key = prop;
1456   } else {
1457     // property have a value, thus extract it and save to the
1458     // allocated string
1459     size_t key_len = eq - prop;
1460     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1461 
1462     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1463     key = tmp_key;
1464 
1465     value = &amp;prop[key_len + 1];
1466   }
1467 
1468   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1469     process_java_compiler_argument(value);
1470     // Record value in Arguments, but let it get passed to Java.
1471   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {
1472     // sun.java.launcher.is_altjvm property is
1473     // private and is processed in process_sun_java_launcher_properties();
1474     // the sun.java.launcher property is passed on to the java application
1475   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1476     // append is true, writable is true, internal is false
1477     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1478                             WriteableProperty, ExternalProperty);
1479   } else {
1480     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1481       char *old_java_command = _java_command;
1482       _java_command = os::strdup_check_oom(value, mtArguments);
1483       if (old_java_command != NULL) {
1484         os::free(old_java_command);
1485       }
1486     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
1487       // If this property is set on the command line then its value will be
1488       // displayed in VM error logs as the URL at which to submit such logs.
1489       // Normally the URL displayed in error logs is different from the value
1490       // of this system property, so a different property should have been
1491       // used here, but we leave this as-is in case someone depends upon it.
1492       const char* old_java_vendor_url_bug = _java_vendor_url_bug;
1493       // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1494       // its value without going through the property list or making a Java call.
1495       _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
1496       if (old_java_vendor_url_bug != NULL) {
1497         os::free((void *)old_java_vendor_url_bug);
1498       }
1499     }
1500 
1501     // Create new property and add at the end of the list
1502     PropertyList_unique_add(&amp;_system_properties, key, value, AddProperty, writeable, internal);
1503   }
1504 
1505   if (key != prop) {
1506     // SystemProperty copy passed value, thus free previously allocated
1507     // memory
1508     FreeHeap((void *)key);
1509   }
1510 
1511   return true;
1512 }
1513 
1514 #if INCLUDE_CDS
1515 const char* unsupported_properties[] = { &quot;jdk.module.limitmods&quot;,
1516                                          &quot;jdk.module.upgrade.path&quot;,
1517                                          &quot;jdk.module.patch.0&quot; };
1518 const char* unsupported_options[] = { &quot;--limit-modules&quot;,
1519                                       &quot;--upgrade-module-path&quot;,
1520                                       &quot;--patch-module&quot;
1521                                     };
1522 void Arguments::check_unsupported_dumping_properties() {
1523   assert(is_dumping_archive(),
1524          &quot;this function is only used with CDS dump time&quot;);
1525   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1526   // If a vm option is found in the unsupported_options array, vm will exit with an error message.
1527   SystemProperty* sp = system_properties();
1528   while (sp != NULL) {
1529     for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1530       if (strcmp(sp-&gt;key(), unsupported_properties[i]) == 0) {
1531         vm_exit_during_initialization(
1532           &quot;Cannot use the following option when dumping the shared archive&quot;, unsupported_options[i]);
1533       }
1534     }
1535     sp = sp-&gt;next();
1536   }
1537 
1538   // Check for an exploded module build in use with -Xshare:dump.
1539   if (!has_jimage()) {
1540     vm_exit_during_initialization(&quot;Dumping the shared archive is not supported with an exploded module build&quot;);
1541   }
1542 }
1543 
1544 bool Arguments::check_unsupported_cds_runtime_properties() {
1545   assert(UseSharedSpaces, &quot;this function is only used with -Xshare:{on,auto}&quot;);
1546   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1547   if (ArchiveClassesAtExit != NULL) {
1548     // dynamic dumping, just return false for now.
1549     // check_unsupported_dumping_properties() will be called later to check the same set of
1550     // properties, and will exit the VM with the correct error message if the unsupported properties
1551     // are used.
1552     return false;
1553   }
1554   for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1555     if (get_property(unsupported_properties[i]) != NULL) {
1556       if (RequireSharedSpaces) {
1557         warning(&quot;CDS is disabled when the %s option is specified.&quot;, unsupported_options[i]);
1558       }
1559       return true;
1560     }
1561   }
1562   return false;
1563 }
1564 #endif
1565 
1566 //===========================================================================================================
1567 // Setting int/mixed/comp mode flags
1568 
1569 void Arguments::set_mode_flags(Mode mode) {
1570   // Set up default values for all flags.
1571   // If you add a flag to any of the branches below,
1572   // add a default value for it here.
1573   set_java_compiler(false);
1574   _mode                      = mode;
1575 
1576   // Ensure Agent_OnLoad has the correct initial values.
1577   // This may not be the final mode; mode may change later in onload phase.
1578   PropertyList_unique_add(&amp;_system_properties, &quot;java.vm.info&quot;,
1579                           VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty);
1580 
1581   UseInterpreter             = true;
1582   UseCompiler                = true;
1583   UseLoopCounter             = true;
1584 
1585   // Default values may be platform/compiler dependent -
1586   // use the saved values
1587   ClipInlining               = Arguments::_ClipInlining;
1588   AlwaysCompileLoopMethods   = Arguments::_AlwaysCompileLoopMethods;
1589   UseOnStackReplacement      = Arguments::_UseOnStackReplacement;
1590   BackgroundCompilation      = Arguments::_BackgroundCompilation;
1591   if (TieredCompilation) {
1592     if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {
1593       Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;
1594     }
1595     if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {
1596       Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;
1597     }
1598   }
1599 
1600   // Change from defaults based on mode
1601   switch (mode) {
1602   default:
1603     ShouldNotReachHere();
1604     break;
1605   case _int:
1606     UseCompiler              = false;
1607     UseLoopCounter           = false;
1608     AlwaysCompileLoopMethods = false;
1609     UseOnStackReplacement    = false;
1610     break;
1611   case _mixed:
1612     // same as default
1613     break;
1614   case _comp:
1615     UseInterpreter           = false;
1616     BackgroundCompilation    = false;
1617     ClipInlining             = false;
1618     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1619     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1620     // compile a level 4 (C2) and then continue executing it.
1621     if (TieredCompilation) {
1622       Tier3InvokeNotifyFreqLog = 0;
1623       Tier4InvocationThreshold = 0;
1624     }
1625     break;
1626   }
1627 }
1628 
1629 // Conflict: required to use shared spaces (-Xshare:on), but
1630 // incompatible command line options were chosen.
1631 static void no_shared_spaces(const char* message) {
1632   if (RequireSharedSpaces) {
1633     jio_fprintf(defaultStream::error_stream(),
1634       &quot;Class data sharing is inconsistent with other specified options.\n&quot;);
1635     vm_exit_during_initialization(&quot;Unable to use shared archive&quot;, message);
1636   } else {
1637     log_info(cds)(&quot;Unable to use shared archive: %s&quot;, message);
1638     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1639   }
1640 }
1641 
1642 void set_object_alignment() {
1643   // Object alignment.
1644   assert(is_power_of_2(ObjectAlignmentInBytes), &quot;ObjectAlignmentInBytes must be power of 2&quot;);
1645   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1646   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, &quot;ObjectAlignmentInBytes value is too small&quot;);
1647   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1648   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, &quot;ObjectAlignmentInBytes value is incorrect&quot;);
1649   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1650 
1651   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1652   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1653 
1654   // Oop encoding heap max
1655   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1656 
1657   if (SurvivorAlignmentInBytes == 0) {
1658     SurvivorAlignmentInBytes = ObjectAlignmentInBytes;
1659   }
1660 }
1661 
1662 size_t Arguments::max_heap_for_compressed_oops() {
1663   // Avoid sign flip.
1664   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), &quot;Unusual page size&quot;);
1665   // We need to fit both the NULL page and the heap into the memory budget, while
1666   // keeping alignment constraints of the heap. To guarantee the latter, as the
1667   // NULL page is located before the heap, we pad the NULL page to the conservative
1668   // maximum alignment that the GC may ever impose upon the heap.
1669   size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),
1670                                                   _conservative_max_heap_alignment);
1671 
1672   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1673   NOT_LP64(ShouldNotReachHere(); return 0);
1674 }
1675 
1676 void Arguments::set_use_compressed_oops() {
1677 #ifndef ZERO
1678 #ifdef _LP64
1679   // MaxHeapSize is not set up properly at this point, but
1680   // the only value that can override MaxHeapSize if we are
1681   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1682   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1683 
1684   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1685     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1686       FLAG_SET_ERGO(UseCompressedOops, true);
1687     }
1688   } else {
1689     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1690       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1691       FLAG_SET_DEFAULT(UseCompressedOops, false);
1692       if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {
1693         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1694       }
1695     }
1696   }
1697 #endif // _LP64
1698 #endif // ZERO
1699 }
1700 
1701 
1702 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1703 // set_use_compressed_oops().
1704 void Arguments::set_use_compressed_klass_ptrs() {
1705 #ifndef ZERO
1706 #ifdef _LP64
1707   // On some architectures, the use of UseCompressedClassPointers implies the use of
1708   // UseCompressedOops. The reason is that the rheap_base register of said platforms
1709   // is reused to perform some optimized spilling, in order to use rheap_base as a
1710   // temp register. But by treating it as any other temp register, spilling can typically
1711   // be completely avoided instead. So it is better not to perform this trick. And by
1712   // not having that reliance, large heaps, or heaps not supporting compressed oops,
1713   // can still use compressed class pointers.
1714   if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS &amp;&amp; !UseCompressedOops) {
1715     if (UseCompressedClassPointers) {
1716       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1717     }
1718     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1719   } else {
1720     // Turn on UseCompressedClassPointers too
1721     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1722       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1723     }
1724     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1725     if (UseCompressedClassPointers) {
1726       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1727         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1728         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1729       }
1730     }
1731   }
1732 #endif // _LP64
1733 #endif // !ZERO
1734 }
1735 
1736 void Arguments::set_conservative_max_heap_alignment() {
1737   // The conservative maximum required alignment for the heap is the maximum of
1738   // the alignments imposed by several sources: any requirements from the heap
1739   // itself and the maximum page size we may run the VM with.
1740   size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
1741   _conservative_max_heap_alignment = MAX4(heap_alignment,
1742                                           (size_t)os::vm_allocation_granularity(),
1743                                           os::max_page_size(),
1744                                           GCArguments::compute_heap_alignment());
1745 }
1746 
1747 jint Arguments::set_ergonomics_flags() {
1748   GCConfig::initialize();
1749 
1750   set_conservative_max_heap_alignment();
1751 
1752 #ifndef ZERO
1753 #ifdef _LP64
1754   set_use_compressed_oops();
1755 
1756   // set_use_compressed_klass_ptrs() must be called after calling
1757   // set_use_compressed_oops().
1758   set_use_compressed_klass_ptrs();
1759 
1760   // Also checks that certain machines are slower with compressed oops
1761   // in vm_version initialization code.
1762 #endif // _LP64
1763 #endif // !ZERO
1764 
1765   return JNI_OK;
1766 }
1767 
1768 julong Arguments::limit_by_allocatable_memory(julong limit) {
1769   julong max_allocatable;
1770   julong result = limit;
1771   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1772     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1773   }
1774   return result;
1775 }
1776 
1777 // Use static initialization to get the default before parsing
1778 static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1779 
1780 void Arguments::set_heap_size() {
1781   julong phys_mem;
1782 
1783   // If the user specified one of these options, they
1784   // want specific memory sizing so do not limit memory
1785   // based on compressed oops addressability.
1786   // Also, memory limits will be calculated based on
1787   // available os physical memory, not our MaxRAM limit,
1788   // unless MaxRAM is also specified.
1789   bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||
1790                            !FLAG_IS_DEFAULT(MaxRAMFraction) ||
1791                            !FLAG_IS_DEFAULT(MinRAMPercentage) ||
1792                            !FLAG_IS_DEFAULT(MinRAMFraction) ||
1793                            !FLAG_IS_DEFAULT(InitialRAMPercentage) ||
1794                            !FLAG_IS_DEFAULT(InitialRAMFraction) ||
1795                            !FLAG_IS_DEFAULT(MaxRAM));
1796   if (override_coop_limit) {
1797     if (FLAG_IS_DEFAULT(MaxRAM)) {
1798       phys_mem = os::physical_memory();
1799       FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);
1800     } else {
1801       phys_mem = (julong)MaxRAM;
1802     }
1803   } else {
1804     phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)
1805                                        : (julong)MaxRAM;
1806   }
1807 
1808 
1809   // Convert deprecated flags
1810   if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
1811       !FLAG_IS_DEFAULT(MaxRAMFraction))
1812     MaxRAMPercentage = 100.0 / MaxRAMFraction;
1813 
1814   if (FLAG_IS_DEFAULT(MinRAMPercentage) &amp;&amp;
1815       !FLAG_IS_DEFAULT(MinRAMFraction))
1816     MinRAMPercentage = 100.0 / MinRAMFraction;
1817 
1818   if (FLAG_IS_DEFAULT(InitialRAMPercentage) &amp;&amp;
1819       !FLAG_IS_DEFAULT(InitialRAMFraction))
1820     InitialRAMPercentage = 100.0 / InitialRAMFraction;
1821 
1822   // If the maximum heap size has not been set with -Xmx,
1823   // then set it as fraction of the size of physical memory,
1824   // respecting the maximum and minimum sizes of the heap.
1825   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1826     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1827     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1828     if (reasonable_min &lt; MaxHeapSize) {
1829       // Small physical memory, so use a minimum fraction of it for the heap
1830       reasonable_max = reasonable_min;
1831     } else {
1832       // Not-small physical memory, so require a heap at least
1833       // as large as MaxHeapSize
1834       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1835     }
1836 
1837     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1838       // Limit the heap size to ErgoHeapSizeLimit
1839       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1840     }
1841 
1842 #ifdef _LP64
1843     if (UseCompressedOops || UseCompressedClassPointers) {
1844       // HeapBaseMinAddress can be greater than default but not less than.
1845       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1846         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1847           // matches compressed oops printing flags
1848           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1849                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1850                                      DefaultHeapBaseMinAddress,
1851                                      DefaultHeapBaseMinAddress/G,
1852                                      HeapBaseMinAddress);
1853           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1854         }
1855       }
1856     }
1857     if (UseCompressedOops) {
1858       // Limit the heap size to the maximum possible when using compressed oops
1859       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1860 
1861       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1862         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1863         // but it should be not less than default MaxHeapSize.
1864         max_coop_heap -= HeapBaseMinAddress;
1865       }
1866 
1867       // If user specified flags prioritizing os physical
1868       // memory limits, then disable compressed oops if
1869       // limits exceed max_coop_heap and UseCompressedOops
1870       // was not specified.
1871       if (reasonable_max &gt; max_coop_heap) {
1872         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1873           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1874             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1875             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1876             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1877           FLAG_SET_ERGO(UseCompressedOops, false);
1878           if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {
1879             FLAG_SET_ERGO(UseCompressedClassPointers, false);
1880           }
1881         } else {
1882           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1883         }
1884       }
1885     }
1886 #endif // _LP64
1887 
1888     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1889 
1890     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1891       // An initial heap size was specified on the command line,
1892       // so be sure that the maximum size is consistent.  Done
1893       // after call to limit_by_allocatable_memory because that
1894       // method might reduce the allocation size.
1895       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1896     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1897       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1898     }
1899 
1900     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
1901     FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);
1902   }
1903 
1904   // If the minimum or initial heap_size have not been set or requested to be set
1905   // ergonomically, set them accordingly.
1906   if (InitialHeapSize == 0 || MinHeapSize == 0) {
1907     julong reasonable_minimum = (julong)(OldSize + NewSize);
1908 
1909     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1910 
1911     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1912 
1913     if (InitialHeapSize == 0) {
1914       julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
1915 
1916       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);
1917       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1918 
1919       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1920 
1921       FLAG_SET_ERGO(InitialHeapSize, (size_t)reasonable_initial);
1922       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, InitialHeapSize);
1923     }
1924     // If the minimum heap size has not been set (via -Xms or -XX:MinHeapSize),
1925     // synchronize with InitialHeapSize to avoid errors with the default value.
1926     if (MinHeapSize == 0) {
1927       FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));
1928       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, MinHeapSize);
1929     }
1930   }
1931 }
1932 
1933 // This option inspects the machine and attempts to set various
1934 // parameters to be optimal for long-running, memory allocation
1935 // intensive jobs.  It is intended for machines with large
1936 // amounts of cpu and memory.
1937 jint Arguments::set_aggressive_heap_flags() {
1938   // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
1939   // VM, but we may not be able to represent the total physical memory
1940   // available (like having 8gb of memory on a box but using a 32bit VM).
1941   // Thus, we need to make sure we&#39;re using a julong for intermediate
1942   // calculations.
1943   julong initHeapSize;
1944   julong total_memory = os::physical_memory();
1945 
1946   if (total_memory &lt; (julong) 256 * M) {
1947     jio_fprintf(defaultStream::error_stream(),
1948             &quot;You need at least 256mb of memory to use -XX:+AggressiveHeap\n&quot;);
1949     vm_exit(1);
1950   }
1951 
1952   // The heap size is half of available memory, or (at most)
1953   // all of possible memory less 160mb (leaving room for the OS
1954   // when using ISM).  This is the maximum; because adaptive sizing
1955   // is turned on below, the actual space used may be smaller.
1956 
1957   initHeapSize = MIN2(total_memory / (julong) 2,
1958           total_memory - (julong) 160 * M);
1959 
1960   initHeapSize = limit_by_allocatable_memory(initHeapSize);
1961 
1962   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1963     if (FLAG_SET_CMDLINE(MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1964       return JNI_EINVAL;
1965     }
1966     if (FLAG_SET_CMDLINE(InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1967       return JNI_EINVAL;
1968     }
1969     if (FLAG_SET_CMDLINE(MinHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1970       return JNI_EINVAL;
1971     }
1972   }
1973   if (FLAG_IS_DEFAULT(NewSize)) {
1974     // Make the young generation 3/8ths of the total heap.
1975     if (FLAG_SET_CMDLINE(NewSize,
1976             ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
1977       return JNI_EINVAL;
1978     }
1979     if (FLAG_SET_CMDLINE(MaxNewSize, NewSize) != JVMFlag::SUCCESS) {
1980       return JNI_EINVAL;
1981     }
1982   }
1983 
1984 #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
1985   FLAG_SET_DEFAULT(UseLargePages, true);
1986 #endif
1987 
1988   // Increase some data structure sizes for efficiency
1989   if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {
1990     return JNI_EINVAL;
1991   }
1992   if (FLAG_SET_CMDLINE(ResizeTLAB, false) != JVMFlag::SUCCESS) {
1993     return JNI_EINVAL;
1994   }
1995   if (FLAG_SET_CMDLINE(TLABSize, 256 * K) != JVMFlag::SUCCESS) {
1996     return JNI_EINVAL;
1997   }
1998 
1999   // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
2000   // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
2001   // space per-gc-thread buffers.  The default is 4kw.
2002   if (FLAG_SET_CMDLINE(YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words
2003     return JNI_EINVAL;
2004   }
2005 
2006   // OldPLABSize is the size of the buffers in the old gen that
2007   // UseParallelGC uses to promote live data that doesn&#39;t fit in the
2008   // survivor spaces.  At any given time, there&#39;s one for each gc thread.
2009   // The default size is 1kw. These buffers are rarely used, since the
2010   // survivor spaces are usually big enough.  For specjbb, however, there
2011   // are occasions when there&#39;s lots of live data in the young gen
2012   // and we end up promoting some of it.  We don&#39;t have a definite
2013   // explanation for why bumping OldPLABSize helps, but the theory
2014   // is that a bigger PLAB results in retaining something like the
2015   // original allocation order after promotion, which improves mutator
2016   // locality.  A minor effect may be that larger PLABs reduce the
2017   // number of PLAB allocation events during gc.  The value of 8kw
2018   // was arrived at by experimenting with specjbb.
2019   if (FLAG_SET_CMDLINE(OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words
2020     return JNI_EINVAL;
2021   }
2022 
2023   // Enable parallel GC and adaptive generation sizing
2024   if (FLAG_SET_CMDLINE(UseParallelGC, true) != JVMFlag::SUCCESS) {
2025     return JNI_EINVAL;
2026   }
2027 
2028   // Encourage steady state memory management
2029   if (FLAG_SET_CMDLINE(ThresholdTolerance, 100) != JVMFlag::SUCCESS) {
2030     return JNI_EINVAL;
2031   }
2032 
2033   // This appears to improve mutator locality
2034   if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {
2035     return JNI_EINVAL;
2036   }
2037 
2038   return JNI_OK;
2039 }
2040 
2041 // This must be called after ergonomics.
2042 void Arguments::set_bytecode_flags() {
2043   if (!RewriteBytecodes) {
2044     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
2045   }
2046 }
2047 
2048 // Aggressive optimization flags
2049 jint Arguments::set_aggressive_opts_flags() {
2050 #ifdef COMPILER2
2051   if (AggressiveUnboxing) {
2052     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
2053       FLAG_SET_DEFAULT(EliminateAutoBox, true);
2054     } else if (!EliminateAutoBox) {
2055       // warning(&quot;AggressiveUnboxing is disabled because EliminateAutoBox is disabled&quot;);
2056       AggressiveUnboxing = false;
2057     }
2058     if (FLAG_IS_DEFAULT(DoEscapeAnalysis)) {
2059       FLAG_SET_DEFAULT(DoEscapeAnalysis, true);
2060     } else if (!DoEscapeAnalysis) {
2061       // warning(&quot;AggressiveUnboxing is disabled because DoEscapeAnalysis is disabled&quot;);
2062       AggressiveUnboxing = false;
2063     }
2064   }
2065   if (!FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
2066     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
2067       FLAG_SET_DEFAULT(EliminateAutoBox, true);
2068     }
2069     // Feed the cache size setting into the JDK
2070     char buffer[1024];
2071     jio_snprintf(buffer, 1024, &quot;java.lang.Integer.IntegerCache.high=&quot; INTX_FORMAT, AutoBoxCacheMax);
2072     if (!add_property(buffer)) {
2073       return JNI_ENOMEM;
2074     }
2075   }
2076 #endif
2077 
2078   return JNI_OK;
2079 }
2080 
2081 //===========================================================================================================
2082 // Parsing of java.compiler property
2083 
2084 void Arguments::process_java_compiler_argument(const char* arg) {
2085   // For backwards compatibility, Djava.compiler=NONE or &quot;&quot;
2086   // causes us to switch to -Xint mode UNLESS -Xdebug
2087   // is also specified.
2088   if (strlen(arg) == 0 || strcasecmp(arg, &quot;NONE&quot;) == 0) {
2089     set_java_compiler(true);    // &quot;-Djava.compiler[=...]&quot; most recently seen.
2090   }
2091 }
2092 
2093 void Arguments::process_java_launcher_argument(const char* launcher, void* extra_info) {
2094   _sun_java_launcher = os::strdup_check_oom(launcher);
2095 }
2096 
2097 bool Arguments::created_by_java_launcher() {
2098   assert(_sun_java_launcher != NULL, &quot;property must have value&quot;);
2099   return strcmp(DEFAULT_JAVA_LAUNCHER, _sun_java_launcher) != 0;
2100 }
2101 
2102 bool Arguments::sun_java_launcher_is_altjvm() {
2103   return _sun_java_launcher_is_altjvm;
2104 }
2105 
2106 //===========================================================================================================
2107 // Parsing of main arguments
2108 
2109 unsigned int addreads_count = 0;
2110 unsigned int addexports_count = 0;
2111 unsigned int addopens_count = 0;
2112 unsigned int addmods_count = 0;
2113 unsigned int patch_mod_count = 0;
2114 
2115 // Check the consistency of vm_init_args
2116 bool Arguments::check_vm_args_consistency() {
2117   // Method for adding checks for flag consistency.
2118   // The intent is to warn the user of all possible conflicts,
2119   // before returning an error.
2120   // Note: Needs platform-dependent factoring.
2121   bool status = true;
2122 
2123   if (TLABRefillWasteFraction == 0) {
2124     jio_fprintf(defaultStream::error_stream(),
2125                 &quot;TLABRefillWasteFraction should be a denominator, &quot;
2126                 &quot;not &quot; SIZE_FORMAT &quot;\n&quot;,
2127                 TLABRefillWasteFraction);
2128     status = false;
2129   }
2130 
2131   if (PrintNMTStatistics) {
2132 #if INCLUDE_NMT
2133     if (MemTracker::tracking_level() == NMT_off) {
2134 #endif // INCLUDE_NMT
2135       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2136       PrintNMTStatistics = false;
2137 #if INCLUDE_NMT
2138     }
2139 #endif
2140   }
2141 
2142   status = CompilerConfig::check_args_consistency(status);
2143 #if INCLUDE_JVMCI
2144   if (status &amp;&amp; EnableJVMCI) {
2145     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2146         AddProperty, UnwriteableProperty, InternalProperty);
<a name="3" id="anc3"></a><span class="line-modified">2147     if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {</span>
2148       return false;
2149     }
2150   }
2151 #endif
2152 
2153 #ifndef SUPPORT_RESERVED_STACK_AREA
2154   if (StackReservedPages != 0) {
2155     FLAG_SET_CMDLINE(StackReservedPages, 0);
2156     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2157   }
2158 #endif
2159 
2160   status = status &amp;&amp; GCArguments::check_args_consistency();
2161 
2162   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {
2163     FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);
2164     warning(&quot;InlineTypePassFieldsAsArgs is not supported on this platform&quot;);
2165   }
2166 
2167   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {
2168     FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);
2169     warning(&quot;InlineTypeReturnedAsFields is not supported on this platform&quot;);
2170   }
2171 
2172   return status;
2173 }
2174 
2175 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2176   const char* option_type) {
2177   if (ignore) return false;
2178 
2179   const char* spacer = &quot; &quot;;
2180   if (option_type == NULL) {
2181     option_type = ++spacer; // Set both to the empty string.
2182   }
2183 
2184   jio_fprintf(defaultStream::error_stream(),
2185               &quot;Unrecognized %s%soption: %s\n&quot;, option_type, spacer,
2186               option-&gt;optionString);
2187   return true;
2188 }
2189 
2190 static const char* user_assertion_options[] = {
2191   &quot;-da&quot;, &quot;-ea&quot;, &quot;-disableassertions&quot;, &quot;-enableassertions&quot;, 0
2192 };
2193 
2194 static const char* system_assertion_options[] = {
2195   &quot;-dsa&quot;, &quot;-esa&quot;, &quot;-disablesystemassertions&quot;, &quot;-enablesystemassertions&quot;, 0
2196 };
2197 
2198 bool Arguments::parse_uintx(const char* value,
2199                             uintx* uintx_arg,
2200                             uintx min_size) {
2201 
2202   // Check the sign first since atojulong() parses only unsigned values.
2203   bool value_is_positive = !(*value == &#39;-&#39;);
2204 
2205   if (value_is_positive) {
2206     julong n;
2207     bool good_return = atojulong(value, &amp;n);
2208     if (good_return) {
2209       bool above_minimum = n &gt;= min_size;
2210       bool value_is_too_large = n &gt; max_uintx;
2211 
2212       if (above_minimum &amp;&amp; !value_is_too_large) {
2213         *uintx_arg = n;
2214         return true;
2215       }
2216     }
2217   }
2218   return false;
2219 }
2220 
<a name="4" id="anc4"></a><span class="line-modified">2221 bool Arguments::create_module_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {</span>
<span class="line-added">2222   assert(is_internal_module_property(prop_name) ||</span>
<span class="line-added">2223          strcmp(prop_name, &quot;jdk.module.illegalAccess&quot;) == 0, &quot;unknown module property: &#39;%s&#39;&quot;, prop_name);</span>
2224   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2225   char* property = AllocateHeap(prop_len, mtArguments);
2226   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2227   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2228     FreeHeap(property);
2229     return false;
2230   }
<a name="5" id="anc5"></a><span class="line-modified">2231   // These are not strictly writeable properties as they cannot be set via -Dprop=val. But that</span>
<span class="line-added">2232   // is enforced by checking is_internal_module_property(). We need the property to be writeable so</span>
<span class="line-added">2233   // that multiple occurrences of the associated flag just causes the existing property value to be</span>
<span class="line-added">2234   // replaced (&quot;last option wins&quot;). Otherwise we would need to keep track of the flags and only convert</span>
<span class="line-added">2235   // to a property after we have finished flag processing.</span>
<span class="line-added">2236   bool added = add_property(property, WriteableProperty, internal);</span>
2237   FreeHeap(property);
2238   return added;
2239 }
2240 
<a name="6" id="anc6"></a><span class="line-modified">2241 bool Arguments::create_numbered_module_property(const char* prop_base_name, const char* prop_value, unsigned int count) {</span>
<span class="line-added">2242   assert(is_internal_module_property(prop_base_name), &quot;unknown module property: &#39;%s&#39;&quot;, prop_base_name);</span>
2243   const unsigned int props_count_limit = 1000;
2244   const int max_digits = 3;
2245   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2246 
2247   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2248   if (count &lt; props_count_limit) {
2249     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2250     char* property = AllocateHeap(prop_len, mtArguments);
2251     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2252     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2253       FreeHeap(property);
2254       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2255       return false;
2256     }
2257     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2258     FreeHeap(property);
2259     return added;
2260   }
2261 
2262   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
2263   return false;
2264 }
2265 
2266 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2267                                                   julong* long_arg,
2268                                                   julong min_size,
2269                                                   julong max_size) {
2270   if (!atojulong(s, long_arg)) return arg_unreadable;
2271   return check_memory_size(*long_arg, min_size, max_size);
2272 }
2273 
2274 // Parse JavaVMInitArgs structure
2275 
2276 jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,
2277                                    const JavaVMInitArgs *java_tool_options_args,
2278                                    const JavaVMInitArgs *java_options_args,
2279                                    const JavaVMInitArgs *cmd_line_args) {
2280   bool patch_mod_javabase = false;
2281 
2282   // Save default settings for some mode flags
2283   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2284   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2285   Arguments::_ClipInlining             = ClipInlining;
2286   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2287   if (TieredCompilation) {
2288     Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
2289     Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
2290   }
2291 
2292   // CDS dumping always write the archive to the default value of SharedBaseAddress.
2293   Arguments::_SharedBaseAddress = SharedBaseAddress;
2294 
2295   // Setup flags for mixed which is the default
2296   set_mode_flags(_mixed);
2297 
2298   // Parse args structure generated from java.base vm options resource
2299   jint result = parse_each_vm_init_arg(vm_options_args, &amp;patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);
2300   if (result != JNI_OK) {
2301     return result;
2302   }
2303 
2304   // Parse args structure generated from JAVA_TOOL_OPTIONS environment
2305   // variable (if present).
2306   result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2307   if (result != JNI_OK) {
2308     return result;
2309   }
2310 
2311   // Parse args structure generated from the command line flags.
2312   result = parse_each_vm_init_arg(cmd_line_args, &amp;patch_mod_javabase, JVMFlag::COMMAND_LINE);
2313   if (result != JNI_OK) {
2314     return result;
2315   }
2316 
2317   // Parse args structure generated from the _JAVA_OPTIONS environment
2318   // variable (if present) (mimics classic VM)
2319   result = parse_each_vm_init_arg(java_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2320   if (result != JNI_OK) {
2321     return result;
2322   }
2323 
2324   // We need to ensure processor and memory resources have been properly
2325   // configured - which may rely on arguments we just processed - before
2326   // doing the final argument processing. Any argument processing that
2327   // needs to know about processor and memory resources must occur after
2328   // this point.
2329 
2330   os::init_container_support();
2331 
2332   // Do final processing now that all arguments have been parsed
2333   result = finalize_vm_init_args(patch_mod_javabase);
2334   if (result != JNI_OK) {
2335     return result;
2336   }
2337 
2338   return JNI_OK;
2339 }
2340 
2341 // Checks if name in command-line argument -agent{lib,path}:name[=options]
2342 // represents a valid JDWP agent.  is_path==true denotes that we
2343 // are dealing with -agentpath (case where name is a path), otherwise with
2344 // -agentlib
2345 bool valid_jdwp_agent(char *name, bool is_path) {
2346   char *_name;
2347   const char *_jdwp = &quot;jdwp&quot;;
2348   size_t _len_jdwp, _len_prefix;
2349 
2350   if (is_path) {
2351     if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {
2352       return false;
2353     }
2354 
2355     _name++;  // skip past last path separator
2356     _len_prefix = strlen(JNI_LIB_PREFIX);
2357 
2358     if (strncmp(_name, JNI_LIB_PREFIX, _len_prefix) != 0) {
2359       return false;
2360     }
2361 
2362     _name += _len_prefix;
2363     _len_jdwp = strlen(_jdwp);
2364 
2365     if (strncmp(_name, _jdwp, _len_jdwp) == 0) {
2366       _name += _len_jdwp;
2367     }
2368     else {
2369       return false;
2370     }
2371 
2372     if (strcmp(_name, JNI_LIB_SUFFIX) != 0) {
2373       return false;
2374     }
2375 
2376     return true;
2377   }
2378 
2379   if (strcmp(name, _jdwp) == 0) {
2380     return true;
2381   }
2382 
2383   return false;
2384 }
2385 
2386 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2387   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2388   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2389   // Find the equal sign between the module name and the path specification
2390   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2391   if (module_equal == NULL) {
2392     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2393     return JNI_ERR;
2394   } else {
2395     // Pick out the module name
2396     size_t module_len = module_equal - patch_mod_tail;
2397     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2398     if (module_name != NULL) {
2399       memcpy(module_name, patch_mod_tail, module_len);
2400       *(module_name + module_len) = &#39;\0&#39;;
2401       // The path piece begins one past the module_equal sign
2402       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2403       FREE_C_HEAP_ARRAY(char, module_name);
<a name="7" id="anc7"></a><span class="line-modified">2404       if (!create_numbered_module_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {</span>
2405         return JNI_ENOMEM;
2406       }
2407     } else {
2408       return JNI_ENOMEM;
2409     }
2410   }
2411   return JNI_OK;
2412 }
2413 
2414 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2415 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2416   // The min and max sizes match the values in globals.hpp, but scaled
2417   // with K. The values have been chosen so that alignment with page
2418   // size doesn&#39;t change the max value, which makes the conversions
2419   // back and forth between Xss value and ThreadStackSize value easier.
2420   // The values have also been chosen to fit inside a 32-bit signed type.
2421   const julong min_ThreadStackSize = 0;
2422   const julong max_ThreadStackSize = 1 * M;
2423 
2424   const julong min_size = min_ThreadStackSize * K;
2425   const julong max_size = max_ThreadStackSize * K;
2426 
2427   assert(is_aligned(max_size, os::vm_page_size()), &quot;Implementation assumption&quot;);
2428 
2429   julong size = 0;
2430   ArgsRange errcode = parse_memory_size(tail, &amp;size, min_size, max_size);
2431   if (errcode != arg_in_range) {
2432     bool silent = (option == NULL); // Allow testing to silence error messages
2433     if (!silent) {
2434       jio_fprintf(defaultStream::error_stream(),
2435                   &quot;Invalid thread stack size: %s\n&quot;, option-&gt;optionString);
2436       describe_range_error(errcode);
2437     }
2438     return JNI_EINVAL;
2439   }
2440 
2441   // Internally track ThreadStackSize in units of 1024 bytes.
2442   const julong size_aligned = align_up(size, K);
2443   assert(size &lt;= size_aligned,
2444          &quot;Overflow: &quot; JULONG_FORMAT &quot; &quot; JULONG_FORMAT,
2445          size, size_aligned);
2446 
2447   const julong size_in_K = size_aligned / K;
2448   assert(size_in_K &lt; (julong)max_intx,
2449          &quot;size_in_K doesn&#39;t fit in the type of ThreadStackSize: &quot; JULONG_FORMAT,
2450          size_in_K);
2451 
2452   // Check that code expanding ThreadStackSize to a page aligned number of bytes won&#39;t overflow.
2453   const julong max_expanded = align_up(size_in_K * K, os::vm_page_size());
2454   assert(max_expanded &lt; max_uintx &amp;&amp; max_expanded &gt;= size_in_K,
2455          &quot;Expansion overflowed: &quot; JULONG_FORMAT &quot; &quot; JULONG_FORMAT,
2456          max_expanded, size_in_K);
2457 
2458   *out_ThreadStackSize = (intx)size_in_K;
2459 
2460   return JNI_OK;
2461 }
2462 
2463 jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {
2464   // For match_option to return remaining or value part of option string
2465   const char* tail;
2466 
2467   // iterate over arguments
2468   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
2469     bool is_absolute_path = false;  // for -agentpath vs -agentlib
2470 
2471     const JavaVMOption* option = args-&gt;options + index;
2472 
2473     if (!match_option(option, &quot;-Djava.class.path&quot;, &amp;tail) &amp;&amp;
2474         !match_option(option, &quot;-Dsun.java.command&quot;, &amp;tail) &amp;&amp;
2475         !match_option(option, &quot;-Dsun.java.launcher&quot;, &amp;tail)) {
2476 
2477         // add all jvm options to the jvm_args string. This string
2478         // is used later to set the java.vm.args PerfData string constant.
2479         // the -Djava.class.path and the -Dsun.java.command options are
2480         // omitted from jvm_args string as each have their own PerfData
2481         // string constant object.
2482         build_jvm_args(option-&gt;optionString);
2483     }
2484 
2485     // -verbose:[class/module/gc/jni]
2486     if (match_option(option, &quot;-verbose&quot;, &amp;tail)) {
2487       if (!strcmp(tail, &quot;:class&quot;) || !strcmp(tail, &quot;&quot;)) {
2488         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, load));
2489         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, unload));
2490       } else if (!strcmp(tail, &quot;:module&quot;)) {
2491         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
2492         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
2493       } else if (!strcmp(tail, &quot;:gc&quot;)) {
2494         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
2495       } else if (!strcmp(tail, &quot;:jni&quot;)) {
2496         LogConfiguration::configure_stdout(LogLevel::Debug, true, LOG_TAGS(jni, resolve));
2497       }
2498     // -da / -ea / -disableassertions / -enableassertions
2499     // These accept an optional class/package name separated by a colon, e.g.,
2500     // -da:java.lang.Thread.
2501     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2502       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2503       if (*tail == &#39;\0&#39;) {
2504         JavaAssertions::setUserClassDefault(enable);
2505       } else {
2506         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2507         JavaAssertions::addOption(tail + 1, enable);
2508       }
2509     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2510     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2511       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2512       JavaAssertions::setSystemClassDefault(enable);
2513     // -bootclasspath:
2514     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2515         jio_fprintf(defaultStream::output_stream(),
2516           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
2517         return JNI_EINVAL;
2518     // -bootclasspath/a:
2519     } else if (match_option(option, &quot;-Xbootclasspath/a:&quot;, &amp;tail)) {
2520       Arguments::append_sysclasspath(tail);
2521     // -bootclasspath/p:
2522     } else if (match_option(option, &quot;-Xbootclasspath/p:&quot;, &amp;tail)) {
2523         jio_fprintf(defaultStream::output_stream(),
2524           &quot;-Xbootclasspath/p is no longer a supported option.\n&quot;);
2525         return JNI_EINVAL;
2526     // -Xrun
2527     } else if (match_option(option, &quot;-Xrun&quot;, &amp;tail)) {
2528       if (tail != NULL) {
2529         const char* pos = strchr(tail, &#39;:&#39;);
2530         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2531         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2532         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2533 
2534         char *options = NULL;
2535         if(pos != NULL) {
2536           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2537           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2538         }
2539 #if !INCLUDE_JVMTI
2540         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2541           jio_fprintf(defaultStream::error_stream(),
2542             &quot;Debugging agents are not supported in this VM\n&quot;);
2543           return JNI_ERR;
2544         }
2545 #endif // !INCLUDE_JVMTI
2546         add_init_library(name, options);
2547       }
2548     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
<a name="8" id="anc8"></a><span class="line-modified">2549       if (!create_numbered_module_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {</span>
2550         return JNI_ENOMEM;
2551       }
2552     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
<a name="9" id="anc9"></a><span class="line-modified">2553       if (!create_numbered_module_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {</span>
2554         return JNI_ENOMEM;
2555       }
2556     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
<a name="10" id="anc10"></a><span class="line-modified">2557       if (!create_numbered_module_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {</span>
2558         return JNI_ENOMEM;
2559       }
2560     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
<a name="11" id="anc11"></a><span class="line-modified">2561       if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {</span>
2562         return JNI_ENOMEM;
2563       }
2564     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
<a name="12" id="anc12"></a><span class="line-modified">2565       if (!create_module_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {</span>
2566         return JNI_ENOMEM;
2567       }
2568     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
<a name="13" id="anc13"></a><span class="line-modified">2569       if (!create_module_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {</span>
2570         return JNI_ENOMEM;
2571       }
2572     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
<a name="14" id="anc14"></a><span class="line-modified">2573       if (!create_module_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {</span>
2574         return JNI_ENOMEM;
2575       }
2576     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2577       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2578       int res = process_patch_mod_option(tail, patch_mod_javabase);
2579       if (res != JNI_OK) {
2580         return res;
2581       }
2582     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
<a name="15" id="anc15"></a><span class="line-modified">2583       if (!create_module_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {</span>
2584         return JNI_ENOMEM;
2585       }
2586     // -agentlib and -agentpath
2587     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2588           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2589       if(tail != NULL) {
2590         const char* pos = strchr(tail, &#39;=&#39;);
2591         char* name;
2592         if (pos == NULL) {
2593           name = os::strdup_check_oom(tail, mtArguments);
2594         } else {
2595           size_t len = pos - tail;
2596           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2597           memcpy(name, tail, len);
2598           name[len] = &#39;\0&#39;;
2599         }
2600 
2601         char *options = NULL;
2602         if(pos != NULL) {
2603           options = os::strdup_check_oom(pos + 1, mtArguments);
2604         }
2605 #if !INCLUDE_JVMTI
2606         if (valid_jdwp_agent(name, is_absolute_path)) {
2607           jio_fprintf(defaultStream::error_stream(),
2608             &quot;Debugging agents are not supported in this VM\n&quot;);
2609           return JNI_ERR;
2610         }
2611 #endif // !INCLUDE_JVMTI
2612         add_init_agent(name, options, is_absolute_path);
2613       }
2614     // -javaagent
2615     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2616 #if !INCLUDE_JVMTI
2617       jio_fprintf(defaultStream::error_stream(),
2618         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2619       return JNI_ERR;
2620 #else
2621       if (tail != NULL) {
2622         size_t length = strlen(tail) + 1;
2623         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2624         jio_snprintf(options, length, &quot;%s&quot;, tail);
2625         add_instrument_agent(&quot;instrument&quot;, options, false);
2626         // java agents need module java.instrument
<a name="16" id="anc16"></a><span class="line-modified">2627         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {</span>
2628           return JNI_ENOMEM;
2629         }
2630       }
2631 #endif // !INCLUDE_JVMTI
2632     // --enable_preview
2633     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2634       set_enable_preview();
2635     // -Xnoclassgc
2636     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2637       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2638         return JNI_EINVAL;
2639       }
2640     // -Xbatch
2641     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2642       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2643         return JNI_EINVAL;
2644       }
2645     // -Xmn for compatibility with other JVM vendors
2646     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2647       julong long_initial_young_size = 0;
2648       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2649       if (errcode != arg_in_range) {
2650         jio_fprintf(defaultStream::error_stream(),
2651                     &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
2652         describe_range_error(errcode);
2653         return JNI_EINVAL;
2654       }
2655       if (FLAG_SET_CMDLINE(MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
2656         return JNI_EINVAL;
2657       }
2658       if (FLAG_SET_CMDLINE(NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
2659         return JNI_EINVAL;
2660       }
2661     // -Xms
2662     } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
2663       julong size = 0;
2664       // an initial heap size of 0 means automatically determine
2665       ArgsRange errcode = parse_memory_size(tail, &amp;size, 0);
2666       if (errcode != arg_in_range) {
2667         jio_fprintf(defaultStream::error_stream(),
2668                     &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
2669         describe_range_error(errcode);
2670         return JNI_EINVAL;
2671       }
2672       if (FLAG_SET_CMDLINE(MinHeapSize, (size_t)size) != JVMFlag::SUCCESS) {
2673         return JNI_EINVAL;
2674       }
2675       if (FLAG_SET_CMDLINE(InitialHeapSize, (size_t)size) != JVMFlag::SUCCESS) {
2676         return JNI_EINVAL;
2677       }
2678     // -Xmx
2679     } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
2680       julong long_max_heap_size = 0;
2681       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2682       if (errcode != arg_in_range) {
2683         jio_fprintf(defaultStream::error_stream(),
2684                     &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
2685         describe_range_error(errcode);
2686         return JNI_EINVAL;
2687       }
2688       if (FLAG_SET_CMDLINE(MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {
2689         return JNI_EINVAL;
2690       }
2691     // Xmaxf
2692     } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
2693       char* err;
2694       int maxf = (int)(strtod(tail, &amp;err) * 100);
2695       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2696         jio_fprintf(defaultStream::error_stream(),
2697                     &quot;Bad max heap free percentage size: %s\n&quot;,
2698                     option-&gt;optionString);
2699         return JNI_EINVAL;
2700       } else {
2701         if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {
2702             return JNI_EINVAL;
2703         }
2704       }
2705     // Xminf
2706     } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
2707       char* err;
2708       int minf = (int)(strtod(tail, &amp;err) * 100);
2709       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2710         jio_fprintf(defaultStream::error_stream(),
2711                     &quot;Bad min heap free percentage size: %s\n&quot;,
2712                     option-&gt;optionString);
2713         return JNI_EINVAL;
2714       } else {
2715         if (FLAG_SET_CMDLINE(MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {
2716           return JNI_EINVAL;
2717         }
2718       }
2719     // -Xss
2720     } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
2721       intx value = 0;
2722       jint err = parse_xss(option, tail, &amp;value);
2723       if (err != JNI_OK) {
2724         return err;
2725       }
2726       if (FLAG_SET_CMDLINE(ThreadStackSize, value) != JVMFlag::SUCCESS) {
2727         return JNI_EINVAL;
2728       }
2729     } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
2730                match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
2731       julong long_ReservedCodeCacheSize = 0;
2732 
2733       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2734       if (errcode != arg_in_range) {
2735         jio_fprintf(defaultStream::error_stream(),
2736                     &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
2737         return JNI_EINVAL;
2738       }
2739       if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {
2740         return JNI_EINVAL;
2741       }
2742     // -green
2743     } else if (match_option(option, &quot;-green&quot;)) {
2744       jio_fprintf(defaultStream::error_stream(),
2745                   &quot;Green threads support not available\n&quot;);
2746           return JNI_EINVAL;
2747     // -native
2748     } else if (match_option(option, &quot;-native&quot;)) {
2749           // HotSpot always uses native threads, ignore silently for compatibility
2750     // -Xrs
2751     } else if (match_option(option, &quot;-Xrs&quot;)) {
2752           // Classic/EVM option, new functionality
2753       if (FLAG_SET_CMDLINE(ReduceSignalUsage, true) != JVMFlag::SUCCESS) {
2754         return JNI_EINVAL;
2755       }
2756       // -Xprof
2757     } else if (match_option(option, &quot;-Xprof&quot;)) {
2758       char version[256];
2759       // Obsolete in JDK 10
2760       JDK_Version::jdk(10).to_string(version, sizeof(version));
2761       warning(&quot;Ignoring option %s; support was removed in %s&quot;, option-&gt;optionString, version);
2762     // -Xinternalversion
2763     } else if (match_option(option, &quot;-Xinternalversion&quot;)) {
2764       jio_fprintf(defaultStream::output_stream(), &quot;%s\n&quot;,
2765                   VM_Version::internal_vm_info_string());
2766       vm_exit(0);
2767 #ifndef PRODUCT
2768     // -Xprintflags
2769     } else if (match_option(option, &quot;-Xprintflags&quot;)) {
2770       JVMFlag::printFlags(tty, false);
2771       vm_exit(0);
2772 #endif
2773     // -D
2774     } else if (match_option(option, &quot;-D&quot;, &amp;tail)) {
2775       const char* value;
2776       if (match_option(option, &quot;-Djava.endorsed.dirs=&quot;, &amp;value) &amp;&amp;
2777             *value!= &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2778         // abort if -Djava.endorsed.dirs is set
2779         jio_fprintf(defaultStream::output_stream(),
2780           &quot;-Djava.endorsed.dirs=%s is not supported. Endorsed standards and standalone APIs\n&quot;
2781           &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;, value);
2782         return JNI_EINVAL;
2783       }
2784       if (match_option(option, &quot;-Djava.ext.dirs=&quot;, &amp;value) &amp;&amp;
2785             *value != &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2786         // abort if -Djava.ext.dirs is set
2787         jio_fprintf(defaultStream::output_stream(),
2788           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2789         return JNI_EINVAL;
2790       }
2791       // Check for module related properties.  They must be set using the modules
2792       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2793       // &quot;-Djdk.module.addmods=java.sql&quot;
2794       if (is_internal_module_property(option-&gt;optionString + 2)) {
2795         needs_module_property_warning = true;
2796         continue;
2797       }
2798       if (!add_property(tail)) {
2799         return JNI_ENOMEM;
2800       }
2801       // Out of the box management support
2802       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2803 #if INCLUDE_MANAGEMENT
2804         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2805           return JNI_EINVAL;
2806         }
2807         // management agent in module jdk.management.agent
<a name="17" id="anc17"></a><span class="line-modified">2808         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {</span>
2809           return JNI_ENOMEM;
2810         }
2811 #else
2812         jio_fprintf(defaultStream::output_stream(),
2813           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2814         return JNI_ERR;
2815 #endif
2816       }
2817     // -Xint
2818     } else if (match_option(option, &quot;-Xint&quot;)) {
2819           set_mode_flags(_int);
2820     // -Xmixed
2821     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2822           set_mode_flags(_mixed);
2823     // -Xcomp
2824     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2825       // for testing the compiler; turn off all flags that inhibit compilation
2826           set_mode_flags(_comp);
2827     // -Xshare:dump
2828     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
2829       if (FLAG_SET_CMDLINE(DumpSharedSpaces, true) != JVMFlag::SUCCESS) {
2830         return JNI_EINVAL;
2831       }
2832     // -Xshare:on
2833     } else if (match_option(option, &quot;-Xshare:on&quot;)) {
2834       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
2835         return JNI_EINVAL;
2836       }
2837       if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
2838         return JNI_EINVAL;
2839       }
2840     // -Xshare:auto || -XX:ArchiveClassesAtExit=&lt;archive file&gt;
2841     } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
2842       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
2843         return JNI_EINVAL;
2844       }
2845       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
2846         return JNI_EINVAL;
2847       }
2848     // -Xshare:off
2849     } else if (match_option(option, &quot;-Xshare:off&quot;)) {
2850       if (FLAG_SET_CMDLINE(UseSharedSpaces, false) != JVMFlag::SUCCESS) {
2851         return JNI_EINVAL;
2852       }
2853       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
2854         return JNI_EINVAL;
2855       }
2856     // -Xverify
2857     } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
2858       if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
2859         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {
2860           return JNI_EINVAL;
2861         }
2862         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
2863           return JNI_EINVAL;
2864         }
2865       } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
2866         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
2867           return JNI_EINVAL;
2868         }
2869         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
2870           return JNI_EINVAL;
2871         }
2872       } else if (strcmp(tail, &quot;:none&quot;) == 0) {
2873         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
2874           return JNI_EINVAL;
2875         }
2876         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {
2877           return JNI_EINVAL;
2878         }
2879         warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
2880       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
2881         return JNI_EINVAL;
2882       }
2883     // -Xdebug
2884     } else if (match_option(option, &quot;-Xdebug&quot;)) {
2885       // note this flag has been used, then ignore
2886       set_xdebug_mode(true);
2887     // -Xnoagent
2888     } else if (match_option(option, &quot;-Xnoagent&quot;)) {
2889       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2890     } else if (match_option(option, &quot;-Xloggc:&quot;, &amp;tail)) {
2891       // Deprecated flag to redirect GC output to a file. -Xloggc:&lt;filename&gt;
2892       log_warning(gc)(&quot;-Xloggc is deprecated. Will use -Xlog:gc:%s instead.&quot;, tail);
2893       _gc_log_filename = os::strdup_check_oom(tail);
2894     } else if (match_option(option, &quot;-Xlog&quot;, &amp;tail)) {
2895       bool ret = false;
2896       if (strcmp(tail, &quot;:help&quot;) == 0) {
2897         fileStream stream(defaultStream::output_stream());
2898         LogConfiguration::print_command_line_help(&amp;stream);
2899         vm_exit(0);
2900       } else if (strcmp(tail, &quot;:disable&quot;) == 0) {
2901         LogConfiguration::disable_logging();
2902         ret = true;
2903       } else if (*tail == &#39;\0&#39;) {
2904         ret = LogConfiguration::parse_command_line_arguments();
2905         assert(ret, &quot;-Xlog without arguments should never fail to parse&quot;);
2906       } else if (*tail == &#39;:&#39;) {
2907         ret = LogConfiguration::parse_command_line_arguments(tail + 1);
2908       }
2909       if (ret == false) {
2910         jio_fprintf(defaultStream::error_stream(),
2911                     &quot;Invalid -Xlog option &#39;-Xlog%s&#39;, see error log for details.\n&quot;,
2912                     tail);
2913         return JNI_EINVAL;
2914       }
2915     // JNI hooks
2916     } else if (match_option(option, &quot;-Xcheck&quot;, &amp;tail)) {
2917       if (!strcmp(tail, &quot;:jni&quot;)) {
2918 #if !INCLUDE_JNI_CHECK
2919         warning(&quot;JNI CHECKING is not supported in this VM&quot;);
2920 #else
2921         CheckJNICalls = true;
2922 #endif // INCLUDE_JNI_CHECK
2923       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2924                                      &quot;check&quot;)) {
2925         return JNI_EINVAL;
2926       }
2927     } else if (match_option(option, &quot;vfprintf&quot;)) {
2928       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2929     } else if (match_option(option, &quot;exit&quot;)) {
2930       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2931     } else if (match_option(option, &quot;abort&quot;)) {
2932       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2933     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
2934     // and the last option wins.
2935     } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
2936       if (FLAG_SET_CMDLINE(NeverTenure, true) != JVMFlag::SUCCESS) {
2937         return JNI_EINVAL;
2938       }
2939       if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {
2940         return JNI_EINVAL;
2941       }
2942       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {
2943         return JNI_EINVAL;
2944       }
2945     } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
2946       if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2947         return JNI_EINVAL;
2948       }
2949       if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {
2950         return JNI_EINVAL;
2951       }
2952       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {
2953         return JNI_EINVAL;
2954       }
2955     } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
2956       uintx max_tenuring_thresh = 0;
2957       if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
2958         jio_fprintf(defaultStream::error_stream(),
2959                     &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
2960         return JNI_EINVAL;
2961       }
2962 
2963       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {
2964         return JNI_EINVAL;
2965       }
2966 
2967       if (MaxTenuringThreshold == 0) {
2968         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2969           return JNI_EINVAL;
2970         }
2971         if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {
2972           return JNI_EINVAL;
2973         }
2974       } else {
2975         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2976           return JNI_EINVAL;
2977         }
2978         if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {
2979           return JNI_EINVAL;
2980         }
2981       }
2982     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
2983       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {
2984         return JNI_EINVAL;
2985       }
2986       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {
2987         return JNI_EINVAL;
2988       }
2989     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
2990       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {
2991         return JNI_EINVAL;
2992       }
2993       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {
2994         return JNI_EINVAL;
2995       }
2996     } else if (match_option(option, &quot;-XX:+ErrorFileToStderr&quot;)) {
2997       if (FLAG_SET_CMDLINE(ErrorFileToStdout, false) != JVMFlag::SUCCESS) {
2998         return JNI_EINVAL;
2999       }
3000       if (FLAG_SET_CMDLINE(ErrorFileToStderr, true) != JVMFlag::SUCCESS) {
3001         return JNI_EINVAL;
3002       }
3003     } else if (match_option(option, &quot;-XX:+ErrorFileToStdout&quot;)) {
3004       if (FLAG_SET_CMDLINE(ErrorFileToStderr, false) != JVMFlag::SUCCESS) {
3005         return JNI_EINVAL;
3006       }
3007       if (FLAG_SET_CMDLINE(ErrorFileToStdout, true) != JVMFlag::SUCCESS) {
3008         return JNI_EINVAL;
3009       }
3010     } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
3011 #if defined(DTRACE_ENABLED)
3012       if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {
3013         return JNI_EINVAL;
3014       }
3015       if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {
3016         return JNI_EINVAL;
3017       }
3018       if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {
3019         return JNI_EINVAL;
3020       }
3021       if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {
3022         return JNI_EINVAL;
3023       }
3024 #else // defined(DTRACE_ENABLED)
3025       jio_fprintf(defaultStream::error_stream(),
3026                   &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
3027       return JNI_EINVAL;
3028 #endif // defined(DTRACE_ENABLED)
3029 #ifdef ASSERT
3030     } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
3031       if (FLAG_SET_CMDLINE(FullGCALot, true) != JVMFlag::SUCCESS) {
3032         return JNI_EINVAL;
3033       }
3034       // disable scavenge before parallel mark-compact
3035       if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {
3036         return JNI_EINVAL;
3037       }
3038 #endif
3039 #if !INCLUDE_MANAGEMENT
3040     } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
3041         jio_fprintf(defaultStream::error_stream(),
3042           &quot;ManagementServer is not supported in this VM.\n&quot;);
3043         return JNI_ERR;
3044 #endif // INCLUDE_MANAGEMENT
3045 #if INCLUDE_JVMCI
3046     } else if (match_option(option, &quot;-XX:-EnableJVMCIProduct&quot;)) {
3047       if (EnableJVMCIProduct) {
3048         jio_fprintf(defaultStream::error_stream(),
3049                   &quot;-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\n&quot;);
3050         return JNI_EINVAL;
3051       }
3052     } else if (match_option(option, &quot;-XX:+EnableJVMCIProduct&quot;)) {
3053       JVMFlag *jvmciFlag = JVMFlag::find_flag(&quot;EnableJVMCIProduct&quot;);
3054       // Allow this flag if it has been unlocked.
3055       if (jvmciFlag != NULL &amp;&amp; jvmciFlag-&gt;is_unlocked()) {
3056         if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {
3057           jio_fprintf(defaultStream::error_stream(),
3058             &quot;Unable to enable JVMCI in product mode&quot;);
3059           return JNI_ERR;
3060         }
3061       }
3062       // The flag was locked so process normally to report that error
3063       else if (!process_argument(&quot;EnableJVMCIProduct&quot;, args-&gt;ignoreUnrecognized, origin)) {
3064         return JNI_EINVAL;
3065       }
3066 #endif // INCLUDE_JVMCI
3067 #if INCLUDE_JFR
3068     } else if (match_jfr_option(&amp;option)) {
3069       return JNI_EINVAL;
3070 #endif
3071     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
3072       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
3073       // already been handled
3074       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
3075           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
3076         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3077           return JNI_EINVAL;
3078         }
3079       }
3080     // Unknown option
3081     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3082       return JNI_ERR;
3083     }
3084   }
3085 
3086   if (EnableValhalla) {
<a name="18" id="anc18"></a><span class="line-modified">3087     // create_property(&quot;valhalla.enableValhalla&quot;, &quot;true&quot;, InternalProperty)</span>
<span class="line-added">3088     const char* prop_name = &quot;valhalla.enableValhalla&quot;;</span>
<span class="line-added">3089     const char* prop_value = &quot;true&quot;;</span>
<span class="line-added">3090     const size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;</span>
<span class="line-added">3091     char* property = AllocateHeap(prop_len, mtArguments);</span>
<span class="line-added">3092     int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);</span>
<span class="line-added">3093     if (ret &lt; 0 || ret &gt;= (int)prop_len) {</span>
<span class="line-added">3094       FreeHeap(property);</span>
<span class="line-added">3095       return JNI_ENOMEM;</span>
<span class="line-added">3096     }</span>
<span class="line-added">3097     bool added = add_property(property, UnwriteableProperty, InternalProperty);</span>
<span class="line-added">3098     FreeHeap(property);</span>
<span class="line-added">3099     if (!added) {</span>
3100       return JNI_ENOMEM;
3101     }
3102   }
3103 
3104   // PrintSharedArchiveAndExit will turn on
3105   //   -Xshare:on
3106   //   -Xlog:class+path=info
3107   if (PrintSharedArchiveAndExit) {
3108     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
3109       return JNI_EINVAL;
3110     }
3111     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
3112       return JNI_EINVAL;
3113     }
3114     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
3115   }
3116 
3117   fix_appclasspath();
3118 
3119   return JNI_OK;
3120 }
3121 
3122 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
3123   // For java.base check for duplicate --patch-module options being specified on the command line.
3124   // This check is only required for java.base, all other duplicate module specifications
3125   // will be checked during module system initialization.  The module system initialization
3126   // will throw an ExceptionInInitializerError if this situation occurs.
3127   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
3128     if (*patch_mod_javabase) {
3129       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
3130     } else {
3131       *patch_mod_javabase = true;
3132     }
3133   }
3134 
3135   // Create GrowableArray lazily, only if --patch-module has been specified
3136   if (_patch_mod_prefix == NULL) {
3137     _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;ModulePatchPath*&gt;(10, true);
3138   }
3139 
3140   _patch_mod_prefix-&gt;push(new ModulePatchPath(module_name, path));
3141 }
3142 
3143 // Remove all empty paths from the app classpath (if IgnoreEmptyClassPaths is enabled)
3144 //
3145 // This is necessary because some apps like to specify classpath like -cp foo.jar:${XYZ}:bar.jar
3146 // in their start-up scripts. If XYZ is empty, the classpath will look like &quot;-cp foo.jar::bar.jar&quot;.
3147 // Java treats such empty paths as if the user specified &quot;-cp foo.jar:.:bar.jar&quot;. I.e., an empty
3148 // path is treated as the current directory.
3149 //
3150 // This causes problems with CDS, which requires that all directories specified in the classpath
3151 // must be empty. In most cases, applications do NOT want to load classes from the current
3152 // directory anyway. Adding -XX:+IgnoreEmptyClassPaths will make these applications&#39; start-up
3153 // scripts compatible with CDS.
3154 void Arguments::fix_appclasspath() {
3155   if (IgnoreEmptyClassPaths) {
3156     const char separator = *os::path_separator();
3157     const char* src = _java_class_path-&gt;value();
3158 
3159     // skip over all the leading empty paths
3160     while (*src == separator) {
3161       src ++;
3162     }
3163 
3164     char* copy = os::strdup_check_oom(src, mtArguments);
3165 
3166     // trim all trailing empty paths
3167     for (char* tail = copy + strlen(copy) - 1; tail &gt;= copy &amp;&amp; *tail == separator; tail--) {
3168       *tail = &#39;\0&#39;;
3169     }
3170 
3171     char from[3] = {separator, separator, &#39;\0&#39;};
3172     char to  [2] = {separator, &#39;\0&#39;};
3173     while (StringUtils::replace_no_expand(copy, from, to) &gt; 0) {
3174       // Keep replacing &quot;::&quot; -&gt; &quot;:&quot; until we have no more &quot;::&quot; (non-windows)
3175       // Keep replacing &quot;;;&quot; -&gt; &quot;;&quot; until we have no more &quot;;;&quot; (windows)
3176     }
3177 
3178     _java_class_path-&gt;set_writeable_value(copy);
3179     FreeHeap(copy); // a copy was made by set_value, so don&#39;t need this anymore
3180   }
3181 }
3182 
3183 jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {
3184   // check if the default lib/endorsed directory exists; if so, error
3185   char path[JVM_MAXPATHLEN];
3186   const char* fileSep = os::file_separator();
3187   jio_snprintf(path, JVM_MAXPATHLEN, &quot;%s%slib%sendorsed&quot;, Arguments::get_java_home(), fileSep, fileSep);
3188 
3189   DIR* dir = os::opendir(path);
3190   if (dir != NULL) {
3191     jio_fprintf(defaultStream::output_stream(),
3192       &quot;&lt;JAVA_HOME&gt;/lib/endorsed is not supported. Endorsed standards and standalone APIs\n&quot;
3193       &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;);
3194     os::closedir(dir);
3195     return JNI_ERR;
3196   }
3197 
3198   jio_snprintf(path, JVM_MAXPATHLEN, &quot;%s%slib%sext&quot;, Arguments::get_java_home(), fileSep, fileSep);
3199   dir = os::opendir(path);
3200   if (dir != NULL) {
3201     jio_fprintf(defaultStream::output_stream(),
3202       &quot;&lt;JAVA_HOME&gt;/lib/ext exists, extensions mechanism no longer supported; &quot;
3203       &quot;Use -classpath instead.\n.&quot;);
3204     os::closedir(dir);
3205     return JNI_ERR;
3206   }
3207 
3208   // This must be done after all arguments have been processed
3209   // and the container support has been initialized since AggressiveHeap
3210   // relies on the amount of total memory available.
3211   if (AggressiveHeap) {
3212     jint result = set_aggressive_heap_flags();
3213     if (result != JNI_OK) {
3214       return result;
3215     }
3216   }
3217 
3218   // This must be done after all arguments have been processed.
3219   // java_compiler() true means set to &quot;NONE&quot; or empty.
3220   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3221     // For backwards compatibility, we switch to interpreted mode if
3222     // -Djava.compiler=&quot;NONE&quot; or &quot;&quot; is specified AND &quot;-Xdebug&quot; was
3223     // not specified.
3224     set_mode_flags(_int);
3225   }
3226 
3227   // CompileThresholdScaling == 0.0 is same as -Xint: Disable compilation (enable interpreter-only mode),
3228   // but like -Xint, leave compilation thresholds unaffected.
3229   // With tiered compilation disabled, setting CompileThreshold to 0 disables compilation as well.
3230   if ((CompileThresholdScaling == 0.0) || (!TieredCompilation &amp;&amp; CompileThreshold == 0)) {
3231     set_mode_flags(_int);
3232   }
3233 
3234   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3235   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
3236     FLAG_SET_ERGO(InitialTenuringThreshold, MaxTenuringThreshold);
3237   }
3238 
3239 #if !COMPILER2_OR_JVMCI
3240   // Don&#39;t degrade server performance for footprint
3241   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3242       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3243     // No need for large granularity pages w/small heaps.
3244     // Note that large pages are enabled/disabled for both the
3245     // Java heap and the code cache.
3246     FLAG_SET_DEFAULT(UseLargePages, false);
3247   }
3248 
3249   UNSUPPORTED_OPTION(ProfileInterpreter);
3250   NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
3251 #endif
3252 
3253 
3254 #ifdef TIERED
3255   // Parse the CompilationMode flag
3256   if (!CompilationModeFlag::initialize()) {
3257     return JNI_ERR;
3258   }
3259 #else
3260   // Tiered compilation is undefined.
3261   UNSUPPORTED_OPTION(TieredCompilation);
3262 #endif
3263 
3264   if (!check_vm_args_consistency()) {
3265     return JNI_ERR;
3266   }
3267 
3268 #if INCLUDE_CDS
3269   if (DumpSharedSpaces) {
3270     // Disable biased locking now as it interferes with the clean up of
3271     // the archived Klasses and Java string objects (at dump time only).
3272     UseBiasedLocking = false;
3273 
3274     // Compiler threads may concurrently update the class metadata (such as method entries), so it&#39;s
3275     // unsafe with DumpSharedSpaces (which modifies the class metadata in place). Let&#39;s disable
3276     // compiler just to be safe.
3277     //
3278     // Note: this is not a concern for DynamicDumpSharedSpaces, which makes a copy of the class metadata
3279     // instead of modifying them in place. The copy is inaccessible to the compiler.
3280     // TODO: revisit the following for the static archive case.
3281     set_mode_flags(_int);
3282   }
3283   if (DumpSharedSpaces || ArchiveClassesAtExit != NULL) {
3284     // Always verify non-system classes during CDS dump
3285     if (!BytecodeVerificationRemote) {
3286       BytecodeVerificationRemote = true;
3287       log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
3288     }
3289   }
3290   if (ArchiveClassesAtExit == NULL) {
3291     FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, false);
3292   }
3293   if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
3294     no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
3295   }
3296   if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
3297     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3298   }
3299 #endif
3300 
3301 #ifndef CAN_SHOW_REGISTERS_ON_ASSERT
3302   UNSUPPORTED_OPTION(ShowRegistersOnAssert);
3303 #endif // CAN_SHOW_REGISTERS_ON_ASSERT
3304 
3305   return JNI_OK;
3306 }
3307 
3308 // Helper class for controlling the lifetime of JavaVMInitArgs
3309 // objects.  The contents of the JavaVMInitArgs are guaranteed to be
3310 // deleted on the destruction of the ScopedVMInitArgs object.
3311 class ScopedVMInitArgs : public StackObj {
3312  private:
3313   JavaVMInitArgs _args;
3314   char*          _container_name;
3315   bool           _is_set;
3316   char*          _vm_options_file_arg;
3317 
3318  public:
3319   ScopedVMInitArgs(const char *container_name) {
3320     _args.version = JNI_VERSION_1_2;
3321     _args.nOptions = 0;
3322     _args.options = NULL;
3323     _args.ignoreUnrecognized = false;
3324     _container_name = (char *)container_name;
3325     _is_set = false;
3326     _vm_options_file_arg = NULL;
3327   }
3328 
3329   // Populates the JavaVMInitArgs object represented by this
3330   // ScopedVMInitArgs object with the arguments in options.  The
3331   // allocated memory is deleted by the destructor.  If this method
3332   // returns anything other than JNI_OK, then this object is in a
3333   // partially constructed state, and should be abandoned.
3334   jint set_args(GrowableArray&lt;JavaVMOption&gt;* options) {
3335     _is_set = true;
3336     JavaVMOption* options_arr = NEW_C_HEAP_ARRAY_RETURN_NULL(
3337         JavaVMOption, options-&gt;length(), mtArguments);
3338     if (options_arr == NULL) {
3339       return JNI_ENOMEM;
3340     }
3341     _args.options = options_arr;
3342 
3343     for (int i = 0; i &lt; options-&gt;length(); i++) {
3344       options_arr[i] = options-&gt;at(i);
3345       options_arr[i].optionString = os::strdup(options_arr[i].optionString);
3346       if (options_arr[i].optionString == NULL) {
3347         // Rely on the destructor to do cleanup.
3348         _args.nOptions = i;
3349         return JNI_ENOMEM;
3350       }
3351     }
3352 
3353     _args.nOptions = options-&gt;length();
3354     _args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;
3355     return JNI_OK;
3356   }
3357 
3358   JavaVMInitArgs* get()             { return &amp;_args; }
3359   char* container_name()            { return _container_name; }
3360   bool  is_set()                    { return _is_set; }
3361   bool  found_vm_options_file_arg() { return _vm_options_file_arg != NULL; }
3362   char* vm_options_file_arg()       { return _vm_options_file_arg; }
3363 
3364   void set_vm_options_file_arg(const char *vm_options_file_arg) {
3365     if (_vm_options_file_arg != NULL) {
3366       os::free(_vm_options_file_arg);
3367     }
3368     _vm_options_file_arg = os::strdup_check_oom(vm_options_file_arg);
3369   }
3370 
3371   ~ScopedVMInitArgs() {
3372     if (_vm_options_file_arg != NULL) {
3373       os::free(_vm_options_file_arg);
3374     }
3375     if (_args.options == NULL) return;
3376     for (int i = 0; i &lt; _args.nOptions; i++) {
3377       os::free(_args.options[i].optionString);
3378     }
3379     FREE_C_HEAP_ARRAY(JavaVMOption, _args.options);
3380   }
3381 
3382   // Insert options into this option list, to replace option at
3383   // vm_options_file_pos (-XX:VMOptionsFile)
3384   jint insert(const JavaVMInitArgs* args,
3385               const JavaVMInitArgs* args_to_insert,
3386               const int vm_options_file_pos) {
3387     assert(_args.options == NULL, &quot;shouldn&#39;t be set yet&quot;);
3388     assert(args_to_insert-&gt;nOptions != 0, &quot;there should be args to insert&quot;);
3389     assert(vm_options_file_pos != -1, &quot;vm_options_file_pos should be set&quot;);
3390 
3391     int length = args-&gt;nOptions + args_to_insert-&gt;nOptions - 1;
3392     GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments)
3393               GrowableArray&lt;JavaVMOption&gt;(length, true);    // Construct new option array
3394     for (int i = 0; i &lt; args-&gt;nOptions; i++) {
3395       if (i == vm_options_file_pos) {
3396         // insert the new options starting at the same place as the
3397         // -XX:VMOptionsFile option
3398         for (int j = 0; j &lt; args_to_insert-&gt;nOptions; j++) {
3399           options-&gt;push(args_to_insert-&gt;options[j]);
3400         }
3401       } else {
3402         options-&gt;push(args-&gt;options[i]);
3403       }
3404     }
3405     // make into options array
3406     jint result = set_args(options);
3407     delete options;
3408     return result;
3409   }
3410 };
3411 
3412 jint Arguments::parse_java_options_environment_variable(ScopedVMInitArgs* args) {
3413   return parse_options_environment_variable(&quot;_JAVA_OPTIONS&quot;, args);
3414 }
3415 
3416 jint Arguments::parse_java_tool_options_environment_variable(ScopedVMInitArgs* args) {
3417   return parse_options_environment_variable(&quot;JAVA_TOOL_OPTIONS&quot;, args);
3418 }
3419 
3420 jint Arguments::parse_options_environment_variable(const char* name,
3421                                                    ScopedVMInitArgs* vm_args) {
3422   char *buffer = ::getenv(name);
3423 
3424   // Don&#39;t check this environment variable if user has special privileges
3425   // (e.g. unix su command).
3426   if (buffer == NULL || os::have_special_privileges()) {
3427     return JNI_OK;
3428   }
3429 
3430   if ((buffer = os::strdup(buffer)) == NULL) {
3431     return JNI_ENOMEM;
3432   }
3433 
3434   jio_fprintf(defaultStream::error_stream(),
3435               &quot;Picked up %s: %s\n&quot;, name, buffer);
3436 
3437   int retcode = parse_options_buffer(name, buffer, strlen(buffer), vm_args);
3438 
3439   os::free(buffer);
3440   return retcode;
3441 }
3442 
3443 jint Arguments::parse_vm_options_file(const char* file_name, ScopedVMInitArgs* vm_args) {
3444   // read file into buffer
3445   int fd = ::open(file_name, O_RDONLY);
3446   if (fd &lt; 0) {
3447     jio_fprintf(defaultStream::error_stream(),
3448                 &quot;Could not open options file &#39;%s&#39;\n&quot;,
3449                 file_name);
3450     return JNI_ERR;
3451   }
3452 
3453   struct stat stbuf;
3454   int retcode = os::stat(file_name, &amp;stbuf);
3455   if (retcode != 0) {
3456     jio_fprintf(defaultStream::error_stream(),
3457                 &quot;Could not stat options file &#39;%s&#39;\n&quot;,
3458                 file_name);
3459     os::close(fd);
3460     return JNI_ERR;
3461   }
3462 
3463   if (stbuf.st_size == 0) {
3464     // tell caller there is no option data and that is ok
3465     os::close(fd);
3466     return JNI_OK;
3467   }
3468 
3469   // &#39;+ 1&#39; for NULL termination even with max bytes
3470   size_t bytes_alloc = stbuf.st_size + 1;
3471 
3472   char *buf = NEW_C_HEAP_ARRAY_RETURN_NULL(char, bytes_alloc, mtArguments);
3473   if (NULL == buf) {
3474     jio_fprintf(defaultStream::error_stream(),
3475                 &quot;Could not allocate read buffer for options file parse\n&quot;);
3476     os::close(fd);
3477     return JNI_ENOMEM;
3478   }
3479 
3480   memset(buf, 0, bytes_alloc);
3481 
3482   // Fill buffer
3483   ssize_t bytes_read = os::read(fd, (void *)buf, (unsigned)bytes_alloc);
3484   os::close(fd);
3485   if (bytes_read &lt; 0) {
3486     FREE_C_HEAP_ARRAY(char, buf);
3487     jio_fprintf(defaultStream::error_stream(),
3488                 &quot;Could not read options file &#39;%s&#39;\n&quot;, file_name);
3489     return JNI_ERR;
3490   }
3491 
3492   if (bytes_read == 0) {
3493     // tell caller there is no option data and that is ok
3494     FREE_C_HEAP_ARRAY(char, buf);
3495     return JNI_OK;
3496   }
3497 
3498   retcode = parse_options_buffer(file_name, buf, bytes_read, vm_args);
3499 
3500   FREE_C_HEAP_ARRAY(char, buf);
3501   return retcode;
3502 }
3503 
3504 jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args) {
3505   GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JavaVMOption&gt;(2, true);    // Construct option array
3506 
3507   // some pointers to help with parsing
3508   char *buffer_end = buffer + buf_len;
3509   char *opt_hd = buffer;
3510   char *wrt = buffer;
3511   char *rd = buffer;
3512 
3513   // parse all options
3514   while (rd &lt; buffer_end) {
3515     // skip leading white space from the input string
3516     while (rd &lt; buffer_end &amp;&amp; isspace(*rd)) {
3517       rd++;
3518     }
3519 
3520     if (rd &gt;= buffer_end) {
3521       break;
3522     }
3523 
3524     // Remember this is where we found the head of the token.
3525     opt_hd = wrt;
3526 
3527     // Tokens are strings of non white space characters separated
3528     // by one or more white spaces.
3529     while (rd &lt; buffer_end &amp;&amp; !isspace(*rd)) {
3530       if (*rd == &#39;\&#39;&#39; || *rd == &#39;&quot;&#39;) {      // handle a quoted string
3531         int quote = *rd;                    // matching quote to look for
3532         rd++;                               // don&#39;t copy open quote
3533         while (rd &lt; buffer_end &amp;&amp; *rd != quote) {
3534                                             // include everything (even spaces)
3535                                             // up until the close quote
3536           *wrt++ = *rd++;                   // copy to option string
3537         }
3538 
3539         if (rd &lt; buffer_end) {
3540           rd++;                             // don&#39;t copy close quote
3541         } else {
3542                                             // did not see closing quote
3543           jio_fprintf(defaultStream::error_stream(),
3544                       &quot;Unmatched quote in %s\n&quot;, name);
3545           delete options;
3546           return JNI_ERR;
3547         }
3548       } else {
3549         *wrt++ = *rd++;                     // copy to option string
3550       }
3551     }
3552 
3553     // steal a white space character and set it to NULL
3554     *wrt++ = &#39;\0&#39;;
3555     // We now have a complete token
3556 
3557     JavaVMOption option;
3558     option.optionString = opt_hd;
3559     option.extraInfo = NULL;
3560 
3561     options-&gt;append(option);                // Fill in option
3562 
3563     rd++;  // Advance to next character
3564   }
3565 
3566   // Fill out JavaVMInitArgs structure.
3567   jint status = vm_args-&gt;set_args(options);
3568 
3569   delete options;
3570   return status;
3571 }
3572 
3573 jint Arguments::set_shared_spaces_flags_and_archive_paths() {
3574   if (DumpSharedSpaces) {
3575     if (RequireSharedSpaces) {
3576       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3577     }
3578     UseSharedSpaces = false;
3579   }
3580 #if INCLUDE_CDS
3581   // Initialize shared archive paths which could include both base and dynamic archive paths
3582   // This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.
3583   if (!init_shared_archive_paths()) {
3584     return JNI_ENOMEM;
3585   }
3586 #endif  // INCLUDE_CDS
3587   return JNI_OK;
3588 }
3589 
3590 #if INCLUDE_CDS
3591 // Sharing support
3592 // Construct the path to the archive
3593 char* Arguments::get_default_shared_archive_path() {
3594   char *default_archive_path;
3595   char jvm_path[JVM_MAXPATHLEN];
3596   os::jvm_path(jvm_path, sizeof(jvm_path));
3597   char *end = strrchr(jvm_path, *os::file_separator());
3598   if (end != NULL) *end = &#39;\0&#39;;
3599   size_t jvm_path_len = strlen(jvm_path);
3600   size_t file_sep_len = strlen(os::file_separator());
3601   const size_t len = jvm_path_len + file_sep_len + 20;
3602   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
3603   jio_snprintf(default_archive_path, len,
3604                UseCompressedOops ? &quot;%s%sclasses.jsa&quot;: &quot;%s%sclasses_nocoops.jsa&quot;,
3605                jvm_path, os::file_separator());
3606   return default_archive_path;
3607 }
3608 
3609 int Arguments::num_archives(const char* archive_path) {
3610   if (archive_path == NULL) {
3611     return 0;
3612   }
3613   int npaths = 1;
3614   char* p = (char*)archive_path;
3615   while (*p != &#39;\0&#39;) {
3616     if (*p == os::path_separator()[0]) {
3617       npaths++;
3618     }
3619     p++;
3620   }
3621   return npaths;
3622 }
3623 
3624 void Arguments::extract_shared_archive_paths(const char* archive_path,
3625                                          char** base_archive_path,
3626                                          char** top_archive_path) {
3627   char* begin_ptr = (char*)archive_path;
3628   char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);
3629   if (end_ptr == NULL || end_ptr == begin_ptr) {
3630     vm_exit_during_initialization(&quot;Base archive was not specified&quot;, archive_path);
3631   }
3632   size_t len = end_ptr - begin_ptr;
3633   char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
3634   strncpy(cur_path, begin_ptr, len);
3635   cur_path[len] = &#39;\0&#39;;
3636   FileMapInfo::check_archive((const char*)cur_path, true /*is_static*/);
3637   *base_archive_path = cur_path;
3638 
3639   begin_ptr = ++end_ptr;
3640   if (*begin_ptr == &#39;\0&#39;) {
3641     vm_exit_during_initialization(&quot;Top archive was not specified&quot;, archive_path);
3642   }
3643   end_ptr = strchr(begin_ptr, &#39;\0&#39;);
3644   assert(end_ptr != NULL, &quot;sanity&quot;);
3645   len = end_ptr - begin_ptr;
3646   cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
3647   strncpy(cur_path, begin_ptr, len + 1);
3648   //cur_path[len] = &#39;\0&#39;;
3649   FileMapInfo::check_archive((const char*)cur_path, false /*is_static*/);
3650   *top_archive_path = cur_path;
3651 }
3652 
3653 bool Arguments::init_shared_archive_paths() {
3654   if (ArchiveClassesAtExit != NULL) {
3655     if (DumpSharedSpaces) {
3656       vm_exit_during_initialization(&quot;-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump&quot;);
3657     }
3658     if (FLAG_SET_CMDLINE(DynamicDumpSharedSpaces, true) != JVMFlag::SUCCESS) {
3659       return false;
3660     }
3661     check_unsupported_dumping_properties();
3662     SharedDynamicArchivePath = os::strdup_check_oom(ArchiveClassesAtExit, mtArguments);
3663   }
3664   if (SharedArchiveFile == NULL) {
3665     SharedArchivePath = get_default_shared_archive_path();
3666   } else {
3667     int archives = num_archives(SharedArchiveFile);
3668     if (is_dumping_archive()) {
3669       if (archives &gt; 1) {
3670         vm_exit_during_initialization(
3671           &quot;Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping&quot;);
3672       }
3673       if (DynamicDumpSharedSpaces) {
3674         if (os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {
3675           vm_exit_during_initialization(
3676             &quot;Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit&quot;,
3677             SharedArchiveFile);
3678         }
3679       }
3680     }
3681     if (!is_dumping_archive()){
3682       if (archives &gt; 2) {
3683         vm_exit_during_initialization(
3684           &quot;Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option&quot;);
3685       }
3686       if (archives == 1) {
3687         char* temp_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);
3688         int name_size;
3689         bool success =
3690           FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &amp;name_size, &amp;SharedArchivePath);
3691         if (!success) {
3692           SharedArchivePath = temp_archive_path;
3693         } else {
3694           SharedDynamicArchivePath = temp_archive_path;
3695         }
3696       } else {
3697         extract_shared_archive_paths((const char*)SharedArchiveFile,
3698                                       &amp;SharedArchivePath, &amp;SharedDynamicArchivePath);
3699       }
3700     } else { // CDS dumping
3701       SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);
3702     }
3703   }
3704   return (SharedArchivePath != NULL);
3705 }
3706 #endif // INCLUDE_CDS
3707 
3708 #ifndef PRODUCT
3709 // Determine whether LogVMOutput should be implicitly turned on.
3710 static bool use_vm_log() {
3711   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3712       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3713       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3714       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3715       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3716     return true;
3717   }
3718 
3719 #ifdef COMPILER1
3720   if (PrintC1Statistics) {
3721     return true;
3722   }
3723 #endif // COMPILER1
3724 
3725 #ifdef COMPILER2
3726   if (PrintOptoAssembly || PrintOptoStatistics) {
3727     return true;
3728   }
3729 #endif // COMPILER2
3730 
3731   return false;
3732 }
3733 
3734 #endif // PRODUCT
3735 
3736 bool Arguments::args_contains_vm_options_file_arg(const JavaVMInitArgs* args) {
3737   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3738     const JavaVMOption* option = args-&gt;options + index;
3739     const char* tail;
3740     if (match_option(option, &quot;-XX:VMOptionsFile=&quot;, &amp;tail)) {
3741       return true;
3742     }
3743   }
3744   return false;
3745 }
3746 
3747 jint Arguments::insert_vm_options_file(const JavaVMInitArgs* args,
3748                                        const char* vm_options_file,
3749                                        const int vm_options_file_pos,
3750                                        ScopedVMInitArgs* vm_options_file_args,
3751                                        ScopedVMInitArgs* args_out) {
3752   jint code = parse_vm_options_file(vm_options_file, vm_options_file_args);
3753   if (code != JNI_OK) {
3754     return code;
3755   }
3756 
3757   if (vm_options_file_args-&gt;get()-&gt;nOptions &lt; 1) {
3758     return JNI_OK;
3759   }
3760 
3761   if (args_contains_vm_options_file_arg(vm_options_file_args-&gt;get())) {
3762     jio_fprintf(defaultStream::error_stream(),
3763                 &quot;A VM options file may not refer to a VM options file. &quot;
3764                 &quot;Specification of &#39;-XX:VMOptionsFile=&lt;file-name&gt;&#39; in the &quot;
3765                 &quot;options file &#39;%s&#39; in options container &#39;%s&#39; is an error.\n&quot;,
3766                 vm_options_file_args-&gt;vm_options_file_arg(),
3767                 vm_options_file_args-&gt;container_name());
3768     return JNI_EINVAL;
3769   }
3770 
3771   return args_out-&gt;insert(args, vm_options_file_args-&gt;get(),
3772                           vm_options_file_pos);
3773 }
3774 
3775 // Expand -XX:VMOptionsFile found in args_in as needed.
3776 // mod_args and args_out parameters may return values as needed.
3777 jint Arguments::expand_vm_options_as_needed(const JavaVMInitArgs* args_in,
3778                                             ScopedVMInitArgs* mod_args,
3779                                             JavaVMInitArgs** args_out) {
3780   jint code = match_special_option_and_act(args_in, mod_args);
3781   if (code != JNI_OK) {
3782     return code;
3783   }
3784 
3785   if (mod_args-&gt;is_set()) {
3786     // args_in contains -XX:VMOptionsFile and mod_args contains the
3787     // original options from args_in along with the options expanded
3788     // from the VMOptionsFile. Return a short-hand to the caller.
3789     *args_out = mod_args-&gt;get();
3790   } else {
3791     *args_out = (JavaVMInitArgs *)args_in;  // no changes so use args_in
3792   }
3793   return JNI_OK;
3794 }
3795 
3796 jint Arguments::match_special_option_and_act(const JavaVMInitArgs* args,
3797                                              ScopedVMInitArgs* args_out) {
3798   // Remaining part of option string
3799   const char* tail;
3800   ScopedVMInitArgs vm_options_file_args(args_out-&gt;container_name());
3801 
3802   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3803     const JavaVMOption* option = args-&gt;options + index;
3804     if (match_option(option, &quot;-XX:Flags=&quot;, &amp;tail)) {
3805       Arguments::set_jvm_flags_file(tail);
3806       continue;
3807     }
3808     if (match_option(option, &quot;-XX:VMOptionsFile=&quot;, &amp;tail)) {
3809       if (vm_options_file_args.found_vm_options_file_arg()) {
3810         jio_fprintf(defaultStream::error_stream(),
3811                     &quot;The option &#39;%s&#39; is already specified in the options &quot;
3812                     &quot;container &#39;%s&#39; so the specification of &#39;%s&#39; in the &quot;
3813                     &quot;same options container is an error.\n&quot;,
3814                     vm_options_file_args.vm_options_file_arg(),
3815                     vm_options_file_args.container_name(),
3816                     option-&gt;optionString);
3817         return JNI_EINVAL;
3818       }
3819       vm_options_file_args.set_vm_options_file_arg(option-&gt;optionString);
3820       // If there&#39;s a VMOptionsFile, parse that
3821       jint code = insert_vm_options_file(args, tail, index,
3822                                          &amp;vm_options_file_args, args_out);
3823       if (code != JNI_OK) {
3824         return code;
3825       }
3826       args_out-&gt;set_vm_options_file_arg(vm_options_file_args.vm_options_file_arg());
3827       if (args_out-&gt;is_set()) {
3828         // The VMOptions file inserted some options so switch &#39;args&#39;
3829         // to the new set of options, and continue processing which
3830         // preserves &quot;last option wins&quot; semantics.
3831         args = args_out-&gt;get();
3832         // The first option from the VMOptionsFile replaces the
3833         // current option.  So we back track to process the
3834         // replacement option.
3835         index--;
3836       }
3837       continue;
3838     }
3839     if (match_option(option, &quot;-XX:+PrintVMOptions&quot;)) {
3840       PrintVMOptions = true;
3841       continue;
3842     }
3843     if (match_option(option, &quot;-XX:-PrintVMOptions&quot;)) {
3844       PrintVMOptions = false;
3845       continue;
3846     }
3847     if (match_option(option, &quot;-XX:+IgnoreUnrecognizedVMOptions&quot;)) {
3848       IgnoreUnrecognizedVMOptions = true;
3849       continue;
3850     }
3851     if (match_option(option, &quot;-XX:-IgnoreUnrecognizedVMOptions&quot;)) {
3852       IgnoreUnrecognizedVMOptions = false;
3853       continue;
3854     }
3855     if (match_option(option, &quot;-XX:+PrintFlagsInitial&quot;)) {
3856       JVMFlag::printFlags(tty, false);
3857       vm_exit(0);
3858     }
3859     if (match_option(option, &quot;-XX:NativeMemoryTracking&quot;, &amp;tail)) {
3860 #if INCLUDE_NMT
3861       // The launcher did not setup nmt environment variable properly.
3862       if (!MemTracker::check_launcher_nmt_support(tail)) {
3863         warning(&quot;Native Memory Tracking did not setup properly, using wrong launcher?&quot;);
3864       }
3865 
3866       // Verify if nmt option is valid.
3867       if (MemTracker::verify_nmt_option()) {
3868         // Late initialization, still in single-threaded mode.
3869         if (MemTracker::tracking_level() &gt;= NMT_summary) {
3870           MemTracker::init();
3871         }
3872       } else {
3873         vm_exit_during_initialization(&quot;Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]&quot;, NULL);
3874       }
3875       continue;
3876 #else
3877       jio_fprintf(defaultStream::error_stream(),
3878         &quot;Native Memory Tracking is not supported in this VM\n&quot;);
3879       return JNI_ERR;
3880 #endif
3881     }
3882 
3883 #ifndef PRODUCT
3884     if (match_option(option, &quot;-XX:+PrintFlagsWithComments&quot;)) {
3885       JVMFlag::printFlags(tty, true);
3886       vm_exit(0);
3887     }
3888 #endif
3889   }
3890   return JNI_OK;
3891 }
3892 
3893 static void print_options(const JavaVMInitArgs *args) {
3894   const char* tail;
3895   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3896     const JavaVMOption *option = args-&gt;options + index;
3897     if (match_option(option, &quot;-XX:&quot;, &amp;tail)) {
3898       logOption(tail);
3899     }
3900   }
3901 }
3902 
3903 bool Arguments::handle_deprecated_print_gc_flags() {
3904   if (PrintGC) {
3905     log_warning(gc)(&quot;-XX:+PrintGC is deprecated. Will use -Xlog:gc instead.&quot;);
3906   }
3907   if (PrintGCDetails) {
3908     log_warning(gc)(&quot;-XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.&quot;);
3909   }
3910 
3911   if (_gc_log_filename != NULL) {
3912     // -Xloggc was used to specify a filename
3913     const char* gc_conf = PrintGCDetails ? &quot;gc*&quot; : &quot;gc&quot;;
3914 
3915     LogTarget(Error, logging) target;
3916     LogStream errstream(target);
3917     return LogConfiguration::parse_log_arguments(_gc_log_filename, gc_conf, NULL, NULL, &amp;errstream);
3918   } else if (PrintGC || PrintGCDetails) {
3919     LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
3920   }
3921   return true;
3922 }
3923 
3924 // Parse entry point called from JNI_CreateJavaVM
3925 
3926 jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
3927   assert(verify_special_jvm_flags(false), &quot;deprecated and obsolete flag table inconsistent&quot;);
3928 
3929   // Initialize ranges and constraints
3930   JVMFlagRangeList::init();
3931   JVMFlagConstraintList::init();
3932 
3933   // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
3934   const char* hotspotrc = &quot;.hotspotrc&quot;;
3935   bool settings_file_specified = false;
3936   bool needs_hotspotrc_warning = false;
3937   ScopedVMInitArgs initial_vm_options_args(&quot;&quot;);
3938   ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3939   ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3940 
3941   // Pointers to current working set of containers
3942   JavaVMInitArgs* cur_cmd_args;
3943   JavaVMInitArgs* cur_vm_options_args;
3944   JavaVMInitArgs* cur_java_options_args;
3945   JavaVMInitArgs* cur_java_tool_options_args;
3946 
3947   // Containers for modified/expanded options
3948   ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);
3949   ScopedVMInitArgs mod_vm_options_args(&quot;vm_options_args&quot;);
3950   ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3951   ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3952 
3953 
3954   jint code =
3955       parse_java_tool_options_environment_variable(&amp;initial_java_tool_options_args);
3956   if (code != JNI_OK) {
3957     return code;
3958   }
3959 
3960   code = parse_java_options_environment_variable(&amp;initial_java_options_args);
3961   if (code != JNI_OK) {
3962     return code;
3963   }
3964 
3965   // Parse the options in the /java.base/jdk/internal/vm/options resource, if present
3966   char *vmoptions = ClassLoader::lookup_vm_options();
3967   if (vmoptions != NULL) {
3968     code = parse_options_buffer(&quot;vm options resource&quot;, vmoptions, strlen(vmoptions), &amp;initial_vm_options_args);
3969     FREE_C_HEAP_ARRAY(char, vmoptions);
3970     if (code != JNI_OK) {
3971       return code;
3972     }
3973   }
3974 
3975   code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
3976                                      &amp;mod_java_tool_options_args,
3977                                      &amp;cur_java_tool_options_args);
3978   if (code != JNI_OK) {
3979     return code;
3980   }
3981 
3982   code = expand_vm_options_as_needed(initial_cmd_args,
3983                                      &amp;mod_cmd_args,
3984                                      &amp;cur_cmd_args);
3985   if (code != JNI_OK) {
3986     return code;
3987   }
3988 
3989   code = expand_vm_options_as_needed(initial_java_options_args.get(),
3990                                      &amp;mod_java_options_args,
3991                                      &amp;cur_java_options_args);
3992   if (code != JNI_OK) {
3993     return code;
3994   }
3995 
3996   code = expand_vm_options_as_needed(initial_vm_options_args.get(),
3997                                      &amp;mod_vm_options_args,
3998                                      &amp;cur_vm_options_args);
3999   if (code != JNI_OK) {
4000     return code;
4001   }
4002 
4003   const char* flags_file = Arguments::get_jvm_flags_file();
4004   settings_file_specified = (flags_file != NULL);
4005 
4006   if (IgnoreUnrecognizedVMOptions) {
4007     cur_cmd_args-&gt;ignoreUnrecognized = true;
4008     cur_java_tool_options_args-&gt;ignoreUnrecognized = true;
4009     cur_java_options_args-&gt;ignoreUnrecognized = true;
4010   }
4011 
4012   // Parse specified settings file
4013   if (settings_file_specified) {
4014     if (!process_settings_file(flags_file, true,
4015                                cur_cmd_args-&gt;ignoreUnrecognized)) {
4016       return JNI_EINVAL;
4017     }
4018   } else {
4019 #ifdef ASSERT
4020     // Parse default .hotspotrc settings file
4021     if (!process_settings_file(&quot;.hotspotrc&quot;, false,
4022                                cur_cmd_args-&gt;ignoreUnrecognized)) {
4023       return JNI_EINVAL;
4024     }
4025 #else
4026     struct stat buf;
4027     if (os::stat(hotspotrc, &amp;buf) == 0) {
4028       needs_hotspotrc_warning = true;
4029     }
4030 #endif
4031   }
4032 
4033   if (PrintVMOptions) {
4034     print_options(cur_java_tool_options_args);
4035     print_options(cur_cmd_args);
4036     print_options(cur_java_options_args);
4037   }
4038 
4039   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
4040   jint result = parse_vm_init_args(cur_vm_options_args,
4041                                    cur_java_tool_options_args,
4042                                    cur_java_options_args,
4043                                    cur_cmd_args);
4044 
4045   if (result != JNI_OK) {
4046     return result;
4047   }
4048 
4049   // Delay warning until here so that we&#39;ve had a chance to process
4050   // the -XX:-PrintWarnings flag
4051   if (needs_hotspotrc_warning) {
4052     warning(&quot;%s file is present but has been ignored.  &quot;
4053             &quot;Run with -XX:Flags=%s to load the file.&quot;,
4054             hotspotrc, hotspotrc);
4055   }
4056 
4057   if (needs_module_property_warning) {
4058     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
4059             &quot; names that are reserved for internal use.&quot;);
4060   }
4061 
4062 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
4063   UNSUPPORTED_OPTION(UseLargePages);
4064 #endif
4065 
4066 #if defined(AIX)
4067   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
4068   UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);
4069 #endif
4070 
4071 #ifndef PRODUCT
4072   if (TraceBytecodesAt != 0) {
4073     TraceBytecodes = true;
4074   }
4075   if (CountCompiledCalls) {
4076     if (UseCounterDecay) {
4077       warning(&quot;UseCounterDecay disabled because CountCalls is set&quot;);
4078       UseCounterDecay = false;
4079     }
4080   }
4081 #endif // PRODUCT
4082 
4083   if (ScavengeRootsInCode == 0) {
4084     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
4085       warning(&quot;Forcing ScavengeRootsInCode non-zero&quot;);
4086     }
4087     ScavengeRootsInCode = 1;
4088   }
4089 
4090   if (!handle_deprecated_print_gc_flags()) {
4091     return JNI_EINVAL;
4092   }
4093 
4094   // Set object alignment values.
4095   set_object_alignment();
4096 
4097 #if !INCLUDE_CDS
4098   if (DumpSharedSpaces || RequireSharedSpaces) {
4099     jio_fprintf(defaultStream::error_stream(),
4100       &quot;Shared spaces are not supported in this VM\n&quot;);
4101     return JNI_ERR;
4102   }
4103   if (DumpLoadedClassList != NULL) {
4104     jio_fprintf(defaultStream::error_stream(),
4105       &quot;DumpLoadedClassList is not supported in this VM\n&quot;);
4106     return JNI_ERR;
4107   }
4108   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
4109       log_is_enabled(Info, cds)) {
4110     warning(&quot;Shared spaces are not supported in this VM&quot;);
4111     FLAG_SET_DEFAULT(UseSharedSpaces, false);
4112     LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
4113   }
4114   no_shared_spaces(&quot;CDS Disabled&quot;);
4115 #endif // INCLUDE_CDS
4116 
4117 #ifndef TIERED
4118   if (FLAG_IS_CMDLINE(CompilationMode)) {
4119     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);
4120   }
4121 #endif
4122 
4123   return JNI_OK;
4124 }
4125 
4126 jint Arguments::apply_ergo() {
4127   // Set flags based on ergonomics.
4128   jint result = set_ergonomics_flags();
4129   if (result != JNI_OK) return result;
4130 
4131   // Set heap size based on available physical memory
4132   set_heap_size();
4133 
4134   GCConfig::arguments()-&gt;initialize();
4135 
4136   result = set_shared_spaces_flags_and_archive_paths();
4137   if (result != JNI_OK) return result;
4138 
4139   // Initialize Metaspace flags and alignments
4140   Metaspace::ergo_initialize();
4141 
4142   // Set compiler flags after GC is selected and GC specific
4143   // flags (LoopStripMiningIter) are set.
4144   CompilerConfig::ergo_initialize();
4145 
4146   // Set bytecode rewriting flags
4147   set_bytecode_flags();
4148 
4149   // Set flags if aggressive optimization flags are enabled
4150   jint code = set_aggressive_opts_flags();
4151   if (code != JNI_OK) {
4152     return code;
4153   }
4154 
4155   // Turn off biased locking for locking debug mode flags,
4156   // which are subtly different from each other but neither works with
4157   // biased locking
4158   if (UseHeavyMonitors
4159 #ifdef COMPILER1
4160       || !UseFastLocking
4161 #endif // COMPILER1
4162 #if INCLUDE_JVMCI
4163       || !JVMCIUseFastLocking
4164 #endif
4165     ) {
4166     if (!FLAG_IS_DEFAULT(UseBiasedLocking) &amp;&amp; UseBiasedLocking) {
4167       // flag set to true on command line; warn the user that they
4168       // can&#39;t enable biased locking here
4169       warning(&quot;Biased Locking is not supported with locking debug flags&quot;
4170               &quot;; ignoring UseBiasedLocking flag.&quot; );
4171     }
4172     UseBiasedLocking = false;
4173   }
4174 
4175 #ifdef CC_INTERP
4176   // Clear flags not supported on zero.
4177   FLAG_SET_DEFAULT(ProfileInterpreter, false);
4178   FLAG_SET_DEFAULT(UseBiasedLocking, false);
4179   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
4180   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));
4181 #endif // CC_INTERP
4182 
4183   if (PrintAssembly &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
4184     warning(&quot;PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output&quot;);
4185     DebugNonSafepoints = true;
4186   }
4187 
4188   if (FLAG_IS_CMDLINE(CompressedClassSpaceSize) &amp;&amp; !UseCompressedClassPointers) {
4189     warning(&quot;Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used&quot;);
4190   }
4191 
4192   // Treat the odd case where local verification is enabled but remote
4193   // verification is not as if both were enabled.
4194   if (BytecodeVerificationLocal &amp;&amp; !BytecodeVerificationRemote) {
4195     log_info(verification)(&quot;Turning on remote verification because local verification is on&quot;);
4196     FLAG_SET_DEFAULT(BytecodeVerificationRemote, true);
4197   }
4198   if (!EnableValhalla || (is_interpreter_only() &amp;&amp; !is_dumping_archive())) {
4199     // Disable calling convention optimizations if value types are not supported
4200     InlineTypePassFieldsAsArgs = false;
4201     InlineTypeReturnedAsFields = false;
4202   }
4203 
4204 #ifndef PRODUCT
4205   if (!LogVMOutput &amp;&amp; FLAG_IS_DEFAULT(LogVMOutput)) {
4206     if (use_vm_log()) {
4207       LogVMOutput = true;
4208     }
4209   }
4210 #endif // PRODUCT
4211 
4212   if (PrintCommandLineFlags) {
4213     JVMFlag::printSetFlags(tty);
4214   }
4215 
4216   // Apply CPU specific policy for the BiasedLocking
4217   if (UseBiasedLocking) {
4218     if (!VM_Version::use_biased_locking() &amp;&amp;
4219         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
4220       UseBiasedLocking = false;
4221     }
4222   }
4223 #ifdef COMPILER2
4224   if (!UseBiasedLocking) {
4225     UseOptoBiasInlining = false;
4226   }
4227 #endif
4228 
4229   return JNI_OK;
4230 }
4231 
4232 jint Arguments::adjust_after_os() {
4233   if (UseNUMA) {
4234     if (UseParallelGC) {
4235       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
4236          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
4237       }
4238     }
4239   }
4240   return JNI_OK;
4241 }
4242 
4243 int Arguments::PropertyList_count(SystemProperty* pl) {
4244   int count = 0;
4245   while(pl != NULL) {
4246     count++;
4247     pl = pl-&gt;next();
4248   }
4249   return count;
4250 }
4251 
4252 // Return the number of readable properties.
4253 int Arguments::PropertyList_readable_count(SystemProperty* pl) {
4254   int count = 0;
4255   while(pl != NULL) {
4256     if (pl-&gt;is_readable()) {
4257       count++;
4258     }
4259     pl = pl-&gt;next();
4260   }
4261   return count;
4262 }
4263 
4264 const char* Arguments::PropertyList_get_value(SystemProperty *pl, const char* key) {
4265   assert(key != NULL, &quot;just checking&quot;);
4266   SystemProperty* prop;
4267   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
4268     if (strcmp(key, prop-&gt;key()) == 0) return prop-&gt;value();
4269   }
4270   return NULL;
4271 }
4272 
4273 // Return the value of the requested property provided that it is a readable property.
4274 const char* Arguments::PropertyList_get_readable_value(SystemProperty *pl, const char* key) {
4275   assert(key != NULL, &quot;just checking&quot;);
4276   SystemProperty* prop;
4277   // Return the property value if the keys match and the property is not internal or
4278   // it&#39;s the special internal property &quot;jdk.boot.class.path.append&quot;.
4279   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
4280     if (strcmp(key, prop-&gt;key()) == 0) {
4281       if (!prop-&gt;internal()) {
4282         return prop-&gt;value();
4283       } else if (strcmp(key, &quot;jdk.boot.class.path.append&quot;) == 0) {
4284         return prop-&gt;value();
4285       } else {
4286         // Property is internal and not jdk.boot.class.path.append so return NULL.
4287         return NULL;
4288       }
4289     }
4290   }
4291   return NULL;
4292 }
4293 
4294 const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {
4295   int count = 0;
4296   const char* ret_val = NULL;
4297 
4298   while(pl != NULL) {
4299     if(count &gt;= index) {
4300       ret_val = pl-&gt;key();
4301       break;
4302     }
4303     count++;
4304     pl = pl-&gt;next();
4305   }
4306 
4307   return ret_val;
4308 }
4309 
4310 char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {
4311   int count = 0;
4312   char* ret_val = NULL;
4313 
4314   while(pl != NULL) {
4315     if(count &gt;= index) {
4316       ret_val = pl-&gt;value();
4317       break;
4318     }
4319     count++;
4320     pl = pl-&gt;next();
4321   }
4322 
4323   return ret_val;
4324 }
4325 
4326 void Arguments::PropertyList_add(SystemProperty** plist, SystemProperty *new_p) {
4327   SystemProperty* p = *plist;
4328   if (p == NULL) {
4329     *plist = new_p;
4330   } else {
4331     while (p-&gt;next() != NULL) {
4332       p = p-&gt;next();
4333     }
4334     p-&gt;set_next(new_p);
4335   }
4336 }
4337 
4338 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4339                                  bool writeable, bool internal) {
4340   if (plist == NULL)
4341     return;
4342 
4343   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4344   PropertyList_add(plist, new_p);
4345 }
4346 
4347 void Arguments::PropertyList_add(SystemProperty *element) {
4348   PropertyList_add(&amp;_system_properties, element);
4349 }
4350 
4351 // This add maintains unique property key in the list.
4352 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4353                                         PropertyAppendable append, PropertyWriteable writeable,
4354                                         PropertyInternal internal) {
4355   if (plist == NULL)
4356     return;
4357 
<a name="19" id="anc19"></a><span class="line-modified">4358   // If property key exists and is writeable, then update with new value.</span>
<span class="line-added">4359   // Trying to update a non-writeable property is silently ignored.</span>
4360   SystemProperty* prop;
4361   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4362     if (strcmp(k, prop-&gt;key()) == 0) {
4363       if (append == AppendProperty) {
<a name="20" id="anc20"></a><span class="line-modified">4364         prop-&gt;append_writeable_value(v);</span>
4365       } else {
<a name="21" id="anc21"></a><span class="line-modified">4366         prop-&gt;set_writeable_value(v);</span>
4367       }
4368       return;
4369     }
4370   }
4371 
4372   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4373 }
4374 
4375 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4376 // Returns true if all of the source pointed by src has been copied over to
4377 // the destination buffer pointed by buf. Otherwise, returns false.
4378 // Notes:
4379 // 1. If the length (buflen) of the destination buffer excluding the
4380 // NULL terminator character is not long enough for holding the expanded
4381 // pid characters, it also returns false instead of returning the partially
4382 // expanded one.
4383 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4384 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4385                                 char* buf, size_t buflen) {
4386   const char* p = src;
4387   char* b = buf;
4388   const char* src_end = &amp;src[srclen];
4389   char* buf_end = &amp;buf[buflen - 1];
4390 
4391   while (p &lt; src_end &amp;&amp; b &lt; buf_end) {
4392     if (*p == &#39;%&#39;) {
4393       switch (*(++p)) {
4394       case &#39;%&#39;:         // &quot;%%&quot; ==&gt; &quot;%&quot;
4395         *b++ = *p++;
4396         break;
4397       case &#39;p&#39;:  {       //  &quot;%p&quot; ==&gt; current process id
4398         // buf_end points to the character before the last character so
4399         // that we could write &#39;\0&#39; to the end of the buffer.
4400         size_t buf_sz = buf_end - b + 1;
4401         int ret = jio_snprintf(b, buf_sz, &quot;%d&quot;, os::current_process_id());
4402 
4403         // if jio_snprintf fails or the buffer is not long enough to hold
4404         // the expanded pid, returns false.
4405         if (ret &lt; 0 || ret &gt;= (int)buf_sz) {
4406           return false;
4407         } else {
4408           b += ret;
4409           assert(*b == &#39;\0&#39;, &quot;fail in copy_expand_pid&quot;);
4410           if (p == src_end &amp;&amp; b == buf_end + 1) {
4411             // reach the end of the buffer.
4412             return true;
4413           }
4414         }
4415         p++;
4416         break;
4417       }
4418       default :
4419         *b++ = &#39;%&#39;;
4420       }
4421     } else {
4422       *b++ = *p++;
4423     }
4424   }
4425   *b = &#39;\0&#39;;
4426   return (p == src_end); // return false if not all of the source was copied
4427 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
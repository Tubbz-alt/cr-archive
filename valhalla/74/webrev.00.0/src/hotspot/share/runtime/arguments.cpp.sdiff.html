<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 558 #ifndef X86
 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 560 #endif // !X86
 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },




 563 
 564 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 565   // These entries will generate build errors.  Their purpose is to test the macros.
 566   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 567   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 568   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 569   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 570   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 571   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 572   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 573 #endif
 574 
 575 #ifndef COMPILER2
 576   // These flags were generally available, but are C2 only, now.
 577   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 578   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 579   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 580   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 581   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 582   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 583 #endif
 584 
 585   { NULL, JDK_Version(0), JDK_Version(0) }
 586 };
 587 
 588 // Flags that are aliases for other flags.
 589 typedef struct {
 590   const char* alias_name;
 591   const char* real_name;
 592 } AliasedFlag;
 593 
 594 static AliasedFlag const aliased_jvm_flags[] = {
 595   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 596   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 597   { NULL, NULL}
 598 };
 599 
 600 // NOTE: A compatibility request will be necessary for each alias to be removed.
 601 static AliasedLoggingFlag const aliased_logging_flags[] = {
<span class="line-removed"> 602   { &quot;PrintCompressedOopsMode&quot;,   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },</span>
 603   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 604   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 605   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 606   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 607   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 608   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 609   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 610   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 611   { &quot;TraceInvokeDynamic&quot;,        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
 612   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 613   { &quot;TraceMethodHandles&quot;,        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
 614   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 615   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 616   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 617   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 618   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 619   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 620 };
 621 
 622 #ifndef PRODUCT
</pre>
<hr />
<pre>
2124                 TLABRefillWasteFraction);
2125     status = false;
2126   }
2127 
2128   if (PrintNMTStatistics) {
2129 #if INCLUDE_NMT
2130     if (MemTracker::tracking_level() == NMT_off) {
2131 #endif // INCLUDE_NMT
2132       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2133       PrintNMTStatistics = false;
2134 #if INCLUDE_NMT
2135     }
2136 #endif
2137   }
2138 
2139   status = CompilerConfig::check_args_consistency(status);
2140 #if INCLUDE_JVMCI
2141   if (status &amp;&amp; EnableJVMCI) {
2142     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2143         AddProperty, UnwriteableProperty, InternalProperty);
<span class="line-modified">2144     if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {</span>
2145       return false;
2146     }
2147   }
2148 #endif
2149 
2150 #ifndef SUPPORT_RESERVED_STACK_AREA
2151   if (StackReservedPages != 0) {
2152     FLAG_SET_CMDLINE(StackReservedPages, 0);
2153     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2154   }
2155 #endif
2156 
2157   status = status &amp;&amp; GCArguments::check_args_consistency();
2158 
2159   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {
2160     FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);
2161     warning(&quot;InlineTypePassFieldsAsArgs is not supported on this platform&quot;);
2162   }
2163 
2164   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {
</pre>
<hr />
<pre>
2198 
2199   // Check the sign first since atojulong() parses only unsigned values.
2200   bool value_is_positive = !(*value == &#39;-&#39;);
2201 
2202   if (value_is_positive) {
2203     julong n;
2204     bool good_return = atojulong(value, &amp;n);
2205     if (good_return) {
2206       bool above_minimum = n &gt;= min_size;
2207       bool value_is_too_large = n &gt; max_uintx;
2208 
2209       if (above_minimum &amp;&amp; !value_is_too_large) {
2210         *uintx_arg = n;
2211         return true;
2212       }
2213     }
2214   }
2215   return false;
2216 }
2217 
<span class="line-modified">2218 bool Arguments::create_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {</span>


2219   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2220   char* property = AllocateHeap(prop_len, mtArguments);
2221   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2222   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2223     FreeHeap(property);
2224     return false;
2225   }
<span class="line-modified">2226   bool added = add_property(property, UnwriteableProperty, internal);</span>





2227   FreeHeap(property);
2228   return added;
2229 }
2230 
<span class="line-modified">2231 bool Arguments::create_numbered_property(const char* prop_base_name, const char* prop_value, unsigned int count) {</span>

2232   const unsigned int props_count_limit = 1000;
2233   const int max_digits = 3;
2234   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2235 
2236   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2237   if (count &lt; props_count_limit) {
2238     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2239     char* property = AllocateHeap(prop_len, mtArguments);
2240     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2241     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2242       FreeHeap(property);
2243       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2244       return false;
2245     }
2246     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2247     FreeHeap(property);
2248     return added;
2249   }
2250 
2251   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
</pre>
<hr />
<pre>
2373 }
2374 
2375 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2376   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2377   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2378   // Find the equal sign between the module name and the path specification
2379   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2380   if (module_equal == NULL) {
2381     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2382     return JNI_ERR;
2383   } else {
2384     // Pick out the module name
2385     size_t module_len = module_equal - patch_mod_tail;
2386     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2387     if (module_name != NULL) {
2388       memcpy(module_name, patch_mod_tail, module_len);
2389       *(module_name + module_len) = &#39;\0&#39;;
2390       // The path piece begins one past the module_equal sign
2391       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2392       FREE_C_HEAP_ARRAY(char, module_name);
<span class="line-modified">2393       if (!create_numbered_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {</span>
2394         return JNI_ENOMEM;
2395       }
2396     } else {
2397       return JNI_ENOMEM;
2398     }
2399   }
2400   return JNI_OK;
2401 }
2402 
2403 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2404 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2405   // The min and max sizes match the values in globals.hpp, but scaled
2406   // with K. The values have been chosen so that alignment with page
2407   // size doesn&#39;t change the max value, which makes the conversions
2408   // back and forth between Xss value and ThreadStackSize value easier.
2409   // The values have also been chosen to fit inside a 32-bit signed type.
2410   const julong min_ThreadStackSize = 0;
2411   const julong max_ThreadStackSize = 1 * M;
2412 
2413   const julong min_size = min_ThreadStackSize * K;
</pre>
<hr />
<pre>
2518         const char* pos = strchr(tail, &#39;:&#39;);
2519         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2520         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2521         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2522 
2523         char *options = NULL;
2524         if(pos != NULL) {
2525           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2526           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2527         }
2528 #if !INCLUDE_JVMTI
2529         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2530           jio_fprintf(defaultStream::error_stream(),
2531             &quot;Debugging agents are not supported in this VM\n&quot;);
2532           return JNI_ERR;
2533         }
2534 #endif // !INCLUDE_JVMTI
2535         add_init_library(name, options);
2536       }
2537     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
<span class="line-modified">2538       if (!create_numbered_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {</span>
2539         return JNI_ENOMEM;
2540       }
2541     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
<span class="line-modified">2542       if (!create_numbered_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {</span>
2543         return JNI_ENOMEM;
2544       }
2545     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
<span class="line-modified">2546       if (!create_numbered_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {</span>
2547         return JNI_ENOMEM;
2548       }
2549     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
<span class="line-modified">2550       if (!create_numbered_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {</span>
2551         return JNI_ENOMEM;
2552       }
2553     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
<span class="line-modified">2554       if (!create_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {</span>
2555         return JNI_ENOMEM;
2556       }
2557     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
<span class="line-modified">2558       if (!create_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {</span>
2559         return JNI_ENOMEM;
2560       }
2561     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
<span class="line-modified">2562       if (!create_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {</span>
2563         return JNI_ENOMEM;
2564       }
2565     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2566       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2567       int res = process_patch_mod_option(tail, patch_mod_javabase);
2568       if (res != JNI_OK) {
2569         return res;
2570       }
2571     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
<span class="line-modified">2572       if (!create_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {</span>
2573         return JNI_ENOMEM;
2574       }
2575     // -agentlib and -agentpath
2576     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2577           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2578       if(tail != NULL) {
2579         const char* pos = strchr(tail, &#39;=&#39;);
2580         char* name;
2581         if (pos == NULL) {
2582           name = os::strdup_check_oom(tail, mtArguments);
2583         } else {
2584           size_t len = pos - tail;
2585           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2586           memcpy(name, tail, len);
2587           name[len] = &#39;\0&#39;;
2588         }
2589 
2590         char *options = NULL;
2591         if(pos != NULL) {
2592           options = os::strdup_check_oom(pos + 1, mtArguments);
</pre>
<hr />
<pre>
2596           jio_fprintf(defaultStream::error_stream(),
2597             &quot;Debugging agents are not supported in this VM\n&quot;);
2598           return JNI_ERR;
2599         }
2600 #endif // !INCLUDE_JVMTI
2601         add_init_agent(name, options, is_absolute_path);
2602       }
2603     // -javaagent
2604     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2605 #if !INCLUDE_JVMTI
2606       jio_fprintf(defaultStream::error_stream(),
2607         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2608       return JNI_ERR;
2609 #else
2610       if (tail != NULL) {
2611         size_t length = strlen(tail) + 1;
2612         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2613         jio_snprintf(options, length, &quot;%s&quot;, tail);
2614         add_instrument_agent(&quot;instrument&quot;, options, false);
2615         // java agents need module java.instrument
<span class="line-modified">2616         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {</span>
2617           return JNI_ENOMEM;
2618         }
2619       }
2620 #endif // !INCLUDE_JVMTI
2621     // --enable_preview
2622     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2623       set_enable_preview();
2624     // -Xnoclassgc
2625     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2626       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2627         return JNI_EINVAL;
2628       }
2629     // -Xbatch
2630     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2631       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2632         return JNI_EINVAL;
2633       }
2634     // -Xmn for compatibility with other JVM vendors
2635     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2636       julong long_initial_young_size = 0;
</pre>
<hr />
<pre>
2777           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2778         return JNI_EINVAL;
2779       }
2780       // Check for module related properties.  They must be set using the modules
2781       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2782       // &quot;-Djdk.module.addmods=java.sql&quot;
2783       if (is_internal_module_property(option-&gt;optionString + 2)) {
2784         needs_module_property_warning = true;
2785         continue;
2786       }
2787       if (!add_property(tail)) {
2788         return JNI_ENOMEM;
2789       }
2790       // Out of the box management support
2791       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2792 #if INCLUDE_MANAGEMENT
2793         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2794           return JNI_EINVAL;
2795         }
2796         // management agent in module jdk.management.agent
<span class="line-modified">2797         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {</span>
2798           return JNI_ENOMEM;
2799         }
2800 #else
2801         jio_fprintf(defaultStream::output_stream(),
2802           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2803         return JNI_ERR;
2804 #endif
2805       }
2806     // -Xint
2807     } else if (match_option(option, &quot;-Xint&quot;)) {
2808           set_mode_flags(_int);
2809     // -Xmixed
2810     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2811           set_mode_flags(_mixed);
2812     // -Xcomp
2813     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2814       // for testing the compiler; turn off all flags that inhibit compilation
2815           set_mode_flags(_comp);
2816     // -Xshare:dump
2817     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
</pre>
<hr />
<pre>
3056 #if INCLUDE_JFR
3057     } else if (match_jfr_option(&amp;option)) {
3058       return JNI_EINVAL;
3059 #endif
3060     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
3061       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
3062       // already been handled
3063       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
3064           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
3065         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3066           return JNI_EINVAL;
3067         }
3068       }
3069     // Unknown option
3070     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3071       return JNI_ERR;
3072     }
3073   }
3074 
3075   if (EnableValhalla) {
<span class="line-modified">3076     if (!create_property(&quot;valhalla.enableValhalla&quot;, &quot;true&quot;, InternalProperty)) {</span>












3077       return JNI_ENOMEM;
3078     }
3079   }
3080 
3081   // PrintSharedArchiveAndExit will turn on
3082   //   -Xshare:on
3083   //   -Xlog:class+path=info
3084   if (PrintSharedArchiveAndExit) {
3085     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
3086       return JNI_EINVAL;
3087     }
3088     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
3089       return JNI_EINVAL;
3090     }
3091     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
3092   }
3093 
3094   fix_appclasspath();
3095 
3096   return JNI_OK;
</pre>
<hr />
<pre>
4315 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4316                                  bool writeable, bool internal) {
4317   if (plist == NULL)
4318     return;
4319 
4320   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4321   PropertyList_add(plist, new_p);
4322 }
4323 
4324 void Arguments::PropertyList_add(SystemProperty *element) {
4325   PropertyList_add(&amp;_system_properties, element);
4326 }
4327 
4328 // This add maintains unique property key in the list.
4329 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4330                                         PropertyAppendable append, PropertyWriteable writeable,
4331                                         PropertyInternal internal) {
4332   if (plist == NULL)
4333     return;
4334 
<span class="line-modified">4335   // If property key exist then update with new value.</span>

4336   SystemProperty* prop;
4337   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4338     if (strcmp(k, prop-&gt;key()) == 0) {
4339       if (append == AppendProperty) {
<span class="line-modified">4340         prop-&gt;append_value(v);</span>
4341       } else {
<span class="line-modified">4342         prop-&gt;set_value(v);</span>
4343       }
4344       return;
4345     }
4346   }
4347 
4348   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4349 }
4350 
4351 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4352 // Returns true if all of the source pointed by src has been copied over to
4353 // the destination buffer pointed by buf. Otherwise, returns false.
4354 // Notes:
4355 // 1. If the length (buflen) of the destination buffer excluding the
4356 // NULL terminator character is not long enough for holding the expanded
4357 // pid characters, it also returns false instead of returning the partially
4358 // expanded one.
4359 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4360 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4361                                 char* buf, size_t buflen) {
4362   const char* p = src;
</pre>
</td>
<td>
<hr />
<pre>
 543 
 544   // -------------- Obsolete Flags - sorted by expired_in --------------
 545   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 546   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 547   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 550   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 551   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 553   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 554   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 556   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 557   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 558 #ifndef X86
 559   { &quot;UseSSE&quot;,                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 560 #endif // !X86
 561   { &quot;UseAdaptiveGCBoundary&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 562   { &quot;MonitorBound&quot;,                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
<span class="line-added"> 563 #ifdef AARCH64</span>
<span class="line-added"> 564   { &quot;UseBarriersForVolatile&quot;,        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
<span class="line-added"> 565 #endif</span>
<span class="line-added"> 566   { &quot;UseLWPSynchronization&quot;,         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },</span>
 567 
 568 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 569   // These entries will generate build errors.  Their purpose is to test the macros.
 570   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 571   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 572   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 573   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 574   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 575   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 576   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 577 #endif
 578 
 579 #ifndef COMPILER2
 580   // These flags were generally available, but are C2 only, now.
 581   { &quot;MaxInlineLevel&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 582   { &quot;MaxRecursiveInlineLevel&quot;,      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 583   { &quot;InlineSmallCode&quot;,              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 584   { &quot;MaxInlineSize&quot;,                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 585   { &quot;FreqInlineSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 586   { &quot;MaxTrivialSize&quot;,               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 587 #endif
 588 
 589   { NULL, JDK_Version(0), JDK_Version(0) }
 590 };
 591 
 592 // Flags that are aliases for other flags.
 593 typedef struct {
 594   const char* alias_name;
 595   const char* real_name;
 596 } AliasedFlag;
 597 
 598 static AliasedFlag const aliased_jvm_flags[] = {
 599   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 600   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 601   { NULL, NULL}
 602 };
 603 
 604 // NOTE: A compatibility request will be necessary for each alias to be removed.
 605 static AliasedLoggingFlag const aliased_logging_flags[] = {

 606   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 607   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 608   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 609   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 610   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 611   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 612   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 613   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 614   { &quot;TraceInvokeDynamic&quot;,        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
 615   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 616   { &quot;TraceMethodHandles&quot;,        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
 617   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 618   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 619   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 620   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 621   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 622   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 623 };
 624 
 625 #ifndef PRODUCT
</pre>
<hr />
<pre>
2127                 TLABRefillWasteFraction);
2128     status = false;
2129   }
2130 
2131   if (PrintNMTStatistics) {
2132 #if INCLUDE_NMT
2133     if (MemTracker::tracking_level() == NMT_off) {
2134 #endif // INCLUDE_NMT
2135       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2136       PrintNMTStatistics = false;
2137 #if INCLUDE_NMT
2138     }
2139 #endif
2140   }
2141 
2142   status = CompilerConfig::check_args_consistency(status);
2143 #if INCLUDE_JVMCI
2144   if (status &amp;&amp; EnableJVMCI) {
2145     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2146         AddProperty, UnwriteableProperty, InternalProperty);
<span class="line-modified">2147     if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {</span>
2148       return false;
2149     }
2150   }
2151 #endif
2152 
2153 #ifndef SUPPORT_RESERVED_STACK_AREA
2154   if (StackReservedPages != 0) {
2155     FLAG_SET_CMDLINE(StackReservedPages, 0);
2156     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2157   }
2158 #endif
2159 
2160   status = status &amp;&amp; GCArguments::check_args_consistency();
2161 
2162   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {
2163     FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);
2164     warning(&quot;InlineTypePassFieldsAsArgs is not supported on this platform&quot;);
2165   }
2166 
2167   if (AMD64_ONLY(false &amp;&amp;) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {
</pre>
<hr />
<pre>
2201 
2202   // Check the sign first since atojulong() parses only unsigned values.
2203   bool value_is_positive = !(*value == &#39;-&#39;);
2204 
2205   if (value_is_positive) {
2206     julong n;
2207     bool good_return = atojulong(value, &amp;n);
2208     if (good_return) {
2209       bool above_minimum = n &gt;= min_size;
2210       bool value_is_too_large = n &gt; max_uintx;
2211 
2212       if (above_minimum &amp;&amp; !value_is_too_large) {
2213         *uintx_arg = n;
2214         return true;
2215       }
2216     }
2217   }
2218   return false;
2219 }
2220 
<span class="line-modified">2221 bool Arguments::create_module_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {</span>
<span class="line-added">2222   assert(is_internal_module_property(prop_name) ||</span>
<span class="line-added">2223          strcmp(prop_name, &quot;jdk.module.illegalAccess&quot;) == 0, &quot;unknown module property: &#39;%s&#39;&quot;, prop_name);</span>
2224   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2225   char* property = AllocateHeap(prop_len, mtArguments);
2226   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2227   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2228     FreeHeap(property);
2229     return false;
2230   }
<span class="line-modified">2231   // These are not strictly writeable properties as they cannot be set via -Dprop=val. But that</span>
<span class="line-added">2232   // is enforced by checking is_internal_module_property(). We need the property to be writeable so</span>
<span class="line-added">2233   // that multiple occurrences of the associated flag just causes the existing property value to be</span>
<span class="line-added">2234   // replaced (&quot;last option wins&quot;). Otherwise we would need to keep track of the flags and only convert</span>
<span class="line-added">2235   // to a property after we have finished flag processing.</span>
<span class="line-added">2236   bool added = add_property(property, WriteableProperty, internal);</span>
2237   FreeHeap(property);
2238   return added;
2239 }
2240 
<span class="line-modified">2241 bool Arguments::create_numbered_module_property(const char* prop_base_name, const char* prop_value, unsigned int count) {</span>
<span class="line-added">2242   assert(is_internal_module_property(prop_base_name), &quot;unknown module property: &#39;%s&#39;&quot;, prop_base_name);</span>
2243   const unsigned int props_count_limit = 1000;
2244   const int max_digits = 3;
2245   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2246 
2247   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2248   if (count &lt; props_count_limit) {
2249     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2250     char* property = AllocateHeap(prop_len, mtArguments);
2251     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2252     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2253       FreeHeap(property);
2254       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2255       return false;
2256     }
2257     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2258     FreeHeap(property);
2259     return added;
2260   }
2261 
2262   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
</pre>
<hr />
<pre>
2384 }
2385 
2386 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2387   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2388   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2389   // Find the equal sign between the module name and the path specification
2390   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2391   if (module_equal == NULL) {
2392     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2393     return JNI_ERR;
2394   } else {
2395     // Pick out the module name
2396     size_t module_len = module_equal - patch_mod_tail;
2397     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2398     if (module_name != NULL) {
2399       memcpy(module_name, patch_mod_tail, module_len);
2400       *(module_name + module_len) = &#39;\0&#39;;
2401       // The path piece begins one past the module_equal sign
2402       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2403       FREE_C_HEAP_ARRAY(char, module_name);
<span class="line-modified">2404       if (!create_numbered_module_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {</span>
2405         return JNI_ENOMEM;
2406       }
2407     } else {
2408       return JNI_ENOMEM;
2409     }
2410   }
2411   return JNI_OK;
2412 }
2413 
2414 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2415 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2416   // The min and max sizes match the values in globals.hpp, but scaled
2417   // with K. The values have been chosen so that alignment with page
2418   // size doesn&#39;t change the max value, which makes the conversions
2419   // back and forth between Xss value and ThreadStackSize value easier.
2420   // The values have also been chosen to fit inside a 32-bit signed type.
2421   const julong min_ThreadStackSize = 0;
2422   const julong max_ThreadStackSize = 1 * M;
2423 
2424   const julong min_size = min_ThreadStackSize * K;
</pre>
<hr />
<pre>
2529         const char* pos = strchr(tail, &#39;:&#39;);
2530         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2531         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2532         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2533 
2534         char *options = NULL;
2535         if(pos != NULL) {
2536           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2537           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2538         }
2539 #if !INCLUDE_JVMTI
2540         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2541           jio_fprintf(defaultStream::error_stream(),
2542             &quot;Debugging agents are not supported in this VM\n&quot;);
2543           return JNI_ERR;
2544         }
2545 #endif // !INCLUDE_JVMTI
2546         add_init_library(name, options);
2547       }
2548     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
<span class="line-modified">2549       if (!create_numbered_module_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {</span>
2550         return JNI_ENOMEM;
2551       }
2552     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
<span class="line-modified">2553       if (!create_numbered_module_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {</span>
2554         return JNI_ENOMEM;
2555       }
2556     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
<span class="line-modified">2557       if (!create_numbered_module_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {</span>
2558         return JNI_ENOMEM;
2559       }
2560     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
<span class="line-modified">2561       if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {</span>
2562         return JNI_ENOMEM;
2563       }
2564     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
<span class="line-modified">2565       if (!create_module_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {</span>
2566         return JNI_ENOMEM;
2567       }
2568     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
<span class="line-modified">2569       if (!create_module_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {</span>
2570         return JNI_ENOMEM;
2571       }
2572     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
<span class="line-modified">2573       if (!create_module_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {</span>
2574         return JNI_ENOMEM;
2575       }
2576     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2577       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2578       int res = process_patch_mod_option(tail, patch_mod_javabase);
2579       if (res != JNI_OK) {
2580         return res;
2581       }
2582     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
<span class="line-modified">2583       if (!create_module_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {</span>
2584         return JNI_ENOMEM;
2585       }
2586     // -agentlib and -agentpath
2587     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2588           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2589       if(tail != NULL) {
2590         const char* pos = strchr(tail, &#39;=&#39;);
2591         char* name;
2592         if (pos == NULL) {
2593           name = os::strdup_check_oom(tail, mtArguments);
2594         } else {
2595           size_t len = pos - tail;
2596           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2597           memcpy(name, tail, len);
2598           name[len] = &#39;\0&#39;;
2599         }
2600 
2601         char *options = NULL;
2602         if(pos != NULL) {
2603           options = os::strdup_check_oom(pos + 1, mtArguments);
</pre>
<hr />
<pre>
2607           jio_fprintf(defaultStream::error_stream(),
2608             &quot;Debugging agents are not supported in this VM\n&quot;);
2609           return JNI_ERR;
2610         }
2611 #endif // !INCLUDE_JVMTI
2612         add_init_agent(name, options, is_absolute_path);
2613       }
2614     // -javaagent
2615     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2616 #if !INCLUDE_JVMTI
2617       jio_fprintf(defaultStream::error_stream(),
2618         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2619       return JNI_ERR;
2620 #else
2621       if (tail != NULL) {
2622         size_t length = strlen(tail) + 1;
2623         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2624         jio_snprintf(options, length, &quot;%s&quot;, tail);
2625         add_instrument_agent(&quot;instrument&quot;, options, false);
2626         // java agents need module java.instrument
<span class="line-modified">2627         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {</span>
2628           return JNI_ENOMEM;
2629         }
2630       }
2631 #endif // !INCLUDE_JVMTI
2632     // --enable_preview
2633     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2634       set_enable_preview();
2635     // -Xnoclassgc
2636     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2637       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2638         return JNI_EINVAL;
2639       }
2640     // -Xbatch
2641     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2642       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2643         return JNI_EINVAL;
2644       }
2645     // -Xmn for compatibility with other JVM vendors
2646     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2647       julong long_initial_young_size = 0;
</pre>
<hr />
<pre>
2788           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2789         return JNI_EINVAL;
2790       }
2791       // Check for module related properties.  They must be set using the modules
2792       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2793       // &quot;-Djdk.module.addmods=java.sql&quot;
2794       if (is_internal_module_property(option-&gt;optionString + 2)) {
2795         needs_module_property_warning = true;
2796         continue;
2797       }
2798       if (!add_property(tail)) {
2799         return JNI_ENOMEM;
2800       }
2801       // Out of the box management support
2802       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2803 #if INCLUDE_MANAGEMENT
2804         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2805           return JNI_EINVAL;
2806         }
2807         // management agent in module jdk.management.agent
<span class="line-modified">2808         if (!create_numbered_module_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {</span>
2809           return JNI_ENOMEM;
2810         }
2811 #else
2812         jio_fprintf(defaultStream::output_stream(),
2813           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2814         return JNI_ERR;
2815 #endif
2816       }
2817     // -Xint
2818     } else if (match_option(option, &quot;-Xint&quot;)) {
2819           set_mode_flags(_int);
2820     // -Xmixed
2821     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2822           set_mode_flags(_mixed);
2823     // -Xcomp
2824     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2825       // for testing the compiler; turn off all flags that inhibit compilation
2826           set_mode_flags(_comp);
2827     // -Xshare:dump
2828     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
</pre>
<hr />
<pre>
3067 #if INCLUDE_JFR
3068     } else if (match_jfr_option(&amp;option)) {
3069       return JNI_EINVAL;
3070 #endif
3071     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
3072       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
3073       // already been handled
3074       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
3075           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
3076         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3077           return JNI_EINVAL;
3078         }
3079       }
3080     // Unknown option
3081     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3082       return JNI_ERR;
3083     }
3084   }
3085 
3086   if (EnableValhalla) {
<span class="line-modified">3087     // create_property(&quot;valhalla.enableValhalla&quot;, &quot;true&quot;, InternalProperty)</span>
<span class="line-added">3088     const char* prop_name = &quot;valhalla.enableValhalla&quot;;</span>
<span class="line-added">3089     const char* prop_value = &quot;true&quot;;</span>
<span class="line-added">3090     const size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;</span>
<span class="line-added">3091     char* property = AllocateHeap(prop_len, mtArguments);</span>
<span class="line-added">3092     int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);</span>
<span class="line-added">3093     if (ret &lt; 0 || ret &gt;= (int)prop_len) {</span>
<span class="line-added">3094       FreeHeap(property);</span>
<span class="line-added">3095       return JNI_ENOMEM;</span>
<span class="line-added">3096     }</span>
<span class="line-added">3097     bool added = add_property(property, UnwriteableProperty, InternalProperty);</span>
<span class="line-added">3098     FreeHeap(property);</span>
<span class="line-added">3099     if (!added) {</span>
3100       return JNI_ENOMEM;
3101     }
3102   }
3103 
3104   // PrintSharedArchiveAndExit will turn on
3105   //   -Xshare:on
3106   //   -Xlog:class+path=info
3107   if (PrintSharedArchiveAndExit) {
3108     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
3109       return JNI_EINVAL;
3110     }
3111     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
3112       return JNI_EINVAL;
3113     }
3114     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
3115   }
3116 
3117   fix_appclasspath();
3118 
3119   return JNI_OK;
</pre>
<hr />
<pre>
4338 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4339                                  bool writeable, bool internal) {
4340   if (plist == NULL)
4341     return;
4342 
4343   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4344   PropertyList_add(plist, new_p);
4345 }
4346 
4347 void Arguments::PropertyList_add(SystemProperty *element) {
4348   PropertyList_add(&amp;_system_properties, element);
4349 }
4350 
4351 // This add maintains unique property key in the list.
4352 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4353                                         PropertyAppendable append, PropertyWriteable writeable,
4354                                         PropertyInternal internal) {
4355   if (plist == NULL)
4356     return;
4357 
<span class="line-modified">4358   // If property key exists and is writeable, then update with new value.</span>
<span class="line-added">4359   // Trying to update a non-writeable property is silently ignored.</span>
4360   SystemProperty* prop;
4361   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4362     if (strcmp(k, prop-&gt;key()) == 0) {
4363       if (append == AppendProperty) {
<span class="line-modified">4364         prop-&gt;append_writeable_value(v);</span>
4365       } else {
<span class="line-modified">4366         prop-&gt;set_writeable_value(v);</span>
4367       }
4368       return;
4369     }
4370   }
4371 
4372   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4373 }
4374 
4375 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4376 // Returns true if all of the source pointed by src has been copied over to
4377 // the destination buffer pointed by buf. Otherwise, returns false.
4378 // Notes:
4379 // 1. If the length (buflen) of the destination buffer excluding the
4380 // NULL terminator character is not long enough for holding the expanded
4381 // pid characters, it also returns false instead of returning the partially
4382 // expanded one.
4383 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4384 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4385                                 char* buf, size_t buflen) {
4386   const char* p = src;
</pre>
</td>
</tr>
</table>
<center><a href="../prims/jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
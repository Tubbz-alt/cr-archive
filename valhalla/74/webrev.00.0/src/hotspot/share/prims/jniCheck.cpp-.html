<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/jniCheck.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logTag.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/guardedMemory.hpp&quot;
  35 #include &quot;oops/instanceKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/symbol.hpp&quot;
  38 #include &quot;prims/jniCheck.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  44 #include &quot;runtime/jniHandles.inline.hpp&quot;
  45 #include &quot;runtime/thread.inline.hpp&quot;
  46 
  47 // Complain every extra number of unplanned local refs
  48 #define CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD 32
  49 
  50 // Heap objects are allowed to be directly referenced only in VM code,
  51 // not in native code.
  52 
  53 #define ASSERT_OOPS_ALLOWED                                          \
  54     assert(JavaThread::current()-&gt;thread_state() == _thread_in_vm,   \
  55            &quot;jniCheck examining oops in bad state.&quot;)
  56 
  57 
  58 // Execute the given block of source code with the thread in VM state.
  59 // To do this, transition from the NATIVE state to the VM state, execute
  60 // the code, and transtition back.  The ThreadInVMfromNative constructor
  61 // performs the transition to VM state, its destructor restores the
  62 // NATIVE state.
  63 
  64 #define IN_VM(source_code)   {                                         \
  65     {                                                                  \
  66       ThreadInVMfromNative __tiv(thr);                                 \
  67       source_code                                                      \
  68     }                                                                  \
  69   }
  70 
  71 
  72 /*
  73  * DECLARATIONS
  74  */
  75 
  76 static struct JNINativeInterface_ * unchecked_jni_NativeInterface;
  77 
  78 
  79 /*
  80  * MACRO DEFINITIONS
  81  */
  82 
  83 // All JNI checked functions here use JNI_ENTRY_CHECKED() instead of the
  84 // QUICK_ENTRY or LEAF variants found in jni.cpp.  This allows handles
  85 // to be created if a fatal error should occur.
  86 
  87 // Check for thread not attached to VM;  need to catch this before
  88 // assertions in the wrapper routines might fire
  89 
  90 // Check for env being the one value appropriate for this thread.
  91 
  92 #define JNI_ENTRY_CHECKED(result_type, header)                           \
  93 extern &quot;C&quot; {                                                             \
  94   result_type JNICALL header {                                           \
  95     JavaThread* thr = (JavaThread*) Thread::current_or_null();           \
  96     if (thr == NULL || !thr-&gt;is_Java_thread()) {                         \
  97       tty-&gt;print_cr(&quot;%s&quot;, fatal_using_jnienv_in_nonjava);                \
  98       os::abort(true);                                                   \
  99     }                                                                    \
 100     JNIEnv* xenv = thr-&gt;jni_environment();                               \
 101     if (env != xenv) {                                                   \
 102       NativeReportJNIFatalError(thr, warn_wrong_jnienv);                 \
 103     }                                                                    \
 104     VM_ENTRY_BASE(result_type, header, thr)
 105 
 106 
 107 #define UNCHECKED() (unchecked_jni_NativeInterface)
 108 
 109 static const char * warn_wrong_jnienv = &quot;Using JNIEnv in the wrong thread&quot;;
 110 static const char * warn_bad_class_descriptor1 = &quot;JNI FindClass received a bad class descriptor \&quot;&quot;;
 111 static const char * warn_bad_class_descriptor2 = &quot;\&quot;.  A correct class descriptor &quot; \
 112   &quot;has no leading \&quot;L\&quot; or trailing \&quot;;\&quot;.  Incorrect descriptors will not be accepted in future releases.&quot;;
 113 static const char * fatal_using_jnienv_in_nonjava = &quot;FATAL ERROR in native method: Using JNIEnv in non-Java thread&quot;;
 114 static const char * warn_other_function_in_critical = &quot;Warning: Calling other JNI functions in the scope of &quot; \
 115   &quot;Get/ReleasePrimitiveArrayCritical or Get/ReleaseStringCritical&quot;;
 116 static const char * fatal_bad_ref_to_jni = &quot;Bad global or local ref passed to JNI&quot;;
 117 static const char * fatal_received_null_class = &quot;JNI received a null class&quot;;
 118 static const char * fatal_class_not_a_class = &quot;JNI received a class argument that is not a class&quot;;
 119 static const char * fatal_class_not_a_throwable_class = &quot;JNI Throw or ThrowNew received a class argument that is not a Throwable or Throwable subclass&quot;;
 120 static const char * fatal_wrong_class_or_method = &quot;Wrong object class or methodID passed to JNI call&quot;;
 121 static const char * fatal_non_weak_method = &quot;non-weak methodID passed to JNI call&quot;;
 122 static const char * fatal_unknown_array_object = &quot;Unknown array object passed to JNI array operations&quot;;
 123 static const char * fatal_object_array_expected = &quot;Object array expected but not received for JNI array operation&quot;;
 124 static const char * fatal_prim_type_array_expected = &quot;Primitive type array expected but not received for JNI array operation&quot;;
 125 static const char * fatal_non_array  = &quot;Non-array passed to JNI array operations&quot;;
 126 static const char * fatal_element_type_mismatch = &quot;Array element type mismatch in JNI&quot;;
 127 static const char * fatal_should_be_static = &quot;Non-static field ID passed to JNI&quot;;
 128 static const char * fatal_wrong_static_field = &quot;Wrong static field ID passed to JNI&quot;;
 129 static const char * fatal_static_field_not_found = &quot;Static field not found in JNI get/set field operations&quot;;
 130 static const char * fatal_static_field_mismatch = &quot;Field type (static) mismatch in JNI get/set field operations&quot;;
 131 static const char * fatal_should_be_nonstatic = &quot;Static field ID passed to JNI&quot;;
 132 static const char * fatal_null_object = &quot;Null object passed to JNI&quot;;
 133 static const char * fatal_wrong_field = &quot;Wrong field ID passed to JNI&quot;;
 134 static const char * fatal_instance_field_not_found = &quot;Instance field not found in JNI get/set field operations&quot;;
 135 static const char * fatal_instance_field_mismatch = &quot;Field type (instance) mismatch in JNI get/set field operations&quot;;
 136 static const char * fatal_non_string = &quot;JNI string operation received a non-string&quot;;
 137 
 138 
 139 // When in VM state:
 140 static void ReportJNIWarning(JavaThread* thr, const char *msg) {
 141   tty-&gt;print_cr(&quot;WARNING in native method: %s&quot;, msg);
 142   thr-&gt;print_stack();
 143 }
 144 
 145 // When in NATIVE state:
 146 static void NativeReportJNIFatalError(JavaThread* thr, const char *msg) {
 147   IN_VM(
 148     ReportJNIFatalError(thr, msg);
 149   )
 150 }
 151 
 152 static void NativeReportJNIWarning(JavaThread* thr, const char *msg) {
 153   IN_VM(
 154     ReportJNIWarning(thr, msg);
 155   )
 156 }
 157 
 158 
 159 
 160 
 161 /*
 162  * SUPPORT FUNCTIONS
 163  */
 164 
 165 /**
 166  * Check whether or not a programmer has actually checked for exceptions. According
 167  * to the JNI Specification (&quot;jni/spec/design.html#java_exceptions&quot;):
 168  *
 169  * There are two cases where the programmer needs to check for exceptions without
 170  * being able to first check an error code:
 171  *
 172  * - The JNI functions that invoke a Java method return the result of the Java method.
 173  * The programmer must call ExceptionOccurred() to check for possible exceptions
 174  * that occurred during the execution of the Java method.
 175  *
 176  * - Some of the JNI array access functions do not return an error code, but may
 177  * throw an ArrayIndexOutOfBoundsException or ArrayStoreException.
 178  *
 179  * In all other cases, a non-error return value guarantees that no exceptions have been thrown.
 180  *
 181  * Programmers often defend against ArrayIndexOutOfBoundsException, so warning
 182  * for these functions would be pedantic.
 183  */
 184 static inline void
 185 check_pending_exception(JavaThread* thr) {
 186   if (thr-&gt;has_pending_exception()) {
 187     NativeReportJNIWarning(thr, &quot;JNI call made with exception pending&quot;);
 188   }
 189   if (thr-&gt;is_pending_jni_exception_check()) {
 190     IN_VM(
 191       tty-&gt;print_cr(&quot;WARNING in native method: JNI call made without checking exceptions when required to from %s&quot;,
 192         thr-&gt;get_pending_jni_exception_check());
 193       thr-&gt;print_stack();
 194     )
 195     thr-&gt;clear_pending_jni_exception_check(); // Just complain once
 196   }
 197 }
 198 
 199 /**
 200  * Add to the planned number of handles. I.e. plus current live &amp; warning threshold
 201  */
 202 static inline void
 203 add_planned_handle_capacity(JNIHandleBlock* handles, size_t capacity) {
 204   handles-&gt;set_planned_capacity(capacity +
 205                                 handles-&gt;get_number_of_live_handles() +
 206                                 CHECK_JNI_LOCAL_REF_CAP_WARN_THRESHOLD);
 207 }
 208 
 209 
 210 static inline void
 211 functionEnterCritical(JavaThread* thr)
 212 {
 213   check_pending_exception(thr);
 214 }
 215 
 216 static inline void
 217 functionEnterCriticalExceptionAllowed(JavaThread* thr)
 218 {
 219 }
 220 
 221 static inline void
 222 functionEnter(JavaThread* thr)
 223 {
 224   if (thr-&gt;in_critical()) {
 225     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 226   }
 227   check_pending_exception(thr);
 228 }
 229 
 230 static inline void
 231 functionEnterExceptionAllowed(JavaThread* thr)
 232 {
 233   if (thr-&gt;in_critical()) {
 234     tty-&gt;print_cr(&quot;%s&quot;, warn_other_function_in_critical);
 235   }
 236 }
 237 
 238 static inline void
 239 functionExit(JavaThread* thr)
 240 {
 241   JNIHandleBlock* handles = thr-&gt;active_handles();
 242   size_t planned_capacity = handles-&gt;get_planned_capacity();
 243   size_t live_handles = handles-&gt;get_number_of_live_handles();
 244   if (live_handles &gt; planned_capacity) {
 245     IN_VM(
 246       tty-&gt;print_cr(&quot;WARNING: JNI local refs: &quot; SIZE_FORMAT &quot;, exceeds capacity: &quot; SIZE_FORMAT,
 247                     live_handles, planned_capacity);
 248       thr-&gt;print_stack();
 249     )
 250     // Complain just the once, reset to current + warn threshold
 251     add_planned_handle_capacity(handles, 0);
 252   }
 253 }
 254 
 255 static inline void
 256 checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)
 257 {
 258   fieldDescriptor fd;
 259 
 260   /* make sure it is a static field */
 261   if (!jfieldIDWorkaround::is_static_jfieldID(fid))
 262     ReportJNIFatalError(thr, fatal_should_be_static);
 263 
 264   /* validate the class being passed */
 265   ASSERT_OOPS_ALLOWED;
 266   Klass* k_oop = jniCheck::validate_class(thr, cls, false);
 267 
 268   /* check for proper subclass hierarchy */
 269   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fid);
 270   Klass* f_oop = id-&gt;holder();
 271   if (!k_oop-&gt;is_subtype_of(f_oop))
 272     ReportJNIFatalError(thr, fatal_wrong_static_field);
 273 
 274   /* check for proper field type */
 275   if (!id-&gt;find_local_field(&amp;fd))
 276     ReportJNIFatalError(thr, fatal_static_field_not_found);
 277   if ((fd.field_type() != ftype) &amp;&amp;
 278       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT) &amp;&amp;
 279       !(fd.field_type() == T_VALUETYPE &amp;&amp; ftype == T_OBJECT)) {
 280     ReportJNIFatalError(thr, fatal_static_field_mismatch);
 281   }
 282 }
 283 
 284 static inline void
 285 checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)
 286 {
 287   fieldDescriptor fd;
 288 
 289   /* make sure it is an instance field */
 290   if (jfieldIDWorkaround::is_static_jfieldID(fid))
 291     ReportJNIFatalError(thr, fatal_should_be_nonstatic);
 292 
 293   /* validate the object being passed and then get its class */
 294   ASSERT_OOPS_ALLOWED;
 295   oop oopObj = jniCheck::validate_object(thr, obj);
 296   if (oopObj == NULL) {
 297     ReportJNIFatalError(thr, fatal_null_object);
 298   }
 299   Klass* k_oop = oopObj-&gt;klass();
 300 
 301   if (!jfieldIDWorkaround::is_valid_jfieldID(k_oop, fid)) {
 302     ReportJNIFatalError(thr, fatal_wrong_field);
 303   }
 304 
 305   /* make sure the field exists */
 306   int offset = jfieldIDWorkaround::from_instance_jfieldID(k_oop, fid);
 307   if (!InstanceKlass::cast(k_oop)-&gt;contains_field_offset(offset))
 308     ReportJNIFatalError(thr, fatal_wrong_field);
 309 
 310   /* check for proper field type */
 311   if (!InstanceKlass::cast(k_oop)-&gt;find_field_from_offset(offset,
 312                                                               false, &amp;fd))
 313     ReportJNIFatalError(thr, fatal_instance_field_not_found);
 314 
 315   if ((fd.field_type() != ftype) &amp;&amp;
 316       !(fd.field_type() == T_ARRAY &amp;&amp; ftype == T_OBJECT) &amp;&amp;
 317       !(fd.field_type() == T_VALUETYPE &amp;&amp; ftype == T_OBJECT)) {
 318     ReportJNIFatalError(thr, fatal_instance_field_mismatch);
 319   }
 320 }
 321 
 322 static inline void
 323 checkString(JavaThread* thr, jstring js)
 324 {
 325   ASSERT_OOPS_ALLOWED;
 326   oop s = jniCheck::validate_object(thr, js);
 327   if ((s == NULL) || !java_lang_String::is_instance(s))
 328     ReportJNIFatalError(thr, fatal_non_string);
 329 }
 330 
 331 static inline arrayOop
 332 check_is_array(JavaThread* thr, jarray jArray)
 333 {
 334   ASSERT_OOPS_ALLOWED;
 335   arrayOop aOop;
 336 
 337   aOop = (arrayOop)jniCheck::validate_object(thr, jArray);
 338   if (aOop == NULL || !aOop-&gt;is_array()) {
 339     ReportJNIFatalError(thr, fatal_non_array);
 340   }
 341   return aOop;
 342 }
 343 
 344 static inline arrayOop
 345 check_is_primitive_array(JavaThread* thr, jarray jArray) {
 346   arrayOop aOop = check_is_array(thr, jArray);
 347 
 348   if (!aOop-&gt;is_typeArray()) {
 349      ReportJNIFatalError(thr, fatal_prim_type_array_expected);
 350   }
 351   return aOop;
 352 }
 353 
 354 static inline void
 355 check_primitive_array_type(JavaThread* thr, jarray jArray, BasicType elementType)
 356 {
 357   BasicType array_type;
 358   arrayOop aOop;
 359 
 360   aOop = check_is_primitive_array(thr, jArray);
 361   array_type = TypeArrayKlass::cast(aOop-&gt;klass())-&gt;element_type();
 362   if (array_type != elementType) {
 363     ReportJNIFatalError(thr, fatal_element_type_mismatch);
 364   }
 365 }
 366 
 367 static inline void
 368 check_is_obj_array(JavaThread* thr, jarray jArray) {
 369   arrayOop aOop = check_is_array(thr, jArray);
 370   if (!aOop-&gt;is_objArray()) {
 371     ReportJNIFatalError(thr, fatal_object_array_expected);
 372   }
 373 }
 374 
 375 /*
 376  * Copy and wrap array elements for bounds checking.
 377  * Remember the original elements (GuardedMemory::get_tag())
 378  */
 379 static void* check_jni_wrap_copy_array(JavaThread* thr, jarray array,
 380     void* orig_elements) {
 381   void* result;
 382   IN_VM(
 383     oop a = JNIHandles::resolve_non_null(array);
 384     size_t len = arrayOop(a)-&gt;length() &lt;&lt;
 385         TypeArrayKlass::cast(a-&gt;klass())-&gt;log2_element_size();
 386     result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);
 387   )
 388   return result;
 389 }
 390 
 391 static void* check_wrapped_array(JavaThread* thr, const char* fn_name,
 392     void* obj, void* carray, size_t* rsz) {
 393   if (carray == NULL) {
 394     tty-&gt;print_cr(&quot;%s: elements vector NULL&quot; PTR_FORMAT, fn_name, p2i(obj));
 395     NativeReportJNIFatalError(thr, &quot;Elements vector NULL&quot;);
 396   }
 397   GuardedMemory guarded(carray);
 398   void* orig_result = guarded.get_tag();
 399   if (!guarded.verify_guards()) {
 400     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: release array failed bounds &quot;
 401         &quot;check, incorrect pointer returned ? array: &quot; PTR_FORMAT &quot; carray: &quot;
 402         PTR_FORMAT, p2i(obj), p2i(carray));
 403     guarded.print_on(tty);
 404     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 405         &quot;failed bounds check&quot;);
 406   }
 407   if (orig_result == NULL) {
 408     tty-&gt;print_cr(&quot;ReleasePrimitiveArrayCritical: unrecognized elements. array: &quot;
 409         PTR_FORMAT &quot; carray: &quot; PTR_FORMAT, p2i(obj), p2i(carray));
 410     guarded.print_on(tty);
 411     NativeReportJNIFatalError(thr, &quot;ReleasePrimitiveArrayCritical: &quot;
 412         &quot;unrecognized elements&quot;);
 413   }
 414   if (rsz != NULL) {
 415     *rsz = guarded.get_user_size();
 416   }
 417   return orig_result;
 418 }
 419 
 420 static void* check_wrapped_array_release(JavaThread* thr, const char* fn_name,
 421     void* obj, void* carray, jint mode) {
 422   size_t sz;
 423   void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &amp;sz);
 424   switch (mode) {
 425   // As we never make copies, mode 0 and JNI_COMMIT are the same.
 426   case 0:
 427   case JNI_COMMIT:
 428     memcpy(orig_result, carray, sz);
 429     break;
 430   case JNI_ABORT:
 431     break;
 432   default:
 433     tty-&gt;print_cr(&quot;%s: Unrecognized mode %i releasing array &quot;
 434         PTR_FORMAT &quot; elements &quot; PTR_FORMAT, fn_name, mode, p2i(obj), p2i(carray));
 435     NativeReportJNIFatalError(thr, &quot;Unrecognized array release mode&quot;);
 436   }
 437   // We always need to release the copy we made with GuardedMemory
 438   GuardedMemory::free_copy(carray);
 439   return orig_result;
 440 }
 441 
 442 oop jniCheck::validate_handle(JavaThread* thr, jobject obj) {
 443   if ((obj != NULL) &amp;&amp; (JNIHandles::handle_type(thr, obj) != JNIInvalidRefType)) {
 444     ASSERT_OOPS_ALLOWED;
 445     return JNIHandles::resolve_external_guard(obj);
 446   }
 447   ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 448   return NULL;
 449 }
 450 
 451 
 452 Method* jniCheck::validate_jmethod_id(JavaThread* thr, jmethodID method_id) {
 453   ASSERT_OOPS_ALLOWED;
 454   // do the fast jmethodID check first
 455   Method* m = Method::checked_resolve_jmethod_id(method_id);
 456   if (m == NULL) {
 457     ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 458   }
 459   // jmethodIDs are handles in the class loader data,
 460   // but that can be expensive so check it last
 461   else if (!Method::is_method_id(method_id)) {
 462     ReportJNIFatalError(thr, fatal_non_weak_method);
 463   }
 464   return m;
 465 }
 466 
 467 
 468 oop jniCheck::validate_object(JavaThread* thr, jobject obj) {
 469   if (obj == NULL) return NULL;
 470   ASSERT_OOPS_ALLOWED;
 471   oop oopObj = jniCheck::validate_handle(thr, obj);
 472   if (oopObj == NULL) {
 473     ReportJNIFatalError(thr, fatal_bad_ref_to_jni);
 474   }
 475   return oopObj;
 476 }
 477 
 478 // Warn if a class descriptor is in decorated form; class descriptors
 479 // passed to JNI findClass should not be decorated unless they are
 480 // array descriptors.
 481 void jniCheck::validate_class_descriptor(JavaThread* thr, const char* name) {
 482   if (name == NULL) return;  // implementation accepts NULL so just return
 483 
 484   size_t len = strlen(name);
 485 
 486   if (len &gt;= 2 &amp;&amp;
 487       name[0] == JVM_SIGNATURE_CLASS &amp;&amp;            // &#39;L&#39;
 488       name[len-1] == JVM_SIGNATURE_ENDCLASS ) {    // &#39;;&#39;
 489     char msg[JVM_MAXPATHLEN];
 490     jio_snprintf(msg, JVM_MAXPATHLEN, &quot;%s%s%s&quot;,
 491                  warn_bad_class_descriptor1, name, warn_bad_class_descriptor2);
 492     ReportJNIWarning(thr, msg);
 493   }
 494 }
 495 
 496 Klass* jniCheck::validate_class(JavaThread* thr, jclass clazz, bool allow_primitive) {
 497   ASSERT_OOPS_ALLOWED;
 498   oop mirror = jniCheck::validate_handle(thr, clazz);
 499   if (mirror == NULL) {
 500     ReportJNIFatalError(thr, fatal_received_null_class);
 501   }
 502 
 503   if (mirror-&gt;klass() != SystemDictionary::Class_klass()) {
 504     ReportJNIFatalError(thr, fatal_class_not_a_class);
 505   }
 506 
 507   Klass* k = java_lang_Class::as_Klass(mirror);
 508   // Make allowances for primitive classes ...
 509   if (!(k != NULL || (allow_primitive &amp;&amp; java_lang_Class::is_primitive(mirror)))) {
 510     ReportJNIFatalError(thr, fatal_class_not_a_class);
 511   }
 512   return k;
 513 }
 514 
 515 void jniCheck::validate_throwable_klass(JavaThread* thr, Klass* klass) {
 516   ASSERT_OOPS_ALLOWED;
 517   assert(klass != NULL, &quot;klass argument must have a value&quot;);
 518 
 519   if (!klass-&gt;is_instance_klass() ||
 520       !klass-&gt;is_subclass_of(SystemDictionary::Throwable_klass())) {
 521     ReportJNIFatalError(thr, fatal_class_not_a_throwable_class);
 522   }
 523 }
 524 
 525 void jniCheck::validate_call(JavaThread* thr, jclass clazz, jmethodID method_id, jobject obj) {
 526   ASSERT_OOPS_ALLOWED;
 527   Method* m = jniCheck::validate_jmethod_id(thr, method_id);
 528   InstanceKlass* holder = m-&gt;method_holder();
 529 
 530   if (clazz != NULL) {
 531     Klass* k = jniCheck::validate_class(thr, clazz, false);
 532     // Check that method is in the class, must be InstanceKlass
 533     if (!InstanceKlass::cast(k)-&gt;is_subtype_of(holder)) {
 534       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 535     }
 536   }
 537 
 538   if (obj != NULL) {
 539     oop recv = jniCheck::validate_object(thr, obj);
 540     assert(recv != NULL, &quot;validate_object checks that&quot;);
 541     Klass* rk = recv-&gt;klass();
 542 
 543     // Check that the object is a subtype of method holder too.
 544     if (!rk-&gt;is_subtype_of(holder)) {
 545       ReportJNIFatalError(thr, fatal_wrong_class_or_method);
 546     }
 547   }
 548 }
 549 
 550 
 551 /*
 552  * IMPLEMENTATION OF FUNCTIONS IN CHECKED TABLE
 553  */
 554 
 555 JNI_ENTRY_CHECKED(jclass,
 556   checked_jni_DefineClass(JNIEnv *env,
 557                           const char *name,
 558                           jobject loader,
 559                           const jbyte *buf,
 560                           jsize len))
 561     functionEnter(thr);
 562     IN_VM(
 563       jniCheck::validate_object(thr, loader);
 564     )
 565     jclass result = UNCHECKED()-&gt;DefineClass(env, name, loader, buf, len);
 566     functionExit(thr);
 567     return result;
 568 JNI_END
 569 
 570 JNI_ENTRY_CHECKED(jclass,
 571   checked_jni_FindClass(JNIEnv *env,
 572                         const char *name))
 573     functionEnter(thr);
 574     IN_VM(
 575       jniCheck::validate_class_descriptor(thr, name);
 576     )
 577     jclass result = UNCHECKED()-&gt;FindClass(env, name);
 578     functionExit(thr);
 579     return result;
 580 JNI_END
 581 
 582 JNI_ENTRY_CHECKED(jmethodID,
 583   checked_jni_FromReflectedMethod(JNIEnv *env,
 584                                   jobject method))
 585     functionEnter(thr);
 586     IN_VM(
 587       jniCheck::validate_object(thr, method);
 588     )
 589     jmethodID result = UNCHECKED()-&gt;FromReflectedMethod(env, method);
 590     functionExit(thr);
 591     return result;
 592 JNI_END
 593 
 594 JNI_ENTRY_CHECKED(jfieldID,
 595   checked_jni_FromReflectedField(JNIEnv *env,
 596                                  jobject field))
 597     functionEnter(thr);
 598     IN_VM(
 599       jniCheck::validate_object(thr, field);
 600     )
 601     jfieldID result = UNCHECKED()-&gt;FromReflectedField(env, field);
 602     functionExit(thr);
 603     return result;
 604 JNI_END
 605 
 606 JNI_ENTRY_CHECKED(jobject,
 607   checked_jni_ToReflectedMethod(JNIEnv *env,
 608                                 jclass cls,
 609                                 jmethodID methodID,
 610                                 jboolean isStatic))
 611     functionEnter(thr);
 612     IN_VM(
 613       jniCheck::validate_call(thr, cls, methodID);
 614     )
 615     jobject result = UNCHECKED()-&gt;ToReflectedMethod(env, cls, methodID,
 616                                                     isStatic);
 617     functionExit(thr);
 618     return result;
 619 JNI_END
 620 
 621 JNI_ENTRY_CHECKED(jclass,
 622   checked_jni_GetSuperclass(JNIEnv *env,
 623                             jclass sub))
 624     functionEnter(thr);
 625     IN_VM(
 626       jniCheck::validate_class(thr, sub, true);
 627     )
 628     jclass result = UNCHECKED()-&gt;GetSuperclass(env, sub);
 629     functionExit(thr);
 630     return result;
 631 JNI_END
 632 
 633 JNI_ENTRY_CHECKED(jboolean,
 634   checked_jni_IsAssignableFrom(JNIEnv *env,
 635                                jclass sub,
 636                                jclass sup))
 637     functionEnter(thr);
 638     IN_VM(
 639       jniCheck::validate_class(thr, sub, true);
 640       jniCheck::validate_class(thr, sup, true);
 641     )
 642     jboolean result = UNCHECKED()-&gt;IsAssignableFrom(env, sub, sup);
 643     functionExit(thr);
 644     return result;
 645 JNI_END
 646 
 647 JNI_ENTRY_CHECKED(jobject,
 648   checked_jni_ToReflectedField(JNIEnv *env,
 649                                jclass cls,
 650                                jfieldID fieldID,
 651                                jboolean isStatic))
 652     functionEnter(thr);
 653     IN_VM(
 654       jniCheck::validate_class(thr, cls, false);
 655     )
 656     jobject result = UNCHECKED()-&gt;ToReflectedField(env, cls, fieldID,
 657                                                    isStatic);
 658     functionExit(thr);
 659     return result;
 660 JNI_END
 661 
 662 JNI_ENTRY_CHECKED(jint,
 663   checked_jni_Throw(JNIEnv *env,
 664                     jthrowable obj))
 665     functionEnter(thr);
 666     IN_VM(
 667       oop oopObj = jniCheck::validate_object(thr, obj);
 668       if (oopObj == NULL) {
 669         // Unchecked Throw tolerates a NULL obj, so just warn
 670         ReportJNIWarning(thr, &quot;JNI Throw called with NULL throwable&quot;);
 671       } else {
 672         jniCheck::validate_throwable_klass(thr, oopObj-&gt;klass());
 673       }
 674     )
 675     jint result = UNCHECKED()-&gt;Throw(env, obj);
 676     functionExit(thr);
 677     return result;
 678 JNI_END
 679 
 680 JNI_ENTRY_CHECKED(jint,
 681   checked_jni_ThrowNew(JNIEnv *env,
 682                        jclass clazz,
 683                        const char *msg))
 684     functionEnter(thr);
 685     IN_VM(
 686       Klass* k = jniCheck::validate_class(thr, clazz, false);
 687       assert(k != NULL, &quot;validate_class shouldn&#39;t return NULL Klass*&quot;);
 688       jniCheck::validate_throwable_klass(thr, k);
 689     )
 690     jint result = UNCHECKED()-&gt;ThrowNew(env, clazz, msg);
 691     functionExit(thr);
 692     return result;
 693 JNI_END
 694 
 695 JNI_ENTRY_CHECKED(jthrowable,
 696   checked_jni_ExceptionOccurred(JNIEnv *env))
 697     thr-&gt;clear_pending_jni_exception_check();
 698     functionEnterExceptionAllowed(thr);
 699     jthrowable result = UNCHECKED()-&gt;ExceptionOccurred(env);
 700     functionExit(thr);
 701     return result;
 702 JNI_END
 703 
 704 JNI_ENTRY_CHECKED(void,
 705   checked_jni_ExceptionDescribe(JNIEnv *env))
 706     functionEnterExceptionAllowed(thr);
 707     UNCHECKED()-&gt;ExceptionDescribe(env);
 708     functionExit(thr);
 709 JNI_END
 710 
 711 JNI_ENTRY_CHECKED(void,
 712   checked_jni_ExceptionClear(JNIEnv *env))
 713     thr-&gt;clear_pending_jni_exception_check();
 714     functionEnterExceptionAllowed(thr);
 715     UNCHECKED()-&gt;ExceptionClear(env);
 716     functionExit(thr);
 717 JNI_END
 718 
 719 JNI_ENTRY_CHECKED(void,
 720   checked_jni_FatalError(JNIEnv *env,
 721                          const char *msg))
 722     thr-&gt;clear_pending_jni_exception_check();
 723     functionEnter(thr);
 724     UNCHECKED()-&gt;FatalError(env, msg);
 725     functionExit(thr);
 726 JNI_END
 727 
 728 JNI_ENTRY_CHECKED(jint,
 729   checked_jni_PushLocalFrame(JNIEnv *env,
 730                              jint capacity))
 731     functionEnterExceptionAllowed(thr);
 732     if (capacity &lt; 0)
 733       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 734     jint result = UNCHECKED()-&gt;PushLocalFrame(env, capacity);
 735     if (result == JNI_OK) {
 736       add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 737     }
 738     functionExit(thr);
 739     return result;
 740 JNI_END
 741 
 742 JNI_ENTRY_CHECKED(jobject,
 743   checked_jni_PopLocalFrame(JNIEnv *env,
 744                             jobject result))
 745     functionEnterExceptionAllowed(thr);
 746     jobject res = UNCHECKED()-&gt;PopLocalFrame(env, result);
 747     functionExit(thr);
 748     return res;
 749 JNI_END
 750 
 751 JNI_ENTRY_CHECKED(jobject,
 752   checked_jni_NewGlobalRef(JNIEnv *env,
 753                            jobject lobj))
 754     functionEnter(thr);
 755     IN_VM(
 756       if (lobj != NULL) {
 757         jniCheck::validate_handle(thr, lobj);
 758       }
 759     )
 760     jobject result = UNCHECKED()-&gt;NewGlobalRef(env,lobj);
 761     functionExit(thr);
 762     return result;
 763 JNI_END
 764 
 765 JNI_ENTRY_CHECKED(void,
 766   checked_jni_DeleteGlobalRef(JNIEnv *env,
 767                               jobject gref))
 768     functionEnterExceptionAllowed(thr);
 769     IN_VM(
 770       jniCheck::validate_object(thr, gref);
 771       if (gref &amp;&amp; !JNIHandles::is_global_handle(gref)) {
 772         ReportJNIFatalError(thr,
 773             &quot;Invalid global JNI handle passed to DeleteGlobalRef&quot;);
 774       }
 775     )
 776     UNCHECKED()-&gt;DeleteGlobalRef(env,gref);
 777     functionExit(thr);
 778 JNI_END
 779 
 780 JNI_ENTRY_CHECKED(void,
 781   checked_jni_DeleteLocalRef(JNIEnv *env,
 782                              jobject obj))
 783     functionEnterExceptionAllowed(thr);
 784     IN_VM(
 785       jniCheck::validate_object(thr, obj);
 786       if (obj &amp;&amp; !(JNIHandles::is_local_handle(thr, obj) ||
 787                    JNIHandles::is_frame_handle(thr, obj)))
 788         ReportJNIFatalError(thr,
 789             &quot;Invalid local JNI handle passed to DeleteLocalRef&quot;);
 790     )
 791     UNCHECKED()-&gt;DeleteLocalRef(env, obj);
 792     functionExit(thr);
 793 JNI_END
 794 
 795 JNI_ENTRY_CHECKED(jboolean,
 796   checked_jni_IsSameObject(JNIEnv *env,
 797                            jobject obj1,
 798                            jobject obj2))
 799     functionEnterExceptionAllowed(thr);
 800     IN_VM(
 801       /* This JNI function can be used to compare weak global references
 802        * to NULL objects. If the handles are valid, but contain NULL,
 803        * then don&#39;t attempt to validate the object.
 804        */
 805       if (obj1 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj1) != NULL) {
 806         jniCheck::validate_object(thr, obj1);
 807       }
 808       if (obj2 != NULL &amp;&amp; jniCheck::validate_handle(thr, obj2) != NULL) {
 809         jniCheck::validate_object(thr, obj2);
 810       }
 811     )
 812     jboolean result = UNCHECKED()-&gt;IsSameObject(env,obj1,obj2);
 813     functionExit(thr);
 814     return result;
 815 JNI_END
 816 
 817 JNI_ENTRY_CHECKED(jobject,
 818   checked_jni_NewLocalRef(JNIEnv *env,
 819                           jobject ref))
 820     functionEnter(thr);
 821     IN_VM(
 822       if (ref != NULL) {
 823         jniCheck::validate_handle(thr, ref);
 824       }
 825     )
 826     jobject result = UNCHECKED()-&gt;NewLocalRef(env, ref);
 827     functionExit(thr);
 828     return result;
 829 JNI_END
 830 
 831 JNI_ENTRY_CHECKED(jint,
 832   checked_jni_EnsureLocalCapacity(JNIEnv *env,
 833                                   jint capacity))
 834     functionEnter(thr);
 835     if (capacity &lt; 0) {
 836       NativeReportJNIFatalError(thr, &quot;negative capacity&quot;);
 837     }
 838     jint result = UNCHECKED()-&gt;EnsureLocalCapacity(env, capacity);
 839     if (result == JNI_OK) {
 840       // increase local ref capacity if needed
 841       if ((size_t)capacity &gt; thr-&gt;active_handles()-&gt;get_planned_capacity()) {
 842         add_planned_handle_capacity(thr-&gt;active_handles(), capacity);
 843       }
 844     }
 845     functionExit(thr);
 846     return result;
 847 JNI_END
 848 
 849 JNI_ENTRY_CHECKED(jobject,
 850   checked_jni_AllocObject(JNIEnv *env,
 851                           jclass clazz))
 852     functionEnter(thr);
 853     IN_VM(
 854       jniCheck::validate_class(thr, clazz, false);
 855     )
 856     jobject result = UNCHECKED()-&gt;AllocObject(env,clazz);
 857     functionExit(thr);
 858     return result;
 859 JNI_END
 860 
 861 JNI_ENTRY_CHECKED(jobject,
 862   checked_jni_NewObject(JNIEnv *env,
 863                         jclass clazz,
 864                         jmethodID methodID,
 865                         ...))
 866     functionEnter(thr);
 867     va_list args;
 868     IN_VM(
 869       jniCheck::validate_call(thr, clazz, methodID);
 870     )
 871     va_start(args, methodID);
 872     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 873     va_end(args);
 874     functionExit(thr);
 875     return result;
 876 JNI_END
 877 
 878 JNI_ENTRY_CHECKED(jobject,
 879   checked_jni_NewObjectV(JNIEnv *env,
 880                          jclass clazz,
 881                          jmethodID methodID,
 882                          va_list args))
 883     functionEnter(thr);
 884     IN_VM(
 885       jniCheck::validate_call(thr, clazz, methodID);
 886     )
 887     jobject result = UNCHECKED()-&gt;NewObjectV(env,clazz,methodID,args);
 888     functionExit(thr);
 889     return result;
 890 JNI_END
 891 
 892 JNI_ENTRY_CHECKED(jobject,
 893   checked_jni_NewObjectA(JNIEnv *env,
 894                          jclass clazz,
 895                          jmethodID methodID,
 896                          const jvalue *args))
 897     functionEnter(thr);
 898     IN_VM(
 899       jniCheck::validate_call(thr, clazz, methodID);
 900     )
 901     jobject result = UNCHECKED()-&gt;NewObjectA(env,clazz,methodID,args);
 902     functionExit(thr);
 903     return result;
 904 JNI_END
 905 
 906 JNI_ENTRY_CHECKED(jclass,
 907   checked_jni_GetObjectClass(JNIEnv *env,
 908                              jobject obj))
 909     functionEnter(thr);
 910     IN_VM(
 911       jniCheck::validate_object(thr, obj);
 912     )
 913     jclass result = UNCHECKED()-&gt;GetObjectClass(env,obj);
 914     functionExit(thr);
 915     return result;
 916 JNI_END
 917 
 918 JNI_ENTRY_CHECKED(jboolean,
 919   checked_jni_IsInstanceOf(JNIEnv *env,
 920                            jobject obj,
 921                            jclass clazz))
 922     functionEnter(thr);
 923     IN_VM(
 924       jniCheck::validate_object(thr, obj);
 925       jniCheck::validate_class(thr, clazz, true);
 926     )
 927     jboolean result = UNCHECKED()-&gt;IsInstanceOf(env,obj,clazz);
 928     functionExit(thr);
 929     return result;
 930 JNI_END
 931 
 932 JNI_ENTRY_CHECKED(jmethodID,
 933   checked_jni_GetMethodID(JNIEnv *env,
 934                           jclass clazz,
 935                           const char *name,
 936                           const char *sig))
 937     functionEnter(thr);
 938     IN_VM(
 939       jniCheck::validate_class(thr, clazz, false);
 940     )
 941     jmethodID result = UNCHECKED()-&gt;GetMethodID(env,clazz,name,sig);
 942     functionExit(thr);
 943     return result;
 944 JNI_END
 945 
 946 #define WRAPPER_CallMethod(ResultType, Result) \
 947 JNI_ENTRY_CHECKED(ResultType,  \
 948   checked_jni_Call##Result##Method(JNIEnv *env, \
 949                                    jobject obj, \
 950                                    jmethodID methodID, \
 951                                    ...)) \
 952     functionEnter(thr); \
 953     va_list args; \
 954     IN_VM( \
 955       jniCheck::validate_call(thr, NULL, methodID, obj); \
 956     ) \
 957     va_start(args,methodID); \
 958     ResultType result =UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID, \
 959                                                           args); \
 960     va_end(args); \
 961     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;Method&quot;); \
 962     functionExit(thr); \
 963     return result; \
 964 JNI_END \
 965 \
 966 JNI_ENTRY_CHECKED(ResultType,  \
 967   checked_jni_Call##Result##MethodV(JNIEnv *env, \
 968                                     jobject obj, \
 969                                     jmethodID methodID, \
 970                                     va_list args)) \
 971     functionEnter(thr); \
 972     IN_VM(\
 973       jniCheck::validate_call(thr, NULL, methodID, obj); \
 974     ) \
 975     ResultType result = UNCHECKED()-&gt;Call##Result##MethodV(env, obj, methodID,\
 976                                                            args); \
 977     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodV&quot;); \
 978     functionExit(thr); \
 979     return result; \
 980 JNI_END \
 981 \
 982 JNI_ENTRY_CHECKED(ResultType,  \
 983   checked_jni_Call##Result##MethodA(JNIEnv *env, \
 984                                     jobject obj, \
 985                                     jmethodID methodID, \
 986                                     const jvalue * args)) \
 987     functionEnter(thr); \
 988     IN_VM( \
 989       jniCheck::validate_call(thr, NULL, methodID, obj); \
 990     ) \
 991     ResultType result = UNCHECKED()-&gt;Call##Result##MethodA(env, obj, methodID,\
 992                                                            args); \
 993     thr-&gt;set_pending_jni_exception_check(&quot;Call&quot;#Result&quot;MethodA&quot;); \
 994     functionExit(thr); \
 995     return result; \
 996 JNI_END
 997 
 998 WRAPPER_CallMethod(jobject,Object)
 999 WRAPPER_CallMethod(jboolean,Boolean)
1000 WRAPPER_CallMethod(jbyte,Byte)
1001 WRAPPER_CallMethod(jshort,Short)
1002 WRAPPER_CallMethod(jchar,Char)
1003 WRAPPER_CallMethod(jint,Int)
1004 WRAPPER_CallMethod(jlong,Long)
1005 WRAPPER_CallMethod(jfloat,Float)
1006 WRAPPER_CallMethod(jdouble,Double)
1007 
1008 JNI_ENTRY_CHECKED(void,
1009   checked_jni_CallVoidMethod(JNIEnv *env, \
1010                              jobject obj, \
1011                              jmethodID methodID, \
1012                              ...))
1013     functionEnter(thr);
1014     va_list args;
1015     IN_VM(
1016       jniCheck::validate_call(thr, NULL, methodID, obj);
1017     )
1018     va_start(args,methodID);
1019     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1020     va_end(args);
1021     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethod&quot;);
1022     functionExit(thr);
1023 JNI_END
1024 
1025 JNI_ENTRY_CHECKED(void,
1026   checked_jni_CallVoidMethodV(JNIEnv *env,
1027                               jobject obj,
1028                               jmethodID methodID,
1029                               va_list args))
1030     functionEnter(thr);
1031     IN_VM(
1032       jniCheck::validate_call(thr, NULL, methodID, obj);
1033     )
1034     UNCHECKED()-&gt;CallVoidMethodV(env,obj,methodID,args);
1035     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodV&quot;);
1036     functionExit(thr);
1037 JNI_END
1038 
1039 JNI_ENTRY_CHECKED(void,
1040   checked_jni_CallVoidMethodA(JNIEnv *env,
1041                               jobject obj,
1042                               jmethodID methodID,
1043                               const jvalue * args))
1044     functionEnter(thr);
1045     IN_VM(
1046       jniCheck::validate_call(thr, NULL, methodID, obj);
1047     )
1048     UNCHECKED()-&gt;CallVoidMethodA(env,obj,methodID,args);
1049     thr-&gt;set_pending_jni_exception_check(&quot;CallVoidMethodA&quot;);
1050     functionExit(thr);
1051 JNI_END
1052 
1053 #define WRAPPER_CallNonvirtualMethod(ResultType, Result) \
1054 JNI_ENTRY_CHECKED(ResultType,  \
1055   checked_jni_CallNonvirtual##Result##Method(JNIEnv *env, \
1056                                              jobject obj, \
1057                                              jclass clazz, \
1058                                              jmethodID methodID, \
1059                                              ...)) \
1060     functionEnter(thr); \
1061     va_list args; \
1062     IN_VM( \
1063       jniCheck::validate_call(thr, clazz, methodID, obj); \
1064     ) \
1065     va_start(args,methodID); \
1066     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1067                                                                      obj, \
1068                                                                      clazz, \
1069                                                                      methodID,\
1070                                                                      args); \
1071     va_end(args); \
1072     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;Method&quot;); \
1073     functionExit(thr); \
1074     return result; \
1075 JNI_END \
1076 \
1077 JNI_ENTRY_CHECKED(ResultType,  \
1078   checked_jni_CallNonvirtual##Result##MethodV(JNIEnv *env, \
1079                                               jobject obj, \
1080                                               jclass clazz, \
1081                                               jmethodID methodID, \
1082                                               va_list args)) \
1083     functionEnter(thr); \
1084     IN_VM( \
1085       jniCheck::validate_call(thr, clazz, methodID, obj); \
1086     ) \
1087     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodV(env, \
1088                                                                      obj, \
1089                                                                      clazz, \
1090                                                                      methodID,\
1091                                                                      args); \
1092     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodV&quot;); \
1093     functionExit(thr); \
1094     return result; \
1095 JNI_END \
1096 \
1097 JNI_ENTRY_CHECKED(ResultType,  \
1098   checked_jni_CallNonvirtual##Result##MethodA(JNIEnv *env, \
1099                                               jobject obj, \
1100                                               jclass clazz, \
1101                                               jmethodID methodID, \
1102                                               const jvalue * args)) \
1103     functionEnter(thr); \
1104     IN_VM( \
1105       jniCheck::validate_call(thr, clazz, methodID, obj); \
1106     ) \
1107     ResultType result = UNCHECKED()-&gt;CallNonvirtual##Result##MethodA(env, \
1108                                                                      obj, \
1109                                                                      clazz, \
1110                                                                      methodID,\
1111                                                                      args); \
1112     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtual&quot;#Result&quot;MethodA&quot;); \
1113     functionExit(thr); \
1114     return result; \
1115 JNI_END
1116 
1117 WRAPPER_CallNonvirtualMethod(jobject,Object)
1118 WRAPPER_CallNonvirtualMethod(jboolean,Boolean)
1119 WRAPPER_CallNonvirtualMethod(jbyte,Byte)
1120 WRAPPER_CallNonvirtualMethod(jshort,Short)
1121 WRAPPER_CallNonvirtualMethod(jchar,Char)
1122 WRAPPER_CallNonvirtualMethod(jint,Int)
1123 WRAPPER_CallNonvirtualMethod(jlong,Long)
1124 WRAPPER_CallNonvirtualMethod(jfloat,Float)
1125 WRAPPER_CallNonvirtualMethod(jdouble,Double)
1126 
1127 JNI_ENTRY_CHECKED(void,
1128   checked_jni_CallNonvirtualVoidMethod(JNIEnv *env,
1129                                        jobject obj,
1130                                        jclass clazz,
1131                                        jmethodID methodID,
1132                                        ...))
1133     functionEnter(thr);
1134     va_list args;
1135     IN_VM(
1136       jniCheck::validate_call(thr, clazz, methodID, obj);
1137     )
1138     va_start(args,methodID);
1139     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1140     va_end(args);
1141     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethod&quot;);
1142     functionExit(thr);
1143 JNI_END
1144 
1145 JNI_ENTRY_CHECKED(void,
1146   checked_jni_CallNonvirtualVoidMethodV(JNIEnv *env,
1147                                         jobject obj,
1148                                         jclass clazz,
1149                                         jmethodID methodID,
1150                                         va_list args))
1151     functionEnter(thr);
1152     IN_VM(
1153       jniCheck::validate_call(thr, clazz, methodID, obj);
1154     )
1155     UNCHECKED()-&gt;CallNonvirtualVoidMethodV(env,obj,clazz,methodID,args);
1156     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodV&quot;);
1157     functionExit(thr);
1158 JNI_END
1159 
1160 JNI_ENTRY_CHECKED(void,
1161   checked_jni_CallNonvirtualVoidMethodA(JNIEnv *env,
1162                                         jobject obj,
1163                                         jclass clazz,
1164                                         jmethodID methodID,
1165                                         const jvalue * args))
1166     functionEnter(thr);
1167     IN_VM(
1168       jniCheck::validate_call(thr, clazz, methodID, obj);
1169     )
1170     UNCHECKED()-&gt;CallNonvirtualVoidMethodA(env,obj,clazz,methodID,args);
1171     thr-&gt;set_pending_jni_exception_check(&quot;CallNonvirtualVoidMethodA&quot;);
1172     functionExit(thr);
1173 JNI_END
1174 
1175 JNI_ENTRY_CHECKED(jfieldID,
1176   checked_jni_GetFieldID(JNIEnv *env,
1177                          jclass clazz,
1178                          const char *name,
1179                          const char *sig))
1180     functionEnter(thr);
1181     IN_VM(
1182       jniCheck::validate_class(thr, clazz, false);
1183     )
1184     jfieldID result = UNCHECKED()-&gt;GetFieldID(env,clazz,name,sig);
1185     functionExit(thr);
1186     return result;
1187 JNI_END
1188 
1189 #define WRAPPER_GetField(ReturnType,Result,FieldType) \
1190 JNI_ENTRY_CHECKED(ReturnType,  \
1191   checked_jni_Get##Result##Field(JNIEnv *env, \
1192                                  jobject obj, \
1193                                  jfieldID fieldID)) \
1194     functionEnter(thr); \
1195     IN_VM( \
1196       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1197     ) \
1198     ReturnType result = UNCHECKED()-&gt;Get##Result##Field(env,obj,fieldID); \
1199     functionExit(thr); \
1200     return result; \
1201 JNI_END
1202 
1203 WRAPPER_GetField(jobject,  Object,  T_OBJECT)
1204 WRAPPER_GetField(jboolean, Boolean, T_BOOLEAN)
1205 WRAPPER_GetField(jbyte,    Byte,    T_BYTE)
1206 WRAPPER_GetField(jshort,   Short,   T_SHORT)
1207 WRAPPER_GetField(jchar,    Char,    T_CHAR)
1208 WRAPPER_GetField(jint,     Int,     T_INT)
1209 WRAPPER_GetField(jlong,    Long,    T_LONG)
1210 WRAPPER_GetField(jfloat,   Float,   T_FLOAT)
1211 WRAPPER_GetField(jdouble,  Double,  T_DOUBLE)
1212 
1213 #define WRAPPER_SetField(ValueType,Result,FieldType) \
1214 JNI_ENTRY_CHECKED(void,  \
1215   checked_jni_Set##Result##Field(JNIEnv *env, \
1216                                  jobject obj, \
1217                                  jfieldID fieldID, \
1218                                  ValueType val)) \
1219     functionEnter(thr); \
1220     IN_VM( \
1221       checkInstanceFieldID(thr, fieldID, obj, FieldType); \
1222     ) \
1223     UNCHECKED()-&gt;Set##Result##Field(env,obj,fieldID,val); \
1224     functionExit(thr); \
1225 JNI_END
1226 
1227 WRAPPER_SetField(jobject,  Object,  T_OBJECT)
1228 WRAPPER_SetField(jboolean, Boolean, T_BOOLEAN)
1229 WRAPPER_SetField(jbyte,    Byte,    T_BYTE)
1230 WRAPPER_SetField(jshort,   Short,   T_SHORT)
1231 WRAPPER_SetField(jchar,    Char,    T_CHAR)
1232 WRAPPER_SetField(jint,     Int,     T_INT)
1233 WRAPPER_SetField(jlong,    Long,    T_LONG)
1234 WRAPPER_SetField(jfloat,   Float,   T_FLOAT)
1235 WRAPPER_SetField(jdouble,  Double,  T_DOUBLE)
1236 
1237 
1238 JNI_ENTRY_CHECKED(jmethodID,
1239   checked_jni_GetStaticMethodID(JNIEnv *env,
1240                                 jclass clazz,
1241                                 const char *name,
1242                                 const char *sig))
1243     functionEnter(thr);
1244     IN_VM(
1245       jniCheck::validate_class(thr, clazz, false);
1246     )
1247     jmethodID result = UNCHECKED()-&gt;GetStaticMethodID(env,clazz,name,sig);
1248     functionExit(thr);
1249     return result;
1250 JNI_END
1251 
1252 #define WRAPPER_CallStaticMethod(ReturnType,Result) \
1253 JNI_ENTRY_CHECKED(ReturnType,  \
1254   checked_jni_CallStatic##Result##Method(JNIEnv *env, \
1255                                          jclass clazz, \
1256                                          jmethodID methodID, \
1257                                          ...)) \
1258     functionEnter(thr); \
1259     va_list args; \
1260     IN_VM( \
1261       jniCheck::validate_call(thr, clazz, methodID); \
1262     ) \
1263     va_start(args,methodID); \
1264     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1265                                                                  clazz, \
1266                                                                  methodID, \
1267                                                                  args); \
1268     va_end(args); \
1269     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;Method&quot;); \
1270     functionExit(thr); \
1271     return result; \
1272 JNI_END \
1273 \
1274 JNI_ENTRY_CHECKED(ReturnType,  \
1275   checked_jni_CallStatic##Result##MethodV(JNIEnv *env, \
1276                                           jclass clazz, \
1277                                           jmethodID methodID,\
1278                                           va_list args)) \
1279     functionEnter(thr); \
1280     IN_VM( \
1281       jniCheck::validate_call(thr, clazz, methodID); \
1282     ) \
1283     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodV(env, \
1284                                                                  clazz, \
1285                                                                  methodID, \
1286                                                                  args); \
1287     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodV&quot;); \
1288     functionExit(thr); \
1289     return result; \
1290 JNI_END \
1291 \
1292 JNI_ENTRY_CHECKED(ReturnType,  \
1293   checked_jni_CallStatic##Result##MethodA(JNIEnv *env, \
1294                                           jclass clazz, \
1295                                           jmethodID methodID, \
1296                                           const jvalue *args)) \
1297     functionEnter(thr); \
1298     IN_VM( \
1299       jniCheck::validate_call(thr, clazz, methodID); \
1300     ) \
1301     ReturnType result = UNCHECKED()-&gt;CallStatic##Result##MethodA(env, \
1302                                                                  clazz, \
1303                                                                  methodID, \
1304                                                                  args); \
1305     thr-&gt;set_pending_jni_exception_check(&quot;CallStatic&quot;#Result&quot;MethodA&quot;); \
1306     functionExit(thr); \
1307     return result; \
1308 JNI_END
1309 
1310 WRAPPER_CallStaticMethod(jobject,Object)
1311 WRAPPER_CallStaticMethod(jboolean,Boolean)
1312 WRAPPER_CallStaticMethod(jbyte,Byte)
1313 WRAPPER_CallStaticMethod(jshort,Short)
1314 WRAPPER_CallStaticMethod(jchar,Char)
1315 WRAPPER_CallStaticMethod(jint,Int)
1316 WRAPPER_CallStaticMethod(jlong,Long)
1317 WRAPPER_CallStaticMethod(jfloat,Float)
1318 WRAPPER_CallStaticMethod(jdouble,Double)
1319 
1320 JNI_ENTRY_CHECKED(void,
1321   checked_jni_CallStaticVoidMethod(JNIEnv *env,
1322                                    jclass cls,
1323                                    jmethodID methodID,
1324                                    ...))
1325     functionEnter(thr);
1326     va_list args;
1327     IN_VM(
1328       jniCheck::validate_call(thr, cls, methodID);
1329     )
1330     va_start(args,methodID);
1331     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1332     va_end(args);
1333     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethod&quot;);
1334     functionExit(thr);
1335 JNI_END
1336 
1337 JNI_ENTRY_CHECKED(void,
1338   checked_jni_CallStaticVoidMethodV(JNIEnv *env,
1339                                     jclass cls,
1340                                     jmethodID methodID,
1341                                     va_list args))
1342     functionEnter(thr);
1343     IN_VM(
1344       jniCheck::validate_call(thr, cls, methodID);
1345     )
1346     UNCHECKED()-&gt;CallStaticVoidMethodV(env,cls,methodID,args);
1347     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodV&quot;);
1348     functionExit(thr);
1349 JNI_END
1350 
1351 JNI_ENTRY_CHECKED(void,
1352   checked_jni_CallStaticVoidMethodA(JNIEnv *env,
1353                                     jclass cls,
1354                                     jmethodID methodID,
1355                                     const jvalue * args))
1356     functionEnter(thr);
1357     IN_VM(
1358       jniCheck::validate_call(thr, cls, methodID);
1359     )
1360     UNCHECKED()-&gt;CallStaticVoidMethodA(env,cls,methodID,args);
1361     thr-&gt;set_pending_jni_exception_check(&quot;CallStaticVoidMethodA&quot;);
1362     functionExit(thr);
1363 JNI_END
1364 
1365 JNI_ENTRY_CHECKED(jfieldID,
1366   checked_jni_GetStaticFieldID(JNIEnv *env,
1367                                jclass clazz,
1368                                const char *name,
1369                                const char *sig))
1370     functionEnter(thr);
1371     IN_VM(
1372       jniCheck::validate_class(thr, clazz, false);
1373     )
1374     jfieldID result = UNCHECKED()-&gt;GetStaticFieldID(env,clazz,name,sig);
1375     functionExit(thr);
1376     return result;
1377 JNI_END
1378 
1379 #define WRAPPER_GetStaticField(ReturnType,Result,FieldType) \
1380 JNI_ENTRY_CHECKED(ReturnType,  \
1381   checked_jni_GetStatic##Result##Field(JNIEnv *env, \
1382                                        jclass clazz, \
1383                                        jfieldID fieldID)) \
1384     functionEnter(thr); \
1385     IN_VM( \
1386       jniCheck::validate_class(thr, clazz, false); \
1387       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1388     ) \
1389     ReturnType result = UNCHECKED()-&gt;GetStatic##Result##Field(env, \
1390                                                               clazz, \
1391                                                               fieldID); \
1392     functionExit(thr); \
1393     return result; \
1394 JNI_END
1395 
1396 WRAPPER_GetStaticField(jobject,  Object,  T_OBJECT)
1397 WRAPPER_GetStaticField(jboolean, Boolean, T_BOOLEAN)
1398 WRAPPER_GetStaticField(jbyte,    Byte,    T_BYTE)
1399 WRAPPER_GetStaticField(jshort,   Short,   T_SHORT)
1400 WRAPPER_GetStaticField(jchar,    Char,    T_CHAR)
1401 WRAPPER_GetStaticField(jint,     Int,     T_INT)
1402 WRAPPER_GetStaticField(jlong,    Long,    T_LONG)
1403 WRAPPER_GetStaticField(jfloat,   Float,   T_FLOAT)
1404 WRAPPER_GetStaticField(jdouble,  Double,  T_DOUBLE)
1405 
1406 #define WRAPPER_SetStaticField(ValueType,Result,FieldType) \
1407 JNI_ENTRY_CHECKED(void,  \
1408   checked_jni_SetStatic##Result##Field(JNIEnv *env, \
1409                                        jclass clazz, \
1410                                        jfieldID fieldID, \
1411                                        ValueType value)) \
1412     functionEnter(thr); \
1413     IN_VM( \
1414       jniCheck::validate_class(thr, clazz, false); \
1415       checkStaticFieldID(thr, fieldID, clazz, FieldType); \
1416     ) \
1417     UNCHECKED()-&gt;SetStatic##Result##Field(env,clazz,fieldID,value); \
1418     functionExit(thr); \
1419 JNI_END
1420 
1421 WRAPPER_SetStaticField(jobject,  Object,  T_OBJECT)
1422 WRAPPER_SetStaticField(jboolean, Boolean, T_BOOLEAN)
1423 WRAPPER_SetStaticField(jbyte,    Byte,    T_BYTE)
1424 WRAPPER_SetStaticField(jshort,   Short,   T_SHORT)
1425 WRAPPER_SetStaticField(jchar,    Char,    T_CHAR)
1426 WRAPPER_SetStaticField(jint,     Int,     T_INT)
1427 WRAPPER_SetStaticField(jlong,    Long,    T_LONG)
1428 WRAPPER_SetStaticField(jfloat,   Float,   T_FLOAT)
1429 WRAPPER_SetStaticField(jdouble,  Double,  T_DOUBLE)
1430 
1431 
1432 JNI_ENTRY_CHECKED(jstring,
1433   checked_jni_NewString(JNIEnv *env,
1434                         const jchar *unicode,
1435                         jsize len))
1436     functionEnter(thr);
1437     jstring result = UNCHECKED()-&gt;NewString(env,unicode,len);
1438     functionExit(thr);
1439     return result;
1440 JNI_END
1441 
1442 JNI_ENTRY_CHECKED(jsize,
1443   checked_jni_GetStringLength(JNIEnv *env,
1444                               jstring str))
1445     functionEnter(thr);
1446     IN_VM(
1447       checkString(thr, str);
1448     )
1449     jsize result = UNCHECKED()-&gt;GetStringLength(env,str);
1450     functionExit(thr);
1451     return result;
1452 JNI_END
1453 
1454 // Arbitrary (but well-known) tag
1455 const void* STRING_TAG = (void*)0x47114711;
1456 
1457 JNI_ENTRY_CHECKED(const jchar *,
1458   checked_jni_GetStringChars(JNIEnv *env,
1459                              jstring str,
1460                              jboolean *isCopy))
1461     functionEnter(thr);
1462     IN_VM(
1463       checkString(thr, str);
1464     )
1465     jchar* new_result = NULL;
1466     const jchar *result = UNCHECKED()-&gt;GetStringChars(env,str,isCopy);
1467     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringChars didn&#39;t return a copy as expected&quot;);
1468     if (result != NULL) {
1469       size_t len = UNCHECKED()-&gt;GetStringLength(env,str) + 1; // + 1 for NULL termination
1470       len *= sizeof(jchar);
1471       new_result = (jchar*) GuardedMemory::wrap_copy(result, len, STRING_TAG);
1472       if (new_result == NULL) {
1473         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringChars&quot;);
1474       }
1475       // Avoiding call to UNCHECKED()-&gt;ReleaseStringChars() since that will fire unexpected dtrace probes
1476       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1477       FreeHeap((char*)result);
1478     }
1479     functionExit(thr);
1480     return new_result;
1481 JNI_END
1482 
1483 JNI_ENTRY_CHECKED(void,
1484   checked_jni_ReleaseStringChars(JNIEnv *env,
1485                                  jstring str,
1486                                  const jchar *chars))
1487     functionEnterExceptionAllowed(thr);
1488     IN_VM(
1489       checkString(thr, str);
1490     )
1491     if (chars == NULL) {
1492        // still do the unchecked call to allow dtrace probes
1493        UNCHECKED()-&gt;ReleaseStringChars(env,str,chars);
1494     }
1495     else {
1496       GuardedMemory guarded((void*)chars);
1497       if (!guarded.verify_guards()) {
1498         tty-&gt;print_cr(&quot;ReleaseStringChars: release chars failed bounds check. &quot;
1499             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1500         guarded.print_on(tty);
1501         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars: &quot;
1502             &quot;release chars failed bounds check.&quot;);
1503       }
1504       if (guarded.get_tag() != STRING_TAG) {
1505         tty-&gt;print_cr(&quot;ReleaseStringChars: called on something not allocated &quot;
1506             &quot;by GetStringChars. string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT,
1507             p2i(str), p2i(chars));
1508         NativeReportJNIFatalError(thr, &quot;ReleaseStringChars called on something &quot;
1509             &quot;not allocated by GetStringChars&quot;);
1510       }
1511        UNCHECKED()-&gt;ReleaseStringChars(env, str,
1512            (const jchar*) guarded.release_for_freeing());
1513     }
1514     functionExit(thr);
1515 JNI_END
1516 
1517 JNI_ENTRY_CHECKED(jstring,
1518   checked_jni_NewStringUTF(JNIEnv *env,
1519                            const char *utf))
1520     functionEnter(thr);
1521     jstring result = UNCHECKED()-&gt;NewStringUTF(env,utf);
1522     functionExit(thr);
1523     return result;
1524 JNI_END
1525 
1526 JNI_ENTRY_CHECKED(jsize,
1527   checked_jni_GetStringUTFLength(JNIEnv *env,
1528                                  jstring str))
1529     functionEnter(thr);
1530     IN_VM(
1531       checkString(thr, str);
1532     )
1533     jsize result = UNCHECKED()-&gt;GetStringUTFLength(env,str);
1534     functionExit(thr);
1535     return result;
1536 JNI_END
1537 
1538 // Arbitrary (but well-known) tag - different than GetStringChars
1539 const void* STRING_UTF_TAG = (void*) 0x48124812;
1540 
1541 JNI_ENTRY_CHECKED(const char *,
1542   checked_jni_GetStringUTFChars(JNIEnv *env,
1543                                 jstring str,
1544                                 jboolean *isCopy))
1545     functionEnter(thr);
1546     IN_VM(
1547       checkString(thr, str);
1548     )
1549     char* new_result = NULL;
1550     const char *result = UNCHECKED()-&gt;GetStringUTFChars(env,str,isCopy);
1551     assert (isCopy == NULL || *isCopy == JNI_TRUE, &quot;GetStringUTFChars didn&#39;t return a copy as expected&quot;);
1552     if (result != NULL) {
1553       size_t len = strlen(result) + 1; // + 1 for NULL termination
1554       new_result = (char*) GuardedMemory::wrap_copy(result, len, STRING_UTF_TAG);
1555       if (new_result == NULL) {
1556         vm_exit_out_of_memory(len, OOM_MALLOC_ERROR, &quot;checked_jni_GetStringUTFChars&quot;);
1557       }
1558       // Avoiding call to UNCHECKED()-&gt;ReleaseStringUTFChars() since that will fire unexpected dtrace probes
1559       // Note that the dtrace arguments for the allocated memory will not match up with this solution.
1560       FreeHeap((char*)result);
1561     }
1562     functionExit(thr);
1563     return new_result;
1564 JNI_END
1565 
1566 JNI_ENTRY_CHECKED(void,
1567   checked_jni_ReleaseStringUTFChars(JNIEnv *env,
1568                                     jstring str,
1569                                     const char* chars))
1570     functionEnterExceptionAllowed(thr);
1571     IN_VM(
1572       checkString(thr, str);
1573     )
1574     if (chars == NULL) {
1575        // still do the unchecked call to allow dtrace probes
1576        UNCHECKED()-&gt;ReleaseStringUTFChars(env,str,chars);
1577     }
1578     else {
1579       GuardedMemory guarded((void*)chars);
1580       if (!guarded.verify_guards()) {
1581         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: release chars failed bounds check. &quot;
1582             &quot;string: &quot; PTR_FORMAT &quot; chars: &quot; PTR_FORMAT, p2i(str), p2i(chars));
1583         guarded.print_on(tty);
1584         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars: &quot;
1585             &quot;release chars failed bounds check.&quot;);
1586       }
1587       if (guarded.get_tag() != STRING_UTF_TAG) {
1588         tty-&gt;print_cr(&quot;ReleaseStringUTFChars: called on something not &quot;
1589             &quot;allocated by GetStringUTFChars. string: &quot; PTR_FORMAT &quot; chars: &quot;
1590             PTR_FORMAT, p2i(str), p2i(chars));
1591         NativeReportJNIFatalError(thr, &quot;ReleaseStringUTFChars &quot;
1592             &quot;called on something not allocated by GetStringUTFChars&quot;);
1593       }
1594       UNCHECKED()-&gt;ReleaseStringUTFChars(env, str,
1595           (const char*) guarded.release_for_freeing());
1596     }
1597     functionExit(thr);
1598 JNI_END
1599 
1600 JNI_ENTRY_CHECKED(jsize,
1601   checked_jni_GetArrayLength(JNIEnv *env,
1602                              jarray array))
1603     functionEnter(thr);
1604     IN_VM(
1605       check_is_array(thr, array);
1606     )
1607     jsize result = UNCHECKED()-&gt;GetArrayLength(env,array);
1608     functionExit(thr);
1609     return result;
1610 JNI_END
1611 
1612 JNI_ENTRY_CHECKED(jobjectArray,
1613   checked_jni_NewObjectArray(JNIEnv *env,
1614                              jsize len,
1615                              jclass clazz,
1616                              jobject init))
1617     functionEnter(thr);
1618     jobjectArray result = UNCHECKED()-&gt;NewObjectArray(env,len,clazz,init);
1619     functionExit(thr);
1620     return result;
1621 JNI_END
1622 
1623 JNI_ENTRY_CHECKED(jobject,
1624   checked_jni_GetObjectArrayElement(JNIEnv *env,
1625                                     jobjectArray array,
1626                                     jsize index))
1627     functionEnter(thr);
1628     IN_VM(
1629       check_is_obj_array(thr, array);
1630     )
1631     jobject result = UNCHECKED()-&gt;GetObjectArrayElement(env,array,index);
1632     functionExit(thr);
1633     return result;
1634 JNI_END
1635 
1636 JNI_ENTRY_CHECKED(void,
1637   checked_jni_SetObjectArrayElement(JNIEnv *env,
1638                                     jobjectArray array,
1639                                     jsize index,
1640                                     jobject val))
1641     functionEnter(thr);
1642     IN_VM(
1643       check_is_obj_array(thr, array);
1644     )
1645     UNCHECKED()-&gt;SetObjectArrayElement(env,array,index,val);
1646     functionExit(thr);
1647 JNI_END
1648 
1649 #define WRAPPER_NewScalarArray(Return, Result) \
1650 JNI_ENTRY_CHECKED(Return, \
1651   checked_jni_New##Result##Array(JNIEnv *env, \
1652                                  jsize len)) \
1653     functionEnter(thr); \
1654     Return result = UNCHECKED()-&gt;New##Result##Array(env,len); \
1655     functionExit(thr); \
1656     return (Return) result; \
1657 JNI_END
1658 
1659 WRAPPER_NewScalarArray(jbooleanArray, Boolean)
1660 WRAPPER_NewScalarArray(jbyteArray, Byte)
1661 WRAPPER_NewScalarArray(jshortArray, Short)
1662 WRAPPER_NewScalarArray(jcharArray, Char)
1663 WRAPPER_NewScalarArray(jintArray, Int)
1664 WRAPPER_NewScalarArray(jlongArray, Long)
1665 WRAPPER_NewScalarArray(jfloatArray, Float)
1666 WRAPPER_NewScalarArray(jdoubleArray, Double)
1667 
1668 #define WRAPPER_GetScalarArrayElements(ElementTag,ElementType,Result) \
1669 JNI_ENTRY_CHECKED(ElementType *,  \
1670   checked_jni_Get##Result##ArrayElements(JNIEnv *env, \
1671                                          ElementType##Array array, \
1672                                          jboolean *isCopy)) \
1673     functionEnter(thr); \
1674     IN_VM( \
1675       check_primitive_array_type(thr, array, ElementTag); \
1676     ) \
1677     ElementType *result = UNCHECKED()-&gt;Get##Result##ArrayElements(env, \
1678                                                                   array, \
1679                                                                   isCopy); \
1680     if (result != NULL) { \
1681       result = (ElementType *) check_jni_wrap_copy_array(thr, array, result); \
1682     } \
1683     functionExit(thr); \
1684     return result; \
1685 JNI_END
1686 
1687 WRAPPER_GetScalarArrayElements(T_BOOLEAN, jboolean, Boolean)
1688 WRAPPER_GetScalarArrayElements(T_BYTE,    jbyte,    Byte)
1689 WRAPPER_GetScalarArrayElements(T_SHORT,   jshort,   Short)
1690 WRAPPER_GetScalarArrayElements(T_CHAR,    jchar,    Char)
1691 WRAPPER_GetScalarArrayElements(T_INT,     jint,     Int)
1692 WRAPPER_GetScalarArrayElements(T_LONG,    jlong,    Long)
1693 WRAPPER_GetScalarArrayElements(T_FLOAT,   jfloat,   Float)
1694 WRAPPER_GetScalarArrayElements(T_DOUBLE,  jdouble,  Double)
1695 
1696 #define WRAPPER_ReleaseScalarArrayElements(ElementTag,ElementType,Result,Tag) \
1697 JNI_ENTRY_CHECKED(void,  \
1698   checked_jni_Release##Result##ArrayElements(JNIEnv *env, \
1699                                              ElementType##Array array, \
1700                                              ElementType *elems, \
1701                                              jint mode)) \
1702     functionEnterExceptionAllowed(thr); \
1703     IN_VM( \
1704       check_primitive_array_type(thr, array, ElementTag); \
1705       ASSERT_OOPS_ALLOWED; \
1706       typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
1707     ) \
1708     ElementType* orig_result = (ElementType *) check_wrapped_array_release( \
1709         thr, &quot;checked_jni_Release&quot;#Result&quot;ArrayElements&quot;, array, elems, mode); \
1710     UNCHECKED()-&gt;Release##Result##ArrayElements(env, array, orig_result, mode); \
1711     functionExit(thr); \
1712 JNI_END
1713 
1714 WRAPPER_ReleaseScalarArrayElements(T_BOOLEAN,jboolean, Boolean, bool)
1715 WRAPPER_ReleaseScalarArrayElements(T_BYTE,   jbyte,    Byte,    byte)
1716 WRAPPER_ReleaseScalarArrayElements(T_SHORT,  jshort,   Short,   short)
1717 WRAPPER_ReleaseScalarArrayElements(T_CHAR,   jchar,    Char,    char)
1718 WRAPPER_ReleaseScalarArrayElements(T_INT,    jint,     Int,     int)
1719 WRAPPER_ReleaseScalarArrayElements(T_LONG,   jlong,    Long,    long)
1720 WRAPPER_ReleaseScalarArrayElements(T_FLOAT,  jfloat,   Float,   float)
1721 WRAPPER_ReleaseScalarArrayElements(T_DOUBLE, jdouble,  Double,  double)
1722 
1723 #define WRAPPER_GetScalarArrayRegion(ElementTag,ElementType,Result) \
1724 JNI_ENTRY_CHECKED(void,  \
1725   checked_jni_Get##Result##ArrayRegion(JNIEnv *env, \
1726                                        ElementType##Array array, \
1727                                        jsize start, \
1728                                        jsize len, \
1729                                        ElementType *buf)) \
1730     functionEnter(thr); \
1731     IN_VM( \
1732       check_primitive_array_type(thr, array, ElementTag); \
1733     ) \
1734     UNCHECKED()-&gt;Get##Result##ArrayRegion(env,array,start,len,buf); \
1735     functionExit(thr); \
1736 JNI_END
1737 
1738 WRAPPER_GetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1739 WRAPPER_GetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1740 WRAPPER_GetScalarArrayRegion(T_SHORT,   jshort,   Short)
1741 WRAPPER_GetScalarArrayRegion(T_CHAR,    jchar,    Char)
1742 WRAPPER_GetScalarArrayRegion(T_INT,     jint,     Int)
1743 WRAPPER_GetScalarArrayRegion(T_LONG,    jlong,    Long)
1744 WRAPPER_GetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1745 WRAPPER_GetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1746 
1747 #define WRAPPER_SetScalarArrayRegion(ElementTag,ElementType,Result) \
1748 JNI_ENTRY_CHECKED(void,  \
1749   checked_jni_Set##Result##ArrayRegion(JNIEnv *env, \
1750                                        ElementType##Array array, \
1751                                        jsize start, \
1752                                        jsize len, \
1753                                        const ElementType *buf)) \
1754     functionEnter(thr); \
1755     IN_VM( \
1756       check_primitive_array_type(thr, array, ElementTag); \
1757     ) \
1758     UNCHECKED()-&gt;Set##Result##ArrayRegion(env,array,start,len,buf); \
1759     functionExit(thr); \
1760 JNI_END
1761 
1762 WRAPPER_SetScalarArrayRegion(T_BOOLEAN, jboolean, Boolean)
1763 WRAPPER_SetScalarArrayRegion(T_BYTE,    jbyte,    Byte)
1764 WRAPPER_SetScalarArrayRegion(T_SHORT,   jshort,   Short)
1765 WRAPPER_SetScalarArrayRegion(T_CHAR,    jchar,    Char)
1766 WRAPPER_SetScalarArrayRegion(T_INT,     jint,     Int)
1767 WRAPPER_SetScalarArrayRegion(T_LONG,    jlong,    Long)
1768 WRAPPER_SetScalarArrayRegion(T_FLOAT,   jfloat,   Float)
1769 WRAPPER_SetScalarArrayRegion(T_DOUBLE,  jdouble,  Double)
1770 
1771 JNI_ENTRY_CHECKED(jint,
1772   checked_jni_RegisterNatives(JNIEnv *env,
1773                               jclass clazz,
1774                               const JNINativeMethod *methods,
1775                               jint nMethods))
1776     functionEnter(thr);
1777     jint result = UNCHECKED()-&gt;RegisterNatives(env,clazz,methods,nMethods);
1778     functionExit(thr);
1779     return result;
1780 JNI_END
1781 
1782 JNI_ENTRY_CHECKED(jint,
1783   checked_jni_UnregisterNatives(JNIEnv *env,
1784                                 jclass clazz))
1785     functionEnter(thr);
1786     jint result = UNCHECKED()-&gt;UnregisterNatives(env,clazz);
1787     functionExit(thr);
1788     return result;
1789 JNI_END
1790 
1791 JNI_ENTRY_CHECKED(jint,
1792   checked_jni_MonitorEnter(JNIEnv *env,
1793                            jobject obj))
1794     functionEnter(thr);
1795     IN_VM(
1796       jniCheck::validate_object(thr, obj);
1797     )
1798     jint result = UNCHECKED()-&gt;MonitorEnter(env,obj);
1799     functionExit(thr);
1800     return result;
1801 JNI_END
1802 
1803 JNI_ENTRY_CHECKED(jint,
1804   checked_jni_MonitorExit(JNIEnv *env,
1805                           jobject obj))
1806     functionEnterExceptionAllowed(thr);
1807     IN_VM(
1808       jniCheck::validate_object(thr, obj);
1809     )
1810     jint result = UNCHECKED()-&gt;MonitorExit(env,obj);
1811     functionExit(thr);
1812     return result;
1813 JNI_END
1814 
1815 JNI_ENTRY_CHECKED(jint,
1816   checked_jni_GetJavaVM(JNIEnv *env,
1817                         JavaVM **vm))
1818     functionEnter(thr);
1819     jint result = UNCHECKED()-&gt;GetJavaVM(env,vm);
1820     functionExit(thr);
1821     return result;
1822 JNI_END
1823 
1824 JNI_ENTRY_CHECKED(void,
1825   checked_jni_GetStringRegion(JNIEnv *env,
1826                               jstring str,
1827                               jsize start,
1828                               jsize len,
1829                               jchar *buf))
1830     functionEnter(thr);
1831     IN_VM(
1832       checkString(thr, str);
1833     )
1834     UNCHECKED()-&gt;GetStringRegion(env, str, start, len, buf);
1835     functionExit(thr);
1836 JNI_END
1837 
1838 JNI_ENTRY_CHECKED(void,
1839   checked_jni_GetStringUTFRegion(JNIEnv *env,
1840                                  jstring str,
1841                                  jsize start,
1842                                  jsize len,
1843                                  char *buf))
1844     functionEnter(thr);
1845     IN_VM(
1846       checkString(thr, str);
1847     )
1848     UNCHECKED()-&gt;GetStringUTFRegion(env, str, start, len, buf);
1849     functionExit(thr);
1850 JNI_END
1851 
1852 JNI_ENTRY_CHECKED(void *,
1853   checked_jni_GetPrimitiveArrayCritical(JNIEnv *env,
1854                                         jarray array,
1855                                         jboolean *isCopy))
1856     functionEnterCritical(thr);
1857     IN_VM(
1858       check_is_primitive_array(thr, array);
1859     )
1860     void *result = UNCHECKED()-&gt;GetPrimitiveArrayCritical(env, array, isCopy);
1861     if (result != NULL) {
1862       result = check_jni_wrap_copy_array(thr, array, result);
1863     }
1864     functionExit(thr);
1865     return result;
1866 JNI_END
1867 
1868 JNI_ENTRY_CHECKED(void,
1869   checked_jni_ReleasePrimitiveArrayCritical(JNIEnv *env,
1870                                             jarray array,
1871                                             void *carray,
1872                                             jint mode))
1873     functionEnterCriticalExceptionAllowed(thr);
1874     IN_VM(
1875       check_is_primitive_array(thr, array);
1876     )
1877     // Check the element array...
1878     void* orig_result = check_wrapped_array_release(thr, &quot;ReleasePrimitiveArrayCritical&quot;, array, carray, mode);
1879     UNCHECKED()-&gt;ReleasePrimitiveArrayCritical(env, array, orig_result, mode);
1880     functionExit(thr);
1881 JNI_END
1882 
1883 JNI_ENTRY_CHECKED(const jchar*,
1884   checked_jni_GetStringCritical(JNIEnv *env,
1885                                 jstring string,
1886                                 jboolean *isCopy))
1887     functionEnterCritical(thr);
1888     IN_VM(
1889       checkString(thr, string);
1890     )
1891     const jchar *result = UNCHECKED()-&gt;GetStringCritical(env, string, isCopy);
1892     functionExit(thr);
1893     return result;
1894 JNI_END
1895 
1896 JNI_ENTRY_CHECKED(void,
1897   checked_jni_ReleaseStringCritical(JNIEnv *env,
1898                                     jstring str,
1899                                     const jchar *chars))
1900     functionEnterCriticalExceptionAllowed(thr);
1901     IN_VM(
1902       checkString(thr, str);
1903     )
1904     /* The Hotspot JNI code does not use the parameters, so just check the
1905      * string parameter as a minor sanity check
1906      */
1907     UNCHECKED()-&gt;ReleaseStringCritical(env, str, chars);
1908     functionExit(thr);
1909 JNI_END
1910 
1911 JNI_ENTRY_CHECKED(jweak,
1912   checked_jni_NewWeakGlobalRef(JNIEnv *env,
1913                                jobject obj))
1914     functionEnter(thr);
1915     IN_VM(
1916       if (obj != NULL) {
1917         jniCheck::validate_handle(thr, obj);
1918       }
1919     )
1920     jweak result = UNCHECKED()-&gt;NewWeakGlobalRef(env, obj);
1921     functionExit(thr);
1922     return result;
1923 JNI_END
1924 
1925 JNI_ENTRY_CHECKED(void,
1926   checked_jni_DeleteWeakGlobalRef(JNIEnv *env,
1927                                   jweak ref))
1928     functionEnterExceptionAllowed(thr);
1929     IN_VM(
1930       if (ref &amp;&amp; !JNIHandles::is_weak_global_handle(ref)) {
1931         ReportJNIFatalError(thr,
1932              &quot;Invalid weak global JNI handle passed to DeleteWeakGlobalRef&quot;);
1933       }
1934     )
1935     UNCHECKED()-&gt;DeleteWeakGlobalRef(env, ref);
1936     functionExit(thr);
1937 JNI_END
1938 
1939 JNI_ENTRY_CHECKED(jboolean,
1940   checked_jni_ExceptionCheck(JNIEnv *env))
1941     thr-&gt;clear_pending_jni_exception_check();
1942     functionEnterExceptionAllowed(thr);
1943     jboolean result = UNCHECKED()-&gt;ExceptionCheck(env);
1944     functionExit(thr);
1945     return result;
1946 JNI_END
1947 
1948 JNI_ENTRY_CHECKED(jobject,
1949   checked_jni_NewDirectByteBuffer(JNIEnv *env,
1950                                   void *address,
1951                                   jlong capacity))
1952     functionEnter(thr);
1953     jobject result = UNCHECKED()-&gt;NewDirectByteBuffer(env, address, capacity);
1954     functionExit(thr);
1955     return result;
1956 JNI_END
1957 
1958 JNI_ENTRY_CHECKED(void *,
1959   checked_jni_GetDirectBufferAddress(JNIEnv *env,
1960                                      jobject buf))
1961     functionEnter(thr);
1962     void* result = UNCHECKED()-&gt;GetDirectBufferAddress(env, buf);
1963     functionExit(thr);
1964     return result;
1965 JNI_END
1966 
1967 JNI_ENTRY_CHECKED(jlong,
1968   checked_jni_GetDirectBufferCapacity(JNIEnv *env,
1969                                       jobject buf))
1970     functionEnter(thr);
1971     jlong result = UNCHECKED()-&gt;GetDirectBufferCapacity(env, buf);
1972     functionExit(thr);
1973     return result;
1974 JNI_END
1975 
1976 JNI_ENTRY_CHECKED(jobjectRefType,
1977   checked_jni_GetObjectRefType(JNIEnv *env,
1978                                jobject obj))
1979     functionEnter(thr);
1980     /* validate the object being passed */
1981     IN_VM(
1982       jniCheck::validate_object(thr, obj);
1983     )
1984     jobjectRefType result = UNCHECKED()-&gt;GetObjectRefType(env, obj);
1985     functionExit(thr);
1986     return result;
1987 JNI_END
1988 
1989 
1990 JNI_ENTRY_CHECKED(jint,
1991   checked_jni_GetVersion(JNIEnv *env))
1992     functionEnter(thr);
1993     jint result = UNCHECKED()-&gt;GetVersion(env);
1994     functionExit(thr);
1995     return result;
1996 JNI_END
1997 
1998 JNI_ENTRY_CHECKED(jobject,
1999   checked_jni_GetModule(JNIEnv *env,
2000                         jclass clazz))
2001     functionEnter(thr);
2002     jobject result = UNCHECKED()-&gt;GetModule(env,clazz);
2003     functionExit(thr);
2004     return result;
2005 JNI_END
2006 
2007 JNI_ENTRY_CHECKED(void*,
2008     checked_jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
2009     functionEnter(thr);
2010     void* result = UNCHECKED()-&gt;GetFlattenedArrayElements(env, array, isCopy);
2011     functionExit(thr);
2012     return result;
2013 
2014 JNI_END
2015 
2016 JNI_ENTRY_CHECKED(void,
2017     checked_jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
2018     functionEnter(thr);
2019     UNCHECKED()-&gt;ReleaseFlattenedArrayElements(env, array, elem, mode);
2020     functionExit(thr);
2021     return;
2022 JNI_END
2023 
2024 JNI_ENTRY_CHECKED(jclass,
2025     checked_jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
2026     functionEnter(thr);
2027     jclass clazz = UNCHECKED()-&gt;GetFlattenedArrayElementClass(env, array);
2028     functionExit(thr);
2029     return clazz;
2030 JNI_END
2031 
2032 JNI_ENTRY_CHECKED(jsize,
2033     checked_jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array))
2034     functionEnter(thr);
2035     jsize size = UNCHECKED()-&gt;GetFlattenedArrayElementSize(env, array);
2036     functionExit(thr);
2037     return size;
2038 JNI_END
2039 
2040 JNI_ENTRY_CHECKED(jsize,
2041     checked_jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
2042     functionEnter(thr);
2043     jsize offset = UNCHECKED()-&gt;GetFieldOffsetInFlattenedLayout(env, clazz, name, signature, isFlattened);
2044     functionExit(thr);
2045     return offset;
2046 JNI_END
2047 
2048 JNI_ENTRY_CHECKED(jobject,
2049     checked_jni_CreateSubElementSelector(JNIEnv* env, jarray array))
2050     functionEnter(thr);
2051     jobject selector = UNCHECKED()-&gt;CreateSubElementSelector(env, array);
2052     functionExit(thr);
2053     return selector;
2054 JNI_END
2055 
2056 JNI_ENTRY_CHECKED(jobject,
2057     checked_jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
2058     functionEnter(thr);
2059     jobject res = UNCHECKED()-&gt;GetSubElementSelector(env, selector, fieldID);
2060     functionExit(thr);
2061     return res;
2062 JNI_END
2063 
2064 JNI_ENTRY_CHECKED(jobject,
2065     checked_jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2066     functionEnter(thr);
2067     jobject res = UNCHECKED()-&gt;GetObjectSubElement(env, array, selector, index);
2068     functionExit(thr);
2069     return res;
2070 JNI_END
2071 
2072 JNI_ENTRY_CHECKED(void,
2073     checked_jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
2074     functionEnter(thr);
2075     UNCHECKED()-&gt;SetObjectSubElement(env, array, selector, index, value);
2076     functionExit(thr);
2077     return;
2078 JNI_END
2079 
2080 JNI_ENTRY_CHECKED(jboolean,
2081     checked_jni_GetBooleanSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2082     functionEnter(thr);
2083     jboolean res = UNCHECKED()-&gt;GetBooleanSubElement(env, array, selector, index);
2084     functionExit(thr);
2085     return res;
2086 JNI_END
2087 
2088 JNI_ENTRY_CHECKED(void,
2089     checked_jni_SetBooleanSubElement(JNIEnv* env, jarray array, jobject selector, int index, jboolean value))
2090     functionEnter(thr);
2091     UNCHECKED()-&gt;SetBooleanSubElement(env, array, selector, index, value);
2092     functionExit(thr);
2093     return;
2094 JNI_END
2095 
2096 JNI_ENTRY_CHECKED(jbyte,
2097     checked_jni_GetByteSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2098     functionEnter(thr);
2099     jbyte res = UNCHECKED()-&gt;GetByteSubElement(env, array, selector, index);
2100     functionExit(thr);
2101     return res;
2102 JNI_END
2103 
2104 JNI_ENTRY_CHECKED(void,
2105     checked_jni_SetByteSubElement(JNIEnv* env, jarray array, jobject selector, int index, jbyte value))
2106     functionEnter(thr);
2107     UNCHECKED()-&gt;SetByteSubElement(env, array, selector, index, value);
2108     functionExit(thr);
2109     return;
2110 JNI_END
2111 
2112 JNI_ENTRY_CHECKED(jshort,
2113     checked_jni_GetShortSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2114     functionEnter(thr);
2115     jshort res = UNCHECKED()-&gt;GetShortSubElement(env, array, selector, index);
2116     functionExit(thr);
2117     return res;
2118 JNI_END
2119 
2120 JNI_ENTRY_CHECKED(void,
2121     checked_jni_SetShortSubElement(JNIEnv* env, jarray array, jobject selector, int index, jshort value))
2122     functionEnter(thr);
2123     UNCHECKED()-&gt;SetShortSubElement(env, array, selector, index, value);
2124     functionExit(thr);
2125     return;
2126 JNI_END
2127 
2128 JNI_ENTRY_CHECKED(jchar,
2129     checked_jni_GetCharSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2130     functionEnter(thr);
2131     jchar res = UNCHECKED()-&gt;GetCharSubElement(env, array, selector, index);
2132     functionExit(thr);
2133     return res;
2134 JNI_END
2135 
2136 JNI_ENTRY_CHECKED(void,
2137     checked_jni_SetCharSubElement(JNIEnv* env, jarray array, jobject selector, int index, jchar value))
2138     functionEnter(thr);
2139     UNCHECKED()-&gt;SetCharSubElement(env, array, selector, index, value);
2140     functionExit(thr);
2141     return;
2142 JNI_END
2143 
2144 JNI_ENTRY_CHECKED(jint,
2145     checked_jni_GetIntSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2146     functionEnter(thr);
2147     jint res = UNCHECKED()-&gt;GetIntSubElement(env, array, selector, index);
2148     functionExit(thr);
2149     return res;
2150 JNI_END
2151 
2152 JNI_ENTRY_CHECKED(void,
2153     checked_jni_SetIntSubElement(JNIEnv* env, jarray array, jobject selector, int index, jint value))
2154     functionEnter(thr);
2155     UNCHECKED()-&gt;SetIntSubElement(env, array, selector, index, value);
2156     functionExit(thr);
2157     return;
2158 JNI_END
2159 
2160 JNI_ENTRY_CHECKED(jlong,
2161     checked_jni_GetLongSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2162     functionEnter(thr);
2163     jlong res = UNCHECKED()-&gt;GetLongSubElement(env, array, selector, index);
2164     functionExit(thr);
2165     return res;
2166 JNI_END
2167 
2168 JNI_ENTRY_CHECKED(void,
2169     checked_jni_SetLongSubElement(JNIEnv* env, jarray array, jobject selector, int index, jlong value))
2170     functionEnter(thr);
2171     UNCHECKED()-&gt;SetLongSubElement(env, array, selector, index, value);
2172     functionExit(thr);
2173     return;
2174 JNI_END
2175 
2176 JNI_ENTRY_CHECKED(jfloat,
2177     checked_jni_GetFloatSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2178     functionEnter(thr);
2179     jfloat res = UNCHECKED()-&gt;GetFloatSubElement(env, array, selector, index);
2180     functionExit(thr);
2181     return res;
2182 JNI_END
2183 
2184 JNI_ENTRY_CHECKED(void,
2185     checked_jni_SetFloatSubElement(JNIEnv* env, jarray array, jobject selector, int index, jfloat value))
2186     functionEnter(thr);
2187     UNCHECKED()-&gt;SetFloatSubElement(env, array, selector, index, value);
2188     functionExit(thr);
2189     return;
2190 JNI_END
2191 
2192 JNI_ENTRY_CHECKED(jdouble,
2193     checked_jni_GetDoubleSubElement(JNIEnv* env, jarray array, jobject selector, int index))
2194     functionEnter(thr);
2195     jdouble res = UNCHECKED()-&gt;GetDoubleSubElement(env, array, selector, index);
2196     functionExit(thr);
2197     return res;
2198 JNI_END
2199 
2200 JNI_ENTRY_CHECKED(void,
2201     checked_jni_SetDoubleSubElement(JNIEnv* env, jarray array, jobject selector, int index, jdouble value))
2202     functionEnter(thr);
2203     UNCHECKED()-&gt;SetDoubleSubElement(env, array, selector, index, value);
2204     functionExit(thr);
2205     return;
2206 JNI_END
2207 
2208 /*
2209  * Structure containing all checked jni functions
2210  */
2211 struct JNINativeInterface_  checked_jni_NativeInterface = {
2212     NULL,
2213     NULL,
2214     NULL,
2215 
2216     NULL,
2217 
2218     checked_jni_GetVersion,
2219 
2220     checked_jni_DefineClass,
2221     checked_jni_FindClass,
2222 
2223     checked_jni_FromReflectedMethod,
2224     checked_jni_FromReflectedField,
2225 
2226     checked_jni_ToReflectedMethod,
2227 
2228     checked_jni_GetSuperclass,
2229     checked_jni_IsAssignableFrom,
2230 
2231     checked_jni_ToReflectedField,
2232 
2233     checked_jni_Throw,
2234     checked_jni_ThrowNew,
2235     checked_jni_ExceptionOccurred,
2236     checked_jni_ExceptionDescribe,
2237     checked_jni_ExceptionClear,
2238     checked_jni_FatalError,
2239 
2240     checked_jni_PushLocalFrame,
2241     checked_jni_PopLocalFrame,
2242 
2243     checked_jni_NewGlobalRef,
2244     checked_jni_DeleteGlobalRef,
2245     checked_jni_DeleteLocalRef,
2246     checked_jni_IsSameObject,
2247 
2248     checked_jni_NewLocalRef,
2249     checked_jni_EnsureLocalCapacity,
2250 
2251     checked_jni_AllocObject,
2252     checked_jni_NewObject,
2253     checked_jni_NewObjectV,
2254     checked_jni_NewObjectA,
2255 
2256     checked_jni_GetObjectClass,
2257     checked_jni_IsInstanceOf,
2258 
2259     checked_jni_GetMethodID,
2260 
2261     checked_jni_CallObjectMethod,
2262     checked_jni_CallObjectMethodV,
2263     checked_jni_CallObjectMethodA,
2264     checked_jni_CallBooleanMethod,
2265     checked_jni_CallBooleanMethodV,
2266     checked_jni_CallBooleanMethodA,
2267     checked_jni_CallByteMethod,
2268     checked_jni_CallByteMethodV,
2269     checked_jni_CallByteMethodA,
2270     checked_jni_CallCharMethod,
2271     checked_jni_CallCharMethodV,
2272     checked_jni_CallCharMethodA,
2273     checked_jni_CallShortMethod,
2274     checked_jni_CallShortMethodV,
2275     checked_jni_CallShortMethodA,
2276     checked_jni_CallIntMethod,
2277     checked_jni_CallIntMethodV,
2278     checked_jni_CallIntMethodA,
2279     checked_jni_CallLongMethod,
2280     checked_jni_CallLongMethodV,
2281     checked_jni_CallLongMethodA,
2282     checked_jni_CallFloatMethod,
2283     checked_jni_CallFloatMethodV,
2284     checked_jni_CallFloatMethodA,
2285     checked_jni_CallDoubleMethod,
2286     checked_jni_CallDoubleMethodV,
2287     checked_jni_CallDoubleMethodA,
2288     checked_jni_CallVoidMethod,
2289     checked_jni_CallVoidMethodV,
2290     checked_jni_CallVoidMethodA,
2291 
2292     checked_jni_CallNonvirtualObjectMethod,
2293     checked_jni_CallNonvirtualObjectMethodV,
2294     checked_jni_CallNonvirtualObjectMethodA,
2295     checked_jni_CallNonvirtualBooleanMethod,
2296     checked_jni_CallNonvirtualBooleanMethodV,
2297     checked_jni_CallNonvirtualBooleanMethodA,
2298     checked_jni_CallNonvirtualByteMethod,
2299     checked_jni_CallNonvirtualByteMethodV,
2300     checked_jni_CallNonvirtualByteMethodA,
2301     checked_jni_CallNonvirtualCharMethod,
2302     checked_jni_CallNonvirtualCharMethodV,
2303     checked_jni_CallNonvirtualCharMethodA,
2304     checked_jni_CallNonvirtualShortMethod,
2305     checked_jni_CallNonvirtualShortMethodV,
2306     checked_jni_CallNonvirtualShortMethodA,
2307     checked_jni_CallNonvirtualIntMethod,
2308     checked_jni_CallNonvirtualIntMethodV,
2309     checked_jni_CallNonvirtualIntMethodA,
2310     checked_jni_CallNonvirtualLongMethod,
2311     checked_jni_CallNonvirtualLongMethodV,
2312     checked_jni_CallNonvirtualLongMethodA,
2313     checked_jni_CallNonvirtualFloatMethod,
2314     checked_jni_CallNonvirtualFloatMethodV,
2315     checked_jni_CallNonvirtualFloatMethodA,
2316     checked_jni_CallNonvirtualDoubleMethod,
2317     checked_jni_CallNonvirtualDoubleMethodV,
2318     checked_jni_CallNonvirtualDoubleMethodA,
2319     checked_jni_CallNonvirtualVoidMethod,
2320     checked_jni_CallNonvirtualVoidMethodV,
2321     checked_jni_CallNonvirtualVoidMethodA,
2322 
2323     checked_jni_GetFieldID,
2324 
2325     checked_jni_GetObjectField,
2326     checked_jni_GetBooleanField,
2327     checked_jni_GetByteField,
2328     checked_jni_GetCharField,
2329     checked_jni_GetShortField,
2330     checked_jni_GetIntField,
2331     checked_jni_GetLongField,
2332     checked_jni_GetFloatField,
2333     checked_jni_GetDoubleField,
2334 
2335     checked_jni_SetObjectField,
2336     checked_jni_SetBooleanField,
2337     checked_jni_SetByteField,
2338     checked_jni_SetCharField,
2339     checked_jni_SetShortField,
2340     checked_jni_SetIntField,
2341     checked_jni_SetLongField,
2342     checked_jni_SetFloatField,
2343     checked_jni_SetDoubleField,
2344 
2345     checked_jni_GetStaticMethodID,
2346 
2347     checked_jni_CallStaticObjectMethod,
2348     checked_jni_CallStaticObjectMethodV,
2349     checked_jni_CallStaticObjectMethodA,
2350     checked_jni_CallStaticBooleanMethod,
2351     checked_jni_CallStaticBooleanMethodV,
2352     checked_jni_CallStaticBooleanMethodA,
2353     checked_jni_CallStaticByteMethod,
2354     checked_jni_CallStaticByteMethodV,
2355     checked_jni_CallStaticByteMethodA,
2356     checked_jni_CallStaticCharMethod,
2357     checked_jni_CallStaticCharMethodV,
2358     checked_jni_CallStaticCharMethodA,
2359     checked_jni_CallStaticShortMethod,
2360     checked_jni_CallStaticShortMethodV,
2361     checked_jni_CallStaticShortMethodA,
2362     checked_jni_CallStaticIntMethod,
2363     checked_jni_CallStaticIntMethodV,
2364     checked_jni_CallStaticIntMethodA,
2365     checked_jni_CallStaticLongMethod,
2366     checked_jni_CallStaticLongMethodV,
2367     checked_jni_CallStaticLongMethodA,
2368     checked_jni_CallStaticFloatMethod,
2369     checked_jni_CallStaticFloatMethodV,
2370     checked_jni_CallStaticFloatMethodA,
2371     checked_jni_CallStaticDoubleMethod,
2372     checked_jni_CallStaticDoubleMethodV,
2373     checked_jni_CallStaticDoubleMethodA,
2374     checked_jni_CallStaticVoidMethod,
2375     checked_jni_CallStaticVoidMethodV,
2376     checked_jni_CallStaticVoidMethodA,
2377 
2378     checked_jni_GetStaticFieldID,
2379 
2380     checked_jni_GetStaticObjectField,
2381     checked_jni_GetStaticBooleanField,
2382     checked_jni_GetStaticByteField,
2383     checked_jni_GetStaticCharField,
2384     checked_jni_GetStaticShortField,
2385     checked_jni_GetStaticIntField,
2386     checked_jni_GetStaticLongField,
2387     checked_jni_GetStaticFloatField,
2388     checked_jni_GetStaticDoubleField,
2389 
2390     checked_jni_SetStaticObjectField,
2391     checked_jni_SetStaticBooleanField,
2392     checked_jni_SetStaticByteField,
2393     checked_jni_SetStaticCharField,
2394     checked_jni_SetStaticShortField,
2395     checked_jni_SetStaticIntField,
2396     checked_jni_SetStaticLongField,
2397     checked_jni_SetStaticFloatField,
2398     checked_jni_SetStaticDoubleField,
2399 
2400     checked_jni_NewString,
2401     checked_jni_GetStringLength,
2402     checked_jni_GetStringChars,
2403     checked_jni_ReleaseStringChars,
2404 
2405     checked_jni_NewStringUTF,
2406     checked_jni_GetStringUTFLength,
2407     checked_jni_GetStringUTFChars,
2408     checked_jni_ReleaseStringUTFChars,
2409 
2410     checked_jni_GetArrayLength,
2411 
2412     checked_jni_NewObjectArray,
2413     checked_jni_GetObjectArrayElement,
2414     checked_jni_SetObjectArrayElement,
2415 
2416     checked_jni_NewBooleanArray,
2417     checked_jni_NewByteArray,
2418     checked_jni_NewCharArray,
2419     checked_jni_NewShortArray,
2420     checked_jni_NewIntArray,
2421     checked_jni_NewLongArray,
2422     checked_jni_NewFloatArray,
2423     checked_jni_NewDoubleArray,
2424 
2425     checked_jni_GetBooleanArrayElements,
2426     checked_jni_GetByteArrayElements,
2427     checked_jni_GetCharArrayElements,
2428     checked_jni_GetShortArrayElements,
2429     checked_jni_GetIntArrayElements,
2430     checked_jni_GetLongArrayElements,
2431     checked_jni_GetFloatArrayElements,
2432     checked_jni_GetDoubleArrayElements,
2433 
2434     checked_jni_ReleaseBooleanArrayElements,
2435     checked_jni_ReleaseByteArrayElements,
2436     checked_jni_ReleaseCharArrayElements,
2437     checked_jni_ReleaseShortArrayElements,
2438     checked_jni_ReleaseIntArrayElements,
2439     checked_jni_ReleaseLongArrayElements,
2440     checked_jni_ReleaseFloatArrayElements,
2441     checked_jni_ReleaseDoubleArrayElements,
2442 
2443     checked_jni_GetBooleanArrayRegion,
2444     checked_jni_GetByteArrayRegion,
2445     checked_jni_GetCharArrayRegion,
2446     checked_jni_GetShortArrayRegion,
2447     checked_jni_GetIntArrayRegion,
2448     checked_jni_GetLongArrayRegion,
2449     checked_jni_GetFloatArrayRegion,
2450     checked_jni_GetDoubleArrayRegion,
2451 
2452     checked_jni_SetBooleanArrayRegion,
2453     checked_jni_SetByteArrayRegion,
2454     checked_jni_SetCharArrayRegion,
2455     checked_jni_SetShortArrayRegion,
2456     checked_jni_SetIntArrayRegion,
2457     checked_jni_SetLongArrayRegion,
2458     checked_jni_SetFloatArrayRegion,
2459     checked_jni_SetDoubleArrayRegion,
2460 
2461     checked_jni_RegisterNatives,
2462     checked_jni_UnregisterNatives,
2463 
2464     checked_jni_MonitorEnter,
2465     checked_jni_MonitorExit,
2466 
2467     checked_jni_GetJavaVM,
2468 
2469     checked_jni_GetStringRegion,
2470     checked_jni_GetStringUTFRegion,
2471 
2472     checked_jni_GetPrimitiveArrayCritical,
2473     checked_jni_ReleasePrimitiveArrayCritical,
2474 
2475     checked_jni_GetStringCritical,
2476     checked_jni_ReleaseStringCritical,
2477 
2478     checked_jni_NewWeakGlobalRef,
2479     checked_jni_DeleteWeakGlobalRef,
2480 
2481     checked_jni_ExceptionCheck,
2482 
2483     checked_jni_NewDirectByteBuffer,
2484     checked_jni_GetDirectBufferAddress,
2485     checked_jni_GetDirectBufferCapacity,
2486 
2487     // New 1.6 Features
2488 
2489     checked_jni_GetObjectRefType,
2490 
2491     // Module Features
2492 
2493     checked_jni_GetModule,
2494 
2495     // Flattened arrays Features
2496     checked_jni_GetFlattenedArrayElements,
2497     checked_jni_ReleaseFlattenedArrayElements,
2498     checked_jni_GetFlattenedArrayElementClass,
2499     checked_jni_GetFlattenedArrayElementSize,
2500     checked_jni_GetFieldOffsetInFlattenedLayout,
2501 
2502     checked_jni_CreateSubElementSelector,
2503     checked_jni_GetSubElementSelector,
2504     checked_jni_GetObjectSubElement,
2505     checked_jni_SetObjectSubElement,
2506 
2507     checked_jni_GetBooleanSubElement,
2508     checked_jni_GetByteSubElement,
2509     checked_jni_GetShortSubElement,
2510     checked_jni_GetCharSubElement,
2511     checked_jni_GetIntSubElement,
2512     checked_jni_GetLongSubElement,
2513     checked_jni_GetFloatSubElement,
2514     checked_jni_GetDoubleSubElement,
2515 
2516     checked_jni_SetBooleanSubElement,
2517     checked_jni_SetByteSubElement,
2518     checked_jni_SetShortSubElement,
2519     checked_jni_SetCharSubElement,
2520     checked_jni_SetIntSubElement,
2521     checked_jni_SetLongSubElement,
2522     checked_jni_SetFloatSubElement,
2523     checked_jni_SetDoubleSubElement
2524 };
2525 
2526 
2527 // Returns the function structure
2528 struct JNINativeInterface_* jni_functions_check() {
2529 
2530   unchecked_jni_NativeInterface = jni_functions_nocheck();
2531 
2532   // make sure the last pointer in the checked table is not null, indicating
2533   // an addition to the JNINativeInterface_ structure without initializing
2534   // it in the checked table.
2535   debug_only(int *lastPtr = (int *)((char *)&amp;checked_jni_NativeInterface + \
2536              sizeof(*unchecked_jni_NativeInterface) - sizeof(char *));)
2537   assert(*lastPtr != 0,
2538          &quot;Mismatched JNINativeInterface tables, check for new entries&quot;);
2539 
2540   // with -verbose:jni this message will print
2541   log_debug(jni, resolve)(&quot;Checked JNI functions are being used to validate JNI usage&quot;);
2542 
2543   return &amp;checked_jni_NativeInterface;
2544 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
  39 #include &quot;gc/shared/softRefPolicy.hpp&quot;
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/bytecodes.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
  62 #include &quot;oops/valueArrayKlass.hpp&quot;
  63 #include &quot;oops/valueKlass.hpp&quot;
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
<a name="1" id="anc1"></a>
  74 #include &quot;utilities/defaultStream.hpp&quot;
  75 #include &quot;utilities/hashtable.inline.hpp&quot;
  76 #if INCLUDE_G1GC
  77 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  78 #endif
  79 
  80 ReservedSpace MetaspaceShared::_shared_rs;
  81 VirtualSpace MetaspaceShared::_shared_vs;
  82 ReservedSpace MetaspaceShared::_symbol_rs;
  83 VirtualSpace MetaspaceShared::_symbol_vs;
  84 MetaspaceSharedStats MetaspaceShared::_stats;
  85 bool MetaspaceShared::_has_error_classes;
  86 bool MetaspaceShared::_archive_loading_failed = false;
  87 bool MetaspaceShared::_remapped_readwrite = false;
  88 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
  89 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
  90 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
  91 intx MetaspaceShared::_relocation_delta;
  92 
  93 // The CDS archive is divided into the following regions:
  94 //     mc  - misc code (the method entry trampolines, c++ vtables)
  95 //     rw  - read-write metadata
  96 //     ro  - read-only metadata and read-only tables
  97 //
  98 //     ca0 - closed archive heap space #0
  99 //     ca1 - closed archive heap space #1 (may be empty)
 100 //     oa0 - open archive heap space #0
 101 //     oa1 - open archive heap space #1 (may be empty)
 102 //
 103 // The mc, rw, and ro regions are linearly allocated, starting from
 104 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro. The size of these 3 regions
 105 // are page-aligned, and there&#39;s no gap between any consecutive regions.
 106 //
 107 // These 3 regions are populated in the following steps:
 108 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 109 //     temporarily allocated outside of the shared regions. Only the method entry
 110 //     trampolines are written into the mc region.
 111 // [2] C++ vtables are copied into the mc region.
 112 // [3] ArchiveCompactor copies RW metadata into the rw region.
 113 // [4] ArchiveCompactor copies RO metadata into the ro region.
 114 // [5] SymbolTable, StringTable, SystemDictionary, and a few other read-only data
 115 //     are copied into the ro region as read-only tables.
 116 //
 117 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
 118 // Their layout is independent of the other 4 regions.
 119 
 120 char* DumpRegion::expand_top_to(char* newtop) {
 121   assert(is_allocatable(), &quot;must be initialized and not packed&quot;);
 122   assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);
 123   if (newtop &gt; _end) {
 124     MetaspaceShared::report_out_of_space(_name, newtop - _top);
 125     ShouldNotReachHere();
 126   }
 127 
 128   if (_rs == MetaspaceShared::shared_rs()) {
 129     uintx delta;
 130     if (DynamicDumpSharedSpaces) {
 131       delta = DynamicArchive::object_delta_uintx(newtop);
 132     } else {
 133       delta = MetaspaceShared::object_delta_uintx(newtop);
 134     }
 135     if (delta &gt; MAX_SHARED_DELTA) {
 136       // This is just a sanity check and should not appear in any real world usage. This
 137       // happens only if you allocate more than 2GB of shared objects and would require
 138       // millions of shared classes.
 139       vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,
 140                                     &quot;Please reduce the number of shared classes.&quot;);
 141     }
 142   }
 143 
 144   MetaspaceShared::commit_to(_rs, _vs, newtop);
 145   _top = newtop;
 146   return _top;
 147 }
 148 
 149 char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {
 150   char* p = (char*)align_up(_top, alignment);
 151   char* newtop = p + align_up(num_bytes, alignment);
 152   expand_top_to(newtop);
 153   memset(p, 0, newtop - p);
 154   return p;
 155 }
 156 
 157 void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {
 158   assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);
 159   intptr_t *p = (intptr_t*)_top;
 160   char* newtop = _top + sizeof(intptr_t);
 161   expand_top_to(newtop);
 162   *p = n;
 163   if (need_to_mark) {
 164     ArchivePtrMarker::mark_pointer(p);
 165   }
 166 }
 167 
 168 void DumpRegion::print(size_t total_bytes) const {
 169   log_debug(cds)(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,
 170                  _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),
 171                  p2i(_base + MetaspaceShared::final_delta()));
 172 }
 173 
 174 void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {
 175   log_error(cds)(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,
 176                  _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));
 177   if (strcmp(_name, failing_region) == 0) {
 178     log_error(cds)(&quot; required = %d&quot;, int(needed_bytes));
 179   }
 180 }
 181 
 182 void DumpRegion::init(ReservedSpace* rs, VirtualSpace* vs) {
 183   _rs = rs;
 184   _vs = vs;
 185   // Start with 0 committed bytes. The memory will be committed as needed by
 186   // MetaspaceShared::commit_to().
 187   if (!_vs-&gt;initialize(*_rs, 0)) {
 188     fatal(&quot;Unable to allocate memory for shared space&quot;);
 189   }
 190   _base = _top = _rs-&gt;base();
 191   _end = _rs-&gt;end();
 192 }
 193 
 194 void DumpRegion::pack(DumpRegion* next) {
 195   assert(!is_packed(), &quot;sanity&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 196   _end = (char*)align_up(_top, Metaspace::reserve_alignment());</span>
 197   _is_packed = true;
 198   if (next != NULL) {
 199     next-&gt;_rs = _rs;
 200     next-&gt;_vs = _vs;
 201     next-&gt;_base = next-&gt;_top = this-&gt;_end;
 202     next-&gt;_end = _rs-&gt;end();
 203   }
 204 }
 205 
 206 static DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;), _symbol_region(&quot;symbols&quot;);
 207 static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;
 208 
 209 void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space) {
 210   first_space-&gt;init(&amp;_shared_rs, &amp;_shared_vs);
 211 }
 212 
 213 DumpRegion* MetaspaceShared::misc_code_dump_space() {
 214   return &amp;_mc_region;
 215 }
 216 
 217 DumpRegion* MetaspaceShared::read_write_dump_space() {
 218   return &amp;_rw_region;
 219 }
 220 
 221 DumpRegion* MetaspaceShared::read_only_dump_space() {
 222   return &amp;_ro_region;
 223 }
 224 
 225 void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,
 226                                       ReservedSpace* rs) {
 227   current-&gt;pack(next);
 228 }
 229 
 230 char* MetaspaceShared::symbol_space_alloc(size_t num_bytes) {
 231   return _symbol_region.allocate(num_bytes);
 232 }
 233 
 234 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 235   return _mc_region.allocate(num_bytes);
 236 }
 237 
 238 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 239   return _ro_region.allocate(num_bytes);
 240 }
 241 
<a name="3" id="anc3"></a><span class="line-modified"> 242 // When reserving an address range using ReservedSpace, we need an alignment that satisfies both:</span>
<span class="line-removed"> 243 // os::vm_allocation_granularity() -- so that we can sub-divide this range into multiple mmap regions,</span>
<span class="line-removed"> 244 //                                    while keeping the first range at offset 0 of this range.</span>
<span class="line-removed"> 245 // Metaspace::reserve_alignment()  -- so we can pass the region to</span>
<span class="line-removed"> 246 //                                    Metaspace::allocate_metaspace_compressed_klass_ptrs.</span>
<span class="line-removed"> 247 size_t MetaspaceShared::reserved_space_alignment() {</span>
<span class="line-removed"> 248   size_t os_align = os::vm_allocation_granularity();</span>
<span class="line-removed"> 249   size_t ms_align = Metaspace::reserve_alignment();</span>
<span class="line-removed"> 250   if (os_align &gt;= ms_align) {</span>
<span class="line-removed"> 251     assert(os_align % ms_align == 0, &quot;must be a multiple&quot;);</span>
<span class="line-removed"> 252     return os_align;</span>
<span class="line-removed"> 253   } else {</span>
<span class="line-removed"> 254     assert(ms_align % os_align == 0, &quot;must be a multiple&quot;);</span>
<span class="line-removed"> 255     return ms_align;</span>
<span class="line-removed"> 256   }</span>
<span class="line-removed"> 257 }</span>
 258 
<a name="4" id="anc4"></a><span class="line-modified"> 259 ReservedSpace MetaspaceShared::reserve_shared_space(size_t size, char* requested_address) {</span>
<span class="line-modified"> 260   return Metaspace::reserve_space(size, reserved_space_alignment(),</span>
<span class="line-modified"> 261                                   requested_address, requested_address != NULL);</span>









 262 }
<a name="5" id="anc5"></a>
 263 
 264 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 265   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 266   const size_t reserve_alignment = reserved_space_alignment();</span>





 267   char* shared_base = (char*)align_up((char*)SharedBaseAddress, reserve_alignment);
 268 
 269 #ifdef _LP64
<a name="7" id="anc7"></a><span class="line-modified"> 270   // On 64-bit VM, the heap and class space layout will be the same as if</span>
<span class="line-modified"> 271   // you&#39;re running in -Xshare:on mode:</span>
<span class="line-modified"> 272   //</span>
<span class="line-modified"> 273   //                              +-- SharedBaseAddress (default = 0x800000000)</span>
<span class="line-removed"> 274   //                              v</span>
<span class="line-removed"> 275   // +-..---------+---------+ ... +----+----+----+--------------------+</span>
<span class="line-removed"> 276   // |    Heap    | Archive |     | MC | RW | RO |    class space     |</span>
<span class="line-removed"> 277   // +-..---------+---------+ ... +----+----+----+--------------------+</span>
<span class="line-removed"> 278   // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB --&gt;|</span>
<span class="line-removed"> 279   //</span>
 280   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 281   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 282 #else
<a name="8" id="anc8"></a><span class="line-modified"> 283   // We don&#39;t support archives larger than 256MB on 32-bit due to limited virtual address space.</span>

 284   size_t cds_total = align_down(256*M, reserve_alignment);
 285 #endif
 286 
<a name="9" id="anc9"></a>
 287   bool use_requested_base = true;
<a name="10" id="anc10"></a>




 288   if (ArchiveRelocationMode == 1) {
 289     log_info(cds)(&quot;ArchiveRelocationMode == 1: always allocate class space at an alternative address&quot;);
 290     use_requested_base = false;
 291   }
 292 
 293   // First try to reserve the space at the specified SharedBaseAddress.
 294   assert(!_shared_rs.is_reserved(), &quot;must be&quot;);
 295   if (use_requested_base) {
<a name="11" id="anc11"></a><span class="line-modified"> 296     _shared_rs = reserve_shared_space(cds_total, shared_base);</span>







 297   }
<a name="12" id="anc12"></a><span class="line-modified"> 298   if (_shared_rs.is_reserved()) {</span>
<span class="line-modified"> 299     assert(shared_base == 0 || _shared_rs.base() == shared_base, &quot;should match&quot;);</span>
<span class="line-modified"> 300   } else {</span>
<span class="line-modified"> 301     // Get a mmap region anywhere if the SharedBaseAddress fails.</span>
<span class="line-modified"> 302     _shared_rs = reserve_shared_space(cds_total);</span>









 303   }
<a name="13" id="anc13"></a>
 304   if (!_shared_rs.is_reserved()) {
 305     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 306                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 307   }
 308 
 309 #ifdef _LP64
<a name="14" id="anc14"></a><span class="line-removed"> 310   // During dump time, we allocate 4GB (UnscaledClassSpaceMax) of space and split it up:</span>
<span class="line-removed"> 311   // + The upper 1 GB is used as the &quot;temporary compressed class space&quot; -- preload_classes()</span>
<span class="line-removed"> 312   //   will store Klasses into this space.</span>
<span class="line-removed"> 313   // + The lower 3 GB is used for the archive -- when preload_classes() is done,</span>
<span class="line-removed"> 314   //   ArchiveCompactor will copy the class metadata into this space, first the RW parts,</span>
<span class="line-removed"> 315   //   then the RO parts.</span>
<span class="line-removed"> 316 </span>
<span class="line-removed"> 317   size_t max_archive_size = align_down(cds_total * 3 / 4, reserve_alignment);</span>
<span class="line-removed"> 318   ReservedSpace tmp_class_space = _shared_rs.last_part(max_archive_size);</span>
<span class="line-removed"> 319   CompressedClassSpaceSize = align_down(tmp_class_space.size(), reserve_alignment);</span>
<span class="line-removed"> 320   _shared_rs = _shared_rs.first_part(max_archive_size);</span>
 321 
 322   if (UseCompressedClassPointers) {
<a name="15" id="anc15"></a><span class="line-modified"> 323     // Set up compress class pointers.</span>
<span class="line-modified"> 324     CompressedKlassPointers::set_base((address)_shared_rs.base());</span>
<span class="line-modified"> 325     // Set narrow_klass_shift to be LogKlassAlignmentInBytes. This is consistent</span>
<span class="line-modified"> 326     // with AOT.</span>
<span class="line-modified"> 327     CompressedKlassPointers::set_shift(LogKlassAlignmentInBytes);</span>
<span class="line-modified"> 328     // Set the range of klass addresses to 4GB.</span>
<span class="line-modified"> 329     CompressedKlassPointers::set_range(cds_total);</span>









































 330     Metaspace::initialize_class_space(tmp_class_space);
<a name="16" id="anc16"></a>













 331   }
<a name="17" id="anc17"></a><span class="line-removed"> 332   log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,</span>
<span class="line-removed"> 333                 p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335   log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,</span>
 336                 CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 337 #endif
 338 
 339   init_shared_dump_space(&amp;_mc_region);
 340   SharedBaseAddress = (size_t)_shared_rs.base();
 341   log_info(cds)(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 342                 _shared_rs.size(), p2i(_shared_rs.base()));
 343 
 344   size_t symbol_rs_size = LP64_ONLY(3 * G) NOT_LP64(128 * M);
 345   _symbol_rs = ReservedSpace(symbol_rs_size);
 346   if (!_symbol_rs.is_reserved()) {
 347     vm_exit_during_initialization(&quot;Unable to reserve memory for symbols&quot;,
 348                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, symbol_rs_size));
 349   }
 350   _symbol_region.init(&amp;_symbol_rs, &amp;_symbol_vs);
 351 }
 352 
 353 // Called by universe_post_init()
 354 void MetaspaceShared::post_initialize(TRAPS) {
 355   if (UseSharedSpaces) {
 356     int size = FileMapInfo::get_number_of_shared_paths();
 357     if (size &gt; 0) {
 358       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 359       if (!DynamicDumpSharedSpaces) {
 360         FileMapInfo* info;
 361         if (FileMapInfo::dynamic_info() == NULL) {
 362           info = FileMapInfo::current_info();
 363         } else {
 364           info = FileMapInfo::dynamic_info();
 365         }
 366         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 367         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 368       }
 369     }
 370   }
 371 }
 372 
 373 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;
 374 
 375 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 376   _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;Handle&gt;(10000, true);
 377 
 378   HashtableTextDump reader(filename);
 379   reader.check_version(&quot;VERSION: 1.0&quot;);
 380 
 381   while (reader.remain() &gt; 0) {
 382     int utf8_length;
 383     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 384     ResourceMark rm(THREAD);
 385     if (utf8_length == 0x7fffffff) {
 386       // buf_len will overflown 32-bit value.
 387       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 388     }
 389     int buf_len = utf8_length+1;
 390     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 391     reader.get_utf8(utf8_buffer, utf8_length);
 392     utf8_buffer[utf8_length] = &#39;\0&#39;;
 393 
 394     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 395       SymbolTable::new_permanent_symbol(utf8_buffer);
 396     } else{
 397       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 398       oop s = StringTable::intern(utf8_buffer, THREAD);
 399 
 400       if (HAS_PENDING_EXCEPTION) {
 401         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 402                                reader.last_line_no(), utf8_length);
 403         CLEAR_PENDING_EXCEPTION;
 404       } else {
 405 #if INCLUDE_G1GC
 406         if (UseG1GC) {
 407           typeArrayOop body = java_lang_String::value(s);
 408           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 409           if (hr-&gt;is_humongous()) {
 410             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 411             // to maximize free heap space and minimize fragmentation.
 412             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 413                                 reader.last_line_no(), utf8_length);
 414             continue;
 415           }
 416         }
 417 #endif
 418         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 419         // add a reference to keep this string alive.
 420         assert(s != NULL, &quot;must succeed&quot;);
 421         Handle h(THREAD, s);
 422         _extra_interned_strings-&gt;append(h);
 423       }
 424     }
 425   }
 426 }
 427 
 428 void MetaspaceShared::commit_to(ReservedSpace* rs, VirtualSpace* vs, char* newtop) {
 429   Arguments::assert_is_dumping_archive();
 430   char* base = rs-&gt;base();
 431   size_t need_committed_size = newtop - base;
 432   size_t has_committed_size = vs-&gt;committed_size();
 433   if (need_committed_size &lt; has_committed_size) {
 434     return;
 435   }
 436 
 437   size_t min_bytes = need_committed_size - has_committed_size;
 438   size_t preferred_bytes = 1 * M;
 439   size_t uncommitted = vs-&gt;reserved_size() - has_committed_size;
 440 
 441   size_t commit =MAX2(min_bytes, preferred_bytes);
 442   commit = MIN2(commit, uncommitted);
 443   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 444 
 445   bool result = vs-&gt;expand_by(commit, false);
 446   if (rs == &amp;_shared_rs) {
 447     ArchivePtrMarker::expand_ptr_end((address*)vs-&gt;high());
 448   }
 449 
 450   if (!result) {
 451     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 452                                           need_committed_size));
 453   }
 454 
 455   assert(rs == &amp;_shared_rs || rs == &amp;_symbol_rs, &quot;must be&quot;);
 456   const char* which = (rs == &amp;_shared_rs) ? &quot;shared&quot; : &quot;symbol&quot;;
 457   log_debug(cds)(&quot;Expanding %s spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,
 458                  which, commit, vs-&gt;actual_committed_size(), vs-&gt;high());
 459 }
 460 
 461 void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {
 462   ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());
 463 }
 464 
 465 // Read/write a data stream for restoring/preserving metadata pointers and
 466 // miscellaneous data from/to the shared archive file.
 467 
 468 void MetaspaceShared::serialize(SerializeClosure* soc) {
 469   int tag = 0;
 470   soc-&gt;do_tag(--tag);
 471 
 472   // Verify the sizes of various metadata in the system.
 473   soc-&gt;do_tag(sizeof(Method));
 474   soc-&gt;do_tag(sizeof(ConstMethod));
 475   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 476   soc-&gt;do_tag(sizeof(ConstantPool));
 477   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 478   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 479   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 480   soc-&gt;do_tag(sizeof(Symbol));
 481 
 482   // Dump/restore miscellaneous metadata.
 483   JavaClasses::serialize_offsets(soc);
 484   Universe::serialize(soc);
 485   soc-&gt;do_tag(--tag);
 486 
 487   // Dump/restore references to commonly used names and signatures.
 488   vmSymbols::serialize(soc);
 489   soc-&gt;do_tag(--tag);
 490 
 491   // Dump/restore the symbol/string/subgraph_info tables
 492   SymbolTable::serialize_shared_table_header(soc);
 493   StringTable::serialize_shared_table_header(soc);
 494   HeapShared::serialize_subgraph_info_table_header(soc);
 495   SystemDictionaryShared::serialize_dictionary_headers(soc);
 496 
 497   InstanceMirrorKlass::serialize_offsets(soc);
 498 
 499   // Dump/restore well known classes (pointers)
 500   SystemDictionaryShared::serialize_well_known_klasses(soc);
 501   soc-&gt;do_tag(--tag);
 502 
 503   serialize_cloned_cpp_vtptrs(soc);
 504   soc-&gt;do_tag(--tag);
 505 
 506   soc-&gt;do_tag(666);
 507 }
 508 
 509 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 510   if (DumpSharedSpaces) {
 511     if (_i2i_entry_code_buffers == NULL) {
 512       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 513       _i2i_entry_code_buffers_size = total_size;
 514     }
 515   } else if (UseSharedSpaces) {
 516     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 517   } else {
 518     return NULL;
 519   }
 520 
 521   assert(_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);
 522   return _i2i_entry_code_buffers;
 523 }
 524 
 525 uintx MetaspaceShared::object_delta_uintx(void* obj) {
 526   Arguments::assert_is_dumping_archive();
 527   if (DumpSharedSpaces) {
 528     assert(shared_rs()-&gt;contains(obj), &quot;must be&quot;);
 529   } else {
 530     assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), &quot;must be&quot;);
 531   }
 532   address base_address = address(SharedBaseAddress);
 533   uintx deltax = address(obj) - base_address;
 534   return deltax;
 535 }
 536 
 537 // Global object for holding classes that have been loaded.  Since this
 538 // is run at a safepoint just before exit, this is the entire set of classes.
 539 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 540 
 541 static int global_klass_compare(Klass** a, Klass **b) {
 542   return a[0]-&gt;name()-&gt;fast_compare(b[0]-&gt;name());
 543 }
 544 
 545 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 546   return _global_klass_objects;
 547 }
 548 
 549 static void collect_array_classes(Klass* k) {
 550   _global_klass_objects-&gt;append_if_missing(k);
 551   if (k-&gt;is_array_klass()) {
 552     // Add in the array classes too
 553     ArrayKlass* ak = ArrayKlass::cast(k);
 554     Klass* h = ak-&gt;higher_dimension();
 555     if (h != NULL) {
 556       h-&gt;array_klasses_do(collect_array_classes);
 557     }
 558   }
 559 }
 560 
 561 class CollectClassesClosure : public KlassClosure {
 562   void do_klass(Klass* k) {
 563     if (k-&gt;is_instance_klass() &amp;&amp;
 564         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 565       // Don&#39;t add to the _global_klass_objects
 566     } else {
 567       _global_klass_objects-&gt;append_if_missing(k);
 568     }
 569     if (k-&gt;is_array_klass()) {
 570       // Add in the array classes too
 571       ArrayKlass* ak = ArrayKlass::cast(k);
 572       Klass* h = ak-&gt;higher_dimension();
 573       if (h != NULL) {
 574         h-&gt;array_klasses_do(collect_array_classes);
 575       }
 576     }
 577   }
 578 };
 579 
 580 static void remove_unshareable_in_classes() {
 581   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 582     Klass* k = _global_klass_objects-&gt;at(i);
 583     if (!k-&gt;is_objArray_klass()) {
 584       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 585       // on their array classes.
 586       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 587       k-&gt;remove_unshareable_info();
 588     }
 589   }
 590 }
 591 
 592 static void remove_java_mirror_in_classes() {
 593   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 594     Klass* k = _global_klass_objects-&gt;at(i);
 595     if (!k-&gt;is_objArray_klass()) {
 596       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 597       // on their array classes.
 598       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 599       k-&gt;remove_java_mirror();
 600     }
 601   }
 602 }
 603 
 604 static void clear_basic_type_mirrors() {
 605   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 606   Universe::set_int_mirror(NULL);
 607   Universe::set_float_mirror(NULL);
 608   Universe::set_double_mirror(NULL);
 609   Universe::set_byte_mirror(NULL);
 610   Universe::set_bool_mirror(NULL);
 611   Universe::set_char_mirror(NULL);
 612   Universe::set_long_mirror(NULL);
 613   Universe::set_short_mirror(NULL);
 614   Universe::set_void_mirror(NULL);
 615 }
 616 
 617 static void rewrite_nofast_bytecode(const methodHandle&amp; method) {
 618   BytecodeStream bcs(method);
 619   while (!bcs.is_last_bytecode()) {
 620     Bytecodes::Code opcode = bcs.next();
 621     switch (opcode) {
 622     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 623     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 624     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 625     case Bytecodes::_iload: {
 626       if (!bcs.is_wide()) {
 627         *bcs.bcp() = Bytecodes::_nofast_iload;
 628       }
 629       break;
 630     }
 631     default: break;
 632     }
 633   }
 634 }
 635 
 636 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 637 // run time. This includes:
 638 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 639 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 640 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
 641 static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {
 642   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 643     Klass* k = _global_klass_objects-&gt;at(i);
 644     if (k-&gt;is_instance_klass()) {
 645       InstanceKlass* ik = InstanceKlass::cast(k);
 646       MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);
 647     }
 648   }
 649 }
 650 
 651 void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {
 652   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
 653     methodHandle m(thread, ik-&gt;methods()-&gt;at(i));
 654     rewrite_nofast_bytecode(m);
 655     Fingerprinter fp(m);
 656     // The side effect of this call sets method&#39;s fingerprint field.
 657     fp.fingerprint();
 658   }
 659 }
 660 
 661 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 662 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 663 //
 664 // Addresses of the vtables and the methods may be different across JVM runs,
 665 // if libjvm.so is dynamically loaded at a different base address.
 666 //
 667 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 668 //
 669 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 670 //                  the CDS image
 671 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 672 //                  into our own tables.
 673 
 674 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 675 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 676   f(ConstantPool) \
 677   f(InstanceClassLoaderKlass) \
 678   f(InstanceKlass) \
 679   f(InstanceMirrorKlass) \
 680   f(InstanceRefKlass) \
 681   f(Method) \
 682   f(ObjArrayKlass) \
 683   f(TypeArrayKlass) \
 684   f(ValueArrayKlass) \
 685   f(ValueKlass)
 686 
 687 class CppVtableInfo {
 688   intptr_t _vtable_size;
 689   intptr_t _cloned_vtable[1];
 690 public:
 691   static int num_slots(int vtable_size) {
 692     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 693   }
 694   int vtable_size()           { return int(uintx(_vtable_size)); }
 695   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 696   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 697   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 698   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 699   static size_t byte_size(int vtable_size) {
 700     CppVtableInfo i;
 701     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 702   }
 703 };
 704 
 705 template &lt;class T&gt; class CppVtableCloner : public T {
 706   static intptr_t* vtable_of(Metadata&amp; m) {
 707     return *((intptr_t**)&amp;m);
 708   }
 709   static CppVtableInfo* _info;
 710 
 711   static int get_vtable_length(const char* name);
 712 
 713 public:
 714   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 715   static intptr_t* allocate(const char* name);
 716 
 717   // Clone the vtable to ...
 718   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 719 
 720   static void zero_vtable_clone() {
 721     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 722     _info-&gt;zero();
 723   }
 724 
 725   static bool is_valid_shared_object(const T* obj) {
 726     intptr_t* vptr = *(intptr_t**)obj;
 727     return vptr == _info-&gt;cloned_vtable();
 728   }
 729 };
 730 
 731 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 732 
 733 template &lt;class T&gt;
 734 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 735   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 736   int n = get_vtable_length(name);
 737   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 738   _info-&gt;set_vtable_size(n);
 739 
 740   intptr_t* p = clone_vtable(name, _info);
 741   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 742 
 743   return _info-&gt;cloned_vtable();
 744 }
 745 
 746 template &lt;class T&gt;
 747 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 748   if (!DumpSharedSpaces) {
 749     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 750     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 751   }
 752   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 753   int n = info-&gt;vtable_size();
 754   intptr_t* srcvtable = vtable_of(tmp);
 755   intptr_t* dstvtable = info-&gt;cloned_vtable();
 756 
 757   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 758   // safe to do memcpy.
 759   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 760   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 761   return dstvtable + n;
 762 }
 763 
 764 // To determine the size of the vtable for each type, we use the following
 765 // trick by declaring 2 subclasses:
 766 //
 767 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 768 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 769 //
 770 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 771 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 772 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 773 // - Their last entry is different.
 774 //
 775 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 776 // and find the first entry that&#39;s different.
 777 //
 778 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 779 // esoteric compilers.
 780 
 781 template &lt;class T&gt; class CppVtableTesterB: public T {
 782 public:
 783   virtual int last_virtual_method() {return 1;}
 784 };
 785 
 786 template &lt;class T&gt; class CppVtableTesterA : public T {
 787 public:
 788   virtual void* last_virtual_method() {
 789     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 790     // compiler/linker won&#39;t alias the two functions.
 791     return NULL;
 792   }
 793 };
 794 
 795 template &lt;class T&gt;
 796 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 797   CppVtableTesterA&lt;T&gt; a;
 798   CppVtableTesterB&lt;T&gt; b;
 799 
 800   intptr_t* avtable = vtable_of(a);
 801   intptr_t* bvtable = vtable_of(b);
 802 
 803   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 804   int vtable_len = 1;
 805   for (; ; vtable_len++) {
 806     if (avtable[vtable_len] != bvtable[vtable_len]) {
 807       break;
 808     }
 809   }
 810   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 811 
 812   return vtable_len;
 813 }
 814 
 815 #define ALLOC_CPP_VTABLE_CLONE(c) \
 816   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 817   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 818 
 819 #define CLONE_CPP_VTABLE(c) \
 820   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 821 
 822 #define ZERO_CPP_VTABLE(c) \
 823  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 824 
 825 //------------------------------ for DynamicDumpSharedSpaces - start
 826 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 827 
 828 enum {
 829   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.
 830   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 831   _num_cloned_vtable_kinds
 832 };
 833 
 834 // This is the index of all the cloned vtables. E.g., for
 835 //     ConstantPool* cp = ....; // an archived constant pool
 836 //     InstanceKlass* ik = ....;// an archived class
 837 // the following holds true:
 838 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 839 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 840 static intptr_t** _cloned_cpp_vtptrs = NULL;
 841 
 842 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 843   assert(DumpSharedSpaces, &quot;must&quot;);
 844   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 845   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 846 }
 847 
 848 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 849   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 850 }
 851 
 852 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {
 853   Arguments::assert_is_dumping_archive();
 854   int kind = -1;
 855   switch (msotype) {
 856   case MetaspaceObj::SymbolType:
 857   case MetaspaceObj::TypeArrayU1Type:
 858   case MetaspaceObj::TypeArrayU2Type:
 859   case MetaspaceObj::TypeArrayU4Type:
 860   case MetaspaceObj::TypeArrayU8Type:
 861   case MetaspaceObj::TypeArrayOtherType:
 862   case MetaspaceObj::ConstMethodType:
 863   case MetaspaceObj::ConstantPoolCacheType:
 864   case MetaspaceObj::AnnotationsType:
 865   case MetaspaceObj::MethodCountersType:
 866   case MetaspaceObj::RecordComponentType:
 867     // These have no vtables.
 868     break;
 869   case MetaspaceObj::ClassType:
 870     {
 871       Klass* k = (Klass*)obj;
 872       assert(k-&gt;is_klass(), &quot;must be&quot;);
 873       if (k-&gt;is_value()) {
 874         kind = ValueKlass_Kind;
 875       } else if (k-&gt;is_instance_klass()) {
 876         InstanceKlass* ik = InstanceKlass::cast(k);
 877         if (ik-&gt;is_class_loader_instance_klass()) {
 878           kind = InstanceClassLoaderKlass_Kind;
 879         } else if (ik-&gt;is_reference_instance_klass()) {
 880           kind = InstanceRefKlass_Kind;
 881         } else if (ik-&gt;is_mirror_instance_klass()) {
 882           kind = InstanceMirrorKlass_Kind;
 883         } else {
 884           kind = InstanceKlass_Kind;
 885         }
 886       } else if (k-&gt;is_typeArray_klass()) {
 887         kind = TypeArrayKlass_Kind;
 888       } else {
 889         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 890         kind = ObjArrayKlass_Kind;
 891       }
 892     }
 893     break;
 894 
 895   case MetaspaceObj::MethodType:
 896     {
 897       Method* m = (Method*)obj;
 898       assert(m-&gt;is_method(), &quot;must be&quot;);
 899       kind = Method_Kind;
 900     }
 901     break;
 902 
 903   case MetaspaceObj::MethodDataType:
 904     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
 905     ShouldNotReachHere();
 906     break;
 907 
 908   case MetaspaceObj::ConstantPoolType:
 909     {
 910       ConstantPool *cp = (ConstantPool*)obj;
 911       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);
 912       kind = ConstantPool_Kind;
 913     }
 914     break;
 915 
 916   default:
 917     ShouldNotReachHere();
 918   }
 919 
 920   if (kind &gt;= 0) {
 921     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
 922     return _cloned_cpp_vtptrs[kind];
 923   } else {
 924     return NULL;
 925   }
 926 }
 927 
 928 //------------------------------ for DynamicDumpSharedSpaces - end
 929 
 930 // This can be called at both dump time and run time:
 931 // - clone the contents of the c++ vtables into the space
 932 //   allocated by allocate_cpp_vtable_clones()
 933 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
 934   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
 935   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
 936 }
 937 
 938 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
 939   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 940   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
 941 }
 942 
 943 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
 944 char* MetaspaceShared::allocate_cpp_vtable_clones() {
 945   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
 946 
 947   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 948   // Layout (each slot is a intptr_t):
 949   //   [number of slots in the first vtable = n1]
 950   //   [ &lt;n1&gt; slots for the first vtable]
 951   //   [number of slots in the first second = n2]
 952   //   [ &lt;n2&gt; slots for the second vtable]
 953   //   ...
 954   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
 955   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
 956 
 957   return cloned_vtables;
 958 }
 959 
 960 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
 961   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
 962   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
 963 }
 964 
 965 void WriteClosure::do_oop(oop* o) {
 966   if (*o == NULL) {
 967     _dump_region-&gt;append_intptr_t(0);
 968   } else {
 969     assert(HeapShared::is_heap_object_archiving_allowed(),
 970            &quot;Archiving heap object is not allowed&quot;);
 971     _dump_region-&gt;append_intptr_t(
 972       (intptr_t)CompressedOops::encode_not_null(*o));
 973   }
 974 }
 975 
 976 void WriteClosure::do_region(u_char* start, size_t size) {
 977   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
 978   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
 979   do_tag((int)size);
 980   while (size &gt; 0) {
 981     _dump_region-&gt;append_intptr_t(*(intptr_t*)start, true);
 982     start += sizeof(intptr_t);
 983     size -= sizeof(intptr_t);
 984   }
 985 }
 986 
 987 // This is for dumping detailed statistics for the allocations
 988 // in the shared spaces.
 989 class DumpAllocStats : public ResourceObj {
 990 public:
 991 
 992   // Here&#39;s poor man&#39;s enum inheritance
 993 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
 994   METASPACE_OBJ_TYPES_DO(f) \
 995   f(SymbolHashentry) \
 996   f(SymbolBucket) \
 997   f(StringHashentry) \
 998   f(StringBucket) \
 999   f(Other)
1000 
1001   enum Type {
1002     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
1003     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
1004     _number_of_types
1005   };
1006 
1007   static const char * type_name(Type type) {
1008     switch(type) {
1009     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
1010     default:
1011       ShouldNotReachHere();
1012       return NULL;
1013     }
1014   }
1015 
1016 public:
1017   enum { RO = 0, RW = 1 };
1018 
1019   int _counts[2][_number_of_types];
1020   int _bytes [2][_number_of_types];
1021 
1022   DumpAllocStats() {
1023     memset(_counts, 0, sizeof(_counts));
1024     memset(_bytes,  0, sizeof(_bytes));
1025   };
1026 
1027   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
1028     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
1029     int which = (read_only) ? RO : RW;
1030     _counts[which][type] ++;
1031     _bytes [which][type] += byte_size;
1032   }
1033 
1034   void record_other_type(int byte_size, bool read_only) {
1035     int which = (read_only) ? RO : RW;
1036     _bytes [which][OtherType] += byte_size;
1037   }
1038   void print_stats(int ro_all, int rw_all, int mc_all);
1039 };
1040 
1041 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {
1042   // Calculate size of data that was not allocated by Metaspace::allocate()
1043   MetaspaceSharedStats *stats = MetaspaceShared::stats();
1044 
1045   // symbols
1046   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
1047   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
1048 
1049   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
1050   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
1051 
1052   // strings
1053   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
1054   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
1055 
1056   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
1057   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
1058 
1059   // TODO: count things like dictionary, vtable, etc
1060   _bytes[RW][OtherType] += mc_all;
1061   rw_all += mc_all; // mc is mapped Read/Write
1062 
1063   // prevent divide-by-zero
1064   if (ro_all &lt; 1) {
1065     ro_all = 1;
1066   }
1067   if (rw_all &lt; 1) {
1068     rw_all = 1;
1069   }
1070 
1071   int all_ro_count = 0;
1072   int all_ro_bytes = 0;
1073   int all_rw_count = 0;
1074   int all_rw_bytes = 0;
1075 
1076 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
1077 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
1078   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
1079   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
1080 
1081   LogMessage(cds) msg;
1082 
1083   msg.debug(&quot;Detailed metadata info (excluding st regions; rw stats include mc regions):&quot;);
1084   msg.debug(&quot;%s&quot;, hdr);
1085   msg.debug(&quot;%s&quot;, sep);
1086   for (int type = 0; type &lt; int(_number_of_types); type ++) {
1087     const char *name = type_name((Type)type);
1088     int ro_count = _counts[RO][type];
1089     int ro_bytes = _bytes [RO][type];
1090     int rw_count = _counts[RW][type];
1091     int rw_bytes = _bytes [RW][type];
1092     int count = ro_count + rw_count;
1093     int bytes = ro_bytes + rw_bytes;
1094 
1095     double ro_perc = percent_of(ro_bytes, ro_all);
1096     double rw_perc = percent_of(rw_bytes, rw_all);
1097     double perc    = percent_of(bytes, ro_all + rw_all);
1098 
1099     msg.debug(fmt_stats, name,
1100                          ro_count, ro_bytes, ro_perc,
1101                          rw_count, rw_bytes, rw_perc,
1102                          count, bytes, perc);
1103 
1104     all_ro_count += ro_count;
1105     all_ro_bytes += ro_bytes;
1106     all_rw_count += rw_count;
1107     all_rw_bytes += rw_bytes;
1108   }
1109 
1110   int all_count = all_ro_count + all_rw_count;
1111   int all_bytes = all_ro_bytes + all_rw_bytes;
1112 
1113   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1114   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1115   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1116 
1117   msg.debug(&quot;%s&quot;, sep);
1118   msg.debug(fmt_stats, &quot;Total&quot;,
1119                        all_ro_count, all_ro_bytes, all_ro_perc,
1120                        all_rw_count, all_rw_bytes, all_rw_perc,
1121                        all_count, all_bytes, all_perc);
1122 
1123   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1124   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1125 
1126 #undef fmt_stats
1127 }
1128 
1129 // Populate the shared space.
1130 
1131 class VM_PopulateDumpSharedSpace: public VM_Operation {
1132 private:
1133   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1134   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1135 
1136   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1137   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1138 
1139   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1140   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1141   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1142                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1143   void dump_symbols();
1144   char* dump_read_only_tables();
1145   void print_class_stats();
1146   void print_region_stats(FileMapInfo* map_info);
1147   void print_bitmap_region_stats(size_t size, size_t total_size);
1148   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1149                                const char *name, size_t total_size);
1150   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1151 
1152 public:
1153 
1154   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1155   void doit();   // outline because gdb sucks
1156   bool allow_nested_vm_operations() const { return true; }
1157 }; // class VM_PopulateDumpSharedSpace
1158 
1159 class SortedSymbolClosure: public SymbolClosure {
1160   GrowableArray&lt;Symbol*&gt; _symbols;
1161   virtual void do_symbol(Symbol** sym) {
1162     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1163     _symbols.append(*sym);
1164   }
1165   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1166     if (a[0] &lt; b[0]) {
1167       return -1;
1168     } else if (a[0] == b[0]) {
<a name="18" id="anc18"></a>

1169       return 0;
1170     } else {
1171       return 1;
1172     }
1173   }
1174 
1175 public:
1176   SortedSymbolClosure() {
1177     SymbolTable::symbols_do(this);
1178     _symbols.sort(compare_symbols_by_address);
1179   }
1180   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {
1181     return &amp;_symbols;
1182   }
1183 };
1184 
1185 // ArchiveCompactor --
1186 //
1187 // This class is the central piece of shared archive compaction -- all metaspace data are
1188 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1189 // metaspace data into their final location in the shared regions.
1190 
1191 class ArchiveCompactor : AllStatic {
1192   static const int INITIAL_TABLE_SIZE = 8087;
1193   static const int MAX_TABLE_SIZE     = 1000000;
1194 
1195   static DumpAllocStats* _alloc_stats;
1196   static SortedSymbolClosure* _ssc;
1197 
1198   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1199   static RelocationTable* _new_loc_table;
1200 
1201 public:
1202   static void initialize() {
1203     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1204     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1205   }
1206   static DumpAllocStats* alloc_stats() {
1207     return _alloc_stats;
1208   }
1209 
1210   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1211   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1212   // that are allocated in the RO space.
1213   class OtherROAllocMark {
1214     char* _oldtop;
1215   public:
1216     OtherROAllocMark() {
1217       _oldtop = _ro_region.top();
1218     }
1219     ~OtherROAllocMark() {
1220       char* newtop = _ro_region.top();
1221       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1222     }
1223   };
1224 
1225   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1226     address obj = ref-&gt;obj();
1227     int bytes = ref-&gt;size() * BytesPerWord;
1228     char* p;
1229     size_t alignment = BytesPerWord;
1230     char* oldtop;
1231     char* newtop;
1232 
1233     if (read_only) {
1234       oldtop = _ro_region.top();
1235       p = _ro_region.allocate(bytes, alignment);
1236       newtop = _ro_region.top();
1237     } else {
1238       oldtop = _rw_region.top();
1239       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1240         // Save a pointer immediate in front of an InstanceKlass, so
1241         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1242         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1243         // in systemDictionaryShared.cpp.
1244         Klass* klass = (Klass*)obj;
1245         if (klass-&gt;is_instance_klass()) {
1246           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1247           _rw_region.allocate(sizeof(address), BytesPerWord);
1248         }
1249       }
1250       p = _rw_region.allocate(bytes, alignment);
1251       newtop = _rw_region.top();
1252     }
1253     memcpy(p, obj, bytes);
1254 
1255     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);
1256     if (cloned_vtable != NULL) {
1257       *(address*)p = (address)cloned_vtable;
1258       ArchivePtrMarker::mark_pointer((address*)p);
1259     }
1260 
1261     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1262     _new_loc_table-&gt;add(obj, (address)p);
1263     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1264     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1265       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1266     }
1267     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1268   }
1269 
1270   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1271     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1272     assert(pp != NULL, &quot;must be&quot;);
1273     return *pp;
1274   }
1275 
1276 private:
1277   // Makes a shallow copy of visited MetaspaceObj&#39;s
1278   class ShallowCopier: public UniqueMetaspaceClosure {
1279     bool _read_only;
1280   public:
1281     ShallowCopier(bool read_only) : _read_only(read_only) {}
1282 
1283     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1284       if (read_only == _read_only) {
1285         allocate(ref, read_only);
1286       }
1287       return true; // recurse into ref.obj()
1288     }
1289   };
1290 
1291   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1292   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1293   public:
1294     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1295       address new_loc = get_new_loc(ref);
1296       RefRelocator refer;
1297       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1298       return true; // recurse into ref.obj()
1299     }
1300     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
1301       assert_valid(type);
1302 
1303       address obj = ref-&gt;obj();
1304       address new_obj = get_new_loc(ref);
1305       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1306       intptr_t* new_p = (intptr_t*)(new_obj + offset);
1307       switch (type) {
1308       case _method_entry_ref:
1309         assert(*p == *new_p, &quot;must be a copy&quot;);
1310         break;
1311       case _internal_pointer_ref:
1312         {
1313           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));
1314           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);
1315           *((address*)new_p) = new_obj + off;
1316         }
1317         break;
1318       default:
1319         ShouldNotReachHere();
1320       }
1321       ArchivePtrMarker::mark_pointer((address*)new_p);
1322     }
1323   };
1324 
1325   // Relocate a reference to point to its shallow copy
1326   class RefRelocator: public MetaspaceClosure {
1327   public:
1328     virtual bool do_ref(Ref* ref, bool read_only) {
1329       if (ref-&gt;not_null()) {
1330         ref-&gt;update(get_new_loc(ref));
1331         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1332       }
1333       return false; // Do not recurse.
1334     }
1335   };
1336 
1337 #ifdef ASSERT
1338   class IsRefInArchiveChecker: public MetaspaceClosure {
1339   public:
1340     virtual bool do_ref(Ref* ref, bool read_only) {
1341       if (ref-&gt;not_null()) {
1342         char* obj = (char*)ref-&gt;obj();
1343         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1344                &quot;must be relocated to point to CDS archive&quot;);
1345       }
1346       return false; // Do not recurse.
1347     }
1348   };
1349 #endif
1350 
1351 public:
1352   static void copy_and_compact() {
1353     ResourceMark rm;
1354     SortedSymbolClosure the_ssc; // StackObj
1355     _ssc = &amp;the_ssc;
1356 
1357     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1358     {
1359       // allocate and shallow-copy RW objects, immediately following the MC region
1360       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1361       _mc_region.pack(&amp;_rw_region);
1362 
1363       ResourceMark rm;
1364       ShallowCopier rw_copier(false);
1365       iterate_roots(&amp;rw_copier);
1366     }
1367     {
1368       // allocate and shallow-copy of RO object, immediately following the RW region
1369       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1370       _rw_region.pack(&amp;_ro_region);
1371 
1372       ResourceMark rm;
1373       ShallowCopier ro_copier(true);
1374       iterate_roots(&amp;ro_copier);
1375     }
1376     {
1377       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1378       ResourceMark rm;
1379       ShallowCopyEmbeddedRefRelocator emb_reloc;
1380       iterate_roots(&amp;emb_reloc);
1381     }
1382     {
1383       log_info(cds)(&quot;Relocating external roots ... &quot;);
1384       ResourceMark rm;
1385       RefRelocator ext_reloc;
1386       iterate_roots(&amp;ext_reloc);
1387     }
1388     {
1389       log_info(cds)(&quot;Fixing symbol identity hash ... &quot;);
1390       os::init_random(0x12345678);
1391       GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1392       for (int i=0; i&lt;symbols-&gt;length(); i++) {
1393         symbols-&gt;at(i)-&gt;update_identity_hash();
1394       }
1395     }
1396 #ifdef ASSERT
1397     {
1398       log_info(cds)(&quot;Verifying external roots ... &quot;);
1399       ResourceMark rm;
1400       IsRefInArchiveChecker checker;
1401       iterate_roots(&amp;checker);
1402     }
1403 #endif
1404 
1405 
1406     // cleanup
1407     _ssc = NULL;
1408   }
1409 
1410   // We must relocate the System::_well_known_klasses only after we have copied the
1411   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1412   // old objects which assert that their klass is the original klass.
1413   static void relocate_well_known_klasses() {
1414     {
1415       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1416       ResourceMark rm;
1417       RefRelocator ext_reloc;
1418       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1419     }
1420     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1421     // objects.
1422 
1423     // We cannot use any of the objects in the heap anymore (except for the
1424     // shared strings) because their headers no longer point to valid Klasses.
1425   }
1426 
1427   static void iterate_roots(MetaspaceClosure* it) {
1428     // To ensure deterministic contents in the archive, we just need to ensure that
1429     // we iterate the MetsapceObjs in a deterministic order. It doesn&#39;t matter where
1430     // the MetsapceObjs are located originally, as they are copied sequentially into
1431     // the archive during the iteration.
1432     //
1433     // The only issue here is that the symbol table and the system directories may be
1434     // randomly ordered, so we copy the symbols and klasses into two arrays and sort
1435     // them deterministically.
1436     //
1437     // During -Xshare:dump, the order of Symbol creation is strictly determined by
1438     // the SharedClassListFile (class loading is done in a single thread and the JIT
1439     // is disabled). Also, Symbols are allocated in monotonically increasing addresses
1440     // (see Symbol::operator new(size_t, int)). So if we iterate the Symbols by
1441     // ascending address order, we ensure that all Symbols are copied into deterministic
1442     // locations in the archive.
1443     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1444     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1445       it-&gt;push(symbols-&gt;adr_at(i));
1446     }
1447     if (_global_klass_objects != NULL) {
1448       // Need to fix up the pointers
1449       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1450         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1451         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1452       }
1453     }
1454     FileMapInfo::metaspace_pointers_do(it, false);
1455     SystemDictionaryShared::dumptime_classes_do(it);
1456     Universe::metaspace_pointers_do(it);
1457     SymbolTable::metaspace_pointers_do(it);
1458     vmSymbols::metaspace_pointers_do(it);
1459 
1460     it-&gt;finish();
1461   }
1462 
1463   static Klass* get_relocated_klass(Klass* orig_klass) {
1464     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1465     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1466     assert(pp != NULL, &quot;must be&quot;);
1467     Klass* klass = (Klass*)(*pp);
1468     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1469     return klass;
1470   }
1471 };
1472 
1473 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1474 SortedSymbolClosure* ArchiveCompactor::_ssc;
1475 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1476 
1477 void VM_PopulateDumpSharedSpace::dump_symbols() {
1478   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1479 
1480   NOT_PRODUCT(SymbolTable::verify());
1481   SymbolTable::write_to_archive();
1482 }
1483 
1484 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1485   ArchiveCompactor::OtherROAllocMark mark;
1486 
1487   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1488   if (!HeapShared::is_heap_object_archiving_allowed()) {
1489     clear_basic_type_mirrors();
1490   }
1491   remove_java_mirror_in_classes();
1492   log_info(cds)(&quot;done. &quot;);
1493 
1494   SystemDictionaryShared::write_to_archive();
1495 
1496   // Write the other data to the output array.
1497   char* start = _ro_region.top();
1498   WriteClosure wc(&amp;_ro_region);
1499   MetaspaceShared::serialize(&amp;wc);
1500 
1501   // Write the bitmaps for patching the archive heap regions
1502   _closed_archive_heap_oopmaps = NULL;
1503   _open_archive_heap_oopmaps = NULL;
1504   dump_archive_heap_oopmaps();
1505 
1506   return start;
1507 }
1508 
1509 void VM_PopulateDumpSharedSpace::print_class_stats() {
1510   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1511   {
1512     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1513     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1514       Klass* k = _global_klass_objects-&gt;at(i);
1515       if (k-&gt;is_instance_klass()) {
1516         num_inst ++;
1517       } else if (k-&gt;is_objArray_klass()) {
1518         num_obj_array ++;
1519       } else {
1520         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1521         num_type_array ++;
1522       }
1523     }
1524     log_info(cds)(&quot;    instance classes   = %5d&quot;, num_inst);
1525     log_info(cds)(&quot;    obj array classes  = %5d&quot;, num_obj_array);
1526     log_info(cds)(&quot;    type array classes = %5d&quot;, num_type_array);
1527   }
1528 }
1529 
1530 void VM_PopulateDumpSharedSpace::relocate_to_default_base_address(CHeapBitMap* ptrmap) {
1531   intx addr_delta = MetaspaceShared::final_delta();
1532   if (addr_delta == 0) {
1533     ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());
1534   } else {
1535     // We are not able to reserve space at Arguments::default_SharedBaseAddress() (due to ASLR).
1536     // This means that the current content of the archive is based on a random
1537     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
1538     // Arguments::default_SharedBaseAddress() without runtime relocation.
1539     //
1540     // Note: both the base and dynamic archive are written with
1541     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()
1542 
1543     // Patch all pointers that are marked by ptrmap within this region,
1544     // where we have just dumped all the metaspace data.
1545     address patch_base = (address)SharedBaseAddress;
1546     address patch_end  = (address)_ro_region.top();
1547     size_t size = patch_end - patch_base;
1548 
1549     // the current value of the pointers to be patched must be within this
1550     // range (i.e., must point to valid metaspace objects)
1551     address valid_old_base = patch_base;
1552     address valid_old_end  = patch_end;
1553 
1554     // after patching, the pointers must point inside this range
1555     // (the requested location of the archive, as mapped at runtime).
1556     address valid_new_base = (address)Arguments::default_SharedBaseAddress();
1557     address valid_new_end  = valid_new_base + size;
1558 
1559     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ] to &quot;
1560                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ]&quot;, p2i(patch_base), p2i(patch_end),
1561                    p2i(valid_new_base), p2i(valid_new_end));
1562 
1563     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1564                                       valid_new_base, valid_new_end, addr_delta, ptrmap);
1565     ptrmap-&gt;iterate(&amp;patcher);
1566     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1567   }
1568 }
1569 
1570 void VM_PopulateDumpSharedSpace::doit() {
1571   CHeapBitMap ptrmap;
1572   MetaspaceShared::initialize_ptr_marker(&amp;ptrmap);
1573 
1574   // We should no longer allocate anything from the metaspace, so that:
1575   //
1576   // (1) Metaspace::allocate might trigger GC if we have run out of
1577   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1578   //     in the VM thread.
1579   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1580   Metaspace::freeze();
1581   DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);
1582 
1583   Thread* THREAD = VMThread::vm_thread();
1584 
1585   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1586 
1587   NOT_PRODUCT(SystemDictionary::verify();)
1588   // The following guarantee is meant to ensure that no loader constraints
1589   // exist yet, since the constraints table is not shared.  This becomes
1590   // more important now that we don&#39;t re-initialize vtables/itables for
1591   // shared classes at runtime, where constraints were previously created.
1592   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1593             &quot;loader constraints are not saved&quot;);
1594   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1595           &quot;placeholders are not saved&quot;);
1596 
1597   // At this point, many classes have been loaded.
1598   // Gather systemDictionary classes in a global array and do everything to
1599   // that so we don&#39;t have to walk the SystemDictionary again.
1600   SystemDictionaryShared::check_excluded_classes();
1601   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1602   CollectClassesClosure collect_classes;
1603   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1604   _global_klass_objects-&gt;sort(global_klass_compare);
1605 
1606   print_class_stats();
1607 
1608   // Ensure the ConstMethods won&#39;t be modified at run-time
1609   log_info(cds)(&quot;Updating ConstMethods ... &quot;);
1610   rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);
1611   log_info(cds)(&quot;done. &quot;);
1612 
1613   // Remove all references outside the metadata
1614   log_info(cds)(&quot;Removing unshareable information ... &quot;);
1615   remove_unshareable_in_classes();
1616   log_info(cds)(&quot;done. &quot;);
1617 
1618   MetaspaceShared::allocate_cloned_cpp_vtptrs();
1619   char* cloned_vtables = _mc_region.top();
1620   MetaspaceShared::allocate_cpp_vtable_clones();
1621 
1622   ArchiveCompactor::initialize();
1623   ArchiveCompactor::copy_and_compact();
1624 
1625   dump_symbols();
1626 
1627   // Dump supported java heap objects
1628   _closed_archive_heap_regions = NULL;
1629   _open_archive_heap_regions = NULL;
1630   dump_java_heap_objects();
1631 
1632   ArchiveCompactor::relocate_well_known_klasses();
1633 
1634   char* serialized_data = dump_read_only_tables();
1635   _ro_region.pack();
1636 
1637   // The vtable clones contain addresses of the current process.
1638   // We don&#39;t want to write these addresses into the archive. Same for i2i buffer.
1639   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1640   memset(MetaspaceShared::i2i_entry_code_buffers(), 0,
1641          MetaspaceShared::i2i_entry_code_buffers_size());
1642 
1643   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1644   // without runtime relocation.
1645   relocate_to_default_base_address(&amp;ptrmap);
1646 
1647   // Create and write the archive file that maps the shared spaces.
1648 
1649   FileMapInfo* mapinfo = new FileMapInfo(true);
1650   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1651   mapinfo-&gt;set_serialized_data(serialized_data);
1652   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1653   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1654                                       MetaspaceShared::i2i_entry_code_buffers_size());
1655   mapinfo-&gt;open_for_write();
1656   MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps, _open_archive_heap_oopmaps);
1657   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1658                                         _closed_archive_heap_regions,
1659                                         _closed_archive_heap_oopmaps,
1660                                         MetaspaceShared::first_closed_archive_heap_region,
1661                                         MetaspaceShared::max_closed_archive_heap_region);
1662   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1663                                         _open_archive_heap_regions,
1664                                         _open_archive_heap_oopmaps,
1665                                         MetaspaceShared::first_open_archive_heap_region,
1666                                         MetaspaceShared::max_open_archive_heap_region);
1667 
1668   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1669   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1670   mapinfo-&gt;write_header();
1671   print_region_stats(mapinfo);
1672   mapinfo-&gt;close();
1673 
1674   if (log_is_enabled(Info, cds)) {
1675     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1676                                                  int(_mc_region.used()));
1677   }
1678 
1679   if (PrintSystemDictionaryAtExit) {
1680     SystemDictionary::print();
1681   }
1682 
1683   if (AllowArchivingWithJavaAgent) {
1684     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1685             &quot;for testing purposes only and should not be used in a production environment&quot;);
1686   }
1687 
1688   // There may be other pending VM operations that operate on the InstanceKlasses,
1689   // which will fail because InstanceKlasses::remove_unshareable_info()
1690   // has been called. Forget these operations and exit the VM directly.
1691   vm_direct_exit(0);
1692 }
1693 
1694 void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {
1695   // Print statistics of all the regions
1696   const size_t bitmap_used = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used();
1697   const size_t bitmap_reserved = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used_aligned();
1698   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1699                                 _mc_region.reserved()  +
1700                                 bitmap_reserved +
1701                                 _total_closed_archive_region_size +
1702                                 _total_open_archive_region_size;
1703   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1704                              _mc_region.used()  +
1705                              bitmap_used +
1706                              _total_closed_archive_region_size +
1707                              _total_open_archive_region_size;
1708   const double total_u_perc = percent_of(total_bytes, total_reserved);
1709 
1710   _mc_region.print(total_reserved);
1711   _rw_region.print(total_reserved);
1712   _ro_region.print(total_reserved);
1713   print_bitmap_region_stats(bitmap_used, total_reserved);
1714   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1715   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1716 
1717   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
1718                  total_bytes, total_reserved, total_u_perc);
1719 }
1720 
1721 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1722   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used]&quot;,
1723                  size, size/double(total_size)*100.0, size);
1724 }
1725 
1726 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1727                                                          const char *name, size_t total_size) {
1728   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1729   for (int i = 0; i &lt; arr_len; i++) {
1730       char* start = (char*)heap_mem-&gt;at(i).start();
1731       size_t size = heap_mem-&gt;at(i).byte_size();
1732       char* top = start + size;
1733       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1734                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1735 
1736   }
1737 }
1738 
1739 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,
1740                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,
1741                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {
1742   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1743   // MetaspaceShared::n_regions (internal to hotspot).
1744   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1745 
1746   // mc contains the trampoline code for method entries, which are patched at run time,
1747   // so it needs to be read/write.
1748   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1749   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1750   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
1751   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps);
1752 }
1753 
1754 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1755   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1756 }
1757 
1758 // Update a Java object to point its Klass* to the new location after
1759 // shared archive has been compacted.
1760 void MetaspaceShared::relocate_klass_ptr(oop o) {
1761   assert(DumpSharedSpaces, &quot;sanity&quot;);
1762   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1763   o-&gt;set_klass(k);
1764 }
1765 
1766 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1767   assert(DumpSharedSpaces, &quot;sanity&quot;);
1768   k = ArchiveCompactor::get_relocated_klass(k);
1769   if (is_final) {
1770     k = (Klass*)(address(k) + final_delta());
1771   }
1772   return k;
1773 }
1774 
1775 class LinkSharedClassesClosure : public KlassClosure {
1776   Thread* THREAD;
1777   bool    _made_progress;
1778  public:
1779   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1780 
1781   void reset()               { _made_progress = false; }
1782   bool made_progress() const { return _made_progress; }
1783 
1784   void do_klass(Klass* k) {
1785     if (k-&gt;is_instance_klass()) {
1786       InstanceKlass* ik = InstanceKlass::cast(k);
1787       // For dynamic CDS dump, only link classes loaded by the builtin class loaders.
1788       bool do_linking = DumpSharedSpaces ? true : !ik-&gt;is_shared_unregistered_class();
1789       if (do_linking) {
1790         // Link the class to cause the bytecodes to be rewritten and the
1791         // cpcache to be created. Class verification is done according
1792         // to -Xverify setting.
1793         _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);
1794         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1795 
1796         if (DumpSharedSpaces) {
1797           // The following function is used to resolve all Strings in the statically
1798           // dumped classes to archive all the Strings. The archive heap is not supported
1799           // for the dynamic archive.
1800           ik-&gt;constants()-&gt;resolve_class_constants(THREAD);
1801         }
1802       }
1803     }
1804   }
1805 };
1806 
1807 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1808   // We need to iterate because verification may cause additional classes
1809   // to be loaded.
1810   LinkSharedClassesClosure link_closure(THREAD);
1811   do {
1812     link_closure.reset();
1813     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1814     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1815   } while (link_closure.made_progress());
1816 }
1817 
1818 void MetaspaceShared::prepare_for_dumping() {
1819   Arguments::check_unsupported_dumping_properties();
1820   ClassLoader::initialize_shared_path();
1821 }
1822 
1823 // Preload classes from a list, populate the shared spaces and dump to a
1824 // file.
1825 void MetaspaceShared::preload_and_dump(TRAPS) {
1826   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1827     ResourceMark rm(THREAD);
1828     char class_list_path_str[JVM_MAXPATHLEN];
1829     // Preload classes to be shared.
1830     const char* class_list_path;
1831     if (SharedClassListFile == NULL) {
1832       // Construct the path to the class list (in jre/lib)
1833       // Walk up two directories from the location of the VM and
1834       // optionally tack on &quot;lib&quot; (depending on platform)
1835       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1836       for (int i = 0; i &lt; 3; i++) {
1837         char *end = strrchr(class_list_path_str, *os::file_separator());
1838         if (end != NULL) *end = &#39;\0&#39;;
1839       }
1840       int class_list_path_len = (int)strlen(class_list_path_str);
1841       if (class_list_path_len &gt;= 3) {
1842         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1843           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1844             jio_snprintf(class_list_path_str + class_list_path_len,
1845                          sizeof(class_list_path_str) - class_list_path_len,
1846                          &quot;%slib&quot;, os::file_separator());
1847             class_list_path_len += 4;
1848           }
1849         }
1850       }
1851       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1852         jio_snprintf(class_list_path_str + class_list_path_len,
1853                      sizeof(class_list_path_str) - class_list_path_len,
1854                      &quot;%sclasslist&quot;, os::file_separator());
1855       }
1856       class_list_path = class_list_path_str;
1857     } else {
1858       class_list_path = SharedClassListFile;
1859     }
1860 
1861     log_info(cds)(&quot;Loading classes to share ...&quot;);
1862     _has_error_classes = false;
1863     int class_count = preload_classes(class_list_path, THREAD);
1864     if (ExtraSharedClassListFile) {
1865       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1866     }
1867     log_info(cds)(&quot;Loading classes to share: done.&quot;);
1868 
1869     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1870 
1871     if (SharedArchiveConfigFile) {
1872       log_info(cds)(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);
1873       read_extra_data(SharedArchiveConfigFile, THREAD);
1874     }
1875     log_info(cds)(&quot;Reading extra data: done.&quot;);
1876 
1877     HeapShared::init_subgraph_entry_fields(THREAD);
1878 
1879     // Rewrite and link classes
1880     log_info(cds)(&quot;Rewriting and linking classes ...&quot;);
1881 
1882     // Link any classes which got missed. This would happen if we have loaded classes that
1883     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1884     // fails verification, all other interfaces that were not specified in the classlist but
1885     // are implemented by K are not verified.
1886     link_and_cleanup_shared_classes(CATCH);
1887     log_info(cds)(&quot;Rewriting and linking classes: done&quot;);
1888 
1889     if (HeapShared::is_heap_object_archiving_allowed()) {
1890       // Avoid fragmentation while archiving heap objects.
1891       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1892       Universe::heap()-&gt;collect(GCCause::_archive_time_gc);
1893       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1894     }
1895 
1896     VM_PopulateDumpSharedSpace op;
1897     VMThread::execute(&amp;op);
1898   }
1899 }
1900 
1901 
1902 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1903   ClassListParser parser(class_list_path);
1904   int class_count = 0;
1905 
1906   while (parser.parse_one_line()) {
1907     Klass* klass = parser.load_current_class(THREAD);
1908     if (HAS_PENDING_EXCEPTION) {
1909       if (klass == NULL &amp;&amp;
1910           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1911         // print a warning only when the pending exception is class not found
1912         log_warning(cds)(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());
1913       }
1914       CLEAR_PENDING_EXCEPTION;
1915     }
1916     if (klass != NULL) {
1917       if (log_is_enabled(Trace, cds)) {
1918         ResourceMark rm(THREAD);
1919         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1920       }
1921 
1922       if (klass-&gt;is_instance_klass()) {
1923         InstanceKlass* ik = InstanceKlass::cast(klass);
1924 
1925         // Link the class to cause the bytecodes to be rewritten and the
1926         // cpcache to be created. The linking is done as soon as classes
1927         // are loaded in order that the related data structures (klass and
1928         // cpCache) are located together.
1929         try_link_class(ik, THREAD);
1930         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1931       }
1932 
1933       class_count++;
1934     }
1935   }
1936 
1937   return class_count;
1938 }
1939 
1940 // Returns true if the class&#39;s status has changed
1941 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
1942   Arguments::assert_is_dumping_archive();
1943   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;
1944       !SystemDictionaryShared::has_class_failed_verification(ik)) {
1945     bool saved = BytecodeVerificationLocal;
1946     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {
1947       // The verification decision is based on BytecodeVerificationRemote
1948       // for non-system classes. Since we are using the NULL classloader
1949       // to load non-system classes for customized class loaders during dumping,
1950       // we need to temporarily change BytecodeVerificationLocal to be the same as
1951       // BytecodeVerificationRemote. Note this can cause the parent system
1952       // classes also being verified. The extra overhead is acceptable during
1953       // dumping.
1954       BytecodeVerificationLocal = BytecodeVerificationRemote;
1955     }
1956     ik-&gt;link_class(THREAD);
1957     if (HAS_PENDING_EXCEPTION) {
1958       ResourceMark rm(THREAD);
1959       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1960                     ik-&gt;external_name());
1961       CLEAR_PENDING_EXCEPTION;
1962       SystemDictionaryShared::set_class_has_failed_verification(ik);
1963       _has_error_classes = true;
1964     }
1965     BytecodeVerificationLocal = saved;
1966     return true;
1967   } else {
1968     return false;
1969   }
1970 }
1971 
1972 #if INCLUDE_CDS_JAVA_HEAP
1973 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1974   // The closed and open archive heap space has maximum two regions.
1975   // See FileMapInfo::write_archive_heap_regions() for details.
1976   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1977   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1978   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1979                                         _open_archive_heap_regions);
1980   ArchiveCompactor::OtherROAllocMark mark;
1981   HeapShared::write_subgraph_info_table();
1982 }
1983 
1984 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1985   if (HeapShared::is_heap_object_archiving_allowed()) {
1986     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1987     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1988 
1989     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1990     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1991   }
1992 }
1993 
1994 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1995                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1996   for (int i=0; i&lt;regions-&gt;length(); i++) {
1997     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1998     size_t size_in_bits = oopmap.size();
1999     size_t size_in_bytes = oopmap.size_in_bytes();
2000     uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);
2001     oopmap.write_to(buffer, size_in_bytes);
2002     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
2003                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
2004                         p2i(buffer), size_in_bytes,
2005                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
2006 
2007     ArchiveHeapOopmapInfo info;
2008     info._oopmap = (address)buffer;
2009     info._oopmap_size_in_bits = size_in_bits;
2010     info._oopmap_size_in_bytes = size_in_bytes;
2011     oopmaps-&gt;append(info);
2012   }
2013 }
2014 #endif // INCLUDE_CDS_JAVA_HEAP
2015 
2016 void ReadClosure::do_ptr(void** p) {
2017   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
2018   intptr_t obj = nextPtr();
2019   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
2020          &quot;hit tag while initializing ptrs.&quot;);
2021   *p = (void*)obj;
2022 }
2023 
2024 void ReadClosure::do_u4(u4* p) {
2025   intptr_t obj = nextPtr();
2026   *p = (u4)(uintx(obj));
2027 }
2028 
2029 void ReadClosure::do_bool(bool* p) {
2030   intptr_t obj = nextPtr();
2031   *p = (bool)(uintx(obj));
2032 }
2033 
2034 void ReadClosure::do_tag(int tag) {
2035   int old_tag;
2036   old_tag = (int)(intptr_t)nextPtr();
2037   // do_int(&amp;old_tag);
2038   assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);
2039   FileMapInfo::assert_mark(tag == old_tag);
2040 }
2041 
2042 void ReadClosure::do_oop(oop *p) {
2043   narrowOop o = (narrowOop)nextPtr();
2044   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {
2045     p = NULL;
2046   } else {
2047     assert(HeapShared::is_heap_object_archiving_allowed(),
2048            &quot;Archived heap object is not allowed&quot;);
2049     assert(HeapShared::open_archive_heap_region_mapped(),
2050            &quot;Open archive heap region is not mapped&quot;);
2051     *p = HeapShared::decode_from_archive(o);
2052   }
2053 }
2054 
2055 void ReadClosure::do_region(u_char* start, size_t size) {
2056   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
2057   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
2058   do_tag((int)size);
2059   while (size &gt; 0) {
2060     *(intptr_t*)start = nextPtr();
2061     start += sizeof(intptr_t);
2062     size -= sizeof(intptr_t);
2063   }
2064 }
2065 
2066 void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {
2067   assert(base &lt;= static_top &amp;&amp; static_top &lt;= top, &quot;must be&quot;);
2068   _shared_metaspace_static_top = static_top;
2069   MetaspaceObj::set_shared_metaspace_range(base, top);
2070 }
2071 
2072 // Return true if given address is in the misc data region
2073 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {
2074   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);
2075 }
2076 
2077 bool MetaspaceShared::is_in_trampoline_frame(address addr) {
2078   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {
2079     return true;
2080   }
2081   return false;
2082 }
2083 
2084 bool MetaspaceShared::is_shared_dynamic(void* p) {
2085   if ((p &lt; MetaspaceObj::shared_metaspace_top()) &amp;&amp;
2086       (p &gt;= _shared_metaspace_static_top)) {
2087     return true;
2088   } else {
2089     return false;
2090   }
2091 }
2092 
2093 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {
2094   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);
2095   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
<a name="19" id="anc19"></a>
2096   FileMapInfo* static_mapinfo = open_static_archive();
2097   FileMapInfo* dynamic_mapinfo = NULL;
2098 
2099   if (static_mapinfo != NULL) {
2100     dynamic_mapinfo = open_dynamic_archive();
2101 
2102     // First try to map at the requested address
2103     result = map_archives(static_mapinfo, dynamic_mapinfo, true);
2104     if (result == MAP_ARCHIVE_MMAP_FAILURE) {
2105       // Mapping has failed (probably due to ASLR). Let&#39;s map at an address chosen
2106       // by the OS.
2107       log_info(cds)(&quot;Try to map archive(s) at an alternative address&quot;);
2108       result = map_archives(static_mapinfo, dynamic_mapinfo, false);
2109     }
2110   }
2111 
2112   if (result == MAP_ARCHIVE_SUCCESS) {
2113     bool dynamic_mapped = (dynamic_mapinfo != NULL &amp;&amp; dynamic_mapinfo-&gt;is_mapped());
2114     char* cds_base = static_mapinfo-&gt;mapped_base();
2115     char* cds_end =  dynamic_mapped ? dynamic_mapinfo-&gt;mapped_end() : static_mapinfo-&gt;mapped_end();
2116     set_shared_metaspace_range(cds_base, static_mapinfo-&gt;mapped_end(), cds_end);
2117     _relocation_delta = static_mapinfo-&gt;relocation_delta();
2118     if (dynamic_mapped) {
2119       FileMapInfo::set_shared_path_table(dynamic_mapinfo);
2120     } else {
2121       FileMapInfo::set_shared_path_table(static_mapinfo);
2122     }
2123   } else {
2124     set_shared_metaspace_range(NULL, NULL, NULL);
2125     UseSharedSpaces = false;
2126     FileMapInfo::fail_continue(&quot;Unable to map shared spaces&quot;);
2127     if (PrintSharedArchiveAndExit) {
2128       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;);
2129     }
2130   }
2131 
2132   if (static_mapinfo != NULL &amp;&amp; !static_mapinfo-&gt;is_mapped()) {
2133     delete static_mapinfo;
2134   }
2135   if (dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped()) {
2136     delete dynamic_mapinfo;
2137   }
2138 }
2139 
2140 FileMapInfo* MetaspaceShared::open_static_archive() {
2141   FileMapInfo* mapinfo = new FileMapInfo(true);
2142   if (!mapinfo-&gt;initialize()) {
2143     delete(mapinfo);
2144     return NULL;
2145   }
2146   return mapinfo;
2147 }
2148 
2149 FileMapInfo* MetaspaceShared::open_dynamic_archive() {
2150   if (DynamicDumpSharedSpaces) {
2151     return NULL;
2152   }
2153   if (Arguments::GetSharedDynamicArchivePath() == NULL) {
2154     return NULL;
2155   }
2156 
2157   FileMapInfo* mapinfo = new FileMapInfo(false);
2158   if (!mapinfo-&gt;initialize()) {
2159     delete(mapinfo);
2160     return NULL;
2161   }
2162   return mapinfo;
2163 }
2164 
2165 // use_requested_addr:
2166 //  true  = map at FileMapHeader::_requested_base_address
2167 //  false = map at an alternative address picked by OS.
2168 MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
2169                                                bool use_requested_addr) {
2170   PRODUCT_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2171       // For product build only -- this is for benchmarking the cost of doing relocation.
<a name="20" id="anc20"></a><span class="line-modified">2172       // For debug builds, the check is done in FileMapInfo::map_regions for better test coverage.</span>

2173       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2174       return MAP_ARCHIVE_MMAP_FAILURE;
2175     });
2176 
2177   if (ArchiveRelocationMode == 2 &amp;&amp; !use_requested_addr) {
2178     log_info(cds)(&quot;ArchiveRelocationMode == 2: never map archive(s) at an alternative address&quot;);
2179     return MAP_ARCHIVE_MMAP_FAILURE;
2180   };
2181 
2182   if (dynamic_mapinfo != NULL) {
2183     // Ensure that the OS won&#39;t be able to allocate new memory spaces between the two
2184     // archives, or else it would mess up the simple comparision in MetaspaceObj::is_shared().
2185     assert(static_mapinfo-&gt;mapping_end_offset() == dynamic_mapinfo-&gt;mapping_base_offset(), &quot;no gap&quot;);
2186   }
2187 
<a name="21" id="anc21"></a><span class="line-modified">2188   ReservedSpace main_rs, archive_space_rs, class_space_rs;</span>
2189   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2190   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
<a name="22" id="anc22"></a><span class="line-modified">2191                                                                  use_requested_addr, main_rs, archive_space_rs,</span>
2192                                                                  class_space_rs);
2193   if (mapped_base_address == NULL) {
2194     result = MAP_ARCHIVE_MMAP_FAILURE;
2195   } else {
<a name="23" id="anc23"></a>




















2196     log_debug(cds)(&quot;Reserved archive_space_rs     [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2197                    p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());
2198     log_debug(cds)(&quot;Reserved class_space_rs [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2199                    p2i(class_space_rs.base()), p2i(class_space_rs.end()), class_space_rs.size());
<a name="24" id="anc24"></a>






















2200     MapArchiveResult static_result = map_archive(static_mapinfo, mapped_base_address, archive_space_rs);
2201     MapArchiveResult dynamic_result = (static_result == MAP_ARCHIVE_SUCCESS) ?
2202                                      map_archive(dynamic_mapinfo, mapped_base_address, archive_space_rs) : MAP_ARCHIVE_OTHER_FAILURE;
2203 
2204     DEBUG_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
<a name="25" id="anc25"></a><span class="line-modified">2205       // This is for simulating mmap failures at the requested address. In debug builds, we do it</span>
<span class="line-modified">2206       // here (after all archives have possibly been mapped), so we can thoroughly test the code for</span>
<span class="line-modified">2207       // failure handling (releasing all allocated resource, etc).</span>

2208       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2209       if (static_result == MAP_ARCHIVE_SUCCESS) {
2210         static_result = MAP_ARCHIVE_MMAP_FAILURE;
2211       }
2212       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2213         dynamic_result = MAP_ARCHIVE_MMAP_FAILURE;
2214       }
2215     });
2216 
2217     if (static_result == MAP_ARCHIVE_SUCCESS) {
2218       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2219         result = MAP_ARCHIVE_SUCCESS;
2220       } else if (dynamic_result == MAP_ARCHIVE_OTHER_FAILURE) {
2221         assert(dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped(), &quot;must have failed&quot;);
2222         // No need to retry mapping the dynamic archive again, as it will never succeed
2223         // (bad file, etc) -- just keep the base archive.
2224         log_warning(cds, dynamic)(&quot;Unable to use shared archive. The top archive failed to load: %s&quot;,
2225                                   dynamic_mapinfo-&gt;full_path());
2226         result = MAP_ARCHIVE_SUCCESS;
2227         // TODO, we can give the unused space for the dynamic archive to class_space_rs, but there&#39;s no
2228         // easy API to do that right now.
2229       } else {
2230         result = MAP_ARCHIVE_MMAP_FAILURE;
2231       }
2232     } else if (static_result == MAP_ARCHIVE_OTHER_FAILURE) {
2233       result = MAP_ARCHIVE_OTHER_FAILURE;
2234     } else {
2235       result = MAP_ARCHIVE_MMAP_FAILURE;
2236     }
2237   }
2238 
2239   if (result == MAP_ARCHIVE_SUCCESS) {
<a name="26" id="anc26"></a><span class="line-removed">2240     if (!main_rs.is_reserved() &amp;&amp; class_space_rs.is_reserved()) {</span>
<span class="line-removed">2241       MemTracker::record_virtual_memory_type((address)class_space_rs.base(), mtClass);</span>
<span class="line-removed">2242     }</span>
2243     SharedBaseAddress = (size_t)mapped_base_address;
2244     LP64_ONLY({
2245         if (Metaspace::using_class_space()) {
<a name="27" id="anc27"></a><span class="line-modified">2246           assert(class_space_rs.is_reserved(), &quot;must be&quot;);</span>
<span class="line-modified">2247           char* cds_base = static_mapinfo-&gt;mapped_base();</span>
<span class="line-modified">2248           Metaspace::allocate_metaspace_compressed_klass_ptrs(class_space_rs, NULL, (address)cds_base);</span>






2249           // map_heap_regions() compares the current narrow oop and klass encodings
2250           // with the archived ones, so it must be done after all encodings are determined.
2251           static_mapinfo-&gt;map_heap_regions();
<a name="28" id="anc28"></a><span class="line-removed">2252           CompressedKlassPointers::set_range(CompressedClassSpaceSize);</span>
2253         }
2254       });
2255   } else {
2256     unmap_archive(static_mapinfo);
2257     unmap_archive(dynamic_mapinfo);
<a name="29" id="anc29"></a><span class="line-modified">2258     release_reserved_spaces(main_rs, archive_space_rs, class_space_rs);</span>
2259   }
2260 
2261   return result;
2262 }
2263 
<a name="30" id="anc30"></a>





















































2264 char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
2265                                                           FileMapInfo* dynamic_mapinfo,
<a name="31" id="anc31"></a><span class="line-modified">2266                                                           bool use_requested_addr,</span>
<span class="line-removed">2267                                                           ReservedSpace&amp; main_rs,</span>
2268                                                           ReservedSpace&amp; archive_space_rs,
2269                                                           ReservedSpace&amp; class_space_rs) {
<a name="32" id="anc32"></a><span class="line-modified">2270   const bool use_klass_space = NOT_LP64(false) LP64_ONLY(Metaspace::using_class_space());</span>
<span class="line-modified">2271   const size_t class_space_size = NOT_LP64(0) LP64_ONLY(Metaspace::compressed_class_space_size());</span>
<span class="line-removed">2272 </span>
<span class="line-removed">2273   if (use_klass_space) {</span>
<span class="line-removed">2274     assert(class_space_size &gt; 0, &quot;CompressedClassSpaceSize must have been validated&quot;);</span>
<span class="line-removed">2275   }</span>
<span class="line-removed">2276   if (use_requested_addr &amp;&amp; !is_aligned(static_mapinfo-&gt;requested_base_address(), reserved_space_alignment())) {</span>
<span class="line-removed">2277     return NULL;</span>
2278   }
2279 
2280   // Size and requested location of the archive_space_rs (for both static and dynamic archives)
<a name="33" id="anc33"></a><span class="line-modified">2281   size_t base_offset = static_mapinfo-&gt;mapping_base_offset();</span>
<span class="line-modified">2282   size_t end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo-&gt;mapping_end_offset() : dynamic_mapinfo-&gt;mapping_end_offset();</span>
<span class="line-modified">2283   assert(base_offset == 0, &quot;must be&quot;);</span>
<span class="line-modified">2284   assert(is_aligned(end_offset,  os::vm_allocation_granularity()), &quot;must be&quot;);</span>
<span class="line-modified">2285   assert(is_aligned(base_offset, os::vm_allocation_granularity()), &quot;must be&quot;);</span>
<span class="line-modified">2286 </span>
<span class="line-modified">2287   // In case reserved_space_alignment() != os::vm_allocation_granularity()</span>
<span class="line-modified">2288   assert((size_t)os::vm_allocation_granularity() &lt;= reserved_space_alignment(), &quot;must be&quot;);</span>
<span class="line-modified">2289   end_offset = align_up(end_offset, reserved_space_alignment());</span>
<span class="line-modified">2290 </span>
<span class="line-modified">2291   size_t archive_space_size = end_offset - base_offset;</span>
<span class="line-removed">2292 </span>
<span class="line-removed">2293   // Special handling for Windows because it cannot mmap into a reserved space:</span>
<span class="line-removed">2294   //    use_requested_addr: We just map each region individually, and give up if any one of them fails.</span>
<span class="line-removed">2295   //   !use_requested_addr: We reserve the space first, and then os::read in all the regions (instead of mmap).</span>
<span class="line-removed">2296   //                        We&#39;re going to patch all the pointers anyway so there&#39;s no benefit for mmap.</span>
<span class="line-removed">2297 </span>
<span class="line-removed">2298   if (use_requested_addr) {</span>
<span class="line-removed">2299     char* archive_space_base = static_mapinfo-&gt;requested_base_address() + base_offset;</span>
<span class="line-removed">2300     char* archive_space_end  = archive_space_base + archive_space_size;</span>
<span class="line-removed">2301     if (!MetaspaceShared::use_windows_memory_mapping()) {</span>
<span class="line-removed">2302       archive_space_rs = reserve_shared_space(archive_space_size, archive_space_base);</span>
<span class="line-removed">2303       if (!archive_space_rs.is_reserved()) {</span>
<span class="line-removed">2304         return NULL;</span>
<span class="line-removed">2305       }</span>
<span class="line-removed">2306     }</span>
<span class="line-removed">2307     if (use_klass_space) {</span>
<span class="line-removed">2308       // Make sure we can map the klass space immediately following the archive_space space</span>
<span class="line-removed">2309       // Don&#39;t call reserve_shared_space here as that may try to enforce platform-specific</span>
<span class="line-removed">2310       // alignment rules which only apply to the archive base address</span>
<span class="line-removed">2311       char* class_space_base = archive_space_end;</span>
<span class="line-removed">2312       class_space_rs = ReservedSpace(class_space_size, reserved_space_alignment(),</span>
<span class="line-removed">2313                                      false /* large_pages */, class_space_base);</span>
<span class="line-removed">2314       if (!class_space_rs.is_reserved()) {</span>
<span class="line-removed">2315         return NULL;</span>
<span class="line-removed">2316       }</span>
<span class="line-removed">2317     }</span>
<span class="line-removed">2318     return static_mapinfo-&gt;requested_base_address();</span>
<span class="line-removed">2319   } else {</span>
<span class="line-removed">2320     if (use_klass_space) {</span>
<span class="line-removed">2321       main_rs = reserve_shared_space(archive_space_size + class_space_size);</span>
<span class="line-removed">2322       if (main_rs.is_reserved()) {</span>
<span class="line-removed">2323         archive_space_rs = main_rs.first_part(archive_space_size, reserved_space_alignment(), /*split=*/true);</span>
<span class="line-removed">2324         class_space_rs = main_rs.last_part(archive_space_size);</span>
<span class="line-removed">2325       }</span>
<span class="line-removed">2326     } else {</span>
<span class="line-removed">2327       main_rs = reserve_shared_space(archive_space_size);</span>
<span class="line-removed">2328       archive_space_rs = main_rs;</span>
2329     }
<a name="34" id="anc34"></a>






2330     if (archive_space_rs.is_reserved()) {
<a name="35" id="anc35"></a>

2331       return archive_space_rs.base();
<a name="36" id="anc36"></a><span class="line-modified">2332     } else {</span>
<span class="line-modified">2333       return NULL;</span>






































2334     }
2335   }
<a name="37" id="anc37"></a>






























2336 }
2337 
<a name="38" id="anc38"></a><span class="line-modified">2338 void MetaspaceShared::release_reserved_spaces(ReservedSpace&amp; main_rs,</span>
<span class="line-removed">2339                                               ReservedSpace&amp; archive_space_rs,</span>
2340                                               ReservedSpace&amp; class_space_rs) {
<a name="39" id="anc39"></a><span class="line-modified">2341   if (main_rs.is_reserved()) {</span>
<span class="line-modified">2342     assert(main_rs.contains(archive_space_rs.base()), &quot;must be&quot;);</span>
<span class="line-modified">2343     assert(main_rs.contains(class_space_rs.base()), &quot;must be&quot;);</span>
<span class="line-modified">2344     log_debug(cds)(&quot;Released shared space (archive+classes) &quot; INTPTR_FORMAT, p2i(main_rs.base()));</span>
<span class="line-modified">2345     main_rs.release();</span>
<span class="line-modified">2346   } else {</span>
<span class="line-modified">2347     if (archive_space_rs.is_reserved()) {</span>
<span class="line-removed">2348       log_debug(cds)(&quot;Released shared space (archive) &quot; INTPTR_FORMAT, p2i(archive_space_rs.base()));</span>
<span class="line-removed">2349       archive_space_rs.release();</span>
<span class="line-removed">2350     }</span>
<span class="line-removed">2351     if (class_space_rs.is_reserved()) {</span>
<span class="line-removed">2352       log_debug(cds)(&quot;Released shared space (classes) &quot; INTPTR_FORMAT, p2i(class_space_rs.base()));</span>
<span class="line-removed">2353       class_space_rs.release();</span>
<span class="line-removed">2354     }</span>
2355   }
2356 }
2357 
2358 static int archive_regions[]  = {MetaspaceShared::mc,
2359                                  MetaspaceShared::rw,
2360                                  MetaspaceShared::ro};
2361 static int archive_regions_count  = 3;
2362 
2363 MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {
2364   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2365   if (mapinfo == NULL) {
2366     return MAP_ARCHIVE_SUCCESS; // The dynamic archive has not been specified. No error has happened -- trivially succeeded.
2367   }
2368 
2369   mapinfo-&gt;set_is_mapped(false);
2370 
2371   if (mapinfo-&gt;alignment() != (size_t)os::vm_allocation_granularity()) {
2372     log_error(cds)(&quot;Unable to map CDS archive -- os::vm_allocation_granularity() expected: &quot; SIZE_FORMAT
2373                    &quot; actual: %d&quot;, mapinfo-&gt;alignment(), os::vm_allocation_granularity());
2374     return MAP_ARCHIVE_OTHER_FAILURE;
2375   }
2376 
2377   MapArchiveResult result =
2378     mapinfo-&gt;map_regions(archive_regions, archive_regions_count, mapped_base_address, rs);
2379 
2380   if (result != MAP_ARCHIVE_SUCCESS) {
2381     unmap_archive(mapinfo);
2382     return result;
2383   }
2384 
2385   if (mapinfo-&gt;is_static()) {
2386     if (!mapinfo-&gt;validate_shared_path_table()) {
2387       unmap_archive(mapinfo);
2388       return MAP_ARCHIVE_OTHER_FAILURE;
2389     }
2390   } else {
2391     if (!DynamicArchive::validate(mapinfo)) {
2392       unmap_archive(mapinfo);
2393       return MAP_ARCHIVE_OTHER_FAILURE;
2394     }
2395   }
2396 
2397   mapinfo-&gt;set_is_mapped(true);
2398   return MAP_ARCHIVE_SUCCESS;
2399 }
2400 
2401 void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {
2402   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2403   if (mapinfo != NULL) {
2404     mapinfo-&gt;unmap_regions(archive_regions, archive_regions_count);
2405     mapinfo-&gt;set_is_mapped(false);
2406   }
2407 }
2408 
2409 // Read the miscellaneous data from the shared file, and
2410 // serialize it out to its various destinations.
2411 
2412 void MetaspaceShared::initialize_shared_spaces() {
2413   FileMapInfo *static_mapinfo = FileMapInfo::current_info();
2414   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2415   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2416   char* buffer = static_mapinfo-&gt;cloned_vtables();
2417   clone_cpp_vtables((intptr_t*)buffer);
2418 
2419   // Verify various attributes of the archive, plus initialize the
2420   // shared string/symbol tables
2421   buffer = static_mapinfo-&gt;serialized_data();
2422   intptr_t* array = (intptr_t*)buffer;
2423   ReadClosure rc(&amp;array);
2424   serialize(&amp;rc);
2425 
2426   // Initialize the run-time symbol table.
2427   SymbolTable::create_table();
2428 
2429   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2430 
2431   // Close the mapinfo file
2432   static_mapinfo-&gt;close();
2433 
2434   static_mapinfo-&gt;unmap_region(MetaspaceShared::bm);
2435 
2436   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2437   if (dynamic_mapinfo != NULL) {
2438     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2439     ReadClosure rc(&amp;buffer);
2440     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2441     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2442     dynamic_mapinfo-&gt;close();
2443   }
2444 
2445   if (PrintSharedArchiveAndExit) {
2446     if (PrintSharedDictionary) {
2447       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2448       SystemDictionaryShared::print_on(tty);
2449     }
2450     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2451       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2452       vm_exit(1);
2453     } else {
2454       tty-&gt;print_cr(&quot;archive is valid&quot;);
2455       vm_exit(0);
2456     }
2457   }
2458 }
2459 
2460 // JVM/TI RedefineClasses() support:
2461 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2462   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2463 
2464   if (UseSharedSpaces) {
2465     // remap the shared readonly space to shared readwrite, private
2466     FileMapInfo* mapinfo = FileMapInfo::current_info();
2467     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2468       return false;
2469     }
2470     if (FileMapInfo::dynamic_info() != NULL) {
2471       mapinfo = FileMapInfo::dynamic_info();
2472       if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2473         return false;
2474       }
2475     }
2476     _remapped_readwrite = true;
2477   }
2478   return true;
2479 }
2480 
2481 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2482   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2483   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2484   // or so.
2485   _mc_region.print_out_of_space_msg(name, needed_bytes);
2486   _rw_region.print_out_of_space_msg(name, needed_bytes);
2487   _ro_region.print_out_of_space_msg(name, needed_bytes);
2488 
2489   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2490                                 &quot;Please reduce the number of shared classes.&quot;);
2491 }
2492 
2493 // This is used to relocate the pointers so that the archive can be mapped at
2494 // Arguments::default_SharedBaseAddress() without runtime relocation.
2495 intx MetaspaceShared::final_delta() {
2496   return intx(Arguments::default_SharedBaseAddress())  // We want the archive to be mapped to here at runtime
2497        - intx(SharedBaseAddress);                      // .. but the archive is mapped at here at dump time
2498 }
<a name="40" id="anc40"></a>



























<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceClosure.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceClosure.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
251   // MetaspaceClosure::finish()
252   static const int MAX_NEST_LEVEL = 5;
253   Ref* _pending_refs;
254   int _nest_level;
255 
256   void push_impl(Ref* ref);
257   void do_push(Ref* ref);
258 
259 public:
260   MetaspaceClosure(): _pending_refs(NULL), _nest_level(0) {}
261   ~MetaspaceClosure();
262 
263   void finish();
264 
265   // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
266   virtual bool do_ref(Ref* ref, bool read_only) = 0;
267 
268   // When you do:
269   //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
270   //       it-&gt;push(_my_field)

271   //
272   // C++ will try to match the &quot;most specific&quot; template function. This one will
273   // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
274   template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
275     push_impl(new PointerArrayRef&lt;T&gt;(mpp, w));
276   }
277 
278   // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
279   // this is the second choice.
280   template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
281     push_impl(new PrimitiveArrayRef&lt;T&gt;(mpp, w));
282   }
283 
284   // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
285   // this will be matched by default.
286   template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
287     push_impl(new ObjectRef&lt;T&gt;(mpp, w));
288   }
289 
290   template &lt;class T&gt; void push_method_entry(T** mpp, intptr_t* p) {
</pre>
</td>
<td>
<hr />
<pre>
251   // MetaspaceClosure::finish()
252   static const int MAX_NEST_LEVEL = 5;
253   Ref* _pending_refs;
254   int _nest_level;
255 
256   void push_impl(Ref* ref);
257   void do_push(Ref* ref);
258 
259 public:
260   MetaspaceClosure(): _pending_refs(NULL), _nest_level(0) {}
261   ~MetaspaceClosure();
262 
263   void finish();
264 
265   // returns true if we want to keep iterating the pointers embedded inside &lt;ref&gt;
266   virtual bool do_ref(Ref* ref, bool read_only) = 0;
267 
268   // When you do:
269   //     void MyType::metaspace_pointers_do(MetaspaceClosure* it) {
270   //       it-&gt;push(_my_field)
<span class="line-added">271   //     }</span>
272   //
273   // C++ will try to match the &quot;most specific&quot; template function. This one will
274   // will be matched if possible (if mpp is an Array&lt;&gt; of any pointer type).
275   template &lt;typename T&gt; void push(Array&lt;T*&gt;** mpp, Writability w = _default) {
276     push_impl(new PointerArrayRef&lt;T&gt;(mpp, w));
277   }
278 
279   // If the above function doesn&#39;t match (mpp is an Array&lt;&gt;, but T is not a pointer type), then
280   // this is the second choice.
281   template &lt;typename T&gt; void push(Array&lt;T&gt;** mpp, Writability w = _default) {
282     push_impl(new PrimitiveArrayRef&lt;T&gt;(mpp, w));
283   }
284 
285   // If the above function doesn&#39;t match (mpp is not an Array&lt;&gt; type), then
286   // this will be matched by default.
287   template &lt;class T&gt; void push(T** mpp, Writability w = _default) {
288     push_impl(new ObjectRef&lt;T&gt;(mpp, w));
289   }
290 
291   template &lt;class T&gt; void push_method_entry(T** mpp, intptr_t* p) {
</pre>
</td>
</tr>
</table>
<center><a href="dynamicArchive.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
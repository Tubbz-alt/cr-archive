<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/methodHandles_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;classfile/javaClasses.inline.hpp&quot;
 30 #include &quot;interpreter/interpreter.hpp&quot;
 31 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;prims/methodHandles.hpp&quot;
 36 #include &quot;runtime/flags/flagSetting.hpp&quot;
 37 #include &quot;runtime/frame.inline.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
 40 #define __ Disassembler::hook&lt;MacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
 41 
 42 #ifdef PRODUCT
 43 #define BLOCK_COMMENT(str) /* nothing */
 44 #define STOP(error) stop(error)
 45 #else
 46 #define BLOCK_COMMENT(str) __ block_comment(str)
 47 #define STOP(error) block_comment(error); __ stop(error)
 48 #endif
 49 
 50 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
 51 
 52 void MethodHandles::load_klass_from_Class(MacroAssembler* _masm, Register klass_reg) {
 53   if (VerifyMethodHandles)
 54     verify_klass(_masm, klass_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_Class),
 55                  &quot;MH argument is a Class&quot;);
 56   __ movptr(klass_reg, Address(klass_reg, java_lang_Class::klass_offset_in_bytes()));
 57 }
 58 
 59 #ifdef ASSERT
 60 static int check_nonzero(const char* xname, int x) {
 61   assert(x != 0, &quot;%s should be nonzero&quot;, xname);
 62   return x;
 63 }
 64 #define NONZERO(x) check_nonzero(#x, x)
 65 #else //ASSERT
 66 #define NONZERO(x) (x)
 67 #endif //ASSERT
 68 
 69 #ifdef ASSERT
 70 void MethodHandles::verify_klass(MacroAssembler* _masm,
 71                                  Register obj, SystemDictionary::WKID klass_id,
 72                                  const char* error_message) {
 73   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 74   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 75   Register temp = rdi;
 76   Register temp2 = noreg;
 77   LP64_ONLY(temp2 = rscratch1);  // used by MacroAssembler::cmpptr and load_klass
 78   Label L_ok, L_bad;
 79   BLOCK_COMMENT(&quot;verify_klass {&quot;);
 80   __ verify_oop(obj);
 81   __ testptr(obj, obj);
 82   __ jcc(Assembler::zero, L_bad);
 83   __ push(temp); if (temp2 != noreg)  __ push(temp2);
 84 #define UNPUSH { if (temp2 != noreg)  __ pop(temp2);  __ pop(temp); }
 85   __ load_klass(temp, obj, temp2);
 86   __ cmpptr(temp, ExternalAddress((address) klass_addr));
 87   __ jcc(Assembler::equal, L_ok);
 88   intptr_t super_check_offset = klass-&gt;super_check_offset();
 89   __ movptr(temp, Address(temp, super_check_offset));
 90   __ cmpptr(temp, ExternalAddress((address) klass_addr));
 91   __ jcc(Assembler::equal, L_ok);
 92   UNPUSH;
 93   __ bind(L_bad);
 94   __ STOP(error_message);
 95   __ BIND(L_ok);
 96   UNPUSH;
 97   BLOCK_COMMENT(&quot;} verify_klass&quot;);
 98 }
 99 
100 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind, Register member_reg, Register temp) {
101   Label L;
102   BLOCK_COMMENT(&quot;verify_ref_kind {&quot;);
103   __ movl(temp, Address(member_reg, NONZERO(java_lang_invoke_MemberName::flags_offset_in_bytes())));
104   __ shrl(temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT);
105   __ andl(temp, java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK);
106   __ cmpl(temp, ref_kind);
107   __ jcc(Assembler::equal, L);
108   { char* buf = NEW_C_HEAP_ARRAY(char, 100, mtInternal);
109     jio_snprintf(buf, 100, &quot;verify_ref_kind expected %x&quot;, ref_kind);
110     if (ref_kind == JVM_REF_invokeVirtual ||
111         ref_kind == JVM_REF_invokeSpecial)
112       // could do this for all ref_kinds, but would explode assembly code size
113       trace_method_handle(_masm, buf);
114     __ STOP(buf);
115   }
116   BLOCK_COMMENT(&quot;} verify_ref_kind&quot;);
117   __ bind(L);
118 }
119 
120 #endif //ASSERT
121 
122 void MethodHandles::jump_from_method_handle(MacroAssembler* _masm, Register method, Register temp,
123                                             bool for_compiler_entry) {
124   assert(method == rbx, &quot;interpreter calling convention&quot;);
125 
126    Label L_no_such_method;
127    __ testptr(rbx, rbx);
128    __ jcc(Assembler::zero, L_no_such_method);
129 
130   __ verify_method_ptr(method);
131 
132   if (!for_compiler_entry &amp;&amp; JvmtiExport::can_post_interpreter_events()) {
133     Label run_compiled_code;
134     // JVMTI events, such as single-stepping, are implemented partly by avoiding running
135     // compiled code in threads for which the event is enabled.  Check here for
136     // interp_only_mode if these events CAN be enabled.
137 #ifdef _LP64
138     Register rthread = r15_thread;
139 #else
140     Register rthread = temp;
141     __ get_thread(rthread);
142 #endif
143     // interp_only is an int, on little endian it is sufficient to test the byte only
144     // Is a cmpl faster?
145     __ cmpb(Address(rthread, JavaThread::interp_only_mode_offset()), 0);
146     __ jccb(Assembler::zero, run_compiled_code);
147     __ jmp(Address(method, Method::interpreter_entry_offset()));
148     __ BIND(run_compiled_code);
149   }
150 
151   // The following jump might pass a value type argument that was erased to Object as oop to a
152   // callee that expects value type arguments to be passed as fields. We need to call the compiled
153   // value entry (_code-&gt;value_entry_point() or _adapter-&gt;c2i_value_entry()) which will take care
154   // of translating between the calling conventions.
155   const ByteSize entry_offset = for_compiler_entry ? Method::from_compiled_value_offset() :
156                                                      Method::from_interpreted_offset();
157   __ jmp(Address(method, entry_offset));
158 
159   __ bind(L_no_such_method);
160   __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));
161 }
162 
163 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
164                                         Register recv, Register method_temp,
165                                         Register temp2,
166                                         bool for_compiler_entry) {
167   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
168   // This is the initial entry point of a lazy method handle.
169   // After type checking, it picks up the invoker from the LambdaForm.
170   assert_different_registers(recv, method_temp, temp2);
171   assert(recv != noreg, &quot;required register&quot;);
172   assert(method_temp == rbx, &quot;required register for loading method&quot;);
173 
174   //NOT_PRODUCT({ FlagSetting fs(TraceMethodHandles, true); trace_method_handle(_masm, &quot;LZMH&quot;); });
175 
176   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
177   __ verify_oop(recv);
178   __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())), temp2);
179   __ verify_oop(method_temp);
180   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())), temp2);
181   __ verify_oop(method_temp);
182   __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())), temp2);
183   __ verify_oop(method_temp);
184   __ access_load_at(T_ADDRESS, IN_HEAP, method_temp,
185                     Address(method_temp, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())),
186                     noreg, noreg);
187 
188   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
189     // make sure recv is already on stack
190     __ movptr(temp2, Address(method_temp, Method::const_offset()));
191     __ load_sized_value(temp2,
192                         Address(temp2, ConstMethod::size_of_parameters_offset()),
193                         sizeof(u2), /*is_signed*/ false);
194     // assert(sizeof(u2) == sizeof(Method::_size_of_parameters), &quot;&quot;);
195     Label L;
196     __ cmpoop(recv, __ argument_address(temp2, -1));
197     __ jcc(Assembler::equal, L);
198     __ movptr(rax, __ argument_address(temp2, -1));
199     __ STOP(&quot;receiver not on stack&quot;);
200     __ BIND(L);
201   }
202 
203   jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry);
204   BLOCK_COMMENT(&quot;} jump_to_lambda_form&quot;);
205 }
206 
207 
208 // Code generation
209 address MethodHandles::generate_method_handle_interpreter_entry(MacroAssembler* _masm,
210                                                                 vmIntrinsics::ID iid) {
211   const bool not_for_compiler_entry = false;  // this is the interpreter entry
212   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
213   if (iid == vmIntrinsics::_invokeGeneric ||
214       iid == vmIntrinsics::_compiledLambdaForm) {
215     // Perhaps surprisingly, the symbolic references visible to Java are not directly used.
216     // They are linked to Java-generated adapters via MethodHandleNatives.linkMethod.
217     // They all allow an appendix argument.
218     __ hlt();           // empty stubs make SG sick
219     return NULL;
220   }
221 
222   // rsi/r13: sender SP (must preserve; see prepare_to_jump_from_interpreted)
223   // rbx: Method*
224   // rdx: argument locator (parameter slot count, added to rsp)
225   // rcx: used as temp to hold mh or receiver
226   // rax, rdi: garbage temps, blown away
227   Register rdx_argp   = rdx;   // argument list ptr, live on error paths
228   Register rax_temp   = rax;
229   Register rcx_mh     = rcx;   // MH receiver; dies quickly and is recycled
230   Register rbx_method = rbx;   // eventual target of this invocation
231 
232   // here&#39;s where control starts out:
233   __ align(CodeEntryAlignment);
234   address entry_point = __ pc();
235 
236   if (VerifyMethodHandles) {
237     assert(Method::intrinsic_id_size_in_bytes() == 2, &quot;assuming Method::_intrinsic_id is u2&quot;);
238 
239     Label L;
240     BLOCK_COMMENT(&quot;verify_intrinsic_id {&quot;);
241     __ cmpw(Address(rbx_method, Method::intrinsic_id_offset_in_bytes()), (int) iid);
242     __ jcc(Assembler::equal, L);
243     if (iid == vmIntrinsics::_linkToVirtual ||
244         iid == vmIntrinsics::_linkToSpecial) {
245       // could do this for all kinds, but would explode assembly code size
246       trace_method_handle(_masm, &quot;bad Method*::intrinsic_id&quot;);
247     }
248     __ STOP(&quot;bad Method*::intrinsic_id&quot;);
249     __ bind(L);
250     BLOCK_COMMENT(&quot;} verify_intrinsic_id&quot;);
251   }
252 
253   // First task:  Find out how big the argument list is.
254   Address rdx_first_arg_addr;
255   int ref_kind = signature_polymorphic_intrinsic_ref_kind(iid);
256   assert(ref_kind != 0 || iid == vmIntrinsics::_invokeBasic, &quot;must be _invokeBasic or a linkTo intrinsic&quot;);
257   if (ref_kind == 0 || MethodHandles::ref_kind_has_receiver(ref_kind)) {
258     __ movptr(rdx_argp, Address(rbx_method, Method::const_offset()));
259     __ load_sized_value(rdx_argp,
260                         Address(rdx_argp, ConstMethod::size_of_parameters_offset()),
261                         sizeof(u2), /*is_signed*/ false);
262     // assert(sizeof(u2) == sizeof(Method::_size_of_parameters), &quot;&quot;);
263     rdx_first_arg_addr = __ argument_address(rdx_argp, -1);
264   } else {
265     DEBUG_ONLY(rdx_argp = noreg);
266   }
267 
268   if (!is_signature_polymorphic_static(iid)) {
269     __ movptr(rcx_mh, rdx_first_arg_addr);
270     DEBUG_ONLY(rdx_argp = noreg);
271   }
272 
273   // rdx_first_arg_addr is live!
274 
275   trace_method_handle_interpreter_entry(_masm, iid);
276 
277   if (iid == vmIntrinsics::_invokeBasic) {
278     generate_method_handle_dispatch(_masm, iid, rcx_mh, noreg, not_for_compiler_entry);
279 
280   } else {
281     // Adjust argument list by popping the trailing MemberName argument.
282     Register rcx_recv = noreg;
283     if (MethodHandles::ref_kind_has_receiver(ref_kind)) {
284       // Load the receiver (not the MH; the actual MemberName&#39;s receiver) up from the interpreter stack.
285       __ movptr(rcx_recv = rcx, rdx_first_arg_addr);
286     }
287     DEBUG_ONLY(rdx_argp = noreg);
288     Register rbx_member = rbx_method;  // MemberName ptr; incoming method ptr is dead now
289     __ pop(rax_temp);           // return address
290     __ pop(rbx_member);         // extract last argument
291     __ push(rax_temp);          // re-push return address
292     generate_method_handle_dispatch(_masm, iid, rcx_recv, rbx_member, not_for_compiler_entry);
293   }
294 
295   return entry_point;
296 }
297 
298 void MethodHandles::generate_method_handle_dispatch(MacroAssembler* _masm,
299                                                     vmIntrinsics::ID iid,
300                                                     Register receiver_reg,
301                                                     Register member_reg,
302                                                     bool for_compiler_entry) {
303   assert(is_signature_polymorphic(iid), &quot;expected invoke iid&quot;);
304   Register rbx_method = rbx;   // eventual target of this invocation
305   // temps used in this code are not used in *either* compiled or interpreted calling sequences
306 #ifdef _LP64
307   Register temp1 = rscratch1;
308   Register temp2 = rscratch2;
309   Register temp3 = rax;
310   if (for_compiler_entry) {
311     assert(receiver_reg == (iid == vmIntrinsics::_linkToStatic ? noreg : j_rarg0), &quot;only valid assignment&quot;);
312     assert_different_registers(temp1,        j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5);
313     assert_different_registers(temp2,        j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5);
314     assert_different_registers(temp3,        j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5);
315   }
316 #else
317   Register temp1 = (for_compiler_entry ? rsi : rdx);
318   Register temp2 = rdi;
319   Register temp3 = rax;
320   if (for_compiler_entry) {
321     assert(receiver_reg == (iid == vmIntrinsics::_linkToStatic ? noreg : rcx), &quot;only valid assignment&quot;);
322     assert_different_registers(temp1,        rcx, rdx);
323     assert_different_registers(temp2,        rcx, rdx);
324     assert_different_registers(temp3,        rcx, rdx);
325   }
326 #endif
327   else {
328     assert_different_registers(temp1, temp2, temp3, saved_last_sp_register());  // don&#39;t trash lastSP
329   }
330   assert_different_registers(temp1, temp2, temp3, receiver_reg);
331   assert_different_registers(temp1, temp2, temp3, member_reg);
332 
333   if (iid == vmIntrinsics::_invokeBasic) {
334     // indirect through MH.form.vmentry.vmtarget
335     jump_to_lambda_form(_masm, receiver_reg, rbx_method, temp1, for_compiler_entry);
336 
337   } else {
338     // The method is a member invoker used by direct method handles.
339     if (VerifyMethodHandles) {
340       // make sure the trailing argument really is a MemberName (caller responsibility)
341       verify_klass(_masm, member_reg, SystemDictionary::WK_KLASS_ENUM_NAME(java_lang_invoke_MemberName),
342                    &quot;MemberName required for invokeVirtual etc.&quot;);
343     }
344 
345     Address member_clazz(    member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));
346     Address member_vmindex(  member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));
347     Address member_vmtarget( member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));
348     Address vmtarget_method( rbx_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));
349 
350     Register temp1_recv_klass = temp1;
351     if (iid != vmIntrinsics::_linkToStatic) {
352       __ verify_oop(receiver_reg);
353       if (iid == vmIntrinsics::_linkToSpecial) {
354         // Don&#39;t actually load the klass; just null-check the receiver.
355         __ null_check(receiver_reg);
356       } else {
357         // load receiver klass itself
358         __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());
359         __ load_klass(temp1_recv_klass, receiver_reg, temp2);
360         __ verify_klass_ptr(temp1_recv_klass);
361       }
362       BLOCK_COMMENT(&quot;check_receiver {&quot;);
363       // The receiver for the MemberName must be in receiver_reg.
364       // Check the receiver against the MemberName.clazz
365       if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
366         // Did not load it above...
367         __ load_klass(temp1_recv_klass, receiver_reg, temp2);
368         __ verify_klass_ptr(temp1_recv_klass);
369       }
370       if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
371         Label L_ok;
372         Register temp2_defc = temp2;
373         __ load_heap_oop(temp2_defc, member_clazz, temp3);
374         load_klass_from_Class(_masm, temp2_defc);
375         __ verify_klass_ptr(temp2_defc);
376         __ check_klass_subtype(temp1_recv_klass, temp2_defc, temp3, L_ok);
377         // If we get here, the type check failed!
378         __ STOP(&quot;receiver class disagrees with MemberName.clazz&quot;);
379         __ bind(L_ok);
380       }
381       BLOCK_COMMENT(&quot;} check_receiver&quot;);
382     }
383     if (iid == vmIntrinsics::_linkToSpecial ||
384         iid == vmIntrinsics::_linkToStatic) {
385       DEBUG_ONLY(temp1_recv_klass = noreg);  // these guys didn&#39;t load the recv_klass
386     }
387 
388     // Live registers at this point:
389     //  member_reg - MemberName that was the trailing argument
390     //  temp1_recv_klass - klass of stacked receiver, if needed
391     //  rsi/r13 - interpreter linkage (if interpreted)
392     //  rcx, rdx, rsi, rdi, r8 - compiler arguments (if compiled)
393 
394     Label L_incompatible_class_change_error;
395     switch (iid) {
396     case vmIntrinsics::_linkToSpecial:
397       if (VerifyMethodHandles) {
398         verify_ref_kind(_masm, JVM_REF_invokeSpecial, member_reg, temp3);
399       }
400       __ load_heap_oop(rbx_method, member_vmtarget);
401       __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg, noreg);
402       break;
403 
404     case vmIntrinsics::_linkToStatic:
405       if (VerifyMethodHandles) {
406         verify_ref_kind(_masm, JVM_REF_invokeStatic, member_reg, temp3);
407       }
408       __ load_heap_oop(rbx_method, member_vmtarget);
409       __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg, noreg);
410       break;
411 
412     case vmIntrinsics::_linkToVirtual:
413     {
414       // same as TemplateTable::invokevirtual,
415       // minus the CP setup and profiling:
416 
417       if (VerifyMethodHandles) {
418         verify_ref_kind(_masm, JVM_REF_invokeVirtual, member_reg, temp3);
419       }
420 
421       // pick out the vtable index from the MemberName, and then we can discard it:
422       Register temp2_index = temp2;
423       __ access_load_at(T_ADDRESS, IN_HEAP, temp2_index, member_vmindex, noreg, noreg);
424 
425       if (VerifyMethodHandles) {
426         Label L_index_ok;
427         __ cmpl(temp2_index, 0);
428         __ jcc(Assembler::greaterEqual, L_index_ok);
429         __ STOP(&quot;no virtual index&quot;);
430         __ BIND(L_index_ok);
431       }
432 
433       // Note:  The verifier invariants allow us to ignore MemberName.clazz and vmtarget
434       // at this point.  And VerifyMethodHandles has already checked clazz, if needed.
435 
436       // get target Method* &amp; entry point
437       __ lookup_virtual_method(temp1_recv_klass, temp2_index, rbx_method);
438       break;
439     }
440 
441     case vmIntrinsics::_linkToInterface:
442     {
443       // same as TemplateTable::invokeinterface
444       // (minus the CP setup and profiling, with different argument motion)
445       if (VerifyMethodHandles) {
446         verify_ref_kind(_masm, JVM_REF_invokeInterface, member_reg, temp3);
447       }
448 
449       Register temp3_intf = temp3;
450       __ load_heap_oop(temp3_intf, member_clazz);
451       load_klass_from_Class(_masm, temp3_intf);
452       __ verify_klass_ptr(temp3_intf);
453 
454       Register rbx_index = rbx_method;
455       __ access_load_at(T_ADDRESS, IN_HEAP, rbx_index, member_vmindex, noreg, noreg);
456       if (VerifyMethodHandles) {
457         Label L;
458         __ cmpl(rbx_index, 0);
459         __ jcc(Assembler::greaterEqual, L);
460         __ STOP(&quot;invalid vtable index for MH.invokeInterface&quot;);
461         __ bind(L);
462       }
463 
464       // given intf, index, and recv klass, dispatch to the implementation method
465       __ lookup_interface_method(temp1_recv_klass, temp3_intf,
466                                  // note: next two args must be the same:
467                                  rbx_index, rbx_method,
468                                  temp2,
469                                  L_incompatible_class_change_error);
470       break;
471     }
472 
473     default:
474       fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
475       break;
476     }
477 
478     // Live at this point:
479     //   rbx_method
480     //   rsi/r13 (if interpreted)
481 
482     // After figuring out which concrete method to call, jump into it.
483     // Note that this works in the interpreter with no data motion.
484     // But the compiled version will require that rcx_recv be shifted out.
485     __ verify_method_ptr(rbx_method);
486     jump_from_method_handle(_masm, rbx_method, temp1, for_compiler_entry);
487 
488     if (iid == vmIntrinsics::_linkToInterface) {
489       __ bind(L_incompatible_class_change_error);
490       __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));
491     }
492   }
493 }
494 
495 #ifndef PRODUCT
496 void trace_method_handle_stub(const char* adaptername,
497                               oop mh,
498                               intptr_t* saved_regs,
499                               intptr_t* entry_sp) {
500   // called as a leaf from native code: do not block the JVM!
501   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
502                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
503   const char* mh_reg_name = has_mh ? &quot;rcx_mh&quot; : &quot;rcx&quot;;
504   tty-&gt;print_cr(&quot;MH %s %s=&quot; PTR_FORMAT &quot; sp=&quot; PTR_FORMAT,
505                 adaptername, mh_reg_name,
506                 p2i(mh), p2i(entry_sp));
507 
508   if (Verbose) {
<a name="1" id="anc1"></a><span class="line-added">509     ResourceMark rm;</span>
510     tty-&gt;print_cr(&quot;Registers:&quot;);
511     const int saved_regs_count = RegisterImpl::number_of_registers;
512     for (int i = 0; i &lt; saved_regs_count; i++) {
513       Register r = as_Register(i);
514       // The registers are stored in reverse order on the stack (by pusha).
515 #ifdef AMD64
516       assert(RegisterImpl::number_of_registers == 16, &quot;sanity&quot;);
517       if (r == rsp) {
518         // rsp is actually not stored by pusha(), compute the old rsp from saved_regs (rsp after pusha): saved_regs + 16 = old rsp
519         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), (intptr_t)(&amp;saved_regs[16]));
520       } else {
521         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
522       }
523 #else
524       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
525 #endif
526       if ((i + 1) % 4 == 0) {
527         tty-&gt;cr();
528       } else {
529         tty-&gt;print(&quot;, &quot;);
530       }
531     }
532     tty-&gt;cr();
533 
534     {
<a name="2" id="anc2"></a><span class="line-modified">535       // dumping last frame with frame::describe</span>
536 
537       JavaThread* p = JavaThread::active();
538 
<a name="3" id="anc3"></a><span class="line-modified">539       PRESERVE_EXCEPTION_MARK; // may not be needed but safer and inexpensive here</span>

540       FrameValues values;
541 
542       // Note: We want to allow trace_method_handle from any call site.
543       // While trace_method_handle creates a frame, it may be entered
544       // without a PC on the stack top (e.g. not just after a call).
545       // Walking that frame could lead to failures due to that invalid PC.
546       // =&gt; carefully detect that frame when doing the stack walking
547 
548       // Current C frame
549       frame cur_frame = os::current_frame();
550 
551       // Robust search of trace_calling_frame (independant of inlining).
552       // Assumes saved_regs comes from a pusha in the trace_calling_frame.
553       assert(cur_frame.sp() &lt; saved_regs, &quot;registers not saved on stack ?&quot;);
554       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
555       while (trace_calling_frame.fp() &lt; saved_regs) {
556         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
557       }
558 
559       // safely create a frame and call frame::describe
560       intptr_t *dump_sp = trace_calling_frame.sender_sp();
561       intptr_t *dump_fp = trace_calling_frame.link();
562 
563       bool walkable = has_mh; // whether the traced frame shoud be walkable
564 
565       if (walkable) {
566         // The previous definition of walkable may have to be refined
567         // if new call sites cause the next frame constructor to start
568         // failing. Alternatively, frame constructors could be
569         // modified to support the current or future non walkable
570         // frames (but this is more intrusive and is not considered as
571         // part of this RFE, which will instead use a simpler output).
572         frame dump_frame = frame(dump_sp, dump_fp);
573         dump_frame.describe(values, 1);
574       } else {
575         // Stack may not be walkable (invalid PC above FP):
576         // Add descriptions without building a Java frame to avoid issues
577         values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
578         values.describe(-1, dump_sp, &quot;sp for #1&quot;);
579       }
580       values.describe(-1, entry_sp, &quot;raw top of stack&quot;);
581 
582       tty-&gt;print_cr(&quot;Stack layout:&quot;);
583       values.print(p);
584     }
585     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
586       mh-&gt;print();
587       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<a name="4" id="anc4"></a><span class="line-modified">588         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
589           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
<a name="5" id="anc5"></a><span class="line-added">590         }</span>
591       }
592     }
593   }
594 }
595 
596 // The stub wraps the arguments in a struct on the stack to avoid
597 // dealing with the different calling conventions for passing 6
598 // arguments.
599 struct MethodHandleStubArguments {
600   const char* adaptername;
601   oopDesc* mh;
602   intptr_t* saved_regs;
603   intptr_t* entry_sp;
604 };
605 void trace_method_handle_stub_wrapper(MethodHandleStubArguments* args) {
606   trace_method_handle_stub(args-&gt;adaptername,
607                            args-&gt;mh,
608                            args-&gt;saved_regs,
609                            args-&gt;entry_sp);
610 }
611 
612 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
613   if (!log_is_enabled(Info, methodhandles))  return;
614   BLOCK_COMMENT(err_msg(&quot;trace_method_handle %s {&quot;, adaptername));
615   __ enter();
616   __ andptr(rsp, -16); // align stack if needed for FPU state
617   __ pusha();
618   __ mov(rbx, rsp); // for retreiving saved_regs
619   // Note: saved_regs must be in the entered frame for the
620   // robust stack walking implemented in trace_method_handle_stub.
621 
622   // save FP result, valid at some call sites (adapter_opt_return_float, ...)
623   __ decrement(rsp, 2 * wordSize);
624 #ifdef _LP64
625   __ movdbl(Address(rsp, 0), xmm0);
626 #else
627   if  (UseSSE &gt;= 2) {
628     __ movdbl(Address(rsp, 0), xmm0);
629   } else if (UseSSE == 1) {
630     __ movflt(Address(rsp, 0), xmm0);
631   } else {
632     __ fst_d(Address(rsp, 0));
633   }
634 #endif // LP64
635 
636   // Incoming state:
637   // rcx: method handle
638   //
639   // To avoid calling convention issues, build a record on the stack
640   // and pass the pointer to that instead.
641   __ push(rbp);               // entry_sp (with extra align space)
642   __ push(rbx);               // pusha saved_regs
643   __ push(rcx);               // mh
644   __ push(rcx);               // slot for adaptername
645   __ movptr(Address(rsp, 0), (intptr_t) adaptername);
646   __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, trace_method_handle_stub_wrapper), rsp);
647   __ increment(rsp, sizeof(MethodHandleStubArguments));
648 
649 #ifdef _LP64
650   __ movdbl(xmm0, Address(rsp, 0));
651 #else
652   if  (UseSSE &gt;= 2) {
653     __ movdbl(xmm0, Address(rsp, 0));
654   } else if (UseSSE == 1) {
655     __ movflt(xmm0, Address(rsp, 0));
656   } else {
657     __ fld_d(Address(rsp, 0));
658   }
659 #endif // LP64
660   __ increment(rsp, 2 * wordSize);
661 
662   __ popa();
663   __ leave();
664   BLOCK_COMMENT(&quot;} trace_method_handle&quot;);
665 }
666 #endif //PRODUCT
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/methodHandles_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/methodHandles_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
489       __ bind(L_incompatible_class_change_error);
490       __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));
491     }
492   }
493 }
494 
495 #ifndef PRODUCT
496 void trace_method_handle_stub(const char* adaptername,
497                               oop mh,
498                               intptr_t* saved_regs,
499                               intptr_t* entry_sp) {
500   // called as a leaf from native code: do not block the JVM!
501   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
502                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
503   const char* mh_reg_name = has_mh ? &quot;rcx_mh&quot; : &quot;rcx&quot;;
504   tty-&gt;print_cr(&quot;MH %s %s=&quot; PTR_FORMAT &quot; sp=&quot; PTR_FORMAT,
505                 adaptername, mh_reg_name,
506                 p2i(mh), p2i(entry_sp));
507 
508   if (Verbose) {

509     tty-&gt;print_cr(&quot;Registers:&quot;);
510     const int saved_regs_count = RegisterImpl::number_of_registers;
511     for (int i = 0; i &lt; saved_regs_count; i++) {
512       Register r = as_Register(i);
513       // The registers are stored in reverse order on the stack (by pusha).
514 #ifdef AMD64
515       assert(RegisterImpl::number_of_registers == 16, &quot;sanity&quot;);
516       if (r == rsp) {
517         // rsp is actually not stored by pusha(), compute the old rsp from saved_regs (rsp after pusha): saved_regs + 16 = old rsp
518         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), (intptr_t)(&amp;saved_regs[16]));
519       } else {
520         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
521       }
522 #else
523       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
524 #endif
525       if ((i + 1) % 4 == 0) {
526         tty-&gt;cr();
527       } else {
528         tty-&gt;print(&quot;, &quot;);
529       }
530     }
531     tty-&gt;cr();
532 
533     {
<span class="line-modified">534      // dumping last frame with frame::describe</span>
535 
536       JavaThread* p = JavaThread::active();
537 
<span class="line-modified">538       ResourceMark rm;</span>
<span class="line-removed">539       PRESERVE_EXCEPTION_MARK; // may not be needed by safer and unexpensive here</span>
540       FrameValues values;
541 
542       // Note: We want to allow trace_method_handle from any call site.
543       // While trace_method_handle creates a frame, it may be entered
544       // without a PC on the stack top (e.g. not just after a call).
545       // Walking that frame could lead to failures due to that invalid PC.
546       // =&gt; carefully detect that frame when doing the stack walking
547 
548       // Current C frame
549       frame cur_frame = os::current_frame();
550 
551       // Robust search of trace_calling_frame (independant of inlining).
552       // Assumes saved_regs comes from a pusha in the trace_calling_frame.
553       assert(cur_frame.sp() &lt; saved_regs, &quot;registers not saved on stack ?&quot;);
554       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
555       while (trace_calling_frame.fp() &lt; saved_regs) {
556         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
557       }
558 
559       // safely create a frame and call frame::describe
</pre>
<hr />
<pre>
568         // failing. Alternatively, frame constructors could be
569         // modified to support the current or future non walkable
570         // frames (but this is more intrusive and is not considered as
571         // part of this RFE, which will instead use a simpler output).
572         frame dump_frame = frame(dump_sp, dump_fp);
573         dump_frame.describe(values, 1);
574       } else {
575         // Stack may not be walkable (invalid PC above FP):
576         // Add descriptions without building a Java frame to avoid issues
577         values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
578         values.describe(-1, dump_sp, &quot;sp for #1&quot;);
579       }
580       values.describe(-1, entry_sp, &quot;raw top of stack&quot;);
581 
582       tty-&gt;print_cr(&quot;Stack layout:&quot;);
583       values.print(p);
584     }
585     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
586       mh-&gt;print();
587       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">588         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0)</span>
589           java_lang_invoke_MethodHandle::form(mh)-&gt;print();

590       }
591     }
592   }
593 }
594 
595 // The stub wraps the arguments in a struct on the stack to avoid
596 // dealing with the different calling conventions for passing 6
597 // arguments.
598 struct MethodHandleStubArguments {
599   const char* adaptername;
600   oopDesc* mh;
601   intptr_t* saved_regs;
602   intptr_t* entry_sp;
603 };
604 void trace_method_handle_stub_wrapper(MethodHandleStubArguments* args) {
605   trace_method_handle_stub(args-&gt;adaptername,
606                            args-&gt;mh,
607                            args-&gt;saved_regs,
608                            args-&gt;entry_sp);
609 }
</pre>
</td>
<td>
<hr />
<pre>
489       __ bind(L_incompatible_class_change_error);
490       __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));
491     }
492   }
493 }
494 
495 #ifndef PRODUCT
496 void trace_method_handle_stub(const char* adaptername,
497                               oop mh,
498                               intptr_t* saved_regs,
499                               intptr_t* entry_sp) {
500   // called as a leaf from native code: do not block the JVM!
501   bool has_mh = (strstr(adaptername, &quot;/static&quot;) == NULL &amp;&amp;
502                  strstr(adaptername, &quot;linkTo&quot;) == NULL);    // static linkers don&#39;t have MH
503   const char* mh_reg_name = has_mh ? &quot;rcx_mh&quot; : &quot;rcx&quot;;
504   tty-&gt;print_cr(&quot;MH %s %s=&quot; PTR_FORMAT &quot; sp=&quot; PTR_FORMAT,
505                 adaptername, mh_reg_name,
506                 p2i(mh), p2i(entry_sp));
507 
508   if (Verbose) {
<span class="line-added">509     ResourceMark rm;</span>
510     tty-&gt;print_cr(&quot;Registers:&quot;);
511     const int saved_regs_count = RegisterImpl::number_of_registers;
512     for (int i = 0; i &lt; saved_regs_count; i++) {
513       Register r = as_Register(i);
514       // The registers are stored in reverse order on the stack (by pusha).
515 #ifdef AMD64
516       assert(RegisterImpl::number_of_registers == 16, &quot;sanity&quot;);
517       if (r == rsp) {
518         // rsp is actually not stored by pusha(), compute the old rsp from saved_regs (rsp after pusha): saved_regs + 16 = old rsp
519         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), (intptr_t)(&amp;saved_regs[16]));
520       } else {
521         tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
522       }
523 #else
524       tty-&gt;print(&quot;%3s=&quot; PTR_FORMAT, r-&gt;name(), saved_regs[((saved_regs_count - 1) - i)]);
525 #endif
526       if ((i + 1) % 4 == 0) {
527         tty-&gt;cr();
528       } else {
529         tty-&gt;print(&quot;, &quot;);
530       }
531     }
532     tty-&gt;cr();
533 
534     {
<span class="line-modified">535       // dumping last frame with frame::describe</span>
536 
537       JavaThread* p = JavaThread::active();
538 
<span class="line-modified">539       PRESERVE_EXCEPTION_MARK; // may not be needed but safer and inexpensive here</span>

540       FrameValues values;
541 
542       // Note: We want to allow trace_method_handle from any call site.
543       // While trace_method_handle creates a frame, it may be entered
544       // without a PC on the stack top (e.g. not just after a call).
545       // Walking that frame could lead to failures due to that invalid PC.
546       // =&gt; carefully detect that frame when doing the stack walking
547 
548       // Current C frame
549       frame cur_frame = os::current_frame();
550 
551       // Robust search of trace_calling_frame (independant of inlining).
552       // Assumes saved_regs comes from a pusha in the trace_calling_frame.
553       assert(cur_frame.sp() &lt; saved_regs, &quot;registers not saved on stack ?&quot;);
554       frame trace_calling_frame = os::get_sender_for_C_frame(&amp;cur_frame);
555       while (trace_calling_frame.fp() &lt; saved_regs) {
556         trace_calling_frame = os::get_sender_for_C_frame(&amp;trace_calling_frame);
557       }
558 
559       // safely create a frame and call frame::describe
</pre>
<hr />
<pre>
568         // failing. Alternatively, frame constructors could be
569         // modified to support the current or future non walkable
570         // frames (but this is more intrusive and is not considered as
571         // part of this RFE, which will instead use a simpler output).
572         frame dump_frame = frame(dump_sp, dump_fp);
573         dump_frame.describe(values, 1);
574       } else {
575         // Stack may not be walkable (invalid PC above FP):
576         // Add descriptions without building a Java frame to avoid issues
577         values.describe(-1, dump_fp, &quot;fp for #1 &lt;not parsed, cannot trust pc&gt;&quot;);
578         values.describe(-1, dump_sp, &quot;sp for #1&quot;);
579       }
580       values.describe(-1, entry_sp, &quot;raw top of stack&quot;);
581 
582       tty-&gt;print_cr(&quot;Stack layout:&quot;);
583       values.print(p);
584     }
585     if (has_mh &amp;&amp; oopDesc::is_oop(mh)) {
586       mh-&gt;print();
587       if (java_lang_invoke_MethodHandle::is_instance(mh)) {
<span class="line-modified">588         if (java_lang_invoke_MethodHandle::form_offset_in_bytes() != 0) {</span>
589           java_lang_invoke_MethodHandle::form(mh)-&gt;print();
<span class="line-added">590         }</span>
591       }
592     }
593   }
594 }
595 
596 // The stub wraps the arguments in a struct on the stack to avoid
597 // dealing with the different calling conventions for passing 6
598 // arguments.
599 struct MethodHandleStubArguments {
600   const char* adaptername;
601   oopDesc* mh;
602   intptr_t* saved_regs;
603   intptr_t* entry_sp;
604 };
605 void trace_method_handle_stub_wrapper(MethodHandleStubArguments* args) {
606   trace_method_handle_stub(args-&gt;adaptername,
607                            args-&gt;mh,
608                            args-&gt;saved_regs,
609                            args-&gt;entry_sp);
610 }
</pre>
</td>
</tr>
</table>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
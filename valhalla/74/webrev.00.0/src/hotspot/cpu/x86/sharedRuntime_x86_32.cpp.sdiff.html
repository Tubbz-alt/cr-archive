<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1033       // Since C arguments do not get reversed, the ordering for
1034       // doubles on the stack must be opposite the Java convention
1035       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
1036       regs[i].set2(VMRegImpl::stack2reg(stack));
1037       stack += 2;
1038       break;
1039     case T_VOID: regs[i].set_bad(); break;
1040     default:
1041       ShouldNotReachHere();
1042       break;
1043     }
1044   }
1045   return stack;
1046 }
1047 
1048 // A simple move of integer like type
1049 static void simple_move32(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1050   if (src.first()-&gt;is_stack()) {
1051     if (dst.first()-&gt;is_stack()) {
1052       // stack to stack
<span class="line-modified">1053       // __ ld(FP, reg2offset(src.first()) + STACK_BIAS, L5);</span>
<span class="line-modified">1054       // __ st(L5, SP, reg2offset(dst.first()) + STACK_BIAS);</span>
1055       __ movl2ptr(rax, Address(rbp, reg2offset_in(src.first())));
1056       __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1057     } else {
1058       // stack to reg
1059       __ movl2ptr(dst.first()-&gt;as_Register(),  Address(rbp, reg2offset_in(src.first())));
1060     }
1061   } else if (dst.first()-&gt;is_stack()) {
1062     // reg to stack
1063     // no need to sign extend on 64bit
1064     __ movptr(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1065   } else {
1066     if (dst.first() != src.first()) {
1067       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1068     }
1069   }
1070 }
1071 
1072 // An oop arg. Must pass a handle not the oop itself
1073 static void object_move(MacroAssembler* masm,
1074                         OopMap* map,
</pre>
</td>
<td>
<hr />
<pre>
1033       // Since C arguments do not get reversed, the ordering for
1034       // doubles on the stack must be opposite the Java convention
1035       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
1036       regs[i].set2(VMRegImpl::stack2reg(stack));
1037       stack += 2;
1038       break;
1039     case T_VOID: regs[i].set_bad(); break;
1040     default:
1041       ShouldNotReachHere();
1042       break;
1043     }
1044   }
1045   return stack;
1046 }
1047 
1048 // A simple move of integer like type
1049 static void simple_move32(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1050   if (src.first()-&gt;is_stack()) {
1051     if (dst.first()-&gt;is_stack()) {
1052       // stack to stack
<span class="line-modified">1053       // __ ld(FP, reg2offset(src.first()), L5);</span>
<span class="line-modified">1054       // __ st(L5, SP, reg2offset(dst.first()));</span>
1055       __ movl2ptr(rax, Address(rbp, reg2offset_in(src.first())));
1056       __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1057     } else {
1058       // stack to reg
1059       __ movl2ptr(dst.first()-&gt;as_Register(),  Address(rbp, reg2offset_in(src.first())));
1060     }
1061   } else if (dst.first()-&gt;is_stack()) {
1062     // reg to stack
1063     // no need to sign extend on 64bit
1064     __ movptr(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1065   } else {
1066     if (dst.first() != src.first()) {
1067       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1068     }
1069   }
1070 }
1071 
1072 // An oop arg. Must pass a handle not the oop itself
1073 static void object_move(MacroAssembler* masm,
1074                         OopMap* map,
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
@@ -93,11 +93,10 @@
     final JavacMessages messages;
     final Names names;
     final boolean allowDefaultMethods;
     final boolean mapCapturesToBounds;
     final boolean allowValueBasedClasses;
-    final boolean nonCovariantValueArrays;
     final boolean injectTopInterfaceTypes;
     final Check chk;
     final Enter enter;
     JCDiagnostic.Factory diags;
     List<Warner> warnStack = List.nil();
@@ -126,11 +125,10 @@
         messages = JavacMessages.instance(context);
         diags = JCDiagnostic.Factory.instance(context);
         noWarnings = new Warner(null);
         Options options = Options.instance(context);
         allowValueBasedClasses = options.isSet("allowValueBasedClasses");
-        nonCovariantValueArrays = options.isSet("nonCovariantValueArrays");
         injectTopInterfaceTypes = Options.instance(context).isUnset("noTopInterfaceInjection") &&
                 Feature.INLINE_TYPES.allowedInSource(source) &&
                 Target.instance(context).hasTopInterfaces();
     }
     // </editor-fold>
@@ -610,10 +608,18 @@
     public boolean isConvertible(Type t, Type s, Warner warn) {
         if (t.hasTag(ERROR)) {
             return true;
         }
 
+        boolean tValue = t.isValue();
+        boolean sValue = s.isValue();
+        if (tValue != sValue) {
+            return tValue ?
+                    isSubtype(t.referenceProjection(), s) :
+                    (!t.hasTag(BOT) || isValueBased(s)) && isSubtype(t, s.referenceProjection());
+        }
+
         boolean tPrimitive = t.isPrimitive();
         boolean sPrimitive = s.isPrimitive();
         if (tPrimitive == sPrimitive) {
             return isSubtypeUnchecked(t, s, warn);
         }
@@ -1011,50 +1017,10 @@
 
     public boolean isValueBased(Type t) {
         return allowValueBasedClasses && t != null && t.tsym != null && (t.tsym.flags() & Flags.VALUEBASED) != 0;
     }
 
-    private final HashMap<ClassSymbol, ClassSymbol> nullableProjectionsMap = new HashMap<>();
-
-    public ClassSymbol projectedNullableType(ClassSymbol c) {
-        if (!c.isValue() || !c.type.hasTag(CLASS))
-            return null;
-        ClassSymbol lox = nullableProjectionsMap.get(c);
-        if (lox != null)
-            return lox;
-
-        ClassType ct = (ClassType) c.type;
-        ClassType loxType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
-        loxType.allparams_field = ct.allparams_field;
-        loxType.supertype_field = ct.supertype_field;
-        loxType.interfaces_field = List.nil();
-        for (Type t :ct.interfaces_field) {
-            if (t.tsym == syms.inlineObjectType.tsym) {
-                loxType.interfaces_field  = loxType.interfaces_field.append(syms.identityObjectType);
-            } else {
-                loxType.interfaces_field  = loxType.interfaces_field.append(t);
-            }
-        }
-        loxType.all_interfaces_field = ct.all_interfaces_field;
-        lox = new ClassSymbol((c.flags() & ~VALUE), c.name, loxType, c.owner) {
-            @Override
-            public boolean isProjectedNullable() {
-                return true;
-            }
-
-            @Override
-            public ClassSymbol nullFreeTypeSymbol() {
-                return c;
-            }
-        };
-        lox.members_field = c.members();
-        loxType.tsym = lox;
-
-        nullableProjectionsMap.put(c, lox);
-        return lox;
-    }
-
     // <editor-fold defaultstate="collapsed" desc="isSubtype">
     /**
      * Is t an unchecked subtype of s?
      */
     public boolean isSubtypeUnchecked(Type t, Type s) {
@@ -1074,19 +1040,20 @@
         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
             if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {
                 if (((ArrayType)t).elemtype.isPrimitive()) {
                     return isSameType(elemtype(t), elemtype(s));
                 } else {
-                    Type et = elemtype(t);
+                    // if T.ref <: S, then T[] <: S[]
                     Type es = elemtype(s);
+                    Type et = elemtype(t);
+                    if (isValue(et)) {
+                        et = et.referenceProjection();
+                        if (isValue(es))
+                            es = es.referenceProjection();  // V <: V, surely
+                    }
                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
                         return false;
-                    if (nonCovariantValueArrays) {
-                        if (isValue(et) || isValue(es)) {
-                            return isSameType(erasure(et), erasure(es));
-                        }
-                    }
                     return true;
                 }
             } else if (isSubtype(t, s, capture)) {
                 return true;
             } else if (t.hasTag(TYPEVAR)) {
@@ -1258,12 +1225,21 @@
             @Override
             public Boolean visitArrayType(ArrayType t, Type s) {
                 if (s.hasTag(ARRAY)) {
                     if (t.elemtype.isPrimitive())
                         return isSameType(t.elemtype, elemtype(s));
-                    else
-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));
+                    else {
+                        // if T.ref <: S, then T[] <: S[]
+                        Type es = elemtype(s);
+                        Type et = elemtype(t);
+                        if (isValue(et)) {
+                            et = et.referenceProjection();
+                            if (isValue(es))
+                                es = es.referenceProjection();  // V <: V, surely
+                        }
+                        return isSubtypeNoCapture(et, es);
+                    }
                 }
 
                 if (s.hasTag(CLASS)) {
                     Name sname = s.tsym.getQualifiedName();
                     return sname == names.java_lang_Object
@@ -1645,10 +1621,19 @@
             public Boolean visitWildcardType(WildcardType t, Type s) {
                 if (s.isPartial())
                     return containedBy(s, t);
                 else {
 //                    debugContainsType(t, s);
+
+                    // -----------------------------------  Unspecified behavior ----------------
+
+                    /* If a value class V implements an interface I, then does "? extends I" contain V?
+                       It seems widening must be applied here to answer yes to compile some common code
+                       patterns.
+                    */
+
+                    // ---------------------------------------------------------------------------
                     return isSameWildcard(t, s)
                         || isCaptureOf(s, t)
                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &&
                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
                 }
@@ -1769,10 +1754,18 @@
                             visitCompoundType((ClassType)s, t, true) :
                             visitCompoundType(t, s, false);
                 }
 
                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
+                    if (isValue(t)) {
+                        // (s) Value ? == (s) Value.ref
+                        t = t.referenceProjection();
+                    }
+                    if (isValue(s)) {
+                        // (Value) t ? == (Value.ref) t
+                        s = s.referenceProjection();
+                    }
                     boolean upcast;
                     if ((upcast = isSubtype(erasure(t), erasure(s)))
                         || isSubtype(erasure(s), erasure(t))) {
                         if (!upcast && s.hasTag(ARRAY)) {
                             if (!isReifiable(s))
@@ -1878,15 +1871,10 @@
                     } else {
                         Type et = elemtype(t);
                         Type es = elemtype(s);
                         if (!visit(et, es))
                             return false;
-                        if (nonCovariantValueArrays) {
-                            if (isValue(et) || isValue(es)) {
-                                return isSameType(erasure(et), erasure(es));
-                            }
-                        }
                         return true;
                     }
                 default:
                     return false;
                 }
@@ -2184,11 +2172,12 @@
          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) => c.s.s.t.Tree
          * (j.u.List<capture#160 of ? extends c.s.s.d.DocTree>, Iterable) =>
          *     Iterable<capture#160 of ? extends c.s.s.d.DocTree>
          */
         if (sym.type == syms.objectType) { //optimization
-            return syms.objectType;
+            if (!isValue(t))
+                return syms.objectType;
         }
         return asSuper.visit(t, sym);
     }
     // where
         private SimpleVisitor<Type,Symbol> asSuper = new SimpleVisitor<Type,Symbol>() {
@@ -2200,16 +2189,13 @@
             @Override
             public Type visitClassType(ClassType t, Symbol sym) {
                 if (t.tsym == sym)
                     return t;
 
-                /* For inline types, the wired in super type is j.l.O.
-                   So we need a special check for V <: V?
-                */
-                if (t.tsym == sym.nullFreeTypeSymbol()) {
-                    return new ClassType(t.getEnclosingType(), t.getTypeArguments(), (TypeSymbol)sym, t.getMetadata());
-                }
+                // No man may be an island, but the bell tolls for a value.
+                if (isValue(t))
+                    return null;
 
                 Type st = supertype(t);
                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
                     Type x = asSuper(st, sym);
                     if (x != null)
@@ -2310,13 +2296,25 @@
      *
      * @param t a type
      * @param sym a symbol
      */
     public Type memberType(Type t, Symbol sym) {
-        return (sym.flags() & STATIC) != 0
-            ? sym.type
-            : memberType.visit(t, sym);
+
+        if ((sym.flags() & STATIC) != 0)
+            return sym.type;
+
+        /* If any inline types are involved, switch over to the reference universe,
+           where the hierarchy is navigable. V and V.ref have identical membership
+           with no bridging needs.
+        */
+        if (t.isValue())
+            t = t.referenceProjection();
+
+        if (sym.owner.isValue())
+            sym = sym.referenceProjection();
+
+        return memberType.visit(t, sym);
         }
     // where
         private SimpleVisitor<Type,Symbol> memberType = new SimpleVisitor<Type,Symbol>() {
 
             public Type visitType(Type t, Symbol sym) {

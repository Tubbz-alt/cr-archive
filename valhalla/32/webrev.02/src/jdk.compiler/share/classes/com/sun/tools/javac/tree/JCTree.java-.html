<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;
  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
  74  *
  75  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  76  * classes should, by convention, start with JC (javac).
  77  *
  78  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  79  * If you write code that depends on this, you do so at your own risk.
  80  * This code and its internal interfaces are subject to change or
  81  * deletion without notice.&lt;/b&gt;
  82  *
  83  * @see TreeMaker
  84  * @see TreeInfo
  85  * @see TreeTranslator
  86  * @see Pretty
  87  */
  88 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  89 
  90     /* Tree tag values, identifying kinds of trees */
  91     public enum Tag {
  92         /** For methods that return an invalid tag if a given condition is not met
  93          */
  94         NO_TAG,
  95 
  96         /** Toplevel nodes, of type TopLevel, representing entire source files.
  97         */
  98         TOPLEVEL,
  99 
 100         /** Package level definitions.
 101          */
 102         PACKAGEDEF,
 103 
 104         /** Import clauses, of type Import.
 105          */
 106         IMPORT,
 107 
 108         /** Class definitions, of type ClassDef.
 109          */
 110         CLASSDEF,
 111 
 112         /** Method definitions, of type MethodDef.
 113          */
 114         METHODDEF,
 115 
 116         /** Variable definitions, of type VarDef.
 117          */
 118         VARDEF,
 119 
 120         /** The no-op statement &quot;;&quot;, of type Skip
 121          */
 122         SKIP,
 123 
 124         /** Blocks, of type Block.
 125          */
 126         BLOCK,
 127 
 128         /** Do-while loops, of type DoLoop.
 129          */
 130         DOLOOP,
 131 
 132         /** While-loops, of type WhileLoop.
 133          */
 134         WHILELOOP,
 135 
 136         /** Withfields, of type WithField.
 137          */
 138         WITHFIELD,
 139 
 140         /** For-loops, of type ForLoop.
 141          */
 142         FORLOOP,
 143 
 144         /** Foreach-loops, of type ForeachLoop.
 145          */
 146         FOREACHLOOP,
 147 
 148         /** Labelled statements, of type Labelled.
 149          */
 150         LABELLED,
 151 
 152         /** Switch statements, of type Switch.
 153          */
 154         SWITCH,
 155 
 156         /** Case parts in switch statements/expressions, of type Case.
 157          */
 158         CASE,
 159 
 160         /** Switch expression statements, of type Switch.
 161          */
 162         SWITCH_EXPRESSION,
 163 
 164         /** Synchronized statements, of type Synchronized.
 165          */
 166         SYNCHRONIZED,
 167 
 168         /** Try statements, of type Try.
 169          */
 170         TRY,
 171 
 172         /** Catch clauses in try statements, of type Catch.
 173          */
 174         CATCH,
 175 
 176         /** Conditional expressions, of type Conditional.
 177          */
 178         CONDEXPR,
 179 
 180         /** Conditional statements, of type If.
 181          */
 182         IF,
 183 
 184         /** Expression statements, of type Exec.
 185          */
 186         EXEC,
 187 
 188         /** Break statements, of type Break.
 189          */
 190         BREAK,
 191 
 192         /** Yield statements, of type Yield.
 193          */
 194         YIELD,
 195 
 196         /** Continue statements, of type Continue.
 197          */
 198         CONTINUE,
 199 
 200         /** Return statements, of type Return.
 201          */
 202         RETURN,
 203 
 204         /** Throw statements, of type Throw.
 205          */
 206         THROW,
 207 
 208         /** Assert statements, of type Assert.
 209          */
 210         ASSERT,
 211 
 212         /** Method invocation expressions, of type Apply.
 213          */
 214         APPLY,
 215 
 216         /** Class instance creation expressions, of type NewClass.
 217          */
 218         NEWCLASS,
 219 
 220         /** Array creation expressions, of type NewArray.
 221          */
 222         NEWARRAY,
 223 
 224         /** Lambda expression, of type Lambda.
 225          */
 226         LAMBDA,
 227 
 228         /** Parenthesized subexpressions, of type Parens.
 229          */
 230         PARENS,
 231 
 232         /** Assignment expressions, of type Assign.
 233          */
 234         ASSIGN,
 235 
 236         /** Type cast expressions, of type TypeCast.
 237          */
 238         TYPECAST,
 239 
 240         /** Type test expressions, of type TypeTest.
 241          */
 242         TYPETEST,
 243 
 244         /** Patterns.
 245          */
 246         BINDINGPATTERN,
 247 
 248         /** Indexed array expressions, of type Indexed.
 249          */
 250         INDEXED,
 251 
 252         /** Selections, of type Select.
 253          */
 254         SELECT,
 255 
 256         /** Member references, of type Reference.
 257          */
 258         REFERENCE,
 259 
 260         /** Simple identifiers, of type Ident.
 261          */
 262         IDENT,
 263 
 264         /** Literals, of type Literal.
 265          */
 266         LITERAL,
 267 
 268         /** Basic type identifiers, of type TypeIdent.
 269          */
 270         TYPEIDENT,
 271 
 272         /** Array types, of type TypeArray.
 273          */
 274         TYPEARRAY,
 275 
 276         /** Parameterized types, of type TypeApply.
 277          */
 278         TYPEAPPLY,
 279 
 280         /** Union types, of type TypeUnion.
 281          */
 282         TYPEUNION,
 283 
 284         /** Intersection types, of type TypeIntersection.
 285          */
 286         TYPEINTERSECTION,
 287 
 288         /** Formal type parameters, of type TypeParameter.
 289          */
 290         TYPEPARAMETER,
 291 
 292         /** Type argument.
 293          */
 294         WILDCARD,
 295 
 296         /** Bound kind: extends, super, exact, or unbound
 297          */
 298         TYPEBOUNDKIND,
 299 
 300         /** metadata: Annotation.
 301          */
 302         ANNOTATION,
 303 
 304         /** metadata: Type annotation.
 305          */
 306         TYPE_ANNOTATION,
 307 
 308         /** metadata: Modifiers
 309          */
 310         MODIFIERS,
 311 
 312         /** An annotated type tree.
 313          */
 314         ANNOTATED_TYPE,
 315 
 316         /** Error trees, of type Erroneous.
 317          */
 318         ERRONEOUS,
 319 
 320         /** Unary operators, of type Unary.
 321          */
 322         POS,                             // +
 323         NEG,                             // -
 324         NOT,                             // !
 325         COMPL,                           // ~
 326         PREINC,                          // ++ _
 327         PREDEC,                          // -- _
 328         POSTINC,                         // _ ++
 329         POSTDEC,                         // _ --
 330 
 331         /** unary operator for null reference checks, only used internally.
 332          */
 333         NULLCHK,
 334 
 335         /** Binary operators, of type Binary.
 336          */
 337         OR,                              // ||
 338         AND,                             // &amp;&amp;
 339         BITOR,                           // |
 340         BITXOR,                          // ^
 341         BITAND,                          // &amp;
 342         EQ,                              // ==
 343         NE,                              // !=
 344         LT,                              // &lt;
 345         GT,                              // &gt;
 346         LE,                              // &lt;=
 347         GE,                              // &gt;=
 348         SL,                              // &lt;&lt;
 349         SR,                              // &gt;&gt;
 350         USR,                             // &gt;&gt;&gt;
 351         PLUS,                            // +
 352         MINUS,                           // -
 353         MUL,                             // *
 354         DIV,                             // /
 355         MOD,                             // %
 356 
 357         /** Assignment operators, of type Assignop.
 358          */
 359         BITOR_ASG(BITOR),                // |=
 360         BITXOR_ASG(BITXOR),              // ^=
 361         BITAND_ASG(BITAND),              // &amp;=
 362 
 363         SL_ASG(SL),                      // &lt;&lt;=
 364         SR_ASG(SR),                      // &gt;&gt;=
 365         USR_ASG(USR),                    // &gt;&gt;&gt;=
 366         PLUS_ASG(PLUS),                  // +=
 367         MINUS_ASG(MINUS),                // -=
 368         MUL_ASG(MUL),                    // *=
 369         DIV_ASG(DIV),                    // /=
 370         MOD_ASG(MOD),                    // %=
 371 
 372         MODULEDEF,
 373         EXPORTS,
 374         OPENS,
 375         PROVIDES,
 376         REQUIRES,
 377         USES,
 378 
 379         /** A synthetic let expression, of type LetExpr.
 380          */
 381         LETEXPR;                         // ala scheme
 382 
 383         private final Tag noAssignTag;
 384 
 385         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 386 
 387         private Tag(Tag noAssignTag) {
 388             this.noAssignTag = noAssignTag;
 389         }
 390 
 391         private Tag() {
 392             this(null);
 393         }
 394 
 395         public static int getNumberOfOperators() {
 396             return numberOfOperators;
 397         }
 398 
 399         public Tag noAssignOp() {
 400             if (noAssignTag != null)
 401                 return noAssignTag;
 402             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 403         }
 404 
 405         public boolean isPostUnaryOp() {
 406             return (this == POSTINC || this == POSTDEC);
 407         }
 408 
 409         public boolean isIncOrDecUnaryOp() {
 410             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 411         }
 412 
 413         public boolean isAssignop() {
 414             return noAssignTag != null;
 415         }
 416 
 417         public int operatorIndex() {
 418             return (this.ordinal() - POS.ordinal());
 419         }
 420     }
 421 
 422     /* The (encoded) position in the source file. @see util.Position.
 423      */
 424     public int pos;
 425 
 426     /* The type of this node.
 427      */
 428     public Type type;
 429 
 430     /* The tag of this node -- one of the constants declared above.
 431      */
 432     public abstract Tag getTag();
 433 
 434     /* Returns true if the tag of this node is equals to tag.
 435      */
 436     public boolean hasTag(Tag tag) {
 437         return tag == getTag();
 438     }
 439 
 440     /** Convert a tree to a pretty-printed string. */
 441     @Override
 442     public String toString() {
 443         StringWriter s = new StringWriter();
 444         try {
 445             new Pretty(s, false).printExpr(this);
 446         }
 447         catch (IOException e) {
 448             // should never happen, because StringWriter is defined
 449             // never to throw any IOExceptions
 450             throw new AssertionError(e);
 451         }
 452         return s.toString();
 453     }
 454 
 455     /** Set position field and return this tree.
 456      */
 457     public JCTree setPos(int pos) {
 458         this.pos = pos;
 459         return this;
 460     }
 461 
 462     /** Set type field and return this tree.
 463      */
 464     public JCTree setType(Type type) {
 465         this.type = type;
 466         return this;
 467     }
 468 
 469     /** Visit this tree with a given visitor.
 470      */
 471     public abstract void accept(Visitor v);
 472 
 473     @DefinedBy(Api.COMPILER_TREE)
 474     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 475 
 476     /** Return a shallow copy of this tree.
 477      */
 478     @Override
 479     public Object clone() {
 480         try {
 481             return super.clone();
 482         } catch(CloneNotSupportedException e) {
 483             throw new RuntimeException(e);
 484         }
 485     }
 486 
 487     /** Get a default position for this tree node.
 488      */
 489     public DiagnosticPosition pos() {
 490         return this;
 491     }
 492 
 493     // for default DiagnosticPosition
 494     public JCTree getTree() {
 495         return this;
 496     }
 497 
 498     // for default DiagnosticPosition
 499     public int getStartPosition() {
 500         return TreeInfo.getStartPos(this);
 501     }
 502 
 503     // for default DiagnosticPosition
 504     public int getPreferredPosition() {
 505         return pos;
 506     }
 507 
 508     // for default DiagnosticPosition
 509     public int getEndPosition(EndPosTable endPosTable) {
 510         return TreeInfo.getEndPos(this, endPosTable);
 511     }
 512 
 513     /**
 514      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 515      */
 516     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 517         /** All definitions in this file (ClassDef, Import, and Skip) */
 518         public List&lt;JCTree&gt; defs;
 519         /** The source file name. */
 520         public JavaFileObject sourcefile;
 521         /** The module to which this compilation unit belongs. */
 522         public ModuleSymbol modle;
 523         /** The location in which this compilation unit was found. */
 524         public Location locn;
 525         /** The package to which this compilation unit belongs. */
 526         public PackageSymbol packge;
 527         /** A scope containing top level classes. */
 528         public WriteableScope toplevelScope;
 529         /** A scope for all named imports. */
 530         public NamedImportScope namedImportScope;
 531         /** A scope for all import-on-demands. */
 532         public StarImportScope starImportScope;
 533         /** Line starting positions, defined only if option -g is set. */
 534         public Position.LineMap lineMap = null;
 535         /** A table that stores all documentation comments indexed by the tree
 536          * nodes they refer to. defined only if option -s is set. */
 537         public DocCommentTable docComments = null;
 538         /* An object encapsulating ending positions of source ranges indexed by
 539          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 540         public EndPosTable endPositions = null;
 541         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 542             this.defs = defs;
 543         }
 544         @Override
 545         public void accept(Visitor v) { v.visitTopLevel(this); }
 546 
 547         @DefinedBy(Api.COMPILER_TREE)
 548         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 549 
 550         public JCModuleDecl getModuleDecl() {
 551             for (JCTree tree : defs) {
 552                 if (tree.hasTag(MODULEDEF)) {
 553                     return (JCModuleDecl) tree;
 554                 }
 555             }
 556 
 557             return null;
 558         }
 559 
 560         @DefinedBy(Api.COMPILER_TREE)
 561         public JCPackageDecl getPackage() {
 562             // PackageDecl must be the first entry if it exists
 563             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 564                 return (JCPackageDecl)defs.head;
 565             return null;
 566         }
 567         @DefinedBy(Api.COMPILER_TREE)
 568         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 569             JCPackageDecl pd = getPackage();
 570             return pd != null ? pd.getAnnotations() : List.nil();
 571         }
 572         @DefinedBy(Api.COMPILER_TREE)
 573         public ExpressionTree getPackageName() {
 574             JCPackageDecl pd = getPackage();
 575             return pd != null ? pd.getPackageName() : null;
 576         }
 577 
 578         @DefinedBy(Api.COMPILER_TREE)
 579         public List&lt;JCImport&gt; getImports() {
 580             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 581             for (JCTree tree : defs) {
 582                 if (tree.hasTag(IMPORT))
 583                     imports.append((JCImport)tree);
 584                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 585                     break;
 586             }
 587             return imports.toList();
 588         }
 589         @DefinedBy(Api.COMPILER_TREE)
 590         public JavaFileObject getSourceFile() {
 591             return sourcefile;
 592         }
 593         @DefinedBy(Api.COMPILER_TREE)
 594         public Position.LineMap getLineMap() {
 595             return lineMap;
 596         }
 597         @DefinedBy(Api.COMPILER_TREE)
 598         public List&lt;JCTree&gt; getTypeDecls() {
 599             List&lt;JCTree&gt; typeDefs;
 600             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 601                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 602                     break;
 603             return typeDefs;
 604         }
 605         @Override @DefinedBy(Api.COMPILER_TREE)
 606         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 607             return v.visitCompilationUnit(this, d);
 608         }
 609 
 610         @Override
 611         public Tag getTag() {
 612             return TOPLEVEL;
 613         }
 614     }
 615 
 616     /**
 617      * Package definition.
 618      */
 619     public static class JCPackageDecl extends JCTree implements PackageTree {
 620         public List&lt;JCAnnotation&gt; annotations;
 621         /** The tree representing the package clause. */
 622         public JCExpression pid;
 623         public PackageSymbol packge;
 624         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 625             this.annotations = annotations;
 626             this.pid = pid;
 627         }
 628         @Override
 629         public void accept(Visitor v) { v.visitPackageDef(this); }
 630         @DefinedBy(Api.COMPILER_TREE)
 631         public Kind getKind() {
 632             return Kind.PACKAGE;
 633         }
 634         @DefinedBy(Api.COMPILER_TREE)
 635         public List&lt;JCAnnotation&gt; getAnnotations() {
 636             return annotations;
 637         }
 638         @DefinedBy(Api.COMPILER_TREE)
 639         public JCExpression getPackageName() {
 640             return pid;
 641         }
 642         @Override @DefinedBy(Api.COMPILER_TREE)
 643         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 644             return v.visitPackage(this, d);
 645         }
 646         @Override
 647         public Tag getTag() {
 648             return PACKAGEDEF;
 649         }
 650     }
 651 
 652     /**
 653      * An import clause.
 654      */
 655     public static class JCImport extends JCTree implements ImportTree {
 656         public boolean staticImport;
 657         /** The imported class(es). */
 658         public JCTree qualid;
 659         public com.sun.tools.javac.code.Scope importScope;
 660         protected JCImport(JCTree qualid, boolean importStatic) {
 661             this.qualid = qualid;
 662             this.staticImport = importStatic;
 663         }
 664         @Override
 665         public void accept(Visitor v) { v.visitImport(this); }
 666 
 667         @DefinedBy(Api.COMPILER_TREE)
 668         public boolean isStatic() { return staticImport; }
 669         @DefinedBy(Api.COMPILER_TREE)
 670         public JCTree getQualifiedIdentifier() { return qualid; }
 671 
 672         @DefinedBy(Api.COMPILER_TREE)
 673         public Kind getKind() { return Kind.IMPORT; }
 674         @Override @DefinedBy(Api.COMPILER_TREE)
 675         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 676             return v.visitImport(this, d);
 677         }
 678 
 679         @Override
 680         public Tag getTag() {
 681             return IMPORT;
 682         }
 683     }
 684 
 685     public static abstract class JCStatement extends JCTree implements StatementTree {
 686         @Override
 687         public JCStatement setType(Type type) {
 688             super.setType(type);
 689             return this;
 690         }
 691         @Override
 692         public JCStatement setPos(int pos) {
 693             super.setPos(pos);
 694             return this;
 695         }
 696     }
 697 
 698     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 699         boolean questioned = false;
 700         @Override
 701         public JCExpression setType(Type type) {
 702             super.setType(type);
 703             return this;
 704         }
 705         @Override
 706         public JCExpression setPos(int pos) {
 707             super.setPos(pos);
 708             return this;
 709         }
 710 
 711         public void setQuestioned() {
 712             this.questioned = true;
 713         }
 714         public boolean isQuestioned() {
 715             return this.questioned;
 716         }
 717 
 718         public boolean isPoly() { return false; }
 719         public boolean isStandalone() { return true; }
 720     }
 721 
 722     /**
 723      * Common supertype for all poly expression trees (lambda, method references,
 724      * conditionals, method and constructor calls)
 725      */
 726     public static abstract class JCPolyExpression extends JCExpression {
 727 
 728         /**
 729          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 730          */
 731         public enum PolyKind {
 732             /** poly expression to be treated as a standalone expression */
 733             STANDALONE,
 734             /** true poly expression */
 735             POLY
 736         }
 737 
 738         /** is this poly expression a &#39;true&#39; poly expression? */
 739         public PolyKind polyKind;
 740 
 741         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 742         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 743     }
 744 
 745     /**
 746      * Common supertype for all functional expression trees (lambda and method references)
 747      */
 748     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 749 
 750         public JCFunctionalExpression() {
 751             //a functional expression is always a &#39;true&#39; poly
 752             polyKind = PolyKind.POLY;
 753         }
 754 
 755         /** list of target types inferred for this functional expression. */
 756         public Type target;
 757 
 758         public Type getDescriptorType(Types types) {
 759             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 760         }
 761     }
 762 
 763     /**
 764      * A class definition.
 765      */
 766     public static class JCClassDecl extends JCStatement implements ClassTree {
 767         /** the modifiers */
 768         public JCModifiers mods;
 769         /** the name of the class */
 770         public Name name;
 771         /** formal class parameters */
 772         public List&lt;JCTypeParameter&gt; typarams;
 773         /** the classes this class extends */
 774         public JCExpression extending;
 775         /** the interfaces implemented by this class */
 776         public List&lt;JCExpression&gt; implementing;
 777         /** all variables and methods defined in this class */
 778         public List&lt;JCTree&gt; defs;
 779         /** the symbol */
 780         public ClassSymbol sym;
 781         protected JCClassDecl(JCModifiers mods,
 782                            Name name,
 783                            List&lt;JCTypeParameter&gt; typarams,
 784                            JCExpression extending,
 785                            List&lt;JCExpression&gt; implementing,
 786                            List&lt;JCTree&gt; defs,
 787                            ClassSymbol sym)
 788         {
 789             this.mods = mods;
 790             this.name = name;
 791             this.typarams = typarams;
 792             this.extending = extending;
 793             this.implementing = implementing;
 794             this.defs = defs;
 795             this.sym = sym;
 796         }
 797         @Override
 798         public void accept(Visitor v) { v.visitClassDef(this); }
 799 
 800         @SuppressWarnings(&quot;preview&quot;)
 801         @DefinedBy(Api.COMPILER_TREE)
 802         public Kind getKind() {
 803             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 804                 return Kind.ANNOTATION_TYPE;
 805             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 806                 return Kind.INTERFACE;
 807             else if ((mods.flags &amp; Flags.ENUM) != 0)
 808                 return Kind.ENUM;
 809             else if ((mods.flags &amp; Flags.RECORD) != 0)
 810                 return Kind.RECORD;
 811             else
 812                 return Kind.CLASS;
 813         }
 814 
 815         @DefinedBy(Api.COMPILER_TREE)
 816         public JCModifiers getModifiers() { return mods; }
 817         @DefinedBy(Api.COMPILER_TREE)
 818         public Name getSimpleName() { return name; }
 819         @DefinedBy(Api.COMPILER_TREE)
 820         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 821             return typarams;
 822         }
 823         @DefinedBy(Api.COMPILER_TREE)
 824         public JCExpression getExtendsClause() { return extending; }
 825         @DefinedBy(Api.COMPILER_TREE)
 826         public List&lt;JCExpression&gt; getImplementsClause() {
 827             return implementing;
 828         }
 829         @DefinedBy(Api.COMPILER_TREE)
 830         public List&lt;JCTree&gt; getMembers() {
 831             return defs;
 832         }
 833         @Override @DefinedBy(Api.COMPILER_TREE)
 834         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 835             return v.visitClass(this, d);
 836         }
 837 
 838         @Override
 839         public Tag getTag() {
 840             return CLASSDEF;
 841         }
 842     }
 843 
 844     /**
 845      * A method definition.
 846      */
 847     public static class JCMethodDecl extends JCTree implements MethodTree {
 848         /** method modifiers */
 849         public JCModifiers mods;
 850         /** method name */
 851         public Name name;
 852         /** type of method return value */
 853         public JCExpression restype;
 854         /** type parameters */
 855         public List&lt;JCTypeParameter&gt; typarams;
 856         /** receiver parameter */
 857         public JCVariableDecl recvparam;
 858         /** value parameters */
 859         public List&lt;JCVariableDecl&gt; params;
 860         /** exceptions thrown by this method */
 861         public List&lt;JCExpression&gt; thrown;
 862         /** statements in the method */
 863         public JCBlock body;
 864         /** default value, for annotation types */
 865         public JCExpression defaultValue;
 866         /** method symbol */
 867         public MethodSymbol sym;
 868         /** nascent value that evolves into the return value for a value factory */
 869         public VarSymbol factoryProduct;
 870 
 871         /** does this method completes normally */
 872         public boolean completesNormally;
 873 
 874         protected JCMethodDecl(JCModifiers mods,
 875                             Name name,
 876                             JCExpression restype,
 877                             List&lt;JCTypeParameter&gt; typarams,
 878                             JCVariableDecl recvparam,
 879                             List&lt;JCVariableDecl&gt; params,
 880                             List&lt;JCExpression&gt; thrown,
 881                             JCBlock body,
 882                             JCExpression defaultValue,
 883                             MethodSymbol sym)
 884         {
 885             this.mods = mods;
 886             this.name = name;
 887             this.restype = restype;
 888             this.typarams = typarams;
 889             this.params = params;
 890             this.recvparam = recvparam;
 891             // TODO: do something special if the given type is null?
 892             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 893             this.thrown = thrown;
 894             this.body = body;
 895             this.defaultValue = defaultValue;
 896             this.sym = sym;
 897         }
 898         @Override
 899         public void accept(Visitor v) { v.visitMethodDef(this); }
 900 
 901         @DefinedBy(Api.COMPILER_TREE)
 902         public Kind getKind() { return Kind.METHOD; }
 903         @DefinedBy(Api.COMPILER_TREE)
 904         public JCModifiers getModifiers() { return mods; }
 905         @DefinedBy(Api.COMPILER_TREE)
 906         public Name getName() { return name; }
 907         @DefinedBy(Api.COMPILER_TREE)
 908         public JCTree getReturnType() { return restype; }
 909         @DefinedBy(Api.COMPILER_TREE)
 910         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 911             return typarams;
 912         }
 913         @DefinedBy(Api.COMPILER_TREE)
 914         public List&lt;JCVariableDecl&gt; getParameters() {
 915             return params;
 916         }
 917         @DefinedBy(Api.COMPILER_TREE)
 918         public JCVariableDecl getReceiverParameter() { return recvparam; }
 919         @DefinedBy(Api.COMPILER_TREE)
 920         public List&lt;JCExpression&gt; getThrows() {
 921             return thrown;
 922         }
 923         @DefinedBy(Api.COMPILER_TREE)
 924         public JCBlock getBody() { return body; }
 925         @DefinedBy(Api.COMPILER_TREE)
 926         public JCTree getDefaultValue() { // for annotation types
 927             return defaultValue;
 928         }
 929         @Override @DefinedBy(Api.COMPILER_TREE)
 930         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 931             return v.visitMethod(this, d);
 932         }
 933 
 934         @Override
 935         public Tag getTag() {
 936             return METHODDEF;
 937         }
 938   }
 939 
 940     /**
 941      * A variable definition.
 942      */
 943     public static class JCVariableDecl extends JCStatement implements VariableTree {
 944         /** variable modifiers */
 945         public JCModifiers mods;
 946         /** variable name */
 947         public Name name;
 948         /** variable name expression */
 949         public JCExpression nameexpr;
 950         /** type of the variable */
 951         public JCExpression vartype;
 952         /** variable&#39;s initial value */
 953         public JCExpression init;
 954         /** symbol */
 955         public VarSymbol sym;
 956         /** explicit start pos */
 957         public int startPos = Position.NOPOS;
 958 
 959         protected JCVariableDecl(JCModifiers mods,
 960                          Name name,
 961                          JCExpression vartype,
 962                          JCExpression init,
 963                          VarSymbol sym) {
 964             this.mods = mods;
 965             this.name = name;
 966             this.vartype = vartype;
 967             this.init = init;
 968             this.sym = sym;
 969         }
 970 
 971         protected JCVariableDecl(JCModifiers mods,
 972                          JCExpression nameexpr,
 973                          JCExpression vartype) {
 974             this(mods, null, vartype, null, null);
 975             this.nameexpr = nameexpr;
 976             if (nameexpr.hasTag(Tag.IDENT)) {
 977                 this.name = ((JCIdent)nameexpr).name;
 978             } else {
 979                 // Only other option is qualified name x.y.this;
 980                 this.name = ((JCFieldAccess)nameexpr).name;
 981             }
 982         }
 983 
 984         public boolean isImplicitlyTyped() {
 985             return vartype == null;
 986         }
 987 
 988         @Override
 989         public void accept(Visitor v) { v.visitVarDef(this); }
 990 
 991         @DefinedBy(Api.COMPILER_TREE)
 992         public Kind getKind() { return Kind.VARIABLE; }
 993         @DefinedBy(Api.COMPILER_TREE)
 994         public JCModifiers getModifiers() { return mods; }
 995         @DefinedBy(Api.COMPILER_TREE)
 996         public Name getName() { return name; }
 997         @DefinedBy(Api.COMPILER_TREE)
 998         public JCExpression getNameExpression() { return nameexpr; }
 999         @DefinedBy(Api.COMPILER_TREE)
1000         public JCTree getType() { return vartype; }
1001         @DefinedBy(Api.COMPILER_TREE)
1002         public JCExpression getInitializer() {
1003             return init;
1004         }
1005         @Override @DefinedBy(Api.COMPILER_TREE)
1006         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1007             return v.visitVariable(this, d);
1008         }
1009 
1010         @Override
1011         public Tag getTag() {
1012             return VARDEF;
1013         }
1014     }
1015 
1016     /**
1017      * A no-op statement &quot;;&quot;.
1018      */
1019     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1020         protected JCSkip() {
1021         }
1022         @Override
1023         public void accept(Visitor v) { v.visitSkip(this); }
1024 
1025         @DefinedBy(Api.COMPILER_TREE)
1026         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1027         @Override @DefinedBy(Api.COMPILER_TREE)
1028         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1029             return v.visitEmptyStatement(this, d);
1030         }
1031 
1032         @Override
1033         public Tag getTag() {
1034             return SKIP;
1035         }
1036     }
1037 
1038     /**
1039      * A statement block.
1040      */
1041     public static class JCBlock extends JCStatement implements BlockTree {
1042         /** flags */
1043         public long flags;
1044         /** statements */
1045         public List&lt;JCStatement&gt; stats;
1046         /** Position of closing brace, optional. */
1047         public int endpos = Position.NOPOS;
1048         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1049             this.stats = stats;
1050             this.flags = flags;
1051         }
1052         @Override
1053         public void accept(Visitor v) { v.visitBlock(this); }
1054 
1055         @DefinedBy(Api.COMPILER_TREE)
1056         public Kind getKind() { return Kind.BLOCK; }
1057         @DefinedBy(Api.COMPILER_TREE)
1058         public List&lt;JCStatement&gt; getStatements() {
1059             return stats;
1060         }
1061         @DefinedBy(Api.COMPILER_TREE)
1062         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1063         @Override @DefinedBy(Api.COMPILER_TREE)
1064         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1065             return v.visitBlock(this, d);
1066         }
1067 
1068         @Override
1069         public Tag getTag() {
1070             return BLOCK;
1071         }
1072     }
1073 
1074     /**
1075      * A do loop
1076      */
1077     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1078         public JCStatement body;
1079         public JCExpression cond;
1080         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1081             this.body = body;
1082             this.cond = cond;
1083         }
1084         @Override
1085         public void accept(Visitor v) { v.visitDoLoop(this); }
1086 
1087         @DefinedBy(Api.COMPILER_TREE)
1088         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1089         @DefinedBy(Api.COMPILER_TREE)
1090         public JCExpression getCondition() { return cond; }
1091         @DefinedBy(Api.COMPILER_TREE)
1092         public JCStatement getStatement() { return body; }
1093         @Override @DefinedBy(Api.COMPILER_TREE)
1094         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1095             return v.visitDoWhileLoop(this, d);
1096         }
1097 
1098         @Override
1099         public Tag getTag() {
1100             return DOLOOP;
1101         }
1102     }
1103 
1104     /**
1105      * A while loop
1106      */
1107     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1108         public JCExpression cond;
1109         public JCStatement body;
1110         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1111             this.cond = cond;
1112             this.body = body;
1113         }
1114         @Override
1115         public void accept(Visitor v) { v.visitWhileLoop(this); }
1116 
1117         @DefinedBy(Api.COMPILER_TREE)
1118         public Kind getKind() { return Kind.WHILE_LOOP; }
1119         @DefinedBy(Api.COMPILER_TREE)
1120         public JCExpression getCondition() { return cond; }
1121         @DefinedBy(Api.COMPILER_TREE)
1122         public JCStatement getStatement() { return body; }
1123         @Override @DefinedBy(Api.COMPILER_TREE)
1124         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1125             return v.visitWhileLoop(this, d);
1126         }
1127 
1128         @Override
1129         public Tag getTag() {
1130             return WHILELOOP;
1131         }
1132     }
1133 
1134     /**
1135      * A withfield expression
1136      */
1137     public static class JCWithField extends JCExpression implements WithFieldTree {
1138         public JCExpression field;
1139         public JCExpression value;
1140         protected JCWithField(JCExpression field, JCExpression value) {
1141             this.field = field;
1142             this.value = value;
1143         }
1144         @Override
1145         public void accept(Visitor v) { v.visitWithField(this); }
1146 
1147         @DefinedBy(Api.COMPILER_TREE)
1148         public Kind getKind() { return Kind.WITH_FIELD; }
1149         @DefinedBy(Api.COMPILER_TREE)
1150         public JCExpression getField() { return field; }
1151         @DefinedBy(Api.COMPILER_TREE)
1152         public JCExpression getValue() { return value; }
1153         @Override @DefinedBy(Api.COMPILER_TREE)
1154         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1155             return v.visitWithField(this, d);
1156         }
1157 
1158         @Override
1159         public Tag getTag() {
1160             return WITHFIELD;
1161         }
1162     }
1163 
1164     /**
1165      * A for loop.
1166      */
1167     public static class JCForLoop extends JCStatement implements ForLoopTree {
1168         public List&lt;JCStatement&gt; init;
1169         public JCExpression cond;
1170         public List&lt;JCExpressionStatement&gt; step;
1171         public JCStatement body;
1172         protected JCForLoop(List&lt;JCStatement&gt; init,
1173                           JCExpression cond,
1174                           List&lt;JCExpressionStatement&gt; update,
1175                           JCStatement body)
1176         {
1177             this.init = init;
1178             this.cond = cond;
1179             this.step = update;
1180             this.body = body;
1181         }
1182         @Override
1183         public void accept(Visitor v) { v.visitForLoop(this); }
1184 
1185         @DefinedBy(Api.COMPILER_TREE)
1186         public Kind getKind() { return Kind.FOR_LOOP; }
1187         @DefinedBy(Api.COMPILER_TREE)
1188         public JCExpression getCondition() { return cond; }
1189         @DefinedBy(Api.COMPILER_TREE)
1190         public JCStatement getStatement() { return body; }
1191         @DefinedBy(Api.COMPILER_TREE)
1192         public List&lt;JCStatement&gt; getInitializer() {
1193             return init;
1194         }
1195         @DefinedBy(Api.COMPILER_TREE)
1196         public List&lt;JCExpressionStatement&gt; getUpdate() {
1197             return step;
1198         }
1199         @Override @DefinedBy(Api.COMPILER_TREE)
1200         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1201             return v.visitForLoop(this, d);
1202         }
1203 
1204         @Override
1205         public Tag getTag() {
1206             return FORLOOP;
1207         }
1208     }
1209 
1210     /**
1211      * The enhanced for loop.
1212      */
1213     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1214         public JCVariableDecl var;
1215         public JCExpression expr;
1216         public JCStatement body;
1217         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1218             this.var = var;
1219             this.expr = expr;
1220             this.body = body;
1221         }
1222         @Override
1223         public void accept(Visitor v) { v.visitForeachLoop(this); }
1224 
1225         @DefinedBy(Api.COMPILER_TREE)
1226         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1227         @DefinedBy(Api.COMPILER_TREE)
1228         public JCVariableDecl getVariable() { return var; }
1229         @DefinedBy(Api.COMPILER_TREE)
1230         public JCExpression getExpression() { return expr; }
1231         @DefinedBy(Api.COMPILER_TREE)
1232         public JCStatement getStatement() { return body; }
1233         @Override @DefinedBy(Api.COMPILER_TREE)
1234         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1235             return v.visitEnhancedForLoop(this, d);
1236         }
1237         @Override
1238         public Tag getTag() {
1239             return FOREACHLOOP;
1240         }
1241     }
1242 
1243     /**
1244      * A labelled expression or statement.
1245      */
1246     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1247         public Name label;
1248         public JCStatement body;
1249         protected JCLabeledStatement(Name label, JCStatement body) {
1250             this.label = label;
1251             this.body = body;
1252         }
1253         @Override
1254         public void accept(Visitor v) { v.visitLabelled(this); }
1255         @DefinedBy(Api.COMPILER_TREE)
1256         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1257         @DefinedBy(Api.COMPILER_TREE)
1258         public Name getLabel() { return label; }
1259         @DefinedBy(Api.COMPILER_TREE)
1260         public JCStatement getStatement() { return body; }
1261         @Override @DefinedBy(Api.COMPILER_TREE)
1262         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1263             return v.visitLabeledStatement(this, d);
1264         }
1265         @Override
1266         public Tag getTag() {
1267             return LABELLED;
1268         }
1269     }
1270 
1271     /**
1272      * A &quot;switch ( ) { }&quot; construction.
1273      */
1274     public static class JCSwitch extends JCStatement implements SwitchTree {
1275         public JCExpression selector;
1276         public List&lt;JCCase&gt; cases;
1277         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1278             this.selector = selector;
1279             this.cases = cases;
1280         }
1281         @Override
1282         public void accept(Visitor v) { v.visitSwitch(this); }
1283 
1284         @DefinedBy(Api.COMPILER_TREE)
1285         public Kind getKind() { return Kind.SWITCH; }
1286         @DefinedBy(Api.COMPILER_TREE)
1287         public JCExpression getExpression() { return selector; }
1288         @DefinedBy(Api.COMPILER_TREE)
1289         public List&lt;JCCase&gt; getCases() { return cases; }
1290         @Override @DefinedBy(Api.COMPILER_TREE)
1291         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1292             return v.visitSwitch(this, d);
1293         }
1294         @Override
1295         public Tag getTag() {
1296             return SWITCH;
1297         }
1298     }
1299 
1300     /**
1301      * A &quot;case  :&quot; of a switch.
1302      */
1303     public static class JCCase extends JCStatement implements CaseTree {
1304         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1305         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1306         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1307         public static final CaseKind RULE = CaseKind.RULE;
1308         public final CaseKind caseKind;
1309         public List&lt;JCExpression&gt; pats;
1310         public List&lt;JCStatement&gt; stats;
1311         public JCTree body;
1312         public boolean completesNormally;
1313         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,
1314                          List&lt;JCStatement&gt; stats, JCTree body) {
1315             Assert.checkNonNull(pats);
1316             Assert.check(pats.isEmpty() || pats.head != null);
1317             this.caseKind = caseKind;
1318             this.pats = pats;
1319             this.stats = stats;
1320             this.body = body;
1321         }
1322         @Override
1323         public void accept(Visitor v) { v.visitCase(this); }
1324 
1325         @Override @DefinedBy(Api.COMPILER_TREE)
1326         public Kind getKind() { return Kind.CASE; }
1327         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)
1328         public JCExpression getExpression() { return pats.head; }
1329         @Override @DefinedBy(Api.COMPILER_TREE)
1330         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1331         @Override @DefinedBy(Api.COMPILER_TREE)
1332         public List&lt;JCStatement&gt; getStatements() {
1333             return caseKind == CaseKind.STATEMENT ? stats : null;
1334         }
1335         @Override @DefinedBy(Api.COMPILER_TREE)
1336         public JCTree getBody() { return body; }
1337         @Override @DefinedBy(Api.COMPILER_TREE)
1338         public CaseKind getCaseKind() {
1339             return caseKind;
1340         }
1341         @Override @DefinedBy(Api.COMPILER_TREE)
1342         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1343             return v.visitCase(this, d);
1344         }
1345         @Override
1346         public Tag getTag() {
1347             return CASE;
1348         }
1349     }
1350 
1351     /**
1352      * A &quot;switch ( ) { }&quot; construction.
1353      */
1354     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1355         public JCExpression selector;
1356         public List&lt;JCCase&gt; cases;
1357         /** Position of closing brace, optional. */
1358         public int endpos = Position.NOPOS;
1359         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1360             this.selector = selector;
1361             this.cases = cases;
1362         }
1363         @Override
1364         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1365 
1366         @DefinedBy(Api.COMPILER_TREE)
1367         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1368         @DefinedBy(Api.COMPILER_TREE)
1369         public JCExpression getExpression() { return selector; }
1370         @DefinedBy(Api.COMPILER_TREE)
1371         public List&lt;JCCase&gt; getCases() { return cases; }
1372         @Override @DefinedBy(Api.COMPILER_TREE)
1373         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1374             return v.visitSwitchExpression(this, d);
1375         }
1376         @Override
1377         public Tag getTag() {
1378             return SWITCH_EXPRESSION;
1379         }
1380     }
1381 
1382     /**
1383      * A synchronized block.
1384      */
1385     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1386         public JCExpression lock;
1387         public JCBlock body;
1388         protected JCSynchronized(JCExpression lock, JCBlock body) {
1389             this.lock = lock;
1390             this.body = body;
1391         }
1392         @Override
1393         public void accept(Visitor v) { v.visitSynchronized(this); }
1394 
1395         @DefinedBy(Api.COMPILER_TREE)
1396         public Kind getKind() { return Kind.SYNCHRONIZED; }
1397         @DefinedBy(Api.COMPILER_TREE)
1398         public JCExpression getExpression() { return lock; }
1399         @DefinedBy(Api.COMPILER_TREE)
1400         public JCBlock getBlock() { return body; }
1401         @Override @DefinedBy(Api.COMPILER_TREE)
1402         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1403             return v.visitSynchronized(this, d);
1404         }
1405         @Override
1406         public Tag getTag() {
1407             return SYNCHRONIZED;
1408         }
1409     }
1410 
1411     /**
1412      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1413      */
1414     public static class JCTry extends JCStatement implements TryTree {
1415         public JCBlock body;
1416         public List&lt;JCCatch&gt; catchers;
1417         public JCBlock finalizer;
1418         public List&lt;JCTree&gt; resources;
1419         public boolean finallyCanCompleteNormally;
1420         protected JCTry(List&lt;JCTree&gt; resources,
1421                         JCBlock body,
1422                         List&lt;JCCatch&gt; catchers,
1423                         JCBlock finalizer) {
1424             this.body = body;
1425             this.catchers = catchers;
1426             this.finalizer = finalizer;
1427             this.resources = resources;
1428         }
1429         @Override
1430         public void accept(Visitor v) { v.visitTry(this); }
1431 
1432         @DefinedBy(Api.COMPILER_TREE)
1433         public Kind getKind() { return Kind.TRY; }
1434         @DefinedBy(Api.COMPILER_TREE)
1435         public JCBlock getBlock() { return body; }
1436         @DefinedBy(Api.COMPILER_TREE)
1437         public List&lt;JCCatch&gt; getCatches() {
1438             return catchers;
1439         }
1440         @DefinedBy(Api.COMPILER_TREE)
1441         public JCBlock getFinallyBlock() { return finalizer; }
1442         @Override @DefinedBy(Api.COMPILER_TREE)
1443         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1444             return v.visitTry(this, d);
1445         }
1446         @Override @DefinedBy(Api.COMPILER_TREE)
1447         public List&lt;JCTree&gt; getResources() {
1448             return resources;
1449         }
1450         @Override
1451         public Tag getTag() {
1452             return TRY;
1453         }
1454     }
1455 
1456     /**
1457      * A catch block.
1458      */
1459     public static class JCCatch extends JCTree implements CatchTree {
1460         public JCVariableDecl param;
1461         public JCBlock body;
1462         protected JCCatch(JCVariableDecl param, JCBlock body) {
1463             this.param = param;
1464             this.body = body;
1465         }
1466         @Override
1467         public void accept(Visitor v) { v.visitCatch(this); }
1468 
1469         @DefinedBy(Api.COMPILER_TREE)
1470         public Kind getKind() { return Kind.CATCH; }
1471         @DefinedBy(Api.COMPILER_TREE)
1472         public JCVariableDecl getParameter() { return param; }
1473         @DefinedBy(Api.COMPILER_TREE)
1474         public JCBlock getBlock() { return body; }
1475         @Override @DefinedBy(Api.COMPILER_TREE)
1476         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1477             return v.visitCatch(this, d);
1478         }
1479         @Override
1480         public Tag getTag() {
1481             return CATCH;
1482         }
1483     }
1484 
1485     /**
1486      * A ( ) ? ( ) : ( ) conditional expression
1487      */
1488     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1489         public JCExpression cond;
1490         public JCExpression truepart;
1491         public JCExpression falsepart;
1492         protected JCConditional(JCExpression cond,
1493                               JCExpression truepart,
1494                               JCExpression falsepart)
1495         {
1496             this.cond = cond;
1497             this.truepart = truepart;
1498             this.falsepart = falsepart;
1499         }
1500         @Override
1501         public void accept(Visitor v) { v.visitConditional(this); }
1502 
1503         @DefinedBy(Api.COMPILER_TREE)
1504         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1505         @DefinedBy(Api.COMPILER_TREE)
1506         public JCExpression getCondition() { return cond; }
1507         @DefinedBy(Api.COMPILER_TREE)
1508         public JCExpression getTrueExpression() { return truepart; }
1509         @DefinedBy(Api.COMPILER_TREE)
1510         public JCExpression getFalseExpression() { return falsepart; }
1511         @Override @DefinedBy(Api.COMPILER_TREE)
1512         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1513             return v.visitConditionalExpression(this, d);
1514         }
1515         @Override
1516         public Tag getTag() {
1517             return CONDEXPR;
1518         }
1519     }
1520 
1521     /**
1522      * An &quot;if ( ) { } else { }&quot; block
1523      */
1524     public static class JCIf extends JCStatement implements IfTree {
1525         public JCExpression cond;
1526         public JCStatement thenpart;
1527         public JCStatement elsepart;
1528         protected JCIf(JCExpression cond,
1529                      JCStatement thenpart,
1530                      JCStatement elsepart)
1531         {
1532             this.cond = cond;
1533             this.thenpart = thenpart;
1534             this.elsepart = elsepart;
1535         }
1536         @Override
1537         public void accept(Visitor v) { v.visitIf(this); }
1538 
1539         @DefinedBy(Api.COMPILER_TREE)
1540         public Kind getKind() { return Kind.IF; }
1541         @DefinedBy(Api.COMPILER_TREE)
1542         public JCExpression getCondition() { return cond; }
1543         @DefinedBy(Api.COMPILER_TREE)
1544         public JCStatement getThenStatement() { return thenpart; }
1545         @DefinedBy(Api.COMPILER_TREE)
1546         public JCStatement getElseStatement() { return elsepart; }
1547         @Override @DefinedBy(Api.COMPILER_TREE)
1548         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1549             return v.visitIf(this, d);
1550         }
1551         @Override
1552         public Tag getTag() {
1553             return IF;
1554         }
1555     }
1556 
1557     /**
1558      * an expression statement
1559      */
1560     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1561         /** expression structure */
1562         public JCExpression expr;
1563         protected JCExpressionStatement(JCExpression expr)
1564         {
1565             this.expr = expr;
1566         }
1567         @Override
1568         public void accept(Visitor v) { v.visitExec(this); }
1569 
1570         @DefinedBy(Api.COMPILER_TREE)
1571         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1572         @DefinedBy(Api.COMPILER_TREE)
1573         public JCExpression getExpression() { return expr; }
1574         @Override @DefinedBy(Api.COMPILER_TREE)
1575         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1576             return v.visitExpressionStatement(this, d);
1577         }
1578         @Override
1579         public Tag getTag() {
1580             return EXEC;
1581         }
1582 
1583         /** Convert a expression-statement tree to a pretty-printed string. */
1584         @Override
1585         public String toString() {
1586             StringWriter s = new StringWriter();
1587             try {
1588                 new Pretty(s, false).printStat(this);
1589             }
1590             catch (IOException e) {
1591                 // should never happen, because StringWriter is defined
1592                 // never to throw any IOExceptions
1593                 throw new AssertionError(e);
1594             }
1595             return s.toString();
1596         }
1597     }
1598 
1599     /**
1600      * A break from a loop or switch.
1601      */
1602     public static class JCBreak extends JCStatement implements BreakTree {
1603         public Name label;
1604         public JCTree target;
1605         protected JCBreak(Name label, JCTree target) {
1606             this.label = label;
1607             this.target = target;
1608         }
1609         @Override
1610         public void accept(Visitor v) { v.visitBreak(this); }
1611         public boolean isValueBreak() {
1612             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1613         }
1614 
1615         @DefinedBy(Api.COMPILER_TREE)
1616         public Kind getKind() { return Kind.BREAK; }
1617         @DefinedBy(Api.COMPILER_TREE)
1618         public Name getLabel() {
1619             return label;
1620         }
1621         @Override @DefinedBy(Api.COMPILER_TREE)
1622         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1623             return v.visitBreak(this, d);
1624         }
1625         @Override
1626         public Tag getTag() {
1627             return BREAK;
1628         }
1629     }
1630 
1631     /**
1632      * A break-with from a switch expression.
1633      */
1634     public static class JCYield extends JCStatement implements YieldTree {
1635         public JCExpression value;
1636         public JCTree target;
1637         protected JCYield(JCExpression value, JCTree target) {
1638             this.value = value;
1639             this.target = target;
1640         }
1641         @Override
1642         public void accept(Visitor v) { v.visitYield(this); }
1643         @DefinedBy(Api.COMPILER_TREE)
1644         public Kind getKind() { return Kind.YIELD; }
1645         @DefinedBy(Api.COMPILER_TREE)
1646         public JCExpression getValue() { return value; }
1647         @Override @DefinedBy(Api.COMPILER_TREE)
1648         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1649             return v.visitYield(this, d);
1650         }
1651         @Override
1652         public Tag getTag() {
1653             return YIELD;
1654         }
1655     }
1656 
1657     /**
1658      * A continue of a loop.
1659      */
1660     public static class JCContinue extends JCStatement implements ContinueTree {
1661         public Name label;
1662         public JCTree target;
1663         protected JCContinue(Name label, JCTree target) {
1664             this.label = label;
1665             this.target = target;
1666         }
1667         @Override
1668         public void accept(Visitor v) { v.visitContinue(this); }
1669 
1670         @DefinedBy(Api.COMPILER_TREE)
1671         public Kind getKind() { return Kind.CONTINUE; }
1672         @DefinedBy(Api.COMPILER_TREE)
1673         public Name getLabel() { return label; }
1674         @Override @DefinedBy(Api.COMPILER_TREE)
1675         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1676             return v.visitContinue(this, d);
1677         }
1678         @Override
1679         public Tag getTag() {
1680             return CONTINUE;
1681         }
1682     }
1683 
1684     /**
1685      * A return statement.
1686      */
1687     public static class JCReturn extends JCStatement implements ReturnTree {
1688         public JCExpression expr;
1689         protected JCReturn(JCExpression expr) {
1690             this.expr = expr;
1691         }
1692         @Override
1693         public void accept(Visitor v) { v.visitReturn(this); }
1694 
1695         @DefinedBy(Api.COMPILER_TREE)
1696         public Kind getKind() { return Kind.RETURN; }
1697         @DefinedBy(Api.COMPILER_TREE)
1698         public JCExpression getExpression() { return expr; }
1699         @Override @DefinedBy(Api.COMPILER_TREE)
1700         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1701             return v.visitReturn(this, d);
1702         }
1703         @Override
1704         public Tag getTag() {
1705             return RETURN;
1706         }
1707     }
1708 
1709     /**
1710      * A throw statement.
1711      */
1712     public static class JCThrow extends JCStatement implements ThrowTree {
1713         public JCExpression expr;
1714         protected JCThrow(JCExpression expr) {
1715             this.expr = expr;
1716         }
1717         @Override
1718         public void accept(Visitor v) { v.visitThrow(this); }
1719 
1720         @DefinedBy(Api.COMPILER_TREE)
1721         public Kind getKind() { return Kind.THROW; }
1722         @DefinedBy(Api.COMPILER_TREE)
1723         public JCExpression getExpression() { return expr; }
1724         @Override @DefinedBy(Api.COMPILER_TREE)
1725         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1726             return v.visitThrow(this, d);
1727         }
1728         @Override
1729         public Tag getTag() {
1730             return THROW;
1731         }
1732     }
1733 
1734     /**
1735      * An assert statement.
1736      */
1737     public static class JCAssert extends JCStatement implements AssertTree {
1738         public JCExpression cond;
1739         public JCExpression detail;
1740         protected JCAssert(JCExpression cond, JCExpression detail) {
1741             this.cond = cond;
1742             this.detail = detail;
1743         }
1744         @Override
1745         public void accept(Visitor v) { v.visitAssert(this); }
1746 
1747         @DefinedBy(Api.COMPILER_TREE)
1748         public Kind getKind() { return Kind.ASSERT; }
1749         @DefinedBy(Api.COMPILER_TREE)
1750         public JCExpression getCondition() { return cond; }
1751         @DefinedBy(Api.COMPILER_TREE)
1752         public JCExpression getDetail() { return detail; }
1753         @Override @DefinedBy(Api.COMPILER_TREE)
1754         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1755             return v.visitAssert(this, d);
1756         }
1757         @Override
1758         public Tag getTag() {
1759             return ASSERT;
1760         }
1761     }
1762 
1763     /**
1764      * A method invocation
1765      */
1766     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1767         public List&lt;JCExpression&gt; typeargs;
1768         public JCExpression meth;
1769         public List&lt;JCExpression&gt; args;
1770         public Type varargsElement;
1771         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1772                         JCExpression meth,
1773                         List&lt;JCExpression&gt; args)
1774         {
1775             this.typeargs = (typeargs == null) ? List.nil()
1776                                                : typeargs;
1777             this.meth = meth;
1778             this.args = args;
1779         }
1780         @Override
1781         public void accept(Visitor v) { v.visitApply(this); }
1782 
1783         @DefinedBy(Api.COMPILER_TREE)
1784         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1785         @DefinedBy(Api.COMPILER_TREE)
1786         public List&lt;JCExpression&gt; getTypeArguments() {
1787             return typeargs;
1788         }
1789         @DefinedBy(Api.COMPILER_TREE)
1790         public JCExpression getMethodSelect() { return meth; }
1791         @DefinedBy(Api.COMPILER_TREE)
1792         public List&lt;JCExpression&gt; getArguments() {
1793             return args;
1794         }
1795         @Override @DefinedBy(Api.COMPILER_TREE)
1796         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1797             return v.visitMethodInvocation(this, d);
1798         }
1799         @Override
1800         public JCMethodInvocation setType(Type type) {
1801             super.setType(type);
1802             return this;
1803         }
1804         @Override
1805         public Tag getTag() {
1806             return(APPLY);
1807         }
1808     }
1809 
1810     /**
1811      * A new(...) operation.
1812      */
1813     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1814         public JCExpression encl;
1815         public List&lt;JCExpression&gt; typeargs;
1816         public JCExpression clazz;
1817         public List&lt;JCExpression&gt; args;
1818         public JCClassDecl def;
1819         public Symbol constructor;
1820         public Type varargsElement;
1821         public Type constructorType;
1822         protected JCNewClass(JCExpression encl,
1823                            List&lt;JCExpression&gt; typeargs,
1824                            JCExpression clazz,
1825                            List&lt;JCExpression&gt; args,
1826                            JCClassDecl def)
1827         {
1828             this.encl = encl;
1829             this.typeargs = (typeargs == null) ? List.nil()
1830                                                : typeargs;
1831             this.clazz = clazz;
1832             this.args = args;
1833             this.def = def;
1834         }
1835         @Override
1836         public void accept(Visitor v) { v.visitNewClass(this); }
1837 
1838         @DefinedBy(Api.COMPILER_TREE)
1839         public Kind getKind() { return Kind.NEW_CLASS; }
1840         @DefinedBy(Api.COMPILER_TREE)
1841         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1842             return encl;
1843         }
1844         @DefinedBy(Api.COMPILER_TREE)
1845         public List&lt;JCExpression&gt; getTypeArguments() {
1846             return typeargs;
1847         }
1848         @DefinedBy(Api.COMPILER_TREE)
1849         public JCExpression getIdentifier() { return clazz; }
1850         @DefinedBy(Api.COMPILER_TREE)
1851         public List&lt;JCExpression&gt; getArguments() {
1852             return args;
1853         }
1854         @DefinedBy(Api.COMPILER_TREE)
1855         public JCClassDecl getClassBody() { return def; }
1856         @Override @DefinedBy(Api.COMPILER_TREE)
1857         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1858             return v.visitNewClass(this, d);
1859         }
1860         @Override
1861         public Tag getTag() {
1862             return NEWCLASS;
1863         }
1864 
1865         public boolean classDeclRemoved() {
1866             return false;
1867         }
1868     }
1869 
1870     /**
1871      * A new[...] operation.
1872      */
1873     public static class JCNewArray extends JCExpression implements NewArrayTree {
1874         public JCExpression elemtype;
1875         public List&lt;JCExpression&gt; dims;
1876         // type annotations on inner-most component
1877         public List&lt;JCAnnotation&gt; annotations;
1878         // type annotations on dimensions
1879         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1880         public List&lt;JCExpression&gt; elems;
1881         protected JCNewArray(JCExpression elemtype,
1882                            List&lt;JCExpression&gt; dims,
1883                            List&lt;JCExpression&gt; elems)
1884         {
1885             this.elemtype = elemtype;
1886             this.dims = dims;
1887             this.annotations = List.nil();
1888             this.dimAnnotations = List.nil();
1889             this.elems = elems;
1890         }
1891         @Override
1892         public void accept(Visitor v) { v.visitNewArray(this); }
1893 
1894         @DefinedBy(Api.COMPILER_TREE)
1895         public Kind getKind() { return Kind.NEW_ARRAY; }
1896         @DefinedBy(Api.COMPILER_TREE)
1897         public JCExpression getType() { return elemtype; }
1898         @DefinedBy(Api.COMPILER_TREE)
1899         public List&lt;JCExpression&gt; getDimensions() {
1900             return dims;
1901         }
1902         @DefinedBy(Api.COMPILER_TREE)
1903         public List&lt;JCExpression&gt; getInitializers() {
1904             return elems;
1905         }
1906         @Override @DefinedBy(Api.COMPILER_TREE)
1907         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1908             return v.visitNewArray(this, d);
1909         }
1910         @Override
1911         public Tag getTag() {
1912             return NEWARRAY;
1913         }
1914 
1915         @Override @DefinedBy(Api.COMPILER_TREE)
1916         public List&lt;JCAnnotation&gt; getAnnotations() {
1917             return annotations;
1918         }
1919 
1920         @Override @DefinedBy(Api.COMPILER_TREE)
1921         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1922             return dimAnnotations;
1923         }
1924     }
1925 
1926     /**
1927      * A lambda expression.
1928      */
1929     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1930 
1931         public enum ParameterKind {
1932             IMPLICIT,
1933             EXPLICIT
1934         }
1935 
1936         public List&lt;JCVariableDecl&gt; params;
1937         public JCTree body;
1938         public boolean canCompleteNormally = true;
1939         public ParameterKind paramKind;
1940 
1941         public JCLambda(List&lt;JCVariableDecl&gt; params,
1942                         JCTree body) {
1943             this.params = params;
1944             this.body = body;
1945             if (params.isEmpty() ||
1946                 params.head.vartype != null) {
1947                 paramKind = ParameterKind.EXPLICIT;
1948             } else {
1949                 paramKind = ParameterKind.IMPLICIT;
1950             }
1951         }
1952         @Override
1953         public Tag getTag() {
1954             return LAMBDA;
1955         }
1956         @Override
1957         public void accept(Visitor v) {
1958             v.visitLambda(this);
1959         }
1960         @Override @DefinedBy(Api.COMPILER_TREE)
1961         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1962             return v.visitLambdaExpression(this, d);
1963         }
1964         @DefinedBy(Api.COMPILER_TREE)
1965         public Kind getKind() {
1966             return Kind.LAMBDA_EXPRESSION;
1967         }
1968         @DefinedBy(Api.COMPILER_TREE)
1969         public JCTree getBody() {
1970             return body;
1971         }
1972         @DefinedBy(Api.COMPILER_TREE)
1973         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1974             return params;
1975         }
1976         @Override
1977         public JCLambda setType(Type type) {
1978             super.setType(type);
1979             return this;
1980         }
1981         @Override @DefinedBy(Api.COMPILER_TREE)
1982         public BodyKind getBodyKind() {
1983             return body.hasTag(BLOCK) ?
1984                     BodyKind.STATEMENT :
1985                     BodyKind.EXPRESSION;
1986         }
1987     }
1988 
1989     /**
1990      * A parenthesized subexpression ( ... )
1991      */
1992     public static class JCParens extends JCExpression implements ParenthesizedTree {
1993         public JCExpression expr;
1994         protected JCParens(JCExpression expr) {
1995             this.expr = expr;
1996         }
1997         @Override
1998         public void accept(Visitor v) { v.visitParens(this); }
1999 
2000         @DefinedBy(Api.COMPILER_TREE)
2001         public Kind getKind() { return Kind.PARENTHESIZED; }
2002         @DefinedBy(Api.COMPILER_TREE)
2003         public JCExpression getExpression() { return expr; }
2004         @Override @DefinedBy(Api.COMPILER_TREE)
2005         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2006             return v.visitParenthesized(this, d);
2007         }
2008         @Override
2009         public Tag getTag() {
2010             return PARENS;
2011         }
2012     }
2013 
2014     /**
2015      * A assignment with &quot;=&quot;.
2016      */
2017     public static class JCAssign extends JCExpression implements AssignmentTree {
2018         public JCExpression lhs;
2019         public JCExpression rhs;
2020         protected JCAssign(JCExpression lhs, JCExpression rhs) {
2021             this.lhs = lhs;
2022             this.rhs = rhs;
2023         }
2024         @Override
2025         public void accept(Visitor v) { v.visitAssign(this); }
2026 
2027         @DefinedBy(Api.COMPILER_TREE)
2028         public Kind getKind() { return Kind.ASSIGNMENT; }
2029         @DefinedBy(Api.COMPILER_TREE)
2030         public JCExpression getVariable() { return lhs; }
2031         @DefinedBy(Api.COMPILER_TREE)
2032         public JCExpression getExpression() { return rhs; }
2033         @Override @DefinedBy(Api.COMPILER_TREE)
2034         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2035             return v.visitAssignment(this, d);
2036         }
2037         @Override
2038         public Tag getTag() {
2039             return ASSIGN;
2040         }
2041     }
2042 
2043     public static abstract class JCOperatorExpression extends JCExpression {
2044         public enum OperandPos {
2045             LEFT,
2046             RIGHT
2047         }
2048 
2049         protected Tag opcode;
2050         public OperatorSymbol operator;
2051 
2052         public OperatorSymbol getOperator() {
2053             return operator;
2054         }
2055 
2056         @Override
2057         public Tag getTag() {
2058             return opcode;
2059         }
2060 
2061         public abstract JCExpression getOperand(OperandPos pos);
2062     }
2063 
2064     /**
2065      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2066      */
2067     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2068         public JCExpression lhs;
2069         public JCExpression rhs;
2070         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2071             this.opcode = opcode;
2072             this.lhs = (JCExpression)lhs;
2073             this.rhs = (JCExpression)rhs;
2074             this.operator = operator;
2075         }
2076         @Override
2077         public void accept(Visitor v) { v.visitAssignop(this); }
2078 
2079         @DefinedBy(Api.COMPILER_TREE)
2080         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2081         @DefinedBy(Api.COMPILER_TREE)
2082         public JCExpression getVariable() { return lhs; }
2083         @DefinedBy(Api.COMPILER_TREE)
2084         public JCExpression getExpression() { return rhs; }
2085         @Override @DefinedBy(Api.COMPILER_TREE)
2086         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2087             return v.visitCompoundAssignment(this, d);
2088         }
2089         @Override
2090         public JCExpression getOperand(OperandPos pos) {
2091             return pos == OperandPos.LEFT ? lhs : rhs;
2092         }
2093     }
2094 
2095     /**
2096      * A unary operation.
2097      */
2098     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2099         public JCExpression arg;
2100         protected JCUnary(Tag opcode, JCExpression arg) {
2101             this.opcode = opcode;
2102             this.arg = arg;
2103         }
2104         @Override
2105         public void accept(Visitor v) { v.visitUnary(this); }
2106 
2107         @DefinedBy(Api.COMPILER_TREE)
2108         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2109         @DefinedBy(Api.COMPILER_TREE)
2110         public JCExpression getExpression() { return arg; }
2111         @Override @DefinedBy(Api.COMPILER_TREE)
2112         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2113             return v.visitUnary(this, d);
2114         }
2115         public void setTag(Tag tag) {
2116             opcode = tag;
2117         }
2118         @Override
2119         public JCExpression getOperand(OperandPos pos) {
2120             return arg;
2121         }
2122     }
2123 
2124     /**
2125      * A binary operation.
2126      */
2127     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2128         public JCExpression lhs;
2129         public JCExpression rhs;
2130         protected JCBinary(Tag opcode,
2131                          JCExpression lhs,
2132                          JCExpression rhs,
2133                          OperatorSymbol operator) {
2134             this.opcode = opcode;
2135             this.lhs = lhs;
2136             this.rhs = rhs;
2137             this.operator = operator;
2138         }
2139         @Override
2140         public void accept(Visitor v) { v.visitBinary(this); }
2141 
2142         @DefinedBy(Api.COMPILER_TREE)
2143         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2144         @DefinedBy(Api.COMPILER_TREE)
2145         public JCExpression getLeftOperand() { return lhs; }
2146         @DefinedBy(Api.COMPILER_TREE)
2147         public JCExpression getRightOperand() { return rhs; }
2148         @Override @DefinedBy(Api.COMPILER_TREE)
2149         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2150             return v.visitBinary(this, d);
2151         }
2152         @Override
2153         public JCExpression getOperand(OperandPos pos) {
2154             return pos == OperandPos.LEFT ? lhs : rhs;
2155         }
2156     }
2157 
2158     /**
2159      * A type cast.
2160      */
2161     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2162         public JCTree clazz;
2163         public JCExpression expr;
2164         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2165             this.clazz = clazz;
2166             this.expr = expr;
2167         }
2168         @Override
2169         public void accept(Visitor v) { v.visitTypeCast(this); }
2170 
2171         @DefinedBy(Api.COMPILER_TREE)
2172         public Kind getKind() { return Kind.TYPE_CAST; }
2173         @DefinedBy(Api.COMPILER_TREE)
2174         public JCTree getType() { return clazz; }
2175         @DefinedBy(Api.COMPILER_TREE)
2176         public JCExpression getExpression() { return expr; }
2177         @Override @DefinedBy(Api.COMPILER_TREE)
2178         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2179             return v.visitTypeCast(this, d);
2180         }
2181         @Override
2182         public Tag getTag() {
2183             return TYPECAST;
2184         }
2185     }
2186 
2187     /**
2188      * A type test.
2189      */
2190     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2191         public JCExpression expr;
2192         public JCTree pattern;
2193         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2194             this.expr = expr;
2195             this.pattern = pattern;
2196         }
2197         @Override
2198         public void accept(Visitor v) { v.visitTypeTest(this); }
2199 
2200         @DefinedBy(Api.COMPILER_TREE)
2201         public Kind getKind() { return Kind.INSTANCE_OF; }
2202         @DefinedBy(Api.COMPILER_TREE)
2203         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2204 
2205         @Override @DefinedBy(Api.COMPILER_TREE)
2206         public JCPattern getPattern() {
2207             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2208         }
2209 
2210         @DefinedBy(Api.COMPILER_TREE)
2211         public JCExpression getExpression() { return expr; }
2212         @Override @DefinedBy(Api.COMPILER_TREE)
2213         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2214             return v.visitInstanceOf(this, d);
2215         }
2216         @Override
2217         public Tag getTag() {
2218             return TYPETEST;
2219         }
2220     }
2221 
2222     /**
2223      * Pattern matching forms.
2224      */
2225     public static abstract class JCPattern extends JCTree
2226             implements PatternTree {
2227         public JCExpression constExpression() {
2228             return null;
2229         }
2230     }
2231 
2232     public static class JCBindingPattern extends JCPattern
2233             implements BindingPatternTree {
2234         public Name name;
2235         public BindingSymbol symbol;
2236         public JCTree vartype;
2237 
2238         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2239             this.name = name;
2240             this.symbol = symbol;
2241             this.vartype = vartype;
2242         }
2243 
2244         @DefinedBy(Api.COMPILER_TREE)
2245         public Name getBinding() {
2246             return name;
2247         }
2248 
2249         @Override @DefinedBy(Api.COMPILER_TREE)
2250         public Tree getType() {
2251             return vartype;
2252         }
2253 
2254         @Override
2255         public void accept(Visitor v) {
2256             v.visitBindingPattern(this);
2257         }
2258 
2259         @DefinedBy(Api.COMPILER_TREE)
2260         public Kind getKind() {
2261             return Kind.BINDING_PATTERN;
2262         }
2263 
2264         @Override
2265         @DefinedBy(Api.COMPILER_TREE)
2266         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2267             return v.visitBindingPattern(this, d);
2268         }
2269 
2270         @Override
2271         public Tag getTag() {
2272             return BINDINGPATTERN;
2273         }
2274     }
2275 
2276     /**
2277      * An array selection
2278      */
2279     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2280         public JCExpression indexed;
2281         public JCExpression index;
2282         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2283             this.indexed = indexed;
2284             this.index = index;
2285         }
2286         @Override
2287         public void accept(Visitor v) { v.visitIndexed(this); }
2288 
2289         @DefinedBy(Api.COMPILER_TREE)
2290         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2291         @DefinedBy(Api.COMPILER_TREE)
2292         public JCExpression getExpression() { return indexed; }
2293         @DefinedBy(Api.COMPILER_TREE)
2294         public JCExpression getIndex() { return index; }
2295         @Override @DefinedBy(Api.COMPILER_TREE)
2296         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2297             return v.visitArrayAccess(this, d);
2298         }
2299         @Override
2300         public Tag getTag() {
2301             return INDEXED;
2302         }
2303     }
2304 
2305     /**
2306      * Selects through packages and classes
2307      */
2308     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2309         /** selected Tree hierarchy */
2310         public JCExpression selected;
2311         /** name of field to select thru */
2312         public Name name;
2313         /** symbol of the selected class */
2314         public Symbol sym;
2315         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2316             this.selected = selected;
2317             this.name = name;
2318             this.sym = sym;
2319         }
2320         @Override
2321         public void accept(Visitor v) { v.visitSelect(this); }
2322 
2323         @DefinedBy(Api.COMPILER_TREE)
2324         public Kind getKind() { return Kind.MEMBER_SELECT; }
2325         @DefinedBy(Api.COMPILER_TREE)
2326         public JCExpression getExpression() { return selected; }
2327         @Override @DefinedBy(Api.COMPILER_TREE)
2328         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2329             return v.visitMemberSelect(this, d);
2330         }
2331         @DefinedBy(Api.COMPILER_TREE)
2332         public Name getIdentifier() { return name; }
2333         @Override
2334         public Tag getTag() {
2335             return SELECT;
2336         }
2337     }
2338 
2339     /**
2340      * Selects a member expression.
2341      */
2342     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2343 
2344         public ReferenceMode mode;
2345         public ReferenceKind kind;
2346         public Name name;
2347         public JCExpression expr;
2348         public List&lt;JCExpression&gt; typeargs;
2349         public Symbol sym;
2350         public Type varargsElement;
2351         public PolyKind refPolyKind;
2352         public boolean ownerAccessible;
2353         private OverloadKind overloadKind;
2354         public Type referentType;
2355 
2356         public enum OverloadKind {
2357             OVERLOADED,
2358             UNOVERLOADED,
2359             ERROR
2360         }
2361 
2362         /**
2363          * Javac-dependent classification for member references, based
2364          * on relevant properties w.r.t. code-generation
2365          */
2366         public enum ReferenceKind {
2367             /** super # instMethod */
2368             SUPER(ReferenceMode.INVOKE, false),
2369             /** Type # instMethod */
2370             UNBOUND(ReferenceMode.INVOKE, true),
2371             /** Type # staticMethod */
2372             STATIC(ReferenceMode.INVOKE, false),
2373             /** Expr # instMethod */
2374             BOUND(ReferenceMode.INVOKE, false),
2375             /** Inner # new */
2376             IMPLICIT_INNER(ReferenceMode.NEW, false),
2377             /** Toplevel # new */
2378             TOPLEVEL(ReferenceMode.NEW, false),
2379             /** ArrayType # new */
2380             ARRAY_CTOR(ReferenceMode.NEW, false);
2381 
2382             final ReferenceMode mode;
2383             final boolean unbound;
2384 
2385             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2386                 this.mode = mode;
2387                 this.unbound = unbound;
2388             }
2389 
2390             public boolean isUnbound() {
2391                 return unbound;
2392             }
2393         }
2394 
2395         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2396             this.mode = mode;
2397             this.name = name;
2398             this.expr = expr;
2399             this.typeargs = typeargs;
2400         }
2401         @Override
2402         public void accept(Visitor v) { v.visitReference(this); }
2403 
2404         @DefinedBy(Api.COMPILER_TREE)
2405         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2406         @Override @DefinedBy(Api.COMPILER_TREE)
2407         public ReferenceMode getMode() { return mode; }
2408         @Override @DefinedBy(Api.COMPILER_TREE)
2409         public JCExpression getQualifierExpression() { return expr; }
2410         @Override @DefinedBy(Api.COMPILER_TREE)
2411         public Name getName() { return name; }
2412         @Override @DefinedBy(Api.COMPILER_TREE)
2413         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2414 
2415         @Override @DefinedBy(Api.COMPILER_TREE)
2416         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2417             return v.visitMemberReference(this, d);
2418         }
2419         @Override
2420         public Tag getTag() {
2421             return REFERENCE;
2422         }
2423         public boolean hasKind(ReferenceKind kind) {
2424             return this.kind == kind;
2425         }
2426 
2427         /**
2428          * @return the overloadKind
2429          */
2430         public OverloadKind getOverloadKind() {
2431             return overloadKind;
2432         }
2433 
2434         /**
2435          * @param overloadKind the overloadKind to set
2436          */
2437         public void setOverloadKind(OverloadKind overloadKind) {
2438             this.overloadKind = overloadKind;
2439         }
2440     }
2441 
2442     /**
2443      * An identifier
2444      */
2445     public static class JCIdent extends JCExpression implements IdentifierTree {
2446         /** the name */
2447         public Name name;
2448         /** the symbol */
2449         public Symbol sym;
2450         protected JCIdent(Name name, Symbol sym) {
2451             this.name = name;
2452             this.sym = sym;
2453         }
2454         @Override
2455         public void accept(Visitor v) { v.visitIdent(this); }
2456 
2457         @DefinedBy(Api.COMPILER_TREE)
2458         public Kind getKind() { return Kind.IDENTIFIER; }
2459         @DefinedBy(Api.COMPILER_TREE)
2460         public Name getName() { return name; }
2461         @Override @DefinedBy(Api.COMPILER_TREE)
2462         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2463             return v.visitIdentifier(this, d);
2464         }
2465         @Override
2466         public Tag getTag() {
2467             return IDENT;
2468         }
2469     }
2470 
2471     /**
2472      * A constant value given literally.
2473      */
2474     public static class JCLiteral extends JCExpression implements LiteralTree {
2475         public TypeTag typetag;
2476         /** value representation */
2477         public Object value;
2478         protected JCLiteral(TypeTag typetag, Object value) {
2479             this.typetag = typetag;
2480             this.value = value;
2481         }
2482         @Override
2483         public void accept(Visitor v) { v.visitLiteral(this); }
2484 
2485         @DefinedBy(Api.COMPILER_TREE)
2486         public Kind getKind() {
2487             return typetag.getKindLiteral();
2488         }
2489 
2490         @DefinedBy(Api.COMPILER_TREE)
2491         public Object getValue() {
2492             switch (typetag) {
2493                 case BOOLEAN:
2494                     int bi = (Integer) value;
2495                     return (bi != 0);
2496                 case CHAR:
2497                     int ci = (Integer) value;
2498                     char c = (char) ci;
2499                     if (c != ci)
2500                         throw new AssertionError(&quot;bad value for char literal&quot;);
2501                     return c;
2502                 default:
2503                     return value;
2504             }
2505         }
2506         @Override @DefinedBy(Api.COMPILER_TREE)
2507         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2508             return v.visitLiteral(this, d);
2509         }
2510         @Override
2511         public JCLiteral setType(Type type) {
2512             super.setType(type);
2513             return this;
2514         }
2515         @Override
2516         public Tag getTag() {
2517             return LITERAL;
2518         }
2519     }
2520 
2521     /**
2522      * Identifies a basic type.
2523      * @see TypeTag
2524      */
2525     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2526         /** the basic type id */
2527         public TypeTag typetag;
2528         protected JCPrimitiveTypeTree(TypeTag typetag) {
2529             this.typetag = typetag;
2530         }
2531         @Override
2532         public void accept(Visitor v) { v.visitTypeIdent(this); }
2533 
2534         @DefinedBy(Api.COMPILER_TREE)
2535         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2536         @DefinedBy(Api.COMPILER_TREE)
2537         public TypeKind getPrimitiveTypeKind() {
2538             return typetag.getPrimitiveTypeKind();
2539         }
2540 
2541         @Override @DefinedBy(Api.COMPILER_TREE)
2542         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2543             return v.visitPrimitiveType(this, d);
2544         }
2545         @Override
2546         public Tag getTag() {
2547             return TYPEIDENT;
2548         }
2549     }
2550 
2551     /**
2552      * An array type, A[]
2553      */
2554     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2555         public JCExpression elemtype;
2556         protected JCArrayTypeTree(JCExpression elemtype) {
2557             this.elemtype = elemtype;
2558         }
2559         @Override
2560         public void accept(Visitor v) { v.visitTypeArray(this); }
2561 
2562         @DefinedBy(Api.COMPILER_TREE)
2563         public Kind getKind() { return Kind.ARRAY_TYPE; }
2564         @DefinedBy(Api.COMPILER_TREE)
2565         public JCTree getType() { return elemtype; }
2566         @Override @DefinedBy(Api.COMPILER_TREE)
2567         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2568             return v.visitArrayType(this, d);
2569         }
2570         @Override
2571         public Tag getTag() {
2572             return TYPEARRAY;
2573         }
2574     }
2575 
2576     /**
2577      * A parameterized type, {@literal T&lt;...&gt;}
2578      */
2579     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2580         public JCExpression clazz;
2581         public List&lt;JCExpression&gt; arguments;
2582         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2583             this.clazz = clazz;
2584             this.arguments = arguments;
2585         }
2586         @Override
2587         public void accept(Visitor v) { v.visitTypeApply(this); }
2588 
2589         @DefinedBy(Api.COMPILER_TREE)
2590         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2591         @DefinedBy(Api.COMPILER_TREE)
2592         public JCTree getType() { return clazz; }
2593         @DefinedBy(Api.COMPILER_TREE)
2594         public List&lt;JCExpression&gt; getTypeArguments() {
2595             return arguments;
2596         }
2597         @Override @DefinedBy(Api.COMPILER_TREE)
2598         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2599             return v.visitParameterizedType(this, d);
2600         }
2601         @Override
2602         public Tag getTag() {
2603             return TYPEAPPLY;
2604         }
2605     }
2606 
2607     /**
2608      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2609      */
2610     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2611 
2612         public List&lt;JCExpression&gt; alternatives;
2613 
2614         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2615             this.alternatives = components;
2616         }
2617         @Override
2618         public void accept(Visitor v) { v.visitTypeUnion(this); }
2619 
2620         @DefinedBy(Api.COMPILER_TREE)
2621         public Kind getKind() { return Kind.UNION_TYPE; }
2622 
2623         @DefinedBy(Api.COMPILER_TREE)
2624         public List&lt;JCExpression&gt; getTypeAlternatives() {
2625             return alternatives;
2626         }
2627         @Override @DefinedBy(Api.COMPILER_TREE)
2628         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2629             return v.visitUnionType(this, d);
2630         }
2631         @Override
2632         public Tag getTag() {
2633             return TYPEUNION;
2634         }
2635     }
2636 
2637     /**
2638      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2639      */
2640     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2641 
2642         public List&lt;JCExpression&gt; bounds;
2643 
2644         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2645             this.bounds = bounds;
2646         }
2647         @Override
2648         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2649 
2650         @DefinedBy(Api.COMPILER_TREE)
2651         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2652 
2653         @DefinedBy(Api.COMPILER_TREE)
2654         public List&lt;JCExpression&gt; getBounds() {
2655             return bounds;
2656         }
2657         @Override @DefinedBy(Api.COMPILER_TREE)
2658         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2659             return v.visitIntersectionType(this, d);
2660         }
2661         @Override
2662         public Tag getTag() {
2663             return TYPEINTERSECTION;
2664         }
2665     }
2666 
2667     /**
2668      * A formal class parameter.
2669      */
2670     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2671         /** name */
2672         public Name name;
2673         /** bounds */
2674         public List&lt;JCExpression&gt; bounds;
2675         /** type annotations on type parameter */
2676         public List&lt;JCAnnotation&gt; annotations;
2677         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2678             this.name = name;
2679             this.bounds = bounds;
2680             this.annotations = annotations;
2681         }
2682         @Override
2683         public void accept(Visitor v) { v.visitTypeParameter(this); }
2684 
2685         @DefinedBy(Api.COMPILER_TREE)
2686         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2687         @DefinedBy(Api.COMPILER_TREE)
2688         public Name getName() { return name; }
2689         @DefinedBy(Api.COMPILER_TREE)
2690         public List&lt;JCExpression&gt; getBounds() {
2691             return bounds;
2692         }
2693         @DefinedBy(Api.COMPILER_TREE)
2694         public List&lt;JCAnnotation&gt; getAnnotations() {
2695             return annotations;
2696         }
2697         @Override @DefinedBy(Api.COMPILER_TREE)
2698         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2699             return v.visitTypeParameter(this, d);
2700         }
2701         @Override
2702         public Tag getTag() {
2703             return TYPEPARAMETER;
2704         }
2705     }
2706 
2707     public static class JCWildcard extends JCExpression implements WildcardTree {
2708         public TypeBoundKind kind;
2709         public JCTree inner;
2710         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2711             this.kind = Assert.checkNonNull(kind);
2712             this.inner = inner;
2713         }
2714         @Override
2715         public void accept(Visitor v) { v.visitWildcard(this); }
2716 
2717         @DefinedBy(Api.COMPILER_TREE)
2718         public Kind getKind() {
2719             switch (kind.kind) {
2720             case UNBOUND:
2721                 return Kind.UNBOUNDED_WILDCARD;
2722             case EXTENDS:
2723                 return Kind.EXTENDS_WILDCARD;
2724             case SUPER:
2725                 return Kind.SUPER_WILDCARD;
2726             default:
2727                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2728             }
2729         }
2730         @DefinedBy(Api.COMPILER_TREE)
2731         public JCTree getBound() { return inner; }
2732         @Override @DefinedBy(Api.COMPILER_TREE)
2733         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2734             return v.visitWildcard(this, d);
2735         }
2736         @Override
2737         public Tag getTag() {
2738             return Tag.WILDCARD;
2739         }
2740     }
2741 
2742     public static class TypeBoundKind extends JCTree {
2743         public BoundKind kind;
2744         protected TypeBoundKind(BoundKind kind) {
2745             this.kind = kind;
2746         }
2747         @Override
2748         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2749 
2750         @DefinedBy(Api.COMPILER_TREE)
2751         public Kind getKind() {
2752             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2753         }
2754         @Override @DefinedBy(Api.COMPILER_TREE)
2755         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2756             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2757         }
2758         @Override
2759         public Tag getTag() {
2760             return TYPEBOUNDKIND;
2761         }
2762     }
2763 
2764     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2765         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2766         private Tag tag;
2767 
2768         public JCTree annotationType;
2769         public List&lt;JCExpression&gt; args;
2770         public Attribute.Compound attribute;
2771 
2772         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2773             this.tag = tag;
2774             this.annotationType = annotationType;
2775             this.args = args;
2776         }
2777 
2778         @Override
2779         public void accept(Visitor v) { v.visitAnnotation(this); }
2780 
2781         @DefinedBy(Api.COMPILER_TREE)
2782         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2783 
2784         @DefinedBy(Api.COMPILER_TREE)
2785         public JCTree getAnnotationType() { return annotationType; }
2786         @DefinedBy(Api.COMPILER_TREE)
2787         public List&lt;JCExpression&gt; getArguments() {
2788             return args;
2789         }
2790         @Override @DefinedBy(Api.COMPILER_TREE)
2791         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2792             return v.visitAnnotation(this, d);
2793         }
2794         @Override
2795         public Tag getTag() {
2796             return tag;
2797         }
2798     }
2799 
2800     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2801         public long flags;
2802         public List&lt;JCAnnotation&gt; annotations;
2803         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2804             this.flags = flags;
2805             this.annotations = annotations;
2806         }
2807         @Override
2808         public void accept(Visitor v) { v.visitModifiers(this); }
2809 
2810         @DefinedBy(Api.COMPILER_TREE)
2811         public Kind getKind() { return Kind.MODIFIERS; }
2812         @DefinedBy(Api.COMPILER_TREE)
2813         public Set&lt;Modifier&gt; getFlags() {
2814             return Flags.asModifierSet(flags);
2815         }
2816         @DefinedBy(Api.COMPILER_TREE)
2817         public List&lt;JCAnnotation&gt; getAnnotations() {
2818             return annotations;
2819         }
2820         @Override @DefinedBy(Api.COMPILER_TREE)
2821         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2822             return v.visitModifiers(this, d);
2823         }
2824         @Override
2825         public Tag getTag() {
2826             return MODIFIERS;
2827         }
2828     }
2829 
2830     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2831         // type annotations
2832         public List&lt;JCAnnotation&gt; annotations;
2833         public JCExpression underlyingType;
2834 
2835         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2836             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2837             this.annotations = annotations;
2838             this.underlyingType = underlyingType;
2839         }
2840         @Override
2841         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2842 
2843         @DefinedBy(Api.COMPILER_TREE)
2844         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2845         @DefinedBy(Api.COMPILER_TREE)
2846         public List&lt;JCAnnotation&gt; getAnnotations() {
2847             return annotations;
2848         }
2849         @DefinedBy(Api.COMPILER_TREE)
2850         public JCExpression getUnderlyingType() {
2851             return underlyingType;
2852         }
2853         @Override @DefinedBy(Api.COMPILER_TREE)
2854         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2855             return v.visitAnnotatedType(this, d);
2856         }
2857         @Override
2858         public Tag getTag() {
2859             return ANNOTATED_TYPE;
2860         }
2861     }
2862 
2863     public static abstract class JCDirective extends JCTree
2864         implements DirectiveTree {
2865     }
2866 
2867     public static class JCModuleDecl extends JCTree implements ModuleTree {
2868         public JCModifiers mods;
2869         public ModuleType type;
2870         private final ModuleKind kind;
2871         public JCExpression qualId;
2872         public List&lt;JCDirective&gt; directives;
2873         public ModuleSymbol sym;
2874 
2875         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2876                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2877             this.mods = mods;
2878             this.kind = kind;
2879             this.qualId = qualId;
2880             this.directives = directives;
2881         }
2882 
2883         @Override
2884         public void accept(Visitor v) { v.visitModuleDef(this); }
2885 
2886         @Override @DefinedBy(Api.COMPILER_TREE)
2887         public Kind getKind() {
2888             return Kind.MODULE;
2889         }
2890 
2891         @Override @DefinedBy(Api.COMPILER_TREE)
2892         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2893             return mods.annotations;
2894         }
2895 
2896         @Override @DefinedBy(Api.COMPILER_TREE)
2897         public ModuleKind getModuleType() {
2898             return kind;
2899         }
2900 
2901         @Override @DefinedBy(Api.COMPILER_TREE)
2902         public JCExpression getName() {
2903             return qualId;
2904         }
2905 
2906         @Override @DefinedBy(Api.COMPILER_TREE)
2907         public List&lt;JCDirective&gt; getDirectives() {
2908             return directives;
2909         }
2910 
2911         @Override @DefinedBy(Api.COMPILER_TREE)
2912         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2913             return v.visitModule(this, d);
2914         }
2915 
2916         @Override
2917         public Tag getTag() {
2918             return MODULEDEF;
2919         }
2920     }
2921 
2922     public static class JCExports extends JCDirective
2923             implements ExportsTree {
2924         public JCExpression qualid;
2925         public List&lt;JCExpression&gt; moduleNames;
2926         public ExportsDirective directive;
2927 
2928         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2929             this.qualid = qualId;
2930             this.moduleNames = moduleNames;
2931         }
2932 
2933         @Override
2934         public void accept(Visitor v) { v.visitExports(this); }
2935 
2936         @Override @DefinedBy(Api.COMPILER_TREE)
2937         public Kind getKind() {
2938             return Kind.EXPORTS;
2939         }
2940 
2941         @Override @DefinedBy(Api.COMPILER_TREE)
2942         public JCExpression getPackageName() {
2943             return qualid;
2944         }
2945 
2946         @Override @DefinedBy(Api.COMPILER_TREE)
2947         public List&lt;JCExpression&gt; getModuleNames() {
2948             return moduleNames;
2949         }
2950 
2951         @Override @DefinedBy(Api.COMPILER_TREE)
2952         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2953             return v.visitExports(this, d);
2954         }
2955 
2956         @Override
2957         public Tag getTag() {
2958             return Tag.EXPORTS;
2959         }
2960     }
2961 
2962     public static class JCOpens extends JCDirective
2963             implements OpensTree {
2964         public JCExpression qualid;
2965         public List&lt;JCExpression&gt; moduleNames;
2966         public OpensDirective directive;
2967 
2968         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2969             this.qualid = qualId;
2970             this.moduleNames = moduleNames;
2971         }
2972 
2973         @Override
2974         public void accept(Visitor v) { v.visitOpens(this); }
2975 
2976         @Override @DefinedBy(Api.COMPILER_TREE)
2977         public Kind getKind() {
2978             return Kind.OPENS;
2979         }
2980 
2981         @Override @DefinedBy(Api.COMPILER_TREE)
2982         public JCExpression getPackageName() {
2983             return qualid;
2984         }
2985 
2986         @Override @DefinedBy(Api.COMPILER_TREE)
2987         public List&lt;JCExpression&gt; getModuleNames() {
2988             return moduleNames;
2989         }
2990 
2991         @Override @DefinedBy(Api.COMPILER_TREE)
2992         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2993             return v.visitOpens(this, d);
2994         }
2995 
2996         @Override
2997         public Tag getTag() {
2998             return Tag.OPENS;
2999         }
3000     }
3001 
3002     public static class JCProvides extends JCDirective
3003             implements ProvidesTree {
3004         public JCExpression serviceName;
3005         public List&lt;JCExpression&gt; implNames;
3006 
3007         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
3008             this.serviceName = serviceName;
3009             this.implNames = implNames;
3010         }
3011 
3012         @Override
3013         public void accept(Visitor v) { v.visitProvides(this); }
3014 
3015         @Override @DefinedBy(Api.COMPILER_TREE)
3016         public Kind getKind() {
3017             return Kind.PROVIDES;
3018         }
3019 
3020         @Override @DefinedBy(Api.COMPILER_TREE)
3021         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3022             return v.visitProvides(this, d);
3023         }
3024 
3025         @Override @DefinedBy(Api.COMPILER_TREE)
3026         public JCExpression getServiceName() {
3027             return serviceName;
3028         }
3029 
3030         @Override @DefinedBy(Api.COMPILER_TREE)
3031         public List&lt;JCExpression&gt; getImplementationNames() {
3032             return implNames;
3033         }
3034 
3035         @Override
3036         public Tag getTag() {
3037             return PROVIDES;
3038         }
3039     }
3040 
3041     public static class JCRequires extends JCDirective
3042             implements RequiresTree {
3043         public boolean isTransitive;
3044         public boolean isStaticPhase;
3045         public JCExpression moduleName;
3046         public RequiresDirective directive;
3047 
3048         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3049             this.isTransitive = isTransitive;
3050             this.isStaticPhase = isStaticPhase;
3051             this.moduleName = moduleName;
3052         }
3053 
3054         @Override
3055         public void accept(Visitor v) { v.visitRequires(this); }
3056 
3057         @Override @DefinedBy(Api.COMPILER_TREE)
3058         public Kind getKind() {
3059             return Kind.REQUIRES;
3060         }
3061 
3062         @Override @DefinedBy(Api.COMPILER_TREE)
3063         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3064             return v.visitRequires(this, d);
3065         }
3066 
3067         @Override @DefinedBy(Api.COMPILER_TREE)
3068         public boolean isTransitive() {
3069             return isTransitive;
3070         }
3071 
3072         @Override @DefinedBy(Api.COMPILER_TREE)
3073         public boolean isStatic() {
3074             return isStaticPhase;
3075         }
3076 
3077         @Override @DefinedBy(Api.COMPILER_TREE)
3078         public JCExpression getModuleName() {
3079             return moduleName;
3080         }
3081 
3082         @Override
3083         public Tag getTag() {
3084             return REQUIRES;
3085         }
3086     }
3087 
3088     public static class JCUses extends JCDirective
3089             implements UsesTree {
3090         public JCExpression qualid;
3091 
3092         protected JCUses(JCExpression qualId) {
3093             this.qualid = qualId;
3094         }
3095 
3096         @Override
3097         public void accept(Visitor v) { v.visitUses(this); }
3098 
3099         @Override @DefinedBy(Api.COMPILER_TREE)
3100         public Kind getKind() {
3101             return Kind.USES;
3102         }
3103 
3104         @Override @DefinedBy(Api.COMPILER_TREE)
3105         public JCExpression getServiceName() {
3106             return qualid;
3107         }
3108 
3109         @Override @DefinedBy(Api.COMPILER_TREE)
3110         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3111             return v.visitUses(this, d);
3112         }
3113 
3114         @Override
3115         public Tag getTag() {
3116             return USES;
3117         }
3118     }
3119 
3120     public static class JCErroneous extends JCExpression
3121             implements ErroneousTree {
3122         public List&lt;? extends JCTree&gt; errs;
3123         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3124             this.errs = errs;
3125         }
3126         @Override
3127         public void accept(Visitor v) { v.visitErroneous(this); }
3128 
3129         @DefinedBy(Api.COMPILER_TREE)
3130         public Kind getKind() { return Kind.ERRONEOUS; }
3131 
3132         @DefinedBy(Api.COMPILER_TREE)
3133         public List&lt;? extends JCTree&gt; getErrorTrees() {
3134             return errs;
3135         }
3136 
3137         @Override @DefinedBy(Api.COMPILER_TREE)
3138         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3139             return v.visitErroneous(this, d);
3140         }
3141         @Override
3142         public Tag getTag() {
3143             return ERRONEOUS;
3144         }
3145     }
3146 
3147     /** (let int x = 3; in x+2) */
3148     public static class LetExpr extends JCExpression {
3149         public List&lt;JCStatement&gt; defs;
3150         public JCExpression expr;
3151         /**true if a expr should be run through Gen.genCond:*/
3152         public boolean needsCond;
3153         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
3154             this.defs = defs;
3155             this.expr = expr;
3156         }
3157         @Override
3158         public void accept(Visitor v) { v.visitLetExpr(this); }
3159 
3160         @DefinedBy(Api.COMPILER_TREE)
3161         public Kind getKind() {
3162             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3163         }
3164         @Override @DefinedBy(Api.COMPILER_TREE)
3165         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3166             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3167         }
3168         @Override
3169         public Tag getTag() {
3170             return LETEXPR;
3171         }
3172     }
3173 
3174     /** An interface for tree factories
3175      */
3176     public interface Factory {
3177         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3178         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3179                                   JCExpression pid);
3180         JCImport Import(JCTree qualid, boolean staticImport);
3181         JCClassDecl ClassDef(JCModifiers mods,
3182                           Name name,
3183                           List&lt;JCTypeParameter&gt; typarams,
3184                           JCExpression extending,
3185                           List&lt;JCExpression&gt; implementing,
3186                           List&lt;JCTree&gt; defs);
3187         JCMethodDecl MethodDef(JCModifiers mods,
3188                             Name name,
3189                             JCExpression restype,
3190                             List&lt;JCTypeParameter&gt; typarams,
3191                             JCVariableDecl recvparam,
3192                             List&lt;JCVariableDecl&gt; params,
3193                             List&lt;JCExpression&gt; thrown,
3194                             JCBlock body,
3195                             JCExpression defaultValue);
3196         JCVariableDecl VarDef(JCModifiers mods,
3197                       Name name,
3198                       JCExpression vartype,
3199                       JCExpression init);
3200         JCSkip Skip();
3201         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3202         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3203         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3204         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3205                         JCExpression cond,
3206                         List&lt;JCExpressionStatement&gt; step,
3207                         JCStatement body);
3208         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3209         JCLabeledStatement Labelled(Name label, JCStatement body);
3210         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3211         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3212         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,
3213                     List&lt;JCStatement&gt; stats, JCTree body);
3214         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3215         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3216         JCTry Try(List&lt;JCTree&gt; resources,
3217                   JCBlock body,
3218                   List&lt;JCCatch&gt; catchers,
3219                   JCBlock finalizer);
3220         JCCatch Catch(JCVariableDecl param, JCBlock body);
3221         JCConditional Conditional(JCExpression cond,
3222                                 JCExpression thenpart,
3223                                 JCExpression elsepart);
3224         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3225         JCExpressionStatement Exec(JCExpression expr);
3226         JCBreak Break(Name label);
3227         JCYield Yield(JCExpression value);
3228         JCContinue Continue(Name label);
3229         JCReturn Return(JCExpression expr);
3230         JCThrow Throw(JCExpression expr);
3231         JCAssert Assert(JCExpression cond, JCExpression detail);
3232         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3233                     JCExpression fn,
3234                     List&lt;JCExpression&gt; args);
3235         JCNewClass NewClass(JCExpression encl,
3236                           List&lt;JCExpression&gt; typeargs,
3237                           JCExpression clazz,
3238                           List&lt;JCExpression&gt; args,
3239                           JCClassDecl def);
3240         JCNewArray NewArray(JCExpression elemtype,
3241                           List&lt;JCExpression&gt; dims,
3242                           List&lt;JCExpression&gt; elems);
3243         JCParens Parens(JCExpression expr);
3244         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3245         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3246         JCUnary Unary(Tag opcode, JCExpression arg);
3247         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3248         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3249         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3250         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3251         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3252         JCFieldAccess Select(JCExpression selected, Name selector);
3253         JCIdent Ident(Name idname);
3254         JCLiteral Literal(TypeTag tag, Object value);
3255         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3256         JCArrayTypeTree TypeArray(JCExpression elemtype);
3257         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3258         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3259         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3260         TypeBoundKind TypeBoundKind(BoundKind kind);
3261         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3262         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3263         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3264         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3265         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3266         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3267         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3268         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3269         JCUses Uses(JCExpression qualId);
3270         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
3271     }
3272 
3273     /** A generic visitor class for trees.
3274      */
3275     public static abstract class Visitor {
3276         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3277         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3278         public void visitImport(JCImport that)               { visitTree(that); }
3279         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3280         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3281         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3282         public void visitSkip(JCSkip that)                   { visitTree(that); }
3283         public void visitBlock(JCBlock that)                 { visitTree(that); }
3284         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3285         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3286         public void visitWithField(JCWithField that)         { visitTree(that); }
3287         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3288         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3289         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3290         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3291         public void visitCase(JCCase that)                   { visitTree(that); }
3292         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3293         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3294         public void visitTry(JCTry that)                     { visitTree(that); }
3295         public void visitCatch(JCCatch that)                 { visitTree(that); }
3296         public void visitConditional(JCConditional that)     { visitTree(that); }
3297         public void visitIf(JCIf that)                       { visitTree(that); }
3298         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3299         public void visitBreak(JCBreak that)                 { visitTree(that); }
3300         public void visitYield(JCYield that)                 { visitTree(that); }
3301         public void visitContinue(JCContinue that)           { visitTree(that); }
3302         public void visitReturn(JCReturn that)               { visitTree(that); }
3303         public void visitThrow(JCThrow that)                 { visitTree(that); }
3304         public void visitAssert(JCAssert that)               { visitTree(that); }
3305         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3306         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3307         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3308         public void visitLambda(JCLambda that)               { visitTree(that); }
3309         public void visitParens(JCParens that)               { visitTree(that); }
3310         public void visitAssign(JCAssign that)               { visitTree(that); }
3311         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3312         public void visitUnary(JCUnary that)                 { visitTree(that); }
3313         public void visitBinary(JCBinary that)               { visitTree(that); }
3314         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3315         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3316         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3317         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3318         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3319         public void visitReference(JCMemberReference that)   { visitTree(that); }
3320         public void visitIdent(JCIdent that)                 { visitTree(that); }
3321         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3322         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3323         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3324         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3325         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3326         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3327         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3328         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3329         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3330         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3331         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3332         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3333         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3334         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3335         public void visitExports(JCExports that)             { visitTree(that); }
3336         public void visitOpens(JCOpens that)                 { visitTree(that); }
3337         public void visitProvides(JCProvides that)           { visitTree(that); }
3338         public void visitRequires(JCRequires that)           { visitTree(that); }
3339         public void visitUses(JCUses that)                   { visitTree(that); }
3340         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3341 
3342         public void visitTree(JCTree that)                   { Assert.error(); }
3343     }
3344 
3345 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;
  32 import java.util.HashMap;
  33 import java.util.Map;
  34 import java.util.Set;
  35 import java.util.concurrent.Callable;
  36 import java.util.function.Supplier;
  37 
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ElementVisitor;
  41 import javax.lang.model.element.ExecutableElement;
  42 import javax.lang.model.element.Modifier;
  43 import javax.lang.model.element.ModuleElement;
  44 import javax.lang.model.element.NestingKind;
  45 import javax.lang.model.element.PackageElement;
  46 import javax.lang.model.element.RecordComponentElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.element.TypeParameterElement;
  49 import javax.lang.model.element.VariableElement;
  50 import javax.tools.JavaFileManager;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.tools.javac.code.Kinds.Kind;
  54 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Attr;
  57 import com.sun.tools.javac.comp.AttrContext;
  58 import com.sun.tools.javac.comp.Env;
  59 import com.sun.tools.javac.jvm.*;
  60 import com.sun.tools.javac.jvm.PoolConstant;
  61 import com.sun.tools.javac.tree.JCTree;
  62 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
  63 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  64 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  65 import com.sun.tools.javac.tree.JCTree.Tag;
  66 import com.sun.tools.javac.util.*;
  67 import com.sun.tools.javac.util.DefinedBy.Api;
  68 import com.sun.tools.javac.util.List;
  69 import com.sun.tools.javac.util.Name;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Kinds.*;
  73 import static com.sun.tools.javac.code.Kinds.Kind.*;
  74 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  75 import com.sun.tools.javac.code.Scope.WriteableScope;
  76 import static com.sun.tools.javac.code.TypeTag.CLASS;
  77 import static com.sun.tools.javac.code.TypeTag.FORALL;
  78 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  79 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  80 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  81 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  82 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  83 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  84 
  85 /** Root class for Java symbols. It contains subclasses
  86  *  for specific sorts of symbols, such as variables, methods and operators,
  87  *  types, packages. Each subclass is represented as a static inner class
  88  *  inside Symbol.
  89  *
  90  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  91  *  If you write code that depends on this, you do so at your own risk.
  92  *  This code and its internal interfaces are subject to change or
  93  *  deletion without notice.&lt;/b&gt;
  94  */
  95 public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {
  96 
  97     /** The kind of this symbol.
  98      *  @see Kinds
  99      */
 100     public Kind kind;
 101 
 102     /** The flags of this symbol.
 103      */
 104     public long flags_field;
 105 
 106     /** An accessor method for the flags of this symbol.
 107      *  Flags of class symbols should be accessed through the accessor
 108      *  method to make sure that the class symbol is loaded.
 109      */
 110     public long flags() { return flags_field; }
 111 
 112     /** The name of this symbol in Utf8 representation.
 113      */
 114     public Name name;
 115 
 116     /** The type of this symbol.
 117      */
 118     public Type type;
 119 
 120     /** The owner of this symbol.
 121      */
 122     public Symbol owner;
 123 
 124     /** The completer of this symbol.
 125      * This should never equal null (NULL_COMPLETER should be used instead).
 126      */
 127     public Completer completer;
 128 
 129     /** A cache for the type erasure of this symbol.
 130      */
 131     public Type erasure_field;
 132 
 133     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;annotations&quot;&gt;
 134 
 135     /** The attributes of this symbol are contained in this
 136      * SymbolMetadata. The SymbolMetadata instance is NOT immutable.
 137      */
 138     protected SymbolMetadata metadata;
 139 
 140 
 141     /** An accessor method for the attributes of this symbol.
 142      *  Attributes of class symbols should be accessed through the accessor
 143      *  method to make sure that the class symbol is loaded.
 144      */
 145     public List&lt;Attribute.Compound&gt; getRawAttributes() {
 146         return (metadata == null)
 147                 ? List.nil()
 148                 : metadata.getDeclarationAttributes();
 149     }
 150 
 151     /** An accessor method for the type attributes of this symbol.
 152      *  Attributes of class symbols should be accessed through the accessor
 153      *  method to make sure that the class symbol is loaded.
 154      */
 155     public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
 156         return (metadata == null)
 157                 ? List.nil()
 158                 : metadata.getTypeAttributes();
 159     }
 160 
 161     /** Fetch a particular annotation from a symbol. */
 162     public Attribute.Compound attribute(Symbol anno) {
 163         for (Attribute.Compound a : getRawAttributes()) {
 164             if (a.type.tsym == anno) return a;
 165         }
 166         return null;
 167     }
 168 
 169     public boolean annotationsPendingCompletion() {
 170         return metadata == null ? false : metadata.pendingCompletion();
 171     }
 172 
 173     public void appendAttributes(List&lt;Attribute.Compound&gt; l) {
 174         if (l.nonEmpty()) {
 175             initedMetadata().append(l);
 176         }
 177     }
 178 
 179     public void appendClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 180         if (l.nonEmpty()) {
 181             initedMetadata().appendClassInitTypeAttributes(l);
 182         }
 183     }
 184 
 185     public void appendInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 186         if (l.nonEmpty()) {
 187             initedMetadata().appendInitTypeAttributes(l);
 188         }
 189     }
 190 
 191     public void appendUniqueTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 192         if (l.nonEmpty()) {
 193             initedMetadata().appendUniqueTypes(l);
 194         }
 195     }
 196 
 197     public List&lt;Attribute.TypeCompound&gt; getClassInitTypeAttributes() {
 198         return (metadata == null)
 199                 ? List.nil()
 200                 : metadata.getClassInitTypeAttributes();
 201     }
 202 
 203     public List&lt;Attribute.TypeCompound&gt; getInitTypeAttributes() {
 204         return (metadata == null)
 205                 ? List.nil()
 206                 : metadata.getInitTypeAttributes();
 207     }
 208 
 209     public void setInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 210         initedMetadata().setInitTypeAttributes(l);
 211     }
 212 
 213     public void setClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 214         initedMetadata().setClassInitTypeAttributes(l);
 215     }
 216 
 217     public List&lt;Attribute.Compound&gt; getDeclarationAttributes() {
 218         return (metadata == null)
 219                 ? List.nil()
 220                 : metadata.getDeclarationAttributes();
 221     }
 222 
 223     public boolean hasAnnotations() {
 224         return (metadata != null &amp;&amp; !metadata.isEmpty());
 225     }
 226 
 227     public boolean hasTypeAnnotations() {
 228         return (metadata != null &amp;&amp; !metadata.isTypesEmpty());
 229     }
 230 
 231     public boolean isCompleted() {
 232         return completer.isTerminal();
 233     }
 234 
 235     public void prependAttributes(List&lt;Attribute.Compound&gt; l) {
 236         if (l.nonEmpty()) {
 237             initedMetadata().prepend(l);
 238         }
 239     }
 240 
 241     public void resetAnnotations() {
 242         initedMetadata().reset();
 243     }
 244 
 245     public void setAttributes(Symbol other) {
 246         if (metadata != null || other.metadata != null) {
 247             initedMetadata().setAttributes(other.metadata);
 248         }
 249     }
 250 
 251     public void setDeclarationAttributes(List&lt;Attribute.Compound&gt; a) {
 252         if (metadata != null || a.nonEmpty()) {
 253             initedMetadata().setDeclarationAttributes(a);
 254         }
 255     }
 256 
 257     public void setTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
 258         if (metadata != null || a.nonEmpty()) {
 259             if (metadata == null)
 260                 metadata = new SymbolMetadata(this);
 261             metadata.setTypeAttributes(a);
 262         }
 263     }
 264 
 265     private SymbolMetadata initedMetadata() {
 266         if (metadata == null)
 267             metadata = new SymbolMetadata(this);
 268         return metadata;
 269     }
 270 
 271     /** This method is intended for debugging only. */
 272     public SymbolMetadata getMetadata() {
 273         return metadata;
 274     }
 275 
 276     // &lt;/editor-fold&gt;
 277 
 278     /** Construct a symbol with given kind, flags, name, type and owner.
 279      */
 280     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 281         this.kind = kind;
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
<a name="1" id="anc1"></a><span class="line-removed"> 302     public boolean isProjectedNullable() {</span>
<span class="line-removed"> 303         return false;</span>
<span class="line-removed"> 304     }</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     public ClassSymbol nullFreeTypeSymbol() {</span>
<span class="line-removed"> 307         return this.type.hasTag(CLASS) &amp;&amp; ((this.flags() &amp; VALUE) != 0) ? (ClassSymbol) this : null;</span>
<span class="line-removed"> 308     }</span>
<span class="line-removed"> 309 </span>
 310     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 311         return v.visitSymbol(this, p);
 312     }
 313 
 314     /** The Java source which this symbol represents.
 315      *  A description of this symbol; overrides Object.
 316      */
 317     public String toString() {
 318         return name.toString();
 319     }
 320 
 321     /** A Java source description of the location of this symbol; used for
 322      *  error reporting.
 323      *
 324      * @return null if the symbol is a package or a toplevel class defined in
 325      * the default package; otherwise, the owner symbol is returned
 326      */
 327     public Symbol location() {
 328         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 329                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
 330                                    owner.kind != PCK &amp;&amp;
 331                                    owner.kind != TYP)) {
 332             return null;
 333         }
 334         return owner;
 335     }
 336 
 337     public Symbol location(Type site, Types types) {
 338         if (owner.name == null || owner.name.isEmpty()) {
 339             return location();
 340         }
 341         if (owner.type.hasTag(CLASS)) {
 342             Type ownertype = types.asOuterSuper(site, owner);
 343             if (ownertype != null) return ownertype.tsym;
 344         }
 345         return owner;
 346     }
 347 
 348     public Symbol baseSymbol() {
 349         return this;
 350     }
 351 
 352     /** The symbol&#39;s erased type.
 353      */
 354     public Type erasure(Types types) {
 355         if (erasure_field == null)
 356             erasure_field = types.erasure(type);
 357         return erasure_field;
 358     }
 359 
 360     /** The external type of a symbol. This is the symbol&#39;s erased type
 361      *  except for constructors of inner classes which get the enclosing
 362      *  instance class added as first argument.
 363      */
 364     public Type externalType(Types types) {
 365         Type t = erasure(types);
 366         if (name == name.table.names.init &amp;&amp; owner.hasOuterInstance()) {
 367             Type outerThisType = types.erasure(owner.type.getEnclosingType());
 368             return new MethodType(t.getParameterTypes().prepend(outerThisType),
 369                                   t.getReturnType(),
 370                                   t.getThrownTypes(),
 371                                   t.tsym);
 372         } else {
 373             return t;
 374         }
 375     }
 376 
 377     public boolean isDeprecated() {
 378         return (flags_field &amp; DEPRECATED) != 0;
 379     }
 380 
 381     public boolean hasDeprecatedAnnotation() {
 382         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 383     }
 384 
 385     public boolean isDeprecatedForRemoval() {
 386         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 387     }
 388 
 389     public boolean isPreviewApi() {
 390         return (flags_field &amp; PREVIEW_API) != 0;
 391     }
 392 
 393     public boolean isDeprecatableViaAnnotation() {
 394         switch (getKind()) {
 395             case LOCAL_VARIABLE:
 396             case PACKAGE:
 397             case PARAMETER:
 398             case RESOURCE_VARIABLE:
 399             case EXCEPTION_PARAMETER:
 400                 return false;
 401             default:
 402                 return true;
 403         }
 404     }
 405 
 406     public boolean isStatic() {
 407         return
 408             (flags() &amp; STATIC) != 0 ||
 409             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 410              name != name.table.names._this;
 411     }
 412 
 413     public boolean isInterface() {
 414         return (flags() &amp; INTERFACE) != 0;
 415     }
 416 
 417     public boolean isAbstract() {
 418         return (flags_field &amp; ABSTRACT) != 0;
 419     }
 420 
 421     public boolean isPrivate() {
 422         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 423     }
 424 
 425     public boolean isValue() {
 426         return (flags() &amp; VALUE) != 0;
 427     }
 428 
<a name="2" id="anc2"></a>






















 429     public boolean isPublic() {
 430         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 431     }
 432 
 433     public boolean isEnum() {
 434         return (flags() &amp; ENUM) != 0;
 435     }
 436 
 437     public boolean isFinal() {
 438         return (flags_field &amp; FINAL) != 0;
 439     }
 440 
 441    /** Is this symbol declared (directly or indirectly) local
 442      *  to a method or variable initializer?
 443      *  Also includes fields of inner classes which are in
 444      *  turn local to a method or variable initializer.
 445      */
 446     public boolean isLocal() {
 447         return
 448             (owner.kind.matches(KindSelector.VAL_MTH) ||
 449              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 450     }
 451 
 452     /** Has this symbol an empty name? This includes anonymous
 453      *  inner classes.
 454      */
 455     public boolean isAnonymous() {
 456         return name.isEmpty();
 457     }
 458 
 459     /** Is this symbol a constructor?
 460      */
 461     public boolean isConstructor() {
 462         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;
 463     }
 464 
 465     /** Is this symbol a value factory?
 466      */
 467     public boolean isValueFactory() {
 468         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));
 469     }
 470 
 471     public boolean isDynamic() {
 472         return false;
 473     }
 474 
 475     /** The fully qualified name of this symbol.
 476      *  This is the same as the symbol&#39;s name except for class symbols,
 477      *  which are handled separately.
 478      */
 479     public Name getQualifiedName() {
 480         return name;
 481     }
 482 
 483     /** The fully qualified name of this symbol after converting to flat
 484      *  representation. This is the same as the symbol&#39;s name except for
 485      *  class symbols, which are handled separately.
 486      */
 487     public Name flatName() {
 488         return getQualifiedName();
 489     }
 490 
 491     /** If this is a class or package, its members, otherwise null.
 492      */
 493     public WriteableScope members() {
 494         return null;
 495     }
 496 
 497     /** A class is an inner class if it it has an enclosing instance class.
 498      */
 499     public boolean isInner() {
 500         return kind == TYP &amp;&amp; type.getEnclosingType().hasTag(CLASS);
 501     }
 502 
 503     /** An inner class has an outer instance if it is not an interface
 504      *  it has an enclosing instance class which might be referenced from the class.
 505      *  Nested classes can see instance members of their enclosing class.
 506      *  Their constructors carry an additional this$n parameter, inserted
 507      *  implicitly by the compiler.
 508      *
 509      *  @see #isInner
 510      */
 511     public boolean hasOuterInstance() {
 512         return
 513             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 514     }
 515 
 516     /** The closest enclosing class of this symbol&#39;s declaration.
 517      *  Warning: this (misnamed) method returns the receiver itself
 518      *  when the receiver is a class (as opposed to its enclosing
 519      *  class as one may be misled to believe.)
 520      */
 521     public ClassSymbol enclClass() {
 522         Symbol c = this;
 523         while (c != null &amp;&amp;
 524                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 525             c = c.owner;
 526         }
 527         return (ClassSymbol)c;
 528     }
 529 
 530     /** The outermost class which indirectly owns this symbol.
<a name="3" id="anc3"></a>

 531      */
 532     public ClassSymbol outermostClass() {
 533         Symbol sym = this;
 534         Symbol prev = null;
 535         while (sym.kind != PCK) {
 536             prev = sym;
 537             sym = sym.owner;
 538         }
<a name="4" id="anc4"></a><span class="line-modified"> 539         return (ClassSymbol) prev;</span>
 540     }
 541 
 542     /** The package which indirectly owns this symbol.
 543      */
 544     public PackageSymbol packge() {
 545         Symbol sym = this;
 546         while (sym.kind != PCK) {
 547             sym = sym.owner;
 548         }
 549         return (PackageSymbol) sym;
 550     }
 551 
 552     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 553      */
 554     public boolean isSubClass(Symbol base, Types types) {
 555         throw new AssertionError(&quot;isSubClass &quot; + this);
 556     }
 557 
 558     /** Fully check membership: hierarchy, protection, and hiding.
 559      *  Does not exclude methods not inherited due to overriding.
 560      */
 561     public boolean isMemberOf(TypeSymbol clazz, Types types) {
 562         return
 563             owner == clazz ||
 564             clazz.isSubClass(owner, types) &amp;&amp;
 565             isInheritedIn(clazz, types) &amp;&amp;
 566             !hiddenIn((ClassSymbol)clazz, types);
 567     }
 568 
 569     /** Is this symbol the same as or enclosed by the given class? */
 570     public boolean isEnclosedBy(ClassSymbol clazz) {
 571         for (Symbol sym = this; sym.kind != PCK; sym = sym.owner)
 572             if (sym == clazz) return true;
 573         return false;
 574     }
 575 
 576     private boolean hiddenIn(ClassSymbol clazz, Types types) {
 577         Symbol sym = hiddenInInternal(clazz, types);
 578         Assert.check(sym != null, &quot;the result of hiddenInInternal() can&#39;t be null&quot;);
 579         /* If we find the current symbol then there is no symbol hiding it
 580          */
 581         return sym != this;
 582     }
 583 
 584     /** This method looks in the supertypes graph that has the current class as the
 585      * initial node, till it finds the current symbol or another symbol that hides it.
 586      * If the current class has more than one supertype (extends one class and
 587      * implements one or more interfaces) then null can be returned, meaning that
 588      * a wrong path in the supertypes graph was selected. Null can only be returned
 589      * as a temporary value, as a result of the recursive call.
 590      */
 591     private Symbol hiddenInInternal(ClassSymbol currentClass, Types types) {
 592         if (currentClass == owner) {
 593             return this;
 594         }
 595         for (Symbol sym : currentClass.members().getSymbolsByName(name)) {
 596             if (sym.kind == kind &amp;&amp;
 597                     (kind != MTH ||
 598                     (sym.flags() &amp; STATIC) != 0 &amp;&amp;
 599                     types.isSubSignature(sym.type, type))) {
 600                 return sym;
 601             }
 602         }
 603         Symbol hiddenSym = null;
 604         for (Type st : types.interfaces(currentClass.type)
 605                 .prepend(types.supertype(currentClass.type))) {
 606             if (st != null &amp;&amp; (st.hasTag(CLASS))) {
 607                 Symbol sym = hiddenInInternal((ClassSymbol)st.tsym, types);
 608                 if (sym == this) {
 609                     return this;
 610                 } else if (sym != null) {
 611                     hiddenSym = sym;
 612                 }
 613             }
 614         }
 615         return hiddenSym;
 616     }
 617 
 618     /** Is this symbol accessible in a given class?
 619      *  PRE: If symbol&#39;s owner is a interface,
 620      *       it is already assumed that the interface is a superinterface
 621      *       the given class.
 622      *  @param clazz  The class for which we want to establish membership.
 623      *                This must be a subclass of the member&#39;s owner.
 624      */
 625     public final boolean isAccessibleIn(Symbol clazz, Types types) {
 626         switch ((int)(flags_field &amp; Flags.AccessFlags)) {
 627         default: // error recovery
 628         case PUBLIC:
 629             return true;
 630         case PRIVATE:
 631             return this.owner == clazz;
 632         case PROTECTED:
 633             // we model interfaces as extending Object
 634             return (clazz.flags() &amp; INTERFACE) == 0;
 635         case 0:
 636             PackageSymbol thisPackage = this.packge();
 637             for (Symbol sup = clazz;
 638                  sup != null &amp;&amp; sup != this.owner;
 639                  sup = types.supertype(sup.type).tsym) {
 640                 while (sup.type.hasTag(TYPEVAR))
 641                     sup = sup.type.getUpperBound().tsym;
 642                 if (sup.type.isErroneous())
 643                     return true; // error recovery
 644                 if ((sup.flags() &amp; COMPOUND) != 0)
 645                     continue;
 646                 if (sup.packge() != thisPackage)
 647                     return false;
 648             }
 649             return (clazz.flags() &amp; INTERFACE) == 0;
 650         }
 651     }
 652 
 653     /** Is this symbol inherited into a given class?
 654      *  PRE: If symbol&#39;s owner is a interface,
 655      *       it is already assumed that the interface is a superinterface
 656      *       of the given class.
 657      *  @param clazz  The class for which we want to establish membership.
 658      *                This must be a subclass of the member&#39;s owner.
 659      */
 660     public boolean isInheritedIn(Symbol clazz, Types types) {
 661         return isAccessibleIn(clazz, types);
 662     }
 663 
 664     /** The (variable or method) symbol seen as a member of given
 665      *  class type`site&#39; (this might change the symbol&#39;s type).
 666      *  This is used exclusively for producing diagnostics.
 667      */
 668     public Symbol asMemberOf(Type site, Types types) {
 669         throw new AssertionError();
 670     }
 671 
 672     /** Does this method symbol override `other&#39; symbol, when both are seen as
 673      *  members of class `origin&#39;?  It is assumed that _other is a member
 674      *  of origin.
 675      *
 676      *  It is assumed that both symbols have the same name.  The static
 677      *  modifier is ignored for this test.
 678      *
 679      *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
 680      */
 681     public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
 682         return false;
 683     }
 684 
 685     /** Complete the elaboration of this symbol&#39;s definition.
 686      */
 687     public void complete() throws CompletionFailure {
 688         if (completer != Completer.NULL_COMPLETER) {
 689             Completer c = completer;
 690             completer = Completer.NULL_COMPLETER;
 691             c.complete(this);
 692         }
 693     }
 694 
 695     public void apiComplete() throws CompletionFailure {
 696         try {
 697             complete();
 698         } catch (CompletionFailure cf) {
 699             cf.dcfh.handleAPICompletionFailure(cf);
 700         }
 701     }
 702 
 703     /** True if the symbol represents an entity that exists.
 704      */
 705     public boolean exists() {
 706         return true;
 707     }
 708 
 709     @DefinedBy(Api.LANGUAGE_MODEL)
 710     public Type asType() {
 711         return type;
 712     }
 713 
 714     @DefinedBy(Api.LANGUAGE_MODEL)
 715     public Symbol getEnclosingElement() {
 716         return owner;
 717     }
 718 
 719     @DefinedBy(Api.LANGUAGE_MODEL)
 720     public ElementKind getKind() {
 721         return ElementKind.OTHER;       // most unkind
 722     }
 723 
 724     @DefinedBy(Api.LANGUAGE_MODEL)
 725     public Set&lt;Modifier&gt; getModifiers() {
 726         apiComplete();
 727         return Flags.asModifierSet(flags());
 728     }
 729 
 730     @DefinedBy(Api.LANGUAGE_MODEL)
 731     public Name getSimpleName() {
 732         return name;
 733     }
 734 
 735     /**
 736      * This is the implementation for {@code
 737      * javax.lang.model.element.Element.getAnnotationMirrors()}.
 738      */
 739     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 740     public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 741         apiComplete();
 742         return getRawAttributes();
 743     }
 744 
 745 
 746     // TODO: getEnclosedElements should return a javac List, fix in FilteredMemberList
 747     @DefinedBy(Api.LANGUAGE_MODEL)
 748     public java.util.List&lt;Symbol&gt; getEnclosedElements() {
 749         return List.nil();
 750     }
 751 
 752     public List&lt;TypeVariableSymbol&gt; getTypeParameters() {
 753         ListBuffer&lt;TypeVariableSymbol&gt; l = new ListBuffer&lt;&gt;();
 754         for (Type t : type.getTypeArguments()) {
 755             Assert.check(t.tsym.getKind() == ElementKind.TYPE_PARAMETER);
 756             l.append((TypeVariableSymbol)t.tsym);
 757         }
 758         return l.toList();
 759     }
 760 
 761     public static class DelegatedSymbol&lt;T extends Symbol&gt; extends Symbol {
 762         protected T other;
 763         public DelegatedSymbol(T other) {
 764             super(other.kind, other.flags_field, other.name, other.type, other.owner);
 765             this.other = other;
 766         }
 767         public String toString() { return other.toString(); }
 768         public Symbol location() { return other.location(); }
 769         public Symbol location(Type site, Types types) { return other.location(site, types); }
 770         public Symbol baseSymbol() { return other; }
 771         public Type erasure(Types types) { return other.erasure(types); }
 772         public Type externalType(Types types) { return other.externalType(types); }
 773         public boolean isLocal() { return other.isLocal(); }
 774         public boolean isConstructor() { return other.isConstructor(); }
 775         public Name getQualifiedName() { return other.getQualifiedName(); }
 776         public Name flatName() { return other.flatName(); }
 777         public WriteableScope members() { return other.members(); }
 778         public boolean isInner() { return other.isInner(); }
 779         public boolean hasOuterInstance() { return other.hasOuterInstance(); }
 780         public ClassSymbol enclClass() { return other.enclClass(); }
 781         public ClassSymbol outermostClass() { return other.outermostClass(); }
 782         public PackageSymbol packge() { return other.packge(); }
 783         public boolean isSubClass(Symbol base, Types types) { return other.isSubClass(base, types); }
 784         public boolean isMemberOf(TypeSymbol clazz, Types types) { return other.isMemberOf(clazz, types); }
 785         public boolean isEnclosedBy(ClassSymbol clazz) { return other.isEnclosedBy(clazz); }
 786         public boolean isInheritedIn(Symbol clazz, Types types) { return other.isInheritedIn(clazz, types); }
 787         public Symbol asMemberOf(Type site, Types types) { return other.asMemberOf(site, types); }
 788         public void complete() throws CompletionFailure { other.complete(); }
 789 
 790         @DefinedBy(Api.LANGUAGE_MODEL)
 791         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 792             return other.accept(v, p);
 793         }
 794 
 795         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 796             return v.visitSymbol(other, p);
 797         }
 798 
 799         public T getUnderlyingSymbol() {
 800             return other;
 801         }
 802     }
 803 
 804     /** A base class for Symbols representing types.
 805      */
 806     public static abstract class TypeSymbol extends Symbol {
 807         public TypeSymbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 808             super(kind, flags, name, type, owner);
 809         }
 810         /** form a fully qualified name from a name and an owner
 811          */
 812         static public Name formFullName(Name name, Symbol owner) {
 813             if (owner == null) return name;
 814             if ((owner.kind != ERR) &amp;&amp;
 815                 (owner.kind.matches(KindSelector.VAL_MTH) ||
 816                  (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 817                  )) return name;
 818             Name prefix = owner.getQualifiedName();
 819             if (prefix == null || prefix == prefix.table.names.empty)
 820                 return name;
 821             else return prefix.append(&#39;.&#39;, name);
 822         }
 823 
 824         /** form a fully qualified name from a name and an owner, after
 825          *  converting to flat representation
 826          */
 827         static public Name formFlatName(Name name, Symbol owner) {
 828             if (owner == null || owner.kind.matches(KindSelector.VAL_MTH) ||
 829                 (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 830                 ) return name;
 831             char sep = owner.kind == TYP ? &#39;$&#39; : &#39;.&#39;;
 832             Name prefix = owner.flatName();
 833             if (prefix == null || prefix == prefix.table.names.empty)
 834                 return name;
 835             else return prefix.append(sep, name);
 836         }
 837 
 838         /**
 839          * A partial ordering between type symbols that refines the
 840          * class inheritance graph.
 841          *
 842          * Type variables always precede other kinds of symbols.
 843          */
 844         public final boolean precedes(TypeSymbol that, Types types) {
 845             if (this == that)
 846                 return false;
 847             if (type.hasTag(that.type.getTag())) {
 848                 if (type.hasTag(CLASS)) {
 849                     return
 850                         types.rank(that.type) &lt; types.rank(this.type) ||
 851                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 852                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 853                 } else if (type.hasTag(TYPEVAR)) {
 854                     return types.isSubtype(this.type, that.type);
 855                 }
 856             }
 857             return type.hasTag(TYPEVAR);
 858         }
 859 
 860         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 861         public List&lt;Symbol&gt; getEnclosedElements() {
 862             List&lt;Symbol&gt; list = List.nil();
 863             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 864                 return list;
 865             }
 866             apiComplete();
 867             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 868                 sym.apiComplete();
 869                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 870                     list = list.prepend(sym);
 871                 }
 872             }
 873             return list;
 874         }
 875 
 876         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 877             Assert.error(&quot;Only on ClassSymbol&quot;);
 878             return null; //unreachable
 879         }
 880 
 881         public boolean isAnnotationType() { return false; }
 882 
 883         @Override
 884         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 885             return v.visitTypeSymbol(this, p);
 886         }
 887     }
 888 
 889     /**
 890      * Type variables are represented by instances of this class.
 891      */
 892     public static class TypeVariableSymbol
 893             extends TypeSymbol implements TypeParameterElement {
 894 
 895         public TypeVariableSymbol(long flags, Name name, Type type, Symbol owner) {
 896             super(TYP, flags, name, type, owner);
 897         }
 898 
 899         @DefinedBy(Api.LANGUAGE_MODEL)
 900         public ElementKind getKind() {
 901             return ElementKind.TYPE_PARAMETER;
 902         }
 903 
 904         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 905         public Symbol getGenericElement() {
 906             return owner;
 907         }
 908 
 909         @DefinedBy(Api.LANGUAGE_MODEL)
 910         public List&lt;Type&gt; getBounds() {
 911             TypeVar t = (TypeVar)type;
 912             Type bound = t.getUpperBound();
 913             if (!bound.isCompound())
 914                 return List.of(bound);
 915             ClassType ct = (ClassType)bound;
 916             if (!ct.tsym.erasure_field.isInterface()) {
 917                 return ct.interfaces_field.prepend(ct.supertype_field);
 918             } else {
 919                 // No superclass was given in bounds.
 920                 // In this case, supertype is Object, erasure is first interface.
 921                 return ct.interfaces_field;
 922             }
 923         }
 924 
 925         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 926         public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 927             // Declaration annotations on type variables are stored in type attributes
 928             // on the owner of the TypeVariableSymbol
 929             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 930             int index = owner.getTypeParameters().indexOf(this);
 931             List&lt;Attribute.Compound&gt; res = List.nil();
 932             for (Attribute.TypeCompound a : candidates) {
 933                 if (isCurrentSymbolsAnnotation(a, index))
 934                     res = res.prepend(a);
 935             }
 936 
 937             return res.reverse();
 938         }
 939 
 940         // Helper to getAnnotation[s]
 941         @Override
 942         public &lt;A extends Annotation&gt; Attribute.Compound getAttribute(Class&lt;A&gt; annoType) {
 943             String name = annoType.getName();
 944 
 945             // Declaration annotations on type variables are stored in type attributes
 946             // on the owner of the TypeVariableSymbol
 947             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 948             int index = owner.getTypeParameters().indexOf(this);
 949             for (Attribute.TypeCompound anno : candidates)
 950                 if (isCurrentSymbolsAnnotation(anno, index) &amp;&amp;
 951                     name.contentEquals(anno.type.tsym.flatName()))
 952                     return anno;
 953 
 954             return null;
 955         }
 956             //where:
 957             boolean isCurrentSymbolsAnnotation(Attribute.TypeCompound anno, int index) {
 958                 return (anno.position.type == TargetType.CLASS_TYPE_PARAMETER ||
 959                         anno.position.type == TargetType.METHOD_TYPE_PARAMETER) &amp;&amp;
 960                         anno.position.parameter_index == index;
 961             }
 962 
 963 
 964         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 965         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 966             return v.visitTypeParameter(this, p);
 967         }
 968     }
 969     /** A class for module symbols.
 970      */
 971     public static class ModuleSymbol extends TypeSymbol
 972             implements ModuleElement {
 973 
 974         public Name version;
 975         public JavaFileManager.Location sourceLocation;
 976         public JavaFileManager.Location classLocation;
 977         public JavaFileManager.Location patchLocation;
 978         public JavaFileManager.Location patchOutputLocation;
 979 
 980         /** All directives, in natural order. */
 981         public List&lt;com.sun.tools.javac.code.Directive&gt; directives;
 982         public List&lt;com.sun.tools.javac.code.Directive.RequiresDirective&gt; requires;
 983         public List&lt;com.sun.tools.javac.code.Directive.ExportsDirective&gt; exports;
 984         public List&lt;com.sun.tools.javac.code.Directive.OpensDirective&gt; opens;
 985         public List&lt;com.sun.tools.javac.code.Directive.ProvidesDirective&gt; provides;
 986         public List&lt;com.sun.tools.javac.code.Directive.UsesDirective&gt; uses;
 987 
 988         public ClassSymbol module_info;
 989 
 990         public PackageSymbol unnamedPackage;
 991         public Map&lt;Name, PackageSymbol&gt; visiblePackages;
 992         public Set&lt;ModuleSymbol&gt; readModules;
 993         public List&lt;Symbol&gt; enclosedPackages = List.nil();
 994 
 995         public Completer usesProvidesCompleter = Completer.NULL_COMPLETER;
 996         public final Set&lt;ModuleFlags&gt; flags = EnumSet.noneOf(ModuleFlags.class);
 997         public final Set&lt;ModuleResolutionFlags&gt; resolutionFlags = EnumSet.noneOf(ModuleResolutionFlags.class);
 998 
 999         /**
1000          * Create a ModuleSymbol with an associated module-info ClassSymbol.
1001          */
1002         public static ModuleSymbol create(Name name, Name module_info) {
1003             ModuleSymbol msym = new ModuleSymbol(name, null);
1004             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
1005             info.fullname = formFullName(module_info, msym);
1006             info.flatname = info.fullname;
1007             info.members_field = WriteableScope.create(info);
1008             msym.module_info = info;
1009             return msym;
1010         }
1011 
1012         public ModuleSymbol(Name name, Symbol owner) {
1013             super(MDL, 0, name, null, owner);
1014             Assert.checkNonNull(name);
1015             this.type = new ModuleType(this);
1016         }
1017 
1018         @Override
1019         public int poolTag() {
1020             return ClassFile.CONSTANT_Module;
1021         }
1022 
1023         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1024         public Name getSimpleName() {
1025             return Convert.shortName(name);
1026         }
1027 
1028         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1029         public boolean isOpen() {
1030             return flags.contains(ModuleFlags.OPEN);
1031         }
1032 
1033         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1034         public boolean isUnnamed() {
1035             return name.isEmpty() &amp;&amp; owner == null;
1036         }
1037 
1038         @Override
1039         public boolean isDeprecated() {
1040             return hasDeprecatedAnnotation();
1041         }
1042 
1043         public boolean isNoModule() {
1044             return false;
1045         }
1046 
1047         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1048         public ElementKind getKind() {
1049             return ElementKind.MODULE;
1050         }
1051 
1052         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1053         public java.util.List&lt;Directive&gt; getDirectives() {
1054             apiComplete();
1055             completeUsesProvides();
1056             return Collections.unmodifiableList(directives);
1057         }
1058 
1059         public void completeUsesProvides() {
1060             if (usesProvidesCompleter != Completer.NULL_COMPLETER) {
1061                 Completer c = usesProvidesCompleter;
1062                 usesProvidesCompleter = Completer.NULL_COMPLETER;
1063                 c.complete(this);
1064             }
1065         }
1066 
1067         @Override
1068         public ClassSymbol outermostClass() {
1069             return null;
1070         }
1071 
1072         @Override
1073         public String toString() {
1074             // TODO: the following strings should be localized
1075             // Do this with custom anon subtypes in Symtab
1076             String n = (name == null) ? &quot;&lt;unknown&gt;&quot;
1077                     : (name.isEmpty()) ? &quot;&lt;unnamed&gt;&quot;
1078                     : String.valueOf(name);
1079             return n;
1080         }
1081 
1082         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1083         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1084             return v.visitModule(this, p);
1085         }
1086 
1087         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1088         public List&lt;Symbol&gt; getEnclosedElements() {
1089             List&lt;Symbol&gt; list = List.nil();
1090             for (Symbol sym : enclosedPackages) {
1091                 if (sym.members().anyMatch(m -&gt; m.kind == TYP))
1092                     list = list.prepend(sym);
1093             }
1094             return list;
1095         }
1096 
1097         public void reset() {
1098             this.directives = null;
1099             this.requires = null;
1100             this.exports = null;
1101             this.provides = null;
1102             this.uses = null;
1103             this.visiblePackages = null;
1104         }
1105 
1106     }
1107 
1108     public enum ModuleFlags {
1109         OPEN(0x0020),
1110         SYNTHETIC(0x1000),
1111         MANDATED(0x8000);
1112 
1113         public static int value(Set&lt;ModuleFlags&gt; s) {
1114             int v = 0;
1115             for (ModuleFlags f: s)
1116                 v |= f.value;
1117             return v;
1118         }
1119 
1120         private ModuleFlags(int value) {
1121             this.value = value;
1122         }
1123 
1124         public final int value;
1125     }
1126 
1127     public enum ModuleResolutionFlags {
1128         DO_NOT_RESOLVE_BY_DEFAULT(0x0001),
1129         WARN_DEPRECATED(0x0002),
1130         WARN_DEPRECATED_REMOVAL(0x0004),
1131         WARN_INCUBATING(0x0008);
1132 
1133         public static int value(Set&lt;ModuleResolutionFlags&gt; s) {
1134             int v = 0;
1135             for (ModuleResolutionFlags f: s)
1136                 v |= f.value;
1137             return v;
1138         }
1139 
1140         private ModuleResolutionFlags(int value) {
1141             this.value = value;
1142         }
1143 
1144         public final int value;
1145     }
1146 
1147     /** A class for package symbols
1148      */
1149     public static class PackageSymbol extends TypeSymbol
1150         implements PackageElement {
1151 
1152         public WriteableScope members_field;
1153         public Name fullname;
1154         public ClassSymbol package_info; // see bug 6443073
1155         public ModuleSymbol modle;
1156         // the file containing the documentation comments for the package
1157         public JavaFileObject sourcefile;
1158 
1159         public PackageSymbol(Name name, Type type, Symbol owner) {
1160             super(PCK, 0, name, type, owner);
1161             this.members_field = null;
1162             this.fullname = formFullName(name, owner);
1163         }
1164 
1165         public PackageSymbol(Name name, Symbol owner) {
1166             this(name, null, owner);
1167             this.type = new PackageType(this);
1168         }
1169 
1170         public String toString() {
1171             return fullname.toString();
1172         }
1173 
1174         @DefinedBy(Api.LANGUAGE_MODEL)
1175         public Name getQualifiedName() {
1176             return fullname;
1177         }
1178 
1179         @DefinedBy(Api.LANGUAGE_MODEL)
1180         public boolean isUnnamed() {
1181             return name.isEmpty() &amp;&amp; owner != null;
1182         }
1183 
1184         public WriteableScope members() {
1185             complete();
1186             return members_field;
1187         }
1188 
1189         @Override
1190         public int poolTag() {
1191             return ClassFile.CONSTANT_Package;
1192         }
1193 
1194         public long flags() {
1195             complete();
1196             return flags_field;
1197         }
1198 
1199         @Override
1200         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1201             complete();
1202             if (package_info != null) {
1203                 package_info.complete();
1204                 mergeAttributes();
1205             }
1206             return super.getRawAttributes();
1207         }
1208 
1209         private void mergeAttributes() {
1210             if (metadata == null &amp;&amp;
1211                 package_info.metadata != null) {
1212                 metadata = new SymbolMetadata(this);
1213                 metadata.setAttributes(package_info.metadata);
1214             }
1215         }
1216 
1217         /** A package &quot;exists&quot; if a type or package that exists has
1218          *  been seen within it.
1219          */
1220         public boolean exists() {
1221             return (flags_field &amp; EXISTS) != 0;
1222         }
1223 
1224         @DefinedBy(Api.LANGUAGE_MODEL)
1225         public ElementKind getKind() {
1226             return ElementKind.PACKAGE;
1227         }
1228 
1229         @DefinedBy(Api.LANGUAGE_MODEL)
1230         public Symbol getEnclosingElement() {
1231             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1232         }
1233 
1234         @DefinedBy(Api.LANGUAGE_MODEL)
1235         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1236             return v.visitPackage(this, p);
1237         }
1238 
1239         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1240             return v.visitPackageSymbol(this, p);
1241         }
1242 
1243         /**Resets the Symbol into the state good for next round of annotation processing.*/
1244         public void reset() {
1245             metadata = null;
1246         }
1247 
1248     }
1249 
1250     public static class RootPackageSymbol extends PackageSymbol {
1251         public final MissingInfoHandler missingInfoHandler;
1252 
1253         public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {
1254             super(name, owner);
1255             this.missingInfoHandler = missingInfoHandler;
1256         }
1257 
1258     }
1259 
1260     /** A class for class symbols
1261      */
1262     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1263 
1264         /** a scope for all class members; variables, methods and inner classes
1265          *  type parameters are not part of this scope
1266          */
1267         public WriteableScope members_field;
1268 
1269         /** the fully qualified name of the class, i.e. pck.outer.inner.
1270          *  null for anonymous classes
1271          */
1272         public Name fullname;
1273 
1274         /** the fully qualified name of the class after converting to flat
1275          *  representation, i.e. pck.outer$inner,
1276          *  set externally for local and anonymous classes
1277          */
1278         public Name flatname;
1279 
1280         /** the sourcefile where the class came from
1281          */
1282         public JavaFileObject sourcefile;
1283 
1284         /** the classfile from where to load this class
1285          *  this will have extension .class or .java
1286          */
1287         public JavaFileObject classfile;
1288 
1289         /** the list of translated local classes (used for generating
1290          * InnerClasses attribute)
1291          */
1292         public List&lt;ClassSymbol&gt; trans_local;
1293 
1294         /** the annotation metadata attached to this class */
1295         private AnnotationTypeMetadata annotationTypeMetadata;
1296 
1297         /* the list of any of record components, only non empty if the class is a record
1298          * and it has at least one record component
1299          */
1300         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1301 
<a name="5" id="anc5"></a>





1302         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1303             super(TYP, flags, name, type, owner);
1304             this.members_field = null;
1305             this.fullname = formFullName(name, owner);
1306             this.flatname = formFlatName(name, owner);
1307             this.sourcefile = null;
1308             this.classfile = null;
1309             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1310         }
1311 
1312         public ClassSymbol(long flags, Name name, Symbol owner) {
1313             this(
1314                 flags,
1315                 name,
1316                 new ClassType(Type.noType, null, null),
1317                 owner);
1318             this.type.tsym = this;
1319         }
1320 
1321         /** The Java source which this symbol represents.
1322          */
1323         public String toString() {
1324             return className();
1325         }
1326 
1327         public long flags() {
1328             complete();
1329             return flags_field;
1330         }
1331 
1332         public WriteableScope members() {
1333             complete();
1334             return members_field;
1335         }
1336 
1337         @Override
1338         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1339             complete();
1340             return super.getRawAttributes();
1341         }
1342 
1343         @Override
1344         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1345             complete();
1346             return super.getRawTypeAttributes();
1347         }
1348 
1349         public Type erasure(Types types) {
1350             if (erasure_field == null)
1351                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1352                                               List.nil(), this,
1353                                               type.getMetadata());
1354             return erasure_field;
1355         }
1356 
1357         public String className() {
1358             if (name.isEmpty())
1359                 return
1360                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1361 
<a name="6" id="anc6"></a><span class="line-modified">1362                 String s = fullname.toString();</span>
<span class="line-removed">1363                 return isProjectedNullable() ? s + &#39;?&#39; : s;</span>
1364         }
1365 
1366         @DefinedBy(Api.LANGUAGE_MODEL)
1367         public Name getQualifiedName() {
1368             return fullname;
1369         }
1370 
1371         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1372         public List&lt;Symbol&gt; getEnclosedElements() {
1373             List&lt;Symbol&gt; result = super.getEnclosedElements();
1374             if (!recordComponents.isEmpty()) {
1375                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1376                 for (RecordComponent rc : reversed) {
1377                     result = result.prepend(rc);
1378                 }
1379             }
1380             return result;
1381         }
1382 
1383         public Name flatName() {
1384             return flatname;
1385         }
1386 
1387         public boolean isSubClass(Symbol base, Types types) {
1388             if (this == base) {
1389                 return true;
1390             } else if ((base.flags() &amp; INTERFACE) != 0) {
1391                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1392                     for (List&lt;Type&gt; is = types.interfaces(t);
1393                          is.nonEmpty();
1394                          is = is.tail)
1395                         if (is.head.tsym.isSubClass(base, types)) return true;
1396             } else {
1397                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1398                     if (t.tsym == base) return true;
1399             }
1400             return false;
1401         }
1402 
1403         /** Complete the elaboration of this symbol&#39;s definition.
1404          */
1405         public void complete() throws CompletionFailure {
1406             Completer origCompleter = completer;
1407             try {
1408                 super.complete();
1409             } catch (CompletionFailure ex) {
1410                 ex.dcfh.classSymbolCompleteFailed(this, origCompleter);
1411                 // quiet error recovery
1412                 flags_field |= (PUBLIC|STATIC);
1413                 this.type = new ErrorType(this, Type.noType);
1414                 throw ex;
1415             }
1416         }
1417 
1418         @DefinedBy(Api.LANGUAGE_MODEL)
1419         public List&lt;Type&gt; getInterfaces() {
1420             apiComplete();
1421             if (type instanceof ClassType) {
1422                 ClassType t = (ClassType)type;
1423                 if (t.interfaces_field == null) // FIXME: shouldn&#39;t be null
1424                     t.interfaces_field = List.nil();
1425                 if (t.all_interfaces_field != null)
1426                     return Type.getModelTypes(t.all_interfaces_field);
1427                 return t.interfaces_field;
1428             } else {
1429                 return List.nil();
1430             }
1431         }
1432 
1433         @DefinedBy(Api.LANGUAGE_MODEL)
1434         public Type getSuperclass() {
1435             apiComplete();
1436             if (type instanceof ClassType) {
1437                 ClassType t = (ClassType)type;
1438                 if (t.supertype_field == null) // FIXME: shouldn&#39;t be null
1439                     t.supertype_field = Type.noType;
1440                 // An interface has no superclass; its supertype is Object.
1441                 return t.isInterface()
1442                     ? Type.noType
1443                     : t.supertype_field.getModelType();
1444             } else {
1445                 return Type.noType;
1446             }
1447         }
1448 
1449         /**
1450          * Returns the next class to search for inherited annotations or {@code null}
1451          * if the next class can&#39;t be found.
1452          */
1453         private ClassSymbol getSuperClassToSearchForAnnotations() {
1454 
1455             Type sup = getSuperclass();
1456 
1457             if (!sup.hasTag(CLASS) || sup.isErroneous())
1458                 return null;
1459 
1460             return (ClassSymbol) sup.tsym;
1461         }
1462 
1463 
1464         @Override
1465         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1466 
1467             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1468 
1469             return sup == null ? super.getInheritedAnnotations(annoType)
1470                                : sup.getAnnotationsByType(annoType);
1471         }
1472 
1473 
1474         @DefinedBy(Api.LANGUAGE_MODEL)
1475         @SuppressWarnings(&quot;preview&quot;)
1476         public ElementKind getKind() {
1477             apiComplete();
1478             long flags = flags();
1479             if ((flags &amp; ANNOTATION) != 0)
1480                 return ElementKind.ANNOTATION_TYPE;
1481             else if ((flags &amp; INTERFACE) != 0)
1482                 return ElementKind.INTERFACE;
1483             else if ((flags &amp; ENUM) != 0)
1484                 return ElementKind.ENUM;
1485             else if ((flags &amp; RECORD) != 0)
1486                 return ElementKind.RECORD;
1487             else
1488                 return ElementKind.CLASS;
1489         }
1490 
1491         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1492         public Set&lt;Modifier&gt; getModifiers() {
1493             apiComplete();
1494             long flags = flags();
1495             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1496         }
1497 
1498         public RecordComponent getRecordComponent(VarSymbol field) {
1499             for (RecordComponent rc : recordComponents) {
1500                 if (rc.name == field.name) {
1501                     return rc;
1502                 }
1503             }
1504             return null;
1505         }
1506 
1507         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing, List&lt;JCAnnotation&gt; annotations) {
1508             for (RecordComponent rc : recordComponents) {
1509                 if (rc.name == var.name) {
1510                     return rc;
1511                 }
1512             }
1513             RecordComponent rc = null;
1514             if (addIfMissing) {
1515                 recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));
1516             }
1517             return rc;
1518         }
1519 
1520         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1521         @SuppressWarnings(&quot;preview&quot;)
1522         public List&lt;? extends RecordComponent&gt; getRecordComponents() {
1523             return recordComponents;
1524         }
1525 
1526         @DefinedBy(Api.LANGUAGE_MODEL)
1527         public NestingKind getNestingKind() {
1528             apiComplete();
1529             if (owner.kind == PCK)
1530                 return NestingKind.TOP_LEVEL;
1531             else if (name.isEmpty())
1532                 return NestingKind.ANONYMOUS;
1533             else if (owner.kind == MTH)
1534                 return NestingKind.LOCAL;
1535             else
1536                 return NestingKind.MEMBER;
1537         }
1538 
1539         @Override
1540         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1541 
1542             Attribute.Compound attrib = super.getAttribute(annoType);
1543 
1544             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1545             if (attrib != null || !inherited)
1546                 return attrib;
1547 
1548             // Search supertypes
1549             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1550             return superType == null ? null
1551                                      : superType.getAttribute(annoType);
1552         }
1553 
1554         @DefinedBy(Api.LANGUAGE_MODEL)
1555         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1556             return v.visitType(this, p);
1557         }
1558 
1559         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1560             return v.visitClassSymbol(this, p);
1561         }
1562 
1563         public void markAbstractIfNeeded(Types types) {
1564             if (types.enter.getEnv(this) != null &amp;&amp;
1565                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1566                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1567                 if (types.firstUnimplementedAbstract(this) != null)
1568                     // add the ABSTRACT flag to an enum
1569                     flags_field |= ABSTRACT;
1570             }
1571         }
1572 
1573         /**Resets the Symbol into the state good for next round of annotation processing.*/
1574         public void reset() {
1575             kind = TYP;
1576             erasure_field = null;
1577             members_field = null;
1578             flags_field = 0;
1579             if (type instanceof ClassType) {
1580                 ClassType t = (ClassType)type;
1581                 t.setEnclosingType(Type.noType);
1582                 t.rank_field = -1;
1583                 t.typarams_field = null;
1584                 t.allparams_field = null;
1585                 t.supertype_field = null;
1586                 t.interfaces_field = null;
1587                 t.all_interfaces_field = null;
1588             }
1589             clearAnnotationMetadata();
1590         }
1591 
1592         public void clearAnnotationMetadata() {
1593             metadata = null;
1594             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1595         }
1596 
1597         @Override
1598         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1599             return annotationTypeMetadata;
1600         }
1601 
1602         @Override
1603         public boolean isAnnotationType() {
1604             return (flags_field &amp; Flags.ANNOTATION) != 0;
1605         }
1606 
1607         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1608             Assert.checkNonNull(a);
1609             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1610             this.annotationTypeMetadata = a;
1611         }
1612 
1613         public boolean isRecord() {
1614             return (flags_field &amp; RECORD) != 0;
1615         }
<a name="7" id="anc7"></a>






















































1616     }
1617 
1618 
1619     /** A class for variable symbols
1620      */
1621     public static class VarSymbol extends Symbol implements VariableElement {
1622 
1623         /** The variable&#39;s declaration position.
1624          */
1625         public int pos = Position.NOPOS;
1626 
1627         /** The variable&#39;s address. Used for different purposes during
1628          *  flow analysis, translation and code generation.
1629          *  Flow analysis:
1630          *    If this is a blank final or local variable, its sequence number.
1631          *  Translation:
1632          *    If this is a private field, its access number.
1633          *  Code generation:
1634          *    If this is a local variable, its logical slot number.
1635          */
1636         public int adr = -1;
1637 
<a name="8" id="anc8"></a>




1638         /** Construct a variable symbol, given its flags, name, type and owner.
1639          */
1640         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1641             super(VAR, flags, name, type, owner);
1642         }
1643 
1644         @Override
1645         public int poolTag() {
1646             return ClassFile.CONSTANT_Fieldref;
1647         }
1648 
1649         public MethodHandleSymbol asMethodHandle(boolean getter) {
1650             return new MethodHandleSymbol(this, getter);
1651         }
1652 
1653         /** Clone this symbol with new owner.
1654          */
1655         public VarSymbol clone(Symbol newOwner) {
1656             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1657                 @Override
1658                 public Symbol baseSymbol() {
1659                     return VarSymbol.this;
1660                 }
1661 
1662                 @Override
1663                 public Object poolKey(Types types) {
1664                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1665                 }
1666             };
1667             v.pos = pos;
1668             v.adr = adr;
1669             v.data = data;
<a name="9" id="anc9"></a>
1670 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1671             return v;
1672         }
1673 
1674         public String toString() {
1675             return name.toString();
1676         }
1677 
1678         public Symbol asMemberOf(Type site, Types types) {
1679             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1680         }
1681 
1682         @DefinedBy(Api.LANGUAGE_MODEL)
1683         public ElementKind getKind() {
1684             long flags = flags();
1685             if ((flags &amp; PARAMETER) != 0) {
1686                 if (isExceptionParameter())
1687                     return ElementKind.EXCEPTION_PARAMETER;
1688                 else
1689                     return ElementKind.PARAMETER;
1690             } else if ((flags &amp; ENUM) != 0) {
1691                 return ElementKind.ENUM_CONSTANT;
1692             } else if (owner.kind == TYP || owner.kind == ERR) {
1693                 return ElementKind.FIELD;
1694             } else if (isResourceVariable()) {
1695                 return ElementKind.RESOURCE_VARIABLE;
1696             } else if ((flags &amp; MATCH_BINDING) != 0) {
1697                 @SuppressWarnings(&quot;preview&quot;)
1698                 ElementKind kind = ElementKind.BINDING_VARIABLE;
1699                 return kind;
1700             } else {
1701                 return ElementKind.LOCAL_VARIABLE;
1702             }
1703         }
1704 
1705         @DefinedBy(Api.LANGUAGE_MODEL)
1706         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1707             return v.visitVariable(this, p);
1708         }
1709 
1710         @DefinedBy(Api.LANGUAGE_MODEL)
1711         public Object getConstantValue() { // Mirror API
1712             return Constants.decode(getConstValue(), type);
1713         }
1714 
1715         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1716                                       final Attr attr,
1717                                       final JCVariableDecl variable)
1718         {
1719             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1720         }
1721 
<a name="10" id="anc10"></a>











1722         /**
1723          * The variable&#39;s constant value, if this is a constant.
1724          * Before the constant value is evaluated, it points to an
1725          * initializer environment.  If this is not a constant, it can
1726          * be used for other stuff.
1727          */
1728         private Object data;
1729 
1730         public boolean isExceptionParameter() {
1731             return data == ElementKind.EXCEPTION_PARAMETER;
1732         }
1733 
1734         public boolean isResourceVariable() {
1735             return data == ElementKind.RESOURCE_VARIABLE;
1736         }
1737 
1738         public Object getConstValue() {
1739             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1740             if (data == ElementKind.EXCEPTION_PARAMETER ||
1741                 data == ElementKind.RESOURCE_VARIABLE) {
1742                 return null;
1743             } else if (data instanceof Callable&lt;?&gt;) {
1744                 // In this case, this is a final variable, with an as
1745                 // yet unevaluated initializer.
1746                 Callable&lt;?&gt; eval = (Callable&lt;?&gt;)data;
1747                 data = null; // to make sure we don&#39;t evaluate this twice.
1748                 try {
1749                     data = eval.call();
1750                 } catch (Exception ex) {
1751                     throw new AssertionError(ex);
1752                 }
1753             }
1754             return data;
1755         }
1756 
1757         public void setData(Object data) {
1758             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1759             this.data = data;
1760         }
1761 
1762         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1763             return v.visitVarSymbol(this, p);
1764         }
1765     }
1766 
1767     @SuppressWarnings(&quot;preview&quot;)
1768     public static class RecordComponent extends VarSymbol implements RecordComponentElement {
1769         public MethodSymbol accessor;
1770         public JCTree.JCMethodDecl accessorMeth;
1771         private final List&lt;JCAnnotation&gt; originalAnnos;
1772 
1773         /**
1774          * Construct a record component, given its flags, name, type and owner.
1775          */
1776         public RecordComponent(JCVariableDecl fieldDecl, List&lt;JCAnnotation&gt; annotations) {
1777             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);
1778             this.originalAnnos = annotations;
1779         }
1780 
1781         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }
1782 
1783         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1784         @SuppressWarnings(&quot;preview&quot;)
1785         public ElementKind getKind() {
1786             return ElementKind.RECORD_COMPONENT;
1787         }
1788 
1789         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1790         public ExecutableElement getAccessor() {
1791             return accessor;
1792         }
1793 
1794         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1795         @SuppressWarnings(&quot;preview&quot;)
1796         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1797             return v.visitRecordComponent(this, p);
1798         }
1799     }
1800 
1801     public static class ParamSymbol extends VarSymbol {
1802         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {
1803             super(flags, name, type, owner);
1804         }
1805 
1806         @Override
1807         public Name getSimpleName() {
1808             if ((flags_field &amp; NAME_FILLED) == 0) {
1809                 flags_field |= NAME_FILLED;
1810                 Symbol rootPack = this;
1811                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
1812                     rootPack = rootPack.owner;
1813                 }
1814                 if (rootPack != null) {
1815                     Name inferredName =
1816                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);
1817                     if (inferredName != null) {
1818                         this.name = inferredName;
1819                     }
1820                 }
1821             }
1822             return super.getSimpleName();
1823         }
1824 
1825     }
1826 
1827     public static class BindingSymbol extends VarSymbol {
1828 
1829         public BindingSymbol(Name name, Type type, Symbol owner) {
1830             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);
1831         }
1832 
1833         public boolean isAliasFor(BindingSymbol b) {
1834             return aliases().containsAll(b.aliases());
1835         }
1836 
1837         List&lt;BindingSymbol&gt; aliases() {
1838             return List.of(this);
1839         }
1840 
1841         public void preserveBinding() {
1842             flags_field |= Flags.MATCH_BINDING_TO_OUTER;
1843         }
1844 
1845         public boolean isPreserved() {
1846             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;
1847         }
1848     }
1849 
1850     /** A class for method symbols.
1851      */
1852     public static class MethodSymbol extends Symbol implements ExecutableElement {
1853 
1854         /** The code of the method. */
1855         public Code code = null;
1856 
1857         /** The extra (synthetic/mandated) parameters of the method. */
1858         public List&lt;VarSymbol&gt; extraParams = List.nil();
1859 
1860         /** The captured local variables in an anonymous class */
1861         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1862 
1863         /** The parameters of the method. */
1864         public List&lt;VarSymbol&gt; params = null;
1865 
1866         /** For an annotation type element, its default value if any.
1867          *  The value is null if none appeared in the method
1868          *  declaration.
1869          */
1870         public Attribute defaultValue = null;
1871 
<a name="11" id="anc11"></a>




1872         /** Construct a method symbol, given its flags, name, type and owner.
1873          */
1874         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1875             super(MTH, flags, name, type, owner);
1876             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1877         }
1878 
1879         /** Clone this symbol with new owner.
1880          */
1881         public MethodSymbol clone(Symbol newOwner) {
1882             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1883                 @Override
1884                 public Symbol baseSymbol() {
1885                     return MethodSymbol.this;
1886                 }
1887 
1888                 @Override
1889                 public Object poolKey(Types types) {
1890                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1891                 }
1892             };
1893             m.code = code;
<a name="12" id="anc12"></a>
1894             return m;
1895         }
1896 
1897         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1898         public Set&lt;Modifier&gt; getModifiers() {
1899             long flags = flags();
1900             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1901         }
1902 
1903         /** The Java source which this symbol represents.
1904          */
1905         public String toString() {
1906             if ((flags() &amp; BLOCK) != 0) {
1907                 return owner.name.toString();
1908             } else {
1909                 String s = (name == name.table.names.init)
1910                     ? owner.name.toString()
1911                     : name.toString();
1912                 if (type != null) {
1913                     if (type.hasTag(FORALL))
1914                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
1915                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
1916                 }
1917                 return s;
1918             }
1919         }
1920 
1921         @Override
1922         public int poolTag() {
1923             return owner.isInterface() ?
1924                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;
1925         }
1926 
1927         public boolean isHandle() {
1928             return false;
1929         }
1930 
1931 
1932         public MethodHandleSymbol asHandle() {
1933             return new MethodHandleSymbol(this);
1934         }
1935 
1936         /** find a symbol that this (proxy method) symbol implements.
1937          *  @param    c       The class whose members are searched for
1938          *                    implementations
1939          */
1940         public Symbol implemented(TypeSymbol c, Types types) {
1941             Symbol impl = null;
1942             for (List&lt;Type&gt; is = types.interfaces(c.type);
1943                  impl == null &amp;&amp; is.nonEmpty();
1944                  is = is.tail) {
1945                 TypeSymbol i = is.head.tsym;
1946                 impl = implementedIn(i, types);
1947                 if (impl == null)
1948                     impl = implemented(i, types);
1949             }
1950             return impl;
1951         }
1952 
1953         public Symbol implementedIn(TypeSymbol c, Types types) {
1954             Symbol impl = null;
1955             for (Symbol sym : c.members().getSymbolsByName(name)) {
1956                 if (this.overrides(sym, (TypeSymbol)owner, types, true) &amp;&amp;
1957                     // FIXME: I suspect the following requires a
1958                     // subst() for a parametric return type.
1959                     types.isSameType(type.getReturnType(),
1960                                      types.memberType(owner.type, sym).getReturnType())) {
1961                     impl = sym;
1962                 }
1963             }
1964             return impl;
1965         }
1966 
1967         /** Will the erasure of this method be considered by the VM to
1968          *  override the erasure of the other when seen from class `origin&#39;?
1969          */
1970         public boolean binaryOverrides(Symbol _other, TypeSymbol origin, Types types) {
1971             if (isConstructor() || _other.kind != MTH) return false;
1972 
1973             if (this == _other) return true;
1974             MethodSymbol other = (MethodSymbol)_other;
1975 
1976             // check for a direct implementation
1977             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
1978                 types.asSuper(owner.type, other.owner) != null &amp;&amp;
1979                 types.isSameType(erasure(types), other.erasure(types)))
1980                 return true;
1981 
1982             // check for an inherited implementation
1983             return
1984                 (flags() &amp; ABSTRACT) == 0 &amp;&amp;
1985                 other.isOverridableIn(origin) &amp;&amp;
1986                 this.isMemberOf(origin, types) &amp;&amp;
1987                 types.isSameType(erasure(types), other.erasure(types));
1988         }
1989 
1990         /** The implementation of this (abstract) symbol in class origin,
1991          *  from the VM&#39;s point of view, null if method does not have an
1992          *  implementation in class.
1993          *  @param origin   The class of which the implementation is a member.
1994          */
1995         public MethodSymbol binaryImplementation(ClassSymbol origin, Types types) {
1996             for (TypeSymbol c = origin; c != null; c = types.supertype(c.type).tsym) {
1997                 for (Symbol sym : c.members().getSymbolsByName(name)) {
1998                     if (sym.kind == MTH &amp;&amp;
1999                         ((MethodSymbol)sym).binaryOverrides(this, origin, types))
2000                         return (MethodSymbol)sym;
2001                 }
2002             }
2003             return null;
2004         }
2005 
2006         /** Does this symbol override `other&#39; symbol, when both are seen as
2007          *  members of class `origin&#39;?  It is assumed that _other is a member
2008          *  of origin.
2009          *
2010          *  It is assumed that both symbols have the same name.  The static
2011          *  modifier is ignored for this test.
2012          *
2013          *  A quirk in the works is that if the receiver is a method symbol for
2014          *  an inherited abstract method we answer false summarily all else being
2015          *  immaterial. Abstract &quot;own&quot; methods (i.e `this&#39; is a direct member of
2016          *  origin) don&#39;t get rejected as summarily and are put to test against the
2017          *  suitable criteria.
2018          *
2019          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2020          */
2021         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
2022             return overrides(_other, origin, types, checkResult, true);
2023         }
2024 
2025         /** Does this symbol override `other&#39; symbol, when both are seen as
2026          *  members of class `origin&#39;?  It is assumed that _other is a member
2027          *  of origin.
2028          *
2029          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2030          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2031          *  is false.
2032          *
2033          *  It is assumed that both symbols have the same name.  The static
2034          *  modifier is ignored for this test.
2035          *
2036          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2037          */
2038         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2039                                             boolean requireConcreteIfInherited) {
2040             if (isConstructor() || _other.kind != MTH) return false;
2041 
<a name="13" id="anc13"></a>









2042             if (this == _other) return true;
2043             MethodSymbol other = (MethodSymbol)_other;
2044 
2045             // check for a direct implementation
2046             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2047                 types.asSuper(owner.type, other.owner) != null) {
2048                 Type mt = types.memberType(owner.type, this);
2049                 Type ot = types.memberType(owner.type, other);
2050                 if (types.isSubSignature(mt, ot)) {
2051                     if (!checkResult)
2052                         return true;
2053                     if (types.returnTypeSubstitutable(mt, ot))
2054                         return true;
2055                 }
2056             }
2057 
2058             // check for an inherited implementation
2059             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2060                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2061                     !other.isOverridableIn(origin) ||
2062                     !this.isMemberOf(origin, types))
2063                 return false;
2064 
2065             // assert types.asSuper(origin.type, other.owner) != null;
2066             Type mt = types.memberType(origin.type, this);
2067             Type ot = types.memberType(origin.type, other);
2068             return
2069                 types.isSubSignature(mt, ot) &amp;&amp;
2070                 (!checkResult || types.resultSubtype(mt, ot, types.noWarnings));
2071         }
2072 
2073         private boolean isOverridableIn(TypeSymbol origin) {
2074             // JLS 8.4.6.1
2075             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2076             case Flags.PRIVATE:
2077                 return false;
2078             case Flags.PUBLIC:
2079                 return !this.owner.isInterface() ||
2080                         (flags_field &amp; STATIC) == 0;
2081             case Flags.PROTECTED:
2082                 return (origin.flags() &amp; INTERFACE) == 0;
2083             case 0:
2084                 // for package private: can only override in the same
2085                 // package
2086                 return
2087                     this.packge() == origin.packge() &amp;&amp;
2088                     (origin.flags() &amp; INTERFACE) == 0;
2089             default:
2090                 return false;
2091             }
2092         }
2093 
2094         @Override
2095         public boolean isInheritedIn(Symbol clazz, Types types) {
<a name="14" id="anc14"></a>








2096             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2097                 case PUBLIC:
2098                     return !this.owner.isInterface() ||
2099                             clazz == owner ||
2100                             (flags_field &amp; STATIC) == 0;
2101                 default:
2102                     return super.isInheritedIn(clazz, types);
2103             }
2104         }
2105 
2106         public boolean isLambdaMethod() {
2107             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2108         }
2109 
<a name="15" id="anc15"></a>











2110         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2111          *  lambda method
2112          */
2113         public MethodSymbol originalEnclosingMethod() {
2114             return this;
2115         }
2116 
2117         /** The implementation of this (abstract) symbol in class origin;
2118          *  null if none exists. Synthetic methods are not considered
2119          *  as possible implementations.
2120          */
2121         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2122             return implementation(origin, types, checkResult, implementation_filter);
2123         }
2124         // where
2125             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2126                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2127 
2128         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2129             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
2130             if (res != null)
2131                 return res;
2132             // if origin is derived from a raw type, we might have missed
2133             // an implementation because we do not know enough about instantiations.
2134             // in this case continue with the supertype as origin.
2135             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
2136                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
2137             else
2138                 return null;
2139         }
2140 
2141         public List&lt;VarSymbol&gt; params() {
2142             owner.complete();
2143             if (params == null) {
2144                 ListBuffer&lt;VarSymbol&gt; newParams = new ListBuffer&lt;&gt;();
2145                 int i = 0;
2146                 for (Type t : type.getParameterTypes()) {
2147                     Name paramName = name.table.fromString(&quot;arg&quot; + i);
2148                     VarSymbol param = new VarSymbol(PARAMETER, paramName, t, this);
2149                     newParams.append(param);
2150                     i++;
2151                 }
2152                 params = newParams.toList();
2153             }
2154             Assert.checkNonNull(params);
2155             return params;
2156         }
2157 
2158         public Symbol asMemberOf(Type site, Types types) {
2159             return new MethodSymbol(flags_field, name, types.memberType(site, this), owner);
2160         }
2161 
2162         @DefinedBy(Api.LANGUAGE_MODEL)
2163         public ElementKind getKind() {
2164             if (name == name.table.names.init)
2165                 return ElementKind.CONSTRUCTOR;
2166             else if (name == name.table.names.clinit)
2167                 return ElementKind.STATIC_INIT;
2168             else if ((flags() &amp; BLOCK) != 0)
2169                 return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;
2170             else
2171                 return ElementKind.METHOD;
2172         }
2173 
2174         public boolean isStaticOrInstanceInit() {
2175             return getKind() == ElementKind.STATIC_INIT ||
2176                     getKind() == ElementKind.INSTANCE_INIT;
2177         }
2178 
2179         @DefinedBy(Api.LANGUAGE_MODEL)
2180         public Attribute getDefaultValue() {
2181             return defaultValue;
2182         }
2183 
2184         @DefinedBy(Api.LANGUAGE_MODEL)
2185         public List&lt;VarSymbol&gt; getParameters() {
2186             return params();
2187         }
2188 
2189         @DefinedBy(Api.LANGUAGE_MODEL)
2190         public boolean isVarArgs() {
2191             return (flags() &amp; VARARGS) != 0;
2192         }
2193 
2194         @DefinedBy(Api.LANGUAGE_MODEL)
2195         public boolean isDefault() {
2196             return (flags() &amp; DEFAULT) != 0;
2197         }
2198 
2199         @DefinedBy(Api.LANGUAGE_MODEL)
2200         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
2201             return v.visitExecutable(this, p);
2202         }
2203 
2204         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2205             return v.visitMethodSymbol(this, p);
2206         }
2207 
2208         @DefinedBy(Api.LANGUAGE_MODEL)
2209         public Type getReceiverType() {
2210             Type result = asType().getReceiverType();
2211             return (result == null) ? Type.noType : result;
2212         }
2213 
2214         @DefinedBy(Api.LANGUAGE_MODEL)
2215         public Type getReturnType() {
2216             return asType().getReturnType();
2217         }
2218 
2219         @DefinedBy(Api.LANGUAGE_MODEL)
2220         public List&lt;Type&gt; getThrownTypes() {
2221             return asType().getThrownTypes();
2222         }
2223     }
2224 
2225     /** A class for invokedynamic method calls.
2226      */
2227     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {
2228 
2229         public LoadableConstant[] staticArgs;
2230         public MethodHandleSymbol bsm;
2231 
2232         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2233             super(0, name, type, owner);
2234             this.bsm = bsm;
2235             this.staticArgs = staticArgs;
2236         }
2237 
2238         @Override
2239         public boolean isDynamic() {
2240             return true;
2241         }
2242 
2243         @Override
2244         public LoadableConstant[] staticArgs() {
2245             return staticArgs;
2246         }
2247 
2248         @Override
2249         public MethodHandleSymbol bootstrapMethod() {
2250             return bsm;
2251         }
2252 
2253         @Override
2254         public int poolTag() {
2255             return ClassFile.CONSTANT_InvokeDynamic;
2256         }
2257 
2258         @Override
2259         public Type dynamicType() {
2260             return type;
2261         }
2262     }
2263 
2264     /** A class for condy.
2265      */
2266     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {
2267         public LoadableConstant[] staticArgs;
2268         public MethodHandleSymbol bsm;
2269 
2270         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2271             super(0, name, type, owner);
2272             this.bsm = bsm;
2273             this.staticArgs = staticArgs;
2274         }
2275 
2276         @Override
2277         public boolean isDynamic() {
2278             return true;
2279         }
2280 
2281         @Override
2282         public PoolConstant dynamicType() {
2283             return type;
2284         }
2285 
2286         @Override
2287         public LoadableConstant[] staticArgs() {
2288             return staticArgs;
2289         }
2290 
2291         @Override
2292         public LoadableConstant bootstrapMethod() {
2293             return bsm;
2294         }
2295 
2296         @Override
2297         public int poolTag() {
2298             return ClassFile.CONSTANT_Dynamic;
2299         }
2300     }
2301 
2302     /** A class for method handles.
2303      */
2304     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {
2305 
2306         private Symbol refSym;
2307         private boolean getter;
2308 
2309         public MethodHandleSymbol(Symbol msym) {
2310             this(msym, false);
2311         }
2312 
2313         public MethodHandleSymbol(Symbol msym, boolean getter) {
2314             super(msym.flags_field, msym.name, msym.type, msym.owner);
2315             this.refSym = msym;
2316             this.getter = getter;
2317         }
2318 
2319         /**
2320          * Returns the kind associated with this method handle.
2321          */
2322         public int referenceKind() {
2323             if (refSym.kind == VAR) {
2324                 return getter ?
2325                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2326                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2327             } else {
2328                 if (refSym.isConstructor()) {
2329                     return ClassFile.REF_newInvokeSpecial;
2330                 } else {
2331                     if (refSym.isStatic()) {
2332                         return ClassFile.REF_invokeStatic;
2333                     } else if ((refSym.flags() &amp; PRIVATE) != 0) {
2334                         return ClassFile.REF_invokeSpecial;
2335                     } else if (refSym.enclClass().isInterface()) {
2336                         return ClassFile.REF_invokeInterface;
2337                     } else {
2338                         return ClassFile.REF_invokeVirtual;
2339                     }
2340                 }
2341             }
2342         }
2343 
2344         @Override
2345         public int poolTag() {
2346             return ClassFile.CONSTANT_MethodHandle;
2347         }
2348 
2349         @Override
2350         public Object poolKey(Types types) {
2351             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2352         }
2353 
2354         @Override
2355         public MethodHandleSymbol asHandle() {
2356             return this;
2357         }
2358 
2359         @Override
2360         public Symbol baseSymbol() {
2361             return refSym;
2362         }
2363 
2364 
2365         @Override
2366         public boolean isHandle() {
2367             return true;
2368         }
2369     }
2370 
2371     /** A class for predefined operators.
2372      */
2373     public static class OperatorSymbol extends MethodSymbol {
2374 
2375         public int opcode;
2376         private int accessCode = Integer.MIN_VALUE;
2377 
2378         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2379             super(PUBLIC | STATIC, name, type, owner);
2380             this.opcode = opcode;
2381         }
2382 
2383         @Override
2384         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2385             return v.visitOperatorSymbol(this, p);
2386         }
2387 
2388         public int getAccessCode(Tag tag) {
2389             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2390                 return accessCode;
2391             }
2392             accessCode = AccessCode.from(tag, opcode);
2393             return accessCode;
2394         }
2395 
2396         /** Access codes for dereferencing, assignment, withfield
2397          *  and pre/post increment/decrement.
2398 
2399          *  All access codes for accesses to the current class are even.
2400          *  If a member of the superclass should be accessed instead (because
2401          *  access was via a qualified super), add one to the corresponding code
2402          *  for the current class, making the number odd.
2403          *  This numbering scheme is used by the backend to decide whether
2404          *  to issue an invokevirtual or invokespecial call.
2405          *
2406          *  @see Gen#visitSelect(JCFieldAccess tree)
2407          */
2408         public enum AccessCode {
2409             UNKNOWN(-1, Tag.NO_TAG),
2410             DEREF(0, Tag.NO_TAG),
2411             ASSIGN(2, Tag.ASSIGN),
2412             PREINC(4, Tag.PREINC),
2413             PREDEC(6, Tag.PREDEC),
2414             POSTINC(8, Tag.POSTINC),
2415             POSTDEC(10, Tag.POSTDEC),
2416             WITHFIELD(12, Tag.WITHFIELD),
2417             FIRSTASGOP(14, Tag.NO_TAG);
2418 
2419             public final int code;
2420             public final Tag tag;
2421             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2422 
2423             AccessCode(int code, Tag tag) {
2424                 this.code = code;
2425                 this.tag = tag;
2426             }
2427 
2428             static public AccessCode getFromCode(int code) {
2429                 for (AccessCode aCodes : AccessCode.values()) {
2430                     if (aCodes.code == code) {
2431                         return aCodes;
2432                     }
2433                 }
2434                 return UNKNOWN;
2435             }
2436 
2437             static int from(Tag tag, int opcode) {
2438                 /** Map bytecode of binary operation to access code of corresponding
2439                 *  assignment operation. This is always an even number.
2440                 */
2441                 switch (tag) {
2442                     case PREINC:
2443                         return AccessCode.PREINC.code;
2444                     case PREDEC:
2445                         return AccessCode.PREDEC.code;
2446                     case POSTINC:
2447                         return AccessCode.POSTINC.code;
2448                     case POSTDEC:
2449                         return AccessCode.POSTDEC.code;
2450                     case WITHFIELD:
2451                         return AccessCode.WITHFIELD.code;
2452                 }
2453                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2454                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2455                 } else if (opcode == string_add) {
2456                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2457                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2458                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2459                 }
2460                 return -1;
2461             }
2462         }
2463     }
2464 
2465     /** Symbol completer interface.
2466      */
2467     public static interface Completer {
2468 
2469         /** Dummy completer to be used when the symbol has been completed or
2470          * does not need completion.
2471          */
2472         public final static Completer NULL_COMPLETER = new Completer() {
2473             public void complete(Symbol sym) { }
2474             public boolean isTerminal() { return true; }
2475         };
2476 
2477         void complete(Symbol sym) throws CompletionFailure;
2478 
2479         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2480          * completer is used as a place holder when the symbol is completed.
2481          * Calling complete on a terminal completer will not affect the symbol.
2482          *
2483          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2484          * examples of terminal completers.
2485          *
2486          * @return true iff this completer is terminal
2487          */
2488         default boolean isTerminal() {
2489             return false;
2490         }
2491     }
2492 
2493     public static class CompletionFailure extends RuntimeException {
2494         private static final long serialVersionUID = 0;
2495         public final transient DeferredCompletionFailureHandler dcfh;
2496         public transient Symbol sym;
2497 
2498         /** A diagnostic object describing the failure
2499          */
2500         private transient JCDiagnostic diag;
2501 
2502         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;
2503 
2504         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {
2505             this.dcfh = dcfh;
2506             this.sym = sym;
2507             this.diagSupplier = diagSupplier;
2508 //          this.printStackTrace();//DEBUG
2509         }
2510 
2511         public JCDiagnostic getDiagnostic() {
2512             if (diag == null &amp;&amp; diagSupplier != null) {
2513                 diag = diagSupplier.get();
2514             }
2515             return diag;
2516         }
2517 
2518         @Override
2519         public String getMessage() {
2520             return getDiagnostic().getMessage(null);
2521         }
2522 
2523         public JCDiagnostic getDetailValue() {
2524             return getDiagnostic();
2525         }
2526 
2527         @Override
2528         public CompletionFailure initCause(Throwable cause) {
2529             super.initCause(cause);
2530             return this;
2531         }
2532 
2533         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {
2534             this.diagSupplier = diagSupplier;
2535             this.diag = null;
2536         }
2537 
2538     }
2539 
2540     /**
2541      * A visitor for symbols.  A visitor is used to implement operations
2542      * (or relations) on symbols.  Most common operations on types are
2543      * binary relations and this interface is designed for binary
2544      * relations, that is, operations on the form
2545      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2546      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2547      *
2548      * @param &lt;R&gt; the return type of the operation implemented by this
2549      * visitor; use Void if no return type is needed.
2550      * @param &lt;P&gt; the type of the second argument (the first being the
2551      * symbol itself) of the operation implemented by this visitor; use
2552      * Void if a second argument is not needed.
2553      */
2554     public interface Visitor&lt;R,P&gt; {
2555         R visitClassSymbol(ClassSymbol s, P arg);
2556         R visitMethodSymbol(MethodSymbol s, P arg);
2557         R visitPackageSymbol(PackageSymbol s, P arg);
2558         R visitOperatorSymbol(OperatorSymbol s, P arg);
2559         R visitVarSymbol(VarSymbol s, P arg);
2560         R visitTypeSymbol(TypeSymbol s, P arg);
2561         R visitSymbol(Symbol s, P arg);
2562     }
2563 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
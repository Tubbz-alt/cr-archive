<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
  39 import com.sun.tools.javac.code.Types.UniqueType;
  40 import com.sun.tools.javac.comp.Infer.IncorporationAction;
  41 import com.sun.tools.javac.jvm.ClassFile;
  42 import com.sun.tools.javac.jvm.PoolConstant;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import static com.sun.tools.javac.code.BoundKind.*;
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
  49 import static com.sun.tools.javac.code.TypeTag.*;
  50 
  51 /** This class represents Java types. The class itself defines the behavior of
  52  *  the following types:
  53  *  &lt;pre&gt;
  54  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  55  *  type `void&#39; (tag: VOID),
  56  *  the bottom type (tag: BOT),
  57  *  the missing type (tag: NONE).
  58  *  &lt;/pre&gt;
  59  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  60  *  all static inner classes of this class:
  61  *  &lt;pre&gt;
  62  *  class types (tag: CLASS, class: ClassType),
  63  *  array types (tag: ARRAY, class: ArrayType),
  64  *  method types (tag: METHOD, class: MethodType),
  65  *  package types (tag: PACKAGE, class: PackageType),
  66  *  type variables (tag: TYPEVAR, class: TypeVar),
  67  *  type arguments (tag: WILDCARD, class: WildcardType),
  68  *  generic method types (tag: FORALL, class: ForAll),
  69  *  the error type (tag: ERROR, class: ErrorType).
  70  *  &lt;/pre&gt;
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  *
  77  *  @see TypeTag
  78  */
  79 public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {
  80 
  81     /**
  82      * Type metadata,  Should be {@code null} for the default value.
  83      *
  84      * Note: it is an invariant that for any {@code TypeMetadata}
  85      * class, a given {@code Type} may have at most one metadata array
  86      * entry of that class.
  87      */
  88     protected final TypeMetadata metadata;
  89 
  90     public TypeMetadata getMetadata() {
  91         return metadata;
  92     }
  93 
  94     public Entry getMetadataOfKind(final Entry.Kind kind) {
  95         return metadata != null ? metadata.get(kind) : null;
  96     }
  97 
  98     /** Constant type: no type at all. */
  99     public static final JCNoType noType = new JCNoType() {
 100         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 101         public String toString() {
 102             return &quot;none&quot;;
 103         }
 104     };
 105 
 106     /** Constant type: special type to be used during recovery of deferred expressions. */
 107     public static final JCNoType recoveryType = new JCNoType(){
 108         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 109         public String toString() {
 110             return &quot;recovery&quot;;
 111         }
 112     };
 113 
 114     /** Constant type: special type to be used for marking stuck trees. */
 115     public static final JCNoType stuckType = new JCNoType() {
 116         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 117         public String toString() {
 118             return &quot;stuck&quot;;
 119         }
 120     };
 121 
 122     /** If this switch is turned on, the names of type variables
 123      *  and anonymous classes are printed with hashcodes appended.
 124      */
 125     public static boolean moreInfo = false;
 126 
 127     /** The defining class / interface / package / type variable.
 128      */
 129     public TypeSymbol tsym;
 130 
 131     @Override
 132     public int poolTag() {
 133         throw new AssertionError(&quot;Invalid pool entry&quot;);
 134     }
 135 
 136     @Override
 137     public Object poolKey(Types types) {
 138         return new UniqueType(this, types);
 139     }
 140 
 141     /**
 142      * Checks if the current type tag is equal to the given tag.
 143      * @return true if tag is equal to the current type tag.
 144      */
 145     public boolean hasTag(TypeTag tag) {
 146         return tag == getTag();
 147     }
 148 
 149     /**
 150      * Returns the current type tag.
 151      * @return the value of the current type tag.
 152      */
 153     public abstract TypeTag getTag();
 154 
 155     public boolean isNumeric() {
 156         return false;
 157     }
 158 
 159     public boolean isIntegral() {
 160         return false;
 161     }
 162 
 163     public boolean isPrimitive() {
 164         return false;
 165     }
 166 
 167     public boolean isPrimitiveOrVoid() {
 168         return false;
 169     }
 170 
 171     public boolean isReference() {
 172         return false;
 173     }
 174 
 175     public boolean isNullOrReference() {
 176         return false;
 177     }
 178 
 179     public boolean isPartial() {
 180         return false;
 181     }
 182 
 183     /**
 184      * The constant value of this type, null if this type does not
 185      * have a constant value attribute. Only primitive types and
 186      * strings (ClassType) can have a constant value attribute.
 187      * @return the constant value attribute of this type
 188      */
 189     public Object constValue() {
 190         return null;
 191     }
 192 
 193     /** Is this a constant type whose value is false?
 194      */
 195     public boolean isFalse() {
 196         return false;
 197     }
 198 
 199     /** Is this a constant type whose value is true?
 200      */
 201     public boolean isTrue() {
 202         return false;
 203     }
 204 
 205     /**
 206      * Get the representation of this type used for modelling purposes.
 207      * By default, this is itself. For ErrorType, a different value
 208      * may be provided.
 209      */
 210     public Type getModelType() {
 211         return this;
 212     }
 213 
 214     public static List&lt;Type&gt; getModelTypes(List&lt;Type&gt; ts) {
 215         ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 216         for (Type t: ts)
 217             lb.append(t.getModelType());
 218         return lb.toList();
 219     }
 220 
 221     /**For ErrorType, returns the original type, otherwise returns the type itself.
 222      */
 223     public Type getOriginalType() {
 224         return this;
 225     }
 226 
 227     public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) { return v.visitType(this, s); }
 228 
 229     /** Define a type given its tag, type symbol, and type annotations
 230      */
 231 
 232     public Type(TypeSymbol tsym, TypeMetadata metadata) {
 233         Assert.checkNonNull(metadata);
 234         this.tsym = tsym;
 235         this.metadata = metadata;
 236     }
 237 
 238     /**
 239      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
 240      * of a given type expression. This mapping returns the original type is no changes occurred
 241      * when recursively mapping the original type&#39;s subterms.
 242      */
 243     public static abstract class StructuralTypeMapping&lt;S&gt; extends Types.TypeMapping&lt;S&gt; {
 244 
 245         @Override
 246         public Type visitClassType(ClassType t, S s) {
 247             Type outer = t.getEnclosingType();
 248             Type outer1 = visit(outer, s);
 249             List&lt;Type&gt; typarams = t.getTypeArguments();
 250             List&lt;Type&gt; typarams1 = visit(typarams, s);
 251             if (outer1 == outer &amp;&amp; typarams1 == typarams) return t;
 252             else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {
 253                 @Override
 254                 protected boolean needsStripping() {
 255                     return true;
 256                 }
 257             };
 258         }
 259 
 260         @Override
 261         public Type visitWildcardType(WildcardType wt, S s) {
 262             Type t = wt.type;
 263             if (t != null)
 264                 t = visit(t, s);
 265             if (t == wt.type)
 266                 return wt;
 267             else
 268                 return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata) {
 269                     @Override
 270                     protected boolean needsStripping() {
 271                         return true;
 272                     }
 273                 };
 274         }
 275 
 276         @Override
 277         public Type visitArrayType(ArrayType t, S s) {
 278             Type elemtype = t.elemtype;
 279             Type elemtype1 = visit(elemtype, s);
 280             if (elemtype1 == elemtype) return t;
 281             else return new ArrayType(elemtype1, t.tsym, t.metadata) {
 282                 @Override
 283                 protected boolean needsStripping() {
 284                     return true;
 285                 }
 286             };
 287         }
 288 
 289         @Override
 290         public Type visitMethodType(MethodType t, S s) {
 291             List&lt;Type&gt; argtypes = t.argtypes;
 292             Type restype = t.restype;
 293             List&lt;Type&gt; thrown = t.thrown;
 294             List&lt;Type&gt; argtypes1 = visit(argtypes, s);
 295             Type restype1 = visit(restype, s);
 296             List&lt;Type&gt; thrown1 = visit(thrown, s);
 297             if (argtypes1 == argtypes &amp;&amp;
 298                 restype1 == restype &amp;&amp;
 299                 thrown1 == thrown) return t;
 300             else return new MethodType(argtypes1, restype1, thrown1, t.tsym) {
 301                 @Override
 302                 protected boolean needsStripping() {
 303                     return true;
 304                 }
 305             };
 306         }
 307 
 308         @Override
 309         public Type visitForAll(ForAll t, S s) {
 310             return visit(t.qtype, s);
 311         }
 312     }
 313 
 314     /** map a type function over all immediate descendants of this type
 315      */
 316     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping, Z arg) {
 317         return mapping.visit(this, arg);
 318     }
 319 
 320     /** map a type function over all immediate descendants of this type (no arg version)
 321      */
 322     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping) {
 323         return mapping.visit(this, null);
 324     }
 325 
 326     /** Define a constant type, of the same kind as this type
 327      *  and with given constant value
 328      */
 329     public Type constType(Object constValue) {
 330         throw new AssertionError();
 331     }
 332 
 333     /**
 334      * If this is a constant type, return its underlying type.
 335      * Otherwise, return the type itself.
 336      */
 337     public Type baseType() {
 338         return this;
 339     }
 340 
 341     /**
 342      * Returns the original version of this type, before metadata were added. This routine is meant
 343      * for internal use only (i.e. {@link Type#equalsIgnoreMetadata(Type)}, {@link Type#stripMetadata});
 344      * it should not be used outside this class.
 345      */
 346     protected Type typeNoMetadata() {
 347         return metadata == TypeMetadata.EMPTY ? this : baseType();
 348     }
 349 
 350     /**
 351      * Create a new copy of this type but with the specified TypeMetadata.
 352      */
 353     public abstract Type cloneWithMetadata(TypeMetadata metadata);
 354 
 355     /**
 356      * Does this type require annotation stripping for API clients?
 357      */
 358     protected boolean needsStripping() {
 359         return false;
 360     }
 361 
 362     /**
 363      * Strip all metadata associated with this type - this could return a new clone of the type.
 364      * This routine is only used to present the correct annotated types back to the users when types
 365      * are accessed through compiler APIs; it should not be used anywhere in the compiler internals
 366      * as doing so might result in performance penalties.
 367      */
 368     public Type stripMetadataIfNeeded() {
 369         return needsStripping() ?
 370                 accept(stripMetadata, null) :
 371                 this;
 372     }
 373 
 374     public Type stripMetadata() {
 375         return accept(stripMetadata, null);
 376     }
 377     //where
 378         private final static TypeMapping&lt;Void&gt; stripMetadata = new StructuralTypeMapping&lt;Void&gt;() {
 379             @Override
 380             public Type visitClassType(ClassType t, Void aVoid) {
 381                 return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);
 382             }
 383 
 384             @Override
 385             public Type visitArrayType(ArrayType t, Void aVoid) {
 386                 return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);
 387             }
 388 
 389             @Override
 390             public Type visitTypeVar(TypeVar t, Void aVoid) {
 391                 return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);
 392             }
 393 
 394             @Override
 395             public Type visitWildcardType(WildcardType wt, Void aVoid) {
 396                 return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);
 397             }
 398         };
 399 
 400     public Type annotatedType(final List&lt;Attribute.TypeCompound&gt; annos) {
 401         final Entry annoMetadata = new TypeMetadata.Annotations(annos);
 402         return cloneWithMetadata(metadata.combine(annoMetadata));
 403     }
 404 
 405     public boolean isAnnotated() {
 406         final TypeMetadata.Annotations metadata =
 407             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 408 
 409         return null != metadata &amp;&amp; !metadata.getAnnotations().isEmpty();
 410     }
 411 
 412     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 413     public List&lt;Attribute.TypeCompound&gt; getAnnotationMirrors() {
 414         final TypeMetadata.Annotations metadata =
 415             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 416 
 417         return metadata == null ? List.nil() : metadata.getAnnotations();
 418     }
 419 
 420 
 421     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 422     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
 423         return null;
 424     }
 425 
 426 
 427     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 428     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType) {
 429         @SuppressWarnings(&quot;unchecked&quot;)
 430         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);
 431         return tmp;
 432     }
 433 
 434     /** Return the base types of a list of types.
 435      */
 436     public static List&lt;Type&gt; baseTypes(List&lt;Type&gt; ts) {
 437         if (ts.nonEmpty()) {
 438             Type t = ts.head.baseType();
 439             List&lt;Type&gt; baseTypes = baseTypes(ts.tail);
 440             if (t != ts.head || baseTypes != ts.tail)
 441                 return baseTypes.prepend(t);
 442         }
 443         return ts;
 444     }
 445 
 446     protected void appendAnnotationsString(StringBuilder sb,
 447                                          boolean prefix) {
 448         if (isAnnotated()) {
 449             if (prefix) {
 450                 sb.append(&quot; &quot;);
 451             }
 452             sb.append(getAnnotationMirrors());
 453             sb.append(&quot; &quot;);
 454         }
 455     }
 456 
 457     protected void appendAnnotationsString(StringBuilder sb) {
 458         appendAnnotationsString(sb, false);
 459     }
 460 
 461     /** The Java source which this type represents.
 462      */
 463     @DefinedBy(Api.LANGUAGE_MODEL)
 464     public String toString() {
 465         StringBuilder sb = new StringBuilder();
 466         appendAnnotationsString(sb);
 467         if (tsym == null || tsym.name == null) {
 468             sb.append(&quot;&lt;none&gt;&quot;);
 469         } else {
 470             sb.append(tsym.name);
 471         }
 472         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 473             sb.append(hashCode());
 474         }
 475         return sb.toString();
 476     }
 477 
 478     /**
 479      * The Java source which this type list represents.  A List is
 480      * represented as a comma-separated listing of the elements in
 481      * that list.
 482      */
 483     public static String toString(List&lt;Type&gt; ts) {
 484         if (ts.isEmpty()) {
 485             return &quot;&quot;;
 486         } else {
 487             StringBuilder buf = new StringBuilder();
 488             buf.append(ts.head.toString());
 489             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 490                 buf.append(&quot;,&quot;).append(l.head.toString());
 491             return buf.toString();
 492         }
 493     }
 494 
 495     /**
 496      * The constant value of this type, converted to String
 497      */
 498     public String stringValue() {
 499         Object cv = Assert.checkNonNull(constValue());
 500         return cv.toString();
 501     }
 502 
 503     /**
 504      * Override this method with care. For most Type instances this should behave as ==.
 505      */
 506     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 507     public boolean equals(Object t) {
 508         return this == t;
 509     }
 510 
 511     public boolean equalsIgnoreMetadata(Type t) {
 512         return typeNoMetadata().equals(t.typeNoMetadata());
 513     }
 514 
 515     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 516     public int hashCode() {
 517         return super.hashCode();
 518     }
 519 
 520     public String argtypes(boolean varargs) {
 521         List&lt;Type&gt; args = getParameterTypes();
 522         if (!varargs) return args.toString();
 523         StringBuilder buf = new StringBuilder();
 524         while (args.tail.nonEmpty()) {
 525             buf.append(args.head);
 526             args = args.tail;
 527             buf.append(&#39;,&#39;);
 528         }
 529         if (args.head.hasTag(ARRAY)) {
 530             buf.append(((ArrayType)args.head).elemtype);
 531             if (args.head.getAnnotationMirrors().nonEmpty()) {
 532                 buf.append(args.head.getAnnotationMirrors());
 533             }
 534             buf.append(&quot;...&quot;);
 535         } else {
 536             buf.append(args.head);
 537         }
 538         return buf.toString();
 539     }
 540 
 541     /** Access methods.
 542      */
 543     public List&lt;Type&gt;        getTypeArguments()  { return List.nil(); }
 544     public Type              getEnclosingType()  { return null; }
 545     public List&lt;Type&gt;        getParameterTypes() { return List.nil(); }
 546     public Type              getReturnType()     { return null; }
 547     public Type              getReceiverType()   { return null; }
 548     public List&lt;Type&gt;        getThrownTypes()    { return List.nil(); }
 549     public Type              getUpperBound()     { return null; }
 550     public Type              getLowerBound()     { return null; }
 551 
 552     /** Navigation methods, these will work for classes, type variables,
 553      *  foralls, but will return null for arrays and methods.
 554      */
 555 
 556    /** Return all parameters of this type and all its outer types in order
 557     *  outer (first) to inner (last).
 558     */
 559     public List&lt;Type&gt; allparams() { return List.nil(); }
 560 
 561     /** Does this type contain &quot;error&quot; elements?
 562      */
 563     public boolean isErroneous() {
 564         return false;
 565     }
 566 
 567     public static boolean isErroneous(List&lt;Type&gt; ts) {
 568         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 569             if (l.head.isErroneous()) return true;
 570         return false;
 571     }
 572 
 573     /** Is this type parameterized?
 574      *  A class type is parameterized if it has some parameters.
 575      *  An array type is parameterized if its element type is parameterized.
 576      *  All other types are not parameterized.
 577      */
 578     public boolean isParameterized() {
 579         return false;
 580     }
 581 
 582     /** Is this type a raw type?
 583      *  A class type is a raw type if it misses some of its parameters.
 584      *  An array type is a raw type if its element type is raw.
 585      *  All other types are not raw.
 586      *  Type validation will ensure that the only raw types
 587      *  in a program are types that miss all their type variables.
 588      */
 589     public boolean isRaw() {
 590         return false;
 591     }
 592 
 593     /**
 594      * A compound type is a special class type whose supertypes are used to store a list
 595      * of component types. There are two kinds of compound types: (i) intersection types
 596      * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.
 597      */
 598     public boolean isCompound() {
 599         return false;
 600     }
 601 
 602     public boolean isIntersection() {
 603         return false;
 604     }
 605 
 606     public boolean isUnion() {
 607         return false;
 608     }
 609 
 610     public boolean isInterface() {
 611         return (tsym.flags() &amp; INTERFACE) != 0;
 612     }
 613 
 614     public boolean isFinal() {
 615         return (tsym.flags() &amp; FINAL) != 0;
 616     }
 617 
 618     /**
 619      * Does this type contain occurrences of type t?
 620      */
 621     public boolean contains(Type t) {
 622         return t.equalsIgnoreMetadata(this);
 623     }
 624 
 625     public static boolean contains(List&lt;Type&gt; ts, Type t) {
 626         for (List&lt;Type&gt; l = ts;
 627              l.tail != null /*inlined: l.nonEmpty()*/;
 628              l = l.tail)
 629             if (l.head.contains(t)) return true;
 630         return false;
 631     }
 632 
 633     /** Does this type contain an occurrence of some type in &#39;ts&#39;?
 634      */
 635     public boolean containsAny(List&lt;Type&gt; ts) {
 636         for (Type t : ts)
 637             if (this.contains(t)) return true;
 638         return false;
 639     }
 640 
 641     public static boolean containsAny(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
 642         for (Type t : ts1)
 643             if (t.containsAny(ts2)) return true;
 644         return false;
 645     }
 646 
 647     public static List&lt;Type&gt; filter(List&lt;Type&gt; ts, Filter&lt;Type&gt; tf) {
 648         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 649         for (Type t : ts) {
 650             if (tf.accepts(t)) {
 651                 buf.append(t);
 652             }
 653         }
 654         return buf.toList();
 655     }
 656 
 657     public boolean isSuperBound() { return false; }
 658     public boolean isExtendsBound() { return false; }
 659     public boolean isUnbound() { return false; }
 660     public Type withTypeVar(Type t) { return this; }
 661 
 662     /** The underlying method type of this type.
 663      */
 664     public MethodType asMethodType() { throw new AssertionError(); }
 665 
 666     /** Complete loading all classes in this type.
 667      */
 668     public void complete() {}
 669 
 670     public TypeSymbol asElement() {
 671         return tsym;
 672     }
 673 
 674     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 675     public TypeKind getKind() {
 676         return TypeKind.OTHER;
 677     }
 678 
 679     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 680     public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 681         throw new AssertionError();
 682     }
 683 
 684     public static class JCPrimitiveType extends Type
 685             implements javax.lang.model.type.PrimitiveType {
 686 
 687         TypeTag tag;
 688 
 689         public JCPrimitiveType(TypeTag tag, TypeSymbol tsym) {
 690             this(tag, tsym, TypeMetadata.EMPTY);
 691         }
 692 
 693         private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {
 694             super(tsym, metadata);
 695             this.tag = tag;
 696             Assert.check(tag.isPrimitive);
 697         }
 698 
 699         @Override
 700         public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {
 701             return new JCPrimitiveType(tag, tsym, md) {
 702                 @Override
 703                 public Type baseType() { return JCPrimitiveType.this.baseType(); }
 704             };
 705         }
 706 
 707         @Override
 708         public boolean isNumeric() {
 709             return tag != BOOLEAN;
 710         }
 711 
 712         @Override
 713         public boolean isIntegral() {
 714             switch (tag) {
 715                 case CHAR:
 716                 case BYTE:
 717                 case SHORT:
 718                 case INT:
 719                 case LONG:
 720                     return true;
 721                 default:
 722                     return false;
 723             }
 724         }
 725 
 726         @Override
 727         public boolean isPrimitive() {
 728             return true;
 729         }
 730 
 731         @Override
 732         public TypeTag getTag() {
 733             return tag;
 734         }
 735 
 736         @Override
 737         public boolean isPrimitiveOrVoid() {
 738             return true;
 739         }
 740 
 741         /** Define a constant type, of the same kind as this type
 742          *  and with given constant value
 743          */
 744         @Override
 745         public Type constType(Object constValue) {
 746             final Object value = constValue;
 747             return new JCPrimitiveType(tag, tsym, metadata) {
 748                     @Override
 749                     public Object constValue() {
 750                         return value;
 751                     }
 752                     @Override
 753                     public Type baseType() {
 754                         return tsym.type;
 755                     }
 756                 };
 757         }
 758 
 759         /**
 760          * The constant value of this type, converted to String
 761          */
 762         @Override
 763         public String stringValue() {
 764             Object cv = Assert.checkNonNull(constValue());
 765             if (tag == BOOLEAN) {
 766                 return ((Integer) cv).intValue() == 0 ? &quot;false&quot; : &quot;true&quot;;
 767             }
 768             else if (tag == CHAR) {
 769                 return String.valueOf((char) ((Integer) cv).intValue());
 770             }
 771             else {
 772                 return cv.toString();
 773             }
 774         }
 775 
 776         /** Is this a constant type whose value is false?
 777          */
 778         @Override
 779         public boolean isFalse() {
 780             return
 781                 tag == BOOLEAN &amp;&amp;
 782                 constValue() != null &amp;&amp;
 783                 ((Integer)constValue()).intValue() == 0;
 784         }
 785 
 786         /** Is this a constant type whose value is true?
 787          */
 788         @Override
 789         public boolean isTrue() {
 790             return
 791                 tag == BOOLEAN &amp;&amp;
 792                 constValue() != null &amp;&amp;
 793                 ((Integer)constValue()).intValue() != 0;
 794         }
 795 
 796         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 797         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 798             return v.visitPrimitive(this, p);
 799         }
 800 
 801         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 802         public TypeKind getKind() {
 803             switch (tag) {
 804                 case BYTE:      return TypeKind.BYTE;
 805                 case CHAR:      return TypeKind.CHAR;
 806                 case SHORT:     return TypeKind.SHORT;
 807                 case INT:       return TypeKind.INT;
 808                 case LONG:      return TypeKind.LONG;
 809                 case FLOAT:     return TypeKind.FLOAT;
 810                 case DOUBLE:    return TypeKind.DOUBLE;
 811                 case BOOLEAN:   return TypeKind.BOOLEAN;
 812             }
 813             throw new AssertionError();
 814         }
 815 
 816     }
 817 
 818     public static class WildcardType extends Type
 819             implements javax.lang.model.type.WildcardType {
 820 
 821         public Type type;
 822         public BoundKind kind;
 823         public TypeVar bound;
 824 
 825         @Override
 826         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 827             return v.visitWildcardType(this, s);
 828         }
 829 
 830         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym) {
 831             this(type, kind, tsym, null, TypeMetadata.EMPTY);
 832         }
 833 
 834         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 835                             TypeMetadata metadata) {
 836             this(type, kind, tsym, null, metadata);
 837         }
 838 
 839         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 840                             TypeVar bound) {
 841             this(type, kind, tsym, bound, TypeMetadata.EMPTY);
 842         }
 843 
 844         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 845                             TypeVar bound, TypeMetadata metadata) {
 846             super(tsym, metadata);
 847             this.type = Assert.checkNonNull(type);
 848             this.kind = kind;
 849             this.bound = bound;
 850         }
 851 
 852         @Override
 853         public WildcardType cloneWithMetadata(TypeMetadata md) {
 854             return new WildcardType(type, kind, tsym, bound, md) {
 855                 @Override
 856                 public Type baseType() { return WildcardType.this.baseType(); }
 857             };
 858         }
 859 
 860         @Override
 861         public TypeTag getTag() {
 862             return WILDCARD;
 863         }
 864 
 865         @Override
 866         public boolean contains(Type t) {
 867             return kind != UNBOUND &amp;&amp; type.contains(t);
 868         }
 869 
 870         public boolean isSuperBound() {
 871             return kind == SUPER ||
 872                 kind == UNBOUND;
 873         }
 874         public boolean isExtendsBound() {
 875             return kind == EXTENDS ||
 876                 kind == UNBOUND;
 877         }
 878         public boolean isUnbound() {
 879             return kind == UNBOUND;
 880         }
 881 
 882         @Override
 883         public boolean isReference() {
 884             return true;
 885         }
 886 
 887         @Override
 888         public boolean isNullOrReference() {
 889             return true;
 890         }
 891 
 892         @Override
 893         public Type withTypeVar(Type t) {
 894             //-System.err.println(this+&quot;.withTypeVar(&quot;+t+&quot;);&quot;);//DEBUG
 895             if (bound == t)
 896                 return this;
 897             bound = (TypeVar)t;
 898             return this;
 899         }
 900 
 901         boolean isPrintingBound = false;
 902         @DefinedBy(Api.LANGUAGE_MODEL)
 903         public String toString() {
 904             StringBuilder s = new StringBuilder();
 905             appendAnnotationsString(s);
 906             s.append(kind.toString());
 907             if (kind != UNBOUND)
 908                 s.append(type);
 909             if (moreInfo &amp;&amp; bound != null &amp;&amp; !isPrintingBound)
 910                 try {
 911                     isPrintingBound = true;
 912                     s.append(&quot;{:&quot;).append(bound.getUpperBound()).append(&quot;:}&quot;);
 913                 } finally {
 914                     isPrintingBound = false;
 915                 }
 916             return s.toString();
 917         }
 918 
 919         @DefinedBy(Api.LANGUAGE_MODEL)
 920         public Type getExtendsBound() {
 921             if (kind == EXTENDS)
 922                 return type;
 923             else
 924                 return null;
 925         }
 926 
 927         @DefinedBy(Api.LANGUAGE_MODEL)
 928         public Type getSuperBound() {
 929             if (kind == SUPER)
 930                 return type;
 931             else
 932                 return null;
 933         }
 934 
 935         @DefinedBy(Api.LANGUAGE_MODEL)
 936         public TypeKind getKind() {
 937             return TypeKind.WILDCARD;
 938         }
 939 
 940         @DefinedBy(Api.LANGUAGE_MODEL)
 941         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 942             return v.visitWildcard(this, p);
 943         }
 944     }
 945 
 946     public static class ConstantPoolQType implements PoolConstant {
 947 
 948         public final Type type;
 949         final Types types;
 950 
 951         public ConstantPoolQType(Type type, Types types) {
 952             this.type = type;
 953             this.types = types;
 954         }
 955 
 956         @Override
 957         public Object poolKey(Types types) {
 958             return this;
 959         }
 960 
 961         @Override
 962         public int poolTag() {
 963             return ClassFile.CONSTANT_Class;
 964         }
 965 
 966         public int hashCode() {
 967             return types.hashCode(type);
 968         }
 969 
 970         public boolean equals(Object obj) {
 971             return (obj instanceof ConstantPoolQType) &amp;&amp;
 972                     types.isSameType(type, ((ConstantPoolQType)obj).type);
 973         }
 974 
 975         public String toString() {
 976             return type.toString();
 977         }
 978     }
 979 
 980     public static class ClassType extends Type implements DeclaredType, LoadableConstant,
 981                                                           javax.lang.model.type.ErrorType {
 982 
 983         /** The enclosing type of this type. If this is the type of an inner
 984          *  class, outer_field refers to the type of its enclosing
 985          *  instance class, in all other cases it refers to noType.
 986          */
 987         private Type outer_field;
 988 
 989         /** The type parameters of this type (to be set once class is loaded).
 990          */
 991         public List&lt;Type&gt; typarams_field;
 992 
 993         /** A cache variable for the type parameters of this type,
 994          *  appended to all parameters of its enclosing class.
 995          *  @see #allparams
 996          */
 997         public List&lt;Type&gt; allparams_field;
 998 
 999         /** The supertype of this class (to be set once class is loaded).
1000          */
1001         public Type supertype_field;
1002 
1003         /** The interfaces of this class (to be set once class is loaded).
1004          */
1005         public List&lt;Type&gt; interfaces_field;
1006 
1007         /** All the interfaces of this class, including missing ones.
1008          */
1009         public List&lt;Type&gt; all_interfaces_field;
1010 
1011         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
1012             this(outer, typarams, tsym, TypeMetadata.EMPTY);
1013         }
1014 
1015         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
1016                          TypeMetadata metadata) {
1017             super(tsym, metadata);
1018             this.outer_field = outer;
1019             this.typarams_field = typarams;
1020             this.allparams_field = null;
1021             this.supertype_field = null;
1022             this.interfaces_field = null;
1023         }
1024 
1025         public int poolTag() {
1026             return ClassFile.CONSTANT_Class;
1027         }
1028 
1029         @Override
1030         public ClassType cloneWithMetadata(TypeMetadata md) {
1031             return new ClassType(outer_field, typarams_field, tsym, md) {
1032                 @Override
1033                 public Type baseType() { return ClassType.this.baseType(); }
1034             };
1035         }
1036 
1037         @Override
1038         public TypeTag getTag() {
1039             return CLASS;
1040         }
1041 
1042         @Override
1043         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1044             return v.visitClassType(this, s);
1045         }
1046 
1047         public Type constType(Object constValue) {
1048             final Object value = constValue;
1049             return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {
1050                     @Override
1051                     public Object constValue() {
1052                         return value;
1053                     }
1054                     @Override
1055                     public Type baseType() {
1056                         return tsym.type;
1057                     }
1058                 };
1059         }
1060 
1061         /** The Java source which this type represents.
1062          */
1063         @DefinedBy(Api.LANGUAGE_MODEL)
1064         public String toString() {
1065             StringBuilder buf = new StringBuilder();
1066             if (getEnclosingType().hasTag(CLASS) &amp;&amp; tsym.owner.kind == TYP) {
1067                 buf.append(getEnclosingType().toString());
1068                 buf.append(&quot;.&quot;);
1069                 appendAnnotationsString(buf);
1070                 buf.append(className(tsym, false));
1071             } else {
1072                 appendAnnotationsString(buf);
1073                 buf.append(className(tsym, true));
1074             }
1075 
1076             if (getTypeArguments().nonEmpty()) {
1077                 buf.append(&#39;&lt;&#39;);
1078                 buf.append(getTypeArguments().toString());
1079                 buf.append(&quot;&gt;&quot;);
1080             }
1081             return buf.toString();
1082         }
1083 //where
1084             private String className(Symbol sym, boolean longform) {
1085                 if (sym.name.isEmpty() &amp;&amp; (sym.flags() &amp; COMPOUND) != 0) {
1086                     StringBuilder s = new StringBuilder(supertype_field.toString());
1087                     for (List&lt;Type&gt; is=interfaces_field; is.nonEmpty(); is = is.tail) {
1088                         s.append(&quot;&amp;&quot;);
1089                         s.append(is.head.toString());
1090                     }
1091                     return s.toString();
1092                 } else if (sym.name.isEmpty()) {
1093                     String s;
1094                     ClassType norm = (ClassType) tsym.type;
1095                     if (norm == null) {
1096                         s = Log.getLocalizedString(&quot;anonymous.class&quot;, (Object)null);
1097                     } else if (norm.interfaces_field != null &amp;&amp; norm.interfaces_field.nonEmpty()) {
1098                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1099                                                    norm.interfaces_field.head);
1100                     } else {
1101                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1102                                                    norm.supertype_field);
1103                     }
1104                     if (moreInfo)
1105                         s += String.valueOf(sym.hashCode());
1106                     return s;
1107                 }
1108                 String s;
1109                 if (longform) {
1110                     s =  sym.getQualifiedName().toString();
1111                 } else {
1112                     s = sym.name.toString();
1113                 }
1114                 return sym.isProjectedNullable() ? s + &#39;?&#39; : s;
1115             }
1116 
1117         @DefinedBy(Api.LANGUAGE_MODEL)
1118         public List&lt;Type&gt; getTypeArguments() {
1119             if (typarams_field == null) {
1120                 complete();
1121                 if (typarams_field == null)
1122                     typarams_field = List.nil();
1123             }
1124             return typarams_field;
1125         }
1126 
1127         public boolean hasErasedSupertypes() {
1128             return isRaw();
1129         }
1130 
1131         @DefinedBy(Api.LANGUAGE_MODEL)
1132         public Type getEnclosingType() {
1133             return outer_field;
1134         }
1135 
1136         public void setEnclosingType(Type outer) {
1137             outer_field = outer;
1138         }
1139 
1140         public List&lt;Type&gt; allparams() {
1141             if (allparams_field == null) {
1142                 allparams_field = getTypeArguments().prependList(getEnclosingType().allparams());
1143             }
1144             return allparams_field;
1145         }
1146 
1147         public boolean isErroneous() {
1148             return
1149                 getEnclosingType().isErroneous() ||
1150                 isErroneous(getTypeArguments()) ||
1151                 this != tsym.type &amp;&amp; tsym.type.isErroneous();
1152         }
1153 
1154         public boolean isParameterized() {
1155             return allparams().tail != null;
1156             // optimization, was: allparams().nonEmpty();
1157         }
1158 
1159         @Override
1160         public boolean isReference() {
1161             return true;
1162         }
1163 
1164         @Override
1165         public boolean isNullOrReference() {
1166             return true;
1167         }
1168 
1169         /** A cache for the rank. */
1170         int rank_field = -1;
1171 
1172         /** A class type is raw if it misses some
1173          *  of its type parameter sections.
1174          *  After validation, this is equivalent to:
1175          *  {@code allparams.isEmpty() &amp;&amp; tsym.type.allparams.nonEmpty(); }
1176          */
1177         public boolean isRaw() {
1178             return
1179                 this != tsym.type &amp;&amp; // necessary, but not sufficient condition
1180                 tsym.type.allparams().nonEmpty() &amp;&amp;
1181                 allparams().isEmpty();
1182         }
1183 
1184         public boolean contains(Type elem) {
1185             return
1186                 elem.equalsIgnoreMetadata(this)
1187                 || (isParameterized()
1188                     &amp;&amp; (getEnclosingType().contains(elem) || contains(getTypeArguments(), elem)))
1189                 || (isCompound()
1190                     &amp;&amp; (supertype_field.contains(elem) || contains(interfaces_field, elem)));
1191         }
1192 
1193         public void complete() {
1194             tsym.complete();
1195         }
1196 
1197         @DefinedBy(Api.LANGUAGE_MODEL)
1198         public TypeKind getKind() {
1199             tsym.apiComplete();
1200             return tsym.kind == TYP ? TypeKind.DECLARED : TypeKind.ERROR;
1201         }
1202 
1203         @DefinedBy(Api.LANGUAGE_MODEL)
1204         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1205             return v.visitDeclared(this, p);
1206         }
1207     }
1208 
1209     public static class ErasedClassType extends ClassType {
1210         public ErasedClassType(Type outer, TypeSymbol tsym,
1211                                TypeMetadata metadata) {
1212             super(outer, List.nil(), tsym, metadata);
1213         }
1214 
1215         @Override
1216         public boolean hasErasedSupertypes() {
1217             return true;
1218         }
1219     }
1220 
1221     // a clone of a ClassType that knows about the alternatives of a union type.
1222     public static class UnionClassType extends ClassType implements UnionType {
1223         final List&lt;? extends Type&gt; alternatives_field;
1224 
1225         public UnionClassType(ClassType ct, List&lt;? extends Type&gt; alternatives) {
1226             // Presently no way to refer to this type directly, so we
1227             // cannot put annotations directly on it.
1228             super(ct.outer_field, ct.typarams_field, ct.tsym);
1229             allparams_field = ct.allparams_field;
1230             supertype_field = ct.supertype_field;
1231             interfaces_field = ct.interfaces_field;
1232             all_interfaces_field = ct.interfaces_field;
1233             alternatives_field = alternatives;
1234         }
1235 
1236         @Override
1237         public UnionClassType cloneWithMetadata(TypeMetadata md) {
1238             throw new AssertionError(&quot;Cannot add metadata to a union type&quot;);
1239         }
1240 
1241         public Type getLub() {
1242             return tsym.type;
1243         }
1244 
1245         @DefinedBy(Api.LANGUAGE_MODEL)
1246         public java.util.List&lt;? extends TypeMirror&gt; getAlternatives() {
1247             return Collections.unmodifiableList(alternatives_field);
1248         }
1249 
1250         @Override
1251         public boolean isUnion() {
1252             return true;
1253         }
1254 
1255         @Override
1256         public boolean isCompound() {
1257             return getLub().isCompound();
1258         }
1259 
1260         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1261         public TypeKind getKind() {
1262             return TypeKind.UNION;
1263         }
1264 
1265         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1266         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1267             return v.visitUnion(this, p);
1268         }
1269 
1270         public Iterable&lt;? extends Type&gt; getAlternativeTypes() {
1271             return alternatives_field;
1272         }
1273     }
1274 
1275     // a clone of a ClassType that knows about the bounds of an intersection type.
1276     public static class IntersectionClassType extends ClassType implements IntersectionType {
1277 
1278         public boolean allInterfaces;
1279 
1280         public IntersectionClassType(List&lt;Type&gt; bounds, ClassSymbol csym, boolean allInterfaces) {
1281             // Presently no way to refer to this type directly, so we
1282             // cannot put annotations directly on it.
1283             super(Type.noType, List.nil(), csym);
1284             this.allInterfaces = allInterfaces;
1285             Assert.check((csym.flags() &amp; COMPOUND) != 0);
1286             supertype_field = bounds.head;
1287             interfaces_field = bounds.tail;
1288             Assert.check(!supertype_field.tsym.isCompleted() ||
1289                     !supertype_field.isInterface(), supertype_field);
1290         }
1291 
1292         @Override
1293         public IntersectionClassType cloneWithMetadata(TypeMetadata md) {
1294             throw new AssertionError(&quot;Cannot add metadata to an intersection type&quot;);
1295         }
1296 
1297         @DefinedBy(Api.LANGUAGE_MODEL)
1298         public java.util.List&lt;? extends TypeMirror&gt; getBounds() {
1299             return Collections.unmodifiableList(getExplicitComponents());
1300         }
1301 
1302         @Override
1303         public boolean isCompound() {
1304             return true;
1305         }
1306 
1307         public List&lt;Type&gt; getComponents() {
1308             return interfaces_field.prepend(supertype_field);
1309         }
1310 
1311         @Override
1312         public boolean isIntersection() {
1313             return true;
1314         }
1315 
1316         public List&lt;Type&gt; getExplicitComponents() {
1317             return allInterfaces ?
1318                     interfaces_field :
1319                     getComponents();
1320         }
1321 
1322         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1323         public TypeKind getKind() {
1324             return TypeKind.INTERSECTION;
1325         }
1326 
1327         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1328         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1329             return v.visitIntersection(this, p);
1330         }
1331     }
1332 
1333     public static class ArrayType extends Type
1334             implements LoadableConstant, javax.lang.model.type.ArrayType {
1335 
1336         public Type elemtype;
1337 
1338         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1339             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1340         }
1341 
1342         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1343                          TypeMetadata metadata) {
1344             super(arrayClass, metadata);
1345             this.elemtype = elemtype;
1346         }
1347 
1348         public ArrayType(ArrayType that) {
1349             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1350             //processing to flow from original array to the cloned array.
1351             this(that.elemtype, that.tsym, that.getMetadata());
1352         }
1353 
1354         public int poolTag() {
1355             return ClassFile.CONSTANT_Class;
1356         }
1357 
1358         @Override
1359         public ArrayType cloneWithMetadata(TypeMetadata md) {
1360             return new ArrayType(elemtype, tsym, md) {
1361                 @Override
1362                 public Type baseType() { return ArrayType.this.baseType(); }
1363             };
1364         }
1365 
1366         @Override
1367         public TypeTag getTag() {
1368             return ARRAY;
1369         }
1370 
1371         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1372             return v.visitArrayType(this, s);
1373         }
1374 
1375         @DefinedBy(Api.LANGUAGE_MODEL)
1376         public String toString() {
1377             StringBuilder sb = new StringBuilder();
1378 
1379             // First append root component type
1380             Type t = elemtype;
1381             while (t.getKind() == TypeKind.ARRAY)
1382                 t = ((ArrayType) t).getComponentType();
1383             sb.append(t);
1384 
1385             // then append @Anno[] @Anno[] ... @Anno[]
1386             t = this;
1387             do {
1388                 t.appendAnnotationsString(sb, true);
1389                 sb.append(&quot;[]&quot;);
1390                 t = ((ArrayType) t).getComponentType();
1391             } while (t.getKind() == TypeKind.ARRAY);
1392 
1393             return sb.toString();
1394         }
1395 
1396         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1397         public boolean equals(Object obj) {
1398             if (obj instanceof ArrayType) {
1399                 ArrayType that = (ArrayType)obj;
1400                 return this == that ||
1401                         elemtype.equals(that.elemtype);
1402             }
1403 
1404             return false;
1405         }
1406 
1407         @DefinedBy(Api.LANGUAGE_MODEL)
1408         public int hashCode() {
1409             return (ARRAY.ordinal() &lt;&lt; 5) + elemtype.hashCode();
1410         }
1411 
1412         public boolean isVarargs() {
1413             return false;
1414         }
1415 
1416         public List&lt;Type&gt; allparams() { return elemtype.allparams(); }
1417 
1418         public boolean isErroneous() {
1419             return elemtype.isErroneous();
1420         }
1421 
1422         public boolean isParameterized() {
1423             return elemtype.isParameterized();
1424         }
1425 
1426         @Override
1427         public boolean isReference() {
1428             return true;
1429         }
1430 
1431         @Override
1432         public boolean isNullOrReference() {
1433             return true;
1434         }
1435 
1436         public boolean isRaw() {
1437             return elemtype.isRaw();
1438         }
1439 
1440         public ArrayType makeVarargs() {
1441             return new ArrayType(elemtype, tsym, metadata) {
1442                 @Override
1443                 public boolean isVarargs() {
1444                     return true;
1445                 }
1446             };
1447         }
1448 
1449         public boolean contains(Type elem) {
1450             return elem.equalsIgnoreMetadata(this) || elemtype.contains(elem);
1451         }
1452 
1453         public void complete() {
1454             elemtype.complete();
1455         }
1456 
1457         @DefinedBy(Api.LANGUAGE_MODEL)
1458         public Type getComponentType() {
1459             return elemtype;
1460         }
1461 
1462         @DefinedBy(Api.LANGUAGE_MODEL)
1463         public TypeKind getKind() {
1464             return TypeKind.ARRAY;
1465         }
1466 
1467         @DefinedBy(Api.LANGUAGE_MODEL)
1468         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1469             return v.visitArray(this, p);
1470         }
1471     }
1472 
1473     public static class MethodType extends Type implements ExecutableType, LoadableConstant {
1474 
1475         public List&lt;Type&gt; argtypes;
1476         public Type restype;
1477         public List&lt;Type&gt; thrown;
1478 
1479         /** The type annotations on the method receiver.
1480          */
1481         public Type recvtype;
1482 
1483         public MethodType(List&lt;Type&gt; argtypes,
1484                           Type restype,
1485                           List&lt;Type&gt; thrown,
1486                           TypeSymbol methodClass) {
1487             // Presently no way to refer to a method type directly, so
1488             // we cannot put type annotations on it.
1489             super(methodClass, TypeMetadata.EMPTY);
1490             this.argtypes = argtypes;
1491             this.restype = restype;
1492             this.thrown = thrown;
1493         }
1494 
1495         @Override
1496         public MethodType cloneWithMetadata(TypeMetadata md) {
1497             throw new AssertionError(&quot;Cannot add metadata to a method type&quot;);
1498         }
1499 
1500         @Override
1501         public TypeTag getTag() {
1502             return METHOD;
1503         }
1504 
1505         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1506             return v.visitMethodType(this, s);
1507         }
1508 
1509         /** The Java source which this type represents.
1510          *
1511          *  XXX 06/09/99 iris This isn&#39;t correct Java syntax, but it probably
1512          *  should be.
1513          */
1514         @DefinedBy(Api.LANGUAGE_MODEL)
1515         public String toString() {
1516             StringBuilder sb = new StringBuilder();
1517             appendAnnotationsString(sb);
1518             sb.append(&#39;(&#39;);
1519             sb.append(argtypes);
1520             sb.append(&#39;)&#39;);
1521             sb.append(restype);
1522             return sb.toString();
1523         }
1524 
1525         @DefinedBy(Api.LANGUAGE_MODEL)
1526         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1527         @DefinedBy(Api.LANGUAGE_MODEL)
1528         public Type              getReturnType()     { return restype; }
1529         @DefinedBy(Api.LANGUAGE_MODEL)
1530         public Type              getReceiverType()   { return recvtype; }
1531         @DefinedBy(Api.LANGUAGE_MODEL)
1532         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1533 
1534         public boolean isErroneous() {
1535             return
1536                 isErroneous(argtypes) ||
1537                 restype != null &amp;&amp; restype.isErroneous();
1538         }
1539 
1540         @Override
1541         public int poolTag() {
1542             return ClassFile.CONSTANT_MethodType;
1543         }
1544 
1545         public boolean contains(Type elem) {
1546             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1547         }
1548 
1549         public MethodType asMethodType() { return this; }
1550 
1551         public void complete() {
1552             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1553                 l.head.complete();
1554             restype.complete();
1555             recvtype.complete();
1556             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1557                 l.head.complete();
1558         }
1559 
1560         @DefinedBy(Api.LANGUAGE_MODEL)
1561         public List&lt;TypeVar&gt; getTypeVariables() {
1562             return List.nil();
1563         }
1564 
1565         public TypeSymbol asElement() {
1566             return null;
1567         }
1568 
1569         @DefinedBy(Api.LANGUAGE_MODEL)
1570         public TypeKind getKind() {
1571             return TypeKind.EXECUTABLE;
1572         }
1573 
1574         @DefinedBy(Api.LANGUAGE_MODEL)
1575         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1576             return v.visitExecutable(this, p);
1577         }
1578     }
1579 
1580     public static class PackageType extends Type implements NoType {
1581 
1582         PackageType(PackageSymbol tsym) {
1583             // Package types cannot be annotated
1584             super(tsym, TypeMetadata.EMPTY);
1585         }
1586 
1587         @Override
1588         public PackageType cloneWithMetadata(TypeMetadata md) {
1589             throw new AssertionError(&quot;Cannot add metadata to a package type&quot;);
1590         }
1591 
1592         @Override
1593         public TypeTag getTag() {
1594             return PACKAGE;
1595         }
1596 
1597         @Override
1598         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1599             return v.visitPackageType(this, s);
1600         }
1601 
1602         @DefinedBy(Api.LANGUAGE_MODEL)
1603         public String toString() {
1604             return tsym.getQualifiedName().toString();
1605         }
1606 
1607         @DefinedBy(Api.LANGUAGE_MODEL)
1608         public TypeKind getKind() {
1609             return TypeKind.PACKAGE;
1610         }
1611 
1612         @DefinedBy(Api.LANGUAGE_MODEL)
1613         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1614             return v.visitNoType(this, p);
1615         }
1616     }
1617 
1618     public static class ModuleType extends Type implements NoType {
1619 
1620         ModuleType(ModuleSymbol tsym) {
1621             // Module types cannot be annotated
1622             super(tsym, TypeMetadata.EMPTY);
1623         }
1624 
1625         @Override
1626         public ModuleType cloneWithMetadata(TypeMetadata md) {
1627             throw new AssertionError(&quot;Cannot add metadata to a module type&quot;);
1628         }
1629 
1630         @Override
1631         public ModuleType annotatedType(List&lt;Attribute.TypeCompound&gt; annos) {
1632             throw new AssertionError(&quot;Cannot annotate a module type&quot;);
1633         }
1634 
1635         @Override
1636         public TypeTag getTag() {
1637             return TypeTag.MODULE;
1638         }
1639 
1640         @Override
1641         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1642             return v.visitModuleType(this, s);
1643         }
1644 
1645         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1646         public String toString() {
1647             return tsym.getQualifiedName().toString();
1648         }
1649 
1650         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1651         public TypeKind getKind() {
1652             return TypeKind.MODULE;
1653         }
1654 
1655         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1656         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1657             return v.visitNoType(this, p);
1658         }
1659     }
1660 
1661     public static class TypeVar extends Type implements TypeVariable {
1662 
1663         /** The upper bound of this type variable; set from outside.
1664          *  Must be nonempty once it is set.
1665          *  For a bound, `bound&#39; is the bound type itself.
1666          *  Multiple bounds are expressed as a single class type which has the
1667          *  individual bounds as superclass, respectively interfaces.
1668          *  The class type then has as `tsym&#39; a compiler generated class `c&#39;,
1669          *  which has a flag COMPOUND and whose owner is the type variable
1670          *  itself. Furthermore, the erasure_field of the class
1671          *  points to the first class or interface bound.
1672          */
1673         private Type _bound = null;
1674 
1675         /** The lower bound of this type variable.
1676          *  TypeVars don&#39;t normally have a lower bound, so it is normally set
1677          *  to syms.botType.
1678          *  Subtypes, such as CapturedType, may provide a different value.
1679          */
1680         public Type lower;
1681 
1682         public TypeVar(Name name, Symbol owner, Type lower) {
1683             super(null, TypeMetadata.EMPTY);
1684             Assert.checkNonNull(lower);
1685             tsym = new TypeVariableSymbol(0, name, this, owner);
1686             this.setUpperBound(null);
1687             this.lower = lower;
1688         }
1689 
1690         public TypeVar(TypeSymbol tsym, Type bound, Type lower) {
1691             this(tsym, bound, lower, TypeMetadata.EMPTY);
1692         }
1693 
1694         public TypeVar(TypeSymbol tsym, Type bound, Type lower,
1695                        TypeMetadata metadata) {
1696             super(tsym, metadata);
1697             Assert.checkNonNull(lower);
1698             this.setUpperBound(bound);
1699             this.lower = lower;
1700         }
1701 
1702         @Override
1703         public TypeVar cloneWithMetadata(TypeMetadata md) {
1704             return new TypeVar(tsym, getUpperBound(), lower, md) {
1705                 @Override
1706                 public Type baseType() { return TypeVar.this.baseType(); }
1707 
1708                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1709                 public Type getUpperBound() { return TypeVar.this.getUpperBound(); }
1710 
1711                 public void setUpperBound(Type bound) { TypeVar.this.setUpperBound(bound); }
1712             };
1713         }
1714 
1715         @Override
1716         public TypeTag getTag() {
1717             return TYPEVAR;
1718         }
1719 
1720         @Override
1721         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1722             return v.visitTypeVar(this, s);
1723         }
1724 
1725         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1726         public Type getUpperBound() { return _bound; }
1727 
1728         public void setUpperBound(Type bound) { this._bound = bound; }
1729 
1730         int rank_field = -1;
1731 
1732         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1733         public Type getLowerBound() {
1734             return lower;
1735         }
1736 
1737         @DefinedBy(Api.LANGUAGE_MODEL)
1738         public TypeKind getKind() {
1739             return TypeKind.TYPEVAR;
1740         }
1741 
1742         public boolean isCaptured() {
1743             return false;
1744         }
1745 
1746         @Override
1747         public boolean isReference() {
1748             return true;
1749         }
1750 
1751         @Override
1752         public boolean isNullOrReference() {
1753             return true;
1754         }
1755 
1756         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1757         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1758             return v.visitTypeVariable(this, p);
1759         }
1760     }
1761 
1762     /** A captured type variable comes from wildcards which can have
1763      *  both upper and lower bound.  CapturedType extends TypeVar with
1764      *  a lower bound.
1765      */
1766     public static class CapturedType extends TypeVar {
1767 
1768         public WildcardType wildcard;
1769 
1770         public CapturedType(Name name,
1771                             Symbol owner,
1772                             Type upper,
1773                             Type lower,
1774                             WildcardType wildcard) {
1775             super(name, owner, lower);
1776             this.lower = Assert.checkNonNull(lower);
1777             this.setUpperBound(upper);
1778             this.wildcard = wildcard;
1779         }
1780 
1781         public CapturedType(TypeSymbol tsym,
1782                             Type bound,
1783                             Type upper,
1784                             Type lower,
1785                             WildcardType wildcard,
1786                             TypeMetadata metadata) {
1787             super(tsym, bound, lower, metadata);
1788             this.wildcard = wildcard;
1789         }
1790 
1791         @Override
1792         public CapturedType cloneWithMetadata(TypeMetadata md) {
1793             return new CapturedType(tsym, getUpperBound(), getUpperBound(), lower, wildcard, md) {
1794                 @Override
1795                 public Type baseType() { return CapturedType.this.baseType(); }
1796 
1797                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1798                 public Type getUpperBound() { return CapturedType.this.getUpperBound(); }
1799 
1800                 public void setUpperBound(Type bound) { CapturedType.this.setUpperBound(bound); }
1801             };
1802         }
1803 
1804         @Override
1805         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1806             return v.visitCapturedType(this, s);
1807         }
1808 
1809         @Override
1810         public boolean isCaptured() {
1811             return true;
1812         }
1813 
1814         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1815         public String toString() {
1816             StringBuilder sb = new StringBuilder();
1817             appendAnnotationsString(sb);
1818             sb.append(&quot;capture#&quot;);
1819             sb.append((hashCode() &amp; 0xFFFFFFFFL) % Printer.PRIME);
1820             sb.append(&quot; of &quot;);
1821             sb.append(wildcard);
1822             return sb.toString();
1823         }
1824     }
1825 
1826     public static abstract class DelegatedType extends Type {
1827         public Type qtype;
1828         public TypeTag tag;
1829 
1830         public DelegatedType(TypeTag tag, Type qtype) {
1831             this(tag, qtype, TypeMetadata.EMPTY);
1832         }
1833 
1834         public DelegatedType(TypeTag tag, Type qtype,
1835                              TypeMetadata metadata) {
1836             super(qtype.tsym, metadata);
1837             this.tag = tag;
1838             this.qtype = qtype;
1839         }
1840 
1841         public TypeTag getTag() { return tag; }
1842         @DefinedBy(Api.LANGUAGE_MODEL)
1843         public String toString() { return qtype.toString(); }
1844         public List&lt;Type&gt; getTypeArguments() { return qtype.getTypeArguments(); }
1845         public Type getEnclosingType() { return qtype.getEnclosingType(); }
1846         public List&lt;Type&gt; getParameterTypes() { return qtype.getParameterTypes(); }
1847         public Type getReturnType() { return qtype.getReturnType(); }
1848         public Type getReceiverType() { return qtype.getReceiverType(); }
1849         public List&lt;Type&gt; getThrownTypes() { return qtype.getThrownTypes(); }
1850         public List&lt;Type&gt; allparams() { return qtype.allparams(); }
1851         public Type getUpperBound() { return qtype.getUpperBound(); }
1852         public boolean isErroneous() { return qtype.isErroneous(); }
1853     }
1854 
1855     /**
1856      * The type of a generic method type. It consists of a method type and
1857      * a list of method type-parameters that are used within the method
1858      * type.
1859      */
1860     public static class ForAll extends DelegatedType implements ExecutableType {
1861         public List&lt;Type&gt; tvars;
1862 
1863         public ForAll(List&lt;Type&gt; tvars, Type qtype) {
1864             super(FORALL, (MethodType)qtype);
1865             this.tvars = tvars;
1866         }
1867 
1868         @Override
1869         public ForAll cloneWithMetadata(TypeMetadata md) {
1870             throw new AssertionError(&quot;Cannot add metadata to a forall type&quot;);
1871         }
1872 
1873         @Override
1874         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1875             return v.visitForAll(this, s);
1876         }
1877 
1878         @DefinedBy(Api.LANGUAGE_MODEL)
1879         public String toString() {
1880             StringBuilder sb = new StringBuilder();
1881             appendAnnotationsString(sb);
1882             sb.append(&#39;&lt;&#39;);
1883             sb.append(tvars);
1884             sb.append(&#39;&gt;&#39;);
1885             sb.append(qtype);
1886             return sb.toString();
1887         }
1888 
1889         public List&lt;Type&gt; getTypeArguments()   { return tvars; }
1890 
1891         public boolean isErroneous()  {
1892             return qtype.isErroneous();
1893         }
1894 
1895         public boolean contains(Type elem) {
1896             return qtype.contains(elem);
1897         }
1898 
1899         public MethodType asMethodType() {
1900             return (MethodType)qtype;
1901         }
1902 
1903         public void complete() {
1904             for (List&lt;Type&gt; l = tvars; l.nonEmpty(); l = l.tail) {
1905                 ((TypeVar)l.head).getUpperBound().complete();
1906             }
1907             qtype.complete();
1908         }
1909 
1910         @DefinedBy(Api.LANGUAGE_MODEL)
1911         public List&lt;TypeVar&gt; getTypeVariables() {
1912             return List.convert(TypeVar.class, getTypeArguments());
1913         }
1914 
1915         @DefinedBy(Api.LANGUAGE_MODEL)
1916         public TypeKind getKind() {
1917             return TypeKind.EXECUTABLE;
1918         }
1919 
1920         @DefinedBy(Api.LANGUAGE_MODEL)
1921         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1922             return v.visitExecutable(this, p);
1923         }
1924     }
1925 
1926     /** A class for inference variables, for use during method/diamond type
1927      *  inference. An inference variable has upper/lower bounds and a set
1928      *  of equality constraints. Such bounds are set during subtyping, type-containment,
1929      *  type-equality checks, when the types being tested contain inference variables.
1930      *  A change listener can be attached to an inference variable, to receive notifications
1931      *  whenever the bounds of an inference variable change.
1932      */
1933     public static class UndetVar extends DelegatedType {
1934 
1935         enum Kind {
1936             NORMAL,
1937             CAPTURED,
1938             THROWS;
1939         }
1940 
1941         /** Inference variable change listener. The listener method is called
1942          *  whenever a change to the inference variable&#39;s bounds occurs
1943          */
1944         public interface UndetVarListener {
1945             /** called when some inference variable bounds (of given kinds ibs) change */
1946             void varBoundChanged(UndetVar uv, InferenceBound ib, Type bound, boolean update);
1947             /** called when the inferred type is set on some inference variable */
1948             default void varInstantiated(UndetVar uv) { Assert.error(); }
1949         }
1950 
1951         /**
1952          * Inference variable bound kinds
1953          */
1954         public enum InferenceBound {
1955             /** lower bounds */
1956             LOWER {
1957                 public InferenceBound complement() { return UPPER; }
1958             },
1959             /** equality constraints */
1960             EQ {
1961                 public InferenceBound complement() { return EQ; }
1962             },
1963             /** upper bounds */
1964             UPPER {
1965                 public InferenceBound complement() { return LOWER; }
1966             };
1967 
1968             public abstract InferenceBound complement();
1969 
1970             public boolean lessThan(InferenceBound that) {
1971                 if (that == this) {
1972                     return false;
1973                 } else {
1974                     switch (that) {
1975                         case UPPER: return true;
1976                         case LOWER: return false;
1977                         case EQ: return (this != UPPER);
1978                         default:
1979                             Assert.error(&quot;Cannot get here!&quot;);
1980                             return false;
1981                     }
1982                 }
1983             }
1984         }
1985 
1986         /** list of incorporation actions (used by the incorporation engine). */
1987         public ArrayDeque&lt;IncorporationAction&gt; incorporationActions = new ArrayDeque&lt;&gt;();
1988 
1989         /** inference variable bounds */
1990         protected Map&lt;InferenceBound, List&lt;Type&gt;&gt; bounds;
1991 
1992         /** inference variable&#39;s inferred type (set from Infer.java) */
1993         private Type inst = null;
1994 
1995         /** number of declared (upper) bounds */
1996         public int declaredCount;
1997 
1998         /** inference variable&#39;s change listener */
1999         public UndetVarListener listener = null;
2000 
2001         Kind kind;
2002 
2003         @Override
2004         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2005             return v.visitUndetVar(this, s);
2006         }
2007 
2008         public UndetVar(TypeVar origin, UndetVarListener listener, Types types) {
2009             // This is a synthesized internal type, so we cannot annotate it.
2010             super(UNDETVAR, origin);
2011             this.kind = origin.isCaptured() ?
2012                     Kind.CAPTURED :
2013                     Kind.NORMAL;
2014             this.listener = listener;
2015             bounds = new EnumMap&lt;&gt;(InferenceBound.class);
2016             List&lt;Type&gt; declaredBounds = types.getBounds(origin);
2017             declaredCount = declaredBounds.length();
2018             bounds.put(InferenceBound.UPPER, List.nil());
2019             bounds.put(InferenceBound.LOWER, List.nil());
2020             bounds.put(InferenceBound.EQ, List.nil());
2021             for (Type t : declaredBounds.reverse()) {
2022                 //add bound works in reverse order
2023                 addBound(InferenceBound.UPPER, t, types, true);
2024             }
2025             if (origin.isCaptured() &amp;&amp; !origin.lower.hasTag(BOT)) {
2026                 //add lower bound if needed
2027                 addBound(InferenceBound.LOWER, origin.lower, types, true);
2028             }
2029         }
2030 
2031         @DefinedBy(Api.LANGUAGE_MODEL)
2032         public String toString() {
2033             StringBuilder sb = new StringBuilder();
2034             appendAnnotationsString(sb);
2035             if (inst == null) {
2036                 sb.append(qtype);
2037                 sb.append(&#39;?&#39;);
2038             } else {
2039                 sb.append(inst);
2040             }
2041             return sb.toString();
2042         }
2043 
2044         public String debugString() {
2045             String result = &quot;inference var = &quot; + qtype + &quot;\n&quot;;
2046             if (inst != null) {
2047                 result += &quot;inst = &quot; + inst + &#39;\n&#39;;
2048             }
2049             for (InferenceBound bound: InferenceBound.values()) {
2050                 List&lt;Type&gt; aboundList = bounds.get(bound);
2051                 if (aboundList != null &amp;&amp; aboundList.size() &gt; 0) {
2052                     result += bound + &quot; = &quot; + aboundList + &#39;\n&#39;;
2053                 }
2054             }
2055             return result;
2056         }
2057 
2058         public void setThrow() {
2059             if (this.kind == Kind.CAPTURED) {
2060                 //invalid state transition
2061                 throw new IllegalStateException();
2062             }
2063             this.kind = Kind.THROWS;
2064         }
2065 
2066         /**
2067          * Returns a new copy of this undet var.
2068          */
2069         public UndetVar dup(Types types) {
2070             UndetVar uv2 = new UndetVar((TypeVar)qtype, listener, types);
2071             dupTo(uv2, types);
2072             return uv2;
2073         }
2074 
2075         /**
2076          * Dumps the contents of this undet var on another undet var.
2077          */
2078         public void dupTo(UndetVar uv2, Types types) {
2079             uv2.listener = null;
2080             uv2.bounds.clear();
2081             for (InferenceBound ib : InferenceBound.values()) {
2082                 uv2.bounds.put(ib, List.nil());
2083                 for (Type t : getBounds(ib)) {
2084                     uv2.addBound(ib, t, types, true);
2085                 }
2086             }
2087             uv2.inst = inst;
2088             uv2.listener = listener;
2089             uv2.incorporationActions = new ArrayDeque&lt;&gt;();
2090             for (IncorporationAction action : incorporationActions) {
2091                 uv2.incorporationActions.add(action.dup(uv2));
2092             }
2093             uv2.kind = kind;
2094         }
2095 
2096         @Override
2097         public UndetVar cloneWithMetadata(TypeMetadata md) {
2098             throw new AssertionError(&quot;Cannot add metadata to an UndetVar type&quot;);
2099         }
2100 
2101         @Override
2102         public boolean isPartial() {
2103             return true;
2104         }
2105 
2106         @Override
2107         public Type baseType() {
2108             return (inst == null) ? this : inst.baseType();
2109         }
2110 
2111         public Type getInst() {
2112             return inst;
2113         }
2114 
2115         public void setInst(Type inst) {
2116             this.inst = inst;
2117             if (listener != null) {
2118                 listener.varInstantiated(this);
2119             }
2120         }
2121 
2122         /** get all bounds of a given kind */
2123         public List&lt;Type&gt; getBounds(InferenceBound... ibs) {
2124             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2125             for (InferenceBound ib : ibs) {
2126                 buf.appendList(bounds.get(ib));
2127             }
2128             return buf.toList();
2129         }
2130 
2131         /** get the list of declared (upper) bounds */
2132         public List&lt;Type&gt; getDeclaredBounds() {
2133             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2134             int count = 0;
2135             for (Type b : getBounds(InferenceBound.UPPER)) {
2136                 if (count++ == declaredCount) break;
2137                 buf.append(b);
2138             }
2139             return buf.toList();
2140         }
2141 
2142         /** internal method used to override an undetvar bounds */
2143         public void setBounds(InferenceBound ib, List&lt;Type&gt; newBounds) {
2144             bounds.put(ib, newBounds);
2145         }
2146 
2147         /** add a bound of a given kind - this might trigger listener notification */
2148         public final void addBound(InferenceBound ib, Type bound, Types types) {
2149             // Per JDK-8075793: in pre-8 sources, follow legacy javac behavior
2150             // when capture variables are inferred as bounds: for lower bounds,
2151             // map to the capture variable&#39;s upper bound; for upper bounds,
2152             // if the capture variable has a lower bound, map to that type
2153             if (types.mapCapturesToBounds) {
2154                 switch (ib) {
2155                     case LOWER:
2156                         bound = types.cvarUpperBound(bound);
2157                         break;
2158                     case UPPER:
2159                         Type altBound = types.cvarLowerBound(bound);
2160                         if (!altBound.hasTag(TypeTag.BOT)) bound = altBound;
2161                         break;
2162                 }
2163             }
2164             addBound(ib, bound, types, false);
2165         }
2166 
2167         @SuppressWarnings(&quot;fallthrough&quot;)
2168         private void addBound(InferenceBound ib, Type bound, Types types, boolean update) {
2169             if (kind == Kind.CAPTURED &amp;&amp; !update) {
2170                 //Captured inference variables bounds must not be updated during incorporation,
2171                 //except when some inference variable (beta) has been instantiated in the
2172                 //right-hand-side of a &#39;C&lt;alpha&gt; = capture(C&lt;? extends/super beta&gt;) constraint.
2173                 if (bound.hasTag(UNDETVAR) &amp;&amp; !((UndetVar)bound).isCaptured()) {
2174                     //If the new incoming bound is itself a (regular) inference variable,
2175                     //then we are allowed to propagate this inference variable bounds to it.
2176                     ((UndetVar)bound).addBound(ib.complement(), this, types, false);
2177                 }
2178             } else {
2179                 Type bound2 = bound.map(toTypeVarMap).baseType();
2180                 List&lt;Type&gt; prevBounds = bounds.get(ib);
2181                 if (bound == qtype) return;
2182                 for (Type b : prevBounds) {
2183                     //check for redundancy - do not add same bound twice
2184                     if (types.isSameType(b, bound2)) return;
2185                 }
2186                 bounds.put(ib, prevBounds.prepend(bound2));
2187                 notifyBoundChange(ib, bound2, false);
2188             }
2189         }
2190         //where
2191             TypeMapping&lt;Void&gt; toTypeVarMap = new StructuralTypeMapping&lt;Void&gt;() {
2192                 @Override
2193                 public Type visitUndetVar(UndetVar uv, Void _unused) {
2194                     return uv.inst != null ? uv.inst : uv.qtype;
2195                 }
2196             };
2197 
2198         /** replace types in all bounds - this might trigger listener notification */
2199         public void substBounds(List&lt;Type&gt; from, List&lt;Type&gt; to, Types types) {
2200             final ListBuffer&lt;Pair&lt;InferenceBound, Type&gt;&gt;  boundsChanged = new ListBuffer&lt;&gt;();
2201             UndetVarListener prevListener = listener;
2202             try {
2203                 //setup new listener for keeping track of changed bounds
2204                 listener = (uv, ib, t, _ignored) -&gt; {
2205                     Assert.check(uv == UndetVar.this);
2206                     boundsChanged.add(new Pair&lt;&gt;(ib, t));
2207                 };
2208                 for (Map.Entry&lt;InferenceBound, List&lt;Type&gt;&gt; _entry : bounds.entrySet()) {
2209                     InferenceBound ib = _entry.getKey();
2210                     List&lt;Type&gt; prevBounds = _entry.getValue();
2211                     ListBuffer&lt;Type&gt; newBounds = new ListBuffer&lt;&gt;();
2212                     ListBuffer&lt;Type&gt; deps = new ListBuffer&lt;&gt;();
2213                     //step 1 - re-add bounds that are not dependent on ivars
2214                     for (Type t : prevBounds) {
2215                         if (!t.containsAny(from)) {
2216                             newBounds.append(t);
2217                         } else {
2218                             deps.append(t);
2219                         }
2220                     }
2221                     //step 2 - replace bounds
2222                     bounds.put(ib, newBounds.toList());
2223                     //step 3 - for each dependency, add new replaced bound
2224                     for (Type dep : deps) {
2225                         addBound(ib, types.subst(dep, from, to), types, true);
2226                     }
2227                 }
2228             } finally {
2229                 listener = prevListener;
2230                 for (Pair&lt;InferenceBound, Type&gt; boundUpdate : boundsChanged) {
2231                     notifyBoundChange(boundUpdate.fst, boundUpdate.snd, true);
2232                 }
2233             }
2234         }
2235 
2236         private void notifyBoundChange(InferenceBound ib, Type bound, boolean update) {
2237             if (listener != null) {
2238                 listener.varBoundChanged(this, ib, bound, update);
2239             }
2240         }
2241 
2242         public final boolean isCaptured() {
2243             return kind == Kind.CAPTURED;
2244         }
2245 
2246         public final boolean isThrows() {
2247             return kind == Kind.THROWS;
2248         }
2249     }
2250 
2251     /** Represents NONE.
2252      */
2253     public static class JCNoType extends Type implements NoType {
2254         public JCNoType() {
2255             // Need to use List.nil(), because JCNoType constructor
2256             // gets called in static initializers in Type, where
2257             // noAnnotations is also defined.
2258             super(null, TypeMetadata.EMPTY);
2259         }
2260 
2261         @Override
2262         public JCNoType cloneWithMetadata(TypeMetadata md) {
2263             throw new AssertionError(&quot;Cannot add metadata to a JCNoType&quot;);
2264         }
2265 
2266         @Override
2267         public TypeTag getTag() {
2268             return NONE;
2269         }
2270 
2271         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2272         public TypeKind getKind() {
2273             return TypeKind.NONE;
2274         }
2275 
2276         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2277         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2278             return v.visitNoType(this, p);
2279         }
2280 
2281         @Override
2282         public boolean isCompound() { return false; }
2283     }
2284 
2285     /** Represents VOID.
2286      */
2287     public static class JCVoidType extends Type implements NoType {
2288 
2289         public JCVoidType() {
2290             // Void cannot be annotated
2291             super(null, TypeMetadata.EMPTY);
2292         }
2293 
2294         @Override
2295         public JCVoidType cloneWithMetadata(TypeMetadata md) {
2296             throw new AssertionError(&quot;Cannot add metadata to a void type&quot;);
2297         }
2298 
2299         @Override
2300         public TypeTag getTag() {
2301             return VOID;
2302         }
2303 
2304         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2305         public TypeKind getKind() {
2306             return TypeKind.VOID;
2307         }
2308 
2309         @Override
2310         public boolean isCompound() { return false; }
2311 
2312         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2313         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2314             return v.visitNoType(this, p);
2315         }
2316 
2317         @Override
2318         public boolean isPrimitiveOrVoid() {
2319             return true;
2320         }
2321     }
2322 
2323     static class BottomType extends Type implements NullType {
2324         public BottomType() {
2325             // Bottom is a synthesized internal type, so it cannot be annotated
2326             super(null, TypeMetadata.EMPTY);
2327         }
2328 
2329         @Override
2330         public BottomType cloneWithMetadata(TypeMetadata md) {
2331             throw new AssertionError(&quot;Cannot add metadata to a bottom type&quot;);
2332         }
2333 
2334         @Override
2335         public TypeTag getTag() {
2336             return BOT;
2337         }
2338 
2339         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2340         public TypeKind getKind() {
2341             return TypeKind.NULL;
2342         }
2343 
2344         @Override
2345         public boolean isCompound() { return false; }
2346 
2347         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2348         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2349             return v.visitNull(this, p);
2350         }
2351 
2352         @Override
2353         public Type constType(Object value) {
2354             return this;
2355         }
2356 
2357         @Override
2358         public String stringValue() {
2359             return &quot;null&quot;;
2360         }
2361 
2362         @Override
2363         public boolean isNullOrReference() {
2364             return true;
2365         }
2366 
2367     }
2368 
2369     public static class ErrorType extends ClassType
2370             implements javax.lang.model.type.ErrorType {
2371 
2372         private Type originalType = null;
2373 
2374         public ErrorType(ClassSymbol c, Type originalType) {
2375             this(originalType, c);
2376             c.type = this;
2377             c.kind = ERR;
2378             c.members_field = new Scope.ErrorScope(c);
2379         }
2380 
2381         public ErrorType(Type originalType, TypeSymbol tsym) {
2382             super(noType, List.nil(), null);
2383             this.tsym = tsym;
2384             this.originalType = (originalType == null ? noType : originalType);
2385         }
2386 
2387         private ErrorType(Type originalType, TypeSymbol tsym,
2388                           TypeMetadata metadata) {
2389             super(noType, List.nil(), null, metadata);
2390             this.tsym = tsym;
2391             this.originalType = (originalType == null ? noType : originalType);
2392         }
2393 
2394         @Override
2395         public ErrorType cloneWithMetadata(TypeMetadata md) {
2396             return new ErrorType(originalType, tsym, md) {
2397                 @Override
2398                 public Type baseType() { return ErrorType.this.baseType(); }
2399             };
2400         }
2401 
2402         @Override
2403         public TypeTag getTag() {
2404             return ERROR;
2405         }
2406 
2407         @Override
2408         public boolean isPartial() {
2409             return true;
2410         }
2411 
2412         @Override
2413         public boolean isReference() {
2414             return true;
2415         }
2416 
2417         @Override
2418         public boolean isNullOrReference() {
2419             return true;
2420         }
2421 
2422         public ErrorType(Name name, TypeSymbol container, Type originalType) {
2423             this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);
2424         }
2425 
2426         @Override
2427         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2428             return v.visitErrorType(this, s);
2429         }
2430 
2431         public Type constType(Object constValue) { return this; }
2432         @DefinedBy(Api.LANGUAGE_MODEL)
2433         public Type getEnclosingType()           { return Type.noType; }
2434         public Type getReturnType()              { return this; }
2435         public Type asSub(Symbol sym)            { return this; }
2436 
2437         public boolean isGenType(Type t)         { return true; }
2438         public boolean isErroneous()             { return true; }
2439         public boolean isCompound()              { return false; }
2440         public boolean isInterface()             { return false; }
2441 
2442         public List&lt;Type&gt; allparams()            { return List.nil(); }
2443         @DefinedBy(Api.LANGUAGE_MODEL)
2444         public List&lt;Type&gt; getTypeArguments()     { return List.nil(); }
2445 
2446         @DefinedBy(Api.LANGUAGE_MODEL)
2447         public TypeKind getKind() {
2448             return TypeKind.ERROR;
2449         }
2450 
2451         public Type getOriginalType() {
2452             return originalType;
2453         }
2454 
2455         @DefinedBy(Api.LANGUAGE_MODEL)
2456         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2457             return v.visitError(this, p);
2458         }
2459     }
2460 
2461     public static class UnknownType extends Type {
2462 
2463         public UnknownType() {
2464             // Unknown is a synthesized internal type, so it cannot be
2465             // annotated.
2466             super(null, TypeMetadata.EMPTY);
2467         }
2468 
2469         @Override
2470         public UnknownType cloneWithMetadata(TypeMetadata md) {
2471             throw new AssertionError(&quot;Cannot add metadata to an unknown type&quot;);
2472         }
2473 
2474         @Override
2475         public TypeTag getTag() {
2476             return UNKNOWN;
2477         }
2478 
2479         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2480         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2481             return v.visitUnknown(this, p);
2482         }
2483 
2484         @Override
2485         public boolean isPartial() {
2486             return true;
2487         }
2488     }
2489 
2490     /**
2491      * A visitor for types.  A visitor is used to implement operations
2492      * (or relations) on types.  Most common operations on types are
2493      * binary relations and this interface is designed for binary
2494      * relations, that is, operations of the form
2495      * Type&amp;nbsp;&amp;times;&amp;nbsp;S&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2496      * &lt;!-- In plain text: Type x S -&gt; R --&gt;
2497      *
2498      * @param &lt;R&gt; the return type of the operation implemented by this
2499      * visitor; use Void if no return type is needed.
2500      * @param &lt;S&gt; the type of the second argument (the first being the
2501      * type itself) of the operation implemented by this visitor; use
2502      * Void if a second argument is not needed.
2503      */
2504     public interface Visitor&lt;R,S&gt; {
2505         R visitClassType(ClassType t, S s);
2506         R visitWildcardType(WildcardType t, S s);
2507         R visitArrayType(ArrayType t, S s);
2508         R visitMethodType(MethodType t, S s);
2509         R visitPackageType(PackageType t, S s);
2510         R visitModuleType(ModuleType t, S s);
2511         R visitTypeVar(TypeVar t, S s);
2512         R visitCapturedType(CapturedType t, S s);
2513         R visitForAll(ForAll t, S s);
2514         R visitUndetVar(UndetVar t, S s);
2515         R visitErrorType(ErrorType t, S s);
2516         R visitType(Type t, S s);
2517     }
2518 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
  50 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  51 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  52 import com.sun.tools.javac.jvm.*;
  53 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  56 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  78 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  79 
  80 /** This is the main context-dependent analysis phase in GJC. It
  81  *  encompasses name resolution, type checking and constant folding as
  82  *  subtasks. Some subtasks involve auxiliary classes.
  83  *  @see Check
  84  *  @see Resolve
  85  *  @see ConstFold
  86  *  @see Infer
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class Attr extends JCTree.Visitor {
  94     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  95 
  96     final Names names;
  97     final Log log;
  98     final Symtab syms;
  99     final Resolve rs;
 100     final Operators operators;
 101     final Infer infer;
 102     final Analyzer analyzer;
 103     final DeferredAttr deferredAttr;
 104     final Check chk;
 105     final Flow flow;
 106     final MemberEnter memberEnter;
 107     final TypeEnter typeEnter;
 108     final TreeMaker make;
 109     final ConstFold cfolder;
 110     final Enter enter;
 111     final Target target;
 112     final Types types;
 113     final Preview preview;
 114     final JCDiagnostic.Factory diags;
 115     final TypeAnnotations typeAnnotations;
 116     final DeferredLintHandler deferredLintHandler;
 117     final TypeEnvs typeEnvs;
 118     final Dependencies dependencies;
 119     final Annotate annotate;
 120     final ArgumentAttr argumentAttr;
 121     final MatchBindingsComputer matchBindingsComputer;
 122 
 123     public static Attr instance(Context context) {
 124         Attr instance = context.get(attrKey);
 125         if (instance == null)
 126             instance = new Attr(context);
 127         return instance;
 128     }
 129 
 130     protected Attr(Context context) {
 131         context.put(attrKey, this);
 132 
 133         names = Names.instance(context);
 134         log = Log.instance(context);
 135         syms = Symtab.instance(context);
 136         rs = Resolve.instance(context);
 137         operators = Operators.instance(context);
 138         chk = Check.instance(context);
 139         flow = Flow.instance(context);
 140         memberEnter = MemberEnter.instance(context);
 141         typeEnter = TypeEnter.instance(context);
 142         make = TreeMaker.instance(context);
 143         enter = Enter.instance(context);
 144         infer = Infer.instance(context);
 145         analyzer = Analyzer.instance(context);
 146         deferredAttr = DeferredAttr.instance(context);
 147         cfolder = ConstFold.instance(context);
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<a name="1" id="anc1"></a><span class="line-removed"> 174         allowGenericsOverValues = options.isSet(&quot;allowGenericsOverValues&quot;);</span>
 175         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);
 176         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);
 177 
 178         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 179         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 180         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 181         methodAttrInfo = new MethodAttrInfo();
 182         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 183         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 184         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 185     }
 186 
 187     /** Switch: support target-typing inference
 188      */
 189     boolean allowPoly;
 190 
 191     /** Switch: support type annotations.
 192      */
 193     boolean allowTypeAnnos;
 194 
 195     /** Switch: support lambda expressions ?
 196      */
 197     boolean allowLambda;
 198 
 199     /** Switch: support default methods ?
 200      */
 201     boolean allowDefaultMethods;
 202 
 203     /** Switch: allow inline types?
 204      */
 205     boolean allowInlineTypes;
 206 
 207     /** Switch: static interface methods enabled?
 208      */
 209     boolean allowStaticInterfaceMethods;
 210 
 211     /** Switch: reifiable types in instanceof enabled?
 212      */
 213     boolean allowReifiableTypesInInstanceof;
 214 
 215     /**
 216      * Switch: warn about use of variable before declaration?
 217      * RFE: 6425594
 218      */
 219     boolean useBeforeDeclarationWarning;
 220 
<a name="2" id="anc2"></a><span class="line-removed"> 221     /**</span>
<span class="line-removed"> 222      * Switch: Allow value types to parameterize generic types?</span>
<span class="line-removed"> 223      */</span>
<span class="line-removed"> 224     boolean allowGenericsOverValues;</span>
<span class="line-removed"> 225 </span>
 226     /**
 227      * Switch: Allow value types with no instance state?
 228      */
 229     boolean allowEmptyValues;
 230 
 231     /**
 232      * Switch: Allow value type member cycles?
 233      */
 234     boolean allowValueMemberCycles;
 235 
 236     /**
 237      * Switch: name of source level; used for error reporting.
 238      */
 239     String sourceName;
 240 
 241     /** Check kind and type of given tree against protokind and prototype.
 242      *  If check succeeds, store type in tree and return it.
 243      *  If check fails, store errType in tree and return it.
 244      *  No checks are performed if the prototype is a method type.
 245      *  It is not necessary in this case since we know that kind and type
 246      *  are correct.
 247      *
 248      *  @param tree     The tree whose kind and type is checked
 249      *  @param found    The computed type of the tree
 250      *  @param ownkind  The computed kind of the tree
 251      *  @param resultInfo  The expected result of the tree
 252      */
 253     Type check(final JCTree tree,
 254                final Type found,
 255                final KindSelector ownkind,
 256                final ResultInfo resultInfo) {
 257         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 258         Type owntype;
 259         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 260                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 261                 !resultInfo.pt.hasTag(FORALL);
 262         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 263             log.error(tree.pos(),
 264                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 265                                             ownkind.kindNames()));
 266             owntype = types.createErrorType(found);
 267         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 268             //delay the check if there are inference variables in the found type
 269             //this means we are dealing with a partially inferred poly expression
 270             owntype = shouldCheck ? resultInfo.pt : found;
 271             if (resultInfo.checkMode.installPostInferenceHook()) {
 272                 inferenceContext.addFreeTypeListener(List.of(found),
 273                         instantiatedContext -&gt; {
 274                             ResultInfo pendingResult =
 275                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 276                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 277                         });
 278             }
 279         } else {
 280             owntype = shouldCheck ?
 281             resultInfo.check(tree, found) :
 282             found;
 283         }
 284         if (resultInfo.checkMode.updateTreeType()) {
 285             tree.type = owntype;
 286         }
 287         return owntype;
 288     }
 289 
 290     /** Is given blank final variable assignable, i.e. in a scope where it
 291      *  may be assigned to even though it is final?
 292      *  @param v      The blank final variable.
 293      *  @param env    The current environment.
 294      */
 295     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 296         Symbol owner = env.info.scope.owner;
 297            // owner refers to the innermost variable, method or
 298            // initializer block declaration at this point.
 299         return
 300             v.owner == owner
 301             ||
 302             ((owner.name == names.init ||    // i.e. we are in a constructor
 303               owner.kind == VAR ||           // i.e. we are in a variable initializer
 304               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 305              &amp;&amp;
 306              v.owner == owner.owner
 307              &amp;&amp;
 308              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 309     }
 310 
 311     /** Check that variable can be assigned to.
 312      *  @param pos    The current source code position.
 313      *  @param v      The assigned variable
 314      *  @param base   If the variable is referred to in a Select, the part
 315      *                to the left of the `.&#39;, null otherwise.
 316      *  @param env    The current environment.
 317      */
 318     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 319         if (v.name == names._this) {
 320             log.error(pos, Errors.CantAssignValToThis);
 321         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 322             ((v.flags() &amp; HASINIT) != 0
 323              ||
 324              !((base == null ||
 325                TreeInfo.isThisQualifier(base)) &amp;&amp;
 326                isAssignableAsBlankFinal(v, env)))) {
 327             if (v.isResourceVariable()) { //TWR resource
 328                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 329             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 330                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 331             } else {
 332                 boolean complain = true;
 333                 /* Allow updates to instance fields of value classes by any method in the same nest via the
 334                    withfield operator -This does not result in mutation of final fields; the code generator
 335                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.
 336                 */
 337                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {
 338                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())
 339                         complain = false;
 340                 }
 341                 if (complain)
 342                     log.error(pos, Errors.CantAssignValToFinalVar(v));
 343             }
 344         }
 345     }
 346 
 347     /** Does tree represent a static reference to an identifier?
 348      *  It is assumed that tree is either a SELECT or an IDENT.
 349      *  We have to weed out selects from non-type names here.
 350      *  @param tree    The candidate tree.
 351      */
 352     boolean isStaticReference(JCTree tree) {
 353         if (tree.hasTag(SELECT)) {
 354             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 355             if (lsym == null || lsym.kind != TYP) {
 356                 return false;
 357             }
 358         }
 359         return true;
 360     }
 361 
 362     /** Is this symbol a type?
 363      */
 364     static boolean isType(Symbol sym) {
 365         return sym != null &amp;&amp; sym.kind == TYP;
 366     }
 367 
 368     /** The current `this&#39; symbol.
 369      *  @param env    The current environment.
 370      */
 371     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 372         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 373     }
 374 
 375     /** Attribute a parsed identifier.
 376      * @param tree Parsed identifier name
 377      * @param topLevel The toplevel to use
 378      */
 379     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 380         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 381         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 382                                            syms.errSymbol.name,
 383                                            null, null, null, null);
 384         localEnv.enclClass.sym = syms.errSymbol;
 385         return attribIdent(tree, localEnv);
 386     }
 387 
 388     /** Attribute a parsed identifier.
 389      * @param tree Parsed identifier name
 390      * @param env The env to use
 391      */
 392     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 393         return tree.accept(identAttributer, env);
 394     }
 395     // where
 396         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 397         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 398             @Override @DefinedBy(Api.COMPILER_TREE)
 399             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 400                 Symbol site = visit(node.getExpression(), env);
 401                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 402                     return site;
 403                 Name name = (Name)node.getIdentifier();
 404                 if (site.kind == PCK) {
 405                     env.toplevel.packge = (PackageSymbol)site;
 406                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 407                             KindSelector.TYP_PCK);
 408                 } else {
 409                     env.enclClass.sym = (ClassSymbol)site;
 410                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 411                 }
 412             }
 413 
 414             @Override @DefinedBy(Api.COMPILER_TREE)
 415             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 416                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 417             }
 418         }
 419 
 420     public Type coerce(Type etype, Type ttype) {
 421         return cfolder.coerce(etype, ttype);
 422     }
 423 
 424     public Type attribType(JCTree node, TypeSymbol sym) {
 425         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 426         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 427         return attribTree(node, localEnv, unknownTypeInfo);
 428     }
 429 
 430     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 431         // Attribute qualifying package or class.
 432         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 433         return attribTree(s.selected, env,
 434                           new ResultInfo(tree.staticImport ?
 435                                          KindSelector.TYP : KindSelector.TYP_PCK,
 436                        Type.noType));
 437     }
 438 
 439     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 440         return attribToTree(expr, env, tree, unknownExprInfo);
 441     }
 442 
 443     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 444         return attribToTree(stmt, env, tree, statInfo);
 445     }
 446 
 447     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 448         breakTree = tree;
 449         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 450         try {
 451             deferredAttr.attribSpeculative(root, env, resultInfo,
 452                     null, DeferredAttr.AttributionMode.ANALYZER,
 453                     argumentAttr.withLocalCacheContext());
 454         } catch (BreakAttr b) {
 455             return b.env;
 456         } catch (AssertionError ae) {
 457             if (ae.getCause() instanceof BreakAttr) {
 458                 return ((BreakAttr)(ae.getCause())).env;
 459             } else {
 460                 throw ae;
 461             }
 462         } finally {
 463             breakTree = null;
 464             log.useSource(prev);
 465         }
 466         return env;
 467     }
 468 
 469     private JCTree breakTree = null;
 470 
 471     private static class BreakAttr extends RuntimeException {
 472         static final long serialVersionUID = -6924771130405446405L;
 473         private transient Env&lt;AttrContext&gt; env;
 474         private BreakAttr(Env&lt;AttrContext&gt; env) {
 475             this.env = env;
 476         }
 477     }
 478 
 479     /**
 480      * Mode controlling behavior of Attr.Check
 481      */
 482     enum CheckMode {
 483 
 484         NORMAL,
 485 
 486         /**
 487          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 488          * that the captured var cache in {@code InferenceContext} will be used in read-only
 489          * mode when performing inference checks.
 490          */
 491         NO_TREE_UPDATE {
 492             @Override
 493             public boolean updateTreeType() {
 494                 return false;
 495             }
 496         },
 497         /**
 498          * Mode signalling that caller will manage free types in tree decorations.
 499          */
 500         NO_INFERENCE_HOOK {
 501             @Override
 502             public boolean installPostInferenceHook() {
 503                 return false;
 504             }
 505         };
 506 
 507         public boolean updateTreeType() {
 508             return true;
 509         }
 510         public boolean installPostInferenceHook() {
 511             return true;
 512         }
 513     }
 514 
 515 
 516     class ResultInfo {
 517         final KindSelector pkind;
 518         final Type pt;
 519         final CheckContext checkContext;
 520         final CheckMode checkMode;
 521 
 522         ResultInfo(KindSelector pkind, Type pt) {
 523             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 524         }
 525 
 526         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 527             this(pkind, pt, chk.basicHandler, checkMode);
 528         }
 529 
 530         protected ResultInfo(KindSelector pkind,
 531                              Type pt, CheckContext checkContext) {
 532             this(pkind, pt, checkContext, CheckMode.NORMAL);
 533         }
 534 
 535         protected ResultInfo(KindSelector pkind,
 536                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 537             this.pkind = pkind;
 538             this.pt = pt;
 539             this.checkContext = checkContext;
 540             this.checkMode = checkMode;
 541         }
 542 
 543         /**
 544          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 545          * @param tree The tree to be type-checked.
 546          * @return true if {@ArgumentAttr} should be used.
 547          */
 548         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 549 
 550         protected Type check(final DiagnosticPosition pos, final Type found) {
 551             return chk.checkType(pos, found, pt, checkContext);
 552         }
 553 
 554         protected ResultInfo dup(Type newPt) {
 555             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 556         }
 557 
 558         protected ResultInfo dup(CheckContext newContext) {
 559             return new ResultInfo(pkind, pt, newContext, checkMode);
 560         }
 561 
 562         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 563             return new ResultInfo(pkind, newPt, newContext, checkMode);
 564         }
 565 
 566         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 567             return new ResultInfo(pkind, newPt, newContext, newMode);
 568         }
 569 
 570         protected ResultInfo dup(CheckMode newMode) {
 571             return new ResultInfo(pkind, pt, checkContext, newMode);
 572         }
 573 
 574         @Override
 575         public String toString() {
 576             if (pt != null) {
 577                 return pt.toString();
 578             } else {
 579                 return &quot;&quot;;
 580             }
 581         }
 582     }
 583 
 584     class MethodAttrInfo extends ResultInfo {
 585         public MethodAttrInfo() {
 586             this(chk.basicHandler);
 587         }
 588 
 589         public MethodAttrInfo(CheckContext checkContext) {
 590             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 591         }
 592 
 593         @Override
 594         protected boolean needsArgumentAttr(JCTree tree) {
 595             return true;
 596         }
 597 
 598         protected ResultInfo dup(Type newPt) {
 599             throw new IllegalStateException();
 600         }
 601 
 602         protected ResultInfo dup(CheckContext newContext) {
 603             return new MethodAttrInfo(newContext);
 604         }
 605 
 606         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 607             throw new IllegalStateException();
 608         }
 609 
 610         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 611             throw new IllegalStateException();
 612         }
 613 
 614         protected ResultInfo dup(CheckMode newMode) {
 615             throw new IllegalStateException();
 616         }
 617     }
 618 
 619     class RecoveryInfo extends ResultInfo {
 620 
 621         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 622             this(deferredAttrContext, Type.recoveryType);
 623         }
 624 
 625         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 626             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 627                 @Override
 628                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 629                     return deferredAttrContext;
 630                 }
 631                 @Override
 632                 public boolean compatible(Type found, Type req, Warner warn) {
 633                     return true;
 634                 }
 635                 @Override
 636                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 637                     if (pt == Type.recoveryType) {
 638                         chk.basicHandler.report(pos, details);
 639                     }
 640                 }
 641             });
 642         }
 643     }
 644 
 645     final ResultInfo statInfo;
 646     final ResultInfo varAssignmentInfo;
 647     final ResultInfo methodAttrInfo;
 648     final ResultInfo unknownExprInfo;
 649     final ResultInfo unknownTypeInfo;
 650     final ResultInfo unknownTypeExprInfo;
 651     final ResultInfo recoveryInfo;
 652 
 653     Type pt() {
 654         return resultInfo.pt;
 655     }
 656 
 657     KindSelector pkind() {
 658         return resultInfo.pkind;
 659     }
 660 
 661 /* ************************************************************************
 662  * Visitor methods
 663  *************************************************************************/
 664 
 665     /** Visitor argument: the current environment.
 666      */
 667     Env&lt;AttrContext&gt; env;
 668 
 669     /** Visitor argument: the currently expected attribution result.
 670      */
 671     ResultInfo resultInfo;
 672 
 673     /** Visitor result: the computed type.
 674      */
 675     Type result;
 676 
 677     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 678 
 679     /** Visitor method: attribute a tree, catching any completion failure
 680      *  exceptions. Return the tree&#39;s type.
 681      *
 682      *  @param tree    The tree to be visited.
 683      *  @param env     The environment visitor argument.
 684      *  @param resultInfo   The result info visitor argument.
 685      */
 686     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 687         Env&lt;AttrContext&gt; prevEnv = this.env;
 688         ResultInfo prevResult = this.resultInfo;
 689         try {
 690             this.env = env;
 691             this.resultInfo = resultInfo;
 692             if (resultInfo.needsArgumentAttr(tree)) {
 693                 result = argumentAttr.attribArg(tree, env);
 694             } else {
 695                 tree.accept(this);
 696             }
 697             matchBindings = matchBindingsComputer.finishBindings(tree,
 698                                                                  matchBindings);
 699             if (tree == breakTree &amp;&amp;
 700                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 701                 breakTreeFound(copyEnv(env));
 702             }
 703             return result;
 704         } catch (CompletionFailure ex) {
 705             tree.type = syms.errType;
 706             return chk.completionError(tree.pos(), ex);
 707         } finally {
 708             this.env = prevEnv;
 709             this.resultInfo = prevResult;
 710         }
 711     }
 712 
 713     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 714         throw new BreakAttr(env);
 715     }
 716 
 717     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 718         Env&lt;AttrContext&gt; newEnv =
 719                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 720         if (newEnv.outer != null) {
 721             newEnv.outer = copyEnv(newEnv.outer);
 722         }
 723         return newEnv;
 724     }
 725 
 726     WriteableScope copyScope(WriteableScope sc) {
 727         WriteableScope newScope = WriteableScope.create(sc.owner);
 728         List&lt;Symbol&gt; elemsList = List.nil();
 729         for (Symbol sym : sc.getSymbols()) {
 730             elemsList = elemsList.prepend(sym);
 731         }
 732         for (Symbol s : elemsList) {
 733             newScope.enter(s);
 734         }
 735         return newScope;
 736     }
 737 
 738     /** Derived visitor method: attribute an expression tree.
 739      */
 740     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 741         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 742     }
 743 
 744     /** Derived visitor method: attribute an expression tree with
 745      *  no constraints on the computed type.
 746      */
 747     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 748         return attribTree(tree, env, unknownExprInfo);
 749     }
 750 
 751     /** Derived visitor method: attribute a type tree.
 752      */
 753     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 754         Type result = attribType(tree, env, Type.noType);
 755         return result;
 756     }
 757 
 758     /** Derived visitor method: attribute a type tree.
 759      */
 760     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 761         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 762         return result;
 763     }
 764 
 765     /** Derived visitor method: attribute a statement or definition tree.
 766      */
 767     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 768         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 769         Type result = attribTree(tree, env, statInfo);
 770         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 771         return result;
 772     }
 773 
 774     /** Attribute a list of expressions, returning a list of types.
 775      */
 776     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 777         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 778         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 779             ts.append(attribExpr(l.head, env, pt));
 780         return ts.toList();
 781     }
 782 
 783     /** Attribute a list of statements, returning nothing.
 784      */
 785     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 786         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 787             attribStat(l.head, env);
 788     }
 789 
 790     /** Attribute the arguments in a method call, returning the method kind.
 791      */
 792     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 793         KindSelector kind = initialKind;
 794         for (JCExpression arg : trees) {
 795             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 796             if (argtype.hasTag(DEFERRED)) {
 797                 kind = KindSelector.of(KindSelector.POLY, kind);
 798             }
 799             argtypes.append(argtype);
 800         }
 801         return kind;
 802     }
 803 
 804     /** Attribute a type argument list, returning a list of types.
 805      *  Caller is responsible for calling checkRefTypes.
 806      */
 807     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 808         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 809         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 810             argtypes.append(attribType(l.head, env));
 811         return argtypes.toList();
 812     }
 813 
 814     /** Attribute a type argument list, returning a list of types.
 815      *  Check that all the types are references.
 816      */
 817     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 818         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 819         return chk.checkRefTypes(trees, types);
 820     }
 821 
 822     /**
 823      * Attribute type variables (of generic classes or methods).
 824      * Compound types are attributed later in attribBounds.
 825      * @param typarams the type variables to enter
 826      * @param env      the current environment
 827      */
 828     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 829         for (JCTypeParameter tvar : typarams) {
 830             TypeVar a = (TypeVar)tvar.type;
 831             a.tsym.flags_field |= UNATTRIBUTED;
 832             a.setUpperBound(Type.noType);
 833             if (!tvar.bounds.isEmpty()) {
<a name="3" id="anc3"></a><span class="line-modified"> 834                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));</span>
 835                 for (JCExpression bound : tvar.bounds.tail)
<a name="4" id="anc4"></a><span class="line-modified"> 836                     bounds = bounds.prepend(attribType(bound, env));</span>
 837                 types.setBounds(a, bounds.reverse());
 838             } else {
 839                 // if no bounds are given, assume a single bound of
 840                 // java.lang.Object.
 841                 types.setBounds(a, List.of(syms.objectType));
 842             }
 843             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 844         }
 845         if (checkCyclic) {
 846             for (JCTypeParameter tvar : typarams) {
 847                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 848             }
 849         }
 850     }
 851 
 852     /**
 853      * Attribute the type references in a list of annotations.
 854      */
 855     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 856                                Env&lt;AttrContext&gt; env) {
 857         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 858             JCAnnotation a = al.head;
 859             attribType(a.annotationType, env);
 860         }
 861     }
 862 
 863     /**
 864      * Attribute a &quot;lazy constant value&quot;.
 865      *  @param env         The env for the const value
 866      *  @param variable    The initializer for the const value
 867      *  @param type        The expected type, or null
 868      *  @see VarSymbol#setLazyConstValue
 869      */
 870     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 871                                       JCVariableDecl variable,
 872                                       Type type) {
 873 
 874         DiagnosticPosition prevLintPos
 875                 = deferredLintHandler.setPos(variable.pos());
 876 
 877         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 878         try {
 879             Type itype = attribExpr(variable.init, env, type);
 880             if (variable.isImplicitlyTyped()) {
 881                 //fixup local variable type
 882                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 883             }
 884             if (itype.constValue() != null) {
 885                 return coerce(itype, type).constValue();
 886             } else {
 887                 return null;
 888             }
 889         } finally {
 890             log.useSource(prevSource);
 891             deferredLintHandler.setPos(prevLintPos);
 892         }
 893     }
 894 
 895     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 896      *  Supertypes of anonymous inner classes are usually already attributed.
 897      *
 898      *  @param tree              The tree making up the type reference.
 899      *  @param env               The environment current at the reference.
 900      *  @param classExpected     true if only a class is expected here.
 901      *  @param interfaceExpected true if only an interface is expected here.
 902      */
 903     Type attribBase(JCTree tree,
 904                     Env&lt;AttrContext&gt; env,
 905                     boolean classExpected,
 906                     boolean interfaceExpected,
 907                     boolean checkExtensible) {
 908         Type t = tree.type != null ?
 909             tree.type :
 910             attribType(tree, env);
 911         return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);
 912     }
 913     Type checkBase(Type t,
 914                    JCTree tree,
 915                    Env&lt;AttrContext&gt; env,
 916                    boolean classExpected,
 917                    boolean interfaceExpected,
 918                    boolean checkExtensible) {
 919         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 920                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 921         if (t.tsym.isAnonymous()) {
 922             log.error(pos, Errors.CantInheritFromAnon);
 923             return types.createErrorType(t);
 924         }
 925         if (t.isErroneous())
 926             return t;
 927         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 928             // check that type variable is already visible
 929             if (t.getUpperBound() == null) {
 930                 log.error(pos, Errors.IllegalForwardRef);
 931                 return types.createErrorType(t);
 932             }
 933         } else {
 934             t = chk.checkClassType(pos, t, checkExtensible);
 935         }
 936         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 937             log.error(pos, Errors.IntfExpectedHere);
 938             // return errType is necessary since otherwise there might
 939             // be undetected cycles which cause attribution to loop
 940             return types.createErrorType(t);
 941         } else if (checkExtensible &amp;&amp;
 942                    classExpected &amp;&amp;
 943                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 944             log.error(pos, Errors.NoIntfExpectedHere);
 945             return types.createErrorType(t);
 946         }
 947         if (checkExtensible &amp;&amp;
 948             ((t.tsym.flags() &amp; FINAL) != 0)) {
 949             log.error(pos,
 950                       Errors.CantInheritFromFinal(t.tsym));
 951         }
 952         chk.checkNonCyclic(pos, t);
 953         return t;
 954     }
 955 
 956     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 957         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 958         id.type = env.info.scope.owner.enclClass().type;
 959         id.sym = env.info.scope.owner.enclClass();
 960         return id.type;
 961     }
 962 
 963     public void visitClassDef(JCClassDecl tree) {
 964         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 965                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 966                         argumentAttr.withLocalCacheContext() : null);
 967         try {
 968             // Local and anonymous classes have not been entered yet, so we need to
 969             // do it now.
 970             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 971                 enter.classEnter(tree, env);
 972             } else {
 973                 // If this class declaration is part of a class level annotation,
 974                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 975                 // order to simplify later steps and allow for sensible error
 976                 // messages.
 977                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 978                     enter.classEnter(tree, env);
 979             }
 980 
 981             ClassSymbol c = tree.sym;
 982             if (c == null) {
 983                 // exit in case something drastic went wrong during enter.
 984                 result = null;
 985             } else {
 986                 // make sure class has been completed:
 987                 c.complete();
 988 
 989                 // If this class appears as an anonymous class
 990                 // in a superclass constructor call
 991                 // disable implicit outer instance from being passed.
 992                 // (This would be an illegal access to &quot;this before super&quot;).
 993                 if (env.info.isSelfCall &amp;&amp;
 994                         env.tree.hasTag(NEWCLASS)) {
 995                     c.flags_field |= NOOUTERTHIS;
 996                 }
 997                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {
 998                     c.flags_field |= VALUE; // avoid further secondary errors.
 999                 }
1000                 attribClass(tree.pos(), c);
1001                 result = tree.type = c.type;
1002             }
1003         } finally {
1004             localCacheContext.ifPresent(LocalCacheContext::leave);
1005         }
1006     }
1007 
1008     public void visitMethodDef(JCMethodDecl tree) {
1009         MethodSymbol m = tree.sym;
1010         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1011 
1012         Lint lint = env.info.lint.augment(m);
1013         Lint prevLint = chk.setLint(lint);
1014         MethodSymbol prevMethod = chk.setMethod(m);
1015         try {
1016             deferredLintHandler.flush(tree.pos());
1017             chk.checkDeprecatedAnnotation(tree.pos(), m);
1018 
1019 
1020             // Create a new environment with local scope
1021             // for attributing the method.
1022             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
1023             localEnv.info.lint = lint;
1024 
1025             attribStats(tree.typarams, localEnv);
1026 
1027             // If we override any other methods, check that we do so properly.
1028             // JLS ???
1029             if (m.isStatic()) {
1030                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
1031             } else {
1032                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1033             }
1034             chk.checkOverride(env, tree, m);
1035 
1036             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1037                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1038             }
1039 
1040             // Enter all type parameters into the local method scope.
1041             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1042                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1043 
1044             ClassSymbol owner = env.enclClass.sym;
1045             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1046                     (tree.params.nonEmpty() ||
1047                     tree.recvparam != null))
1048                 log.error(tree.params.nonEmpty() ?
1049                         tree.params.head.pos() :
1050                         tree.recvparam.pos(),
1051                         Errors.IntfAnnotationMembersCantHaveParams);
1052 
1053             // Attribute all value parameters.
1054             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1055                 attribStat(l.head, localEnv);
1056             }
1057 
1058             chk.checkVarargsMethodDecl(localEnv, tree);
1059 
1060             // Check that type parameters are well-formed.
1061             chk.validate(tree.typarams, localEnv);
1062 
1063             // Check that result type is well-formed.
1064             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1065                 chk.validate(tree.restype, localEnv);
1066 
1067             // Check that receiver type is well-formed.
1068             if (tree.recvparam != null) {
1069                 // Use a new environment to check the receiver parameter.
1070                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1071                 // Is there a better way?
1072                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1073                 attribType(tree.recvparam, newEnv);
1074                 chk.validate(tree.recvparam, newEnv);
1075             }
1076 
1077             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1078                 // lets find if this method is an accessor
1079                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1080                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1081                 if (recordComponent.isPresent()) {
1082                     // the method is a user defined accessor lets check that everything is fine
1083                     if (!tree.sym.isPublic()) {
1084                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1085                     }
1086                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1087                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1088                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1089                     }
1090                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1091                         log.error(tree,
1092                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1093                     }
1094                     if (!tree.typarams.isEmpty()) {
1095                         log.error(tree,
1096                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1097                     }
1098                     if (tree.sym.isStatic()) {
1099                         log.error(tree,
1100                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1101                     }
1102                 }
1103 
1104                 if (tree.name == names.init) {
1105                     // if this a constructor other than the canonical one
1106                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1107                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1108                         if (app == null ||
1109                                 TreeInfo.name(app.meth) != names._this ||
1110                                 !checkFirstConstructorStat(app, tree, false)) {
1111                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1112                         }
1113                     } else {
1114                         // but if it is the canonical:
1115 
1116                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor
1117                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1118                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1119                             if (app != null &amp;&amp;
1120                                     (TreeInfo.name(app.meth) == names._this ||
1121                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1122                                     checkFirstConstructorStat(app, tree, false)) {
1123                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1124                                         Fragments.Canonical, tree.sym.name,
1125                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1126                             }
1127                         }
1128 
1129                         // also we want to check that no type variables have been defined
1130                         if (!tree.typarams.isEmpty()) {
1131                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1132                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1133                         }
1134 
1135                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1136                          * record components
1137                          */
1138                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1139                         for (JCVariableDecl param: tree.params) {
1140                             if (!types.isSameType(param.type, recordComponentTypes.head)) {
1141                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1142                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1143                             }
1144                             recordComponentTypes = recordComponentTypes.tail;
1145                         }
1146                     }
1147                 }
1148             }
1149 
1150             // annotation method checks
1151             if ((owner.flags() &amp; ANNOTATION) != 0) {
1152                 // annotation method cannot have throws clause
1153                 if (tree.thrown.nonEmpty()) {
1154                     log.error(tree.thrown.head.pos(),
1155                               Errors.ThrowsNotAllowedInIntfAnnotation);
1156                 }
1157                 // annotation method cannot declare type-parameters
1158                 if (tree.typarams.nonEmpty()) {
1159                     log.error(tree.typarams.head.pos(),
1160                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1161                 }
1162                 // validate annotation method&#39;s return type (could be an annotation type)
1163                 chk.validateAnnotationType(tree.restype);
1164                 // ensure that annotation method does not clash with members of Object/Annotation
1165                 chk.validateAnnotationMethod(tree.pos(), m);
1166             }
1167 
1168             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1169                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1170 
1171             if (tree.body == null) {
1172                 // Empty bodies are only allowed for
1173                 // abstract, native, or interface methods, or for methods
1174                 // in a retrofit signature class.
1175                 if (tree.defaultValue != null) {
1176                     if ((owner.flags() &amp; ANNOTATION) == 0)
1177                         log.error(tree.pos(),
1178                                   Errors.DefaultAllowedInIntfAnnotationMember);
1179                 }
1180                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1181                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1182             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1183                 if ((owner.flags() &amp; INTERFACE) != 0) {
1184                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1185                 } else {
1186                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1187                 }
1188             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1189                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1190             } else {
1191                 // Add an implicit super() call unless an explicit call to
1192                 // super(...) or this(...) is given
1193                 // or we are compiling class java.lang.Object.
1194                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1195                     JCBlock body = tree.body;
1196                     if (body.stats.isEmpty() ||
1197                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {
1198                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1199                                 make.Ident(names._super), make.Idents(List.nil())));
1200                         body.stats = body.stats.prepend(supCall);
1201                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1202                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1203                             TreeInfo.isSuperCall(body.stats.head)) {
1204                         // enum constructors are not allowed to call super
1205                         // directly, so make sure there aren&#39;t any super calls
1206                         // in enum constructors, except in the compiler
1207                         // generated one.
1208                         log.error(tree.body.stats.head.pos(),
1209                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1210                     }
1211                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1212                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1213                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1214                         if (!initParamNames.equals(recordComponentNames)) {
1215                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1216                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1217                         }
1218                         if (!tree.sym.isPublic()) {
1219                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1220                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1221                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1222                         }
1223                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1224                             log.error(tree,
1225                                     Errors.InvalidCanonicalConstructorInRecord(
1226                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1227                                             env.enclClass.sym.name,
1228                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1229                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1230                         }
1231                     }
1232                 }
1233                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {
1234                     if ((owner.type == syms.objectType) ||
1235                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {
1236                         m.flags_field |= EMPTYNOARGCONSTR;
1237                     }
1238                 }
1239 
1240                 // Attribute all type annotations in the body
1241                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1242                 annotate.flush();
1243 
1244                 // Attribute method body.
1245                 attribStat(tree.body, localEnv);
1246             }
1247 
1248             localEnv.info.scope.leave();
1249             result = tree.type = m.type;
1250         } finally {
1251             chk.setLint(prevLint);
1252             chk.setMethod(prevMethod);
1253         }
1254     }
1255 
1256     public void visitVarDef(JCVariableDecl tree) {
1257         // Local variables have not been entered yet, so we need to do it now:
1258         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1259             if (tree.sym != null) {
1260                 // parameters have already been entered
1261                 env.info.scope.enter(tree.sym);
1262             } else {
1263                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1264                     if (tree.init == null) {
1265                         //cannot use &#39;var&#39; without initializer
1266                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1267                         tree.vartype = make.Erroneous();
1268                     } else {
1269                         Fragment msg = canInferLocalVarType(tree);
1270                         if (msg != null) {
1271                             //cannot use &#39;var&#39; with initializer which require an explicit target
1272                             //(e.g. lambda, method reference, array initializer).
1273                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1274                             tree.vartype = make.Erroneous();
1275                         }
1276                     }
1277                 }
1278                 try {
1279                     annotate.blockAnnotations();
1280                     memberEnter.memberEnter(tree, env);
1281                 } finally {
1282                     annotate.unblockAnnotations();
1283                 }
1284             }
1285         } else {
1286             if (tree.init != null) {
1287                 // Field initializer expression need to be entered.
1288                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1289                 annotate.flush();
1290             }
1291         }
1292 
1293         VarSymbol v = tree.sym;
1294         Lint lint = env.info.lint.augment(v);
1295         Lint prevLint = chk.setLint(lint);
1296 
1297         // Check that the variable&#39;s declared type is well-formed.
1298         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1299                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1300                 (tree.sym.flags() &amp; PARAMETER) != 0;
1301         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1302 
1303         try {
1304             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1305             deferredLintHandler.flush(tree.pos());
1306             chk.checkDeprecatedAnnotation(tree.pos(), v);
1307 
1308             /* Don&#39;t want constant propagation/folding for instance fields of value classes,
1309                as these can undergo updates via copy on write.
1310             */
1311             if (tree.init != null) {
1312                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||
1313                     !memberEnter.needsLazyConstValue(tree.init)) {
1314                     // Not a compile-time constant
1315                     // Attribute initializer in a new environment
1316                     // with the declared variable as owner.
1317                     // Check that initializer conforms to variable&#39;s declared type.
1318                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1319                     initEnv.info.lint = lint;
1320                     // In order to catch self-references, we set the variable&#39;s
1321                     // declaration position to maximal possible value, effectively
1322                     // marking the variable as undefined.
1323                     initEnv.info.enclVar = v;
1324                     attribExpr(tree.init, initEnv, v.type);
1325                     if (tree.isImplicitlyTyped()) {
1326                         //fixup local variable type
1327                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1328                     }
1329                 }
1330                 if (tree.isImplicitlyTyped()) {
1331                     setSyntheticVariableType(tree, v.type);
1332                 }
1333             }
1334             result = tree.type = v.type;
1335             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1336                 if (isNonArgsMethodInObject(v.name)) {
1337                     log.error(tree, Errors.IllegalRecordComponentName(v));
1338                 }
1339             }
1340         }
1341         finally {
1342             chk.setLint(prevLint);
1343         }
1344     }
1345 
1346     private boolean isNonArgsMethodInObject(Name name) {
1347         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1348             if (s.type.getParameterTypes().isEmpty()) {
1349                 return true;
1350             }
1351         }
1352         return false;
1353     }
1354 
1355     Fragment canInferLocalVarType(JCVariableDecl tree) {
1356         LocalInitScanner lis = new LocalInitScanner();
1357         lis.scan(tree.init);
1358         return lis.badInferenceMsg;
1359     }
1360 
1361     static class LocalInitScanner extends TreeScanner {
1362         Fragment badInferenceMsg = null;
1363         boolean needsTarget = true;
1364 
1365         @Override
1366         public void visitNewArray(JCNewArray tree) {
1367             if (tree.elemtype == null &amp;&amp; needsTarget) {
1368                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1369             }
1370         }
1371 
1372         @Override
1373         public void visitLambda(JCLambda tree) {
1374             if (needsTarget) {
1375                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1376             }
1377         }
1378 
1379         @Override
1380         public void visitTypeCast(JCTypeCast tree) {
1381             boolean prevNeedsTarget = needsTarget;
1382             try {
1383                 needsTarget = false;
1384                 super.visitTypeCast(tree);
1385             } finally {
1386                 needsTarget = prevNeedsTarget;
1387             }
1388         }
1389 
1390         @Override
1391         public void visitReference(JCMemberReference tree) {
1392             if (needsTarget) {
1393                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1394             }
1395         }
1396 
1397         @Override
1398         public void visitNewClass(JCNewClass tree) {
1399             boolean prevNeedsTarget = needsTarget;
1400             try {
1401                 needsTarget = false;
1402                 super.visitNewClass(tree);
1403             } finally {
1404                 needsTarget = prevNeedsTarget;
1405             }
1406         }
1407 
1408         @Override
1409         public void visitApply(JCMethodInvocation tree) {
1410             boolean prevNeedsTarget = needsTarget;
1411             try {
1412                 needsTarget = false;
1413                 super.visitApply(tree);
1414             } finally {
1415                 needsTarget = prevNeedsTarget;
1416             }
1417         }
1418     }
1419 
1420     public void visitSkip(JCSkip tree) {
1421         result = null;
1422     }
1423 
1424     public void visitBlock(JCBlock tree) {
1425         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1426             // Block is a static or instance initializer;
1427             // let the owner of the environment be a freshly
1428             // created BLOCK-method.
1429             Symbol fakeOwner =
1430                 new MethodSymbol(tree.flags | BLOCK |
1431                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1432                     env.info.scope.owner);
1433             final Env&lt;AttrContext&gt; localEnv =
1434                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1435 
1436             if ((tree.flags &amp; STATIC) != 0)
1437                 localEnv.info.staticLevel++;
1438             else if (tree.stats.size() &gt; 0)
1439                 env.info.scope.owner.flags_field |= HASINITBLOCK;
1440 
1441             // Attribute all type annotations in the block
1442             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1443             annotate.flush();
1444             attribStats(tree.stats, localEnv);
1445 
1446             {
1447                 // Store init and clinit type annotations with the ClassSymbol
1448                 // to allow output in Gen.normalizeDefs.
1449                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1450                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1451                 if ((tree.flags &amp; STATIC) != 0) {
1452                     cs.appendClassInitTypeAttributes(tas);
1453                 } else {
1454                     cs.appendInitTypeAttributes(tas);
1455                 }
1456             }
1457         } else {
1458             // Create a new local environment with a local scope.
1459             Env&lt;AttrContext&gt; localEnv =
1460                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1461             try {
1462                 attribStats(tree.stats, localEnv);
1463             } finally {
1464                 localEnv.info.scope.leave();
1465             }
1466         }
1467         result = null;
1468     }
1469 
1470     public void visitDoLoop(JCDoWhileLoop tree) {
1471         attribStat(tree.body, env.dup(tree));
1472         attribExpr(tree.cond, env, syms.booleanType);
1473         if (!breaksOutOf(tree, tree.body)) {
1474             //include condition&#39;s body when false after the while, if cannot get out of the loop
1475             MatchBindings condBindings = matchBindings;
1476             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1477             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1478         }
1479         result = null;
1480     }
1481 
1482     public void visitWhileLoop(JCWhileLoop tree) {
1483         attribExpr(tree.cond, env, syms.booleanType);
1484         MatchBindings condBindings = matchBindings;
1485         // include condition&#39;s bindings when true in the body:
1486         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1487         try {
1488             attribStat(tree.body, whileEnv.dup(tree));
1489         } finally {
1490             whileEnv.info.scope.leave();
1491         }
1492         if (!breaksOutOf(tree, tree.body)) {
1493             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1494             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1495             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1496         }
1497         result = null;
1498     }
1499 
1500     private boolean breaksOutOf(JCTree loop, JCTree body) {
1501         preFlow(body);
1502         return flow.breaksOutOf(env, loop, body, make);
1503     }
1504 
1505     public void visitWithField(JCWithField tree) {
1506         boolean inWithField = env.info.inWithField;
1507         try {
1508             env.info.inWithField = true;
1509             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);
1510             attribExpr(tree.value, env, fieldtype);
1511             Type capturedType = syms.errType;
1512             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {
1513                 final Symbol sym = TreeInfo.symbol(tree.field);
1514                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||
1515                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {
1516                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);
1517                 } else {
1518                     Type ownType = sym.owner.type;
1519                     switch(tree.field.getTag()) {
1520                         case IDENT:
1521                             JCIdent ident = (JCIdent) tree.field;
1522                             ownType = ident.sym.owner.type;
1523                             break;
1524                         case SELECT:
1525                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;
1526                             ownType = fieldAccess.selected.type;
1527                             break;
1528                     }
1529                     capturedType = capture(ownType);
1530                 }
1531             }
1532             result = check(tree, capturedType, KindSelector.VAL, resultInfo);
1533         } finally {
1534             env.info.inWithField = inWithField;
1535         }
1536     }
1537 
1538     public void visitForLoop(JCForLoop tree) {
1539         Env&lt;AttrContext&gt; loopEnv =
1540             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1541         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1542         try {
1543             attribStats(tree.init, loopEnv);
1544             if (tree.cond != null) {
1545                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1546                 // include condition&#39;s bindings when true in the body and step:
1547                 condBindings = matchBindings;
1548             }
1549             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1550             try {
1551                 bodyEnv.tree = tree; // before, we were not in loop!
1552                 attribStats(tree.step, bodyEnv);
1553                 attribStat(tree.body, bodyEnv);
1554             } finally {
1555                 bodyEnv.info.scope.leave();
1556             }
1557             result = null;
1558         }
1559         finally {
1560             loopEnv.info.scope.leave();
1561         }
1562         if (!breaksOutOf(tree, tree.body)) {
1563             //include condition&#39;s body when false after the while, if cannot get out of the loop
1564             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1565             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1566         }
1567     }
1568 
1569     public void visitForeachLoop(JCEnhancedForLoop tree) {
1570         Env&lt;AttrContext&gt; loopEnv =
1571             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1572         try {
1573             //the Formal Parameter of a for-each loop is not in the scope when
1574             //attributing the for-each expression; we mimic this by attributing
1575             //the for-each expression first (against original scope).
1576             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1577             chk.checkNonVoid(tree.pos(), exprType);
1578             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1579             if (elemtype == null) {
1580                 // or perhaps expr implements Iterable&lt;T&gt;?
1581                 Type base = types.asSuper(exprType, syms.iterableType.tsym);
1582                 if (base == null) {
1583                     log.error(tree.expr.pos(),
1584                               Errors.ForeachNotApplicableToType(exprType,
1585                                                                 Fragments.TypeReqArrayOrIterable));
1586                     elemtype = types.createErrorType(exprType);
1587                 } else {
1588                     List&lt;Type&gt; iterableParams = base.allparams();
1589                     elemtype = iterableParams.isEmpty()
1590                         ? syms.objectType
1591                         : types.wildUpperBound(iterableParams.head);
1592                 }
1593             }
1594             if (tree.var.isImplicitlyTyped()) {
1595                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1596                 setSyntheticVariableType(tree.var, inferredType);
1597             }
1598             attribStat(tree.var, loopEnv);
1599             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1600             loopEnv.tree = tree; // before, we were not in loop!
1601             attribStat(tree.body, loopEnv);
1602             result = null;
1603         }
1604         finally {
1605             loopEnv.info.scope.leave();
1606         }
1607     }
1608 
1609     public void visitLabelled(JCLabeledStatement tree) {
1610         // Check that label is not used in an enclosing statement
1611         Env&lt;AttrContext&gt; env1 = env;
1612         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1613             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1614                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1615                 log.error(tree.pos(),
1616                           Errors.LabelAlreadyInUse(tree.label));
1617                 break;
1618             }
1619             env1 = env1.next;
1620         }
1621 
1622         attribStat(tree.body, env.dup(tree));
1623         result = null;
1624     }
1625 
1626     public void visitSwitch(JCSwitch tree) {
1627         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1628             attribStats(c.stats, caseEnv);
1629         });
1630         result = null;
1631     }
1632 
1633     public void visitSwitchExpression(JCSwitchExpression tree) {
1634         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1635                 PolyKind.STANDALONE : PolyKind.POLY;
1636 
1637         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1638             //this means we are returning a poly conditional from void-compatible lambda expression
1639             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1640             result = tree.type = types.createErrorType(resultInfo.pt);
1641             return;
1642         }
1643 
1644         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1645                 unknownExprInfo :
1646                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1647 
1648         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1649         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1650 
1651         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1652             caseEnv.info.yieldResult = condInfo;
1653             attribStats(c.stats, caseEnv);
1654             new TreeScanner() {
1655                 @Override
1656                 public void visitYield(JCYield brk) {
1657                     if (brk.target == tree) {
1658                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1659                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1660                     }
1661                     super.visitYield(brk);
1662                 }
1663 
1664                 @Override public void visitClassDef(JCClassDecl tree) {}
1665                 @Override public void visitLambda(JCLambda tree) {}
1666             }.scan(c.stats);
1667         });
1668 
1669         if (tree.cases.isEmpty()) {
1670             log.error(tree.pos(),
1671                       Errors.SwitchExpressionEmpty);
1672         } else if (caseTypes.isEmpty()) {
1673             log.error(tree.pos(),
1674                       Errors.SwitchExpressionNoResultExpressions);
1675         }
1676 
1677         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1678 
1679         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1680     }
1681     //where:
1682         CheckContext switchExpressionContext(CheckContext checkContext) {
1683             return new Check.NestedCheckContext(checkContext) {
1684                 //this will use enclosing check context to check compatibility of
1685                 //subexpression against target type; if we are in a method check context,
1686                 //depending on whether boxing is allowed, we could have incompatibilities
1687                 @Override
1688                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1689                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1690                 }
1691             };
1692         }
1693 
1694     private void handleSwitch(JCTree switchTree,
1695                               JCExpression selector,
1696                               List&lt;JCCase&gt; cases,
1697                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1698         Type seltype = attribExpr(selector, env);
1699 
1700         Env&lt;AttrContext&gt; switchEnv =
1701             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1702 
1703         try {
1704             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1705             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1706             if (!enumSwitch &amp;&amp; !stringSwitch)
1707                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1708 
1709             // Attribute all cases and
1710             // check that there are no duplicate case labels or default clauses.
1711             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1712             boolean hasDefault = false;      // Is there a default label?
1713             CaseTree.CaseKind caseKind = null;
1714             boolean wasError = false;
1715             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1716                 JCCase c = l.head;
1717                 if (caseKind == null) {
1718                     caseKind = c.caseKind;
1719                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1720                     log.error(c.pos(),
1721                               Errors.SwitchMixingCaseTypes);
1722                     wasError = true;
1723                 }
1724                 if (c.getExpressions().nonEmpty()) {
1725                     for (JCExpression pat : c.getExpressions()) {
1726                         if (TreeInfo.isNull(pat)) {
1727                             log.error(pat.pos(),
1728                                       Errors.SwitchNullNotAllowed);
1729                         } else if (enumSwitch) {
1730                             Symbol sym = enumConstant(pat, seltype);
1731                             if (sym == null) {
1732                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1733                             } else if (!labels.add(sym)) {
1734                                 log.error(c.pos(), Errors.DuplicateCaseLabel);
1735                             }
1736                         } else {
1737                             Type pattype = attribExpr(pat, switchEnv, seltype);
1738                             if (!pattype.hasTag(ERROR)) {
1739                                 if (pattype.constValue() == null) {
1740                                     log.error(pat.pos(),
1741                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1742                                 } else if (!labels.add(pattype.constValue())) {
1743                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1744                                 }
1745                             }
1746                         }
1747                     }
1748                 } else if (hasDefault) {
1749                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1750                 } else {
1751                     hasDefault = true;
1752                 }
1753                 Env&lt;AttrContext&gt; caseEnv =
1754                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1755                 try {
1756                     attribCase.accept(c, caseEnv);
1757                 } finally {
1758                     caseEnv.info.scope.leave();
1759                 }
1760                 addVars(c.stats, switchEnv.info.scope);
1761             }
1762         } finally {
1763             switchEnv.info.scope.leave();
1764         }
1765     }
1766     // where
1767         /** Add any variables defined in stats to the switch scope. */
1768         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1769             for (;stats.nonEmpty(); stats = stats.tail) {
1770                 JCTree stat = stats.head;
1771                 if (stat.hasTag(VARDEF))
1772                     switchScope.enter(((JCVariableDecl) stat).sym);
1773             }
1774         }
1775     // where
1776     /** Return the selected enumeration constant symbol, or null. */
1777     private Symbol enumConstant(JCTree tree, Type enumType) {
1778         if (tree.hasTag(IDENT)) {
1779             JCIdent ident = (JCIdent)tree;
1780             Name name = ident.name;
1781             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1782                 if (sym.kind == VAR) {
1783                     Symbol s = ident.sym = sym;
1784                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1785                     ident.type = s.type;
1786                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1787                         ? null : s;
1788                 }
1789             }
1790         }
1791         return null;
1792     }
1793 
1794     public void visitSynchronized(JCSynchronized tree) {
1795         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);
1796         attribStat(tree.body, env);
1797         result = null;
1798     }
1799 
1800     public void visitTry(JCTry tree) {
1801         // Create a new local environment with a local
1802         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1803         try {
1804             boolean isTryWithResource = tree.resources.nonEmpty();
1805             // Create a nested environment for attributing the try block if needed
1806             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1807                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1808                 localEnv;
1809             try {
1810                 // Attribute resource declarations
1811                 for (JCTree resource : tree.resources) {
1812                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1813                         @Override
1814                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1815                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1816                         }
1817                     };
1818                     ResultInfo twrResult =
1819                         new ResultInfo(KindSelector.VAR,
1820                                        syms.autoCloseableType,
1821                                        twrContext);
1822                     if (resource.hasTag(VARDEF)) {
1823                         attribStat(resource, tryEnv);
1824                         twrResult.check(resource, resource.type);
1825 
1826                         //check that resource type cannot throw InterruptedException
1827                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1828 
1829                         VarSymbol var = ((JCVariableDecl) resource).sym;
1830                         var.setData(ElementKind.RESOURCE_VARIABLE);
1831                     } else {
1832                         attribTree(resource, tryEnv, twrResult);
1833                     }
1834                 }
1835                 // Attribute body
1836                 attribStat(tree.body, tryEnv);
1837             } finally {
1838                 if (isTryWithResource)
1839                     tryEnv.info.scope.leave();
1840             }
1841 
1842             // Attribute catch clauses
1843             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1844                 JCCatch c = l.head;
1845                 Env&lt;AttrContext&gt; catchEnv =
1846                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1847                 try {
1848                     Type ctype = attribStat(c.param, catchEnv);
1849                     if (TreeInfo.isMultiCatch(c)) {
1850                         //multi-catch parameter is implicitly marked as final
1851                         c.param.sym.flags_field |= FINAL | UNION;
1852                     }
1853                     if (c.param.sym.kind == VAR) {
1854                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1855                     }
1856                     chk.checkType(c.param.vartype.pos(),
1857                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1858                                   syms.throwableType);
1859                     attribStat(c.body, catchEnv);
1860                 } finally {
1861                     catchEnv.info.scope.leave();
1862                 }
1863             }
1864 
1865             // Attribute finalizer
1866             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1867             result = null;
1868         }
1869         finally {
1870             localEnv.info.scope.leave();
1871         }
1872     }
1873 
1874     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1875         if (!resource.isErroneous() &amp;&amp;
1876             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;
1877             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1878             Symbol close = syms.noSymbol;
1879             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1880             try {
1881                 close = rs.resolveQualifiedMethod(pos,
1882                         env,
1883                         types.skipTypeVars(resource, false),
1884                         names.close,
1885                         List.nil(),
1886                         List.nil());
1887             }
1888             finally {
1889                 log.popDiagnosticHandler(discardHandler);
1890             }
1891             if (close.kind == MTH &amp;&amp;
1892                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1893                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1894                     env.info.lint.isEnabled(LintCategory.TRY)) {
1895                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1896             }
1897         }
1898     }
1899 
1900     public void visitConditional(JCConditional tree) {
1901         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1902         MatchBindings condBindings = matchBindings;
1903 
1904         tree.polyKind = (!allowPoly ||
1905                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1906                 isBooleanOrNumeric(env, tree)) ?
1907                 PolyKind.STANDALONE : PolyKind.POLY;
1908 
1909         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1910             //this means we are returning a poly conditional from void-compatible lambda expression
1911             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1912             result = tree.type = types.createErrorType(resultInfo.pt);
1913             return;
1914         }
1915 
1916         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1917                 unknownExprInfo :
1918                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1919 
1920 
1921         // x ? y : z
1922         // include x&#39;s bindings when true in y
1923         // include x&#39;s bindings when false in z
1924 
1925         Type truetype;
1926         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1927         try {
1928             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1929         } finally {
1930             trueEnv.info.scope.leave();
1931         }
1932 
1933         MatchBindings trueBindings = matchBindings;
1934 
1935         Type falsetype;
1936         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1937         try {
1938             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1939         } finally {
1940             falseEnv.info.scope.leave();
1941         }
1942 
1943         MatchBindings falseBindings = matchBindings;
1944 
1945         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1946                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1947                          List.of(truetype, falsetype)) : pt();
1948         if (condtype.constValue() != null &amp;&amp;
1949                 truetype.constValue() != null &amp;&amp;
1950                 falsetype.constValue() != null &amp;&amp;
1951                 !owntype.hasTag(NONE)) {
1952             //constant folding
1953             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1954         }
1955         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1956         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1957     }
1958     //where
1959         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1960             switch (tree.getTag()) {
1961                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1962                               ((JCLiteral)tree).typetag == BOOLEAN ||
1963                               ((JCLiteral)tree).typetag == BOT;
1964                 case LAMBDA: case REFERENCE: return false;
1965                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1966                 case CONDEXPR:
1967                     JCConditional condTree = (JCConditional)tree;
1968                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1969                             isBooleanOrNumeric(env, condTree.falsepart);
1970                 case APPLY:
1971                     JCMethodInvocation speculativeMethodTree =
1972                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1973                                     tree, env, unknownExprInfo,
1974                                     argumentAttr.withLocalCacheContext());
1975                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1976                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1977                             env.enclClass.type :
1978                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1979                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1980                     return primitiveOrBoxed(owntype);
1981                 case NEWCLASS:
1982                     JCExpression className =
1983                             removeClassParams.translate(((JCNewClass)tree).clazz);
1984                     JCExpression speculativeNewClassTree =
1985                             (JCExpression)deferredAttr.attribSpeculative(
1986                                     className, env, unknownTypeInfo,
1987                                     argumentAttr.withLocalCacheContext());
1988                     return primitiveOrBoxed(speculativeNewClassTree.type);
1989                 default:
1990                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
1991                             argumentAttr.withLocalCacheContext()).type;
1992                     return primitiveOrBoxed(speculativeType);
1993             }
1994         }
1995         //where
1996             boolean primitiveOrBoxed(Type t) {
1997                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
1998             }
1999 
2000             TreeTranslator removeClassParams = new TreeTranslator() {
2001                 @Override
2002                 public void visitTypeApply(JCTypeApply tree) {
2003                     result = translate(tree.clazz);
2004                 }
2005             };
2006 
2007         CheckContext conditionalContext(CheckContext checkContext) {
2008             return new Check.NestedCheckContext(checkContext) {
2009                 //this will use enclosing check context to check compatibility of
2010                 //subexpression against target type; if we are in a method check context,
2011                 //depending on whether boxing is allowed, we could have incompatibilities
2012                 @Override
2013                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
2014                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
2015                 }
2016             };
2017         }
2018 
2019         /** Compute the type of a conditional expression, after
2020          *  checking that it exists.  See JLS 15.25. Does not take into
2021          *  account the special case where condition and both arms
2022          *  are constants.
2023          *
2024          *  @param pos      The source position to be used for error
2025          *                  diagnostics.
2026          *  @param thentype The type of the expression&#39;s then-part.
2027          *  @param elsetype The type of the expression&#39;s else-part.
2028          */
2029         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
2030             if (condTypes.isEmpty()) {
2031                 return syms.objectType; //TODO: how to handle?
2032             }
2033             Type first = condTypes.head;
2034             // If same type, that is the result
2035             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
2036                 return first.baseType();
2037 
2038             List&lt;Type&gt; unboxedTypes = condTypes.stream()
2039                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
2040                                                .collect(List.collector());
2041 
2042             // Otherwise, if both arms can be converted to a numeric
2043             // type, return the least numeric type that fits both arms
2044             // (i.e. return larger of the two, or return int if one
2045             // arm is short, the other is char).
2046             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
2047                 // If one arm has an integer subrange type (i.e., byte,
2048                 // short, or char), and the other is an integer constant
2049                 // that fits into the subrange, return the subrange type.
2050                 for (Type type : unboxedTypes) {
2051                     if (!type.getTag().isStrictSubRangeOf(INT)) {
2052                         continue;
2053                     }
2054                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
2055                         return type.baseType();
2056                 }
2057 
2058                 for (TypeTag tag : primitiveTags) {
2059                     Type candidate = syms.typeOfTag[tag.ordinal()];
2060                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
2061                         return candidate;
2062                     }
2063                 }
2064             }
2065 
2066             // Those were all the cases that could result in a primitive
2067             condTypes = condTypes.stream()
2068                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type : t)
2069                                  .collect(List.collector());
2070 
2071             for (Type type : condTypes) {
2072                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
2073                     return type.baseType();
2074             }
2075 
2076             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
2077 
2078             condTypes = condTypes.stream()
2079                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
2080                                  .collect(List.collector());
2081 
2082             // both are known to be reference types.  The result is
2083             // lub(thentype,elsetype). This cannot fail, as it will
2084             // always be possible to infer &quot;Object&quot; if nothing better.
2085             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2086         }
2087 
2088     final static TypeTag[] primitiveTags = new TypeTag[]{
2089         BYTE,
2090         CHAR,
2091         SHORT,
2092         INT,
2093         LONG,
2094         FLOAT,
2095         DOUBLE,
2096         BOOLEAN,
2097     };
2098 
2099     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2100         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2101         bindings.forEach(env1.info.scope::enter);
2102         return env1;
2103     }
2104 
2105     public void visitIf(JCIf tree) {
2106         attribExpr(tree.cond, env, syms.booleanType);
2107 
2108         // if (x) { y } [ else z ]
2109         // include x&#39;s bindings when true in y
2110         // include x&#39;s bindings when false in z
2111 
2112         MatchBindings condBindings = matchBindings;
2113         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2114 
2115         try {
2116             attribStat(tree.thenpart, thenEnv);
2117         } finally {
2118             thenEnv.info.scope.leave();
2119         }
2120 
2121         preFlow(tree.thenpart);
2122         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2123         boolean aliveAfterElse;
2124 
2125         if (tree.elsepart != null) {
2126             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2127             try {
2128                 attribStat(tree.elsepart, elseEnv);
2129             } finally {
2130                 elseEnv.info.scope.leave();
2131             }
2132             preFlow(tree.elsepart);
2133             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2134         } else {
2135             aliveAfterElse = true;
2136         }
2137 
2138         chk.checkEmptyIf(tree);
2139 
2140         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2141 
2142         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2143             afterIfBindings = condBindings.bindingsWhenTrue;
2144         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2145             afterIfBindings = condBindings.bindingsWhenFalse;
2146         }
2147 
2148         afterIfBindings.forEach(env.info.scope::enter);
2149         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2150 
2151         result = null;
2152     }
2153 
2154         void preFlow(JCTree tree) {
2155             new PostAttrAnalyzer() {
2156                 @Override
2157                 public void scan(JCTree tree) {
2158                     if (tree == null ||
2159                             (tree.type != null &amp;&amp;
2160                             tree.type == Type.stuckType)) {
2161                         //don&#39;t touch stuck expressions!
2162                         return;
2163                     }
2164                     super.scan(tree);
2165                 }
2166             }.scan(tree);
2167         }
2168 
2169     public void visitExec(JCExpressionStatement tree) {
2170         //a fresh environment is required for 292 inference to work properly ---
2171         //see Infer.instantiatePolymorphicSignatureInstance()
2172         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2173         attribExpr(tree.expr, localEnv);
2174         result = null;
2175     }
2176 
2177     public void visitBreak(JCBreak tree) {
2178         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2179         result = null;
2180     }
2181 
2182     public void visitYield(JCYield tree) {
2183         if (env.info.yieldResult != null) {
2184             attribTree(tree.value, env, env.info.yieldResult);
2185             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2186         } else {
2187             log.error(tree.pos(), tree.value.hasTag(PARENS)
2188                     ? Errors.NoSwitchExpressionQualify
2189                     : Errors.NoSwitchExpression);
2190             attribTree(tree.value, env, unknownExprInfo);
2191         }
2192         result = null;
2193     }
2194 
2195     public void visitContinue(JCContinue tree) {
2196         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2197         result = null;
2198     }
2199     //where
2200         /** Return the target of a break, continue or yield statement,
2201          *  if it exists, report an error if not.
2202          *  Note: The target of a labelled break or continue is the
2203          *  (non-labelled) statement tree referred to by the label,
2204          *  not the tree representing the labelled statement itself.
2205          *
2206          *  @param pos     The position to be used for error diagnostics
2207          *  @param tag     The tag of the jump statement. This is either
2208          *                 Tree.BREAK or Tree.CONTINUE.
2209          *  @param label   The label of the jump statement, or null if no
2210          *                 label is given.
2211          *  @param env     The environment current at the jump statement.
2212          */
2213         private JCTree findJumpTarget(DiagnosticPosition pos,
2214                                                    JCTree.Tag tag,
2215                                                    Name label,
2216                                                    Env&lt;AttrContext&gt; env) {
2217             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2218 
2219             if (jumpTarget.snd != null) {
2220                 log.error(pos, jumpTarget.snd);
2221             }
2222 
2223             return jumpTarget.fst;
2224         }
2225         /** Return the target of a break or continue statement, if it exists,
2226          *  report an error if not.
2227          *  Note: The target of a labelled break or continue is the
2228          *  (non-labelled) statement tree referred to by the label,
2229          *  not the tree representing the labelled statement itself.
2230          *
2231          *  @param tag     The tag of the jump statement. This is either
2232          *                 Tree.BREAK or Tree.CONTINUE.
2233          *  @param label   The label of the jump statement, or null if no
2234          *                 label is given.
2235          *  @param env     The environment current at the jump statement.
2236          */
2237         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2238                                                                        Name label,
2239                                                                        Env&lt;AttrContext&gt; env) {
2240             // Search environments outwards from the point of jump.
2241             Env&lt;AttrContext&gt; env1 = env;
2242             JCDiagnostic.Error pendingError = null;
2243             LOOP:
2244             while (env1 != null) {
2245                 switch (env1.tree.getTag()) {
2246                     case LABELLED:
2247                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2248                         if (label == labelled.label) {
2249                             // If jump is a continue, check that target is a loop.
2250                             if (tag == CONTINUE) {
2251                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2252                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2253                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2254                                         !labelled.body.hasTag(FOREACHLOOP)) {
2255                                     pendingError = Errors.NotLoopLabel(label);
2256                                 }
2257                                 // Found labelled statement target, now go inwards
2258                                 // to next non-labelled tree.
2259                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2260                             } else {
2261                                 return Pair.of(labelled, pendingError);
2262                             }
2263                         }
2264                         break;
2265                     case DOLOOP:
2266                     case WHILELOOP:
2267                     case FORLOOP:
2268                     case FOREACHLOOP:
2269                         if (label == null) return Pair.of(env1.tree, pendingError);
2270                         break;
2271                     case SWITCH:
2272                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2273                         break;
2274                     case SWITCH_EXPRESSION:
2275                         if (tag == YIELD) {
2276                             return Pair.of(env1.tree, null);
2277                         } else if (tag == BREAK) {
2278                             pendingError = Errors.BreakOutsideSwitchExpression;
2279                         } else {
2280                             pendingError = Errors.ContinueOutsideSwitchExpression;
2281                         }
2282                         break;
2283                     case LAMBDA:
2284                     case METHODDEF:
2285                     case CLASSDEF:
2286                         break LOOP;
2287                     default:
2288                 }
2289                 env1 = env1.next;
2290             }
2291             if (label != null)
2292                 return Pair.of(null, Errors.UndefLabel(label));
2293             else if (pendingError != null)
2294                 return Pair.of(null, pendingError);
2295             else if (tag == CONTINUE)
2296                 return Pair.of(null, Errors.ContOutsideLoop);
2297             else
2298                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2299         }
2300 
2301     public void visitReturn(JCReturn tree) {
2302         // Check that there is an enclosing method which is
2303         // nested within than the enclosing class.
2304         if (env.info.returnResult == null) {
2305             log.error(tree.pos(), Errors.RetOutsideMeth);
2306         } else if (env.info.yieldResult != null) {
2307             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2308         } else if (!env.info.isLambda &amp;&amp;
2309                 !env.info.isNewClass &amp;&amp;
2310                 env.enclMethod != null &amp;&amp;
2311                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2312             log.error(env.enclMethod,
2313                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2314         } else {
2315             // Attribute return expression, if it exists, and check that
2316             // it conforms to result type of enclosing method.
2317             if (tree.expr != null) {
2318                 if (env.info.returnResult.pt.hasTag(VOID)) {
2319                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2320                               diags.fragment(Fragments.UnexpectedRetVal));
2321                 }
2322                 attribTree(tree.expr, env, env.info.returnResult);
2323             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2324                     !env.info.returnResult.pt.hasTag(NONE)) {
2325                 env.info.returnResult.checkContext.report(tree.pos(),
2326                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2327             }
2328         }
2329         result = null;
2330     }
2331 
2332     public void visitThrow(JCThrow tree) {
2333         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2334         if (allowPoly) {
2335             chk.checkType(tree, owntype, syms.throwableType);
2336         }
2337         result = null;
2338     }
2339 
2340     public void visitAssert(JCAssert tree) {
2341         attribExpr(tree.cond, env, syms.booleanType);
2342         if (tree.detail != null) {
2343             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2344         }
2345         result = null;
2346     }
2347 
2348      /** Visitor method for method invocations.
2349      *  NOTE: The method part of an application will have in its type field
2350      *        the return type of the method, not the method&#39;s type itself!
2351      */
2352     public void visitApply(JCMethodInvocation tree) {
2353         // The local environment of a method application is
2354         // a new environment nested in the current one.
2355         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2356 
2357         // The types of the actual method arguments.
2358         List&lt;Type&gt; argtypes;
2359 
2360         // The types of the actual method type arguments.
2361         List&lt;Type&gt; typeargtypes = null;
2362 
2363         Name methName = TreeInfo.name(tree.meth);
2364 
2365         boolean isConstructorCall =
2366             methName == names._this || methName == names._super;
2367 
2368         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2369         if (isConstructorCall) {
2370             // We are seeing a ...this(...) or ...super(...) call.
2371             // Check that this is the first statement in a constructor.
2372             if (checkFirstConstructorStat(tree, env.enclMethod, true)) {
2373 
2374                 // Record the fact
2375                 // that this is a constructor call (using isSelfCall).
2376                 localEnv.info.isSelfCall = true;
2377 
2378                 // Attribute arguments, yielding list of argument types.
2379                 KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2380                 argtypes = argtypesBuf.toList();
2381                 typeargtypes = attribTypes(tree.typeargs, localEnv);
2382 
2383                 // Variable `site&#39; points to the class in which the called
2384                 // constructor is defined.
2385                 Type site = env.enclClass.sym.type;
2386                 if (methName == names._super) {
2387                     if (site == syms.objectType) {
2388                         log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2389                         site = types.createErrorType(syms.objectType);
2390                     } else {
2391                         site = types.supertype(site);
2392                     }
2393                 }
2394 
2395                 if (site.hasTag(CLASS)) {
2396                     Type encl = site.getEnclosingType();
2397                     while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2398                         encl = encl.getUpperBound();
2399                     if (encl.hasTag(CLASS)) {
2400                         // we are calling a nested class
2401 
2402                         if (tree.meth.hasTag(SELECT)) {
2403                             JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2404 
2405                             // We are seeing a prefixed call, of the form
2406                             //     &lt;expr&gt;.super(...).
2407                             // Check that the prefix expression conforms
2408                             // to the outer instance type of the class.
2409                             chk.checkRefType(qualifier.pos(),
2410                                              attribExpr(qualifier, localEnv,
2411                                                         encl));
2412                         } else if (methName == names._super) {
2413                             // qualifier omitted; check for existence
2414                             // of an appropriate implicit qualifier.
2415                             rs.resolveImplicitThis(tree.meth.pos(),
2416                                                    localEnv, site, true);
2417                         }
2418                     } else if (tree.meth.hasTag(SELECT)) {
2419                         log.error(tree.meth.pos(),
2420                                   Errors.IllegalQualNotIcls(site.tsym));
2421                     }
2422 
2423                     // if we&#39;re calling a java.lang.Enum constructor,
2424                     // prefix the implicit String and int parameters
2425                     if (site.tsym == syms.enumSym)
2426                         argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2427 
2428                     // Resolve the called constructor under the assumption
2429                     // that we are referring to a superclass instance of the
2430                     // current instance (JLS ???).
2431                     boolean selectSuperPrev = localEnv.info.selectSuper;
2432                     localEnv.info.selectSuper = true;
2433                     localEnv.info.pendingResolutionPhase = null;
2434                     Symbol sym = rs.resolveConstructor(
2435                         tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2436                     localEnv.info.selectSuper = selectSuperPrev;
2437 
2438                     // Set method symbol to resolved constructor...
2439                     TreeInfo.setSymbol(tree.meth, sym);
2440 
2441                     // ...and check that it is legal in the current context.
2442                     // (this will also set the tree&#39;s type)
2443                     Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2444                     checkId(tree.meth, site, sym, localEnv,
2445                             new ResultInfo(kind, mpt));
2446                 }
2447                 // Otherwise, `site&#39; is an error type and we do nothing
2448             }
2449             result = tree.type = syms.voidType;
2450         } else {
2451             // Otherwise, we are seeing a regular method call.
2452             // Attribute the arguments, yielding list of argument types, ...
2453             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2454             argtypes = argtypesBuf.toList();
2455             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2456 
2457             // ... and attribute the method using as a prototype a methodtype
2458             // whose formal argument types is exactly the list of actual
2459             // arguments (this will also set the method symbol).
2460             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2461             localEnv.info.pendingResolutionPhase = null;
2462             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2463 
2464             // Compute the result type.
2465             Type restype = mtype.getReturnType();
2466             if (restype.hasTag(WILDCARD))
2467                 throw new AssertionError(mtype);
2468 
2469             Type qualifier = (tree.meth.hasTag(SELECT))
2470                     ? ((JCFieldAccess) tree.meth).selected.type
2471                     : env.enclClass.sym.type;
2472             Symbol msym = TreeInfo.symbol(tree.meth);
2473             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2474 
2475             chk.checkRefTypes(tree.typeargs, typeargtypes);
2476 
2477             final Symbol symbol = TreeInfo.symbol(tree.meth);
2478             if (symbol != null) {
2479                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??
2480                  */
2481                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)
2482                         &amp;&amp; (tree.meth.hasTag(SELECT))
2483                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)
2484                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;
2485                 if (types.isValue(qualifier) || superCallOnValueReceiver) {
2486                     int argSize = argtypes.size();
2487                     Name name = symbol.name;
2488                     switch (name.toString()) {
2489                         case &quot;wait&quot;:
2490                             if (argSize == 0
2491                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;
2492                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {
2493                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2494                             }
2495                             break;
2496                         case &quot;notify&quot;:
2497                         case &quot;notifyAll&quot;:
2498                         case &quot;clone&quot;:
2499                         case &quot;finalize&quot;:
2500                             if (argSize == 0)
2501                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));
2502                             break;
2503                         case &quot;hashCode&quot;:
2504                         case &quot;equals&quot;:
2505                         case &quot;toString&quot;:
2506                             if (superCallOnValueReceiver)
2507                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));
2508                             break;
2509                     }
2510                 }
2511             }
2512 
2513             // Check that value of resulting type is admissible in the
2514             // current context.  Also, capture the return type
2515             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2516             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2517         }
2518         chk.validate(tree.typeargs, localEnv);
2519     }
2520     //where
2521         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2522             if (msym != null &amp;&amp;
2523                     msym.owner == syms.objectType.tsym &amp;&amp;
2524                     methodName == names.getClass &amp;&amp;
2525                     argtypes.isEmpty()) {
2526                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
2527                 return new ClassType(restype.getEnclosingType(),
2528                         List.of(new WildcardType(types.erasure(qualifierType),
2529                                 BoundKind.EXTENDS,
2530                                 syms.boundClass)),
2531                         restype.tsym,
2532                         restype.getMetadata());
2533             } else if (msym != null &amp;&amp;
2534                     msym.owner == syms.arrayClass &amp;&amp;
2535                     methodName == names.clone &amp;&amp;
2536                     types.isArray(qualifierType)) {
2537                 // as a special case, array.clone() has a result that is
2538                 // the same as static type of the array being cloned
2539                 return qualifierType;
2540             } else {
2541                 return restype;
2542             }
2543         }
2544 
2545         /** Check that given application node appears as first statement
2546          *  in a constructor call.
2547          *  @param tree          The application node
2548          *  @param enclMethod    The enclosing method of the application.
2549          *  @param error         Should an error be issued?
2550          */
2551         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2552             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2553                 JCBlock body = enclMethod.body;
2554                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2555                     ((JCExpressionStatement) body.stats.head).expr == tree)
2556                     return true;
2557             }
2558             if (error) {
2559                 log.error(tree.pos(),
2560                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2561             }
2562             return false;
2563         }
2564 
2565         /** Obtain a method type with given argument types.
2566          */
2567         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2568             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2569             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2570         }
2571 
2572     public void visitNewClass(final JCNewClass tree) {
2573         Type owntype = types.createErrorType(tree.type);
2574 
2575         // The local environment of a class creation is
2576         // a new environment nested in the current one.
2577         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2578 
2579         // The anonymous inner class definition of the new expression,
2580         // if one is defined by it.
2581         JCClassDecl cdef = tree.def;
2582 
2583         // If enclosing class is given, attribute it, and
2584         // complete class name to be fully qualified
2585         JCExpression clazz = tree.clazz; // Class field following new
2586         JCExpression clazzid;            // Identifier in class field
2587         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2588         annoclazzid = null;
2589 
2590         if (clazz.hasTag(TYPEAPPLY)) {
2591             clazzid = ((JCTypeApply) clazz).clazz;
2592             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2593                 annoclazzid = (JCAnnotatedType) clazzid;
2594                 clazzid = annoclazzid.underlyingType;
2595             }
2596         } else {
2597             if (clazz.hasTag(ANNOTATED_TYPE)) {
2598                 annoclazzid = (JCAnnotatedType) clazz;
2599                 clazzid = annoclazzid.underlyingType;
2600             } else {
2601                 clazzid = clazz;
2602             }
2603         }
2604 
2605         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2606 
2607         if (tree.encl != null) {
2608             // We are seeing a qualified new, of the form
2609             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2610             // In this case, we let clazz stand for the name of the
2611             // allocated class C prefixed with the type of the qualifier
2612             // expression, so that we can
2613             // resolve it with standard techniques later. I.e., if
2614             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2615             // yields a clazz T.C.
2616             Type encltype = chk.checkRefType(tree.encl.pos(),
2617                                              attribExpr(tree.encl, env));
2618             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2619             // from expr to the combined type, or not? Yes, do this.
2620             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2621                                                  ((JCIdent) clazzid).name);
2622 
2623             EndPosTable endPosTable = this.env.toplevel.endPositions;
2624             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2625             if (clazz.hasTag(ANNOTATED_TYPE)) {
2626                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2627                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2628 
2629                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2630                     clazzid1 = make.at(tree.pos).
2631                         TypeApply(clazzid1,
2632                                   ((JCTypeApply) clazz).arguments);
2633                 }
2634 
2635                 clazzid1 = make.at(tree.pos).
2636                     AnnotatedType(annos, clazzid1);
2637             } else if (clazz.hasTag(TYPEAPPLY)) {
2638                 clazzid1 = make.at(tree.pos).
2639                     TypeApply(clazzid1,
2640                               ((JCTypeApply) clazz).arguments);
2641             }
2642 
2643             clazz = clazzid1;
2644         }
2645 
2646         // Attribute clazz expression and store
2647         // symbol + type back into the attributed tree.
2648         Type clazztype;
2649 
2650         try {
2651             env.info.isNewClass = true;
2652             clazztype = TreeInfo.isEnumInit(env.tree) ?
2653                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2654                 attribType(clazz, env);
2655         } finally {
2656             env.info.isNewClass = false;
2657         }
2658 
2659         clazztype = chk.checkDiamond(tree, clazztype);
2660         chk.validate(clazz, localEnv);
2661         if (tree.encl != null) {
2662             // We have to work in this case to store
2663             // symbol + type back into the attributed tree.
2664             tree.clazz.type = clazztype;
2665             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2666             clazzid.type = ((JCIdent) clazzid).sym.type;
2667             if (annoclazzid != null) {
2668                 annoclazzid.type = clazzid.type;
2669             }
2670             if (!clazztype.isErroneous()) {
2671                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2672                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2673                 } else if (clazztype.tsym.isStatic()) {
2674                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2675                 }
2676             }
2677         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2678                    clazztype.getEnclosingType().hasTag(CLASS)) {
2679             // Check for the existence of an apropos outer instance
2680             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2681         }
2682 
2683         // Attribute constructor arguments.
2684         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2685         final KindSelector pkind =
2686             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2687         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2688         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2689 
2690         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2691             // Enums may not be instantiated except implicitly
2692             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2693                 (!env.tree.hasTag(VARDEF) ||
2694                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2695                  ((JCVariableDecl) env.tree).init != tree))
2696                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2697 
2698             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2699                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2700             boolean skipNonDiamondPath = false;
2701             // Check that class is not abstract
2702             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2703                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2704                 log.error(tree.pos(),
2705                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2706                 skipNonDiamondPath = true;
2707             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2708                 // Check that no constructor arguments are given to
2709                 // anonymous classes implementing an interface
2710                 if (!argtypes.isEmpty())
2711                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2712 
2713                 if (!typeargtypes.isEmpty())
2714                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2715 
2716                 // Error recovery: pretend no arguments were supplied.
2717                 argtypes = List.nil();
2718                 typeargtypes = List.nil();
2719                 skipNonDiamondPath = true;
2720             }
2721             if (TreeInfo.isDiamond(tree)) {
2722                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2723                             clazztype.tsym.type.getTypeArguments(),
2724                                                clazztype.tsym,
2725                                                clazztype.getMetadata());
2726 
2727                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2728                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2729                 diamondEnv.info.pendingResolutionPhase = null;
2730 
2731                 //if the type of the instance creation expression is a class type
2732                 //apply method resolution inference (JLS 15.12.2.7). The return type
2733                 //of the resolved constructor will be a partially instantiated type
2734                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2735                             diamondEnv,
2736                             site,
2737                             argtypes,
2738                             typeargtypes);
2739                 tree.constructor = constructor.baseSymbol();
2740 
2741                 final TypeSymbol csym = clazztype.tsym;
2742                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2743                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2744                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2745                 constructorType = checkId(tree, site,
2746                         constructor,
2747                         diamondEnv,
2748                         diamondResult);
2749 
2750                 tree.clazz.type = types.createErrorType(clazztype);
2751                 if (!constructorType.isErroneous()) {
2752                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2753                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2754                 }
2755                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2756             }
2757 
2758             // Resolve the called constructor under the assumption
2759             // that we are referring to a superclass instance of the
2760             // current instance (JLS ???).
2761             else if (!skipNonDiamondPath) {
2762                 //the following code alters some of the fields in the current
2763                 //AttrContext - hence, the current context must be dup&#39;ed in
2764                 //order to avoid downstream failures
2765                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2766                 rsEnv.info.selectSuper = cdef != null;
2767                 rsEnv.info.pendingResolutionPhase = null;
2768                 tree.constructor = rs.resolveConstructor(
2769                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2770                 if (cdef == null) { //do not check twice!
2771                     tree.constructorType = checkId(tree,
2772                             clazztype,
2773                             tree.constructor,
2774                             rsEnv,
2775                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2776                     if (rsEnv.info.lastResolveVarargs())
2777                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2778                 }
2779             }
2780 
2781             if (cdef != null) {
2782                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2783                 return;
2784             }
2785 
2786             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2787                 owntype = clazztype;
2788         }
2789         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2790         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2791         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2792             //we need to wait for inference to finish and then replace inference vars in the constructor type
2793             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2794                     instantiatedContext -&gt; {
2795                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2796                     });
2797         }
2798         chk.validate(tree.typeargs, localEnv);
2799     }
2800 
2801         // where
2802         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2803                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2804                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2805                                                    KindSelector pkind) {
2806             // We are seeing an anonymous class instance creation.
2807             // In this case, the class instance creation
2808             // expression
2809             //
2810             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2811             //
2812             // is represented internally as
2813             //
2814             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2815             //
2816             // This expression is then *transformed* as follows:
2817             //
2818             // (1) add an extends or implements clause
2819             // (2) add a constructor.
2820             //
2821             // For instance, if C is a class, and ET is the type of E,
2822             // the expression
2823             //
2824             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2825             //
2826             // is translated to (where X is a fresh name and typarams is the
2827             // parameter list of the super constructor):
2828             //
2829             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2830             //     X extends C&lt;typargs2&gt; {
2831             //       &lt;typarams&gt; X(ET e, args) {
2832             //         e.&lt;typeargs1&gt;super(args)
2833             //       }
2834             //       ...
2835             //     }
2836             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2837             final boolean isDiamond = TreeInfo.isDiamond(tree);
2838             if (isDiamond
2839                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2840                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2841                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2842                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2843                         instantiatedContext -&gt; {
2844                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2845                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2846                             ResultInfo prevResult = this.resultInfo;
2847                             try {
2848                                 this.resultInfo = resultInfoForClassDefinition;
2849                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2850                                                             localEnv, argtypes, typeargtypes, pkind);
2851                             } finally {
2852                                 this.resultInfo = prevResult;
2853                             }
2854                         });
2855             } else {
2856                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2857                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2858                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2859                         // One or more types inferred in the previous steps is non-denotable.
2860                         Fragment fragment = Diamond(clazztype.tsym);
2861                         log.error(tree.clazz.pos(),
2862                                 Errors.CantApplyDiamond1(
2863                                         fragment,
2864                                         invalidDiamondArgs.size() &gt; 1 ?
2865                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2866                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2867                     }
2868                     // For &lt;&gt;(){}, inferred types must also be accessible.
2869                     for (Type t : clazztype.getTypeArguments()) {
2870                         rs.checkAccessibleType(env, t);
2871                     }
2872                     chk.checkParameterizationWithValues(tree, clazztype);
2873                 }
2874 
2875                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2876                 // false for isInterface call even when the original type is an interface.
2877                 boolean implementing = clazztype.tsym.isInterface() ||
2878                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2879                         clazztype.getOriginalType().tsym.isInterface();
2880 
2881                 if (implementing) {
2882                     cdef.implementing = List.of(clazz);
2883                 } else {
2884                     cdef.extending = clazz;
2885                 }
2886 
2887                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2888                     isSerializable(clazztype)) {
2889                     localEnv.info.isSerializable = true;
2890                 }
2891 
2892                 attribStat(cdef, localEnv);
2893 
2894                 List&lt;Type&gt; finalargtypes;
2895                 // If an outer instance is given,
2896                 // prefix it to the constructor arguments
2897                 // and delete it from the new expression
2898                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2899                     finalargtypes = argtypes.prepend(tree.encl.type);
2900                 } else {
2901                     finalargtypes = argtypes;
2902                 }
2903 
2904                 // Reassign clazztype and recompute constructor. As this necessarily involves
2905                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2906                 // them. Original arguments have right decorations already.
2907                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2908                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2909                 }
2910 
2911                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2912                                                     : cdef.sym.type;
2913                 Symbol sym = tree.constructor = rs.resolveConstructor(
2914                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2915                 Assert.check(!sym.kind.isResolutionError());
2916                 tree.constructor = sym;
2917                 tree.constructorType = checkId(tree,
2918                         clazztype,
2919                         tree.constructor,
2920                         localEnv,
2921                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2922             }
2923             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2924                                 clazztype : types.createErrorType(tree.type);
2925             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2926             chk.validate(tree.typeargs, localEnv);
2927         }
2928 
2929         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2930             return new Check.NestedCheckContext(checkContext) {
2931                 @Override
2932                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2933                     enclosingContext.report(clazz.clazz,
2934                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2935                 }
2936             };
2937         }
2938 
2939     /** Make an attributed null check tree.
2940      */
2941     public JCExpression makeNullCheck(JCExpression arg) {
2942         // optimization: new Outer() can never be null; skip null check
2943         if (arg.getTag() == NEWCLASS)
2944             return arg;
2945         // Likewise arg can&#39;t be null if it is a value.
2946         if (types.isValue(arg.type))
2947             return arg;
2948         // optimization: X.this is never null; skip null check
2949         Name name = TreeInfo.name(arg);
2950         if (name == names._this || name == names._super) return arg;
2951 
2952         JCTree.Tag optag = NULLCHK;
2953         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2954         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2955         tree.type = arg.type;
2956         return tree;
2957     }
2958 
2959     public void visitNewArray(JCNewArray tree) {
2960         Type owntype = types.createErrorType(tree.type);
2961         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2962         Type elemtype;
2963         if (tree.elemtype != null) {
2964             elemtype = attribType(tree.elemtype, localEnv);
2965             chk.validate(tree.elemtype, localEnv);
2966             owntype = elemtype;
2967             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2968                 attribExpr(l.head, localEnv, syms.intType);
2969                 owntype = new ArrayType(owntype, syms.arrayClass);
2970             }
2971         } else {
2972             // we are seeing an untyped aggregate { ... }
2973             // this is allowed only if the prototype is an array
2974             if (pt().hasTag(ARRAY)) {
2975                 elemtype = types.elemtype(pt());
2976             } else {
2977                 if (!pt().hasTag(ERROR) &amp;&amp;
2978                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2979                     log.error(tree.pos(),
2980                               Errors.IllegalInitializerForType(pt()));
2981                 }
2982                 elemtype = types.createErrorType(pt());
2983             }
2984         }
2985         if (tree.elems != null) {
2986             attribExprs(tree.elems, localEnv, elemtype);
2987             owntype = new ArrayType(elemtype, syms.arrayClass);
2988         }
2989         if (!types.isReifiable(elemtype))
2990             log.error(tree.pos(), Errors.GenericArrayCreation);
2991         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2992     }
2993 
2994     /*
2995      * A lambda expression can only be attributed when a target-type is available.
2996      * In addition, if the target-type is that of a functional interface whose
2997      * descriptor contains inference variables in argument position the lambda expression
2998      * is &#39;stuck&#39; (see DeferredAttr).
2999      */
3000     @Override
3001     public void visitLambda(final JCLambda that) {
3002         boolean wrongContext = false;
3003         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3004             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3005                 //lambda only allowed in assignment or method invocation/cast context
3006                 log.error(that.pos(), Errors.UnexpectedLambda);
3007             }
3008             resultInfo = recoveryInfo;
3009             wrongContext = true;
3010         }
3011         //create an environment for attribution of the lambda expression
3012         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
3013         boolean needsRecovery =
3014                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
3015         try {
3016             if (needsRecovery &amp;&amp; isSerializable(pt())) {
3017                 localEnv.info.isSerializable = true;
3018                 localEnv.info.isSerializableLambda = true;
3019             }
3020             localEnv.info.isLambda = true;
3021             List&lt;Type&gt; explicitParamTypes = null;
3022             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
3023                 //attribute lambda parameters
3024                 attribStats(that.params, localEnv);
3025                 explicitParamTypes = TreeInfo.types(that.params);
3026             }
3027 
3028             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
3029             Type currentTarget = targetInfo.target;
3030             Type lambdaType = targetInfo.descriptor;
3031 
3032             if (currentTarget.isErroneous()) {
3033                 result = that.type = currentTarget;
3034                 return;
3035             }
3036 
3037             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
3038 
3039             if (lambdaType.hasTag(FORALL)) {
3040                 //lambda expression target desc cannot be a generic method
3041                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3042                                                                     kindName(currentTarget.tsym),
3043                                                                     currentTarget.tsym);
3044                 resultInfo.checkContext.report(that, diags.fragment(msg));
3045                 result = that.type = types.createErrorType(pt());
3046                 return;
3047             }
3048 
3049             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
3050                 //add param type info in the AST
3051                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
3052                 List&lt;JCVariableDecl&gt; params = that.params;
3053 
3054                 boolean arityMismatch = false;
3055 
3056                 while (params.nonEmpty()) {
3057                     if (actuals.isEmpty()) {
3058                         //not enough actuals to perform lambda parameter inference
3059                         arityMismatch = true;
3060                     }
3061                     //reset previously set info
3062                     Type argType = arityMismatch ?
3063                             syms.errType :
3064                             actuals.head;
3065                     if (params.head.isImplicitlyTyped()) {
3066                         setSyntheticVariableType(params.head, argType);
3067                     }
3068                     params.head.sym = null;
3069                     actuals = actuals.isEmpty() ?
3070                             actuals :
3071                             actuals.tail;
3072                     params = params.tail;
3073                 }
3074 
3075                 //attribute lambda parameters
3076                 attribStats(that.params, localEnv);
3077 
3078                 if (arityMismatch) {
3079                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3080                         result = that.type = types.createErrorType(currentTarget);
3081                         return;
3082                 }
3083             }
3084 
3085             //from this point on, no recovery is needed; if we are in assignment context
3086             //we will be able to attribute the whole lambda body, regardless of errors;
3087             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
3088             //with the target-type, it will be recovered anyway in Attr.checkId
3089             needsRecovery = false;
3090 
3091             ResultInfo bodyResultInfo = localEnv.info.returnResult =
3092                     lambdaBodyResult(that, lambdaType, resultInfo);
3093 
3094             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
3095                 attribTree(that.getBody(), localEnv, bodyResultInfo);
3096             } else {
3097                 JCBlock body = (JCBlock)that.body;
3098                 if (body == breakTree &amp;&amp;
3099                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3100                     breakTreeFound(copyEnv(localEnv));
3101                 }
3102                 attribStats(body.stats, localEnv);
3103             }
3104 
3105             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3106 
3107             boolean isSpeculativeRound =
3108                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3109 
3110             preFlow(that);
3111             flow.analyzeLambda(env, that, make, isSpeculativeRound);
3112 
3113             that.type = currentTarget; //avoids recovery at this stage
3114             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
3115 
3116             if (!isSpeculativeRound) {
3117                 //add thrown types as bounds to the thrown types free variables if needed:
3118                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3119                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3120                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3121                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3122                     }
3123                 }
3124 
3125                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3126             }
3127             result = wrongContext ? that.type = types.createErrorType(pt())
3128                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3129         } catch (Types.FunctionDescriptorLookupError ex) {
3130             JCDiagnostic cause = ex.getDiagnostic();
3131             resultInfo.checkContext.report(that, cause);
3132             result = that.type = types.createErrorType(pt());
3133             return;
3134         } catch (CompletionFailure cf) {
3135             chk.completionError(that.pos(), cf);
3136         } catch (Throwable t) {
3137             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3138             //as that would likely cause the same exception again.
3139             needsRecovery = false;
3140             throw t;
3141         } finally {
3142             localEnv.info.scope.leave();
3143             if (needsRecovery) {
3144                 attribTree(that, env, recoveryInfo);
3145             }
3146         }
3147     }
3148     //where
3149         class TargetInfo {
3150             Type target;
3151             Type descriptor;
3152 
3153             public TargetInfo(Type target, Type descriptor) {
3154                 this.target = target;
3155                 this.descriptor = descriptor;
3156             }
3157         }
3158 
3159         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3160             Type lambdaType;
3161             Type currentTarget = resultInfo.pt;
3162             if (resultInfo.pt != Type.recoveryType) {
3163                 /* We need to adjust the target. If the target is an
3164                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3165                  * the target will be updated to SAM
3166                  */
3167                 currentTarget = targetChecker.visit(currentTarget, that);
3168                 if (!currentTarget.isIntersection()) {
3169                     if (explicitParamTypes != null) {
3170                         currentTarget = infer.instantiateFunctionalInterface(that,
3171                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3172                     }
3173                     currentTarget = types.removeWildcards(currentTarget);
3174                     lambdaType = types.findDescriptorType(currentTarget);
3175                 } else {
3176                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3177                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3178                     for (Type bound : ict.getExplicitComponents()) {
3179                         if (explicitParamTypes != null) {
3180                             try {
3181                                 bound = infer.instantiateFunctionalInterface(that,
3182                                         bound, explicitParamTypes, resultInfo.checkContext);
3183                             } catch (FunctionDescriptorLookupError t) {
3184                                 // do nothing
3185                             }
3186                         }
3187                         bound = types.removeWildcards(bound);
3188                         components.add(bound);
3189                     }
3190                     currentTarget = types.makeIntersectionType(components.toList());
3191                     currentTarget.tsym.flags_field |= INTERFACE;
3192                     lambdaType = types.findDescriptorType(currentTarget);
3193                 }
3194 
3195             } else {
3196                 currentTarget = Type.recoveryType;
3197                 lambdaType = fallbackDescriptorType(that);
3198             }
3199             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3200                 //lambda expression target desc cannot be a generic method
3201                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3202                                                                     kindName(currentTarget.tsym),
3203                                                                     currentTarget.tsym);
3204                 resultInfo.checkContext.report(that, diags.fragment(msg));
3205                 currentTarget = types.createErrorType(pt());
3206             }
3207             return new TargetInfo(currentTarget, lambdaType);
3208         }
3209 
3210         void preFlow(JCLambda tree) {
3211             new PostAttrAnalyzer() {
3212                 @Override
3213                 public void scan(JCTree tree) {
3214                     if (tree == null ||
3215                             (tree.type != null &amp;&amp;
3216                             tree.type == Type.stuckType)) {
3217                         //don&#39;t touch stuck expressions!
3218                         return;
3219                     }
3220                     super.scan(tree);
3221                 }
3222 
3223                 @Override
3224                 public void visitClassDef(JCClassDecl that) {
3225                     // or class declaration trees!
3226                 }
3227 
3228                 public void visitLambda(JCLambda that) {
3229                     // or lambda expressions!
3230                 }
3231             }.scan(tree.body);
3232         }
3233 
3234         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3235 
3236             @Override
3237             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3238                 return t.isIntersection() ?
3239                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3240             }
3241 
3242             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3243                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3244                 return ict;
3245             }
3246 
3247             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3248                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3249                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3250                 for (Type i : ict.interfaces_field) {
3251                     if (i.isParameterized()) {
3252                         targs.appendList(i.tsym.type.allparams());
3253                     }
3254                     supertypes.append(i.tsym.type);
3255                 }
3256                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3257                 notionalIntf.allparams_field = targs.toList();
3258                 notionalIntf.tsym.flags_field |= INTERFACE;
3259                 return notionalIntf.tsym;
3260             }
3261         };
3262 
3263         private Type fallbackDescriptorType(JCExpression tree) {
3264             switch (tree.getTag()) {
3265                 case LAMBDA:
3266                     JCLambda lambda = (JCLambda)tree;
3267                     List&lt;Type&gt; argtypes = List.nil();
3268                     for (JCVariableDecl param : lambda.params) {
3269                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3270                                 argtypes.append(param.vartype.type) :
3271                                 argtypes.append(syms.errType);
3272                     }
3273                     return new MethodType(argtypes, Type.recoveryType,
3274                             List.of(syms.throwableType), syms.methodClass);
3275                 case REFERENCE:
3276                     return new MethodType(List.nil(), Type.recoveryType,
3277                             List.of(syms.throwableType), syms.methodClass);
3278                 default:
3279                     Assert.error(&quot;Cannot get here!&quot;);
3280             }
3281             return null;
3282         }
3283 
3284         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3285                 final InferenceContext inferenceContext, final Type... ts) {
3286             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3287         }
3288 
3289         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3290                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3291             if (inferenceContext.free(ts)) {
3292                 inferenceContext.addFreeTypeListener(ts,
3293                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3294             } else {
3295                 for (Type t : ts) {
3296                     rs.checkAccessibleType(env, t);
3297                 }
3298             }
3299         }
3300 
3301         /**
3302          * Lambda/method reference have a special check context that ensures
3303          * that i.e. a lambda return type is compatible with the expected
3304          * type according to both the inherited context and the assignment
3305          * context.
3306          */
3307         class FunctionalReturnContext extends Check.NestedCheckContext {
3308 
3309             FunctionalReturnContext(CheckContext enclosingContext) {
3310                 super(enclosingContext);
3311             }
3312 
3313             @Override
3314             public boolean compatible(Type found, Type req, Warner warn) {
3315                 //return type must be compatible in both current context and assignment context
3316                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3317             }
3318 
3319             @Override
3320             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3321                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3322             }
3323         }
3324 
3325         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3326 
3327             JCExpression expr;
3328             boolean expStmtExpected;
3329 
3330             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3331                 super(enclosingContext);
3332                 this.expr = expr;
3333             }
3334 
3335             @Override
3336             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3337                 if (expStmtExpected) {
3338                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3339                 } else {
3340                     super.report(pos, details);
3341                 }
3342             }
3343 
3344             @Override
3345             public boolean compatible(Type found, Type req, Warner warn) {
3346                 //a void return is compatible with an expression statement lambda
3347                 if (req.hasTag(VOID)) {
3348                     expStmtExpected = true;
3349                     return TreeInfo.isExpressionStatement(expr);
3350                 } else {
3351                     return super.compatible(found, req, warn);
3352                 }
3353             }
3354         }
3355 
3356         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3357             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3358                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3359                     new FunctionalReturnContext(resultInfo.checkContext);
3360 
3361             return descriptor.getReturnType() == Type.recoveryType ?
3362                     recoveryInfo :
3363                     new ResultInfo(KindSelector.VAL,
3364                             descriptor.getReturnType(), funcContext);
3365         }
3366 
3367         /**
3368         * Lambda compatibility. Check that given return types, thrown types, parameter types
3369         * are compatible with the expected functional interface descriptor. This means that:
3370         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3371         * types must be compatible with the return type of the expected descriptor.
3372         */
3373         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3374             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3375 
3376             //return values have already been checked - but if lambda has no return
3377             //values, we must ensure that void/value compatibility is correct;
3378             //this amounts at checking that, if a lambda body can complete normally,
3379             //the descriptor&#39;s return type must be void
3380             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3381                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3382                 Fragment msg =
3383                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3384                 checkContext.report(tree,
3385                                     diags.fragment(msg));
3386             }
3387 
3388             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3389             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3390                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3391             }
3392         }
3393 
3394         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3395          * static field and that lambda has type annotations, these annotations will
3396          * also be stored at these fake clinit methods.
3397          *
3398          * LambdaToMethod also use fake clinit methods so they can be reused.
3399          * Also as LTM is a phase subsequent to attribution, the methods from
3400          * clinits can be safely removed by LTM to save memory.
3401          */
3402         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3403 
3404         public MethodSymbol removeClinit(ClassSymbol sym) {
3405             return clinits.remove(sym);
3406         }
3407 
3408         /* This method returns an environment to be used to attribute a lambda
3409          * expression.
3410          *
3411          * The owner of this environment is a method symbol. If the current owner
3412          * is not a method, for example if the lambda is used to initialize
3413          * a field, then if the field is:
3414          *
3415          * - an instance field, we use the first constructor.
3416          * - a static field, we create a fake clinit method.
3417          */
3418         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3419             Env&lt;AttrContext&gt; lambdaEnv;
3420             Symbol owner = env.info.scope.owner;
3421             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3422                 //field initializer
3423                 ClassSymbol enclClass = owner.enclClass();
3424                 Symbol newScopeOwner = env.info.scope.owner;
3425                 /* if the field isn&#39;t static, then we can get the first constructor
3426                  * and use it as the owner of the environment. This is what
3427                  * LTM code is doing to look for type annotations so we are fine.
3428                  */
3429                 if ((owner.flags() &amp; STATIC) == 0) {
3430                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3431                         newScopeOwner = s;
3432                         break;
3433                     }
3434                 } else {
3435                     /* if the field is static then we need to create a fake clinit
3436                      * method, this method can later be reused by LTM.
3437                      */
3438                     MethodSymbol clinit = clinits.get(enclClass);
3439                     if (clinit == null) {
3440                         Type clinitType = new MethodType(List.nil(),
3441                                 syms.voidType, List.nil(), syms.methodClass);
3442                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3443                                 names.clinit, clinitType, enclClass);
3444                         clinit.params = List.nil();
3445                         clinits.put(enclClass, clinit);
3446                     }
3447                     newScopeOwner = clinit;
3448                 }
3449                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3450             } else {
3451                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3452             }
3453             lambdaEnv.info.yieldResult = null;
3454             return lambdaEnv;
3455         }
3456 
3457     @Override
3458     public void visitReference(final JCMemberReference that) {
3459         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3460             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3461                 //method reference only allowed in assignment or method invocation/cast context
3462                 log.error(that.pos(), Errors.UnexpectedMref);
3463             }
3464             result = that.type = types.createErrorType(pt());
3465             return;
3466         }
3467         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3468         try {
3469             //attribute member reference qualifier - if this is a constructor
3470             //reference, the expected kind must be a type
3471             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3472 
3473             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3474                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3475                 if (!exprType.isErroneous() &amp;&amp;
3476                     exprType.isRaw() &amp;&amp;
3477                     that.typeargs != null) {
3478                     log.error(that.expr.pos(),
3479                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3480                                                  Fragments.MrefInferAndExplicitParams));
3481                     exprType = types.createErrorType(exprType);
3482                 }
3483             }
3484 
3485             if (exprType.isErroneous()) {
3486                 //if the qualifier expression contains problems,
3487                 //give up attribution of method reference
3488                 result = that.type = exprType;
3489                 return;
3490             }
3491 
3492             if (TreeInfo.isStaticSelector(that.expr, names)) {
3493                 //if the qualifier is a type, validate it; raw warning check is
3494                 //omitted as we don&#39;t know at this stage as to whether this is a
3495                 //raw selector (because of inference)
3496                 chk.validate(that.expr, env, false);
3497             } else {
3498                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3499                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3500             }
3501             //attrib type-arguments
3502             List&lt;Type&gt; typeargtypes = List.nil();
3503             if (that.typeargs != null) {
3504                 typeargtypes = attribTypes(that.typeargs, localEnv);
3505             }
3506 
3507             boolean isTargetSerializable =
3508                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3509                     isSerializable(pt());
3510             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3511             Type currentTarget = targetInfo.target;
3512             Type desc = targetInfo.descriptor;
3513 
3514             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3515             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3516             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3517 
3518             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3519                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3520             }
3521 
3522             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3523             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3524             try {
3525                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3526                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3527                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3528             } finally {
3529                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3530             }
3531 
3532             Symbol refSym = refResult.fst;
3533             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3534 
3535             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3536              *  JDK-8075541
3537              */
3538             if (refSym.kind != MTH) {
3539                 boolean targetError;
3540                 switch (refSym.kind) {
3541                     case ABSENT_MTH:
3542                     case MISSING_ENCL:
3543                         targetError = false;
3544                         break;
3545                     case WRONG_MTH:
3546                     case WRONG_MTHS:
3547                     case AMBIGUOUS:
3548                     case HIDDEN:
3549                     case STATICERR:
3550                         targetError = true;
3551                         break;
3552                     default:
3553                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3554                         targetError = false;
3555                 }
3556 
3557                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3558                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3559                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3560 
3561                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3562                         targetError ?
3563                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3564                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3565 
3566                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3567                     //a target error doesn&#39;t make sense during recovery stage
3568                     //as we don&#39;t know what actual parameter types are
3569                     result = that.type = currentTarget;
3570                     return;
3571                 } else {
3572                     if (targetError) {
3573                         resultInfo.checkContext.report(that, diag);
3574                     } else {
3575                         log.report(diag);
3576                     }
3577                     result = that.type = types.createErrorType(currentTarget);
3578                     return;
3579                 }
3580             }
3581 
3582             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3583             that.kind = lookupHelper.referenceKind(that.sym);
3584             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3585 
3586             if (desc.getReturnType() == Type.recoveryType) {
3587                 // stop here
3588                 result = that.type = currentTarget;
3589                 return;
3590             }
3591 
3592             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3593                 Type enclosingType = exprType.getEnclosingType();
3594                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3595                     // Check for the existence of an appropriate outer instance
3596                     rs.resolveImplicitThis(that.pos(), env, exprType);
3597                 }
3598             }
3599 
3600             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3601 
3602                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3603                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3604                         that.kind.isUnbound() &amp;&amp;
3605                         lookupHelper.site.isRaw()) {
3606                     chk.checkRaw(that.expr, localEnv);
3607                 }
3608 
3609                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3610                         exprType.getTypeArguments().nonEmpty()) {
3611                     //static ref with class type-args
3612                     log.error(that.expr.pos(),
3613                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3614                                                  Fragments.StaticMrefWithTargs));
3615                     result = that.type = types.createErrorType(currentTarget);
3616                     return;
3617                 }
3618 
3619                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3620                     // Check that super-qualified symbols are not abstract (JLS)
3621                     rs.checkNonAbstract(that.pos(), that.sym);
3622                 }
3623 
3624                 if (isTargetSerializable) {
3625                     chk.checkAccessFromSerializableElement(that, true);
3626                 }
3627             }
3628 
3629             ResultInfo checkInfo =
3630                     resultInfo.dup(newMethodTemplate(
3631                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3632                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3633                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3634 
3635             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3636 
3637             if (that.kind.isUnbound() &amp;&amp;
3638                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3639                 //re-generate inference constraints for unbound receiver
3640                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3641                     //cannot happen as this has already been checked - we just need
3642                     //to regenerate the inference constraints, as that has been lost
3643                     //as a result of the call to inferenceContext.save()
3644                     Assert.error(&quot;Can&#39;t get here&quot;);
3645                 }
3646             }
3647 
3648             if (!refType.isErroneous()) {
3649                 refType = types.createMethodTypeWithReturn(refType,
3650                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3651             }
3652 
3653             //go ahead with standard method reference compatibility check - note that param check
3654             //is a no-op (as this has been taken care during method applicability)
3655             boolean isSpeculativeRound =
3656                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3657 
3658             that.type = currentTarget; //avoids recovery at this stage
3659             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3660             if (!isSpeculativeRound) {
3661                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3662             }
3663             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3664         } catch (Types.FunctionDescriptorLookupError ex) {
3665             JCDiagnostic cause = ex.getDiagnostic();
3666             resultInfo.checkContext.report(that, cause);
3667             result = that.type = types.createErrorType(pt());
3668             return;
3669         }
3670     }
3671     //where
3672         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3673             //if this is a constructor reference, the expected kind must be a type
3674             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3675                                   KindSelector.VAL_TYP : KindSelector.TYP,
3676                                   Type.noType);
3677         }
3678 
3679 
3680     @SuppressWarnings(&quot;fallthrough&quot;)
3681     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3682         InferenceContext inferenceContext = checkContext.inferenceContext();
3683         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3684 
3685         Type resType;
3686         switch (tree.getMode()) {
3687             case NEW:
3688                 if (!tree.expr.type.isRaw()) {
3689                     resType = tree.expr.type;
3690                     break;
3691                 }
3692             default:
3693                 resType = refType.getReturnType();
3694         }
3695 
3696         Type incompatibleReturnType = resType;
3697 
3698         if (returnType.hasTag(VOID)) {
3699             incompatibleReturnType = null;
3700         }
3701 
3702         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3703             if (resType.isErroneous() ||
3704                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3705                             checkContext.checkWarner(tree, resType, returnType))) {
3706                 incompatibleReturnType = null;
3707             }
3708         }
3709 
3710         if (incompatibleReturnType != null) {
3711             Fragment msg =
3712                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3713             checkContext.report(tree, diags.fragment(msg));
3714         } else {
3715             if (inferenceContext.free(refType)) {
3716                 // we need to wait for inference to finish and then replace inference vars in the referent type
3717                 inferenceContext.addFreeTypeListener(List.of(refType),
3718                         instantiatedContext -&gt; {
3719                             tree.referentType = instantiatedContext.asInstType(refType);
3720                         });
3721             } else {
3722                 tree.referentType = refType;
3723             }
3724         }
3725 
3726         if (!speculativeAttr) {
3727             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3728                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3729             }
3730         }
3731     }
3732 
3733     boolean checkExConstraints(
3734             List&lt;Type&gt; thrownByFuncExpr,
3735             List&lt;Type&gt; thrownAtFuncType,
3736             InferenceContext inferenceContext) {
3737         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3738          *  are not proper types
3739          */
3740         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3741                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3742         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3743 
3744         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3745          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3746          *  declaration
3747          */
3748         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3749                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3750 
3751         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3752          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3753          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3754          *  reduces to true
3755          */
3756         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3757         for (Type checked : checkedList) {
3758             boolean isSubtype = false;
3759             for (Type proper : properList) {
3760                 if (types.isSubtype(checked, proper)) {
3761                     isSubtype = true;
3762                     break;
3763                 }
3764             }
3765             if (!isSubtype) {
3766                 uncaughtByProperTypes.add(checked);
3767             }
3768         }
3769 
3770         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3771             return false;
3772         }
3773 
3774         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3775          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3776          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3777          */
3778         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3779         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3780             nonProperAsUndet.forEach(nonProper -&gt; {
3781                 types.isSubtype(checkedEx, nonProper);
3782             });
3783         });
3784 
3785         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3786          */
3787         nonProperAsUndet.stream()
3788                 .filter(t -&gt; t.hasTag(UNDETVAR))
3789                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3790         return true;
3791     }
3792 
3793     /**
3794      * Set functional type info on the underlying AST. Note: as the target descriptor
3795      * might contain inference variables, we might need to register an hook in the
3796      * current inference context.
3797      */
3798     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3799             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3800         if (checkContext.inferenceContext().free(descriptorType)) {
3801             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3802                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3803                     inferenceContext.asInstType(primaryTarget), checkContext));
3804         } else {
3805             if (pt.hasTag(CLASS)) {
3806                 fExpr.target = primaryTarget;
3807             }
3808             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3809                     pt != Type.recoveryType) {
3810                 //check that functional interface class is well-formed
3811                 try {
3812                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3813                      * when it&#39;s executed post-inference. See the listener code
3814                      * above.
3815                      */
3816                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3817                             names.empty, fExpr.target, ABSTRACT);
3818                     if (csym != null) {
3819                         chk.checkImplementations(env.tree, csym, csym);
3820                         try {
3821                             //perform an additional functional interface check on the synthetic class,
3822                             //as there may be spurious errors for raw targets - because of existing issues
3823                             //with membership and inheritance (see JDK-8074570).
3824                             csym.flags_field |= INTERFACE;
3825                             types.findDescriptorType(csym.type);
3826                         } catch (FunctionDescriptorLookupError err) {
3827                             resultInfo.checkContext.report(fExpr,
3828                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3829                         }
3830                     }
3831                 } catch (Types.FunctionDescriptorLookupError ex) {
3832                     JCDiagnostic cause = ex.getDiagnostic();
3833                     resultInfo.checkContext.report(env.tree, cause);
3834                 }
3835             }
3836         }
3837     }
3838 
3839     public void visitParens(JCParens tree) {
3840         Type owntype = attribTree(tree.expr, env, resultInfo);
3841         result = check(tree, owntype, pkind(), resultInfo);
3842         Symbol sym = TreeInfo.symbol(tree);
3843         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3844             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3845     }
3846 
3847     public void visitAssign(JCAssign tree) {
3848         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3849         Type capturedType = capture(owntype);
3850         attribExpr(tree.rhs, env, owntype);
3851         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3852     }
3853 
3854     public void visitAssignop(JCAssignOp tree) {
3855         // Attribute arguments.
3856         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3857         Type operand = attribExpr(tree.rhs, env);
3858         // Find operator.
3859         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3860         if (operator != operators.noOpSymbol &amp;&amp;
3861                 !owntype.isErroneous() &amp;&amp;
3862                 !operand.isErroneous()) {
3863             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3864             chk.checkCastable(tree.rhs.pos(),
3865                               operator.type.getReturnType(),
3866                               owntype);
3867         }
3868         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3869     }
3870 
3871     public void visitUnary(JCUnary tree) {
3872         // Attribute arguments.
3873         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3874             ? attribTree(tree.arg, env, varAssignmentInfo)
3875             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3876 
3877         // Find operator.
3878         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3879         Type owntype = types.createErrorType(tree.type);
3880         if (operator != operators.noOpSymbol &amp;&amp;
3881                 !argtype.isErroneous()) {
3882             owntype = (tree.getTag().isIncOrDecUnaryOp())
3883                 ? tree.arg.type
3884                 : operator.type.getReturnType();
3885             int opc = ((OperatorSymbol)operator).opcode;
3886 
3887             // If the argument is constant, fold it.
3888             if (argtype.constValue() != null) {
3889                 Type ctype = cfolder.fold1(opc, argtype);
3890                 if (ctype != null) {
3891                     owntype = cfolder.coerce(ctype, owntype);
3892                 }
3893             }
3894         }
3895         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3896         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3897     }
3898 
3899     public void visitBinary(JCBinary tree) {
3900         // Attribute arguments.
3901         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3902         // x &amp;&amp; y
3903         // include x&#39;s bindings when true in y
3904 
3905         // x || y
3906         // include x&#39;s bindings when false in y
3907 
3908         MatchBindings lhsBindings = matchBindings;
3909         List&lt;BindingSymbol&gt; propagatedBindings;
3910         switch (tree.getTag()) {
3911             case AND:
3912                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3913                 break;
3914             case OR:
3915                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3916                 break;
3917             default:
3918                 propagatedBindings = List.nil();
3919                 break;
3920         }
3921         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3922         Type right;
3923         try {
3924             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3925         } finally {
3926             rhsEnv.info.scope.leave();
3927         }
3928 
3929         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3930 
3931         // Find operator.
3932         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3933         Type owntype = types.createErrorType(tree.type);
3934         if (operator != operators.noOpSymbol &amp;&amp;
3935                 !left.isErroneous() &amp;&amp;
3936                 !right.isErroneous()) {
3937             owntype = operator.type.getReturnType();
3938             int opc = ((OperatorSymbol)operator).opcode;
3939             // If both arguments are constants, fold them.
3940             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3941                 Type ctype = cfolder.fold2(opc, left, right);
3942                 if (ctype != null) {
3943                     owntype = cfolder.coerce(ctype, owntype);
3944                 }
3945             }
3946 
3947             // Check that argument types of a reference ==, != are
3948             // castable to each other, (JLS 15.21).  Note: unboxing
3949             // comparisons will not have an acmp* opc at this point.
3950             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3951                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3952                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3953                 }
3954                 chk.checkForSuspectClassLiteralComparison(tree, left, right);
3955             }
3956 
3957             chk.checkDivZero(tree.rhs.pos(), operator, right);
3958         }
3959         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3960     }
3961 
3962     public void visitTypeCast(final JCTypeCast tree) {
3963         Type clazztype = attribType(tree.clazz, env);
3964         chk.validate(tree.clazz, env, false);
3965         //a fresh environment is required for 292 inference to work properly ---
3966         //see Infer.instantiatePolymorphicSignatureInstance()
3967         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3968         //should we propagate the target type?
3969         final ResultInfo castInfo;
3970         JCExpression expr = TreeInfo.skipParens(tree.expr);
3971         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3972         if (isPoly) {
3973             //expression is a poly - we need to propagate target type info
3974             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
3975                                       new Check.NestedCheckContext(resultInfo.checkContext) {
3976                 @Override
3977                 public boolean compatible(Type found, Type req, Warner warn) {
3978                     return types.isCastable(found, req, warn);
3979                 }
3980             });
3981         } else {
3982             //standalone cast - target-type info is not propagated
3983             castInfo = unknownExprInfo;
3984         }
3985         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3986         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3987         if (exprtype.constValue() != null)
3988             owntype = cfolder.coerce(exprtype, owntype);
3989         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3990         if (!isPoly)
3991             chk.checkRedundantCast(localEnv, tree);
3992     }
3993 
3994     public void visitTypeTest(JCInstanceOf tree) {
3995         Type exprtype = chk.checkNullOrRefType(
3996                 tree.expr.pos(), attribExpr(tree.expr, env));
3997         Type clazztype;
3998         JCTree typeTree;
3999         if (tree.pattern.getTag() == BINDINGPATTERN) {
4000             attribTree(tree.pattern, env, unknownExprInfo);
4001             clazztype = tree.pattern.type;
4002             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
4003             typeTree = pattern.vartype;
4004             if (!clazztype.hasTag(TYPEVAR)) {
4005                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
4006             }
4007         } else {
4008             clazztype = attribType(tree.pattern, env);
4009             typeTree = tree.pattern;
4010         }
4011         if (!clazztype.hasTag(TYPEVAR)) {
4012             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
4013         }
4014         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
4015             boolean valid = false;
4016             if (allowReifiableTypesInInstanceof) {
4017                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
4018                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
4019                 }
4020                 Warner warner = new Warner();
4021                 if (!types.isCastable(exprtype, clazztype, warner)) {
4022                     chk.basicHandler.report(tree.expr.pos(),
4023                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));
4024                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {
4025                     log.error(tree.expr.pos(),
4026                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
4027                 } else {
4028                     valid = true;
4029                 }
4030             } else {
4031                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
4032             }
4033             if (!valid) {
4034                 clazztype = types.createErrorType(clazztype);
4035             }
4036         }
4037         chk.validate(typeTree, env, false);
4038         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4039         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
4040     }
4041 
4042     public void visitBindingPattern(JCBindingPattern tree) {
4043         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
4044         tree.type = attribTree(tree.vartype, env, varInfo);
4045         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);
4046         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
4047             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
4048         }
4049         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
4050         annotate.flush();
4051         result = tree.type;
4052         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
4053     }
4054 
4055     public void visitIndexed(JCArrayAccess tree) {
4056         Type owntype = types.createErrorType(tree.type);
4057         Type atype = attribExpr(tree.indexed, env);
4058         attribExpr(tree.index, env, syms.intType);
4059         if (types.isArray(atype))
4060             owntype = types.elemtype(atype);
4061         else if (!atype.hasTag(ERROR))
4062             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
4063         if (!pkind().contains(KindSelector.VAL))
4064             owntype = capture(owntype);
4065         result = check(tree, owntype, KindSelector.VAR, resultInfo);
4066     }
4067 
4068     public void visitIdent(JCIdent tree) {
4069         Symbol sym;
4070 
4071         // Find symbol
4072         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
4073             // If we are looking for a method, the prototype `pt&#39; will be a
4074             // method type with the type of the call&#39;s arguments as parameters.
4075             env.info.pendingResolutionPhase = null;
4076             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
4077         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
4078             sym = tree.sym;
4079         } else {
<a name="5" id="anc5"></a><span class="line-modified">4080             boolean wasQuestioned = env.info.isQuestioned;</span>
<span class="line-removed">4081             try {</span>
<span class="line-removed">4082                 env.info.isQuestioned = tree.isQuestioned();</span>
<span class="line-removed">4083                 sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());</span>
<span class="line-removed">4084             } finally {</span>
<span class="line-removed">4085                 env.info.isQuestioned = wasQuestioned;</span>
<span class="line-removed">4086             }</span>
4087         }
4088         tree.sym = sym;
4089 
4090         // (1) Also find the environment current for the class where
4091         //     sym is defined (`symEnv&#39;).
4092         // Only for pre-tiger versions (1.4 and earlier):
4093         // (2) Also determine whether we access symbol out of an anonymous
4094         //     class in a this or super call.  This is illegal for instance
4095         //     members since such classes don&#39;t carry a this$n link.
4096         //     (`noOuterThisPath&#39;).
4097         Env&lt;AttrContext&gt; symEnv = env;
4098         boolean noOuterThisPath = false;
4099         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
4100             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4101             sym.owner.kind == TYP &amp;&amp;
4102             tree.name != names._this &amp;&amp; tree.name != names._super) {
4103 
4104             // Find environment in which identifier is defined.
4105             while (symEnv.outer != null &amp;&amp;
4106                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
4107                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
4108                     noOuterThisPath = false;
4109                 symEnv = symEnv.outer;
4110             }
4111         }
4112 
4113         // If symbol is a variable, ...
4114         if (sym.kind == VAR) {
4115             VarSymbol v = (VarSymbol)sym;
4116 
4117             // ..., evaluate its initializer, if it has one, and check for
4118             // illegal forward reference.
4119             checkInit(tree, env, v, false);
4120 
4121             // If we are expecting a variable (as opposed to a value), check
4122             // that the variable is assignable in the current environment.
4123             if (KindSelector.ASG.subset(pkind()))
4124                 checkAssignable(tree.pos(), v, null, env);
4125         }
4126 
4127         // In a constructor body,
4128         // if symbol is a field or instance method, check that it is
4129         // not accessed before the supertype constructor is called.
4130         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4131             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4132             sym.owner.kind == TYP &amp;&amp;
4133             (sym.flags() &amp; STATIC) == 0) {
4134             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4135                                           sym : thisSym(tree.pos(), env));
4136         }
4137         Env&lt;AttrContext&gt; env1 = env;
4138         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4139             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4140             // If the found symbol is inaccessible, then it is
4141             // accessed through an enclosing instance.  Locate this
4142             // enclosing instance:
4143             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4144                 env1 = env1.outer;
4145         }
4146 
4147         if (env.info.isSerializable) {
4148             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4149         }
4150 
4151         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4152     }
4153 
4154     public void visitSelect(JCFieldAccess tree) {
4155         // Determine the expected kind of the qualifier expression.
4156         KindSelector skind = KindSelector.NIL;
4157         if (tree.name == names._this || tree.name == names._super ||
4158                 tree.name == names._class || tree.name == names._default)
4159         {
4160             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {
4161                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),
4162                         Feature.INLINE_TYPES.error(sourceName));
4163             }
4164             skind = KindSelector.TYP;
4165         } else {
4166             if (pkind().contains(KindSelector.PCK))
4167                 skind = KindSelector.of(skind, KindSelector.PCK);
4168             if (pkind().contains(KindSelector.TYP))
4169                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4170             if (pkind().contains(KindSelector.VAL_MTH))
4171                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4172         }
4173 
4174         // Attribute the qualifier expression, and determine its symbol (if any).
4175         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4176         if (!pkind().contains(KindSelector.TYP_PCK))
4177             site = capture(site); // Capture field access
4178 
4179         // don&#39;t allow T.class T[].class, etc
4180         if (skind == KindSelector.TYP) {
4181             Type elt = site;
4182             while (elt.hasTag(ARRAY))
4183                 elt = ((ArrayType)elt).elemtype;
4184             if (elt.hasTag(TYPEVAR)) {
4185                 if (tree.name == names._default) {
4186                     result = check(tree, litType(BOT).constType(null),
4187                             KindSelector.VAL, resultInfo);
4188                 } else {
4189                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);
4190                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);
4191                     tree.sym = tree.type.tsym;
4192                     return;
4193                 }
4194             }
4195         }
4196 
4197         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4198         // for the selection. This is relevant for determining whether
4199         // protected symbols are accessible.
4200         Symbol sitesym = TreeInfo.symbol(tree.selected);
4201 
<a name="6" id="anc6"></a><span class="line-removed">4202         /* As we simply attach the members from the value type to its light weight box type</span>
<span class="line-removed">4203            without reassigning ownership, always perform any lookups on the value type.</span>
<span class="line-removed">4204          */</span>
<span class="line-removed">4205         if (site.tsym.isProjectedNullable())</span>
<span class="line-removed">4206             site = site.tsym.nullFreeTypeSymbol().type;</span>
<span class="line-removed">4207 </span>
4208         boolean selectSuperPrev = env.info.selectSuper;
4209         env.info.selectSuper =
4210             sitesym != null &amp;&amp;
4211             sitesym.name == names._super;
4212 
4213         // Determine the symbol represented by the selection.
4214         env.info.pendingResolutionPhase = null;
<a name="7" id="anc7"></a><span class="line-modified">4215         boolean wasQuestioned = env.info.isQuestioned;</span>
<span class="line-removed">4216         Symbol sym;</span>
<span class="line-removed">4217         try {</span>
<span class="line-removed">4218             env.info.isQuestioned = tree.isQuestioned();</span>
<span class="line-removed">4219             sym = selectSym(tree, sitesym, site, env, resultInfo);</span>
<span class="line-removed">4220         } finally {</span>
<span class="line-removed">4221             env.info.isQuestioned = wasQuestioned;</span>
<span class="line-removed">4222         }</span>
4223         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4224             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4225             sym = syms.errSymbol;
4226         }
4227         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4228             site = capture(site);
4229             sym = selectSym(tree, sitesym, site, env, resultInfo);
4230         }
4231         boolean varArgs = env.info.lastResolveVarargs();
4232         tree.sym = sym;
4233 
4234         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4235             site = types.skipTypeVars(site, true);
4236         }
4237 
4238         // If that symbol is a variable, ...
4239         if (sym.kind == VAR) {
4240             VarSymbol v = (VarSymbol)sym;
4241 
4242             // ..., evaluate its initializer, if it has one, and check for
4243             // illegal forward reference.
4244             checkInit(tree, env, v, true);
4245 
4246             // If we are expecting a variable (as opposed to a value), check
4247             // that the variable is assignable in the current environment.
4248             if (KindSelector.ASG.subset(pkind()))
4249                 checkAssignable(tree.pos(), v, tree.selected, env);
4250         }
4251 
4252         if (sitesym != null &amp;&amp;
4253                 sitesym.kind == VAR &amp;&amp;
4254                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4255                 sym.kind == MTH &amp;&amp;
4256                 sym.name.equals(names.close) &amp;&amp;
4257                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4258                 env.info.lint.isEnabled(LintCategory.TRY)) {
4259             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4260         }
4261 
4262         // Disallow selecting a type from an expression
4263         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4264             tree.type = check(tree.selected, pt(),
4265                               sitesym == null ?
4266                                       KindSelector.VAL : sitesym.kind.toSelector(),
4267                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4268         }
4269 
4270         if (isType(sitesym)) {
4271             if (sym.name == names._this) {
4272                 // If `C&#39; is the currently compiled class, check that
4273                 // C.this&#39; does not appear in a call to a super(...)
4274                 if (env.info.isSelfCall &amp;&amp;
4275                     site.tsym == env.enclClass.sym) {
4276                     chk.earlyRefError(tree.pos(), sym);
4277                 }
4278             } else {
4279                 // Check if type-qualified fields or methods are static (JLS)
4280                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4281                     sym.name != names._super &amp;&amp;
4282                     (sym.kind == VAR || sym.kind == MTH)) {
4283                     rs.accessBase(rs.new StaticError(sym),
4284                               tree.pos(), site, sym.name, true);
4285                 }
4286             }
4287             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4288                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4289                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4290             }
4291         } else if (sym.kind != ERR &amp;&amp;
4292                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4293                    sym.name != names._class) {
4294             // If the qualified item is not a type and the selected item is static, report
4295             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4296             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4297         }
4298 
4299         // If we are selecting an instance member via a `super&#39;, ...
4300         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4301 
4302             // Check that super-qualified symbols are not abstract (JLS)
4303             rs.checkNonAbstract(tree.pos(), sym);
4304 
4305             if (site.isRaw()) {
4306                 // Determine argument types for site.
4307                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4308                 if (site1 != null) site = site1;
4309             }
4310         }
4311 
4312         if (env.info.isSerializable) {
4313             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4314         }
4315 
4316         env.info.selectSuper = selectSuperPrev;
4317         result = checkId(tree, site, sym, env, resultInfo);
4318     }
4319     //where
4320         /** Determine symbol referenced by a Select expression,
4321          *
4322          *  @param tree   The select tree.
4323          *  @param site   The type of the selected expression,
4324          *  @param env    The current environment.
4325          *  @param resultInfo The current result.
4326          */
4327         private Symbol selectSym(JCFieldAccess tree,
4328                                  Symbol location,
4329                                  Type site,
4330                                  Env&lt;AttrContext&gt; env,
4331                                  ResultInfo resultInfo) {
4332             DiagnosticPosition pos = tree.pos();
4333             Name name = tree.name;
4334             switch (site.getTag()) {
4335             case PACKAGE:
4336                 return rs.accessBase(
4337                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4338                     pos, location, site, name, true);
4339             case ARRAY:
4340             case CLASS:
4341                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4342                     return rs.resolveQualifiedMethod(
4343                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4344                 } else if (name == names._this || name == names._super) {
4345                     return rs.resolveSelf(pos, env, site.tsym, name);
4346                 } else if (name == names._class) {
4347                     // In this case, we have already made sure in
4348                     // visitSelect that qualifier expression is a type.
4349                     return syms.getClassField(site, types);
4350                 } else if (name == names._default) {
4351                     return new VarSymbol(STATIC, names._default, site, site.tsym);
<a name="8" id="anc8"></a>



4352                 } else {
4353                     // We are seeing a plain identifier as selector.
4354                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4355                         sym = rs.accessBase(sym, pos, location, site, name, true);
4356                     return sym;
4357                 }
4358             case WILDCARD:
4359                 throw new AssertionError(tree);
4360             case TYPEVAR:
4361                 if (name == names._default) {
4362                     // Be sure to return the default value before examining bounds
4363                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4364                 }
4365                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4366                 // It should only happen during memberEnter/attribBase
4367                 // when determining the super type which *must* be
4368                 // done before attributing the type variables.  In
4369                 // other words, we are seeing this illegal program:
4370                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4371                 Symbol sym = (site.getUpperBound() != null)
4372                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4373                     : null;
4374                 if (sym == null) {
4375                     log.error(pos, Errors.TypeVarCantBeDeref);
4376                     return syms.errSymbol;
4377                 } else {
4378                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4379                         rs.new AccessError(env, site, sym) :
4380                                 sym;
4381                     rs.accessBase(sym2, pos, location, site, name, true);
4382                     return sym;
4383                 }
4384             case ERROR:
4385                 // preserve identifier names through errors
4386                 return types.createErrorType(name, site.tsym, site).tsym;
4387             default:
4388                 // The qualifier expression is of a primitive type -- only
4389                 // .class and .default is allowed for these.
4390                 if (name == names._class) {
4391                     // In this case, we have already made sure in Select that
4392                     // qualifier expression is a type.
4393                     return syms.getClassField(site, types);
4394                 } else if (name == names._default) {
4395                     return new VarSymbol(STATIC, names._default, site, site.tsym);
4396                 } else {
4397                     log.error(pos, Errors.CantDeref(site));
4398                     return syms.errSymbol;
4399                 }
4400             }
4401         }
4402 
4403         /** Determine type of identifier or select expression and check that
4404          *  (1) the referenced symbol is not deprecated
4405          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4406          *  (3) if symbol is a variable, check that its type and kind are
4407          *      compatible with the prototype and protokind.
4408          *  (4) if symbol is an instance field of a raw type,
4409          *      which is being assigned to, issue an unchecked warning if its
4410          *      type changes under erasure.
4411          *  (5) if symbol is an instance method of a raw type, issue an
4412          *      unchecked warning if its argument types change under erasure.
4413          *  If checks succeed:
4414          *    If symbol is a constant, return its constant type
4415          *    else if symbol is a method, return its result type
4416          *    otherwise return its type.
4417          *  Otherwise return errType.
4418          *
4419          *  @param tree       The syntax tree representing the identifier
4420          *  @param site       If this is a select, the type of the selected
4421          *                    expression, otherwise the type of the current class.
4422          *  @param sym        The symbol representing the identifier.
4423          *  @param env        The current environment.
4424          *  @param resultInfo    The expected result
4425          */
4426         Type checkId(JCTree tree,
4427                      Type site,
4428                      Symbol sym,
4429                      Env&lt;AttrContext&gt; env,
4430                      ResultInfo resultInfo) {
4431             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4432                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4433                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4434         }
4435 
4436         Type checkMethodIdInternal(JCTree tree,
4437                      Type site,
4438                      Symbol sym,
4439                      Env&lt;AttrContext&gt; env,
4440                      ResultInfo resultInfo) {
4441             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4442                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4443                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4444                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4445                 return owntype;
4446             } else {
4447                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4448             }
4449         }
4450 
4451         Type checkIdInternal(JCTree tree,
4452                      Type site,
4453                      Symbol sym,
4454                      Type pt,
4455                      Env&lt;AttrContext&gt; env,
4456                      ResultInfo resultInfo) {
4457             if (pt.isErroneous()) {
4458                 return types.createErrorType(site);
4459             }
4460             Type owntype; // The computed type of this identifier occurrence.
4461             switch (sym.kind) {
4462             case TYP:
4463                 // For types, the computed type equals the symbol&#39;s type,
4464                 // except for two situations:
4465                 owntype = sym.type;
4466                 if (owntype.hasTag(CLASS)) {
4467                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4468                     Type ownOuter = owntype.getEnclosingType();
4469 
4470                     // (a) If the symbol&#39;s type is parameterized, erase it
4471                     // because no type parameters were given.
4472                     // We recover generic outer type later in visitTypeApply.
4473                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4474                         owntype = types.erasure(owntype);
4475                     }
4476 
4477                     // (b) If the symbol&#39;s type is an inner class, then
4478                     // we have to interpret its outer type as a superclass
4479                     // of the site type. Example:
4480                     //
4481                     // class Tree&lt;A&gt; { class Visitor { ... } }
4482                     // class PointTree extends Tree&lt;Point&gt; { ... }
4483                     // ...PointTree.Visitor...
4484                     //
4485                     // Then the type of the last expression above is
4486                     // Tree&lt;Point&gt;.Visitor.
4487                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4488                         Type normOuter = site;
4489                         if (normOuter.hasTag(CLASS)) {
4490                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4491                         }
4492                         if (normOuter == null) // perhaps from an import
4493                             normOuter = types.erasure(ownOuter);
4494                         if (normOuter != ownOuter)
4495                             owntype = new ClassType(
4496                                 normOuter, List.nil(), owntype.tsym,
4497                                 owntype.getMetadata());
4498                     }
4499                 }
4500                 break;
4501             case VAR:
4502                 VarSymbol v = (VarSymbol)sym;
4503 
4504                 if (env.info.enclVar != null
4505                         &amp;&amp; v.type.hasTag(NONE)) {
4506                     //self reference to implicitly typed variable declaration
4507                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4508                     return v.type = types.createErrorType(v.type);
4509                 }
4510 
4511                 // Test (4): if symbol is an instance field of a raw type,
4512                 // which is being assigned to, issue an unchecked warning if
4513                 // its type changes under erasure.
4514                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4515                     v.owner.kind == TYP &amp;&amp;
4516                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4517                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4518                     Type s = types.asOuterSuper(site, v.owner);
4519                     if (s != null &amp;&amp;
4520                         s.isRaw() &amp;&amp;
4521                         !types.isSameType(v.type, v.erasure(types))) {
4522                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4523                     }
4524                 }
4525                 // The computed type of a variable is the type of the
4526                 // variable symbol, taken as a member of the site type.
4527                 owntype = (sym.owner.kind == TYP &amp;&amp;
4528                            sym.name != names._this &amp;&amp; sym.name != names._super)
4529                     ? types.memberType(site, sym)
4530                     : sym.type;
4531 
4532                 // If the variable is a constant, record constant value in
4533                 // computed type.
4534                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4535                     owntype = owntype.constType(v.getConstValue());
4536 
4537                 if (resultInfo.pkind == KindSelector.VAL) {
4538                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4539                 }
4540                 break;
4541             case MTH: {
4542                 owntype = checkMethod(site, sym,
4543                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4544                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4545                         resultInfo.pt.getTypeArguments());
4546                 break;
4547             }
4548             case PCK: case ERR:
4549                 owntype = sym.type;
4550                 break;
4551             default:
4552                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4553                                          &quot; in tree &quot; + tree);
4554             }
4555 
4556             // Emit a `deprecation&#39; warning if symbol is deprecated.
4557             // (for constructors (but not for constructor references), the error
4558             // was given when the constructor was resolved)
4559 
4560             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4561                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4562                 chk.checkSunAPI(tree.pos(), sym);
4563                 chk.checkProfile(tree.pos(), sym);
4564                 chk.checkPreview(tree.pos(), sym);
4565             }
4566 
4567             // If symbol is a variable, check that its type and
4568             // kind are compatible with the prototype and protokind.
4569             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4570         }
4571 
4572         /** Check that variable is initialized and evaluate the variable&#39;s
4573          *  initializer, if not yet done. Also check that variable is not
4574          *  referenced before it is defined.
4575          *  @param tree    The tree making up the variable reference.
4576          *  @param env     The current environment.
4577          *  @param v       The variable&#39;s symbol.
4578          */
4579         private void checkInit(JCTree tree,
4580                                Env&lt;AttrContext&gt; env,
4581                                VarSymbol v,
4582                                boolean onlyWarning) {
4583             // A forward reference is diagnosed if the declaration position
4584             // of the variable is greater than the current tree position
4585             // and the tree and variable definition occur in the same class
4586             // definition.  Note that writes don&#39;t count as references.
4587             // This check applies only to class and instance
4588             // variables.  Local variables follow different scope rules,
4589             // and are subject to definite assignment checking.
4590             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4591             if (initEnv != null &amp;&amp;
4592                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4593                 v.owner.kind == TYP &amp;&amp;
4594                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4595                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4596                 (!env.tree.hasTag(ASSIGN) ||
4597                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4598                 if (!onlyWarning || isStaticEnumField(v)) {
4599                     Error errkey = (initEnv.info.enclVar == v) ?
4600                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4601                     log.error(tree.pos(), errkey);
4602                 } else if (useBeforeDeclarationWarning) {
4603                     Warning warnkey = (initEnv.info.enclVar == v) ?
4604                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4605                     log.warning(tree.pos(), warnkey);
4606                 }
4607             }
4608 
4609             v.getConstValue(); // ensure initializer is evaluated
4610 
4611             checkEnumInitializer(tree, env, v);
4612         }
4613 
4614         /**
4615          * Returns the enclosing init environment associated with this env (if any). An init env
4616          * can be either a field declaration env or a static/instance initializer env.
4617          */
4618         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4619             while (true) {
4620                 switch (env.tree.getTag()) {
4621                     case VARDEF:
4622                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4623                         if (vdecl.sym.owner.kind == TYP) {
4624                             //field
4625                             return env;
4626                         }
4627                         break;
4628                     case BLOCK:
4629                         if (env.next.tree.hasTag(CLASSDEF)) {
4630                             //instance/static initializer
4631                             return env;
4632                         }
4633                         break;
4634                     case METHODDEF:
4635                     case CLASSDEF:
4636                     case TOPLEVEL:
4637                         return null;
4638                 }
4639                 Assert.checkNonNull(env.next);
4640                 env = env.next;
4641             }
4642         }
4643 
4644         /**
4645          * Check for illegal references to static members of enum.  In
4646          * an enum type, constructors and initializers may not
4647          * reference its static members unless they are constant.
4648          *
4649          * @param tree    The tree making up the variable reference.
4650          * @param env     The current environment.
4651          * @param v       The variable&#39;s symbol.
4652          * @jls 8.9 Enum Types
4653          */
4654         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4655             // JLS:
4656             //
4657             // &quot;It is a compile-time error to reference a static field
4658             // of an enum type that is not a compile-time constant
4659             // (15.28) from constructors, instance initializer blocks,
4660             // or instance variable initializer expressions of that
4661             // type. It is a compile-time error for the constructors,
4662             // instance initializer blocks, or instance variable
4663             // initializer expressions of an enum constant e to refer
4664             // to itself or to an enum constant of the same type that
4665             // is declared to the right of e.&quot;
4666             if (isStaticEnumField(v)) {
4667                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4668 
4669                 if (enclClass == null || enclClass.owner == null)
4670                     return;
4671 
4672                 // See if the enclosing class is the enum (or a
4673                 // subclass thereof) declaring v.  If not, this
4674                 // reference is OK.
4675                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4676                     return;
4677 
4678                 // If the reference isn&#39;t from an initializer, then
4679                 // the reference is OK.
4680                 if (!Resolve.isInitializer(env))
4681                     return;
4682 
4683                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4684             }
4685         }
4686 
4687         /** Is the given symbol a static, non-constant field of an Enum?
4688          *  Note: enum literals should not be regarded as such
4689          */
4690         private boolean isStaticEnumField(VarSymbol v) {
4691             return Flags.isEnum(v.owner) &amp;&amp;
4692                    Flags.isStatic(v) &amp;&amp;
4693                    !Flags.isConstant(v) &amp;&amp;
4694                    v.name != names._class;
4695         }
4696 
4697     /**
4698      * Check that method arguments conform to its instantiation.
4699      **/
4700     public Type checkMethod(Type site,
4701                             final Symbol sym,
4702                             ResultInfo resultInfo,
4703                             Env&lt;AttrContext&gt; env,
4704                             final List&lt;JCExpression&gt; argtrees,
4705                             List&lt;Type&gt; argtypes,
4706                             List&lt;Type&gt; typeargtypes) {
4707         // Test (5): if symbol is an instance method of a raw type, issue
4708         // an unchecked warning if its argument types change under erasure.
4709         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4710             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4711             Type s = types.asOuterSuper(site, sym.owner);
4712             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4713                 !types.isSameTypes(sym.type.getParameterTypes(),
4714                                    sym.erasure(types).getParameterTypes())) {
4715                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4716             }
4717         }
4718 
4719         if (env.info.defaultSuperCallSite != null) {
4720             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4721                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4722                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4723                 List&lt;MethodSymbol&gt; icand_sup =
4724                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4725                 if (icand_sup.nonEmpty() &amp;&amp;
4726                         icand_sup.head != sym &amp;&amp;
4727                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4728                     log.error(env.tree.pos(),
4729                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4730                     break;
4731                 }
4732             }
4733             env.info.defaultSuperCallSite = null;
4734         }
4735 
4736         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4737             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4738             if (app.meth.hasTag(SELECT) &amp;&amp;
4739                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4740                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4741             }
4742         }
4743 
4744         // Compute the identifier&#39;s instantiated type.
4745         // For methods, we need to compute the instance type by
4746         // Resolve.instantiate from the symbol&#39;s type as well as
4747         // any type arguments and value arguments.
4748         Warner noteWarner = new Warner();
4749         try {
4750             Type owntype = rs.checkMethod(
4751                     env,
4752                     site,
4753                     sym,
4754                     resultInfo,
4755                     argtypes,
4756                     typeargtypes,
4757                     noteWarner);
4758 
4759             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4760                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4761 
4762             argtypes = argtypes.map(checkDeferredMap);
4763 
4764             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4765                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4766                         sym.name,
4767                         rs.methodArguments(sym.type.getParameterTypes()),
4768                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4769                         kindName(sym.location()),
4770                         sym.location()));
4771                 if (resultInfo.pt != Infer.anyPoly ||
4772                         !owntype.hasTag(METHOD) ||
4773                         !owntype.isPartial()) {
4774                     //if this is not a partially inferred method type, erase return type. Otherwise,
4775                     //erasure is carried out in PartiallyInferredMethodType.check().
4776                     owntype = new MethodType(owntype.getParameterTypes(),
4777                             types.erasure(owntype.getReturnType()),
4778                             types.erasure(owntype.getThrownTypes()),
4779                             syms.methodClass);
4780                 }
4781             }
4782 
4783             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4784                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4785                  PolyKind.POLY : PolyKind.STANDALONE;
4786             TreeInfo.setPolyKind(env.tree, pkind);
4787 
4788             return (resultInfo.pt == Infer.anyPoly) ?
4789                     owntype :
4790                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4791                             resultInfo.checkContext.inferenceContext());
4792         } catch (Infer.InferenceException ex) {
4793             //invalid target type - propagate exception outwards or report error
4794             //depending on the current check context
4795             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4796             return types.createErrorType(site);
4797         } catch (Resolve.InapplicableMethodException ex) {
4798             final JCDiagnostic diag = ex.getDiagnostic();
4799             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4800                 @Override
4801                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4802                     return new Pair&lt;&gt;(sym, diag);
4803                 }
4804             };
4805             List&lt;Type&gt; argtypes2 = argtypes.map(
4806                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4807             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4808                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4809             log.report(errDiag);
4810             return types.createErrorType(site);
4811         }
4812     }
4813 
4814     public void visitLiteral(JCLiteral tree) {
4815         result = check(tree, litType(tree.typetag).constType(tree.value),
4816                 KindSelector.VAL, resultInfo);
4817     }
4818     //where
4819     /** Return the type of a literal with given type tag.
4820      */
4821     Type litType(TypeTag tag) {
4822         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4823     }
4824 
4825     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4826         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4827     }
4828 
4829     public void visitTypeArray(JCArrayTypeTree tree) {
4830         Type etype = attribType(tree.elemtype, env);
4831         Type type = new ArrayType(etype, syms.arrayClass);
4832         result = check(tree, type, KindSelector.TYP, resultInfo);
4833     }
4834 
4835     /** Visitor method for parameterized types.
4836      *  Bound checking is left until later, since types are attributed
4837      *  before supertype structure is completely known
4838      */
4839     public void visitTypeApply(JCTypeApply tree) {
4840         Type owntype = types.createErrorType(tree.type);
4841 
4842         // Attribute functor part of application and make sure it&#39;s a class.
4843         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
<a name="9" id="anc9"></a><span class="line-removed">4844         if (tree.isQuestioned() &amp;&amp; clazztype != null &amp;&amp; clazztype.tsym != null &amp;&amp; clazztype.tsym.isValue()) {</span>
<span class="line-removed">4845             clazztype = types.projectedNullableType((ClassSymbol) clazztype.tsym).type;</span>
<span class="line-removed">4846         }</span>
4847 
4848         // Attribute type parameters
4849         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4850 
4851         if (clazztype.hasTag(CLASS)) {
4852             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4853             if (actuals.isEmpty()) //diamond
4854                 actuals = formals;
4855 
4856             if (actuals.length() == formals.length()) {
4857                 List&lt;Type&gt; a = actuals;
4858                 List&lt;Type&gt; f = formals;
4859                 while (a.nonEmpty()) {
4860                     a.head = a.head.withTypeVar(f.head);
4861                     a = a.tail;
4862                     f = f.tail;
4863                 }
4864                 // Compute the proper generic outer
4865                 Type clazzOuter = clazztype.getEnclosingType();
4866                 if (clazzOuter.hasTag(CLASS)) {
4867                     Type site;
4868                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4869                     if (clazz.hasTag(IDENT)) {
4870                         site = env.enclClass.sym.type;
4871                     } else if (clazz.hasTag(SELECT)) {
4872                         site = ((JCFieldAccess) clazz).selected.type;
4873                     } else throw new AssertionError(&quot;&quot;+tree);
4874                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4875                         if (site.hasTag(CLASS))
4876                             site = types.asOuterSuper(site, clazzOuter.tsym);
4877                         if (site == null)
4878                             site = types.erasure(clazzOuter);
4879                         clazzOuter = site;
4880                     }
4881                 }
4882                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4883                                         clazztype.getMetadata());
4884             } else {
4885                 if (formals.length() != 0) {
4886                     log.error(tree.pos(),
4887                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4888                 } else {
4889                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4890                 }
4891                 owntype = types.createErrorType(tree.type);
4892             }
4893         }
4894         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4895     }
4896 
4897     public void visitTypeUnion(JCTypeUnion tree) {
4898         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4899         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4900         for (JCExpression typeTree : tree.alternatives) {
4901             Type ctype = attribType(typeTree, env);
4902             ctype = chk.checkType(typeTree.pos(),
4903                           chk.checkClassType(typeTree.pos(), ctype),
4904                           syms.throwableType);
4905             if (!ctype.isErroneous()) {
4906                 //check that alternatives of a union type are pairwise
4907                 //unrelated w.r.t. subtyping
4908                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4909                     for (Type t : multicatchTypes) {
4910                         boolean sub = types.isSubtype(ctype, t);
4911                         boolean sup = types.isSubtype(t, ctype);
4912                         if (sub || sup) {
4913                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4914                             Type a = sub ? ctype : t;
4915                             Type b = sub ? t : ctype;
4916                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4917                         }
4918                     }
4919                 }
4920                 multicatchTypes.append(ctype);
4921                 if (all_multicatchTypes != null)
4922                     all_multicatchTypes.append(ctype);
4923             } else {
4924                 if (all_multicatchTypes == null) {
4925                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4926                     all_multicatchTypes.appendList(multicatchTypes);
4927                 }
4928                 all_multicatchTypes.append(ctype);
4929             }
4930         }
4931         Type t = check(tree, types.lub(multicatchTypes.toList()),
4932                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4933         if (t.hasTag(CLASS)) {
4934             List&lt;Type&gt; alternatives =
4935                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4936             t = new UnionClassType((ClassType) t, alternatives);
4937         }
4938         tree.type = result = t;
4939     }
4940 
4941     public void visitTypeIntersection(JCTypeIntersection tree) {
4942         attribTypes(tree.bounds, env);
4943         tree.type = result = checkIntersection(tree, tree.bounds);
4944     }
4945 
4946     public void visitTypeParameter(JCTypeParameter tree) {
4947         TypeVar typeVar = (TypeVar) tree.type;
4948 
4949         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4950             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4951         }
4952 
4953         if (!typeVar.getUpperBound().isErroneous()) {
4954             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4955             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4956         }
4957     }
4958 
4959     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4960         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4961         if (bounds.nonEmpty()) {
4962             // accept class or interface or typevar as first bound.
4963             bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);
4964             boundSet.add(types.erasure(bounds.head.type));
4965             if (bounds.head.type.isErroneous()) {
4966                 return bounds.head.type;
4967             }
4968             else if (bounds.head.type.hasTag(TYPEVAR)) {
4969                 // if first bound was a typevar, do not accept further bounds.
4970                 if (bounds.tail.nonEmpty()) {
4971                     log.error(bounds.tail.head.pos(),
4972                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4973                     return bounds.head.type;
4974                 }
4975             } else {
4976                 // if first bound was a class or interface, accept only interfaces
4977                 // as further bounds.
4978                 for (JCExpression bound : bounds.tail) {
4979                     bound.type = checkBase(bound.type, bound, env, false, true, false);
4980                     if (bound.type.isErroneous()) {
4981                         bounds = List.of(bound);
4982                     }
4983                     else if (bound.type.hasTag(CLASS)) {
4984                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
4985                     }
4986                 }
4987             }
4988         }
4989 
4990         if (bounds.length() == 0) {
4991             return syms.objectType;
4992         } else if (bounds.length() == 1) {
4993             return bounds.head.type;
4994         } else {
4995             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4996             // ... the variable&#39;s bound is a class type flagged COMPOUND
4997             // (see comment for TypeVar.bound).
4998             // In this case, generate a class tree that represents the
4999             // bound class, ...
5000             JCExpression extending;
5001             List&lt;JCExpression&gt; implementing;
5002             if (!bounds.head.type.isInterface()) {
5003                 extending = bounds.head;
5004                 implementing = bounds.tail;
5005             } else {
5006                 extending = null;
5007                 implementing = bounds;
5008             }
5009             JCClassDecl cd = make.at(tree).ClassDef(
5010                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),
5011                 names.empty, List.nil(),
5012                 extending, implementing, List.nil());
5013 
5014             ClassSymbol c = (ClassSymbol)owntype.tsym;
5015             Assert.check((c.flags() &amp; COMPOUND) != 0);
5016             cd.sym = c;
5017             c.sourcefile = env.toplevel.sourcefile;
5018 
5019             // ... and attribute the bound class
5020             c.flags_field |= UNATTRIBUTED;
5021             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5022             typeEnvs.put(c, cenv);
5023             attribClass(c);
5024             return owntype;
5025         }
5026     }
5027 
5028     public void visitWildcard(JCWildcard tree) {
5029         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5030         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5031             ? syms.objectType
5032             : attribType(tree.inner, env);
<a name="10" id="anc10"></a><span class="line-modified">5033         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, allowGenericsOverValues),</span>
5034                                               tree.kind.kind,
5035                                               syms.boundClass),
5036                 KindSelector.TYP, resultInfo);
5037     }
5038 
5039     public void visitAnnotation(JCAnnotation tree) {
5040         Assert.error(&quot;should be handled in annotate&quot;);
5041     }
5042 
5043     public void visitAnnotatedType(JCAnnotatedType tree) {
5044         attribAnnotationTypes(tree.annotations, env);
5045         Type underlyingType = attribType(tree.underlyingType, env);
5046         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5047 
5048         if (!env.info.isNewClass)
5049             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5050         result = tree.type = annotatedType;
5051     }
5052 
5053     public void visitErroneous(JCErroneous tree) {
5054         if (tree.errs != null)
5055             for (JCTree err : tree.errs)
5056                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
5057         result = tree.type = syms.errType;
5058     }
5059 
5060     /** Default visitor method for all other trees.
5061      */
5062     public void visitTree(JCTree tree) {
5063         throw new AssertionError();
5064     }
5065 
5066     /**
5067      * Attribute an env for either a top level tree or class or module declaration.
5068      */
5069     public void attrib(Env&lt;AttrContext&gt; env) {
5070         switch (env.tree.getTag()) {
5071             case MODULEDEF:
5072                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
5073                 break;
5074             case TOPLEVEL:
5075                 attribTopLevel(env);
5076                 break;
5077             case PACKAGEDEF:
5078                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
5079                 break;
5080             default:
5081                 attribClass(env.tree.pos(), env.enclClass.sym);
5082         }
5083     }
5084 
5085     /**
5086      * Attribute a top level tree. These trees are encountered when the
5087      * package declaration has annotations.
5088      */
5089     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
5090         JCCompilationUnit toplevel = env.toplevel;
5091         try {
5092             annotate.flush();
5093         } catch (CompletionFailure ex) {
5094             chk.completionError(toplevel.pos(), ex);
5095         }
5096     }
5097 
5098     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
5099         try {
5100             annotate.flush();
5101             attribPackage(p);
5102         } catch (CompletionFailure ex) {
5103             chk.completionError(pos, ex);
5104         }
5105     }
5106 
5107     void attribPackage(PackageSymbol p) {
5108         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
5109         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
5110     }
5111 
5112     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
5113         try {
5114             annotate.flush();
5115             attribModule(m);
5116         } catch (CompletionFailure ex) {
5117             chk.completionError(pos, ex);
5118         }
5119     }
5120 
5121     void attribModule(ModuleSymbol m) {
5122         // Get environment current at the point of module definition.
5123         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5124         attribStat(env.tree, env);
5125     }
5126 
5127     /** Main method: attribute class definition associated with given class symbol.
5128      *  reporting completion failures at the given position.
5129      *  @param pos The source position at which completion errors are to be
5130      *             reported.
5131      *  @param c   The class symbol whose definition will be attributed.
5132      */
5133     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5134         try {
5135             annotate.flush();
5136             attribClass(c);
5137             if (types.isValue(c.type)) {
5138                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5139                 if (!allowValueMemberCycles) {
5140                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))
5141                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);
5142                 }
5143             }
5144         } catch (CompletionFailure ex) {
5145             chk.completionError(pos, ex);
5146         }
5147     }
5148 
5149     /** Attribute class definition associated with given class symbol.
5150      *  @param c   The class symbol whose definition will be attributed.
5151      */
5152     void attribClass(ClassSymbol c) throws CompletionFailure {
5153         if (c.type.hasTag(ERROR)) return;
5154 
5155         // Check for cycles in the inheritance graph, which can arise from
5156         // ill-formed class files.
5157         chk.checkNonCyclic(null, c.type);
5158 
5159         Type st = types.supertype(c.type);
5160         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5161             // First, attribute superclass.
5162             if (st.hasTag(CLASS))
5163                 attribClass((ClassSymbol)st.tsym);
5164 
5165             // Next attribute owner, if it is a class.
5166             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5167                 attribClass((ClassSymbol)c.owner);
5168         }
5169 
5170         // The previous operations might have attributed the current class
5171         // if there was a cycle. So we test first whether the class is still
5172         // UNATTRIBUTED.
5173         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5174             c.flags_field &amp;= ~UNATTRIBUTED;
5175 
5176             // Get environment current at the point of class definition.
5177             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5178 
5179             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5180             // because the annotations were not available at the time the env was created. Therefore,
5181             // we look up the environment chain for the first enclosing environment for which the
5182             // lint value is set. Typically, this is the parent env, but might be further if there
5183             // are any envs created as a result of TypeParameter nodes.
5184             Env&lt;AttrContext&gt; lintEnv = env;
5185             while (lintEnv.info.lint == null)
5186                 lintEnv = lintEnv.next;
5187 
5188             // Having found the enclosing lint value, we can initialize the lint value for this class
5189             env.info.lint = lintEnv.info.lint.augment(c);
5190 
5191             Lint prevLint = chk.setLint(env.info.lint);
5192             JavaFileObject prev = log.useSource(c.sourcefile);
5193             ResultInfo prevReturnRes = env.info.returnResult;
5194 
5195             try {
5196                 deferredLintHandler.flush(env.tree);
5197                 env.info.returnResult = null;
5198                 // java.lang.Enum may not be subclassed by a non-enum
5199                 if (st.tsym == syms.enumSym &amp;&amp;
5200                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5201                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5202 
5203                 // Enums may not be extended by source-level classes
5204                 if (st.tsym != null &amp;&amp;
5205                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5206                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5207                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5208                 }
5209 
5210                 if (isSerializable(c.type)) {
5211                     env.info.isSerializable = true;
5212                 }
5213 
5214                 attribClassBody(env, c);
5215 
5216                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.
5217                     Assert.check(env.tree.hasTag(CLASSDEF));
5218                     JCClassDecl classDecl = (JCClassDecl) env.tree;
5219                     if (classDecl.extending != null) {
5220                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);
5221                     }
5222                 }
5223 
5224                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5225                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5226                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5227                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5228             } finally {
5229                 env.info.returnResult = prevReturnRes;
5230                 log.useSource(prev);
5231                 chk.setLint(prevLint);
5232             }
5233 
5234         }
5235     }
5236 
5237     public void visitImport(JCImport tree) {
5238         // nothing to do
5239     }
5240 
5241     public void visitModuleDef(JCModuleDecl tree) {
5242         tree.sym.completeUsesProvides();
5243         ModuleSymbol msym = tree.sym;
5244         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5245         Lint prevLint = chk.setLint(lint);
5246         chk.checkModuleName(tree);
5247         chk.checkDeprecatedAnnotation(tree, msym);
5248 
5249         try {
5250             deferredLintHandler.flush(tree.pos());
5251         } finally {
5252             chk.setLint(prevLint);
5253         }
5254     }
5255 
5256     /** Finish the attribution of a class. */
5257     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5258         JCClassDecl tree = (JCClassDecl)env.tree;
5259         Assert.check(c == tree.sym);
5260 
5261         // Validate type parameters, supertype and interfaces.
5262         attribStats(tree.typarams, env);
5263         if (!c.isAnonymous()) {
5264             //already checked if anonymous
5265             chk.validate(tree.typarams, env);
5266             chk.validate(tree.extending, env);
5267             chk.validate(tree.implementing, env);
5268         }
5269 
5270         c.markAbstractIfNeeded(types);
5271 
5272         // If this is a non-abstract class, check that it has no abstract
5273         // methods or unimplemented methods of an implemented interface.
5274         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5275             chk.checkAllDefined(tree.pos(), c);
5276         }
5277 
5278         if ((c.flags() &amp; ANNOTATION) != 0) {
5279             if (tree.implementing.nonEmpty())
5280                 log.error(tree.implementing.head.pos(),
5281                           Errors.CantExtendIntfAnnotation);
5282             if (tree.typarams.nonEmpty()) {
5283                 log.error(tree.typarams.head.pos(),
5284                           Errors.IntfAnnotationCantHaveTypeParams(c));
5285             }
5286 
5287             // If this annotation type has a @Repeatable, validate
5288             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5289             // If this annotation type has a @Repeatable, validate
5290             if (repeatable != null) {
5291                 // get diagnostic position for error reporting
5292                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5293                 Assert.checkNonNull(cbPos);
5294 
5295                 chk.validateRepeatable(c, repeatable, cbPos);
5296             }
5297         } else {
5298             // Check that all extended classes and interfaces
5299             // are compatible (i.e. no two define methods with same arguments
5300             // yet different return types).  (JLS 8.4.6.3)
5301             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5302             if (allowDefaultMethods) {
5303                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5304             }
5305         }
5306 
5307         // Check that class does not import the same parameterized interface
5308         // with two different argument lists.
5309         chk.checkClassBounds(tree.pos(), c.type);
5310 
5311         tree.type = c.type;
5312 
5313         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5314              l.nonEmpty(); l = l.tail) {
5315              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5316         }
5317 
5318         // Check that a generic class doesn&#39;t extend Throwable
5319         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5320             log.error(tree.extending.pos(), Errors.GenericThrowable);
5321 
5322         // Check that all methods which implement some
5323         // method conform to the method they implement.
5324         chk.checkImplementations(tree);
5325 
5326         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5327         checkAutoCloseable(tree.pos(), env, c.type);
5328 
5329         boolean hasInstanceFields = false;
5330         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5331             // Attribute declaration
5332             attribStat(l.head, env);
5333 
5334             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)
5335                 hasInstanceFields = true;
5336 
5337             // Check that declarations in inner classes are not static (JLS 8.1.2)
5338             // Make an exception for static constants.
5339             if (c.owner.kind != PCK &amp;&amp;
5340                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5341                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5342                 Symbol sym = null;
5343                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5344                 if (sym == null ||
5345                     sym.kind != VAR ||
5346                     ((VarSymbol) sym).getConstValue() == null)
5347                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5348             }
5349         }
5350         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {
5351             log.error(tree.pos(), Errors.EmptyValueNotYet);
5352         }
5353 
5354         // Check for cycles among non-initial constructors.
5355         chk.checkCyclicConstructors(tree);
5356 
5357         // Check for cycles among annotation elements.
5358         chk.checkNonCyclicElements(tree);
5359 
5360         // Check for proper use of serialVersionUID
5361         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5362                 &amp;&amp; isSerializable(c.type)
5363                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5364                 &amp;&amp; !c.isAnonymous()) {
5365             checkSerialVersionUID(tree, c);
5366         }
5367         if (allowTypeAnnos) {
5368             // Correctly organize the positions of the type annotations
5369             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5370 
5371             // Check type annotations applicability rules
5372             validateTypeAnnotations(tree, false);
5373         }
5374     }
5375         // where
5376         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5377         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5378             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5379                 if (types.isSameType(al.head.annotationType.type, t))
5380                     return al.head.pos();
5381             }
5382 
5383             return null;
5384         }
5385 
5386         /** check if a type is a subtype of Serializable, if that is available. */
5387         boolean isSerializable(Type t) {
5388             try {
5389                 syms.serializableType.complete();
5390             }
5391             catch (CompletionFailure e) {
5392                 return false;
5393             }
5394             return types.isSubtype(t, syms.serializableType);
5395         }
5396 
5397         /** Check that an appropriate serialVersionUID member is defined. */
5398         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5399 
5400             // check for presence of serialVersionUID
5401             VarSymbol svuid = null;
5402             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5403                 if (sym.kind == VAR) {
5404                     svuid = (VarSymbol)sym;
5405                     break;
5406                 }
5407             }
5408 
5409             if (svuid == null) {
5410                 log.warning(LintCategory.SERIAL,
5411                         tree.pos(), Warnings.MissingSVUID(c));
5412                 return;
5413             }
5414 
5415             // check that it is static final
5416             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5417                 (STATIC | FINAL))
5418                 log.warning(LintCategory.SERIAL,
5419                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5420 
5421             // check that it is long
5422             else if (!svuid.type.hasTag(LONG))
5423                 log.warning(LintCategory.SERIAL,
5424                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5425 
5426             // check constant
5427             else if (svuid.getConstValue() == null)
5428                 log.warning(LintCategory.SERIAL,
5429                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5430         }
5431 
5432     private Type capture(Type type) {
5433         return types.capture(type);
5434     }
5435 
5436     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5437         if (type.isErroneous()) {
5438             tree.vartype = make.at(Position.NOPOS).Erroneous();
5439         } else {
5440             tree.vartype = make.at(Position.NOPOS).Type(type);
5441         }
5442     }
5443 
5444     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5445         tree.accept(new TypeAnnotationsValidator(sigOnly));
5446     }
5447     //where
5448     private final class TypeAnnotationsValidator extends TreeScanner {
5449 
5450         private final boolean sigOnly;
5451         public TypeAnnotationsValidator(boolean sigOnly) {
5452             this.sigOnly = sigOnly;
5453         }
5454 
5455         public void visitAnnotation(JCAnnotation tree) {
5456             chk.validateTypeAnnotation(tree, false);
5457             super.visitAnnotation(tree);
5458         }
5459         public void visitAnnotatedType(JCAnnotatedType tree) {
5460             if (!tree.underlyingType.type.isErroneous()) {
5461                 super.visitAnnotatedType(tree);
5462             }
5463         }
5464         public void visitTypeParameter(JCTypeParameter tree) {
5465             chk.validateTypeAnnotations(tree.annotations, true);
5466             scan(tree.bounds);
5467             // Don&#39;t call super.
5468             // This is needed because above we call validateTypeAnnotation with
5469             // false, which would forbid annotations on type parameters.
5470             // super.visitTypeParameter(tree);
5471         }
5472         public void visitMethodDef(JCMethodDecl tree) {
5473             if (tree.recvparam != null &amp;&amp;
5474                     !tree.recvparam.vartype.type.isErroneous()) {
5475                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5476                         tree.recvparam.vartype.type.tsym);
5477             }
5478             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5479                 validateAnnotatedType(tree.restype, tree.restype.type);
5480             }
5481             if (sigOnly) {
5482                 scan(tree.mods);
5483                 scan(tree.restype);
5484                 scan(tree.typarams);
5485                 scan(tree.recvparam);
5486                 scan(tree.params);
5487                 scan(tree.thrown);
5488             } else {
5489                 scan(tree.defaultValue);
5490                 scan(tree.body);
5491             }
5492         }
5493         public void visitVarDef(final JCVariableDecl tree) {
5494             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5495             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5496                 validateAnnotatedType(tree.vartype, tree.sym.type);
5497             scan(tree.mods);
5498             scan(tree.vartype);
5499             if (!sigOnly) {
5500                 scan(tree.init);
5501             }
5502         }
5503         public void visitTypeCast(JCTypeCast tree) {
5504             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5505                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5506             super.visitTypeCast(tree);
5507         }
5508         public void visitTypeTest(JCInstanceOf tree) {
5509             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5510                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5511             super.visitTypeTest(tree);
5512         }
5513         public void visitNewClass(JCNewClass tree) {
5514             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5515                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5516                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5517                             tree.clazz.type.tsym);
5518                 }
5519                 if (tree.def != null) {
5520                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5521                 }
5522 
5523                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5524             }
5525             super.visitNewClass(tree);
5526         }
5527         public void visitNewArray(JCNewArray tree) {
5528             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5529                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5530                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5531                             tree.elemtype.type.tsym);
5532                 }
5533                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5534             }
5535             super.visitNewArray(tree);
5536         }
5537         public void visitClassDef(JCClassDecl tree) {
5538             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5539             if (sigOnly) {
5540                 scan(tree.mods);
5541                 scan(tree.typarams);
5542                 scan(tree.extending);
5543                 scan(tree.implementing);
5544             }
5545             for (JCTree member : tree.defs) {
5546                 if (member.hasTag(Tag.CLASSDEF)) {
5547                     continue;
5548                 }
5549                 scan(member);
5550             }
5551         }
5552         public void visitBlock(JCBlock tree) {
5553             if (!sigOnly) {
5554                 scan(tree.stats);
5555             }
5556         }
5557 
5558         /* I would want to model this after
5559          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5560          * and override visitSelect and visitTypeApply.
5561          * However, we only set the annotated type in the top-level type
5562          * of the symbol.
5563          * Therefore, we need to override each individual location where a type
5564          * can occur.
5565          */
5566         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5567             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5568 
5569             if (type.isPrimitiveOrVoid()) {
5570                 return;
5571             }
5572 
5573             JCTree enclTr = errtree;
5574             Type enclTy = type;
5575 
5576             boolean repeat = true;
5577             while (repeat) {
5578                 if (enclTr.hasTag(TYPEAPPLY)) {
5579                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5580                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5581                     if (trargs.length() &gt; 0) {
5582                         // Nothing to do for diamonds
5583                         if (tyargs.length() == trargs.length()) {
5584                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5585                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5586                             }
5587                         }
5588                         // If the lengths don&#39;t match, it&#39;s either a diamond
5589                         // or some nested type that redundantly provides
5590                         // type arguments in the tree.
5591                     }
5592 
5593                     // Look at the clazz part of a generic type
5594                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5595                 }
5596 
5597                 if (enclTr.hasTag(SELECT)) {
5598                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5599                     if (enclTy != null &amp;&amp;
5600                             !enclTy.hasTag(NONE)) {
5601                         enclTy = enclTy.getEnclosingType();
5602                     }
5603                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5604                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5605                     if (enclTy == null || enclTy.hasTag(NONE)) {
5606                         if (at.getAnnotations().size() == 1) {
5607                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5608                         } else {
5609                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5610                             for (JCAnnotation an : at.getAnnotations()) {
5611                                 comps.add(an.attribute);
5612                             }
5613                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5614                         }
5615                         repeat = false;
5616                     }
5617                     enclTr = at.underlyingType;
5618                     // enclTy doesn&#39;t need to be changed
5619                 } else if (enclTr.hasTag(IDENT)) {
5620                     repeat = false;
5621                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5622                     JCWildcard wc = (JCWildcard) enclTr;
5623                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5624                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5625                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5626                     } else {
5627                         // Nothing to do for UNBOUND
5628                     }
5629                     repeat = false;
5630                 } else if (enclTr.hasTag(TYPEARRAY)) {
5631                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5632                     validateAnnotatedType(art.getType(), art.elemtype.type);
5633                     repeat = false;
5634                 } else if (enclTr.hasTag(TYPEUNION)) {
5635                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5636                     for (JCTree t : ut.getTypeAlternatives()) {
5637                         validateAnnotatedType(t, t.type);
5638                     }
5639                     repeat = false;
5640                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5641                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5642                     for (JCTree t : it.getBounds()) {
5643                         validateAnnotatedType(t, t.type);
5644                     }
5645                     repeat = false;
5646                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5647                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5648                     repeat = false;
5649                 } else {
5650                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5651                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5652                 }
5653             }
5654         }
5655 
5656         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5657                 Symbol sym) {
5658             // Ensure that no declaration annotations are present.
5659             // Note that a tree type might be an AnnotatedType with
5660             // empty annotations, if only declaration annotations were given.
5661             // This method will raise an error for such a type.
5662             for (JCAnnotation ai : annotations) {
5663                 if (!ai.type.isErroneous() &amp;&amp;
5664                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5665                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5666                 }
5667             }
5668         }
5669     }
5670 
5671     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5672 
5673     /**
5674      * Handle missing types/symbols in an AST. This routine is useful when
5675      * the compiler has encountered some errors (which might have ended up
5676      * terminating attribution abruptly); if the compiler is used in fail-over
5677      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5678      * prevents NPE to be propagated during subsequent compilation steps.
5679      */
5680     public void postAttr(JCTree tree) {
5681         new PostAttrAnalyzer().scan(tree);
5682     }
5683 
5684     class PostAttrAnalyzer extends TreeScanner {
5685 
5686         private void initTypeIfNeeded(JCTree that) {
5687             if (that.type == null) {
5688                 if (that.hasTag(METHODDEF)) {
5689                     that.type = dummyMethodType((JCMethodDecl)that);
5690                 } else {
5691                     that.type = syms.unknownType;
5692                 }
5693             }
5694         }
5695 
5696         /* Construct a dummy method type. If we have a method declaration,
5697          * and the declared return type is void, then use that return type
5698          * instead of UNKNOWN to avoid spurious error messages in lambda
5699          * bodies (see:JDK-8041704).
5700          */
5701         private Type dummyMethodType(JCMethodDecl md) {
5702             Type restype = syms.unknownType;
5703             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5704                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5705                 if (prim.typetag == VOID)
5706                     restype = syms.voidType;
5707             }
5708             return new MethodType(List.nil(), restype,
5709                                   List.nil(), syms.methodClass);
5710         }
5711         private Type dummyMethodType() {
5712             return dummyMethodType(null);
5713         }
5714 
5715         @Override
5716         public void scan(JCTree tree) {
5717             if (tree == null) return;
5718             if (tree instanceof JCExpression) {
5719                 initTypeIfNeeded(tree);
5720             }
5721             super.scan(tree);
5722         }
5723 
5724         @Override
5725         public void visitIdent(JCIdent that) {
5726             if (that.sym == null) {
5727                 that.sym = syms.unknownSymbol;
5728             }
5729         }
5730 
5731         @Override
5732         public void visitSelect(JCFieldAccess that) {
5733             if (that.sym == null) {
5734                 that.sym = syms.unknownSymbol;
5735             }
5736             super.visitSelect(that);
5737         }
5738 
5739         @Override
5740         public void visitClassDef(JCClassDecl that) {
5741             initTypeIfNeeded(that);
5742             if (that.sym == null) {
5743                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5744             }
5745             super.visitClassDef(that);
5746         }
5747 
5748         @Override
5749         public void visitMethodDef(JCMethodDecl that) {
5750             initTypeIfNeeded(that);
5751             if (that.sym == null) {
5752                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5753             }
5754             super.visitMethodDef(that);
5755         }
5756 
5757         @Override
5758         public void visitVarDef(JCVariableDecl that) {
5759             initTypeIfNeeded(that);
5760             if (that.sym == null) {
5761                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5762                 that.sym.adr = 0;
5763             }
5764             if (that.vartype == null) {
5765                 that.vartype = make.at(Position.NOPOS).Erroneous();
5766             }
5767             super.visitVarDef(that);
5768         }
5769 
5770         @Override
5771         public void visitBindingPattern(JCBindingPattern that) {
5772             if (that.symbol == null) {
5773                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5774                 that.symbol.adr = 0;
5775             }
5776             super.visitBindingPattern(that);
5777         }
5778 
5779         @Override
5780         public void visitNewClass(JCNewClass that) {
5781             if (that.constructor == null) {
5782                 that.constructor = new MethodSymbol(0, names.init,
5783                         dummyMethodType(), syms.noSymbol);
5784             }
5785             if (that.constructorType == null) {
5786                 that.constructorType = syms.unknownType;
5787             }
5788             super.visitNewClass(that);
5789         }
5790 
5791         @Override
5792         public void visitAssignop(JCAssignOp that) {
5793             if (that.operator == null) {
5794                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5795                         -1, syms.noSymbol);
5796             }
5797             super.visitAssignop(that);
5798         }
5799 
5800         @Override
5801         public void visitBinary(JCBinary that) {
5802             if (that.operator == null) {
5803                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5804                         -1, syms.noSymbol);
5805             }
5806             super.visitBinary(that);
5807         }
5808 
5809         @Override
5810         public void visitUnary(JCUnary that) {
5811             if (that.operator == null) {
5812                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5813                         -1, syms.noSymbol);
5814             }
5815             super.visitUnary(that);
5816         }
5817 
5818         @Override
5819         public void visitReference(JCMemberReference that) {
5820             super.visitReference(that);
5821             if (that.sym == null) {
5822                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5823                         syms.noSymbol);
5824             }
5825         }
5826     }
5827     // &lt;/editor-fold&gt;
5828 
5829     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5830         new TreeScanner() {
5831             Symbol packge = pkg;
5832             @Override
5833             public void visitIdent(JCIdent that) {
5834                 that.sym = packge;
5835             }
5836 
5837             @Override
5838             public void visitSelect(JCFieldAccess that) {
5839                 that.sym = packge;
5840                 packge = packge.owner;
5841                 super.visitSelect(that);
5842             }
5843         }.scan(pid);
5844     }
5845 
5846 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.*;
  29 import com.sun.tools.javac.code.Symbol.*;
  30 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 
  34 import java.util.function.ToIntBiFunction;
  35 import java.util.function.ToIntFunction;
  36 
  37 import static com.sun.tools.javac.code.TypeTag.BOT;
  38 import static com.sun.tools.javac.code.TypeTag.INT;
  39 import static com.sun.tools.javac.jvm.ByteCodes.*;
  40 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;
  41 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;
  42 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;
  43 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;
  44 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;
  45 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;
  46 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;
  47 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;
  48 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;
  49 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;
  50 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;
  51 import static com.sun.tools.javac.jvm.UninitializedType.*;
  52 import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;
  53 import java.util.Arrays;
  54 
  55 /** An internal structure that corresponds to the code attribute of
  56  *  methods in a classfile. The class also provides some utility operations to
  57  *  generate bytecode instructions.
  58  *
  59  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  60  *  If you write code that depends on this, you do so at your own risk.
  61  *  This code and its internal interfaces are subject to change or
  62  *  deletion without notice.&lt;/b&gt;
  63  */
  64 public class Code {
  65 
  66     public final boolean debugCode;
  67     public final boolean needStackMap;
  68 
  69     public enum StackMapFormat {
  70         NONE,
  71         CLDC {
  72             Name getAttributeName(Names names) {
  73                 return names.StackMap;
  74             }
  75         },
  76         JSR202 {
  77             Name getAttributeName(Names names) {
  78                 return names.StackMapTable;
  79             }
  80         };
  81         Name getAttributeName(Names names) {
  82             return names.empty;
  83         }
  84     }
  85 
  86     final Types types;
  87     final Symtab syms;
  88     final PoolWriter poolWriter;
  89 
  90 /*---------- classfile fields: --------------- */
  91 
  92     /** The maximum stack size.
  93      */
  94     public int max_stack = 0;
  95 
  96     /** The maximum number of local variable slots.
  97      */
  98     public int max_locals = 0;
  99 
 100     /** The code buffer.
 101      */
 102     public byte[] code = new byte[64];
 103 
 104     /** the current code pointer.
 105      */
 106     public int cp = 0;
 107 
 108     /** Check the code against VM spec limits; if
 109      *  problems report them and return true.
 110      */
 111     public boolean checkLimits(DiagnosticPosition pos, Log log) {
 112         if (cp &gt; ClassFile.MAX_CODE) {
 113             log.error(pos, Errors.LimitCode);
 114             return true;
 115         }
 116         if (max_locals &gt; ClassFile.MAX_LOCALS) {
 117             log.error(pos, Errors.LimitLocals);
 118             return true;
 119         }
 120         if (max_stack &gt; ClassFile.MAX_STACK) {
 121             log.error(pos, Errors.LimitStack);
 122             return true;
 123         }
 124         return false;
 125     }
 126 
 127     /** A buffer for expression catch data. Each enter is a vector
 128      *  of four unsigned shorts.
 129      */
 130     ListBuffer&lt;char[]&gt; catchInfo = new ListBuffer&lt;&gt;();
 131 
 132     /** A buffer for line number information. Each entry is a vector
 133      *  of two unsigned shorts.
 134      */
 135     List&lt;char[]&gt; lineInfo = List.nil(); // handled in stack fashion
 136 
 137     /** The CharacterRangeTable
 138      */
 139     public CRTable crt;
 140 
 141 /*---------- internal fields: --------------- */
 142 
 143     /** Are we generating code with jumps &amp;ge; 32K?
 144      */
 145     public boolean fatcode;
 146 
 147     /** Code generation enabled?
 148      */
 149     private boolean alive = true;
 150 
 151     /** The current machine state (registers and stack).
 152      */
 153     State state;
 154 
 155     /** Is it forbidden to compactify code, because something is
 156      *  pointing to current location?
 157      */
 158     private boolean fixedPc = false;
 159 
 160     /** The next available register.
 161      */
 162     public int nextreg = 0;
 163 
 164     /** A chain for jumps to be resolved before the next opcode is emitted.
 165      *  We do this lazily to avoid jumps to jumps.
 166      */
 167     Chain pendingJumps = null;
 168 
 169     /** The position of the currently statement, if we are at the
 170      *  start of this statement, NOPOS otherwise.
 171      *  We need this to emit line numbers lazily, which we need to do
 172      *  because of jump-to-jump optimization.
 173      */
 174     int pendingStatPos = Position.NOPOS;
 175 
 176     /** Set true when a stackMap is needed at the current PC. */
 177     boolean pendingStackMap = false;
 178 
 179     /** The stack map format to be generated. */
 180     StackMapFormat stackMap;
 181 
 182     /** Switch: emit variable debug info.
 183      */
 184     boolean varDebugInfo;
 185 
 186     /** Switch: emit line number info.
 187      */
 188     boolean lineDebugInfo;
 189 
 190     /** Emit line number info if map supplied
 191      */
 192     Position.LineMap lineMap;
 193 
 194     final MethodSymbol meth;
 195 
 196     private int letExprStackPos = 0;
 197 
 198     /** Construct a code object, given the settings of the fatcode,
 199      *  debugging info switches and the CharacterRangeTable.
 200      */
 201     public Code(MethodSymbol meth,
 202                 boolean fatcode,
 203                 Position.LineMap lineMap,
 204                 boolean varDebugInfo,
 205                 StackMapFormat stackMap,
 206                 boolean debugCode,
 207                 CRTable crt,
 208                 Symtab syms,
 209                 Types types,
 210                 PoolWriter poolWriter) {
 211         this.meth = meth;
 212         this.fatcode = fatcode;
 213         this.lineMap = lineMap;
 214         this.lineDebugInfo = lineMap != null;
 215         this.varDebugInfo = varDebugInfo;
 216         this.crt = crt;
 217         this.syms = syms;
 218         this.types = types;
 219         this.poolWriter = poolWriter;
 220         this.debugCode = debugCode;
 221         this.stackMap = stackMap;
 222         switch (stackMap) {
 223         case CLDC:
 224         case JSR202:
 225             this.needStackMap = true;
 226             break;
 227         default:
 228             this.needStackMap = false;
 229         }
 230         state = new State();
 231         lvar = new LocalVar[20];
 232     }
 233 
 234 
 235 /* **************************************************************************
 236  * Typecodes &amp; related stuff
 237  ****************************************************************************/
 238 
 239     /** Given a type, return its type code (used implicitly in the
 240      *  JVM architecture).
 241      */
 242     public static int typecode(Type type) {
 243         switch (type.getTag()) {
 244         case BYTE: return BYTEcode;
 245         case SHORT: return SHORTcode;
 246         case CHAR: return CHARcode;
 247         case INT: return INTcode;
 248         case LONG: return LONGcode;
 249         case FLOAT: return FLOATcode;
 250         case DOUBLE: return DOUBLEcode;
 251         case BOOLEAN: return BYTEcode;
 252         case VOID: return VOIDcode;
 253         case CLASS:
 254         case ARRAY:
 255         case METHOD:
 256         case BOT:
 257         case TYPEVAR:
 258         case UNINITIALIZED_THIS:
 259         case UNINITIALIZED_OBJECT:
 260             return OBJECTcode;
 261         default: throw new AssertionError(&quot;typecode &quot; + type.getTag());
 262         }
 263     }
 264 
 265     /** Collapse type code for subtypes of int to INTcode.
 266      */
 267     public static int truncate(int tc) {
 268         switch (tc) {
 269         case BYTEcode: case SHORTcode: case CHARcode: return INTcode;
 270         default: return tc;
 271         }
 272     }
 273 
 274     /** The width in bytes of objects of the type.
 275      */
 276     public static int width(int typecode) {
 277         switch (typecode) {
 278         case LONGcode: case DOUBLEcode: return 2;
 279         case VOIDcode: return 0;
 280         default: return 1;
 281         }
 282     }
 283 
 284     public static int width(Type type) {
 285         return type == null ? 1 : width(typecode(type));
 286     }
 287 
 288     /** The total width taken up by a vector of objects.
 289      */
 290     public static int width(List&lt;Type&gt; types) {
 291         int w = 0;
 292         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail)
 293             w = w + width(l.head);
 294         return w;
 295     }
 296 
 297     /** Given a type, return its code for allocating arrays of that type.
 298      */
 299     public static int arraycode(Type type) {
 300         switch (type.getTag()) {
 301         case BYTE: return 8;
 302         case BOOLEAN: return 4;
 303         case SHORT: return 9;
 304         case CHAR: return 5;
 305         case INT: return 10;
 306         case LONG: return 11;
 307         case FLOAT: return 6;
 308         case DOUBLE: return 7;
 309         case CLASS: return 0;
 310         case ARRAY: return 1;
 311         default: throw new AssertionError(&quot;arraycode &quot; + type);
 312         }
 313     }
 314 
 315 
 316 /* **************************************************************************
 317  * Emit code
 318  ****************************************************************************/
 319 
 320     /** The current output code pointer.
 321      */
 322     public int curCP() {
 323         /*
 324          * This method has side-effects because calling it can indirectly provoke
 325          *  extra code generation, like goto instructions, depending on the context
 326          *  where it&#39;s called.
 327          *  Use with care or even better avoid using it.
 328          */
 329         if (pendingJumps != null) {
 330             resolvePending();
 331         }
 332         if (pendingStatPos != Position.NOPOS) {
 333             markStatBegin();
 334         }
 335         fixedPc = true;
 336         return cp;
 337     }
 338 
 339     /** Emit a byte of code.
 340      */
 341     private  void emit1(int od) {
 342         if (!alive) return;
 343         code = ArrayUtils.ensureCapacity(code, cp);
 344         code[cp++] = (byte)od;
 345     }
 346 
 347     /** Emit two bytes of code.
 348      */
 349     private void emit2(int od) {
 350         if (!alive) return;
 351         if (cp + 2 &gt; code.length) {
 352             emit1(od &gt;&gt; 8);
 353             emit1(od);
 354         } else {
 355             code[cp++] = (byte)(od &gt;&gt; 8);
 356             code[cp++] = (byte)od;
 357         }
 358     }
 359 
 360     /** Emit four bytes of code.
 361      */
 362     public void emit4(int od) {
 363         if (!alive) return;
 364         if (cp + 4 &gt; code.length) {
 365             emit1(od &gt;&gt; 24);
 366             emit1(od &gt;&gt; 16);
 367             emit1(od &gt;&gt; 8);
 368             emit1(od);
 369         } else {
 370             code[cp++] = (byte)(od &gt;&gt; 24);
 371             code[cp++] = (byte)(od &gt;&gt; 16);
 372             code[cp++] = (byte)(od &gt;&gt; 8);
 373             code[cp++] = (byte)od;
 374         }
 375     }
 376 
 377     /** Emit an opcode.
 378      */
 379     private void emitop(int op) {
 380         if (pendingJumps != null) resolvePending();
 381         if (alive) {
 382             if (pendingStatPos != Position.NOPOS)
 383                 markStatBegin();
 384             if (pendingStackMap) {
 385                 pendingStackMap = false;
 386                 emitStackMap();
 387             }
 388             if (debugCode)
 389                 System.err.println(&quot;emit@&quot; + cp + &quot; stack=&quot; +
 390                                    state.stacksize + &quot;: &quot; +
 391                                    mnem(op));
 392             emit1(op);
 393         }
 394     }
 395 
 396     void postop() {
 397         Assert.check(alive || isStatementStart());
 398     }
 399 
 400     /** Emit a ldc (or ldc_w) instruction, taking into account operand size
 401     */
 402     public void emitLdc(LoadableConstant constant) {
 403         int od = poolWriter.putConstant(constant);
 404         if (od &lt;= 255) {
 405             emitop1(ldc1, od, constant);
 406         }
 407         else {
 408             emitop2(ldc2, od, constant);
 409         }
 410     }
 411 
 412     /** Emit a multinewarray instruction.
 413      */
 414     public void emitMultianewarray(int ndims, int type, Type arrayType) {
 415         emitop(multianewarray);
 416         if (!alive) return;
 417         emit2(type);
 418         emit1(ndims);
 419         state.pop(ndims);
 420         state.push(arrayType);
 421     }
 422 
 423     /** Emit newarray.
 424      */
 425     public void emitNewarray(int elemcode, Type arrayType) {
 426         emitop(newarray);
 427         if (!alive) return;
 428         emit1(elemcode);
 429         state.pop(1); // count
 430         state.push(arrayType);
 431     }
 432 
 433     /** Emit anewarray.
 434      */
 435     public void emitAnewarray(int od, Type arrayType) {
 436         emitop(anewarray);
 437         if (!alive) return;
 438         emit2(od);
 439         state.pop(1);
 440         state.push(arrayType);
 441     }
 442 
 443     /** Emit an invokeinterface instruction.
 444      */
 445     public void emitInvokeinterface(Symbol member, Type mtype) {
 446         int argsize = width(mtype.getParameterTypes());
 447         emitop(invokeinterface);
 448         if (!alive) return;
 449         emit2(poolWriter.putMember(member));
 450         emit1(argsize + 1);
 451         emit1(0);
 452         state.pop(argsize + 1);
 453         state.push(mtype.getReturnType());
 454     }
 455 
 456     /** Emit an invokespecial instruction.
 457      */
 458     public void emitInvokespecial(Symbol member, Type mtype) {
 459         int argsize = width(mtype.getParameterTypes());
 460         emitop(invokespecial);
 461         if (!alive) return;
 462         emit2(poolWriter.putMember(member));
 463         state.pop(argsize);
 464         if (member.isConstructor())
 465             state.markInitialized((UninitializedType)state.peek());
 466         state.pop(1);
 467         state.push(mtype.getReturnType());
 468     }
 469 
 470     /** Emit an invokestatic instruction.
 471      */
 472     public void emitInvokestatic(Symbol member, Type mtype) {
 473         int argsize = width(mtype.getParameterTypes());
 474         emitop(invokestatic);
 475         if (!alive) return;
 476         emit2(poolWriter.putMember(member));
 477         state.pop(argsize);
 478         state.push(mtype.getReturnType());
 479     }
 480 
 481     /** Emit an invokevirtual instruction.
 482      */
 483     public void emitInvokevirtual(Symbol member, Type mtype) {
 484         int argsize = width(mtype.getParameterTypes());
 485         emitop(invokevirtual);
 486         if (!alive) return;
 487         emit2(poolWriter.putMember(member));
 488         state.pop(argsize + 1);
 489         state.push(mtype.getReturnType());
 490     }
 491 
 492     /** Emit an invokedynamic instruction.
 493      */
 494     public void emitInvokedynamic(DynamicMethodSymbol dynMember, Type mtype) {
 495         int argsize = width(mtype.getParameterTypes());
 496         emitop(invokedynamic);
 497         if (!alive) return;
 498         emit2(poolWriter.putDynamic(dynMember));
 499         emit2(0);
 500         state.pop(argsize);
 501         state.push(mtype.getReturnType());
 502     }
 503 
 504     /** Emit an opcode with no operand field.
 505      */
 506     public void emitop0(int op) {
 507         emitop(op);
 508         if (!alive) return;
 509         switch (op) {
 510         case aaload: {
 511             state.pop(1);// index
 512             Type a = state.stack[state.stacksize-1];
 513             Assert.check(!a.hasTag(BOT)); // null type as is cannot be indexed.
 514             state.pop(1);
 515             state.push(types.erasure(types.elemtype(a))); }
 516             break;
 517         case goto_:
 518             markDead();
 519             break;
 520         case nop:
 521         case ineg:
 522         case lneg:
 523         case fneg:
 524         case dneg:
 525             break;
 526         case aconst_null:
 527             state.push(syms.botType);
 528             break;
 529         case iconst_m1:
 530         case iconst_0:
 531         case iconst_1:
 532         case iconst_2:
 533         case iconst_3:
 534         case iconst_4:
 535         case iconst_5:
 536         case iload_0:
 537         case iload_1:
 538         case iload_2:
 539         case iload_3:
 540             state.push(syms.intType);
 541             break;
 542         case lconst_0:
 543         case lconst_1:
 544         case lload_0:
 545         case lload_1:
 546         case lload_2:
 547         case lload_3:
 548             state.push(syms.longType);
 549             break;
 550         case fconst_0:
 551         case fconst_1:
 552         case fconst_2:
 553         case fload_0:
 554         case fload_1:
 555         case fload_2:
 556         case fload_3:
 557             state.push(syms.floatType);
 558             break;
 559         case dconst_0:
 560         case dconst_1:
 561         case dload_0:
 562         case dload_1:
 563         case dload_2:
 564         case dload_3:
 565             state.push(syms.doubleType);
 566             break;
 567         case aload_0:
 568             state.push(lvar[0].sym.type);
 569             break;
 570         case aload_1:
 571             state.push(lvar[1].sym.type);
 572             break;
 573         case aload_2:
 574             state.push(lvar[2].sym.type);
 575             break;
 576         case aload_3:
 577             state.push(lvar[3].sym.type);
 578             break;
 579         case iaload:
 580         case baload:
 581         case caload:
 582         case saload:
 583             state.pop(2);
 584             state.push(syms.intType);
 585             break;
 586         case laload:
 587             state.pop(2);
 588             state.push(syms.longType);
 589             break;
 590         case faload:
 591             state.pop(2);
 592             state.push(syms.floatType);
 593             break;
 594         case daload:
 595             state.pop(2);
 596             state.push(syms.doubleType);
 597             break;
 598         case istore_0:
 599         case istore_1:
 600         case istore_2:
 601         case istore_3:
 602         case fstore_0:
 603         case fstore_1:
 604         case fstore_2:
 605         case fstore_3:
 606         case astore_0:
 607         case astore_1:
 608         case astore_2:
 609         case astore_3:
 610         case pop:
 611         case lshr:
 612         case lshl:
 613         case lushr:
 614             state.pop(1);
 615             break;
 616         case areturn:
 617         case ireturn:
 618         case freturn:
 619             Assert.check(state.nlocks == 0);
 620             state.pop(1);
 621             markDead();
 622             break;
 623         case athrow:
 624             state.pop(1);
 625             markDead();
 626             break;
 627         case lstore_0:
 628         case lstore_1:
 629         case lstore_2:
 630         case lstore_3:
 631         case dstore_0:
 632         case dstore_1:
 633         case dstore_2:
 634         case dstore_3:
 635         case pop2:
 636             state.pop(2);
 637             break;
 638         case lreturn:
 639         case dreturn:
 640             Assert.check(state.nlocks == 0);
 641             state.pop(2);
 642             markDead();
 643             break;
 644         case dup:
 645             state.push(state.stack[state.stacksize-1]);
 646             break;
 647         case return_:
 648             Assert.check(state.nlocks == 0);
 649             markDead();
 650             break;
 651         case arraylength:
 652             state.pop(1);
 653             state.push(syms.intType);
 654             break;
 655         case isub:
 656         case iadd:
 657         case imul:
 658         case idiv:
 659         case imod:
 660         case ishl:
 661         case ishr:
 662         case iushr:
 663         case iand:
 664         case ior:
 665         case ixor:
 666             state.pop(1);
 667             // state.pop(1);
 668             // state.push(syms.intType);
 669             break;
 670         case aastore:
 671             state.pop(3);
 672             break;
 673         case land:
 674         case lor:
 675         case lxor:
 676         case lmod:
 677         case ldiv:
 678         case lmul:
 679         case lsub:
 680         case ladd:
 681             state.pop(2);
 682             break;
 683         case lcmp:
 684             state.pop(4);
 685             state.push(syms.intType);
 686             break;
 687         case l2i:
 688             state.pop(2);
 689             state.push(syms.intType);
 690             break;
 691         case i2l:
 692             state.pop(1);
 693             state.push(syms.longType);
 694             break;
 695         case i2f:
 696             state.pop(1);
 697             state.push(syms.floatType);
 698             break;
 699         case i2d:
 700             state.pop(1);
 701             state.push(syms.doubleType);
 702             break;
 703         case l2f:
 704             state.pop(2);
 705             state.push(syms.floatType);
 706             break;
 707         case l2d:
 708             state.pop(2);
 709             state.push(syms.doubleType);
 710             break;
 711         case f2i:
 712             state.pop(1);
 713             state.push(syms.intType);
 714             break;
 715         case f2l:
 716             state.pop(1);
 717             state.push(syms.longType);
 718             break;
 719         case f2d:
 720             state.pop(1);
 721             state.push(syms.doubleType);
 722             break;
 723         case d2i:
 724             state.pop(2);
 725             state.push(syms.intType);
 726             break;
 727         case d2l:
 728             state.pop(2);
 729             state.push(syms.longType);
 730             break;
 731         case d2f:
 732             state.pop(2);
 733             state.push(syms.floatType);
 734             break;
 735         case tableswitch:
 736         case lookupswitch:
 737             state.pop(1);
 738             // the caller is responsible for patching up the state
 739             break;
 740         case dup_x1: {
 741             Type val1 = state.pop1();
 742             Type val2 = state.pop1();
 743             state.push(val1);
 744             state.push(val2);
 745             state.push(val1);
 746             break;
 747         }
 748         case bastore:
 749             state.pop(3);
 750             break;
 751         case int2byte:
 752         case int2char:
 753         case int2short:
 754             break;
 755         case fmul:
 756         case fadd:
 757         case fsub:
 758         case fdiv:
 759         case fmod:
 760             state.pop(1);
 761             break;
 762         case castore:
 763         case iastore:
 764         case fastore:
 765         case sastore:
 766             state.pop(3);
 767             break;
 768         case lastore:
 769         case dastore:
 770             state.pop(4);
 771             break;
 772         case dup2:
 773             if (state.stack[state.stacksize-1] != null) {
 774                 Type value1 = state.pop1();
 775                 Type value2 = state.pop1();
 776                 state.push(value2);
 777                 state.push(value1);
 778                 state.push(value2);
 779                 state.push(value1);
 780             } else {
 781                 Type value = state.pop2();
 782                 state.push(value);
 783                 state.push(value);
 784             }
 785             break;
 786         case dup2_x1:
 787             if (state.stack[state.stacksize-1] != null) {
 788                 Type value1 = state.pop1();
 789                 Type value2 = state.pop1();
 790                 Type value3 = state.pop1();
 791                 state.push(value2);
 792                 state.push(value1);
 793                 state.push(value3);
 794                 state.push(value2);
 795                 state.push(value1);
 796             } else {
 797                 Type value1 = state.pop2();
 798                 Type value2 = state.pop1();
 799                 state.push(value1);
 800                 state.push(value2);
 801                 state.push(value1);
 802             }
 803             break;
 804         case dup2_x2:
 805             if (state.stack[state.stacksize-1] != null) {
 806                 Type value1 = state.pop1();
 807                 Type value2 = state.pop1();
 808                 if (state.stack[state.stacksize-1] != null) {
 809                     // form 1
 810                     Type value3 = state.pop1();
 811                     Type value4 = state.pop1();
 812                     state.push(value2);
 813                     state.push(value1);
 814                     state.push(value4);
 815                     state.push(value3);
 816                     state.push(value2);
 817                     state.push(value1);
 818                 } else {
 819                     // form 3
 820                     Type value3 = state.pop2();
 821                     state.push(value2);
 822                     state.push(value1);
 823                     state.push(value3);
 824                     state.push(value2);
 825                     state.push(value1);
 826                 }
 827             } else {
 828                 Type value1 = state.pop2();
 829                 if (state.stack[state.stacksize-1] != null) {
 830                     // form 2
 831                     Type value2 = state.pop1();
 832                     Type value3 = state.pop1();
 833                     state.push(value1);
 834                     state.push(value3);
 835                     state.push(value2);
 836                     state.push(value1);
 837                 } else {
 838                     // form 4
 839                     Type value2 = state.pop2();
 840                     state.push(value1);
 841                     state.push(value2);
 842                     state.push(value1);
 843                 }
 844             }
 845             break;
 846         case dup_x2: {
 847             Type value1 = state.pop1();
 848             if (state.stack[state.stacksize-1] != null) {
 849                 // form 1
 850                 Type value2 = state.pop1();
 851                 Type value3 = state.pop1();
 852                 state.push(value1);
 853                 state.push(value3);
 854                 state.push(value2);
 855                 state.push(value1);
 856             } else {
 857                 // form 2
 858                 Type value2 = state.pop2();
 859                 state.push(value1);
 860                 state.push(value2);
 861                 state.push(value1);
 862             }
 863         }
 864             break;
 865         case fcmpl:
 866         case fcmpg:
 867             state.pop(2);
 868             state.push(syms.intType);
 869             break;
 870         case dcmpl:
 871         case dcmpg:
 872             state.pop(4);
 873             state.push(syms.intType);
 874             break;
 875         case swap: {
 876             Type value1 = state.pop1();
 877             Type value2 = state.pop1();
 878             state.push(value1);
 879             state.push(value2);
 880             break;
 881         }
 882         case dadd:
 883         case dsub:
 884         case dmul:
 885         case ddiv:
 886         case dmod:
 887             state.pop(2);
 888             break;
 889         case ret:
 890             markDead();
 891             break;
 892         case wide:
 893             // must be handled by the caller.
 894             return;
 895         case monitorenter:
 896         case monitorexit:
 897             state.pop(1);
 898             break;
 899 
 900         default:
 901             throw new AssertionError(mnem(op));
 902         }
 903         postop();
 904     }
 905 
 906     /** Emit an opcode with a one-byte operand field.
 907      */
 908     public void emitop1(int op, int od) {
 909         emitop1(op, od, null);
 910     }
 911 
 912     public void emitop1(int op, int od, PoolConstant data) {
 913         emitop(op);
 914         if (!alive) return;
 915         emit1(od);
 916         switch (op) {
 917         case bipush:
 918             state.push(syms.intType);
 919             break;
 920         case ldc1:
 921             state.push(types.constantType((LoadableConstant)data));
 922             break;
 923         default:
 924             throw new AssertionError(mnem(op));
 925         }
 926         postop();
 927     }
 928 
 929     /** Emit an opcode with a one-byte operand field;
 930      *  widen if field does not fit in a byte.
 931      */
 932     public void emitop1w(int op, int od) {
 933         if (od &gt; 0xFF) {
 934             emitop(wide);
 935             emitop(op);
 936             emit2(od);
 937         } else {
 938             emitop(op);
 939             emit1(od);
 940         }
 941         if (!alive) return;
 942         switch (op) {
 943         case iload:
 944             state.push(syms.intType);
 945             break;
 946         case lload:
 947             state.push(syms.longType);
 948             break;
 949         case fload:
 950             state.push(syms.floatType);
 951             break;
 952         case dload:
 953             state.push(syms.doubleType);
 954             break;
 955         case aload:
 956             state.push(lvar[od].sym.type);
 957             break;
 958         case lstore:
 959         case dstore:
 960             state.pop(2);
 961             break;
 962         case istore:
 963         case fstore:
 964         case astore:
 965             state.pop(1);
 966             break;
 967         case ret:
 968             markDead();
 969             break;
 970         default:
 971             throw new AssertionError(mnem(op));
 972         }
 973         postop();
 974     }
 975 
 976     /** Emit an opcode with two one-byte operand fields;
 977      *  widen if either field does not fit in a byte.
 978      */
 979     public void emitop1w(int op, int od1, int od2) {
 980         if (od1 &gt; 0xFF || od2 &lt; -128 || od2 &gt; 127) {
 981             emitop(wide);
 982             emitop(op);
 983             emit2(od1);
 984             emit2(od2);
 985         } else {
 986             emitop(op);
 987             emit1(od1);
 988             emit1(od2);
 989         }
 990         if (!alive) return;
 991         switch (op) {
 992         case iinc:
 993             break;
 994         default:
 995             throw new AssertionError(mnem(op));
 996         }
 997     }
 998 
 999     /** Emit an opcode with a two-byte operand field.
1000      */
1001     public &lt;P extends PoolConstant&gt; void emitop2(int op, P constant, ToIntBiFunction&lt;PoolWriter, P&gt; poolFunc) {
1002         int od = poolFunc.applyAsInt(poolWriter, constant);
1003         emitop2(op, od, constant);
1004     }
1005 
1006     public void emitop2(int op, int od) {
1007         emitop2(op, od, null);
1008     }
1009 
1010     public void emitop2(int op, int od, PoolConstant data) {
1011         emitop(op);
1012         if (!alive) return;
1013         emit2(od);
1014         switch (op) {
1015         case getstatic:
1016             state.push(((Symbol)data).erasure(types));
1017             break;
1018         case putstatic:
1019             state.pop(((Symbol)data).erasure(types));
1020             break;
1021         case new_: {
1022             Type t = (Type)data;
1023             state.push(uninitializedObject(t.tsym.erasure(types), cp - 3));
1024             break;
1025         }
1026         case defaultvalue: {
1027             Type t = (Type)data;
1028             state.push(t.tsym.erasure(types));
1029             break;
1030         }
1031         case sipush:
1032             state.push(syms.intType);
1033             break;
1034         case if_acmp_null:
1035         case if_acmp_nonnull:
1036         case ifeq:
1037         case ifne:
1038         case iflt:
1039         case ifge:
1040         case ifgt:
1041         case ifle:
1042             state.pop(1);
1043             break;
1044         case if_icmpeq:
1045         case if_icmpne:
1046         case if_icmplt:
1047         case if_icmpge:
1048         case if_icmpgt:
1049         case if_icmple:
1050         case if_acmpeq:
1051         case if_acmpne:
1052             state.pop(2);
1053             break;
1054         case goto_:
1055             markDead();
1056             break;
1057         case withfield:
1058             state.pop(((Symbol)data).erasure(types));
1059             break;
1060         case putfield:
1061             state.pop(((Symbol)data).erasure(types));
1062             state.pop(1); // object ref
1063             break;
1064         case getfield:
1065             state.pop(1); // object ref
1066             state.push(((Symbol)data).erasure(types));
1067             break;
1068         case checkcast: {
1069             state.pop(1); // object ref
1070             Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);
1071             state.push(t);
1072             break; }
1073         case ldc2w:
1074             state.push(types.constantType((LoadableConstant)data));
1075             break;
1076         case instanceof_:
1077             state.pop(1);
1078             state.push(syms.intType);
1079             break;
1080         case ldc2:
1081             state.push(types.constantType((LoadableConstant)data));
1082             break;
1083         case jsr:
1084             break;
1085         default:
1086             throw new AssertionError(mnem(op));
1087         }
1088         // postop();
1089     }
1090 
1091     /** Emit an opcode with a four-byte operand field.
1092      */
1093     public void emitop4(int op, int od) {
1094         emitop(op);
1095         if (!alive) return;
1096         emit4(od);
1097         switch (op) {
1098         case goto_w:
1099             markDead();
1100             break;
1101         case jsr_w:
1102             break;
1103         default:
1104             throw new AssertionError(mnem(op));
1105         }
1106         // postop();
1107     }
1108 
1109     /** Align code pointer to next `incr&#39; boundary.
1110      */
1111     public void align(int incr) {
1112         if (alive)
1113             while (cp % incr != 0) emitop0(nop);
1114     }
1115 
1116     /** Place a byte into code at address pc.
1117      *  Pre: {@literal pc + 1 &lt;= cp }.
1118      */
1119     private void put1(int pc, int op) {
1120         code[pc] = (byte)op;
1121     }
1122 
1123     /** Place two bytes into code at address pc.
1124      *  Pre: {@literal pc + 2 &lt;= cp }.
1125      */
1126     private void put2(int pc, int od) {
1127         // pre: pc + 2 &lt;= cp
1128         put1(pc, od &gt;&gt; 8);
1129         put1(pc+1, od);
1130     }
1131 
1132     /** Place four  bytes into code at address pc.
1133      *  Pre: {@literal pc + 4 &lt;= cp }.
1134      */
1135     public void put4(int pc, int od) {
1136         // pre: pc + 4 &lt;= cp
1137         put1(pc  , od &gt;&gt; 24);
1138         put1(pc+1, od &gt;&gt; 16);
1139         put1(pc+2, od &gt;&gt; 8);
1140         put1(pc+3, od);
1141     }
1142 
1143     /** Return code byte at position pc as an unsigned int.
1144      */
1145     private int get1(int pc) {
1146         return code[pc] &amp; 0xFF;
1147     }
1148 
1149     /** Return two code bytes at position pc as an unsigned int.
1150      */
1151     private int get2(int pc) {
1152         return (get1(pc) &lt;&lt; 8) | get1(pc+1);
1153     }
1154 
1155     /** Return four code bytes at position pc as an int.
1156      */
1157     public int get4(int pc) {
1158         // pre: pc + 4 &lt;= cp
1159         return
1160             (get1(pc) &lt;&lt; 24) |
1161             (get1(pc+1) &lt;&lt; 16) |
1162             (get1(pc+2) &lt;&lt; 8) |
1163             (get1(pc+3));
1164     }
1165 
1166     /** Is code generation currently enabled?
1167      */
1168     public boolean isAlive() {
1169         return alive || pendingJumps != null;
1170     }
1171 
1172     /** Switch code generation on/off.
1173      */
1174     public void markDead() {
1175         alive = false;
1176     }
1177 
1178     /** Declare an entry point; return current code pointer
1179      */
1180     public int entryPoint() {
1181         int pc = curCP();
1182         alive = true;
1183         pendingStackMap = needStackMap;
1184         return pc;
1185     }
1186 
1187     /** Declare an entry point with initial state;
1188      *  return current code pointer
1189      */
1190     public int entryPoint(State state) {
1191         int pc = curCP();
1192         alive = true;
1193         State newState = state.dup();
1194         setDefined(newState.defined);
1195         this.state = newState;
1196         Assert.check(state.stacksize &lt;= max_stack);
1197         if (debugCode) System.err.println(&quot;entry point &quot; + state);
1198         pendingStackMap = needStackMap;
1199         return pc;
1200     }
1201 
1202     /** Declare an entry point with initial state plus a pushed value;
1203      *  return current code pointer
1204      */
1205     public int entryPoint(State state, Type pushed) {
1206         int pc = curCP();
1207         alive = true;
1208         State newState = state.dup();
1209         setDefined(newState.defined);
1210         this.state = newState;
1211         Assert.check(state.stacksize &lt;= max_stack);
1212         this.state.push(pushed);
1213         if (debugCode) System.err.println(&quot;entry point &quot; + state);
1214         pendingStackMap = needStackMap;
1215         return pc;
1216     }
1217 
1218     public int setLetExprStackPos(int pos) {
1219         int res = letExprStackPos;
1220         letExprStackPos = pos;
1221         return res;
1222     }
1223 
1224     public boolean isStatementStart() {
1225         return !alive || state.stacksize == letExprStackPos;
1226     }
1227 
1228 /**************************************************************************
1229  * Stack map generation
1230  *************************************************************************/
1231 
1232     /** An entry in the stack map. */
1233     static class StackMapFrame {
1234         int pc;
1235         Type[] locals;
1236         Type[] stack;
1237     }
1238 
1239     /** A buffer of cldc stack map entries. */
1240     StackMapFrame[] stackMapBuffer = null;
1241 
1242     /** A buffer of compressed StackMapTable entries. */
1243     StackMapTableFrame[] stackMapTableBuffer = null;
1244     int stackMapBufferSize = 0;
1245 
1246     /** The last PC at which we generated a stack map. */
1247     int lastStackMapPC = -1;
1248 
1249     /** The last stack map frame in StackMapTable. */
1250     StackMapFrame lastFrame = null;
1251 
1252     /** The stack map frame before the last one. */
1253     StackMapFrame frameBeforeLast = null;
1254 
1255     /** Emit a stack map entry.  */
1256     public void emitStackMap() {
1257         int pc = curCP();
1258         if (!needStackMap) return;
1259 
1260 
1261 
1262         switch (stackMap) {
1263             case CLDC:
1264                 emitCLDCStackMap(pc, getLocalsSize());
1265                 break;
1266             case JSR202:
1267                 emitStackMapFrame(pc, getLocalsSize());
1268                 break;
1269             default:
1270                 throw new AssertionError(&quot;Should have chosen a stackmap format&quot;);
1271         }
1272         // DEBUG code follows
1273         if (debugCode) state.dump(pc);
1274     }
1275 
1276     private int getLocalsSize() {
1277         int nextLocal = 0;
1278         for (int i=max_locals-1; i&gt;=0; i--) {
1279             if (state.defined.isMember(i) &amp;&amp; lvar[i] != null) {
1280                 nextLocal = i + width(lvar[i].sym.erasure(types));
1281                 break;
1282             }
1283         }
1284         return nextLocal;
1285     }
1286 
1287     /** Emit a CLDC stack map frame. */
1288     void emitCLDCStackMap(int pc, int localsSize) {
1289         if (lastStackMapPC == pc) {
1290             // drop existing stackmap at this offset
1291             stackMapBuffer[--stackMapBufferSize] = null;
1292         }
1293         lastStackMapPC = pc;
1294 
1295         if (stackMapBuffer == null) {
1296             stackMapBuffer = new StackMapFrame[20];
1297         } else {
1298             stackMapBuffer = ArrayUtils.ensureCapacity(stackMapBuffer, stackMapBufferSize);
1299         }
1300         StackMapFrame frame =
1301             stackMapBuffer[stackMapBufferSize++] = new StackMapFrame();
1302         frame.pc = pc;
1303 
1304         frame.locals = new Type[localsSize];
1305         for (int i=0; i&lt;localsSize; i++) {
1306             if (state.defined.isMember(i) &amp;&amp; lvar[i] != null) {
1307                 Type vtype = lvar[i].sym.type;
1308                 if (!(vtype instanceof UninitializedType))
1309                     vtype = types.erasure(vtype);
1310                 frame.locals[i] = vtype;
1311             }
1312         }
1313         frame.stack = new Type[state.stacksize];
1314         for (int i=0; i&lt;state.stacksize; i++)
1315             frame.stack[i] = state.stack[i];
1316     }
1317 
1318     void emitStackMapFrame(int pc, int localsSize) {
1319         if (lastFrame == null) {
1320             // first frame
1321             lastFrame = getInitialFrame();
1322         } else if (lastFrame.pc == pc) {
1323             // drop existing stackmap at this offset
1324             stackMapTableBuffer[--stackMapBufferSize] = null;
1325             lastFrame = frameBeforeLast;
1326             frameBeforeLast = null;
1327         }
1328 
1329         StackMapFrame frame = new StackMapFrame();
1330         frame.pc = pc;
1331 
1332         int localCount = 0;
1333         Type[] locals = new Type[localsSize];
1334         for (int i=0; i&lt;localsSize; i++, localCount++) {
1335             if (state.defined.isMember(i) &amp;&amp; lvar[i] != null) {
1336                 Type vtype = lvar[i].sym.type;
1337                 if (!(vtype instanceof UninitializedType))
1338                     vtype = types.erasure(vtype);
1339                 locals[i] = vtype;
1340                 if (width(vtype) &gt; 1) i++;
1341             }
1342         }
1343         frame.locals = new Type[localCount];
1344         for (int i=0, j=0; i&lt;localsSize; i++, j++) {
1345             Assert.check(j &lt; localCount);
1346             frame.locals[j] = locals[i];
1347             if (width(locals[i]) &gt; 1) i++;
1348         }
1349 
1350         int stackCount = 0;
1351         for (int i=0; i&lt;state.stacksize; i++) {
1352             if (state.stack[i] != null) {
1353                 stackCount++;
1354             }
1355         }
1356         frame.stack = new Type[stackCount];
1357         stackCount = 0;
1358         for (int i=0; i&lt;state.stacksize; i++) {
1359             if (state.stack[i] != null) {
1360                 frame.stack[stackCount++] = types.erasure(state.stack[i]);
1361             }
1362         }
1363 
1364         if (stackMapTableBuffer == null) {
1365             stackMapTableBuffer = new StackMapTableFrame[20];
1366         } else {
1367             stackMapTableBuffer = ArrayUtils.ensureCapacity(
1368                                     stackMapTableBuffer,
1369                                     stackMapBufferSize);
1370         }
1371         stackMapTableBuffer[stackMapBufferSize++] =
1372                 StackMapTableFrame.getInstance(frame, lastFrame.pc, lastFrame.locals, types);
1373 
1374         frameBeforeLast = lastFrame;
1375         lastFrame = frame;
1376     }
1377 
1378     StackMapFrame getInitialFrame() {
1379         StackMapFrame frame = new StackMapFrame();
1380         List&lt;Type&gt; arg_types = ((MethodType)meth.externalType(types)).argtypes;
1381         int len = arg_types.length();
1382         int count = 0;
1383         if (!meth.isStatic()) {
1384             Type thisType = meth.owner.type;
1385             frame.locals = new Type[len+1];
1386             if (meth.isConstructor() &amp;&amp; thisType != syms.objectType) {
1387                 frame.locals[count++] = UninitializedType.uninitializedThis(thisType);
1388             } else {
1389                 frame.locals[count++] = types.erasure(thisType);
1390             }
1391         } else {
1392             frame.locals = new Type[len];
1393         }
1394         for (Type arg_type : arg_types) {
1395             frame.locals[count++] = types.erasure(arg_type);
1396         }
1397         frame.pc = -1;
1398         frame.stack = null;
1399         return frame;
1400     }
1401 
1402 
1403 /**************************************************************************
1404  * Operations having to do with jumps
1405  *************************************************************************/
1406 
1407     /** A chain represents a list of unresolved jumps. Jump locations
1408      *  are sorted in decreasing order.
1409      */
1410     public static class Chain {
1411 
1412         /** The position of the jump instruction.
1413          */
1414         public final int pc;
1415 
1416         /** The machine state after the jump instruction.
1417          *  Invariant: all elements of a chain list have the same stacksize
1418          *  and compatible stack and register contents.
1419          */
1420         Code.State state;
1421 
1422         /** The next jump in the list.
1423          */
1424         public final Chain next;
1425 
1426         /** Construct a chain from its jump position, stacksize, previous
1427          *  chain, and machine state.
1428          */
1429         public Chain(int pc, Chain next, Code.State state) {
1430             this.pc = pc;
1431             this.next = next;
1432             this.state = state;
1433         }
1434     }
1435 
1436     /** Negate a branch opcode.
1437      */
1438     public static int negate(int opcode) {
1439         if (opcode == if_acmp_null) return if_acmp_nonnull;
1440         else if (opcode == if_acmp_nonnull) return if_acmp_null;
1441         else return ((opcode + 1) ^ 1) - 1;
1442     }
1443 
1444     /** Emit a jump instruction.
1445      *  Return code pointer of instruction to be patched.
1446      */
1447     public int emitJump(int opcode) {
1448         if (fatcode) {
1449             if (opcode == goto_ || opcode == jsr) {
1450                 emitop4(opcode + goto_w - goto_, 0);
1451             } else {
1452                 emitop2(negate(opcode), 8);
1453                 emitop4(goto_w, 0);
1454                 alive = true;
1455                 pendingStackMap = needStackMap;
1456             }
1457             return cp - 5;
1458         } else {
1459             emitop2(opcode, 0);
1460             return cp - 3;
1461         }
1462     }
1463 
1464     /** Emit a branch with given opcode; return its chain.
1465      *  branch differs from jump in that jsr is treated as no-op.
1466      */
1467     public Chain branch(int opcode) {
1468         Chain result = null;
1469         if (opcode == goto_) {
1470             result = pendingJumps;
1471             pendingJumps = null;
1472         }
1473         if (opcode != dontgoto &amp;&amp; isAlive()) {
1474             result = new Chain(emitJump(opcode),
1475                                result,
1476                                state.dup());
1477             fixedPc = fatcode;
1478             if (opcode == goto_) alive = false;
1479         }
1480         return result;
1481     }
1482 
1483     /** Resolve chain to point to given target.
1484      */
1485     public void resolve(Chain chain, int target) {
1486         boolean changed = false;
1487         State newState = state;
1488         for (; chain != null; chain = chain.next) {
1489             Assert.check(state != chain.state
1490                     &amp;&amp; (target &gt; chain.pc || isStatementStart()));
1491             if (target &gt;= cp) {
1492                 target = cp;
1493             } else if (get1(target) == goto_) {
1494                 if (fatcode) target = target + get4(target + 1);
1495                 else target = target + get2(target + 1);
1496             }
1497             if (get1(chain.pc) == goto_ &amp;&amp;
1498                 chain.pc + 3 == target &amp;&amp; target == cp &amp;&amp; !fixedPc) {
1499                 // If goto the next instruction, the jump is not needed:
1500                 // compact the code.
1501                 if (varDebugInfo) {
1502                     adjustAliveRanges(cp, -3);
1503                 }
1504                 cp = cp - 3;
1505                 target = target - 3;
1506                 if (chain.next == null) {
1507                     // This is the only jump to the target. Exit the loop
1508                     // without setting new state. The code is reachable
1509                     // from the instruction before goto_.
1510                     alive = true;
1511                     break;
1512                 }
1513             } else {
1514                 if (fatcode)
1515                     put4(chain.pc + 1, target - chain.pc);
1516                 else if (target - chain.pc &lt; Short.MIN_VALUE ||
1517                          target - chain.pc &gt; Short.MAX_VALUE)
1518                     fatcode = true;
1519                 else
1520                     put2(chain.pc + 1, target - chain.pc);
1521                 Assert.check(!alive ||
1522                     chain.state.stacksize == newState.stacksize &amp;&amp;
1523                     chain.state.nlocks == newState.nlocks);
1524             }
1525             fixedPc = true;
1526             if (cp == target) {
1527                 changed = true;
1528                 if (debugCode)
1529                     System.err.println(&quot;resolving chain state=&quot; + chain.state);
1530                 if (alive) {
1531                     newState = chain.state.join(newState);
1532                 } else {
1533                     newState = chain.state;
1534                     alive = true;
1535                 }
1536             }
1537         }
1538         Assert.check(!changed || state != newState);
1539         if (state != newState) {
1540             setDefined(newState.defined);
1541             state = newState;
1542             pendingStackMap = needStackMap;
1543         }
1544     }
1545 
1546     /** Resolve chain to point to current code pointer.
1547      */
1548     public void resolve(Chain chain) {
1549         Assert.check(
1550             !alive ||
1551             chain==null ||
1552             state.stacksize == chain.state.stacksize &amp;&amp;
1553             state.nlocks == chain.state.nlocks);
1554         pendingJumps = mergeChains(chain, pendingJumps);
1555     }
1556 
1557     /** Resolve any pending jumps.
1558      */
1559     public void resolvePending() {
1560         Chain x = pendingJumps;
1561         pendingJumps = null;
1562         resolve(x, cp);
1563     }
1564 
1565     /** Merge the jumps in of two chains into one.
1566      */
1567     public static Chain mergeChains(Chain chain1, Chain chain2) {
1568         // recursive merge sort
1569         if (chain2 == null) return chain1;
1570         if (chain1 == null) return chain2;
1571         Assert.check(
1572             chain1.state.stacksize == chain2.state.stacksize &amp;&amp;
1573             chain1.state.nlocks == chain2.state.nlocks);
1574         if (chain1.pc &lt; chain2.pc)
1575             return new Chain(
1576                 chain2.pc,
1577                 mergeChains(chain1, chain2.next),
1578                 chain2.state);
1579         return new Chain(
1580                 chain1.pc,
1581                 mergeChains(chain1.next, chain2),
1582                 chain1.state);
1583     }
1584 
1585 
1586 /* **************************************************************************
1587  * Catch clauses
1588  ****************************************************************************/
1589 
1590     /** Add a catch clause to code.
1591      */
1592     public void addCatch(char startPc, char endPc,
1593                          char handlerPc, char catchType) {
1594             catchInfo.append(new char[]{startPc, endPc, handlerPc, catchType});
1595         }
1596 
1597 
1598     public void compressCatchTable() {
1599         ListBuffer&lt;char[]&gt; compressedCatchInfo = new ListBuffer&lt;&gt;();
1600         List&lt;Integer&gt; handlerPcs = List.nil();
1601         for (char[] catchEntry : catchInfo) {
1602             handlerPcs = handlerPcs.prepend((int)catchEntry[2]);
1603         }
1604         for (char[] catchEntry : catchInfo) {
1605             int startpc = catchEntry[0];
1606             int endpc = catchEntry[1];
1607             if (startpc == endpc ||
1608                     (startpc == (endpc - 1) &amp;&amp;
1609                     handlerPcs.contains(startpc))) {
1610                 continue;
1611             } else {
1612                 compressedCatchInfo.append(catchEntry);
1613             }
1614         }
1615         catchInfo = compressedCatchInfo;
1616     }
1617 
1618 
1619 /* **************************************************************************
1620  * Line numbers
1621  ****************************************************************************/
1622 
1623     /** Add a line number entry.
1624      */
1625     public void addLineNumber(char startPc, char lineNumber) {
1626         if (lineDebugInfo) {
1627             if (lineInfo.nonEmpty() &amp;&amp; lineInfo.head[0] == startPc)
1628                 lineInfo = lineInfo.tail;
1629             if (lineInfo.isEmpty() || lineInfo.head[1] != lineNumber)
1630                 lineInfo = lineInfo.prepend(new char[]{startPc, lineNumber});
1631         }
1632     }
1633 
1634     /** Mark beginning of statement.
1635      */
1636     public void statBegin(int pos) {
1637         if (pos != Position.NOPOS) {
1638             pendingStatPos = pos;
1639         }
1640     }
1641 
1642     /** Force stat begin eagerly
1643      */
1644     public void markStatBegin() {
1645         if (alive &amp;&amp; lineDebugInfo) {
1646             int line = lineMap.getLineNumber(pendingStatPos);
1647             char cp1 = (char)cp;
1648             char line1 = (char)line;
1649             if (cp1 == cp &amp;&amp; line1 == line)
1650                 addLineNumber(cp1, line1);
1651         }
1652         pendingStatPos = Position.NOPOS;
1653     }
1654 
1655 
1656 /* **************************************************************************
1657  * Simulated VM machine state
1658  ****************************************************************************/
1659 
1660     class State implements Cloneable {
1661         /** The set of registers containing values. */
1662         Bits defined;
1663 
1664         /** The (types of the) contents of the machine stack. */
1665         Type[] stack;
1666 
1667         /** The first stack position currently unused. */
1668         int stacksize;
1669 
1670         /** The numbers of registers containing locked monitors. */
1671         int[] locks;
1672         int nlocks;
1673 
1674         State() {
1675             defined = new Bits();
1676             stack = new Type[16];
1677         }
1678 
1679         State dup() {
1680             try {
1681                 State state = (State)super.clone();
1682                 state.defined = new Bits(defined);
1683                 state.stack = stack.clone();
1684                 if (locks != null) state.locks = locks.clone();
1685                 if (debugCode) {
1686                     System.err.println(&quot;duping state &quot; + this);
1687                     dump();
1688                 }
1689                 return state;
1690             } catch (CloneNotSupportedException ex) {
1691                 throw new AssertionError(ex);
1692             }
1693         }
1694 
1695         void lock(int register) {
1696             if (locks == null) {
1697                 locks = new int[20];
1698             } else {
1699                 locks = ArrayUtils.ensureCapacity(locks, nlocks);
1700             }
1701             locks[nlocks] = register;
1702             nlocks++;
1703         }
1704 
1705         void unlock(int register) {
1706             nlocks--;
1707             Assert.check(locks[nlocks] == register);
1708             locks[nlocks] = -1;
1709         }
1710 
1711         void push(Type t) {
1712             if (debugCode) System.err.println(&quot;   pushing &quot; + t);
1713             switch (t.getTag()) {
1714             case VOID:
1715                 return;
1716             case BYTE:
1717             case CHAR:
1718             case SHORT:
1719             case BOOLEAN:
1720                 t = syms.intType;
1721                 break;
1722             default:
1723                 break;
1724             }
1725             stack = ArrayUtils.ensureCapacity(stack, stacksize+2);
1726             stack[stacksize++] = t;
1727             switch (width(t)) {
1728             case 1:
1729                 break;
1730             case 2:
1731                 stack[stacksize++] = null;
1732                 break;
1733             default:
1734                 throw new AssertionError(t);
1735             }
1736             if (stacksize &gt; max_stack)
1737                 max_stack = stacksize;
1738         }
1739 
1740         Type pop1() {
1741             if (debugCode) System.err.println(&quot;   popping &quot; + 1);
1742             stacksize--;
1743             Type result = stack[stacksize];
1744             stack[stacksize] = null;
1745             Assert.check(result != null &amp;&amp; width(result) == 1);
1746             return result;
1747         }
1748 
1749         Type peek() {
1750             return stack[stacksize-1];
1751         }
1752 
1753         Type pop2() {
1754             if (debugCode) System.err.println(&quot;   popping &quot; + 2);
1755             stacksize -= 2;
1756             Type result = stack[stacksize];
1757             stack[stacksize] = null;
1758             Assert.check(stack[stacksize+1] == null
1759                     &amp;&amp; result != null &amp;&amp; width(result) == 2);
1760             return result;
1761         }
1762 
1763         void pop(int n) {
1764             if (debugCode) System.err.println(&quot;   popping &quot; + n);
1765             while (n &gt; 0) {
1766                 stack[--stacksize] = null;
1767                 n--;
1768             }
1769         }
1770 
1771         void pop(Type t) {
1772             pop(width(t));
1773         }
1774 
1775         /** Force the top of the stack to be treated as this supertype
1776          *  of its current type. */
1777         void forceStackTop(Type t) {
1778             if (!alive) return;
1779             switch (t.getTag()) {
1780             case CLASS:
1781             case ARRAY:
1782                 int width = width(t);
1783                 Type old = stack[stacksize-width];
<a name="1" id="anc1"></a><span class="line-modified">1784                 Assert.check(types.isSubtype(types.erasure(old),</span>
<span class="line-modified">1785                                        types.erasure(t)));</span>
1786                 stack[stacksize-width] = t;
1787                 break;
1788             default:
1789             }
1790         }
1791 
1792         void markInitialized(UninitializedType old) {
1793             Type newtype = old.initializedType();
1794             for (int i=0; i&lt;stacksize; i++) {
1795                 if (stack[i] == old) stack[i] = newtype;
1796             }
1797             for (int i=0; i&lt;lvar.length; i++) {
1798                 LocalVar lv = lvar[i];
1799                 if (lv != null &amp;&amp; lv.sym.type == old) {
1800                     VarSymbol sym = lv.sym;
1801                     sym = sym.clone(sym.owner);
1802                     sym.type = newtype;
1803                     LocalVar newlv = lvar[i] = new LocalVar(sym);
1804                     newlv.aliveRanges = lv.aliveRanges;
1805                 }
1806             }
1807         }
1808 
1809         State join(State other) {
1810             defined.andSet(other.defined);
1811             Assert.check(stacksize == other.stacksize
1812                     &amp;&amp; nlocks == other.nlocks);
1813             for (int i=0; i&lt;stacksize; ) {
1814                 Type t = stack[i];
1815                 Type tother = other.stack[i];
1816                 Type result =
1817                     t==tother ? t :
1818                     types.isSubtype(t, tother) ? tother :
1819                     types.isSubtype(tother, t) ? t :
1820                     error();
1821                 int w = width(result);
1822                 stack[i] = result;
1823                 if (w == 2) Assert.checkNull(stack[i+1]);
1824                 i += w;
1825             }
1826             return this;
1827         }
1828 
1829         Type error() {
1830             throw new AssertionError(&quot;inconsistent stack types at join point&quot;);
1831         }
1832 
1833         void dump() {
1834             dump(-1);
1835         }
1836 
1837         void dump(int pc) {
1838             System.err.print(&quot;stackMap for &quot; + meth.owner + &quot;.&quot; + meth);
1839             if (pc == -1)
1840                 System.out.println();
1841             else
1842                 System.out.println(&quot; at &quot; + pc);
1843             System.err.println(&quot; stack (from bottom):&quot;);
1844             for (int i=0; i&lt;stacksize; i++)
1845                 System.err.println(&quot;  &quot; + i + &quot;: &quot; + stack[i]);
1846 
1847             int lastLocal = 0;
1848             for (int i=max_locals-1; i&gt;=0; i--) {
1849                 if (defined.isMember(i)) {
1850                     lastLocal = i;
1851                     break;
1852                 }
1853             }
1854             if (lastLocal &gt;= 0)
1855                 System.err.println(&quot; locals:&quot;);
1856             for (int i=0; i&lt;=lastLocal; i++) {
1857                 System.err.print(&quot;  &quot; + i + &quot;: &quot;);
1858                 if (defined.isMember(i)) {
1859                     LocalVar var = lvar[i];
1860                     if (var == null) {
1861                         System.err.println(&quot;(none)&quot;);
1862                     } else if (var.sym == null)
1863                         System.err.println(&quot;UNKNOWN!&quot;);
1864                     else
1865                         System.err.println(&quot;&quot; + var.sym + &quot; of type &quot; +
1866                                            var.sym.erasure(types));
1867                 } else {
1868                     System.err.println(&quot;undefined&quot;);
1869                 }
1870             }
1871             if (nlocks != 0) {
1872                 System.err.print(&quot; locks:&quot;);
1873                 for (int i=0; i&lt;nlocks; i++) {
1874                     System.err.print(&quot; &quot; + locks[i]);
1875                 }
1876                 System.err.println();
1877             }
1878         }
1879     }
1880 
1881     static final Type jsrReturnValue = new JCPrimitiveType(INT, null);
1882 
1883 
1884 /* **************************************************************************
1885  * Local variables
1886  ****************************************************************************/
1887 
1888     /** A live range of a local variable. */
1889     static class LocalVar {
1890         final VarSymbol sym;
1891         final char reg;
1892 
1893         class Range {
1894             char start_pc = Character.MAX_VALUE;
1895             char length = Character.MAX_VALUE;
1896 
1897             Range() {}
1898 
1899             Range(char start) {
1900                 this.start_pc = start;
1901             }
1902 
1903             Range(char start, char length) {
1904                 this.start_pc = start;
1905                 this.length = length;
1906             }
1907 
1908             boolean closed() {
1909                 return start_pc != Character.MAX_VALUE &amp;&amp; length != Character.MAX_VALUE;
1910             }
1911 
1912             @Override
1913             public String toString() {
1914                 int currentStartPC = start_pc;
1915                 int currentLength = length;
1916                 return &quot;startpc = &quot; + currentStartPC + &quot; length &quot; + currentLength;
1917             }
1918         }
1919 
1920         java.util.List&lt;Range&gt; aliveRanges = new java.util.ArrayList&lt;&gt;();
1921 
1922         LocalVar(VarSymbol v) {
1923             this.sym = v;
1924             this.reg = (char)v.adr;
1925         }
1926         public LocalVar dup() {
1927             return new LocalVar(sym);
1928         }
1929 
1930         Range firstRange() {
1931             return aliveRanges.isEmpty() ? null : aliveRanges.get(0);
1932         }
1933 
1934         Range lastRange() {
1935             return aliveRanges.isEmpty() ? null : aliveRanges.get(aliveRanges.size() - 1);
1936         }
1937 
1938         void removeLastRange() {
1939             Range lastRange = lastRange();
1940             if (lastRange != null) {
1941                 aliveRanges.remove(lastRange);
1942             }
1943         }
1944 
1945         @Override
1946         public String toString() {
1947             if (aliveRanges == null) {
1948                 return &quot;empty local var&quot;;
1949             }
1950             StringBuilder sb = new StringBuilder().append(sym)
1951                     .append(&quot; in register &quot;).append((int)reg).append(&quot; \n&quot;);
1952             for (Range r : aliveRanges) {
1953                 sb.append(&quot; starts at pc=&quot;).append(Integer.toString(((int)r.start_pc)))
1954                     .append(&quot; length=&quot;).append(Integer.toString(((int)r.length)))
1955                     .append(&quot;\n&quot;);
1956             }
1957             return sb.toString();
1958         }
1959 
1960         public void openRange(char start) {
1961             if (!hasOpenRange()) {
1962                 aliveRanges.add(new Range(start));
1963             }
1964         }
1965 
1966         public void closeRange(char length) {
1967             if (isLastRangeInitialized() &amp;&amp; length &gt; 0) {
1968                 Range range = lastRange();
1969                 if (range != null) {
1970                     if (range.length == Character.MAX_VALUE) {
1971                         range.length = length;
1972                     }
1973                 }
1974             } else {
1975                 removeLastRange();
1976             }
1977         }
1978 
1979         public boolean hasOpenRange() {
1980             if (aliveRanges.isEmpty()) {
1981                 return false;
1982             }
1983             return lastRange().length == Character.MAX_VALUE;
1984         }
1985 
1986         public boolean isLastRangeInitialized() {
1987             if (aliveRanges.isEmpty()) {
1988                 return false;
1989             }
1990             return lastRange().start_pc != Character.MAX_VALUE;
1991         }
1992 
1993         public Range getWidestRange() {
1994             if (aliveRanges.isEmpty()) {
1995                 return new Range();
1996             } else {
1997                 Range firstRange = firstRange();
1998                 Range lastRange = lastRange();
1999                 char length = (char)(lastRange.length + (lastRange.start_pc - firstRange.start_pc));
2000                 return new Range(firstRange.start_pc, length);
2001             }
2002          }
2003 
2004     }
2005 
2006     /** Local variables, indexed by register. */
2007     LocalVar[] lvar;
2008 
2009     /** Add a new local variable. */
2010     private void addLocalVar(VarSymbol v) {
2011         int adr = v.adr;
2012         lvar = ArrayUtils.ensureCapacity(lvar, adr+1);
2013         Assert.checkNull(lvar[adr]);
2014         if (pendingJumps != null) {
2015             resolvePending();
2016         }
2017         lvar[adr] = new LocalVar(v);
2018         state.defined.excl(adr);
2019     }
2020 
2021     void adjustAliveRanges(int oldCP, int delta) {
2022         for (LocalVar localVar: lvar) {
2023             if (localVar != null) {
2024                 for (LocalVar.Range range: localVar.aliveRanges) {
2025                     if (range.closed() &amp;&amp; range.start_pc + range.length &gt;= oldCP) {
2026                         range.length += delta;
2027                     }
2028                 }
2029             }
2030         }
2031     }
2032 
2033     /**
2034      * Calculates the size of the LocalVariableTable.
2035      */
2036     public int getLVTSize() {
2037         int result = varBufferSize;
2038         for (int i = 0; i &lt; varBufferSize; i++) {
2039             LocalVar var = varBuffer[i];
2040             result += var.aliveRanges.size() - 1;
2041         }
2042         return result;
2043     }
2044 
2045     /** Set the current variable defined state. */
2046     public void setDefined(Bits newDefined) {
2047         if (alive &amp;&amp; newDefined != state.defined) {
2048             Bits diff = new Bits(state.defined).xorSet(newDefined);
2049             for (int adr = diff.nextBit(0);
2050                  adr &gt;= 0;
2051                  adr = diff.nextBit(adr+1)) {
2052                 if (adr &gt;= nextreg)
2053                     state.defined.excl(adr);
2054                 else if (state.defined.isMember(adr))
2055                     setUndefined(adr);
2056                 else
2057                     setDefined(adr);
2058             }
2059         }
2060     }
2061 
2062     /** Mark a register as being (possibly) defined. */
2063     public void setDefined(int adr) {
2064         LocalVar v = lvar[adr];
2065         if (v == null) {
2066             state.defined.excl(adr);
2067         } else {
2068             state.defined.incl(adr);
2069             if (cp &lt; Character.MAX_VALUE) {
2070                 v.openRange((char)cp);
2071             }
2072         }
2073     }
2074 
2075     /** Mark a register as being undefined. */
2076     public void setUndefined(int adr) {
2077         state.defined.excl(adr);
2078         if (adr &lt; lvar.length &amp;&amp;
2079             lvar[adr] != null &amp;&amp;
2080             lvar[adr].isLastRangeInitialized()) {
2081             LocalVar v = lvar[adr];
2082             char length = (char)(curCP() - v.lastRange().start_pc);
2083             if (length &lt; Character.MAX_VALUE) {
2084                 lvar[adr] = v.dup();
2085                 v.closeRange(length);
2086                 putVar(v);
2087                 fillLocalVarPosition(v);
2088             } else {
2089                 v.removeLastRange();
2090             }
2091         }
2092     }
2093 
2094     /** End the scope of a variable. */
2095     private void endScope(int adr) {
2096         LocalVar v = lvar[adr];
2097         if (v != null) {
2098             if (v.isLastRangeInitialized()) {
2099                 char length = (char)(curCP() - v.lastRange().start_pc);
2100                 if (length &lt; Character.MAX_VALUE) {
2101                     v.closeRange(length);
2102                     putVar(v);
2103                     fillLocalVarPosition(v);
2104                 }
2105             }
2106             /** the call to curCP() can implicitly adjust the current cp, if so
2107              * the alive range of local variables may be modified. Thus we need
2108              * all of them. For this reason assigning null to the given address
2109              * should be the last action to do.
2110              */
2111             lvar[adr] = null;
2112         }
2113         state.defined.excl(adr);
2114     }
2115 
2116     private void fillLocalVarPosition(LocalVar lv) {
2117         if (lv == null || lv.sym == null || lv.sym.isExceptionParameter()|| !lv.sym.hasTypeAnnotations())
2118             return;
2119         LocalVar.Range[] validRanges = lv.aliveRanges.stream().filter(r -&gt; r.closed() &amp;&amp; r.length &gt; 0).toArray(s -&gt; new LocalVar.Range[s]);
2120         if (validRanges.length == 0)
2121             return ;
2122         int[] lvarOffset = Arrays.stream(validRanges).mapToInt(r -&gt; r.start_pc).toArray();
2123         int[] lvarLength = Arrays.stream(validRanges).mapToInt(r -&gt; r.length).toArray();
2124         int[] lvarIndex = Arrays.stream(validRanges).mapToInt(r -&gt; lv.reg).toArray();
2125         for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2126             TypeAnnotationPosition p = ta.position;
2127             p.lvarOffset = appendArray(p.lvarOffset, lvarOffset);
2128             p.lvarLength = appendArray(p.lvarLength, lvarLength);
2129             p.lvarIndex = appendArray(p.lvarIndex, lvarIndex);
2130             p.isValidOffset = true;
2131         }
2132     }
2133 
2134     private int[] appendArray(int[] source, int[] append) {
2135         if (source == null || source.length == 0) return append;
2136 
2137         int[] result = new int[source.length + append.length];
2138 
2139         System.arraycopy(source, 0, result, 0, source.length);
2140         System.arraycopy(append, 0, result, source.length, append.length);
2141         return result;
2142     }
2143 
2144     // Method to be called after compressCatchTable to
2145     // fill in the exception table index for type
2146     // annotations on exception parameters.
2147     public void fillExceptionParameterPositions() {
2148         for (int i = 0; i &lt; varBufferSize; ++i) {
2149             LocalVar lv = varBuffer[i];
2150             if (lv == null || lv.sym == null
2151                     || !lv.sym.hasTypeAnnotations()
2152                     || !lv.sym.isExceptionParameter())
2153                 continue;
2154 
2155             for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2156                 TypeAnnotationPosition p = ta.position;
2157                 if (p.hasCatchType()) {
2158                     final int idx = findExceptionIndex(p);
2159                     if (idx == -1)
2160                         Assert.error(&quot;Could not find exception index for type annotation &quot; +
2161                                      ta + &quot; on exception parameter&quot;);
2162                     p.setExceptionIndex(idx);
2163                 }
2164             }
2165         }
2166     }
2167 
2168     private int findExceptionIndex(TypeAnnotationPosition p) {
2169         final int catchType = p.getCatchType();
2170         final int startPos = p.getStartPos();
2171         final int len = catchInfo.length();
2172         List&lt;char[]&gt; iter = catchInfo.toList();
2173         for (int i = 0; i &lt; len; ++i) {
2174             char[] catchEntry = iter.head;
2175             iter = iter.tail;
2176             int ct = catchEntry[3];
2177             int sp = catchEntry[0];
2178             if (catchType == ct &amp;&amp; sp == startPos) {
2179                 return i;
2180             }
2181         }
2182         return -1;
2183     }
2184 
2185     /** Put a live variable range into the buffer to be output to the
2186      *  class file.
2187      */
2188     void putVar(LocalVar var) {
2189         // Keep local variables if
2190         // 1) we need them for debug information
2191         // 2) it is an exception type and it contains type annotations
2192         boolean keepLocalVariables = varDebugInfo ||
2193             (var.sym.isExceptionParameter() &amp;&amp; var.sym.hasTypeAnnotations());
2194         if (!keepLocalVariables) return;
2195         //don&#39;t keep synthetic vars, unless they are lambda method parameters
2196         boolean ignoredSyntheticVar = (var.sym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp;
2197                 ((var.sym.owner.flags() &amp; Flags.LAMBDA_METHOD) == 0 ||
2198                  (var.sym.flags() &amp; Flags.PARAMETER) == 0);
2199         if (ignoredSyntheticVar) return;
2200         if (varBuffer == null)
2201             varBuffer = new LocalVar[20];
2202         else
2203             varBuffer = ArrayUtils.ensureCapacity(varBuffer, varBufferSize);
2204         varBuffer[varBufferSize++] = var;
2205     }
2206 
2207     /** Previously live local variables, to be put into the variable table. */
2208     LocalVar[] varBuffer;
2209     int varBufferSize;
2210 
2211     /** Create a new local variable address and return it.
2212      */
2213     private int newLocal(int typecode) {
2214         int reg = nextreg;
2215         int w = width(typecode);
2216         nextreg = reg + w;
2217         if (nextreg &gt; max_locals) max_locals = nextreg;
2218         return reg;
2219     }
2220 
2221     private int newLocal(Type type) {
2222         return newLocal(typecode(type));
2223     }
2224 
2225     public int newLocal(VarSymbol v) {
2226         int reg = v.adr = newLocal(v.erasure(types));
2227         addLocalVar(v);
2228         return reg;
2229     }
2230 
2231     /** Start a set of fresh registers.
2232      */
2233     public void newRegSegment() {
2234         nextreg = max_locals;
2235     }
2236 
2237     /** End scopes of all variables with registers &amp;ge; first.
2238      */
2239     public void endScopes(int first) {
2240         int prevNextReg = nextreg;
2241         nextreg = first;
2242         for (int i = nextreg; i &lt; prevNextReg; i++) endScope(i);
2243     }
2244 
2245 /**************************************************************************
2246  * static tables
2247  *************************************************************************/
2248 
2249     public static String mnem(int opcode) {
2250         return Mneumonics.mnem[opcode];
2251     }
2252 
2253     private static class Mneumonics {
2254         private final static String[] mnem = new String[ByteCodeCount];
2255         static {
2256             mnem[nop] = &quot;nop&quot;;
2257             mnem[aconst_null] = &quot;aconst_null&quot;;
2258             mnem[iconst_m1] = &quot;iconst_m1&quot;;
2259             mnem[iconst_0] = &quot;iconst_0&quot;;
2260             mnem[iconst_1] = &quot;iconst_1&quot;;
2261             mnem[iconst_2] = &quot;iconst_2&quot;;
2262             mnem[iconst_3] = &quot;iconst_3&quot;;
2263             mnem[iconst_4] = &quot;iconst_4&quot;;
2264             mnem[iconst_5] = &quot;iconst_5&quot;;
2265             mnem[lconst_0] = &quot;lconst_0&quot;;
2266             mnem[lconst_1] = &quot;lconst_1&quot;;
2267             mnem[fconst_0] = &quot;fconst_0&quot;;
2268             mnem[fconst_1] = &quot;fconst_1&quot;;
2269             mnem[fconst_2] = &quot;fconst_2&quot;;
2270             mnem[dconst_0] = &quot;dconst_0&quot;;
2271             mnem[dconst_1] = &quot;dconst_1&quot;;
2272             mnem[bipush] = &quot;bipush&quot;;
2273             mnem[sipush] = &quot;sipush&quot;;
2274             mnem[ldc1] = &quot;ldc1&quot;;
2275             mnem[ldc2] = &quot;ldc2&quot;;
2276             mnem[ldc2w] = &quot;ldc2w&quot;;
2277             mnem[iload] = &quot;iload&quot;;
2278             mnem[lload] = &quot;lload&quot;;
2279             mnem[fload] = &quot;fload&quot;;
2280             mnem[dload] = &quot;dload&quot;;
2281             mnem[aload] = &quot;aload&quot;;
2282             mnem[iload_0] = &quot;iload_0&quot;;
2283             mnem[lload_0] = &quot;lload_0&quot;;
2284             mnem[fload_0] = &quot;fload_0&quot;;
2285             mnem[dload_0] = &quot;dload_0&quot;;
2286             mnem[aload_0] = &quot;aload_0&quot;;
2287             mnem[iload_1] = &quot;iload_1&quot;;
2288             mnem[lload_1] = &quot;lload_1&quot;;
2289             mnem[fload_1] = &quot;fload_1&quot;;
2290             mnem[dload_1] = &quot;dload_1&quot;;
2291             mnem[aload_1] = &quot;aload_1&quot;;
2292             mnem[iload_2] = &quot;iload_2&quot;;
2293             mnem[lload_2] = &quot;lload_2&quot;;
2294             mnem[fload_2] = &quot;fload_2&quot;;
2295             mnem[dload_2] = &quot;dload_2&quot;;
2296             mnem[aload_2] = &quot;aload_2&quot;;
2297             mnem[iload_3] = &quot;iload_3&quot;;
2298             mnem[lload_3] = &quot;lload_3&quot;;
2299             mnem[fload_3] = &quot;fload_3&quot;;
2300             mnem[dload_3] = &quot;dload_3&quot;;
2301             mnem[aload_3] = &quot;aload_3&quot;;
2302             mnem[iaload] = &quot;iaload&quot;;
2303             mnem[laload] = &quot;laload&quot;;
2304             mnem[faload] = &quot;faload&quot;;
2305             mnem[daload] = &quot;daload&quot;;
2306             mnem[aaload] = &quot;aaload&quot;;
2307             mnem[baload] = &quot;baload&quot;;
2308             mnem[caload] = &quot;caload&quot;;
2309             mnem[saload] = &quot;saload&quot;;
2310             mnem[istore] = &quot;istore&quot;;
2311             mnem[lstore] = &quot;lstore&quot;;
2312             mnem[fstore] = &quot;fstore&quot;;
2313             mnem[dstore] = &quot;dstore&quot;;
2314             mnem[astore] = &quot;astore&quot;;
2315             mnem[istore_0] = &quot;istore_0&quot;;
2316             mnem[lstore_0] = &quot;lstore_0&quot;;
2317             mnem[fstore_0] = &quot;fstore_0&quot;;
2318             mnem[dstore_0] = &quot;dstore_0&quot;;
2319             mnem[astore_0] = &quot;astore_0&quot;;
2320             mnem[istore_1] = &quot;istore_1&quot;;
2321             mnem[lstore_1] = &quot;lstore_1&quot;;
2322             mnem[fstore_1] = &quot;fstore_1&quot;;
2323             mnem[dstore_1] = &quot;dstore_1&quot;;
2324             mnem[astore_1] = &quot;astore_1&quot;;
2325             mnem[istore_2] = &quot;istore_2&quot;;
2326             mnem[lstore_2] = &quot;lstore_2&quot;;
2327             mnem[fstore_2] = &quot;fstore_2&quot;;
2328             mnem[dstore_2] = &quot;dstore_2&quot;;
2329             mnem[astore_2] = &quot;astore_2&quot;;
2330             mnem[istore_3] = &quot;istore_3&quot;;
2331             mnem[lstore_3] = &quot;lstore_3&quot;;
2332             mnem[fstore_3] = &quot;fstore_3&quot;;
2333             mnem[dstore_3] = &quot;dstore_3&quot;;
2334             mnem[astore_3] = &quot;astore_3&quot;;
2335             mnem[iastore] = &quot;iastore&quot;;
2336             mnem[lastore] = &quot;lastore&quot;;
2337             mnem[fastore] = &quot;fastore&quot;;
2338             mnem[dastore] = &quot;dastore&quot;;
2339             mnem[aastore] = &quot;aastore&quot;;
2340             mnem[bastore] = &quot;bastore&quot;;
2341             mnem[castore] = &quot;castore&quot;;
2342             mnem[sastore] = &quot;sastore&quot;;
2343             mnem[pop] = &quot;pop&quot;;
2344             mnem[pop2] = &quot;pop2&quot;;
2345             mnem[dup] = &quot;dup&quot;;
2346             mnem[dup_x1] = &quot;dup_x1&quot;;
2347             mnem[dup_x2] = &quot;dup_x2&quot;;
2348             mnem[dup2] = &quot;dup2&quot;;
2349             mnem[dup2_x1] = &quot;dup2_x1&quot;;
2350             mnem[dup2_x2] = &quot;dup2_x2&quot;;
2351             mnem[swap] = &quot;swap&quot;;
2352             mnem[iadd] = &quot;iadd&quot;;
2353             mnem[ladd] = &quot;ladd&quot;;
2354             mnem[fadd] = &quot;fadd&quot;;
2355             mnem[dadd] = &quot;dadd&quot;;
2356             mnem[isub] = &quot;isub&quot;;
2357             mnem[lsub] = &quot;lsub&quot;;
2358             mnem[fsub] = &quot;fsub&quot;;
2359             mnem[dsub] = &quot;dsub&quot;;
2360             mnem[imul] = &quot;imul&quot;;
2361             mnem[lmul] = &quot;lmul&quot;;
2362             mnem[fmul] = &quot;fmul&quot;;
2363             mnem[dmul] = &quot;dmul&quot;;
2364             mnem[idiv] = &quot;idiv&quot;;
2365             mnem[ldiv] = &quot;ldiv&quot;;
2366             mnem[fdiv] = &quot;fdiv&quot;;
2367             mnem[ddiv] = &quot;ddiv&quot;;
2368             mnem[imod] = &quot;imod&quot;;
2369             mnem[lmod] = &quot;lmod&quot;;
2370             mnem[fmod] = &quot;fmod&quot;;
2371             mnem[dmod] = &quot;dmod&quot;;
2372             mnem[ineg] = &quot;ineg&quot;;
2373             mnem[lneg] = &quot;lneg&quot;;
2374             mnem[fneg] = &quot;fneg&quot;;
2375             mnem[dneg] = &quot;dneg&quot;;
2376             mnem[ishl] = &quot;ishl&quot;;
2377             mnem[lshl] = &quot;lshl&quot;;
2378             mnem[ishr] = &quot;ishr&quot;;
2379             mnem[lshr] = &quot;lshr&quot;;
2380             mnem[iushr] = &quot;iushr&quot;;
2381             mnem[lushr] = &quot;lushr&quot;;
2382             mnem[iand] = &quot;iand&quot;;
2383             mnem[land] = &quot;land&quot;;
2384             mnem[ior] = &quot;ior&quot;;
2385             mnem[lor] = &quot;lor&quot;;
2386             mnem[ixor] = &quot;ixor&quot;;
2387             mnem[lxor] = &quot;lxor&quot;;
2388             mnem[iinc] = &quot;iinc&quot;;
2389             mnem[i2l] = &quot;i2l&quot;;
2390             mnem[i2f] = &quot;i2f&quot;;
2391             mnem[i2d] = &quot;i2d&quot;;
2392             mnem[l2i] = &quot;l2i&quot;;
2393             mnem[l2f] = &quot;l2f&quot;;
2394             mnem[l2d] = &quot;l2d&quot;;
2395             mnem[f2i] = &quot;f2i&quot;;
2396             mnem[f2l] = &quot;f2l&quot;;
2397             mnem[f2d] = &quot;f2d&quot;;
2398             mnem[d2i] = &quot;d2i&quot;;
2399             mnem[d2l] = &quot;d2l&quot;;
2400             mnem[d2f] = &quot;d2f&quot;;
2401             mnem[int2byte] = &quot;int2byte&quot;;
2402             mnem[int2char] = &quot;int2char&quot;;
2403             mnem[int2short] = &quot;int2short&quot;;
2404             mnem[lcmp] = &quot;lcmp&quot;;
2405             mnem[fcmpl] = &quot;fcmpl&quot;;
2406             mnem[fcmpg] = &quot;fcmpg&quot;;
2407             mnem[dcmpl] = &quot;dcmpl&quot;;
2408             mnem[dcmpg] = &quot;dcmpg&quot;;
2409             mnem[ifeq] = &quot;ifeq&quot;;
2410             mnem[ifne] = &quot;ifne&quot;;
2411             mnem[iflt] = &quot;iflt&quot;;
2412             mnem[ifge] = &quot;ifge&quot;;
2413             mnem[ifgt] = &quot;ifgt&quot;;
2414             mnem[ifle] = &quot;ifle&quot;;
2415             mnem[if_icmpeq] = &quot;if_icmpeq&quot;;
2416             mnem[if_icmpne] = &quot;if_icmpne&quot;;
2417             mnem[if_icmplt] = &quot;if_icmplt&quot;;
2418             mnem[if_icmpge] = &quot;if_icmpge&quot;;
2419             mnem[if_icmpgt] = &quot;if_icmpgt&quot;;
2420             mnem[if_icmple] = &quot;if_icmple&quot;;
2421             mnem[if_acmpeq] = &quot;if_acmpeq&quot;;
2422             mnem[if_acmpne] = &quot;if_acmpne&quot;;
2423             mnem[goto_] = &quot;goto_&quot;;
2424             mnem[jsr] = &quot;jsr&quot;;
2425             mnem[ret] = &quot;ret&quot;;
2426             mnem[tableswitch] = &quot;tableswitch&quot;;
2427             mnem[lookupswitch] = &quot;lookupswitch&quot;;
2428             mnem[ireturn] = &quot;ireturn&quot;;
2429             mnem[lreturn] = &quot;lreturn&quot;;
2430             mnem[freturn] = &quot;freturn&quot;;
2431             mnem[dreturn] = &quot;dreturn&quot;;
2432             mnem[areturn] = &quot;areturn&quot;;
2433             mnem[return_] = &quot;return_&quot;;
2434             mnem[getstatic] = &quot;getstatic&quot;;
2435             mnem[putstatic] = &quot;putstatic&quot;;
2436             mnem[getfield] = &quot;getfield&quot;;
2437             mnem[putfield] = &quot;putfield&quot;;
2438             mnem[invokevirtual] = &quot;invokevirtual&quot;;
2439             mnem[invokespecial] = &quot;invokespecial&quot;;
2440             mnem[invokestatic] = &quot;invokestatic&quot;;
2441             mnem[invokeinterface] = &quot;invokeinterface&quot;;
2442             mnem[invokedynamic] = &quot;invokedynamic&quot;;
2443             mnem[new_] = &quot;new_&quot;;
2444             mnem[newarray] = &quot;newarray&quot;;
2445             mnem[anewarray] = &quot;anewarray&quot;;
2446             mnem[arraylength] = &quot;arraylength&quot;;
2447             mnem[athrow] = &quot;athrow&quot;;
2448             mnem[checkcast] = &quot;checkcast&quot;;
2449             mnem[instanceof_] = &quot;instanceof_&quot;;
2450             mnem[monitorenter] = &quot;monitorenter&quot;;
2451             mnem[monitorexit] = &quot;monitorexit&quot;;
2452             mnem[wide] = &quot;wide&quot;;
2453             mnem[multianewarray] = &quot;multianewarray&quot;;
2454             mnem[if_acmp_null] = &quot;if_acmp_null&quot;;
2455             mnem[if_acmp_nonnull] = &quot;if_acmp_nonnull&quot;;
2456             mnem[goto_w] = &quot;goto_w&quot;;
2457             mnem[jsr_w] = &quot;jsr_w&quot;;
2458             mnem[breakpoint] = &quot;breakpoint&quot;;
2459             mnem[defaultvalue] = &quot;defaultvalue&quot;;
2460             mnem[withfield] = &quot;withfield&quot;;
2461         }
2462     }
2463 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
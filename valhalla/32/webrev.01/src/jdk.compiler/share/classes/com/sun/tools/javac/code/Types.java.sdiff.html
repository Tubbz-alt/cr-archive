<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Type.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
<span class="line-removed">  98     final boolean nonCovariantValueArrays;</span>
  99     final boolean injectTopInterfaceTypes;
 100     final Check chk;
 101     final Enter enter;
 102     JCDiagnostic.Factory diags;
 103     List&lt;Warner&gt; warnStack = List.nil();
 104     final Name capturedName;
 105 
 106     public final Warner noWarnings;
 107 
 108     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 109     public static Types instance(Context context) {
 110         Types instance = context.get(typesKey);
 111         if (instance == null)
 112             instance = new Types(context);
 113         return instance;
 114     }
 115 
 116     protected Types(Context context) {
 117         context.put(typesKey, this);
 118         syms = Symtab.instance(context);
 119         names = Names.instance(context);
 120         Source source = Source.instance(context);
 121         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 122         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 123         chk = Check.instance(context);
 124         enter = Enter.instance(context);
 125         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 126         messages = JavacMessages.instance(context);
 127         diags = JCDiagnostic.Factory.instance(context);
 128         noWarnings = new Warner(null);
 129         Options options = Options.instance(context);
 130         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
<span class="line-removed"> 131         nonCovariantValueArrays = options.isSet(&quot;nonCovariantValueArrays&quot;);</span>
 132         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
 133                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
 134                 Target.instance(context).hasTopInterfaces();
 135     }
 136     // &lt;/editor-fold&gt;
 137 
 138     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 139     /**
 140      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 141      * @param t a type argument, either a wildcard or a type
 142      */
 143     public Type wildUpperBound(Type t) {
 144         if (t.hasTag(WILDCARD)) {
 145             WildcardType w = (WildcardType) t;
 146             if (w.isSuperBound())
 147                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 148             else
 149                 return wildUpperBound(w.type);
 150         }
 151         else return t;
</pre>
<hr />
<pre>
 595                 return res;
 596             }
 597 
 598             @Override
 599             public Type visitErrorType(ErrorType t, Symbol sym) {
 600                 return t;
 601             }
 602         };
 603     // &lt;/editor-fold&gt;
 604 
 605     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 606     /**
 607      * Is t a subtype of or convertible via boxing/unboxing
 608      * conversion to s?
 609      */
 610     public boolean isConvertible(Type t, Type s, Warner warn) {
 611         if (t.hasTag(ERROR)) {
 612             return true;
 613         }
 614 








 615         boolean tPrimitive = t.isPrimitive();
 616         boolean sPrimitive = s.isPrimitive();
 617         if (tPrimitive == sPrimitive) {
 618             return isSubtypeUnchecked(t, s, warn);
 619         }
 620         boolean tUndet = t.hasTag(UNDETVAR);
 621         boolean sUndet = s.hasTag(UNDETVAR);
 622 
 623         if (tUndet || sUndet) {
 624             return tUndet ?
 625                     isSubtype(t, boxedTypeOrType(s)) :
 626                     isSubtype(boxedTypeOrType(t), s);
 627         }
 628 
 629         return tPrimitive
 630             ? isSubtype(boxedClass(t).type, s)
 631             : isSubtype(unboxedType(t), s);
 632     }
 633 
 634     /**
</pre>
<hr />
<pre>
 996            this.origin = origin;
 997        }
 998 
 999        @Override
1000        public boolean accepts(Symbol sym) {
1001            return sym.kind == MTH &amp;&amp;
1002                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1003                    !overridesObjectMethod(origin, sym) &amp;&amp;
1004                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1005        }
1006     }
1007 
1008     public boolean isValue(Type t) {
1009         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1010     }
1011 
1012     public boolean isValueBased(Type t) {
1013         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1014     }
1015 
<span class="line-removed">1016     private final HashMap&lt;ClassSymbol, ClassSymbol&gt; nullableProjectionsMap = new HashMap&lt;&gt;();</span>
<span class="line-removed">1017 </span>
<span class="line-removed">1018     public ClassSymbol projectedNullableType(ClassSymbol c) {</span>
<span class="line-removed">1019         if (!c.isValue() || !c.type.hasTag(CLASS))</span>
<span class="line-removed">1020             return null;</span>
<span class="line-removed">1021         ClassSymbol lox = nullableProjectionsMap.get(c);</span>
<span class="line-removed">1022         if (lox != null)</span>
<span class="line-removed">1023             return lox;</span>
<span class="line-removed">1024 </span>
<span class="line-removed">1025         ClassType ct = (ClassType) c.type;</span>
<span class="line-removed">1026         ClassType loxType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-removed">1027         loxType.allparams_field = ct.allparams_field;</span>
<span class="line-removed">1028         loxType.supertype_field = ct.supertype_field;</span>
<span class="line-removed">1029         loxType.interfaces_field = List.nil();</span>
<span class="line-removed">1030         for (Type t :ct.interfaces_field) {</span>
<span class="line-removed">1031             if (t.tsym == syms.inlineObjectType.tsym) {</span>
<span class="line-removed">1032                 loxType.interfaces_field  = loxType.interfaces_field.append(syms.identityObjectType);</span>
<span class="line-removed">1033             } else {</span>
<span class="line-removed">1034                 loxType.interfaces_field  = loxType.interfaces_field.append(t);</span>
<span class="line-removed">1035             }</span>
<span class="line-removed">1036         }</span>
<span class="line-removed">1037         loxType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-removed">1038         lox = new ClassSymbol((c.flags() &amp; ~VALUE), c.name, loxType, c.owner) {</span>
<span class="line-removed">1039             @Override</span>
<span class="line-removed">1040             public boolean isProjectedNullable() {</span>
<span class="line-removed">1041                 return true;</span>
<span class="line-removed">1042             }</span>
<span class="line-removed">1043 </span>
<span class="line-removed">1044             @Override</span>
<span class="line-removed">1045             public ClassSymbol nullFreeTypeSymbol() {</span>
<span class="line-removed">1046                 return c;</span>
<span class="line-removed">1047             }</span>
<span class="line-removed">1048         };</span>
<span class="line-removed">1049         lox.members_field = c.members();</span>
<span class="line-removed">1050         loxType.tsym = lox;</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052         nullableProjectionsMap.put(c, lox);</span>
<span class="line-removed">1053         return lox;</span>
<span class="line-removed">1054     }</span>
<span class="line-removed">1055 </span>
1056     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1057     /**
1058      * Is t an unchecked subtype of s?
1059      */
1060     public boolean isSubtypeUnchecked(Type t, Type s) {
1061         return isSubtypeUnchecked(t, s, noWarnings);
1062     }
1063     /**
1064      * Is t an unchecked subtype of s?
1065      */
1066     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1067         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1068         if (result) {
1069             checkUnsafeVarargsConversion(t, s, warn);
1070         }
1071         return result;
1072     }
1073     //where
1074         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1075             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1076                 if (((ArrayType)t).elemtype.isPrimitive()) {
1077                     return isSameType(elemtype(t), elemtype(s));
1078                 } else {
<span class="line-modified">1079                     Type et = elemtype(t);</span>
1080                     Type es = elemtype(s);






1081                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1082                         return false;
<span class="line-removed">1083                     if (nonCovariantValueArrays) {</span>
<span class="line-removed">1084                         if (isValue(et) || isValue(es)) {</span>
<span class="line-removed">1085                             return isSameType(erasure(et), erasure(es));</span>
<span class="line-removed">1086                         }</span>
<span class="line-removed">1087                     }</span>
1088                     return true;
1089                 }
1090             } else if (isSubtype(t, s, capture)) {
1091                 return true;
1092             } else if (t.hasTag(TYPEVAR)) {
1093                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1094             } else if (!s.isRaw()) {
1095                 Type t2 = asSuper(t, s.tsym);
1096                 if (t2 != null &amp;&amp; t2.isRaw()) {
1097                     if (isReifiable(s)) {
1098                         warn.silentWarn(LintCategory.UNCHECKED);
1099                     } else {
1100                         warn.warn(LintCategory.UNCHECKED);
1101                     }
1102                     return true;
1103                 }
1104             }
1105             return false;
1106         }
1107 
</pre>
<hr />
<pre>
1243             }
1244 
1245             @Override
1246             public Boolean visitClassType(ClassType t, Type s) {
1247                 Type sup = asSuper(t, s.tsym);
1248                 if (sup == null) return false;
1249                 // If t is an intersection, sup might not be a class type
1250                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1251                 return sup.tsym == s.tsym
1252                      // Check type variable containment
1253                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1254                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1255                                           s.getEnclosingType());
1256             }
1257 
1258             @Override
1259             public Boolean visitArrayType(ArrayType t, Type s) {
1260                 if (s.hasTag(ARRAY)) {
1261                     if (t.elemtype.isPrimitive())
1262                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1263                     else</span>
<span class="line-modified">1264                         return isSubtypeNoCapture(t.elemtype, elemtype(s));</span>









1265                 }
1266 
1267                 if (s.hasTag(CLASS)) {
1268                     Name sname = s.tsym.getQualifiedName();
1269                     return sname == names.java_lang_Object
1270                         || sname == names.java_lang_Cloneable
1271                         || sname == names.java_io_Serializable
1272                         || (injectTopInterfaceTypes &amp;&amp; sname == names.java_lang_IdentityObject);
1273                 }
1274 
1275                 return false;
1276             }
1277 
1278             @Override
1279             public Boolean visitUndetVar(UndetVar t, Type s) {
1280                 //todo: test against origin needed? or replace with substitution?
1281                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1282                     return true;
1283                 } else if (s.hasTag(BOT)) {
1284                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
</pre>
<hr />
<pre>
1630 //            void debugContainsType(WildcardType t, Type s) {
1631 //                System.err.println();
1632 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1633 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1634 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1635 //                                  t.isSuperBound()
1636 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1637 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1638 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1639 //                                  t.isExtendsBound()
1640 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1641 //                System.err.println();
1642 //            }
1643 
1644             @Override
1645             public Boolean visitWildcardType(WildcardType t, Type s) {
1646                 if (s.isPartial())
1647                     return containedBy(s, t);
1648                 else {
1649 //                    debugContainsType(t, s);









1650                     return isSameWildcard(t, s)
1651                         || isCaptureOf(s, t)
1652                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1653                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1654                 }
1655             }
1656 
1657             @Override
1658             public Boolean visitUndetVar(UndetVar t, Type s) {
1659                 if (!s.hasTag(WILDCARD)) {
1660                     return isSameType(t, s);
1661                 } else {
1662                     return false;
1663                 }
1664             }
1665 
1666             @Override
1667             public Boolean visitErrorType(ErrorType t, Type s) {
1668                 return true;
1669             }
</pre>
<hr />
<pre>
1754             public Boolean visitClassType(ClassType t, Type s) {
1755                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1756                     return true;
1757 
1758                 if (s.hasTag(TYPEVAR)) {
1759                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1760                         warnStack.head.warn(LintCategory.UNCHECKED);
1761                         return true;
1762                     } else {
1763                         return false;
1764                     }
1765                 }
1766 
1767                 if (t.isCompound() || s.isCompound()) {
1768                     return !t.isCompound() ?
1769                             visitCompoundType((ClassType)s, t, true) :
1770                             visitCompoundType(t, s, false);
1771                 }
1772 
1773                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {








1774                     boolean upcast;
1775                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1776                         || isSubtype(erasure(s), erasure(t))) {
1777                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1778                             if (!isReifiable(s))
1779                                 warnStack.head.warn(LintCategory.UNCHECKED);
1780                             return true;
1781                         } else if (s.isRaw()) {
1782                             return true;
1783                         } else if (t.isRaw()) {
1784                             if (!isUnbounded(s))
1785                                 warnStack.head.warn(LintCategory.UNCHECKED);
1786                             return true;
1787                         }
1788                         // Assume |a| &lt;: |b|
1789                         final Type a = upcast ? t : s;
1790                         final Type b = upcast ? s : t;
1791                         final boolean HIGH = true;
1792                         final boolean LOW = false;
1793                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1863                 case ERROR:
1864                 case BOT:
1865                     return true;
1866                 case TYPEVAR:
1867                     if (isCastable(s, t, noWarnings)) {
1868                         warnStack.head.warn(LintCategory.UNCHECKED);
1869                         return true;
1870                     } else {
1871                         return false;
1872                     }
1873                 case CLASS:
1874                     return isSubtype(t, s);
1875                 case ARRAY:
1876                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1877                         return elemtype(t).hasTag(elemtype(s).getTag());
1878                     } else {
1879                         Type et = elemtype(t);
1880                         Type es = elemtype(s);
1881                         if (!visit(et, es))
1882                             return false;
<span class="line-removed">1883                         if (nonCovariantValueArrays) {</span>
<span class="line-removed">1884                             if (isValue(et) || isValue(es)) {</span>
<span class="line-removed">1885                                 return isSameType(erasure(et), erasure(es));</span>
<span class="line-removed">1886                             }</span>
<span class="line-removed">1887                         }</span>
1888                         return true;
1889                     }
1890                 default:
1891                     return false;
1892                 }
1893             }
1894 
1895             @Override
1896             public Boolean visitTypeVar(TypeVar t, Type s) {
1897                 switch (s.getTag()) {
1898                 case ERROR:
1899                 case BOT:
1900                     return true;
1901                 case TYPEVAR:
1902                     if (isSubtype(t, s)) {
1903                         return true;
1904                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1905                         warnStack.head.warn(LintCategory.UNCHECKED);
1906                         return true;
1907                     } else {
</pre>
<hr />
<pre>
2169      * given symbol.  If none exists, return null.
2170      *
2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2173      * this method could yield surprising answers when invoked on arrays. For example when
2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2175      *
2176      * @param t a type
2177      * @param sym a symbol
2178      */
2179     public Type asSuper(Type t, Symbol sym) {
2180         /* Some examples:
2181          *
2182          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2183          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2184          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2185          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2186          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2187          */
2188         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2189             return syms.objectType;</span>

2190         }
2191         return asSuper.visit(t, sym);
2192     }
2193     // where
2194         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2195 
2196             public Type visitType(Type t, Symbol sym) {
2197                 return null;
2198             }
2199 
2200             @Override
2201             public Type visitClassType(ClassType t, Symbol sym) {
2202                 if (t.tsym == sym)
2203                     return t;
2204 
<span class="line-modified">2205                 /* For inline types, the wired in super type is j.l.O.</span>
<span class="line-modified">2206                    So we need a special check for V &lt;: V?</span>
<span class="line-modified">2207                 */</span>
<span class="line-removed">2208                 if (t.tsym == sym.nullFreeTypeSymbol()) {</span>
<span class="line-removed">2209                     return new ClassType(t.getEnclosingType(), t.getTypeArguments(), (TypeSymbol)sym, t.getMetadata());</span>
<span class="line-removed">2210                 }</span>
2211 
2212                 Type st = supertype(t);
2213                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2214                     Type x = asSuper(st, sym);
2215                     if (x != null)
2216                         return x;
2217                 }
2218                 if ((sym.flags() &amp; INTERFACE) != 0) {
2219                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2220                         if (!l.head.hasTag(ERROR)) {
2221                             Type x = asSuper(l.head, sym);
2222                             if (x != null)
2223                                 return x;
2224                         }
2225                     }
2226                 }
2227                 return null;
2228             }
2229 
2230             @Override
</pre>
<hr />
<pre>
2295         case ARRAY:
2296             return isSubtype(t, sym.type) ? sym.type : null;
2297         case TYPEVAR:
2298             return asSuper(t, sym);
2299         case ERROR:
2300             return t;
2301         default:
2302             return null;
2303         }
2304     }
2305     // &lt;/editor-fold&gt;
2306 
2307     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2308     /**
2309      * The type of given symbol, seen as a member of t.
2310      *
2311      * @param t a type
2312      * @param sym a symbol
2313      */
2314     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2315         return (sym.flags() &amp; STATIC) != 0</span>
<span class="line-modified">2316             ? sym.type</span>
<span class="line-modified">2317             : memberType.visit(t, sym);</span>












2318         }
2319     // where
2320         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2321 
2322             public Type visitType(Type t, Symbol sym) {
2323                 return sym.type;
2324             }
2325 
2326             @Override
2327             public Type visitWildcardType(WildcardType t, Symbol sym) {
2328                 return memberType(wildUpperBound(t), sym);
2329             }
2330 
2331             @Override
2332             public Type visitClassType(ClassType t, Symbol sym) {
2333                 Symbol owner = sym.owner;
2334                 long flags = sym.flags();
2335                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2336                     Type base = asOuterSuper(t, owner);
2337                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
</td>
<td>
<hr />
<pre>
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;

  98     final boolean injectTopInterfaceTypes;
  99     final Check chk;
 100     final Enter enter;
 101     JCDiagnostic.Factory diags;
 102     List&lt;Warner&gt; warnStack = List.nil();
 103     final Name capturedName;
 104 
 105     public final Warner noWarnings;
 106 
 107     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 108     public static Types instance(Context context) {
 109         Types instance = context.get(typesKey);
 110         if (instance == null)
 111             instance = new Types(context);
 112         return instance;
 113     }
 114 
 115     protected Types(Context context) {
 116         context.put(typesKey, this);
 117         syms = Symtab.instance(context);
 118         names = Names.instance(context);
 119         Source source = Source.instance(context);
 120         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 121         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 122         chk = Check.instance(context);
 123         enter = Enter.instance(context);
 124         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 125         messages = JavacMessages.instance(context);
 126         diags = JCDiagnostic.Factory.instance(context);
 127         noWarnings = new Warner(null);
 128         Options options = Options.instance(context);
 129         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);

 130         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
 131                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
 132                 Target.instance(context).hasTopInterfaces();
 133     }
 134     // &lt;/editor-fold&gt;
 135 
 136     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 137     /**
 138      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 139      * @param t a type argument, either a wildcard or a type
 140      */
 141     public Type wildUpperBound(Type t) {
 142         if (t.hasTag(WILDCARD)) {
 143             WildcardType w = (WildcardType) t;
 144             if (w.isSuperBound())
 145                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 146             else
 147                 return wildUpperBound(w.type);
 148         }
 149         else return t;
</pre>
<hr />
<pre>
 593                 return res;
 594             }
 595 
 596             @Override
 597             public Type visitErrorType(ErrorType t, Symbol sym) {
 598                 return t;
 599             }
 600         };
 601     // &lt;/editor-fold&gt;
 602 
 603     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 604     /**
 605      * Is t a subtype of or convertible via boxing/unboxing
 606      * conversion to s?
 607      */
 608     public boolean isConvertible(Type t, Type s, Warner warn) {
 609         if (t.hasTag(ERROR)) {
 610             return true;
 611         }
 612 
<span class="line-added"> 613         boolean tValue = t.isValue();</span>
<span class="line-added"> 614         boolean sValue = s.isValue();</span>
<span class="line-added"> 615         if (tValue != sValue) {</span>
<span class="line-added"> 616             return tValue ?</span>
<span class="line-added"> 617                     isSubtype(t.referenceProjection(), s) :</span>
<span class="line-added"> 618                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());</span>
<span class="line-added"> 619         }</span>
<span class="line-added"> 620 </span>
 621         boolean tPrimitive = t.isPrimitive();
 622         boolean sPrimitive = s.isPrimitive();
 623         if (tPrimitive == sPrimitive) {
 624             return isSubtypeUnchecked(t, s, warn);
 625         }
 626         boolean tUndet = t.hasTag(UNDETVAR);
 627         boolean sUndet = s.hasTag(UNDETVAR);
 628 
 629         if (tUndet || sUndet) {
 630             return tUndet ?
 631                     isSubtype(t, boxedTypeOrType(s)) :
 632                     isSubtype(boxedTypeOrType(t), s);
 633         }
 634 
 635         return tPrimitive
 636             ? isSubtype(boxedClass(t).type, s)
 637             : isSubtype(unboxedType(t), s);
 638     }
 639 
 640     /**
</pre>
<hr />
<pre>
1002            this.origin = origin;
1003        }
1004 
1005        @Override
1006        public boolean accepts(Symbol sym) {
1007            return sym.kind == MTH &amp;&amp;
1008                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1009                    !overridesObjectMethod(origin, sym) &amp;&amp;
1010                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1011        }
1012     }
1013 
1014     public boolean isValue(Type t) {
1015         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1016     }
1017 
1018     public boolean isValueBased(Type t) {
1019         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1020     }
1021 








































1022     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1023     /**
1024      * Is t an unchecked subtype of s?
1025      */
1026     public boolean isSubtypeUnchecked(Type t, Type s) {
1027         return isSubtypeUnchecked(t, s, noWarnings);
1028     }
1029     /**
1030      * Is t an unchecked subtype of s?
1031      */
1032     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1033         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1034         if (result) {
1035             checkUnsafeVarargsConversion(t, s, warn);
1036         }
1037         return result;
1038     }
1039     //where
1040         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1041             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1042                 if (((ArrayType)t).elemtype.isPrimitive()) {
1043                     return isSameType(elemtype(t), elemtype(s));
1044                 } else {
<span class="line-modified">1045                     // if T.ref &lt;: S, then T[] &lt;: S[]</span>
1046                     Type es = elemtype(s);
<span class="line-added">1047                     Type et = elemtype(t);</span>
<span class="line-added">1048                     if (isValue(et)) {</span>
<span class="line-added">1049                         et = et.referenceProjection();</span>
<span class="line-added">1050                         if (isValue(es))</span>
<span class="line-added">1051                             es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1052                     }</span>
1053                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1054                         return false;





1055                     return true;
1056                 }
1057             } else if (isSubtype(t, s, capture)) {
1058                 return true;
1059             } else if (t.hasTag(TYPEVAR)) {
1060                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1061             } else if (!s.isRaw()) {
1062                 Type t2 = asSuper(t, s.tsym);
1063                 if (t2 != null &amp;&amp; t2.isRaw()) {
1064                     if (isReifiable(s)) {
1065                         warn.silentWarn(LintCategory.UNCHECKED);
1066                     } else {
1067                         warn.warn(LintCategory.UNCHECKED);
1068                     }
1069                     return true;
1070                 }
1071             }
1072             return false;
1073         }
1074 
</pre>
<hr />
<pre>
1210             }
1211 
1212             @Override
1213             public Boolean visitClassType(ClassType t, Type s) {
1214                 Type sup = asSuper(t, s.tsym);
1215                 if (sup == null) return false;
1216                 // If t is an intersection, sup might not be a class type
1217                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1218                 return sup.tsym == s.tsym
1219                      // Check type variable containment
1220                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1221                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1222                                           s.getEnclosingType());
1223             }
1224 
1225             @Override
1226             public Boolean visitArrayType(ArrayType t, Type s) {
1227                 if (s.hasTag(ARRAY)) {
1228                     if (t.elemtype.isPrimitive())
1229                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1230                     else {</span>
<span class="line-modified">1231                         // if T.ref &lt;: S, then T[] &lt;: S[]</span>
<span class="line-added">1232                         Type es = elemtype(s);</span>
<span class="line-added">1233                         Type et = elemtype(t);</span>
<span class="line-added">1234                         if (isValue(et)) {</span>
<span class="line-added">1235                             et = et.referenceProjection();</span>
<span class="line-added">1236                             if (isValue(es))</span>
<span class="line-added">1237                                 es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1238                         }</span>
<span class="line-added">1239                         return isSubtypeNoCapture(et, es);</span>
<span class="line-added">1240                     }</span>
1241                 }
1242 
1243                 if (s.hasTag(CLASS)) {
1244                     Name sname = s.tsym.getQualifiedName();
1245                     return sname == names.java_lang_Object
1246                         || sname == names.java_lang_Cloneable
1247                         || sname == names.java_io_Serializable
1248                         || (injectTopInterfaceTypes &amp;&amp; sname == names.java_lang_IdentityObject);
1249                 }
1250 
1251                 return false;
1252             }
1253 
1254             @Override
1255             public Boolean visitUndetVar(UndetVar t, Type s) {
1256                 //todo: test against origin needed? or replace with substitution?
1257                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1258                     return true;
1259                 } else if (s.hasTag(BOT)) {
1260                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
</pre>
<hr />
<pre>
1606 //            void debugContainsType(WildcardType t, Type s) {
1607 //                System.err.println();
1608 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1609 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1610 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1611 //                                  t.isSuperBound()
1612 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1613 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1614 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1615 //                                  t.isExtendsBound()
1616 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1617 //                System.err.println();
1618 //            }
1619 
1620             @Override
1621             public Boolean visitWildcardType(WildcardType t, Type s) {
1622                 if (s.isPartial())
1623                     return containedBy(s, t);
1624                 else {
1625 //                    debugContainsType(t, s);
<span class="line-added">1626 </span>
<span class="line-added">1627                     // -----------------------------------  Unspecified behavior ----------------</span>
<span class="line-added">1628 </span>
<span class="line-added">1629                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?</span>
<span class="line-added">1630                        It seems widening must be applied here to answer yes to compile some common code</span>
<span class="line-added">1631                        patterns.</span>
<span class="line-added">1632                     */</span>
<span class="line-added">1633 </span>
<span class="line-added">1634                     // ---------------------------------------------------------------------------</span>
1635                     return isSameWildcard(t, s)
1636                         || isCaptureOf(s, t)
1637                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1638                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1639                 }
1640             }
1641 
1642             @Override
1643             public Boolean visitUndetVar(UndetVar t, Type s) {
1644                 if (!s.hasTag(WILDCARD)) {
1645                     return isSameType(t, s);
1646                 } else {
1647                     return false;
1648                 }
1649             }
1650 
1651             @Override
1652             public Boolean visitErrorType(ErrorType t, Type s) {
1653                 return true;
1654             }
</pre>
<hr />
<pre>
1739             public Boolean visitClassType(ClassType t, Type s) {
1740                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1741                     return true;
1742 
1743                 if (s.hasTag(TYPEVAR)) {
1744                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1745                         warnStack.head.warn(LintCategory.UNCHECKED);
1746                         return true;
1747                     } else {
1748                         return false;
1749                     }
1750                 }
1751 
1752                 if (t.isCompound() || s.isCompound()) {
1753                     return !t.isCompound() ?
1754                             visitCompoundType((ClassType)s, t, true) :
1755                             visitCompoundType(t, s, false);
1756                 }
1757 
1758                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
<span class="line-added">1759                     if (isValue(t)) {</span>
<span class="line-added">1760                         // (s) Value ? == (s) Value.ref</span>
<span class="line-added">1761                         t = t.referenceProjection();</span>
<span class="line-added">1762                     }</span>
<span class="line-added">1763                     if (isValue(s)) {</span>
<span class="line-added">1764                         // (Value) t ? == (Value.ref) t</span>
<span class="line-added">1765                         s = s.referenceProjection();</span>
<span class="line-added">1766                     }</span>
1767                     boolean upcast;
1768                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1769                         || isSubtype(erasure(s), erasure(t))) {
1770                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1771                             if (!isReifiable(s))
1772                                 warnStack.head.warn(LintCategory.UNCHECKED);
1773                             return true;
1774                         } else if (s.isRaw()) {
1775                             return true;
1776                         } else if (t.isRaw()) {
1777                             if (!isUnbounded(s))
1778                                 warnStack.head.warn(LintCategory.UNCHECKED);
1779                             return true;
1780                         }
1781                         // Assume |a| &lt;: |b|
1782                         final Type a = upcast ? t : s;
1783                         final Type b = upcast ? s : t;
1784                         final boolean HIGH = true;
1785                         final boolean LOW = false;
1786                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1856                 case ERROR:
1857                 case BOT:
1858                     return true;
1859                 case TYPEVAR:
1860                     if (isCastable(s, t, noWarnings)) {
1861                         warnStack.head.warn(LintCategory.UNCHECKED);
1862                         return true;
1863                     } else {
1864                         return false;
1865                     }
1866                 case CLASS:
1867                     return isSubtype(t, s);
1868                 case ARRAY:
1869                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1870                         return elemtype(t).hasTag(elemtype(s).getTag());
1871                     } else {
1872                         Type et = elemtype(t);
1873                         Type es = elemtype(s);
1874                         if (!visit(et, es))
1875                             return false;





1876                         return true;
1877                     }
1878                 default:
1879                     return false;
1880                 }
1881             }
1882 
1883             @Override
1884             public Boolean visitTypeVar(TypeVar t, Type s) {
1885                 switch (s.getTag()) {
1886                 case ERROR:
1887                 case BOT:
1888                     return true;
1889                 case TYPEVAR:
1890                     if (isSubtype(t, s)) {
1891                         return true;
1892                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1893                         warnStack.head.warn(LintCategory.UNCHECKED);
1894                         return true;
1895                     } else {
</pre>
<hr />
<pre>
2157      * given symbol.  If none exists, return null.
2158      *
2159      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2160      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2161      * this method could yield surprising answers when invoked on arrays. For example when
2162      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2163      *
2164      * @param t a type
2165      * @param sym a symbol
2166      */
2167     public Type asSuper(Type t, Symbol sym) {
2168         /* Some examples:
2169          *
2170          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2171          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2172          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2173          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2174          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2175          */
2176         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2177             if (!isValue(t))</span>
<span class="line-added">2178                 return syms.objectType;</span>
2179         }
2180         return asSuper.visit(t, sym);
2181     }
2182     // where
2183         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2184 
2185             public Type visitType(Type t, Symbol sym) {
2186                 return null;
2187             }
2188 
2189             @Override
2190             public Type visitClassType(ClassType t, Symbol sym) {
2191                 if (t.tsym == sym)
2192                     return t;
2193 
<span class="line-modified">2194                // No man may be an island, but the bell tolls for a value.</span>
<span class="line-modified">2195                 if (isValue(t))</span>
<span class="line-modified">2196                     return null;</span>



2197 
2198                 Type st = supertype(t);
2199                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2200                     Type x = asSuper(st, sym);
2201                     if (x != null)
2202                         return x;
2203                 }
2204                 if ((sym.flags() &amp; INTERFACE) != 0) {
2205                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2206                         if (!l.head.hasTag(ERROR)) {
2207                             Type x = asSuper(l.head, sym);
2208                             if (x != null)
2209                                 return x;
2210                         }
2211                     }
2212                 }
2213                 return null;
2214             }
2215 
2216             @Override
</pre>
<hr />
<pre>
2281         case ARRAY:
2282             return isSubtype(t, sym.type) ? sym.type : null;
2283         case TYPEVAR:
2284             return asSuper(t, sym);
2285         case ERROR:
2286             return t;
2287         default:
2288             return null;
2289         }
2290     }
2291     // &lt;/editor-fold&gt;
2292 
2293     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2294     /**
2295      * The type of given symbol, seen as a member of t.
2296      *
2297      * @param t a type
2298      * @param sym a symbol
2299      */
2300     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2301 </span>
<span class="line-modified">2302         if ((sym.flags() &amp; STATIC) != 0)</span>
<span class="line-modified">2303             return sym.type;</span>
<span class="line-added">2304 </span>
<span class="line-added">2305         /* If any inline types are involved, switch over to the reference universe,</span>
<span class="line-added">2306            where the hierarchy is navigable. V and V.ref have identical membership</span>
<span class="line-added">2307            with no bridging needs.</span>
<span class="line-added">2308         */</span>
<span class="line-added">2309         if (t.isValue())</span>
<span class="line-added">2310             t = t.referenceProjection();</span>
<span class="line-added">2311 </span>
<span class="line-added">2312         if (sym.owner.isValue())</span>
<span class="line-added">2313             sym = sym.referenceProjection();</span>
<span class="line-added">2314 </span>
<span class="line-added">2315         return memberType.visit(t, sym);</span>
2316         }
2317     // where
2318         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2319 
2320             public Type visitType(Type t, Symbol sym) {
2321                 return sym.type;
2322             }
2323 
2324             @Override
2325             public Type visitWildcardType(WildcardType t, Symbol sym) {
2326                 return memberType(wildUpperBound(t), sym);
2327             }
2328 
2329             @Override
2330             public Type visitClassType(ClassType t, Symbol sym) {
2331                 Symbol owner = sym.owner;
2332                 long flags = sym.flags();
2333                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2334                     Type base = asOuterSuper(t, owner);
2335                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
</td>
</tr>
</table>
<center><a href="Type.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
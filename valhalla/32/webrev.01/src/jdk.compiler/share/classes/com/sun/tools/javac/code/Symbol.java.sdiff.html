<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
<span class="line-removed"> 302     public boolean isProjectedNullable() {</span>
<span class="line-removed"> 303         return false;</span>
<span class="line-removed"> 304     }</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     public ClassSymbol nullFreeTypeSymbol() {</span>
<span class="line-removed"> 307         return this.type.hasTag(CLASS) &amp;&amp; ((this.flags() &amp; VALUE) != 0) ? (ClassSymbol) this : null;</span>
<span class="line-removed"> 308     }</span>
<span class="line-removed"> 309 </span>
 310     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 311         return v.visitSymbol(this, p);
 312     }
 313 
 314     /** The Java source which this symbol represents.
 315      *  A description of this symbol; overrides Object.
 316      */
 317     public String toString() {
 318         return name.toString();
 319     }
 320 
 321     /** A Java source description of the location of this symbol; used for
 322      *  error reporting.
 323      *
 324      * @return null if the symbol is a package or a toplevel class defined in
 325      * the default package; otherwise, the owner symbol is returned
 326      */
 327     public Symbol location() {
 328         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 329                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
</pre>
<hr />
<pre>
 409             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 410              name != name.table.names._this;
 411     }
 412 
 413     public boolean isInterface() {
 414         return (flags() &amp; INTERFACE) != 0;
 415     }
 416 
 417     public boolean isAbstract() {
 418         return (flags_field &amp; ABSTRACT) != 0;
 419     }
 420 
 421     public boolean isPrivate() {
 422         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 423     }
 424 
 425     public boolean isValue() {
 426         return (flags() &amp; VALUE) != 0;
 427     }
 428 























 429     public boolean isPublic() {
 430         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 431     }
 432 
 433     public boolean isEnum() {
 434         return (flags() &amp; ENUM) != 0;
 435     }
 436 
 437     public boolean isFinal() {
 438         return (flags_field &amp; FINAL) != 0;
 439     }
 440 
 441    /** Is this symbol declared (directly or indirectly) local
 442      *  to a method or variable initializer?
 443      *  Also includes fields of inner classes which are in
 444      *  turn local to a method or variable initializer.
 445      */
 446     public boolean isLocal() {
 447         return
 448             (owner.kind.matches(KindSelector.VAL_MTH) ||
</pre>
<hr />
<pre>
 511     public boolean hasOuterInstance() {
 512         return
 513             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 514     }
 515 
 516     /** The closest enclosing class of this symbol&#39;s declaration.
 517      *  Warning: this (misnamed) method returns the receiver itself
 518      *  when the receiver is a class (as opposed to its enclosing
 519      *  class as one may be misled to believe.)
 520      */
 521     public ClassSymbol enclClass() {
 522         Symbol c = this;
 523         while (c != null &amp;&amp;
 524                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 525             c = c.owner;
 526         }
 527         return (ClassSymbol)c;
 528     }
 529 
 530     /** The outermost class which indirectly owns this symbol.


 531      */
 532     public ClassSymbol outermostClass() {
 533         Symbol sym = this;
 534         Symbol prev = null;
 535         while (sym.kind != PCK) {
 536             prev = sym;
 537             sym = sym.owner;
 538         }
<span class="line-modified"> 539         return (ClassSymbol) prev;</span>
 540     }
 541 
 542     /** The package which indirectly owns this symbol.
 543      */
 544     public PackageSymbol packge() {
 545         Symbol sym = this;
 546         while (sym.kind != PCK) {
 547             sym = sym.owner;
 548         }
 549         return (PackageSymbol) sym;
 550     }
 551 
 552     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 553      */
 554     public boolean isSubClass(Symbol base, Types types) {
 555         throw new AssertionError(&quot;isSubClass &quot; + this);
 556     }
 557 
 558     /** Fully check membership: hierarchy, protection, and hiding.
 559      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1282         public JavaFileObject sourcefile;
1283 
1284         /** the classfile from where to load this class
1285          *  this will have extension .class or .java
1286          */
1287         public JavaFileObject classfile;
1288 
1289         /** the list of translated local classes (used for generating
1290          * InnerClasses attribute)
1291          */
1292         public List&lt;ClassSymbol&gt; trans_local;
1293 
1294         /** the annotation metadata attached to this class */
1295         private AnnotationTypeMetadata annotationTypeMetadata;
1296 
1297         /* the list of any of record components, only non empty if the class is a record
1298          * and it has at least one record component
1299          */
1300         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1301 






1302         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1303             super(TYP, flags, name, type, owner);
1304             this.members_field = null;
1305             this.fullname = formFullName(name, owner);
1306             this.flatname = formFlatName(name, owner);
1307             this.sourcefile = null;
1308             this.classfile = null;
1309             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1310         }
1311 
1312         public ClassSymbol(long flags, Name name, Symbol owner) {
1313             this(
1314                 flags,
1315                 name,
1316                 new ClassType(Type.noType, null, null),
1317                 owner);
1318             this.type.tsym = this;
1319         }
1320 
1321         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1342 
1343         @Override
1344         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1345             complete();
1346             return super.getRawTypeAttributes();
1347         }
1348 
1349         public Type erasure(Types types) {
1350             if (erasure_field == null)
1351                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1352                                               List.nil(), this,
1353                                               type.getMetadata());
1354             return erasure_field;
1355         }
1356 
1357         public String className() {
1358             if (name.isEmpty())
1359                 return
1360                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1361 
<span class="line-modified">1362                 String s = fullname.toString();</span>
<span class="line-removed">1363                 return isProjectedNullable() ? s + &#39;?&#39; : s;</span>
1364         }
1365 
1366         @DefinedBy(Api.LANGUAGE_MODEL)
1367         public Name getQualifiedName() {
1368             return fullname;
1369         }
1370 
1371         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1372         public List&lt;Symbol&gt; getEnclosedElements() {
1373             List&lt;Symbol&gt; result = super.getEnclosedElements();
1374             if (!recordComponents.isEmpty()) {
1375                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1376                 for (RecordComponent rc : reversed) {
1377                     result = result.prepend(rc);
1378                 }
1379             }
1380             return result;
1381         }
1382 
1383         public Name flatName() {
</pre>
<hr />
<pre>
1596 
1597         @Override
1598         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1599             return annotationTypeMetadata;
1600         }
1601 
1602         @Override
1603         public boolean isAnnotationType() {
1604             return (flags_field &amp; Flags.ANNOTATION) != 0;
1605         }
1606 
1607         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1608             Assert.checkNonNull(a);
1609             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1610             this.annotationTypeMetadata = a;
1611         }
1612 
1613         public boolean isRecord() {
1614             return (flags_field &amp; RECORD) != 0;
1615         }























































1616     }
1617 
1618 
1619     /** A class for variable symbols
1620      */
1621     public static class VarSymbol extends Symbol implements VariableElement {
1622 
1623         /** The variable&#39;s declaration position.
1624          */
1625         public int pos = Position.NOPOS;
1626 
1627         /** The variable&#39;s address. Used for different purposes during
1628          *  flow analysis, translation and code generation.
1629          *  Flow analysis:
1630          *    If this is a blank final or local variable, its sequence number.
1631          *  Translation:
1632          *    If this is a private field, its access number.
1633          *  Code generation:
1634          *    If this is a local variable, its logical slot number.
1635          */
1636         public int adr = -1;
1637 





1638         /** Construct a variable symbol, given its flags, name, type and owner.
1639          */
1640         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1641             super(VAR, flags, name, type, owner);
1642         }
1643 
1644         @Override
1645         public int poolTag() {
1646             return ClassFile.CONSTANT_Fieldref;
1647         }
1648 
1649         public MethodHandleSymbol asMethodHandle(boolean getter) {
1650             return new MethodHandleSymbol(this, getter);
1651         }
1652 
1653         /** Clone this symbol with new owner.
1654          */
1655         public VarSymbol clone(Symbol newOwner) {
1656             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1657                 @Override
1658                 public Symbol baseSymbol() {
1659                     return VarSymbol.this;
1660                 }
1661 
1662                 @Override
1663                 public Object poolKey(Types types) {
1664                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1665                 }
1666             };
1667             v.pos = pos;
1668             v.adr = adr;
1669             v.data = data;

1670 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1671             return v;
1672         }
1673 
1674         public String toString() {
1675             return name.toString();
1676         }
1677 
1678         public Symbol asMemberOf(Type site, Types types) {
1679             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1680         }
1681 
1682         @DefinedBy(Api.LANGUAGE_MODEL)
1683         public ElementKind getKind() {
1684             long flags = flags();
1685             if ((flags &amp; PARAMETER) != 0) {
1686                 if (isExceptionParameter())
1687                     return ElementKind.EXCEPTION_PARAMETER;
1688                 else
1689                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1702             }
1703         }
1704 
1705         @DefinedBy(Api.LANGUAGE_MODEL)
1706         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1707             return v.visitVariable(this, p);
1708         }
1709 
1710         @DefinedBy(Api.LANGUAGE_MODEL)
1711         public Object getConstantValue() { // Mirror API
1712             return Constants.decode(getConstValue(), type);
1713         }
1714 
1715         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1716                                       final Attr attr,
1717                                       final JCVariableDecl variable)
1718         {
1719             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1720         }
1721 












1722         /**
1723          * The variable&#39;s constant value, if this is a constant.
1724          * Before the constant value is evaluated, it points to an
1725          * initializer environment.  If this is not a constant, it can
1726          * be used for other stuff.
1727          */
1728         private Object data;
1729 
1730         public boolean isExceptionParameter() {
1731             return data == ElementKind.EXCEPTION_PARAMETER;
1732         }
1733 
1734         public boolean isResourceVariable() {
1735             return data == ElementKind.RESOURCE_VARIABLE;
1736         }
1737 
1738         public Object getConstValue() {
1739             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1740             if (data == ElementKind.EXCEPTION_PARAMETER ||
1741                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1852     public static class MethodSymbol extends Symbol implements ExecutableElement {
1853 
1854         /** The code of the method. */
1855         public Code code = null;
1856 
1857         /** The extra (synthetic/mandated) parameters of the method. */
1858         public List&lt;VarSymbol&gt; extraParams = List.nil();
1859 
1860         /** The captured local variables in an anonymous class */
1861         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1862 
1863         /** The parameters of the method. */
1864         public List&lt;VarSymbol&gt; params = null;
1865 
1866         /** For an annotation type element, its default value if any.
1867          *  The value is null if none appeared in the method
1868          *  declaration.
1869          */
1870         public Attribute defaultValue = null;
1871 





1872         /** Construct a method symbol, given its flags, name, type and owner.
1873          */
1874         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1875             super(MTH, flags, name, type, owner);
1876             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1877         }
1878 
1879         /** Clone this symbol with new owner.
1880          */
1881         public MethodSymbol clone(Symbol newOwner) {
1882             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1883                 @Override
1884                 public Symbol baseSymbol() {
1885                     return MethodSymbol.this;
1886                 }
1887 
1888                 @Override
1889                 public Object poolKey(Types types) {
1890                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1891                 }
1892             };
1893             m.code = code;

1894             return m;
1895         }
1896 
1897         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1898         public Set&lt;Modifier&gt; getModifiers() {
1899             long flags = flags();
1900             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1901         }
1902 
1903         /** The Java source which this symbol represents.
1904          */
1905         public String toString() {
1906             if ((flags() &amp; BLOCK) != 0) {
1907                 return owner.name.toString();
1908             } else {
1909                 String s = (name == name.table.names.init)
1910                     ? owner.name.toString()
1911                     : name.toString();
1912                 if (type != null) {
1913                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2022             return overrides(_other, origin, types, checkResult, true);
2023         }
2024 
2025         /** Does this symbol override `other&#39; symbol, when both are seen as
2026          *  members of class `origin&#39;?  It is assumed that _other is a member
2027          *  of origin.
2028          *
2029          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2030          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2031          *  is false.
2032          *
2033          *  It is assumed that both symbols have the same name.  The static
2034          *  modifier is ignored for this test.
2035          *
2036          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2037          */
2038         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2039                                             boolean requireConcreteIfInherited) {
2040             if (isConstructor() || _other.kind != MTH) return false;
2041 










2042             if (this == _other) return true;
2043             MethodSymbol other = (MethodSymbol)_other;
2044 
2045             // check for a direct implementation
2046             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2047                 types.asSuper(owner.type, other.owner) != null) {
2048                 Type mt = types.memberType(owner.type, this);
2049                 Type ot = types.memberType(owner.type, other);
2050                 if (types.isSubSignature(mt, ot)) {
2051                     if (!checkResult)
2052                         return true;
2053                     if (types.returnTypeSubstitutable(mt, ot))
2054                         return true;
2055                 }
2056             }
2057 
2058             // check for an inherited implementation
2059             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2060                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2061                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2076             case Flags.PRIVATE:
2077                 return false;
2078             case Flags.PUBLIC:
2079                 return !this.owner.isInterface() ||
2080                         (flags_field &amp; STATIC) == 0;
2081             case Flags.PROTECTED:
2082                 return (origin.flags() &amp; INTERFACE) == 0;
2083             case 0:
2084                 // for package private: can only override in the same
2085                 // package
2086                 return
2087                     this.packge() == origin.packge() &amp;&amp;
2088                     (origin.flags() &amp; INTERFACE) == 0;
2089             default:
2090                 return false;
2091             }
2092         }
2093 
2094         @Override
2095         public boolean isInheritedIn(Symbol clazz, Types types) {









2096             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2097                 case PUBLIC:
2098                     return !this.owner.isInterface() ||
2099                             clazz == owner ||
2100                             (flags_field &amp; STATIC) == 0;
2101                 default:
2102                     return super.isInheritedIn(clazz, types);
2103             }
2104         }
2105 
2106         public boolean isLambdaMethod() {
2107             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2108         }
2109 












2110         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2111          *  lambda method
2112          */
2113         public MethodSymbol originalEnclosingMethod() {
2114             return this;
2115         }
2116 
2117         /** The implementation of this (abstract) symbol in class origin;
2118          *  null if none exists. Synthetic methods are not considered
2119          *  as possible implementations.
2120          */
2121         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2122             return implementation(origin, types, checkResult, implementation_filter);
2123         }
2124         // where
2125             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2126                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2127 
2128         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2129             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
</td>
<td>
<hr />
<pre>
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 








 302     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 303         return v.visitSymbol(this, p);
 304     }
 305 
 306     /** The Java source which this symbol represents.
 307      *  A description of this symbol; overrides Object.
 308      */
 309     public String toString() {
 310         return name.toString();
 311     }
 312 
 313     /** A Java source description of the location of this symbol; used for
 314      *  error reporting.
 315      *
 316      * @return null if the symbol is a package or a toplevel class defined in
 317      * the default package; otherwise, the owner symbol is returned
 318      */
 319     public Symbol location() {
 320         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 321                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
</pre>
<hr />
<pre>
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isValue() {
 418         return (flags() &amp; VALUE) != 0;
 419     }
 420 
<span class="line-added"> 421     /**</span>
<span class="line-added"> 422      * Is this a *derived* reference projection symbol ??</span>
<span class="line-added"> 423      */</span>
<span class="line-added"> 424     public boolean isReferenceProjection() {</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     /**</span>
<span class="line-added"> 429      * Return the value projection IFF `this&#39; happens to be derived reference projection, null</span>
<span class="line-added"> 430      * otherwise.</span>
<span class="line-added"> 431      */</span>
<span class="line-added"> 432     public Symbol valueProjection() {</span>
<span class="line-added"> 433         return null;</span>
<span class="line-added"> 434     }</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     /**</span>
<span class="line-added"> 437      * Return the reference projection IFF `this&#39; happens to be value projection, null</span>
<span class="line-added"> 438      * otherwise.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     public Symbol referenceProjection() {</span>
<span class="line-added"> 441         return null;</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443 </span>
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
 458      *  Also includes fields of inner classes which are in
 459      *  turn local to a method or variable initializer.
 460      */
 461     public boolean isLocal() {
 462         return
 463             (owner.kind.matches(KindSelector.VAL_MTH) ||
</pre>
<hr />
<pre>
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<span class="line-added"> 546      * `outermost&#39; being a lexical construct, should transcend</span>
<span class="line-added"> 547      *  projections</span>
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
<span class="line-modified"> 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);</span>
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
 567     }
 568 
 569     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 570      */
 571     public boolean isSubClass(Symbol base, Types types) {
 572         throw new AssertionError(&quot;isSubClass &quot; + this);
 573     }
 574 
 575     /** Fully check membership: hierarchy, protection, and hiding.
 576      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1299         public JavaFileObject sourcefile;
1300 
1301         /** the classfile from where to load this class
1302          *  this will have extension .class or .java
1303          */
1304         public JavaFileObject classfile;
1305 
1306         /** the list of translated local classes (used for generating
1307          * InnerClasses attribute)
1308          */
1309         public List&lt;ClassSymbol&gt; trans_local;
1310 
1311         /** the annotation metadata attached to this class */
1312         private AnnotationTypeMetadata annotationTypeMetadata;
1313 
1314         /* the list of any of record components, only non empty if the class is a record
1315          * and it has at least one record component
1316          */
1317         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1318 
<span class="line-added">1319         /* the `other&#39; projection: If `this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
<span class="line-added">1320            and vice versa.</span>
<span class="line-added">1321          */</span>
<span class="line-added">1322         public ClassSymbol projection;</span>
<span class="line-added">1323 </span>
<span class="line-added">1324 </span>
1325         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1326             super(TYP, flags, name, type, owner);
1327             this.members_field = null;
1328             this.fullname = formFullName(name, owner);
1329             this.flatname = formFlatName(name, owner);
1330             this.sourcefile = null;
1331             this.classfile = null;
1332             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1333         }
1334 
1335         public ClassSymbol(long flags, Name name, Symbol owner) {
1336             this(
1337                 flags,
1338                 name,
1339                 new ClassType(Type.noType, null, null),
1340                 owner);
1341             this.type.tsym = this;
1342         }
1343 
1344         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1365 
1366         @Override
1367         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1368             complete();
1369             return super.getRawTypeAttributes();
1370         }
1371 
1372         public Type erasure(Types types) {
1373             if (erasure_field == null)
1374                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1375                                               List.nil(), this,
1376                                               type.getMetadata());
1377             return erasure_field;
1378         }
1379 
1380         public String className() {
1381             if (name.isEmpty())
1382                 return
1383                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1384 
<span class="line-modified">1385                 return fullname.toString();</span>

1386         }
1387 
1388         @DefinedBy(Api.LANGUAGE_MODEL)
1389         public Name getQualifiedName() {
1390             return fullname;
1391         }
1392 
1393         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1394         public List&lt;Symbol&gt; getEnclosedElements() {
1395             List&lt;Symbol&gt; result = super.getEnclosedElements();
1396             if (!recordComponents.isEmpty()) {
1397                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1398                 for (RecordComponent rc : reversed) {
1399                     result = result.prepend(rc);
1400                 }
1401             }
1402             return result;
1403         }
1404 
1405         public Name flatName() {
</pre>
<hr />
<pre>
1618 
1619         @Override
1620         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1621             return annotationTypeMetadata;
1622         }
1623 
1624         @Override
1625         public boolean isAnnotationType() {
1626             return (flags_field &amp; Flags.ANNOTATION) != 0;
1627         }
1628 
1629         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1630             Assert.checkNonNull(a);
1631             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1632             this.annotationTypeMetadata = a;
1633         }
1634 
1635         public boolean isRecord() {
1636             return (flags_field &amp; RECORD) != 0;
1637         }
<span class="line-added">1638 </span>
<span class="line-added">1639         @Override</span>
<span class="line-added">1640         public boolean isReferenceProjection() {</span>
<span class="line-added">1641             return projection != null &amp;&amp; projection.isValue();</span>
<span class="line-added">1642         }</span>
<span class="line-added">1643 </span>
<span class="line-added">1644         @Override</span>
<span class="line-added">1645         public ClassSymbol valueProjection() {</span>
<span class="line-added">1646             return isReferenceProjection() ? projection : null;</span>
<span class="line-added">1647         }</span>
<span class="line-added">1648 </span>
<span class="line-added">1649         @Override</span>
<span class="line-added">1650         public ClassSymbol referenceProjection() {</span>
<span class="line-added">1651             if (!isValue() || projection != null)</span>
<span class="line-added">1652                 return projection;</span>
<span class="line-added">1653 </span>
<span class="line-added">1654             ClassType ct = (ClassType) this.type;</span>
<span class="line-added">1655             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-added">1656             projectedType.allparams_field = ct.allparams_field;</span>
<span class="line-added">1657             projectedType.supertype_field = ct.supertype_field;</span>
<span class="line-added">1658 </span>
<span class="line-added">1659             projectedType.interfaces_field = ct.interfaces_field;</span>
<span class="line-added">1660             projectedType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-added">1661             projectedType.projection = ct;</span>
<span class="line-added">1662             ct.projection = projectedType;</span>
<span class="line-added">1663 </span>
<span class="line-added">1664             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1665             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));</span>
<span class="line-added">1666 </span>
<span class="line-added">1667             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);</span>
<span class="line-added">1668             projection.members_field = WriteableScope.create(projection);</span>
<span class="line-added">1669             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) { // TODO: TYP?, CLINT?</span>
<span class="line-added">1670                 Symbol clone = null;</span>
<span class="line-added">1671                 if (s.kind == MTH) {</span>
<span class="line-added">1672                     MethodSymbol vMethod = (MethodSymbol)s;</span>
<span class="line-added">1673                     MethodSymbol rMethod = vMethod.clone(projection);</span>
<span class="line-added">1674                     vMethod.projection = rMethod;</span>
<span class="line-added">1675                     rMethod.projection = vMethod;</span>
<span class="line-added">1676                     clone = rMethod;</span>
<span class="line-added">1677                 } else if (s.kind == VAR) {</span>
<span class="line-added">1678                     VarSymbol vVar = (VarSymbol)s;</span>
<span class="line-added">1679                     VarSymbol rVar = vVar.clone(projection);</span>
<span class="line-added">1680                     vVar.projection = rVar;</span>
<span class="line-added">1681                     rVar.projection = vVar;</span>
<span class="line-added">1682                     clone = rVar;</span>
<span class="line-added">1683                 }</span>
<span class="line-added">1684                 projection.members_field.enter(clone);</span>
<span class="line-added">1685             }</span>
<span class="line-added">1686             projection.completer = Completer.NULL_COMPLETER;</span>
<span class="line-added">1687             projection.sourcefile = this.sourcefile;</span>
<span class="line-added">1688             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1689             projection.projection = this;</span>
<span class="line-added">1690             projectedType.tsym = projection;</span>
<span class="line-added">1691             return projection;</span>
<span class="line-added">1692         }</span>
1693     }
1694 
1695 
1696     /** A class for variable symbols
1697      */
1698     public static class VarSymbol extends Symbol implements VariableElement {
1699 
1700         /** The variable&#39;s declaration position.
1701          */
1702         public int pos = Position.NOPOS;
1703 
1704         /** The variable&#39;s address. Used for different purposes during
1705          *  flow analysis, translation and code generation.
1706          *  Flow analysis:
1707          *    If this is a blank final or local variable, its sequence number.
1708          *  Translation:
1709          *    If this is a private field, its access number.
1710          *  Code generation:
1711          *    If this is a local variable, its logical slot number.
1712          */
1713         public int adr = -1;
1714 
<span class="line-added">1715         /* The `other&#39; projection: If `this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1716            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1717         */</span>
<span class="line-added">1718         public VarSymbol projection;</span>
<span class="line-added">1719 </span>
1720         /** Construct a variable symbol, given its flags, name, type and owner.
1721          */
1722         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1723             super(VAR, flags, name, type, owner);
1724         }
1725 
1726         @Override
1727         public int poolTag() {
1728             return ClassFile.CONSTANT_Fieldref;
1729         }
1730 
1731         public MethodHandleSymbol asMethodHandle(boolean getter) {
1732             return new MethodHandleSymbol(this, getter);
1733         }
1734 
1735         /** Clone this symbol with new owner.
1736          */
1737         public VarSymbol clone(Symbol newOwner) {
1738             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1739                 @Override
1740                 public Symbol baseSymbol() {
1741                     return VarSymbol.this;
1742                 }
1743 
1744                 @Override
1745                 public Object poolKey(Types types) {
1746                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1747                 }
1748             };
1749             v.pos = pos;
1750             v.adr = adr;
1751             v.data = data;
<span class="line-added">1752             v.projection = projection;</span>
1753 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1754             return v;
1755         }
1756 
1757         public String toString() {
1758             return name.toString();
1759         }
1760 
1761         public Symbol asMemberOf(Type site, Types types) {
1762             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1763         }
1764 
1765         @DefinedBy(Api.LANGUAGE_MODEL)
1766         public ElementKind getKind() {
1767             long flags = flags();
1768             if ((flags &amp; PARAMETER) != 0) {
1769                 if (isExceptionParameter())
1770                     return ElementKind.EXCEPTION_PARAMETER;
1771                 else
1772                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1785             }
1786         }
1787 
1788         @DefinedBy(Api.LANGUAGE_MODEL)
1789         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1790             return v.visitVariable(this, p);
1791         }
1792 
1793         @DefinedBy(Api.LANGUAGE_MODEL)
1794         public Object getConstantValue() { // Mirror API
1795             return Constants.decode(getConstValue(), type);
1796         }
1797 
1798         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1799                                       final Attr attr,
1800                                       final JCVariableDecl variable)
1801         {
1802             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1803         }
1804 
<span class="line-added">1805         @Override</span>
<span class="line-added">1806         public VarSymbol referenceProjection() {</span>
<span class="line-added">1807             return this.owner.isValue() ?</span>
<span class="line-added">1808                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">1809                                : null;</span>
<span class="line-added">1810         }</span>
<span class="line-added">1811 </span>
<span class="line-added">1812         @Override</span>
<span class="line-added">1813         public VarSymbol valueProjection() {</span>
<span class="line-added">1814             return  projection != null ? projection.owner.isValue() ? projection : null: null;</span>
<span class="line-added">1815         }</span>
<span class="line-added">1816 </span>
1817         /**
1818          * The variable&#39;s constant value, if this is a constant.
1819          * Before the constant value is evaluated, it points to an
1820          * initializer environment.  If this is not a constant, it can
1821          * be used for other stuff.
1822          */
1823         private Object data;
1824 
1825         public boolean isExceptionParameter() {
1826             return data == ElementKind.EXCEPTION_PARAMETER;
1827         }
1828 
1829         public boolean isResourceVariable() {
1830             return data == ElementKind.RESOURCE_VARIABLE;
1831         }
1832 
1833         public Object getConstValue() {
1834             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1835             if (data == ElementKind.EXCEPTION_PARAMETER ||
1836                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1947     public static class MethodSymbol extends Symbol implements ExecutableElement {
1948 
1949         /** The code of the method. */
1950         public Code code = null;
1951 
1952         /** The extra (synthetic/mandated) parameters of the method. */
1953         public List&lt;VarSymbol&gt; extraParams = List.nil();
1954 
1955         /** The captured local variables in an anonymous class */
1956         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1957 
1958         /** The parameters of the method. */
1959         public List&lt;VarSymbol&gt; params = null;
1960 
1961         /** For an annotation type element, its default value if any.
1962          *  The value is null if none appeared in the method
1963          *  declaration.
1964          */
1965         public Attribute defaultValue = null;
1966 
<span class="line-added">1967         /* The `other&#39; projection: If `this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1968            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1969         */</span>
<span class="line-added">1970         public MethodSymbol projection;</span>
<span class="line-added">1971 </span>
1972         /** Construct a method symbol, given its flags, name, type and owner.
1973          */
1974         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1975             super(MTH, flags, name, type, owner);
1976             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1977         }
1978 
1979         /** Clone this symbol with new owner.
1980          */
1981         public MethodSymbol clone(Symbol newOwner) {
1982             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1983                 @Override
1984                 public Symbol baseSymbol() {
1985                     return MethodSymbol.this;
1986                 }
1987 
1988                 @Override
1989                 public Object poolKey(Types types) {
1990                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1991                 }
1992             };
1993             m.code = code;
<span class="line-added">1994             m.projection = projection;</span>
1995             return m;
1996         }
1997 
1998         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1999         public Set&lt;Modifier&gt; getModifiers() {
2000             long flags = flags();
2001             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2002         }
2003 
2004         /** The Java source which this symbol represents.
2005          */
2006         public String toString() {
2007             if ((flags() &amp; BLOCK) != 0) {
2008                 return owner.name.toString();
2009             } else {
2010                 String s = (name == name.table.names.init)
2011                     ? owner.name.toString()
2012                     : name.toString();
2013                 if (type != null) {
2014                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2123             return overrides(_other, origin, types, checkResult, true);
2124         }
2125 
2126         /** Does this symbol override `other&#39; symbol, when both are seen as
2127          *  members of class `origin&#39;?  It is assumed that _other is a member
2128          *  of origin.
2129          *
2130          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2131          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2132          *  is false.
2133          *
2134          *  It is assumed that both symbols have the same name.  The static
2135          *  modifier is ignored for this test.
2136          *
2137          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2138          */
2139         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2140                                             boolean requireConcreteIfInherited) {
2141             if (isConstructor() || _other.kind != MTH) return false;
2142 
<span class="line-added">2143 </span>
<span class="line-added">2144             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2145                where the hierarchy is navigable</span>
<span class="line-added">2146             */</span>
<span class="line-added">2147             if (origin.isValue())</span>
<span class="line-added">2148                 origin = (TypeSymbol) origin.referenceProjection();</span>
<span class="line-added">2149 </span>
<span class="line-added">2150             if (this.owner.isValue())</span>
<span class="line-added">2151                 return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);</span>
<span class="line-added">2152 </span>
2153             if (this == _other) return true;
2154             MethodSymbol other = (MethodSymbol)_other;
2155 
2156             // check for a direct implementation
2157             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2158                 types.asSuper(owner.type, other.owner) != null) {
2159                 Type mt = types.memberType(owner.type, this);
2160                 Type ot = types.memberType(owner.type, other);
2161                 if (types.isSubSignature(mt, ot)) {
2162                     if (!checkResult)
2163                         return true;
2164                     if (types.returnTypeSubstitutable(mt, ot))
2165                         return true;
2166                 }
2167             }
2168 
2169             // check for an inherited implementation
2170             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2171                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2172                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2187             case Flags.PRIVATE:
2188                 return false;
2189             case Flags.PUBLIC:
2190                 return !this.owner.isInterface() ||
2191                         (flags_field &amp; STATIC) == 0;
2192             case Flags.PROTECTED:
2193                 return (origin.flags() &amp; INTERFACE) == 0;
2194             case 0:
2195                 // for package private: can only override in the same
2196                 // package
2197                 return
2198                     this.packge() == origin.packge() &amp;&amp;
2199                     (origin.flags() &amp; INTERFACE) == 0;
2200             default:
2201                 return false;
2202             }
2203         }
2204 
2205         @Override
2206         public boolean isInheritedIn(Symbol clazz, Types types) {
<span class="line-added">2207 </span>
<span class="line-added">2208             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2209                where the hierarchy is navigable</span>
<span class="line-added">2210             */</span>
<span class="line-added">2211             if (clazz.isValue())</span>
<span class="line-added">2212                 clazz = clazz.referenceProjection();</span>
<span class="line-added">2213             if (this.owner.isValue())</span>
<span class="line-added">2214                 return this.projection.isInheritedIn(clazz, types);</span>
<span class="line-added">2215 </span>
2216             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2217                 case PUBLIC:
2218                     return !this.owner.isInterface() ||
2219                             clazz == owner ||
2220                             (flags_field &amp; STATIC) == 0;
2221                 default:
2222                     return super.isInheritedIn(clazz, types);
2223             }
2224         }
2225 
2226         public boolean isLambdaMethod() {
2227             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2228         }
2229 
<span class="line-added">2230         @Override</span>
<span class="line-added">2231         public MethodSymbol referenceProjection() {</span>
<span class="line-added">2232             return this.owner.isValue() ?</span>
<span class="line-added">2233                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">2234                     : null;</span>
<span class="line-added">2235         }</span>
<span class="line-added">2236 </span>
<span class="line-added">2237         @Override</span>
<span class="line-added">2238         public MethodSymbol valueProjection() {</span>
<span class="line-added">2239             return  projection != null ? projection.owner.isValue() ? projection : null : null;</span>
<span class="line-added">2240         }</span>
<span class="line-added">2241 </span>
2242         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2243          *  lambda method
2244          */
2245         public MethodSymbol originalEnclosingMethod() {
2246             return this;
2247         }
2248 
2249         /** The implementation of this (abstract) symbol in class origin;
2250          *  null if none exists. Synthetic methods are not considered
2251          *  as possible implementations.
2252          */
2253         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2254             return implementation(origin, types, checkResult, implementation_filter);
2255         }
2256         // where
2257             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2258                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2259 
2260         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2261             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
</td>
</tr>
</table>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
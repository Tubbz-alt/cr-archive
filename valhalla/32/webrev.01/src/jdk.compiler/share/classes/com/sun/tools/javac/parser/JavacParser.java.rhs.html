<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Flags.Flag;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
  52 import static com.sun.tools.javac.code.Flags.asFlagSet;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
  82     private static final int infixPrecedenceLevels = 10;
  83 
  84     /** Is the parser instantiated to parse a module-info file ?
  85      */
  86     private final boolean parseModuleInfo;
  87 
  88     /** The scanner used for lexical analysis.
  89      */
  90     protected Lexer S;
  91 
  92     /** The factory to be used for abstract syntax tree construction.
  93      */
  94     protected TreeMaker F;
  95 
  96     /** The log to be used for error diagnostics.
  97      */
  98     private Log log;
  99 
 100     /** The Source language setting. */
 101     private Source source;
 102 
 103     /** The Preview language setting. */
 104     private Preview preview;
 105 
 106     /** The name table. */
 107     private Names names;
 108 
 109     /** End position mappings container */
 110     protected final AbstractEndPosTable endPosTable;
 111 
 112     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 113     // the presence of type annotations even though they are not ambiguous
 114     // in the absence of type annotations.  Consider this code:
 115     //   void m(String [] m) { }
 116     //   void m(String ... m) { }
 117     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 118     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 119     // if the next token is ... and in that case parse an ellipsis.  But in
 120     // the presence of type annotations:
 121     //   void m(String @A [] m) { }
 122     //   void m(String @A ... m) { }
 123     // no finite lookahead is enough to determine whether to read array
 124     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 125     // bracketsOpt first reads all the leading annotations and only then
 126     // discovers that it needs to fail.  bracketsOpt needs a way to push
 127     // back the extra annotations that it read.  (But, bracketsOpt should
 128     // not *always* be allowed to push back extra annotations that it finds
 129     // -- in most contexts, any such extra annotation is an error.
 130     //
 131     // The following two variables permit type annotations that have
 132     // already been read to be stored for later use.  Alternate
 133     // implementations are possible but would cause much larger changes to
 134     // the parser.
 135 
 136     /** Type annotations that have already been read but have not yet been used. **/
 137     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 138 
 139     /**
 140      * If the parser notices extra annotations, then it either immediately
 141      * issues an error (if this variable is false) or places the extra
 142      * annotations in variable typeAnnotationsPushedBack (if this variable
 143      * is true).
 144      */
 145     private boolean permitTypeAnnotationsPushBack = false;
 146 
 147     interface ErrorRecoveryAction {
 148         JCTree doRecover(JavacParser parser);
 149     }
 150 
 151     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 152         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 153         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 154     }
 155 
 156     /** Construct a parser from a given scanner, tree factory and log.
 157      */
 158     protected JavacParser(ParserFactory fac,
 159                           Lexer S,
 160                           boolean keepDocComments,
 161                           boolean keepLineMap,
 162                           boolean keepEndPositions) {
 163         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 164 
 165     }
 166     /** Construct a parser from a given scanner, tree factory and log.
 167      */
 168     protected JavacParser(ParserFactory fac,
 169                      Lexer S,
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
 193     }
 194 
 195     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 196         return  keepEndPositions
 197                 ? new SimpleEndPosTable(this)
 198                 : new EmptyEndPosTable(this);
 199     }
 200 
 201     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 202         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 203     }
 204 
 205     /** Switch: should we fold strings?
 206      */
 207     boolean allowStringFolding;
 208 
 209     /** Switch: should we allow withField operator at source level ?
 210     */
 211     boolean allowWithFieldOperator;
 212 
 213     /** Switch: should we keep docComments?
 214      */
 215     boolean keepDocComments;
 216 
 217     /** Switch: should we keep line table?
 218      */
 219     boolean keepLineMap;
 220 
 221     /** Switch: is &quot;this&quot; allowed as an identifier?
 222      * This is needed to parse receiver types.
 223      */
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 
 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed
<a name="1" id="anc1"></a>
 244      */
 245     protected static final int EXPR = 0x1;
 246     protected static final int TYPE = 0x2;
 247     protected static final int NOPARAMS = 0x4;
 248     protected static final int TYPEARG = 0x8;
 249     protected static final int DIAMOND = 0x10;
 250     protected static final int NOLAMBDA = 0x20;
<a name="2" id="anc2"></a>
 251 
 252     protected void selectExprMode() {
 253         mode = (mode &amp; NOLAMBDA) | EXPR;
 254     }
 255 
 256     protected void selectTypeMode() {
 257         mode = (mode &amp; NOLAMBDA) | TYPE;
 258     }
 259 
 260     /** The current mode.
 261      */
 262     protected int mode = 0;
 263 
 264     /** The mode of the term that was parsed last.
 265      */
 266     protected int lastmode = 0;
 267 
 268     /* ---------- token management -------------- */
 269 
 270     protected Token token;
 271 
 272     public Token token() {
 273         return token;
 274     }
 275 
 276     public void nextToken() {
 277         S.nextToken();
 278         token = S.token();
 279     }
 280 
 281     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 282         return peekToken(0, tk);
 283     }
 284 
 285     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 286         return tk.accepts(S.token(lookahead + 1).kind);
 287     }
 288 
 289     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 290         return peekToken(0, tk1, tk2);
 291     }
 292 
 293     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 294         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 295                 tk2.accepts(S.token(lookahead + 2).kind);
 296     }
 297 
 298     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 299         return peekToken(0, tk1, tk2, tk3);
 300     }
 301 
 302     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 303         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 304                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 305                 tk3.accepts(S.token(lookahead + 3).kind);
 306     }
 307 
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {
 309         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 310                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 311                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;
 312                 tk4.accepts(S.token(lookahead + 4).kind);
 313     }
 314 
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 317         return peekToken(0, kinds);
 318     }
 319 
 320     @SuppressWarnings(&quot;unchecked&quot;)
 321     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 322         for (; lookahead &lt; kinds.length ; lookahead++) {
 323             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
 329 
 330     /* ---------- error recovery -------------- */
 331 
 332     private JCErroneous errorTree;
 333 
 334     /** Skip forward until a suitable stop token is found.
 335      */
 336     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 337          while (true) {
 338              switch (token.kind) {
 339                 case SEMI:
 340                     nextToken();
 341                     return;
 342                 case PUBLIC:
 343                 case FINAL:
 344                 case ABSTRACT:
 345                 case MONKEYS_AT:
 346                 case EOF:
 347                 case CLASS:
 348                 case INTERFACE:
 349                 case ENUM:
 350                     return;
 351                 case IMPORT:
 352                     if (stopAtImport)
 353                         return;
 354                     break;
 355                 case LBRACE:
 356                 case RBRACE:
 357                 case PRIVATE:
 358                 case PROTECTED:
 359                 case STATIC:
 360                 case TRANSIENT:
 361                 case NATIVE:
 362                 case VOLATILE:
 363                 case SYNCHRONIZED:
 364                 case STRICTFP:
 365                 case LT:
 366                 case BYTE:
 367                 case SHORT:
 368                 case CHAR:
 369                 case INT:
 370                 case LONG:
 371                 case FLOAT:
 372                 case DOUBLE:
 373                 case BOOLEAN:
 374                 case VOID:
 375                     if (stopAtMemberDecl)
 376                         return;
 377                     break;
 378                 case UNDERSCORE:
 379                 case IDENTIFIER:
 380                    if (stopAtIdentifier)
 381                         return;
 382                     break;
 383                 case CASE:
 384                 case DEFAULT:
 385                 case IF:
 386                 case FOR:
 387                 case WHILE:
 388                 case DO:
 389                 case TRY:
 390                 case SWITCH:
 391                 case RETURN:
 392                 case THROW:
 393                 case BREAK:
 394                 case CONTINUE:
 395                 case ELSE:
 396                 case FINALLY:
 397                 case CATCH:
 398                 case THIS:
 399                 case SUPER:
 400                 case NEW:
 401                     if (stopAtStatement)
 402                         return;
 403                     break;
 404                 case ASSERT:
 405                     if (stopAtStatement)
 406                         return;
 407                     break;
 408             }
 409             nextToken();
 410         }
 411     }
 412 
 413     protected JCErroneous syntaxError(int pos, Error errorKey) {
 414         return syntaxError(pos, List.nil(), errorKey);
 415     }
 416 
 417     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 418         setErrorEndPos(pos);
 419         JCErroneous err = F.at(pos).Erroneous(errs);
 420         reportSyntaxError(err, errorKey);
 421         if (errs != null) {
 422             JCTree last = errs.last();
 423             if (last != null)
 424                 storeEnd(last, pos);
 425         }
 426         return toP(err);
 427     }
 428 
 429     private static final int RECOVERY_THRESHOLD = 50;
 430     private int errorPos = Position.NOPOS;
 431     private int count = 0;
 432 
 433     /**
 434      * Report a syntax using the given the position parameter and arguments,
 435      * unless one was already reported at the same position.
 436      */
 437     protected void reportSyntaxError(int pos, Error errorKey) {
 438         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 439         reportSyntaxError(diag, errorKey);
 440     }
 441 
 442     /**
 443      * Report a syntax error using the given DiagnosticPosition object and
 444      * arguments, unless one was already reported at the same position.
 445      */
 446     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 447         int pos = diagPos.getPreferredPosition();
 448         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 449             if (token.kind == EOF) {
 450                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 451             } else {
 452                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 453             }
 454         }
 455         S.errPos(pos);
 456         if (token.pos == errorPos) {
 457             //check for a possible infinite loop in parsing:
 458             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 459         } else {
 460             count = 0;
 461             errorPos = token.pos;
 462         }
 463     }
 464 
 465     /** If next input token matches given token, skip it, otherwise report
 466      *  an error.
 467      */
 468     public void accept(TokenKind tk) {
 469         accept(tk, Errors::Expected);
 470     }
 471 
 472     /** If next input token matches given token, skip it, otherwise report
 473      *  an error.
 474      */
 475     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 476         if (token.kind == tk) {
 477             nextToken();
 478         } else {
 479             setErrorEndPos(token.pos);
 480             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 481         }
 482     }
 483 
 484     /** If next input token matches one of the two given tokens, skip it, otherwise report
 485      *  an error.
 486      *
 487      * @return The actual token kind.
 488      */
 489     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {
 490         TokenKind returnValue = token.kind;
 491         if (token.kind == tk1 || token.kind == tk2) {
 492             nextToken();
 493         } else {
 494             setErrorEndPos(token.pos);
 495             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));
 496         }
 497         return returnValue;
 498     }
 499 
 500     /** Report an illegal start of expression/type error at given position.
 501      */
 502     JCExpression illegal(int pos) {
 503         setErrorEndPos(pos);
 504         if ((mode &amp; EXPR) != 0)
 505             return syntaxError(pos, Errors.IllegalStartOfExpr);
 506         else
 507             return syntaxError(pos, Errors.IllegalStartOfType);
 508 
 509     }
 510 
 511     /** Report an illegal start of expression/type error at current position.
 512      */
 513     JCExpression illegal() {
 514         return illegal(token.pos);
 515     }
 516 
 517     /** Diagnose a modifier flag from the set, if any. */
 518     protected void checkNoMods(long mods) {
 519         if (mods != 0) {
 520             long lowestMod = mods &amp; -mods;
 521             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 522         }
 523     }
 524 
 525 /* ---------- doc comments --------- */
 526 
 527     /** A table to store all documentation comments
 528      *  indexed by the tree nodes they refer to.
 529      *  defined only if option flag keepDocComment is set.
 530      */
 531     private final DocCommentTable docComments;
 532 
 533     /** Make an entry into docComments hashtable,
 534      *  provided flag keepDocComments is set and given doc comment is non-null.
 535      *  @param tree   The tree to be used as index in the hashtable
 536      *  @param dc     The doc comment to associate with the tree, or null.
 537      */
 538     protected void attach(JCTree tree, Comment dc) {
 539         if (keepDocComments &amp;&amp; dc != null) {
 540 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 541             docComments.putComment(tree, dc);
 542         }
 543     }
 544 
 545 /* -------- source positions ------- */
 546 
 547     protected void setErrorEndPos(int errPos) {
 548         endPosTable.setErrorEndPos(errPos);
 549     }
 550 
 551     protected void storeEnd(JCTree tree, int endpos) {
 552         endPosTable.storeEnd(tree, endpos);
 553     }
 554 
 555     protected &lt;T extends JCTree&gt; T to(T t) {
 556         return endPosTable.to(t);
 557     }
 558 
 559     protected &lt;T extends JCTree&gt; T toP(T t) {
 560         return endPosTable.toP(t);
 561     }
 562 
 563     /** Get the start position for a tree node.  The start position is
 564      * defined to be the position of the first character of the first
 565      * token of the node&#39;s source text.
 566      * @param tree  The tree node
 567      */
 568     public int getStartPos(JCTree tree) {
 569         return TreeInfo.getStartPos(tree);
 570     }
 571 
 572     /**
 573      * Get the end position for a tree node.  The end position is
 574      * defined to be the position of the last character of the last
 575      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 576      * positions are not generated or the position is otherwise not
 577      * found.
 578      * @param tree  The tree node
 579      */
 580     public int getEndPos(JCTree tree) {
 581         return endPosTable.getEndPos(tree);
 582     }
 583 
 584 
 585 
 586 /* ---------- parsing -------------- */
 587 
 588     /**
 589      * Ident = IDENTIFIER
 590      */
 591     public Name ident() {
 592         return ident(false);
 593     }
 594 
 595     protected Name ident(boolean advanceOnErrors) {
 596         if (token.kind == IDENTIFIER) {
 597             Name name = token.name();
 598             nextToken();
 599             return name;
 600         } else if (token.kind == ASSERT) {
 601             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 602             nextToken();
 603             return names.error;
 604         } else if (token.kind == ENUM) {
 605             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 606             nextToken();
 607             return names.error;
 608         } else if (token.kind == THIS) {
 609             if (allowThisIdent) {
 610                 // Make sure we&#39;re using a supported source version.
 611                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 612                 Name name = token.name();
 613                 nextToken();
 614                 return name;
 615             } else {
 616                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 617                 nextToken();
 618                 return names.error;
 619             }
 620         } else if (token.kind == UNDERSCORE) {
 621             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 622                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 623             } else {
 624                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 625             }
 626             Name name = token.name();
 627             nextToken();
 628             return name;
 629         } else {
 630             accept(IDENTIFIER);
 631             if (advanceOnErrors) {
 632                 nextToken();
 633             }
 634             return names.error;
 635         }
 636     }
 637 
 638     /**
<a name="3" id="anc3"></a><span class="line-modified"> 639      * Qualident = Ident { DOT [Annotations] Ident }</span>
 640      */
 641     public JCExpression qualident(boolean allowAnnos) {
 642         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 643         while (token.kind == DOT) {
 644             int pos = token.pos;
 645             nextToken();
 646             List&lt;JCAnnotation&gt; tyannos = null;
 647             if (allowAnnos) {
 648                 tyannos = typeAnnotationsOpt();
 649             }
 650             t = toP(F.at(pos).Select(t, ident()));
 651             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 652                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 653             }
 654         }
<a name="4" id="anc4"></a>






 655         return t;
 656     }
 657 
 658     JCExpression literal(Name prefix) {
 659         return literal(prefix, token.pos);
 660     }
 661 
 662     /**
 663      * Literal =
 664      *     INTLITERAL
 665      *   | LONGLITERAL
 666      *   | FLOATLITERAL
 667      *   | DOUBLELITERAL
 668      *   | CHARLITERAL
 669      *   | STRINGLITERAL
 670      *   | TRUE
 671      *   | FALSE
 672      *   | NULL
 673      */
 674     JCExpression literal(Name prefix, int pos) {
 675         JCExpression t = errorTree;
 676         switch (token.kind) {
 677         case INTLITERAL:
 678             try {
 679                 t = F.at(pos).Literal(
 680                     TypeTag.INT,
 681                     Convert.string2int(strval(prefix), token.radix()));
 682             } catch (NumberFormatException ex) {
 683                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 684             }
 685             break;
 686         case LONGLITERAL:
 687             try {
 688                 t = F.at(pos).Literal(
 689                     TypeTag.LONG,
 690                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 691             } catch (NumberFormatException ex) {
 692                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 693             }
 694             break;
 695         case FLOATLITERAL: {
 696             String proper = token.radix() == 16 ?
 697                     (&quot;0x&quot;+ token.stringVal()) :
 698                     token.stringVal();
 699             Float n;
 700             try {
 701                 n = Float.valueOf(proper);
 702             } catch (NumberFormatException ex) {
 703                 // error already reported in scanner
 704                 n = Float.NaN;
 705             }
 706             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 707                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 708             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 709                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 710             else
 711                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 712             break;
 713         }
 714         case DOUBLELITERAL: {
 715             String proper = token.radix() == 16 ?
 716                     (&quot;0x&quot;+ token.stringVal()) :
 717                     token.stringVal();
 718             Double n;
 719             try {
 720                 n = Double.valueOf(proper);
 721             } catch (NumberFormatException ex) {
 722                 // error already reported in scanner
 723                 n = Double.NaN;
 724             }
 725             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 726                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 727             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 728                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 729             else
 730                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 731             break;
 732         }
 733         case CHARLITERAL:
 734             t = F.at(pos).Literal(
 735                 TypeTag.CHAR,
 736                 token.stringVal().charAt(0) + 0);
 737             break;
 738         case STRINGLITERAL:
 739             t = F.at(pos).Literal(
 740                 TypeTag.CLASS,
 741                 token.stringVal());
 742             break;
 743         case TRUE: case FALSE:
 744             t = F.at(pos).Literal(
 745                 TypeTag.BOOLEAN,
 746                 (token.kind == TRUE ? 1 : 0));
 747             break;
 748         case NULL:
 749             t = F.at(pos).Literal(
 750                 TypeTag.BOT,
 751                 null);
 752             break;
 753         default:
 754             Assert.error();
 755         }
 756         if (t == errorTree)
 757             t = F.at(pos).Erroneous();
 758         storeEnd(t, token.endPos);
 759         nextToken();
 760         return t;
 761     }
 762     //where
 763         boolean isZero(String s) {
 764             char[] cs = s.toCharArray();
 765             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 766             int i = ((base==16) ? 2 : 0);
 767             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 768             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 769         }
 770 
 771         String strval(Name prefix) {
 772             String s = token.stringVal();
 773             return prefix.isEmpty() ? s : prefix + s;
 774         }
 775 
 776     /** terms can be either expressions or types.
 777      */
 778     public JCExpression parseExpression() {
 779         return term(EXPR);
 780     }
 781 
 782     /**
 783      * parses (optional) type annotations followed by a type. If the
 784      * annotations are present before the type and are not consumed during array
 785      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 786      * these annotations and the underlying type. Otherwise, it returns the
 787      * underlying type.
 788      *
 789      * &lt;p&gt;
 790      *
 791      * Note that this method sets {@code mode} to {@code TYPE} first, before
 792      * parsing annotations.
 793      */
 794     public JCExpression parseType() {
 795         return parseType(false);
 796     }
 797 
<a name="5" id="anc5"></a>











 798     public JCExpression parseType(boolean allowVar) {
 799         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 800         return parseType(allowVar, annotations);
 801     }
 802 
 803     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
<a name="6" id="anc6"></a><span class="line-modified"> 804         JCExpression result = unannotatedType(allowVar);</span>
 805 
 806         if (annotations.nonEmpty()) {
 807             result = insertAnnotationsToMostInner(result, annotations, false);
 808         }
 809 
 810         return result;
 811     }
 812 
<a name="7" id="anc7"></a><span class="line-modified"> 813     public JCExpression unannotatedType(boolean allowVar) {</span>
<span class="line-modified"> 814         JCExpression result = term(TYPE);</span>
 815         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 816 
 817         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 818             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 819         }
 820 
 821         return result;
 822     }
 823 
 824 
 825 
 826     protected JCExpression term(int newmode) {
 827         int prevmode = mode;
 828         mode = newmode;
 829         JCExpression t = term();
 830         lastmode = mode;
 831         mode = prevmode;
 832         return t;
 833     }
 834 
 835     /**
 836      *  {@literal
 837      *  Expression = Expression1 [ExpressionRest]
 838      *  ExpressionRest = [AssignmentOperator Expression1]
 839      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 840      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 841      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 842      *  Type = Type1
 843      *  TypeNoParams = TypeNoParams1
 844      *  StatementExpression = Expression
 845      *  ConstantExpression = Expression
 846      *  }
 847      */
 848     JCExpression term() {
 849         JCExpression t = term1();
 850         if ((mode &amp; EXPR) != 0 &amp;&amp;
 851             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 852             return termRest(t);
 853         else
 854             return t;
 855     }
 856 
 857     JCExpression termRest(JCExpression t) {
 858         switch (token.kind) {
 859         case EQ: {
 860             int pos = token.pos;
 861             nextToken();
 862             selectExprMode();
 863             JCExpression t1 = term();
 864             return toP(F.at(pos).Assign(t, t1));
 865         }
 866         case PLUSEQ:
 867         case SUBEQ:
 868         case STAREQ:
 869         case SLASHEQ:
 870         case PERCENTEQ:
 871         case AMPEQ:
 872         case BAREQ:
 873         case CARETEQ:
 874         case LTLTEQ:
 875         case GTGTEQ:
 876         case GTGTGTEQ:
 877             int pos = token.pos;
 878             TokenKind tk = token.kind;
 879             nextToken();
 880             selectExprMode();
 881             JCExpression t1 = term();
 882             return F.at(pos).Assignop(optag(tk), t, t1);
 883         default:
 884             return t;
 885         }
 886     }
 887 
 888     /** Expression1   = Expression2 [Expression1Rest]
 889      *  Type1         = Type2
 890      *  TypeNoParams1 = TypeNoParams2
 891      */
 892     JCExpression term1() {
 893         JCExpression t = term2();
 894         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 895             selectExprMode();
 896             return term1Rest(t);
 897         } else {
 898             return t;
 899         }
 900     }
 901 
 902     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 903      */
 904     JCExpression term1Rest(JCExpression t) {
 905         if (token.kind == QUES) {
 906             int pos = token.pos;
 907             nextToken();
 908             JCExpression t1 = term();
 909             accept(COLON);
 910             JCExpression t2 = term1();
 911             return F.at(pos).Conditional(t, t1, t2);
 912         } else {
 913             return t;
 914         }
 915     }
 916 
 917     /** Expression2   = Expression3 [Expression2Rest]
 918      *  Type2         = Type3
 919      *  TypeNoParams2 = TypeNoParams3
 920      */
 921     JCExpression term2() {
 922         JCExpression t = term3();
 923         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 924             selectExprMode();
 925             return term2Rest(t, TreeInfo.orPrec);
 926         } else {
 927             return t;
 928         }
 929     }
 930 
 931     /*  Expression2Rest = {infixop Expression3}
 932      *                  | Expression3 instanceof Type
 933      *                  | Expression3 instanceof Pattern
 934      *  infixop         = &quot;||&quot;
 935      *                  | &quot;&amp;&amp;&quot;
 936      *                  | &quot;|&quot;
 937      *                  | &quot;^&quot;
 938      *                  | &quot;&amp;&quot;
 939      *                  | &quot;==&quot; | &quot;!=&quot;
 940      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 941      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 942      *                  | &quot;+&quot; | &quot;-&quot;
 943      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 944      */
 945     JCExpression term2Rest(JCExpression t, int minprec) {
 946         JCExpression[] odStack = newOdStack();
 947         Token[] opStack = newOpStack();
 948 
 949         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 950         int top = 0;
 951         odStack[0] = t;
 952         int startPos = token.pos;
 953         Token topOp = Tokens.DUMMY;
 954         while (prec(token.kind) &gt;= minprec) {
 955             opStack[top] = topOp;
 956 
 957             if (token.kind == INSTANCEOF) {
 958                 int pos = token.pos;
 959                 nextToken();
<a name="8" id="anc8"></a><span class="line-modified"> 960                 JCTree pattern = parseType();</span>
 961                 if (token.kind == IDENTIFIER) {
 962                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 963                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 964                 }
 965                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 966             } else {
 967                 topOp = token;
 968                 nextToken();
 969                 top++;
 970                 odStack[top] = term3();
 971             }
 972             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 973                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 974                 top--;
 975                 topOp = opStack[top];
 976             }
 977         }
 978         Assert.check(top == 0);
 979         t = odStack[0];
 980 
 981         if (t.hasTag(JCTree.Tag.PLUS)) {
 982             t = foldStrings(t);
 983         }
 984 
 985         odStackSupply.add(odStack);
 986         opStackSupply.add(opStack);
 987         return t;
 988     }
 989     //where
 990         /** If tree is a concatenation of string literals, replace it
 991          *  by a single literal representing the concatenated string.
 992          */
 993         protected JCExpression foldStrings(JCExpression tree) {
 994             if (!allowStringFolding)
 995                 return tree;
 996             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 997             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 998             boolean needsFolding = false;
 999             JCExpression curr = tree;
1000             while (true) {
1001                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1002                     JCBinary op = (JCBinary)curr;
1003                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1004                     curr = op.lhs;
1005                 } else {
1006                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1007                     break; //last one!
1008                 }
1009             }
1010             if (needsFolding) {
1011                 List&lt;JCExpression&gt; ops = opStack.toList();
1012                 JCExpression res = ops.head;
1013                 for (JCExpression op : ops.tail) {
1014                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1015                     storeEnd(res, getEndPos(op));
1016                 }
1017                 return res;
1018             } else {
1019                 return tree;
1020             }
1021         }
1022 
1023         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1024                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1025             JCLiteral str = stringLiteral(tree);
1026             if (str != null) {
1027                 litBuf.prepend(str);
1028                 return last &amp;&amp; merge(litBuf, opStack);
1029             } else {
1030                 boolean res = merge(litBuf, opStack);
1031                 litBuf.clear();
1032                 opStack.prepend(tree);
1033                 return res;
1034             }
1035         }
1036 
1037         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1038             if (litBuf.isEmpty()) {
1039                 return false;
1040             } else if (litBuf.size() == 1) {
1041                 opStack.prepend(litBuf.first());
1042                 return false;
1043             } else {
1044                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1045                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1046                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1047                 opStack.prepend(t);
1048                 return true;
1049             }
1050         }
1051 
1052         private JCLiteral stringLiteral(JCTree tree) {
1053             if (tree.hasTag(LITERAL)) {
1054                 JCLiteral lit = (JCLiteral)tree;
1055                 if (lit.typetag == TypeTag.CLASS) {
1056                     return lit;
1057                 }
1058             }
1059             return null;
1060         }
1061 
1062 
1063         /** optimization: To save allocating a new operand/operator stack
1064          *  for every binary operation, we use supplys.
1065          */
1066         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1067         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1068 
1069         private JCExpression[] newOdStack() {
1070             if (odStackSupply.isEmpty())
1071                 return new JCExpression[infixPrecedenceLevels + 1];
1072             return odStackSupply.remove(odStackSupply.size() - 1);
1073         }
1074 
1075         private Token[] newOpStack() {
1076             if (opStackSupply.isEmpty())
1077                 return new Token[infixPrecedenceLevels + 1];
1078             return opStackSupply.remove(opStackSupply.size() - 1);
1079         }
1080 
1081     /**
1082      *  Expression3    = PrefixOp Expression3
1083      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1084      *                 | Primary {Selector} {PostfixOp}
1085      *
1086      *  {@literal
1087      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1088      *                 | Literal
1089      *                 | [TypeArguments] THIS [Arguments]
1090      *                 | [TypeArguments] SUPER SuperSuffix
1091      *                 | NEW [TypeArguments] Creator
1092      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1093      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1094      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1095      *                 | Expression3 MemberReferenceSuffix
1096      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1097      *                   | Arguments
1098      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1099      *                   ]
1100      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1101      *  }
1102      *
1103      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1104      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1105      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1106      *                 | BasicType
1107      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1108      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1109      *                 | &quot;.&quot; THIS
1110      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1111      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1112      *                 | &quot;[&quot; Expression &quot;]&quot;
1113      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1114      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1115      */
1116     protected JCExpression term3() {
1117         int pos = token.pos;
1118         JCExpression t;
1119         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1120         switch (token.kind) {
1121         case QUES:
1122             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1123                 selectTypeMode();
1124                 return typeArgument();
1125             } else
1126                 return illegal();
1127         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1128             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1129                 TokenKind tk = token.kind;
1130                 nextToken();
1131                 selectExprMode();
1132                 if (tk == SUB &amp;&amp;
1133                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1134                     token.radix() == 10) {
1135                     selectExprMode();
1136                     t = literal(names.hyphen, pos);
1137                 } else {
1138                     t = term3();
1139                     return F.at(pos).Unary(unoptag(tk), t);
1140                 }
1141             } else return illegal();
1142             break;
1143         case WITHFIELD:
1144             if (!allowWithFieldOperator) {
1145                 log.error(pos, Errors.WithFieldOperatorDisallowed);
1146             }
1147             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1148                 nextToken();
1149                 accept(LPAREN);
1150                 mode = EXPR;
1151                 t = term();
1152                 accept(COMMA);
1153                 mode = EXPR;
1154                 JCExpression v = term();
1155                 accept(RPAREN);
1156                 return F.at(pos).WithField(t, v);
1157             } else return illegal();
1158         case LPAREN:
1159             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1160                 ParensResult pres = analyzeParens();
1161                 switch (pres) {
1162                     case CAST:
1163                        accept(LPAREN);
1164                        selectTypeMode();
1165                        int pos1 = pos;
1166                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1167                        while (token.kind == AMP) {
1168                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1169                            accept(AMP);
1170                            targets = targets.prepend(parseType());
1171                        }
1172                        if (targets.length() &gt; 1) {
1173                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1174                        }
1175                        accept(RPAREN);
1176                        selectExprMode();
1177                        JCExpression t1 = term3();
1178                        return F.at(pos).TypeCast(t, t1);
1179                     case IMPLICIT_LAMBDA:
1180                     case EXPLICIT_LAMBDA:
1181                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1182                         break;
1183                     default: //PARENS
1184                         accept(LPAREN);
1185                         selectExprMode();
1186                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1187                         accept(RPAREN);
1188                         t = toP(F.at(pos).Parens(t));
1189                         break;
1190                 }
1191             } else {
1192                 return illegal();
1193             }
1194             break;
1195         case THIS:
1196             if ((mode &amp; EXPR) != 0) {
1197                 selectExprMode();
1198                 t = to(F.at(pos).Ident(names._this));
1199                 nextToken();
1200                 if (typeArgs == null)
1201                     t = argumentsOpt(null, t);
1202                 else
1203                     t = arguments(typeArgs, t);
1204                 typeArgs = null;
1205             } else return illegal();
1206             break;
1207         case SUPER:
1208             if ((mode &amp; EXPR) != 0) {
1209                 selectExprMode();
1210                 t = to(F.at(pos).Ident(names._super));
1211                 t = superSuffix(typeArgs, t);
1212                 typeArgs = null;
1213             } else return illegal();
1214             break;
1215         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1216         case CHARLITERAL: case STRINGLITERAL:
1217         case TRUE: case FALSE: case NULL:
1218             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1219                 selectExprMode();
1220                 t = literal(names.empty);
1221             } else return illegal();
1222             break;
1223         case NEW:
1224             if (typeArgs != null) return illegal();
1225             if ((mode &amp; EXPR) != 0) {
1226                 selectExprMode();
1227                 nextToken();
1228                 if (token.kind == LT) typeArgs = typeArguments(false);
1229                 t = creator(pos, typeArgs);
1230                 typeArgs = null;
1231             } else return illegal();
1232             break;
1233         case MONKEYS_AT:
1234             // Only annotated cast types and method references are valid
1235             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1236             if (typeAnnos.isEmpty()) {
1237                 // else there would be no &#39;@&#39;
1238                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1239             }
1240 
1241             JCExpression expr = term3();
1242 
1243             if ((mode &amp; TYPE) == 0) {
1244                 // Type annotations on class literals no longer legal
1245                 switch (expr.getTag()) {
1246                 case REFERENCE: {
1247                     JCMemberReference mref = (JCMemberReference) expr;
1248                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1249                     t = mref;
1250                     break;
1251                 }
1252                 case SELECT: {
1253                     JCFieldAccess sel = (JCFieldAccess) expr;
1254 
1255                     if (sel.name != names._class) {
1256                         return illegal();
1257                     } else {
1258                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1259                         return expr;
1260                     }
1261                 }
1262                 default:
1263                     return illegal(typeAnnos.head.pos);
1264                 }
1265 
1266             } else {
1267                 // Type annotations targeting a cast
1268                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1269             }
1270             break;
1271         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1272             if (typeArgs != null) return illegal();
1273             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1274                 t = lambdaExpressionOrStatement(false, false, pos);
1275             } else {
1276                 t = toP(F.at(token.pos).Ident(ident()));
<a name="9" id="anc9"></a>
1277                 loop: while (true) {
1278                     pos = token.pos;
1279                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1280 
1281                     // need to report an error later if LBRACKET is for array
1282                     // index access rather than array creation level
1283                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1284                         return illegal(annos.head.pos);
1285 
1286                     switch (token.kind) {
1287                     case LBRACKET:
1288                         nextToken();
1289                         if (token.kind == RBRACKET) {
1290                             nextToken();
1291                             t = bracketsOpt(t);
1292                             t = toP(F.at(pos).TypeArray(t));
1293                             if (annos.nonEmpty()) {
1294                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1295                             }
1296                             t = bracketsSuffix(t);
1297                         } else {
1298                             if ((mode &amp; EXPR) != 0) {
1299                                 selectExprMode();
1300                                 JCExpression t1 = term();
1301                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1302                                 t = to(F.at(pos).Indexed(t, t1));
1303                             }
1304                             accept(RBRACKET);
1305                         }
1306                         break loop;
1307                     case LPAREN:
1308                         if ((mode &amp; EXPR) != 0) {
1309                             selectExprMode();
1310                             t = arguments(typeArgs, t);
1311                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1312                             typeArgs = null;
1313                         }
1314                         break loop;
1315                     case DOT:
1316                         nextToken();
1317                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1318                             return illegal();
1319                         }
1320                         int oldmode = mode;
1321                         mode &amp;= ~NOPARAMS;
1322                         typeArgs = typeArgumentsOpt(EXPR);
1323                         mode = oldmode;
1324                         if ((mode &amp; EXPR) != 0) {
1325                             switch (token.kind) {
1326                             case DEFAULT:
1327                                 if (typeArgs != null) return illegal();
1328                                 selectExprMode();
1329                                 t = to(F.at(pos).Select(t, names._default));
1330                                 nextToken();
1331                                 break loop;
1332                             case CLASS:
1333                                 if (typeArgs != null) return illegal();
1334                                 selectExprMode();
1335                                 t = to(F.at(pos).Select(t, names._class));
1336                                 nextToken();
1337                                 break loop;
1338                             case THIS:
1339                                 if (typeArgs != null) return illegal();
1340                                 selectExprMode();
1341                                 t = to(F.at(pos).Select(t, names._this));
1342                                 nextToken();
1343                                 break loop;
1344                             case SUPER:
1345                                 selectExprMode();
1346                                 t = to(F.at(pos).Select(t, names._super));
1347                                 t = superSuffix(typeArgs, t);
1348                                 typeArgs = null;
1349                                 break loop;
1350                             case NEW:
1351                                 if (typeArgs != null) return illegal();
1352                                 selectExprMode();
1353                                 int pos1 = token.pos;
1354                                 nextToken();
1355                                 if (token.kind == LT) typeArgs = typeArguments(false);
1356                                 t = innerCreator(pos1, typeArgs, t);
1357                                 typeArgs = null;
1358                                 break loop;
1359                             }
1360                         }
1361 
1362                         List&lt;JCAnnotation&gt; tyannos = null;
1363                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1364                             tyannos = typeAnnotationsOpt();
1365                         }
1366                         // typeArgs saved for next loop iteration.
1367                         t = toP(F.at(pos).Select(t, ident()));
<a name="10" id="anc10"></a>
1368                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1369                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1370                         }
1371                         break;
1372                     case ELLIPSIS:
1373                         if (this.permitTypeAnnotationsPushBack) {
1374                             this.typeAnnotationsPushedBack = annos;
1375                         } else if (annos.nonEmpty()) {
1376                             // Don&#39;t return here -- error recovery attempt
1377                             illegal(annos.head.pos);
1378                         }
1379                         break loop;
1380                     case LT:
1381                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {
1382                             //this is either an unbound method reference whose qualifier
1383                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of
1384                             //the form ValueType&lt;S&gt;.default
1385                             int pos1 = token.pos;
1386                             accept(LT);
1387                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1388                             args.append(typeArgument());
1389                             while (token.kind == COMMA) {
1390                                 nextToken();
1391                                 args.append(typeArgument());
1392                             }
1393                             accept(GT);
1394                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1395                             while (token.kind == DOT) {
1396                                 nextToken();
1397                                 if (token.kind == DEFAULT) {
1398                                     t =  toP(F.at(token.pos).Select(t, names._default));
1399                                     nextToken();
1400                                     selectExprMode();
1401                                     return term3Rest(t, typeArgs);
1402                                 }
1403                                 selectTypeMode();
1404                                 t = toP(F.at(token.pos).Select(t, ident()));
1405                                 t = typeArgumentsOpt(t);
1406                             }
1407                             t = bracketsOpt(t);
1408                             if (token.kind != COLCOL) {
1409                                 //method reference expected here
1410                                 t = illegal();
1411                             }
1412                             selectExprMode();
1413                             return term3Rest(t, typeArgs);
1414                         }
1415                         break loop;
1416                     default:
1417                         break loop;
1418                     }
1419                 }
1420             }
1421             if (typeArgs != null) illegal();
1422             t = typeArgumentsOpt(t);
1423             break;
1424         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1425         case DOUBLE: case BOOLEAN:
1426             if (typeArgs != null) illegal();
1427             t = bracketsSuffix(bracketsOpt(basicType()));
1428             break;
1429         case VOID:
1430             if (typeArgs != null) illegal();
1431             if ((mode &amp; EXPR) != 0) {
1432                 nextToken();
1433                 if (token.kind == DOT) {
1434                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1435                     t = bracketsSuffix(ti);
1436                 } else {
1437                     return illegal(pos);
1438                 }
1439             } else {
1440                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1441                 // a void type (like other primitive types) to the next phase.
1442                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1443                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1444                 nextToken();
1445                 return ti;
1446                 //return illegal();
1447             }
1448             break;
1449         case SWITCH:
1450             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1451             allowYieldStatement = true;
1452             int switchPos = token.pos;
1453             nextToken();
1454             JCExpression selector = parExpression();
1455             accept(LBRACE);
1456             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1457             while (true) {
1458                 pos = token.pos;
1459                 switch (token.kind) {
1460                 case CASE:
1461                 case DEFAULT:
1462                     cases.appendList(switchExpressionStatementGroup());
1463                     break;
1464                 case RBRACE: case EOF:
1465                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1466                                                                                cases.toList()));
1467                     e.endpos = token.pos;
1468                     accept(RBRACE);
1469                     return e;
1470                 default:
1471                     nextToken(); // to ensure progress
1472                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1473                 }
1474             }
1475         default:
1476             return illegal();
1477         }
1478         return term3Rest(t, typeArgs);
1479     }
1480 
<a name="11" id="anc11"></a>










1481     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1482         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1483         int casePos = token.pos;
1484         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1485 
1486         if (token.kind == DEFAULT) {
1487             nextToken();
1488         } else {
1489             accept(CASE);
1490             while (true) {
1491                 pats.append(term(EXPR | NOLAMBDA));
1492                 if (token.kind != COMMA) break;
1493                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1494                 nextToken();
1495             };
1496         }
1497         List&lt;JCStatement&gt; stats = null;
1498         JCTree body = null;
1499         CaseTree.CaseKind kind;
1500         switch (token.kind) {
1501             case ARROW:
1502                 checkSourceLevel(Feature.SWITCH_RULE);
1503                 nextToken();
1504                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1505                     stats = List.of(parseStatement());
1506                     body = stats.head;
1507                     kind = JCCase.RULE;
1508                 } else {
1509                     JCExpression value = parseExpression();
1510                     stats = List.of(to(F.at(value).Yield(value)));
1511                     body = value;
1512                     kind = JCCase.RULE;
1513                     accept(SEMI);
1514                 }
1515                 break;
1516             default:
1517                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1518                 stats = blockStatements();
1519                 kind = JCCase.STATEMENT;
1520                 break;
1521         }
1522         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1523         return caseExprs.toList();
1524     }
1525 
1526     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1527         if (typeArgs != null) illegal();
1528         while (true) {
1529             int pos1 = token.pos;
1530             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1531 
1532             if (token.kind == LBRACKET) {
1533                 nextToken();
1534                 if ((mode &amp; TYPE) != 0) {
1535                     int oldmode = mode;
1536                     selectTypeMode();
1537                     if (token.kind == RBRACKET) {
1538                         nextToken();
1539                         t = bracketsOpt(t);
1540                         t = toP(F.at(pos1).TypeArray(t));
1541                         if (token.kind == COLCOL) {
1542                             selectExprMode();
1543                             continue;
1544                         }
1545                         if (annos.nonEmpty()) {
1546                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1547                         }
1548                         return t;
1549                     }
1550                     mode = oldmode;
1551                 }
1552                 if ((mode &amp; EXPR) != 0) {
1553                     selectExprMode();
1554                     JCExpression t1 = term();
1555                     t = to(F.at(pos1).Indexed(t, t1));
1556                 }
1557                 accept(RBRACKET);
1558             } else if (token.kind == DOT) {
1559                 nextToken();
1560                 typeArgs = typeArgumentsOpt(EXPR);
1561                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1562                     selectExprMode();
1563                     t = to(F.at(pos1).Select(t, names._super));
1564                     nextToken();
1565                     t = arguments(typeArgs, t);
1566                     typeArgs = null;
1567                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {
1568                     if (typeArgs != null) return illegal();
1569                     selectExprMode();
1570                     int pos2 = token.pos;
1571                     nextToken();
1572                     if (token.kind == LT) typeArgs = typeArguments(false);
1573                     t = innerCreator(pos2, typeArgs, t);
1574                     typeArgs = null;
1575                 } else {
1576                     List&lt;JCAnnotation&gt; tyannos = null;
1577                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1578                         // is the mode check needed?
1579                         tyannos = typeAnnotationsOpt();
1580                     }
1581                     t = toP(F.at(pos1).Select(t, ident(true)));
1582                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1583                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1584                     }
1585                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1586                     typeArgs = null;
1587                 }
1588             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1589                 selectExprMode();
1590                 if (typeArgs != null) return illegal();
1591                 accept(COLCOL);
1592                 t = memberReferenceSuffix(pos1, t);
1593             } else {
1594                 if (!annos.isEmpty()) {
1595                     if (permitTypeAnnotationsPushBack)
1596                         typeAnnotationsPushedBack = annos;
1597                     else
1598                         return illegal(annos.head.pos);
1599                 }
1600                 break;
1601             }
1602         }
1603         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1604             selectExprMode();
1605             t = to(F.at(token.pos).Unary(
1606                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1607             nextToken();
1608         }
1609         return toP(t);
1610     }
1611 
1612     /**
1613      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1614      * method reference or a default value creation that uses a parameterized type
1615      * or a binary expression. To disambiguate, look for a
1616      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1617      */
1618     @SuppressWarnings(&quot;fallthrough&quot;)
1619     boolean isParameterizedTypePrefix() {
1620         int pos = 0, depth = 0;
1621         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1622             switch (t.kind) {
1623                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1624                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1625                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1626                 case DOUBLE: case BOOLEAN: case CHAR:
1627                 case MONKEYS_AT:
1628                     break;
1629 
1630                 case LPAREN:
1631                     // skip annotation values
1632                     int nesting = 0;
1633                     for (; ; pos++) {
1634                         TokenKind tk2 = S.token(pos).kind;
1635                         switch (tk2) {
1636                             case EOF:
1637                                 return false;
1638                             case LPAREN:
1639                                 nesting++;
1640                                 break;
1641                             case RPAREN:
1642                                 nesting--;
1643                                 if (nesting == 0) {
1644                                     continue outer;
1645                                 }
1646                                 break;
1647                         }
1648                     }
1649 
1650                 case LT:
1651                     depth++; break;
1652                 case GTGTGT:
1653                     depth--;
1654                 case GTGT:
1655                     depth--;
1656                 case GT:
1657                     depth--;
1658                     if (depth == 0) {
1659                         TokenKind nextKind = S.token(pos + 1).kind;
1660                         return
1661                             nextKind == TokenKind.DOT ||
1662                             nextKind == TokenKind.LBRACKET ||
1663                             nextKind == TokenKind.COLCOL;
1664                     }
1665                     break;
1666                 default:
1667                     return false;
1668             }
1669         }
1670     }
1671 
1672     /**
1673      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1674      * method reference or a binary expression. To disambiguate, look for a
1675      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1676      */
1677     @SuppressWarnings(&quot;fallthrough&quot;)
1678     ParensResult analyzeParens() {
1679         int depth = 0;
1680         boolean type = false;
1681         ParensResult defaultResult = ParensResult.PARENS;
1682         outer: for (int lookahead = 0; ; lookahead++) {
1683             TokenKind tk = S.token(lookahead).kind;
1684             switch (tk) {
1685                 case COMMA:
1686                     type = true;
1687                 case EXTENDS: case SUPER: case DOT: case AMP:
1688                     //skip
1689                     break;
1690                 case QUES:
1691                     if (peekToken(lookahead, EXTENDS) ||
1692                             peekToken(lookahead, SUPER)) {
1693                         //wildcards
1694                         type = true;
1695                     }
1696                     break;
1697                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1698                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1699                     if (peekToken(lookahead, RPAREN)) {
1700                         //Type, &#39;)&#39; -&gt; cast
1701                         return ParensResult.CAST;
1702                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1703                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1704                         return ParensResult.EXPLICIT_LAMBDA;
1705                     }
1706                     break;
1707                 case LPAREN:
1708                     if (lookahead != 0) {
1709                         // &#39;(&#39; in a non-starting position -&gt; parens
1710                         return ParensResult.PARENS;
1711                     } else if (peekToken(lookahead, RPAREN)) {
1712                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1713                         return ParensResult.EXPLICIT_LAMBDA;
1714                     }
1715                     break;
1716                 case RPAREN:
1717                     // if we have seen something that looks like a type,
1718                     // then it&#39;s a cast expression
1719                     if (type) return ParensResult.CAST;
1720                     // otherwise, disambiguate cast vs. parenthesized expression
1721                     // based on subsequent token.
1722                     switch (S.token(lookahead + 1).kind) {
1723                         /*case PLUSPLUS: case SUBSUB: */
1724                         case BANG: case TILDE:
1725                         case LPAREN: case THIS: case SUPER:
1726                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1727                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1728                         case TRUE: case FALSE: case NULL:
1729                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1730                         case SWITCH:
1731                         case BYTE: case SHORT: case CHAR: case INT:
1732                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1733                             return ParensResult.CAST;
1734                         default:
1735                             return defaultResult;
1736                     }
1737                 case UNDERSCORE:
1738                 case ASSERT:
1739                 case ENUM:
1740                 case IDENTIFIER:
1741                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {
1742                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1743                         return ParensResult.EXPLICIT_LAMBDA;
1744                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1745                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1746                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1747                                                       : ParensResult.PARENS;
1748                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1749                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1750                     }
1751                     type = false;
1752                     break;
1753                 case FINAL:
1754                 case ELLIPSIS:
1755                     //those can only appear in explicit lambdas
1756                     return ParensResult.EXPLICIT_LAMBDA;
1757                 case MONKEYS_AT:
1758                     type = true;
1759                     lookahead += 1; //skip &#39;@&#39;
1760                     while (peekToken(lookahead, DOT)) {
1761                         lookahead += 2;
1762                     }
1763                     if (peekToken(lookahead, LPAREN)) {
1764                         lookahead++;
1765                         //skip annotation values
1766                         int nesting = 0;
1767                         for (; ; lookahead++) {
1768                             TokenKind tk2 = S.token(lookahead).kind;
1769                             switch (tk2) {
1770                                 case EOF:
1771                                     return ParensResult.PARENS;
1772                                 case LPAREN:
1773                                     nesting++;
1774                                     break;
1775                                 case RPAREN:
1776                                     nesting--;
1777                                     if (nesting == 0) {
1778                                         continue outer;
1779                                     }
1780                                 break;
1781                             }
1782                         }
1783                     }
1784                     break;
1785                 case LBRACKET:
1786                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1787                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1788                         return ParensResult.EXPLICIT_LAMBDA;
1789                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1790                             peekToken(lookahead, RBRACKET, AMP)) {
1791                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1792                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1793                         return ParensResult.CAST;
1794                     } else if (peekToken(lookahead, RBRACKET)) {
1795                         //consume the &#39;]&#39; and skip
1796                         type = true;
1797                         lookahead++;
1798                         break;
1799                     } else {
1800                         return ParensResult.PARENS;
1801                     }
1802                 case LT:
1803                     depth++; break;
1804                 case GTGTGT:
1805                     depth--;
1806                 case GTGT:
1807                     depth--;
1808                 case GT:
1809                     depth--;
1810                     if (depth == 0) {
1811                         if (peekToken(lookahead, RPAREN) ||
1812                                 peekToken(lookahead, AMP)) {
1813                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1814                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1815                             return ParensResult.CAST;
1816                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1817                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1818                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||
1819                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||
1820                                 peekToken(lookahead, ELLIPSIS)) {
1821                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1822                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1823                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1824                             return ParensResult.EXPLICIT_LAMBDA;
1825                         }
1826                         //it looks a type, but could still be (i) a cast to generic type,
1827                         //(ii) an unbound method reference or (iii) an explicit lambda
1828                         type = true;
1829                         break;
1830                     } else if (depth &lt; 0) {
1831                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1832                         return ParensResult.PARENS;
1833                     }
1834                     break;
1835                 default:
1836                     //this includes EOF
1837                     return defaultResult;
1838             }
1839         }
1840     }
1841 
1842     /** Accepts all identifier-like tokens */
1843     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1844 
1845     enum ParensResult {
1846         CAST,
1847         EXPLICIT_LAMBDA,
1848         IMPLICIT_LAMBDA,
1849         PARENS
1850     }
1851 
1852     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1853         List&lt;JCVariableDecl&gt; params = explicitParams ?
1854                 formalParameters(true, false) :
1855                 implicitParameters(hasParens);
1856         if (explicitParams) {
1857             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1858             for (JCVariableDecl param: params) {
1859                 Name restrictedTypeName;
1860                 if (param.vartype != null &amp;&amp;
1861                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1862                         param.vartype.hasTag(TYPEARRAY)) {
1863                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1864                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1865                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1866                 }
1867                 lambdaClassifier.addParameter(param);
1868                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1869                     break;
1870                 }
1871             }
1872             if (lambdaClassifier.diagFragment != null) {
1873                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1874             }
1875             for (JCVariableDecl param: params) {
1876                 if (param.vartype != null
1877                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1878                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1879                     param.startPos = TreeInfo.getStartPos(param.vartype);
1880                     param.vartype = null;
1881                 }
1882             }
1883         }
1884         return lambdaExpressionOrStatementRest(params, pos);
1885     }
1886 
1887     enum LambdaParameterKind {
1888         VAR(0),
1889         EXPLICIT(1),
1890         IMPLICIT(2),
1891         ERROR(-1);
1892 
1893         private final int index;
1894 
1895         LambdaParameterKind(int index) {
1896             this.index = index;
1897         }
1898     }
1899 
1900     private final static Fragment[][] decisionTable = new Fragment[][] {
1901         /*              VAR                              EXPLICIT                         IMPLICIT  */
1902         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1903         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1904         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1905     };
1906 
1907     class LambdaClassifier {
1908 
1909         LambdaParameterKind kind;
1910         Fragment diagFragment;
1911         List&lt;JCVariableDecl&gt; params;
1912 
1913         void addParameter(JCVariableDecl param) {
1914             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1915                 if (restrictedTypeName(param.vartype, false) != null) {
1916                     reduce(LambdaParameterKind.VAR);
1917                 } else {
1918                     reduce(LambdaParameterKind.EXPLICIT);
1919                 }
1920             }
1921             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1922                 param.vartype != null &amp;&amp; param.name == names.empty) {
1923                 reduce(LambdaParameterKind.IMPLICIT);
1924             }
1925         }
1926 
1927         private void reduce(LambdaParameterKind newKind) {
1928             if (kind == null) {
1929                 kind = newKind;
1930             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1931                 LambdaParameterKind currentKind = kind;
1932                 kind = LambdaParameterKind.ERROR;
1933                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1934                         newKind.index == LambdaParameterKind.VAR.index;
1935                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1936                         decisionTable[currentKind.index][newKind.index] : null;
1937             }
1938         }
1939 
1940         LambdaParameterKind result() {
1941             return kind;
1942         }
1943     }
1944 
1945     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1946         checkSourceLevel(Feature.LAMBDA);
1947         accept(ARROW);
1948 
1949         return token.kind == LBRACE ?
1950             lambdaStatement(args, pos, token.pos) :
1951             lambdaExpression(args, pos);
1952     }
1953 
1954     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1955         JCBlock block = block(pos2, 0);
1956         return toP(F.at(pos).Lambda(args, block));
1957     }
1958 
1959     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1960         JCTree expr = parseExpression();
1961         return toP(F.at(pos).Lambda(args, expr));
1962     }
1963 
1964     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1965      */
1966     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1967         nextToken();
1968         if (token.kind == LPAREN || typeArgs != null) {
1969             t = arguments(typeArgs, t);
1970         } else if (token.kind == COLCOL) {
1971             if (typeArgs != null) return illegal();
1972             t = memberReferenceSuffix(t);
1973         } else {
1974             int pos = token.pos;
1975             accept(DOT);
1976             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1977             t = toP(F.at(pos).Select(t, ident()));
1978             t = argumentsOpt(typeArgs, t);
1979         }
1980         return t;
1981     }
1982 
1983     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1984      */
1985     JCPrimitiveTypeTree basicType() {
1986         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1987         nextToken();
1988         return t;
1989     }
1990 
1991     /** ArgumentsOpt = [ Arguments ]
1992      */
1993     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1994         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1995             selectExprMode();
1996             return arguments(typeArgs, t);
1997         } else {
1998             return t;
1999         }
2000     }
2001 
2002     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
2003      */
2004     List&lt;JCExpression&gt; arguments() {
2005         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2006         if (token.kind == LPAREN) {
2007             nextToken();
2008             if (token.kind != RPAREN) {
2009                 args.append(parseExpression());
2010                 while (token.kind == COMMA) {
2011                     nextToken();
2012                     args.append(parseExpression());
2013                 }
2014             }
2015             accept(RPAREN);
2016         } else {
2017             syntaxError(token.pos, Errors.Expected(LPAREN));
2018         }
2019         return args.toList();
2020     }
2021 
2022     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2023         int pos = token.pos;
2024         List&lt;JCExpression&gt; args = arguments();
2025         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2026         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2027                                                                     ((JCIdent) t).name)) {
2028             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2029             mi = F.Erroneous(List.of(mi));
2030         }
2031         return toP(mi);
2032     }
2033 
2034     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2035         if (name == names.yield) {
2036             if (allowYieldStatement) {
2037                 return true;
2038             } else {
2039                 log.warning(pos, Warnings.InvalidYield);
2040             }
2041         }
2042         return false;
2043     }
2044 
2045     /**  TypeArgumentsOpt = [ TypeArguments ]
2046      */
2047     JCExpression typeArgumentsOpt(JCExpression t) {
2048         if (token.kind == LT &amp;&amp;
2049             (mode &amp; TYPE) != 0 &amp;&amp;
2050             (mode &amp; NOPARAMS) == 0) {
2051             selectTypeMode();
2052             return typeArguments(t, false);
2053         } else {
2054             return t;
2055         }
2056     }
2057     List&lt;JCExpression&gt; typeArgumentsOpt() {
2058         return typeArgumentsOpt(TYPE);
2059     }
2060 
2061     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2062         if (token.kind == LT) {
2063             if ((mode &amp; useMode) == 0 ||
2064                 (mode &amp; NOPARAMS) != 0) {
2065                 illegal();
2066             }
2067             mode = useMode;
2068             return typeArguments(false);
2069         }
2070         return null;
2071     }
2072 
2073     /**
2074      *  {@literal
2075      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2076      *  }
2077      */
2078     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2079         if (token.kind == LT) {
2080             nextToken();
2081             if (token.kind == GT &amp;&amp; diamondAllowed) {
2082                 checkSourceLevel(Feature.DIAMOND);
2083                 mode |= DIAMOND;
2084                 nextToken();
2085                 return List.nil();
2086             } else {
2087                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2088                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2089                 while (token.kind == COMMA) {
2090                     nextToken();
2091                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2092                 }
2093                 switch (token.kind) {
2094 
2095                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2096                 case GTGTGT: case GTGT:
2097                     token = S.split();
2098                     break;
2099                 case GT:
2100                     nextToken();
2101                     break;
2102                 default:
2103                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2104                     break;
2105                 }
2106                 return args.toList();
2107             }
2108         } else {
2109             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2110         }
2111     }
2112 
2113     /**
2114      *  {@literal
2115      *  TypeArgument = Type
2116      *               | [Annotations] &quot;?&quot;
2117      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2118      *               | [Annotations] &quot;?&quot; SUPER Type
2119      *  }
2120      */
2121     JCExpression typeArgument() {
2122         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2123         if (token.kind != QUES) return parseType(false, annotations);
2124         int pos = token.pos;
2125         nextToken();
2126         JCExpression result;
2127         if (token.kind == EXTENDS) {
2128             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2129             nextToken();
2130             JCExpression bound = parseType();
2131             result = F.at(pos).Wildcard(t, bound);
2132         } else if (token.kind == SUPER) {
2133             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2134             nextToken();
2135             JCExpression bound = parseType();
2136             result = F.at(pos).Wildcard(t, bound);
2137         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2138             //error recovery
2139             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2140             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2141             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2142             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2143             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2144             result = err;
2145         } else {
2146             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2147             result = toP(F.at(pos).Wildcard(t, null));
2148         }
2149         if (!annotations.isEmpty()) {
2150             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2151         }
<a name="12" id="anc12"></a>
2152         return result;
2153     }
2154 
2155     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2156         int pos = token.pos;
2157         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
<a name="13" id="anc13"></a><span class="line-modified">2158         return toP(F.at(pos).TypeApply(t, args));</span>


2159     }
2160 
2161     /**
2162      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2163      *
2164      * &lt;p&gt;
2165      *
2166      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2167      * the expression &lt;code&gt;t&lt;/code&gt;.
2168      */
2169     private JCExpression bracketsOpt(JCExpression t,
2170             List&lt;JCAnnotation&gt; annotations) {
2171         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2172 
2173         if (token.kind == LBRACKET) {
2174             int pos = token.pos;
2175             nextToken();
2176             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2177         } else if (!nextLevelAnnotations.isEmpty()) {
2178             if (permitTypeAnnotationsPushBack) {
2179                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2180             } else {
2181                 return illegal(nextLevelAnnotations.head.pos);
2182             }
2183         }
2184 
2185         if (!annotations.isEmpty()) {
2186             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2187         }
2188         return t;
2189     }
2190 
2191     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2192      */
2193     private JCExpression bracketsOpt(JCExpression t) {
2194         return bracketsOpt(t, List.nil());
2195     }
2196 
2197     private JCExpression bracketsOptCont(JCExpression t, int pos,
2198             List&lt;JCAnnotation&gt; annotations) {
2199         accept(RBRACKET);
2200         t = bracketsOpt(t);
2201         t = toP(F.at(pos).TypeArray(t));
2202         if (annotations.nonEmpty()) {
2203             t = toP(F.at(pos).AnnotatedType(annotations, t));
2204         }
2205         return t;
2206     }
2207 
2208     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2209      *  BracketsSuffixType =
2210      */
2211     JCExpression bracketsSuffix(JCExpression t) {
2212         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2213             selectExprMode();
2214             int pos = token.pos;
2215             nextToken();
2216             TokenKind selector = accept2(CLASS, DEFAULT);
2217             if (token.pos == endPosTable.errorEndPos) {
2218                 // error recovery
2219                 Name name;
2220                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2221                     name = token.name();
2222                     nextToken();
2223                 } else {
2224                     name = names.error;
2225                 }
2226                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2227             } else {
2228                 Tag tag = t.getTag();
2229                 // Type annotations are illegal on class literals. Annotated non array class literals
2230                 // are complained about directly in term3(), Here check for type annotations on dimensions
2231                 // taking care to handle some interior dimension(s) being annotated.
2232                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2233                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2234                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));
2235             }
2236         } else if ((mode &amp; TYPE) != 0) {
2237             if (token.kind != COLCOL) {
2238                 selectTypeMode();
2239             }
2240         } else if (token.kind != COLCOL) {
2241             syntaxError(token.pos, Errors.DotClassExpected);
2242         }
2243         return t;
2244     }
2245 
2246     /**
2247      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2248      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2249      */
2250     JCExpression memberReferenceSuffix(JCExpression t) {
2251         int pos1 = token.pos;
2252         accept(COLCOL);
2253         return memberReferenceSuffix(pos1, t);
2254     }
2255 
2256     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2257         checkSourceLevel(Feature.METHOD_REFERENCES);
2258         selectExprMode();
2259         List&lt;JCExpression&gt; typeArgs = null;
2260         if (token.kind == LT) {
2261             typeArgs = typeArguments(false);
2262         }
2263         Name refName;
2264         ReferenceMode refMode;
2265         if (token.kind == NEW) {
2266             refMode = ReferenceMode.NEW;
2267             refName = names.init;
2268             nextToken();
2269         } else {
2270             refMode = ReferenceMode.INVOKE;
2271             refName = ident();
2272         }
2273         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2274     }
2275 
2276     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2277      */
2278     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2279         final JCModifiers mods = modifiersOpt();
2280         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;
2281         if (!newAnnotations.isEmpty()) {
2282             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);
2283         }
2284         switch (token.kind) {
2285         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2286         case DOUBLE: case BOOLEAN:
2287             if (mods.flags != 0) {
2288                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2289                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2290             }
2291             if (typeArgs == null) {
2292                 if (newAnnotations.isEmpty()) {
2293                     return arrayCreatorRest(newpos, basicType());
2294                 } else {
2295                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2296                 }
2297             }
2298             break;
2299         default:
2300         }
2301         JCExpression t = qualident(true);
2302 
2303         int oldmode = mode;
2304         selectTypeMode();
2305         boolean diamondFound = false;
2306         int lastTypeargsPos = -1;
2307         if (token.kind == LT) {
2308             lastTypeargsPos = token.pos;
2309             t = typeArguments(t, true);
2310             diamondFound = (mode &amp; DIAMOND) != 0;
2311         }
2312         while (token.kind == DOT) {
2313             if (diamondFound) {
2314                 //cannot select after a diamond
2315                 illegal();
2316             }
2317             int pos = token.pos;
2318             nextToken();
2319             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2320             t = toP(F.at(pos).Select(t, ident()));
2321 
2322             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2323                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2324             }
2325 
2326             if (token.kind == LT) {
2327                 lastTypeargsPos = token.pos;
2328                 t = typeArguments(t, true);
2329                 diamondFound = (mode &amp; DIAMOND) != 0;
2330             }
2331         }
2332         mode = oldmode;
2333         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2334             // handle type annotations for non primitive arrays
2335             if (newAnnotations.nonEmpty()) {
2336                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2337             }
2338 
2339             JCExpression e = arrayCreatorRest(newpos, t);
2340             if (diamondFound) {
2341                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2342                 return toP(F.at(newpos).Erroneous(List.of(e)));
2343             }
2344             else if (typeArgs != null) {
2345                 int pos = newpos;
2346                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2347                     // note: this should always happen but we should
2348                     // not rely on this as the parser is continuously
2349                     // modified to improve error recovery.
2350                     pos = typeArgs.head.pos;
2351                 }
2352                 setErrorEndPos(S.prevToken().endPos);
2353                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2354                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2355                 return toP(err);
2356             }
2357             return e;
2358         } else if (token.kind == LPAREN) {
2359             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);
2360             if (badModifiers != 0)
2361                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2362             // handle type annotations for instantiations and anonymous classes
2363             if (newAnnotations.nonEmpty()) {
2364                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2365             }
2366             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);
2367             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {
2368                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2369                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2370             }
2371             return newClass;
2372         } else {
2373             setErrorEndPos(token.pos);
2374             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2375             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2376             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2377         }
2378     }
2379 
2380     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2381      */
2382     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2383         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2384 
2385         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2386 
2387         if (newAnnotations.nonEmpty()) {
2388             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2389         }
2390 
2391         if (token.kind == LT) {
2392             int oldmode = mode;
2393             t = typeArguments(t, true);
2394             mode = oldmode;
2395         }
2396         return classCreatorRest(newpos, encl, typeArgs, t, 0);
2397     }
2398 
2399     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2400      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2401      */
2402     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2403         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2404 
2405         accept(LBRACKET);
2406         if (token.kind == RBRACKET) {
2407             accept(RBRACKET);
2408             elemtype = bracketsOpt(elemtype, annos);
2409             if (token.kind == LBRACE) {
2410                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2411                 if (annos.nonEmpty()) {
2412                     // when an array initializer is present then
2413                     // the parsed annotations should target the
2414                     // new array tree
2415                     // bracketsOpt inserts the annotation in
2416                     // elemtype, and it needs to be corrected
2417                     //
2418                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2419                     assert annotated.annotations == annos;
2420                     na.annotations = annotated.annotations;
2421                     na.elemtype = annotated.underlyingType;
2422                 }
2423                 return na;
2424             } else {
2425                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2426                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2427             }
2428         } else {
2429             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2430 
2431             // maintain array dimension type annotations
2432             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2433             dimAnnotations.append(annos);
2434 
2435             dims.append(parseExpression());
2436             accept(RBRACKET);
2437             while (token.kind == LBRACKET
2438                     || token.kind == MONKEYS_AT) {
2439                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2440                 int pos = token.pos;
2441                 nextToken();
2442                 if (token.kind == RBRACKET) {
2443                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2444                 } else {
2445                     if (token.kind == RBRACKET) { // no dimension
2446                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2447                     } else {
2448                         dimAnnotations.append(maybeDimAnnos);
2449                         dims.append(parseExpression());
2450                         accept(RBRACKET);
2451                     }
2452                 }
2453             }
2454 
2455             List&lt;JCExpression&gt; elems = null;
2456             int errpos = token.pos;
2457 
2458             if (token.kind == LBRACE) {
2459                 elems = arrayInitializerElements(newpos, elemtype);
2460             }
2461 
2462             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2463             na.dimAnnotations = dimAnnotations.toList();
2464 
2465             if (elems != null) {
2466                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2467             }
2468 
2469             return na;
2470         }
2471     }
2472 
2473     /** ClassCreatorRest = Arguments [ClassBody]
2474      */
2475     JCNewClass classCreatorRest(int newpos,
2476                                   JCExpression encl,
2477                                   List&lt;JCExpression&gt; typeArgs,
2478                                   JCExpression t,
2479                                   long flags)
2480     {
2481         List&lt;JCExpression&gt; args = arguments();
2482         JCClassDecl body = null;
2483         if (token.kind == LBRACE) {
2484             int pos = token.pos;
2485             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2486             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);
2487             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2488         }
2489         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2490         return newClass;
2491     }
2492 
2493     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2494      */
2495     JCExpression arrayInitializer(int newpos, JCExpression t) {
2496         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2497         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2498     }
2499 
2500     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2501         accept(LBRACE);
2502         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2503         if (token.kind == COMMA) {
2504             nextToken();
2505         } else if (token.kind != RBRACE) {
2506             elems.append(variableInitializer());
2507             while (token.kind == COMMA) {
2508                 nextToken();
2509                 if (token.kind == RBRACE) break;
2510                 elems.append(variableInitializer());
2511             }
2512         }
2513         accept(RBRACE);
2514         return elems.toList();
2515     }
2516 
2517     /** VariableInitializer = ArrayInitializer | Expression
2518      */
2519     public JCExpression variableInitializer() {
2520         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2521     }
2522 
2523     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2524      */
2525     JCExpression parExpression() {
2526         int pos = token.pos;
2527         accept(LPAREN);
2528         JCExpression t = parseExpression();
2529         accept(RPAREN);
2530         return toP(F.at(pos).Parens(t));
2531     }
2532 
2533     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2534      */
2535     JCBlock block(int pos, long flags) {
2536         accept(LBRACE);
2537         List&lt;JCStatement&gt; stats = blockStatements();
2538         JCBlock t = F.at(pos).Block(flags, stats);
2539         while (token.kind == CASE || token.kind == DEFAULT) {
2540             syntaxError(token.pos, Errors.Orphaned(token.kind));
2541             switchBlockStatementGroups();
2542         }
2543         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2544         // usually but not necessarily the last char of the last token.
2545         t.endpos = token.pos;
2546         accept(RBRACE);
2547         return toP(t);
2548     }
2549 
2550     public JCBlock block() {
2551         return block(token.pos, 0);
2552     }
2553 
2554     /** BlockStatements = { BlockStatement }
2555      *  BlockStatement  = LocalVariableDeclarationStatement
2556      *                  | ClassOrInterfaceOrEnumDeclaration
2557      *                  | [Ident &quot;:&quot;] Statement
2558      *  LocalVariableDeclarationStatement
2559      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2560      */
2561     @SuppressWarnings(&quot;fallthrough&quot;)
2562     List&lt;JCStatement&gt; blockStatements() {
2563         //todo: skip to anchor on error(?)
2564         int lastErrPos = -1;
2565         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2566         while (true) {
2567             List&lt;JCStatement&gt; stat = blockStatement();
2568             if (stat.isEmpty()) {
2569                 return stats.toList();
2570             } else {
2571                 // error recovery
2572                 if (token.pos == lastErrPos)
2573                     return stats.toList();
2574                 if (token.pos &lt;= endPosTable.errorEndPos) {
2575                     skip(false, true, true, true);
2576                     lastErrPos = token.pos;
2577                 }
2578                 stats.addAll(stat);
2579             }
2580         }
2581     }
2582 
2583     /*
2584      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2585      * this method will also recognize variable and class declarations (which are
2586      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2587      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2588      * and an error will be produced by this method.
2589      */
2590     JCStatement parseStatementAsBlock() {
2591         int pos = token.pos;
2592         List&lt;JCStatement&gt; stats = blockStatement();
2593         if (stats.isEmpty()) {
2594             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2595             return toP(F.at(pos).Exec(e));
2596         } else {
2597             JCStatement first = stats.head;
2598             Error error = null;
2599             switch (first.getTag()) {
2600             case CLASSDEF:
2601                 error = Errors.ClassNotAllowed;
2602                 break;
2603             case VARDEF:
2604                 error = Errors.VariableNotAllowed;
2605                 break;
2606             }
2607             if (error != null) {
2608                 log.error(DiagnosticFlag.SYNTAX, first, error);
2609                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2610                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2611             }
2612             return first;
2613         }
2614     }
2615 
2616     /**This method parses a statement appearing inside a block.
2617      */
2618     @SuppressWarnings(&quot;fallthrough&quot;)
2619     List&lt;JCStatement&gt; blockStatement() {
2620         //todo: skip to anchor on error(?)
2621         token = recastToken(token);
2622         Comment dc;
2623         int pos = token.pos;
2624         switch (token.kind) {
2625         case RBRACE: case CASE: case DEFAULT: case EOF:
2626             return List.nil();
2627         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2628         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2629         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2630         case ASSERT:
2631             return List.of(parseSimpleStatement());
2632         case VALUE:
2633         case MONKEYS_AT:
2634         case FINAL: {
2635             dc = token.comment(CommentStyle.JAVADOC);
2636             JCModifiers mods = modifiersOpt();
2637             if (token.kind == INTERFACE ||
2638                 token.kind == CLASS ||
2639                 token.kind == ENUM ||
2640                 isRecordStart()) {
2641                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2642             } else {
2643                 JCExpression t = parseType(true);
2644                 return localVariableDeclarations(mods, t);
2645             }
2646         }
2647         case ABSTRACT: case STRICTFP: {
2648             dc = token.comment(CommentStyle.JAVADOC);
2649             JCModifiers mods = modifiersOpt();
2650             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2651         }
2652         case INTERFACE:
2653         case CLASS:
2654             dc = token.comment(CommentStyle.JAVADOC);
2655             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2656         case ENUM:
2657             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2658             dc = token.comment(CommentStyle.JAVADOC);
2659             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2660         case IDENTIFIER:
2661             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2662                 Token next = S.token(1);
2663                 boolean isYieldStatement;
2664                 switch (next.kind) {
2665                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2666                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2667                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2668                     case NEW: case SWITCH: case THIS: case SUPER:
2669                         isYieldStatement = true;
2670                         break;
2671                     case PLUSPLUS: case SUBSUB:
2672                         isYieldStatement = S.token(2).kind != SEMI;
2673                         break;
2674                     case LPAREN:
2675                         int lookahead = 2;
2676                         int balance = 1;
2677                         boolean hasComma = false;
2678                         Token l;
2679                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2680                             switch (l.kind) {
2681                                 case LPAREN: balance++; break;
2682                                 case RPAREN: balance--; break;
2683                                 case COMMA: if (balance == 1) hasComma = true; break;
2684                             }
2685                             lookahead++;
2686                         }
2687                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2688                         break;
2689                     case SEMI: //error recovery - this is not a valid statement:
2690                         isYieldStatement = true;
2691                         break;
2692                     default:
2693                         isYieldStatement = false;
2694                         break;
2695                 }
2696 
2697                 if (isYieldStatement) {
2698                     nextToken();
2699                     JCExpression t = term(EXPR);
2700                     accept(SEMI);
2701                     return List.of(toP(F.at(pos).Yield(t)));
2702                 }
2703 
2704                 //else intentional fall-through
2705             }
2706         }
2707         if (isRecordStart() &amp;&amp; allowRecords) {
2708             dc = token.comment(CommentStyle.JAVADOC);
2709             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2710         } else {
2711             Token prevToken = token;
2712             JCExpression t = term(EXPR | TYPE);
2713             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2714                 nextToken();
2715                 JCStatement stat = parseStatementAsBlock();
2716                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2717             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2718                 pos = token.pos;
2719                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2720                 F.at(pos);
2721                 return localVariableDeclarations(mods, t);
2722             } else {
2723                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2724                 t = checkExprStat(t);
2725                 accept(SEMI);
2726                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2727                 return List.of(expr);
2728             }
2729         }
2730     }
2731     //where
2732         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2733             ListBuffer&lt;JCStatement&gt; stats =
2734                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2735             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2736             accept(SEMI);
2737             storeEnd(stats.last(), S.prevToken().endPos);
2738             return stats.toList();
2739         }
2740 
2741     /** Statement =
2742      *       Block
2743      *     | IF ParExpression Statement [ELSE Statement]
2744      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2745      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2746      *     | WHILE ParExpression Statement
2747      *     | DO Statement WHILE ParExpression &quot;;&quot;
2748      *     | TRY Block ( Catches | [Catches] FinallyPart )
2749      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2750      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2751      *     | SYNCHRONIZED ParExpression Block
2752      *     | RETURN [Expression] &quot;;&quot;
2753      *     | THROW Expression &quot;;&quot;
2754      *     | BREAK [Ident] &quot;;&quot;
2755      *     | CONTINUE [Ident] &quot;;&quot;
2756      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2757      *     | &quot;;&quot;
2758      */
2759     public JCStatement parseSimpleStatement() {
2760         int pos = token.pos;
2761         switch (token.kind) {
2762         case LBRACE:
2763             return block();
2764         case IF: {
2765             nextToken();
2766             JCExpression cond = parExpression();
2767             JCStatement thenpart = parseStatementAsBlock();
2768             JCStatement elsepart = null;
2769             if (token.kind == ELSE) {
2770                 nextToken();
2771                 elsepart = parseStatementAsBlock();
2772             }
2773             return F.at(pos).If(cond, thenpart, elsepart);
2774         }
2775         case FOR: {
2776             nextToken();
2777             accept(LPAREN);
2778             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2779             if (inits.length() == 1 &amp;&amp;
2780                 inits.head.hasTag(VARDEF) &amp;&amp;
2781                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2782                 token.kind == COLON) {
2783                 JCVariableDecl var = (JCVariableDecl)inits.head;
2784                 accept(COLON);
2785                 JCExpression expr = parseExpression();
2786                 accept(RPAREN);
2787                 JCStatement body = parseStatementAsBlock();
2788                 return F.at(pos).ForeachLoop(var, expr, body);
2789             } else {
2790                 accept(SEMI);
2791                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2792                 accept(SEMI);
2793                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2794                 accept(RPAREN);
2795                 JCStatement body = parseStatementAsBlock();
2796                 return F.at(pos).ForLoop(inits, cond, steps, body);
2797             }
2798         }
2799         case WHILE: {
2800             nextToken();
2801             JCExpression cond = parExpression();
2802             JCStatement body = parseStatementAsBlock();
2803             return F.at(pos).WhileLoop(cond, body);
2804         }
2805         case DO: {
2806             nextToken();
2807             JCStatement body = parseStatementAsBlock();
2808             accept(WHILE);
2809             JCExpression cond = parExpression();
2810             accept(SEMI);
2811             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2812             return t;
2813         }
2814         case TRY: {
2815             nextToken();
2816             List&lt;JCTree&gt; resources = List.nil();
2817             if (token.kind == LPAREN) {
2818                 nextToken();
2819                 resources = resources();
2820                 accept(RPAREN);
2821             }
2822             JCBlock body = block();
2823             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2824             JCBlock finalizer = null;
2825             if (token.kind == CATCH || token.kind == FINALLY) {
2826                 while (token.kind == CATCH) catchers.append(catchClause());
2827                 if (token.kind == FINALLY) {
2828                     nextToken();
2829                     finalizer = block();
2830                 }
2831             } else {
2832                 if (resources.isEmpty()) {
2833                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2834                 }
2835             }
2836             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2837         }
2838         case SWITCH: {
2839             nextToken();
2840             JCExpression selector = parExpression();
2841             accept(LBRACE);
2842             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2843             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2844             accept(RBRACE);
2845             return t;
2846         }
2847         case SYNCHRONIZED: {
2848             nextToken();
2849             JCExpression lock = parExpression();
2850             JCBlock body = block();
2851             return F.at(pos).Synchronized(lock, body);
2852         }
2853         case RETURN: {
2854             nextToken();
2855             JCExpression result = token.kind == SEMI ? null : parseExpression();
2856             accept(SEMI);
2857             JCReturn t = toP(F.at(pos).Return(result));
2858             return t;
2859         }
2860         case THROW: {
2861             nextToken();
2862             JCExpression exc = parseExpression();
2863             accept(SEMI);
2864             JCThrow t = toP(F.at(pos).Throw(exc));
2865             return t;
2866         }
2867         case BREAK: {
2868             nextToken();
2869             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2870             accept(SEMI);
2871             JCBreak t = toP(F.at(pos).Break(label));
2872             return t;
2873         }
2874         case CONTINUE: {
2875             nextToken();
2876             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2877             accept(SEMI);
2878             JCContinue t =  toP(F.at(pos).Continue(label));
2879             return t;
2880         }
2881         case SEMI:
2882             nextToken();
2883             return toP(F.at(pos).Skip());
2884         case ELSE:
2885             int elsePos = token.pos;
2886             nextToken();
2887             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2888         case FINALLY:
2889             int finallyPos = token.pos;
2890             nextToken();
2891             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2892         case CATCH:
2893             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2894         case ASSERT: {
2895             nextToken();
2896             JCExpression assertion = parseExpression();
2897             JCExpression message = null;
2898             if (token.kind == COLON) {
2899                 nextToken();
2900                 message = parseExpression();
2901             }
2902             accept(SEMI);
2903             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2904             return t;
2905         }
2906         default:
2907             Assert.error();
2908             return null;
2909         }
2910     }
2911 
2912     @Override
2913     public JCStatement parseStatement() {
2914         return parseStatementAsBlock();
2915     }
2916 
2917     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2918         int errPos = S.errPos();
2919         JCTree stm = action.doRecover(this);
2920         S.errPos(errPos);
2921         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2922     }
2923 
2924     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2925      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2926      */
2927     protected JCCatch catchClause() {
2928         int pos = token.pos;
2929         accept(CATCH);
2930         accept(LPAREN);
2931         JCModifiers mods = optFinal(Flags.PARAMETER);
2932         List&lt;JCExpression&gt; catchTypes = catchTypes();
2933         JCExpression paramType = catchTypes.size() &gt; 1 ?
2934                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2935                 catchTypes.head;
2936         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2937         accept(RPAREN);
2938         JCBlock body = block();
2939         return F.at(pos).Catch(formal, body);
2940     }
2941 
2942     List&lt;JCExpression&gt; catchTypes() {
2943         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2944         catchTypes.add(parseType());
2945         while (token.kind == BAR) {
2946             nextToken();
2947             // Instead of qualident this is now parseType.
2948             // But would that allow too much, e.g. arrays or generics?
2949             catchTypes.add(parseType());
2950         }
2951         return catchTypes.toList();
2952     }
2953 
2954     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2955      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2956      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2957      */
2958     List&lt;JCCase&gt; switchBlockStatementGroups() {
2959         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2960         while (true) {
2961             int pos = token.pos;
2962             switch (token.kind) {
2963             case CASE:
2964             case DEFAULT:
2965                 cases.appendList(switchBlockStatementGroup());
2966                 break;
2967             case RBRACE: case EOF:
2968                 return cases.toList();
2969             default:
2970                 nextToken(); // to ensure progress
2971                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2972             }
2973         }
2974     }
2975 
2976     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2977         int pos = token.pos;
2978         List&lt;JCStatement&gt; stats;
2979         JCCase c;
2980         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2981         switch (token.kind) {
2982         case CASE: {
2983             nextToken();
2984             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2985             while (true) {
2986                 pats.append(term(EXPR | NOLAMBDA));
2987                 if (token.kind != COMMA) break;
2988                 nextToken();
2989                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2990             };
2991             CaseTree.CaseKind caseKind;
2992             JCTree body = null;
2993             if (token.kind == ARROW) {
2994                 checkSourceLevel(Feature.SWITCH_RULE);
2995                 accept(ARROW);
2996                 caseKind = JCCase.RULE;
2997                 JCStatement statement = parseStatementAsBlock();
2998                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2999                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3000                 }
3001                 stats = List.of(statement);
3002                 body = stats.head;
3003             } else {
3004                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3005                 caseKind = JCCase.STATEMENT;
3006                 stats = blockStatements();
3007             }
3008             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
3009             if (stats.isEmpty())
3010                 storeEnd(c, S.prevToken().endPos);
3011             return cases.append(c).toList();
3012         }
3013         case DEFAULT: {
3014             nextToken();
3015             CaseTree.CaseKind caseKind;
3016             JCTree body = null;
3017             if (token.kind == ARROW) {
3018                 checkSourceLevel(Feature.SWITCH_RULE);
3019                 accept(ARROW);
3020                 caseKind = JCCase.RULE;
3021                 JCStatement statement = parseStatementAsBlock();
3022                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3023                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3024                 }
3025                 stats = List.of(statement);
3026                 body = stats.head;
3027             } else {
3028                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3029                 caseKind = JCCase.STATEMENT;
3030                 stats = blockStatements();
3031             }
3032             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3033             if (stats.isEmpty())
3034                 storeEnd(c, S.prevToken().endPos);
3035             return cases.append(c).toList();
3036         }
3037         }
3038         throw new AssertionError(&quot;should not reach here&quot;);
3039     }
3040 
3041     /** MoreStatementExpressions = { COMMA StatementExpression }
3042      */
3043     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3044                                                                     JCExpression first,
3045                                                                     T stats) {
3046         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3047         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3048         while (token.kind == COMMA) {
3049             nextToken();
3050             pos = token.pos;
3051             JCExpression t = parseExpression();
3052             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3053             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3054         }
3055         return stats;
3056     }
3057 
3058     /** ForInit = StatementExpression MoreStatementExpressions
3059      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3060      */
3061     List&lt;JCStatement&gt; forInit() {
3062         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3063         int pos = token.pos;
3064         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3065             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3066         } else {
3067             JCExpression t = term(EXPR | TYPE);
3068             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3069                 pos = token.pos;
3070                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
3071                 F.at(pos);
3072                 return variableDeclarators(mods, t, stats, true).toList();
3073             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3074                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3075                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3076             } else {
3077                 return moreStatementExpressions(pos, t, stats).toList();
3078             }
3079         }
3080     }
3081 
3082     /** ForUpdate = StatementExpression MoreStatementExpressions
3083      */
3084     List&lt;JCExpressionStatement&gt; forUpdate() {
3085         return moreStatementExpressions(token.pos,
3086                                         parseExpression(),
3087                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3088     }
3089 
3090     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3091      *
3092      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3093      */
3094     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3095         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3096         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3097         int prevmode = mode;
3098         while (token.kind == MONKEYS_AT) {
3099             int pos = token.pos;
3100             nextToken();
3101             buf.append(annotation(pos, kind));
3102         }
3103         lastmode = mode;
3104         mode = prevmode;
3105         List&lt;JCAnnotation&gt; annotations = buf.toList();
3106 
3107         return annotations;
3108     }
3109 
3110     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3111         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3112         return annotations;
3113     }
3114 
3115     /** ModifiersOpt = { Modifier }
3116      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3117      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3118      *           | &quot;@&quot; Annotation
3119      */
3120     protected JCModifiers modifiersOpt() {
3121         return modifiersOpt(null);
3122     }
3123     protected JCModifiers modifiersOpt(JCModifiers partial) {
3124         long flags;
3125         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3126         int pos;
3127         if (partial == null) {
3128             flags = 0;
3129             pos = token.pos;
3130         } else {
3131             flags = partial.flags;
3132             annotations.appendList(partial.annotations);
3133             pos = partial.pos;
3134         }
3135         if (token.deprecatedFlag()) {
3136             flags |= Flags.DEPRECATED;
3137         }
3138         int lastPos;
3139     loop:
3140         while (true) {
3141             long flag;
3142             token = recastToken(token);
3143             switch (token.kind) {
3144             case PRIVATE     : flag = Flags.PRIVATE; break;
3145             case PROTECTED   : flag = Flags.PROTECTED; break;
3146             case PUBLIC      : flag = Flags.PUBLIC; break;
3147             case STATIC      : flag = Flags.STATIC; break;
3148             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3149             case FINAL       : flag = Flags.FINAL; break;
3150             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3151             case NATIVE      : flag = Flags.NATIVE; break;
3152             case VALUE       : flag = Flags.VALUE; break;
3153             case VOLATILE    : flag = Flags.VOLATILE; break;
3154             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3155             case STRICTFP    : flag = Flags.STRICTFP; break;
3156             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3157             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3158             case ERROR       : flag = 0; nextToken(); break;
3159             default: break loop;
3160             }
3161             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3162             lastPos = token.pos;
3163             nextToken();
3164             if (flag == Flags.ANNOTATION) {
3165                 if (token.kind != INTERFACE) {
3166                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3167                     // if first modifier is an annotation, set pos to annotation&#39;s.
3168                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3169                         pos = ann.pos;
3170                     final Name name = TreeInfo.name(ann.annotationType);
3171                     if (name == names.__inline__ || name == names.java_lang___inline__) {
3172                         flag = Flags.VALUE;
3173                     } else {
3174                         annotations.append(ann);
3175                         flag = 0;
3176                     }
3177                 }
3178             }
3179             flags |= flag;
3180         }
3181         switch (token.kind) {
3182         case ENUM: flags |= Flags.ENUM; break;
3183         case INTERFACE: flags |= Flags.INTERFACE; break;
3184         default: break;
3185         }
3186 
3187         /* A modifiers tree with no modifier tokens or annotations
3188          * has no text position. */
3189         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3190             pos = Position.NOPOS;
3191 
3192         // Force value classes to be automatically final.
3193         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {
3194             flags |= Flags.FINAL;
3195         }
3196 
3197         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3198         if (pos != Position.NOPOS)
3199             storeEnd(mods, S.prevToken().endPos);
3200         return mods;
3201     }
3202 
3203     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3204      *
3205      * @param pos position of &quot;@&quot; token
3206      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3207      */
3208     JCAnnotation annotation(int pos, Tag kind) {
3209         // accept(AT); // AT consumed by caller
3210         if (kind == Tag.TYPE_ANNOTATION) {
3211             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3212         }
3213         JCTree ident = qualident(false);
3214         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3215         JCAnnotation ann;
3216         if (kind == Tag.ANNOTATION) {
3217             ann = F.at(pos).Annotation(ident, fieldValues);
3218         } else if (kind == Tag.TYPE_ANNOTATION) {
3219             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3220         } else {
3221             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3222         }
3223 
3224         storeEnd(ann, S.prevToken().endPos);
3225         return ann;
3226     }
3227 
3228     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3229         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3230     }
3231 
3232     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3233     List&lt;JCExpression&gt; annotationFieldValues() {
3234         accept(LPAREN);
3235         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3236         if (token.kind != RPAREN) {
3237             buf.append(annotationFieldValue());
3238             while (token.kind == COMMA) {
3239                 nextToken();
3240                 buf.append(annotationFieldValue());
3241             }
3242         }
3243         accept(RPAREN);
3244         return buf.toList();
3245     }
3246 
3247     /** AnnotationFieldValue    = AnnotationValue
3248      *                          | Identifier &quot;=&quot; AnnotationValue
3249      */
3250     JCExpression annotationFieldValue() {
3251         if (LAX_IDENTIFIER.accepts(token.kind)) {
3252             selectExprMode();
3253             JCExpression t1 = term1();
3254             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3255                 int pos = token.pos;
3256                 accept(EQ);
3257                 JCExpression v = annotationValue();
3258                 return toP(F.at(pos).Assign(t1, v));
3259             } else {
3260                 return t1;
3261             }
3262         }
3263         return annotationValue();
3264     }
3265 
3266     /* AnnotationValue          = ConditionalExpression
3267      *                          | Annotation
3268      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3269      */
3270     JCExpression annotationValue() {
3271         int pos;
3272         switch (token.kind) {
3273         case MONKEYS_AT:
3274             pos = token.pos;
3275             nextToken();
3276             return annotation(pos, Tag.ANNOTATION);
3277         case LBRACE:
3278             pos = token.pos;
3279             accept(LBRACE);
3280             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3281             if (token.kind == COMMA) {
3282                 nextToken();
3283             } else if (token.kind != RBRACE) {
3284                 buf.append(annotationValue());
3285                 while (token.kind == COMMA) {
3286                     nextToken();
3287                     if (token.kind == RBRACE) break;
3288                     buf.append(annotationValue());
3289                 }
3290             }
3291             accept(RBRACE);
3292             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3293         default:
3294             selectExprMode();
3295             return term1();
3296         }
3297     }
3298 
3299     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3300      */
3301     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3302                                                                          JCExpression type,
3303                                                                          T vdefs,
3304                                                                          boolean localDecl)
3305     {
3306         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3307     }
3308 
3309     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3310      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3311      *
3312      *  @param reqInit  Is an initializer always required?
3313      *  @param dc       The documentation comment for the variable declarations, or null.
3314      */
3315     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3316                                                                      JCModifiers mods,
3317                                                                      JCExpression type,
3318                                                                      Name name,
3319                                                                      boolean reqInit,
3320                                                                      Comment dc,
3321                                                                      T vdefs,
3322                                                                      boolean localDecl)
3323     {
3324         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3325         vdefs.append(head);
3326         while (token.kind == COMMA) {
3327             // All but last of multiple declarators subsume a comma
3328             storeEnd((JCTree)vdefs.last(), token.endPos);
3329             nextToken();
3330             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3331         }
3332         return vdefs;
3333     }
3334 
3335     /** VariableDeclarator = Ident VariableDeclaratorRest
3336      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3337      */
3338     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3339         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3340     }
3341 
3342     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3343      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3344      *
3345      *  @param reqInit  Is an initializer always required?
3346      *  @param dc       The documentation comment for the variable declarations, or null.
3347      */
3348     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3349                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3350         type = bracketsOpt(type);
3351         JCExpression init = null;
3352         if (token.kind == EQ) {
3353             nextToken();
3354             init = variableInitializer();
3355         }
3356         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3357         JCTree elemType = TreeInfo.innermostType(type, true);
3358         int startPos = Position.NOPOS;
3359         if (elemType.hasTag(IDENT)) {
3360             Name typeName = ((JCIdent)elemType).name;
3361             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3362                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3363                     //error - &#39;var&#39; and arrays
3364                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3365                 } else {
3366                     if(compound)
3367                         //error - &#39;var&#39; in compound local var decl
3368                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3369                     startPos = TreeInfo.getStartPos(mods);
3370                     if (startPos == Position.NOPOS)
3371                         startPos = TreeInfo.getStartPos(type);
3372                     //implicit type
3373                     type = null;
3374                 }
3375             }
3376         }
3377         JCVariableDecl result =
3378             toP(F.at(pos).VarDef(mods, name, type, init));
3379         attach(result, dc);
3380         result.startPos = startPos;
3381         return result;
3382     }
3383 
3384     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.
3385     Token recastToken(Token token) {
3386         if (token.kind != IDENTIFIER || token.name() != names.inline) {
3387             return token;
3388         }
3389         if (peekToken(t-&gt;t == PRIVATE ||
3390                          t == PROTECTED ||
3391                          t == PUBLIC ||
3392                          t == STATIC ||
3393                          t == TRANSIENT ||
3394                          t == FINAL ||
3395                          t == ABSTRACT ||
3396                          t == NATIVE ||
3397                          t == VOLATILE ||
3398                          t == SYNCHRONIZED ||
3399                          t == STRICTFP ||
3400                          t == MONKEYS_AT ||
3401                          t == DEFAULT ||
3402                          t == BYTE ||
3403                          t == SHORT ||
3404                          t == CHAR ||
3405                          t == INT ||
3406                          t == LONG ||
3407                          t == FLOAT ||
3408                          t == DOUBLE ||
3409                          t == BOOLEAN ||
3410                          t == CLASS ||
3411                          t == INTERFACE ||
3412                          t == ENUM ||
3413                          t == IDENTIFIER)) { // new value Comparable() {}
3414             checkSourceLevel(Feature.INLINE_TYPES);
3415             return new Token(VALUE, token.pos, token.endPos, token.comments);
3416         }
3417         return token;
3418     }
3419 
3420     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3421         switch (e.getTag()) {
3422             case IDENT:
3423                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3424             case TYPEARRAY:
3425                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3426             default:
3427                 return null;
3428         }
3429     }
3430 
3431     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3432         if (name == names.var) {
3433             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3434                 return Source.JDK10;
3435             } else if (shouldWarn) {
3436                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3437             }
3438         }
3439         if (name == names.yield) {
3440             if (allowYieldStatement) {
3441                 return Source.JDK14;
3442             } else if (shouldWarn) {
3443                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3444             }
3445         }
3446         if (name == names.record) {
3447             if (allowRecords) {
3448                 return Source.JDK14;
3449             } else if (shouldWarn) {
3450                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3451             }
3452         }
3453         return null;
3454     }
3455 
3456     /** VariableDeclaratorId = Ident BracketsOpt
3457      */
3458     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3459         return variableDeclaratorId(mods, type, false);
3460     }
3461     //where
3462     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3463         int pos = token.pos;
3464         Name name;
3465         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3466             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3467             name = token.name();
3468             nextToken();
3469         } else {
3470             if (allowThisIdent ||
3471                 !lambdaParameter ||
3472                 LAX_IDENTIFIER.accepts(token.kind) ||
3473                 mods.flags != Flags.PARAMETER ||
3474                 mods.annotations.nonEmpty()) {
3475                 JCExpression pn = qualident(false);
3476                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3477                     name = ((JCIdent)pn).name;
3478                 } else {
3479                     if (allowThisIdent) {
3480                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3481                             log.error(token.pos, Errors.VarargsAndReceiver);
3482                         }
3483                         if (token.kind == LBRACKET) {
3484                             log.error(token.pos, Errors.ArrayAndReceiver);
3485                         }
3486                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3487                             log.error(token.pos, Errors.WrongReceiver);
3488                         }
3489                     }
3490                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3491                 }
3492             } else {
3493                 /** if it is a lambda parameter and the token kind is not an identifier,
3494                  *  and there are no modifiers or annotations, then this means that the compiler
3495                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3496                  *  var or explicit parameters. So we assign the error name to the parameter name
3497                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3498                  *  a higher level.
3499                  */
3500                 name = names.empty;
3501             }
3502         }
3503         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3504                 token.kind == LBRACKET) {
3505             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3506         }
3507         type = bracketsOpt(type);
3508 
3509         return toP(F.at(pos).VarDef(mods, name, type, null));
3510     }
3511 
3512     /** Resources = Resource { &quot;;&quot; Resources }
3513      */
3514     List&lt;JCTree&gt; resources() {
3515         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3516         defs.append(resource());
3517         while (token.kind == SEMI) {
3518             // All but last of multiple declarators must subsume a semicolon
3519             storeEnd(defs.last(), token.endPos);
3520             int semiColonPos = token.pos;
3521             nextToken();
3522             if (token.kind == RPAREN) { // Optional trailing semicolon
3523                                        // after last resource
3524                 break;
3525             }
3526             defs.append(resource());
3527         }
3528         return defs.toList();
3529     }
3530 
3531     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3532      *           | Expression
3533      */
3534     protected JCTree resource() {
3535         int startPos = token.pos;
3536         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3537             JCModifiers mods = optFinal(Flags.FINAL);
3538             JCExpression t = parseType(true);
3539             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3540         }
3541         JCExpression t = term(EXPR | TYPE);
3542         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3543             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3544             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3545         } else {
3546             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3547             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3548                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3549             }
3550 
3551             return t;
3552         }
3553     }
3554 
3555     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3556      */
3557     public JCTree.JCCompilationUnit parseCompilationUnit() {
3558         Token firstToken = token;
3559         JCModifiers mods = null;
3560         boolean consumedToplevelDoc = false;
3561         boolean seenImport = false;
3562         boolean seenPackage = false;
3563         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3564         if (token.kind == MONKEYS_AT)
3565             mods = modifiersOpt();
3566 
3567         if (token.kind == PACKAGE) {
3568             int packagePos = token.pos;
3569             List&lt;JCAnnotation&gt; annotations = List.nil();
3570             seenPackage = true;
3571             if (mods != null) {
3572                 checkNoMods(mods.flags);
3573                 annotations = mods.annotations;
3574                 mods = null;
3575             }
3576             nextToken();
3577             JCExpression pid = qualident(false);
3578             accept(SEMI);
3579             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3580             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3581             consumedToplevelDoc = true;
3582             defs.append(pd);
3583         }
3584 
3585         boolean checkForImports = true;
3586         boolean firstTypeDecl = true;
3587         while (token.kind != EOF) {
3588             if (token.pos &lt;= endPosTable.errorEndPos) {
3589                 // error recovery
3590                 skip(checkForImports, false, false, false);
3591                 if (token.kind == EOF)
3592                     break;
3593             }
3594             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3595                 seenImport = true;
3596                 defs.append(importDeclaration());
3597             } else {
3598                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3599                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3600                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3601                     consumedToplevelDoc = true;
3602                 }
3603                 if (mods != null || token.kind != SEMI)
3604                     mods = modifiersOpt(mods);
3605                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3606                     ModuleKind kind = ModuleKind.STRONG;
3607                     if (token.name() == names.open) {
3608                         kind = ModuleKind.OPEN;
3609                         nextToken();
3610                     }
3611                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3612                         if (mods != null) {
3613                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3614                         }
3615                         defs.append(moduleDecl(mods, kind, docComment));
3616                         consumedToplevelDoc = true;
3617                         break;
3618                     } else if (kind != ModuleKind.STRONG) {
3619                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3620                     }
3621                 }
3622                 JCTree def = typeDeclaration(mods, docComment);
3623                 if (def instanceof JCExpressionStatement)
3624                     def = ((JCExpressionStatement)def).expr;
3625                 defs.append(def);
3626                 if (def instanceof JCClassDecl)
3627                     checkForImports = false;
3628                 mods = null;
3629                 firstTypeDecl = false;
3630             }
3631         }
3632         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3633         if (!consumedToplevelDoc)
3634             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3635         if (defs.isEmpty())
3636             storeEnd(toplevel, S.prevToken().endPos);
3637         if (keepDocComments)
3638             toplevel.docComments = docComments;
3639         if (keepLineMap)
3640             toplevel.lineMap = S.getLineMap();
3641         this.endPosTable.setParser(null); // remove reference to parser
3642         toplevel.endPositions = this.endPosTable;
3643         return toplevel;
3644     }
3645 
3646     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3647         int pos = token.pos;
3648         checkSourceLevel(Feature.MODULES);
3649 
3650         nextToken();
3651         JCExpression name = qualident(false);
3652         List&lt;JCDirective&gt; directives = null;
3653 
3654         accept(LBRACE);
3655         directives = moduleDirectiveList();
3656         accept(RBRACE);
3657         accept(EOF);
3658 
3659         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3660         attach(result, dc);
3661         return result;
3662     }
3663 
3664     List&lt;JCDirective&gt; moduleDirectiveList() {
3665         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3666         while (token.kind == IDENTIFIER) {
3667             int pos = token.pos;
3668             if (token.name() == names.requires) {
3669                 nextToken();
3670                 boolean isTransitive = false;
3671                 boolean isStaticPhase = false;
3672             loop:
3673                 while (true) {
3674                     switch (token.kind) {
3675                         case IDENTIFIER:
3676                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3677                                 Token t1 = S.token(1);
3678                                 if (t1.kind == SEMI || t1.kind == DOT) {
3679                                     break loop;
3680                                 }
3681                                 isTransitive = true;
3682                                 break;
3683                             } else {
3684                                 break loop;
3685                             }
3686                         case STATIC:
3687                             if (isStaticPhase) {
3688                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3689                             }
3690                             isStaticPhase = true;
3691                             break;
3692                         default:
3693                             break loop;
3694                     }
3695                     nextToken();
3696                 }
3697                 JCExpression moduleName = qualident(false);
3698                 accept(SEMI);
3699                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3700             } else if (token.name() == names.exports || token.name() == names.opens) {
3701                 boolean exports = token.name() == names.exports;
3702                 nextToken();
3703                 JCExpression pkgName = qualident(false);
3704                 List&lt;JCExpression&gt; moduleNames = null;
3705                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3706                     nextToken();
3707                     moduleNames = qualidentList(false);
3708                 }
3709                 accept(SEMI);
3710                 JCDirective d;
3711                 if (exports) {
3712                     d = F.at(pos).Exports(pkgName, moduleNames);
3713                 } else {
3714                     d = F.at(pos).Opens(pkgName, moduleNames);
3715                 }
3716                 defs.append(toP(d));
3717             } else if (token.name() == names.provides) {
3718                 nextToken();
3719                 JCExpression serviceName = qualident(false);
3720                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3721                     nextToken();
3722                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3723                     accept(SEMI);
3724                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3725                 } else {
3726                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3727                     skip(false, false, false, false);
3728                 }
3729             } else if (token.name() == names.uses) {
3730                 nextToken();
3731                 JCExpression service = qualident(false);
3732                 accept(SEMI);
3733                 defs.append(toP(F.at(pos).Uses(service)));
3734             } else {
3735                 setErrorEndPos(pos);
3736                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3737                 break;
3738             }
3739         }
3740         return defs.toList();
3741     }
3742 
3743     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3744      */
3745     protected JCTree importDeclaration() {
3746         int pos = token.pos;
3747         nextToken();
3748         boolean importStatic = false;
3749         if (token.kind == STATIC) {
3750             importStatic = true;
3751             nextToken();
3752         }
3753         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3754         do {
3755             int pos1 = token.pos;
3756             accept(DOT);
3757             if (token.kind == STAR) {
3758                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3759                 nextToken();
3760                 break;
3761             } else {
3762                 pid = toP(F.at(pos1).Select(pid, ident()));
3763             }
3764         } while (token.kind == DOT);
3765         accept(SEMI);
3766         return toP(F.at(pos).Import(pid, importStatic));
3767     }
3768 
3769     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3770      *                  | &quot;;&quot;
3771      */
3772     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3773         int pos = token.pos;
3774         if (mods == null &amp;&amp; token.kind == SEMI) {
3775             nextToken();
3776             return toP(F.at(pos).Skip());
3777         } else {
3778             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3779         }
3780     }
3781 
3782     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3783      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3784      *  @param mods     Any modifiers starting the class or interface declaration
3785      *  @param dc       The documentation comment for the class, or null.
3786      */
3787     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3788         if (token.kind == CLASS) {
3789             return classDeclaration(mods, dc);
3790         } if (isRecordStart()) {
3791             return recordDeclaration(mods, dc);
3792         } else if (token.kind == INTERFACE) {
3793             return interfaceDeclaration(mods, dc);
3794         } else if (token.kind == ENUM) {
3795             return enumDeclaration(mods, dc);
3796         } else {
3797             int pos = token.pos;
3798             List&lt;JCTree&gt; errs;
3799             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3800                 checkSourceLevel(Feature.RECORDS);
3801                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3802                 return toP(F.Exec(erroneousTree));
3803             } else {
3804                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3805                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3806                     setErrorEndPos(token.pos);
3807                 } else {
3808                     errs = List.of(mods);
3809                 }
3810                 final JCErroneous erroneousTree;
3811                 if (parseModuleInfo) {
3812                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3813                 } else {
3814                     if (allowRecords) {
3815                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3816                     } else {
3817                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3818                     }
3819                 }
3820                 return toP(F.Exec(erroneousTree));
3821             }
3822         }
3823     }
3824 
3825     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3826      *                     [IMPLEMENTS TypeList] ClassBody
3827      *  @param mods    The modifiers starting the class declaration
3828      *  @param dc       The documentation comment for the class, or null.
3829      */
3830     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3831         int pos = token.pos;
3832         accept(CLASS);
3833         Name name = typeName();
3834 
3835         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3836 
3837         JCExpression extending = null;
3838         if (token.kind == EXTENDS) {
3839             nextToken();
3840             extending = parseType();
3841         }
3842         List&lt;JCExpression&gt; implementing = List.nil();
3843         if (token.kind == IMPLEMENTS) {
3844             nextToken();
3845             implementing = typeList();
3846         }
3847         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3848         JCClassDecl result = toP(F.at(pos).ClassDef(
3849             mods, name, typarams, extending, implementing, defs));
3850         attach(result, dc);
3851         return result;
3852     }
3853 
3854     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3855         int pos = token.pos;
3856         nextToken();
3857         mods.flags |= Flags.RECORD;
3858         Name name = typeName();
3859 
3860         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3861 
3862         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3863 
3864         List&lt;JCExpression&gt; implementing = List.nil();
3865         if (token.kind == IMPLEMENTS) {
3866             nextToken();
3867             implementing = typeList();
3868         }
3869         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3870         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3871         for (JCVariableDecl field : headerFields) {
3872             fields.add(field);
3873         }
3874         for (JCTree def : defs) {
3875             if (def.hasTag(METHODDEF)) {
3876                 JCMethodDecl methDef = (JCMethodDecl) def;
3877                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3878                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3879                     for (JCVariableDecl param : headerFields) {
3880                         tmpParams.add(F.at(param)
3881                                 // we will get flags plus annotations from the record component
3882                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3883                                 param.name, param.vartype, null));
3884                     }
3885                     methDef.params = tmpParams.toList();
3886                 }
3887             }
3888         }
3889         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3890             JCVariableDecl field = fields.get(i);
3891             defs = defs.prepend(field);
3892         }
3893         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3894         attach(result, dc);
3895         return result;
3896     }
3897 
3898     Name typeName() {
3899         int pos = token.pos;
3900         Name name = ident();
3901         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3902         if (source != null) {
3903             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3904         }
3905         return name;
3906     }
3907 
3908     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3909      *                         [EXTENDS TypeList] InterfaceBody
3910      *  @param mods    The modifiers starting the interface declaration
3911      *  @param dc       The documentation comment for the interface, or null.
3912      */
3913     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3914         int pos = token.pos;
3915         accept(INTERFACE);
3916 
3917         Name name = typeName();
3918 
3919         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3920 
3921         List&lt;JCExpression&gt; extending = List.nil();
3922         if (token.kind == EXTENDS) {
3923             nextToken();
3924             extending = typeList();
3925         }
3926         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3927         JCClassDecl result = toP(F.at(pos).ClassDef(
3928             mods, name, typarams, null, extending, defs));
3929         attach(result, dc);
3930         return result;
3931     }
3932 
3933     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3934      *  @param mods    The modifiers starting the enum declaration
3935      *  @param dc       The documentation comment for the enum, or null.
3936      */
3937     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3938         int pos = token.pos;
3939         accept(ENUM);
3940 
3941         Name name = typeName();
3942 
3943         List&lt;JCExpression&gt; implementing = List.nil();
3944         if (token.kind == IMPLEMENTS) {
3945             nextToken();
3946             implementing = typeList();
3947         }
3948 
3949         List&lt;JCTree&gt; defs = enumBody(name);
3950         mods.flags |= Flags.ENUM;
3951         JCClassDecl result = toP(F.at(pos).
3952             ClassDef(mods, name, List.nil(),
3953                      null, implementing, defs));
3954         attach(result, dc);
3955         return result;
3956     }
3957 
3958     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3959      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3960      */
3961     List&lt;JCTree&gt; enumBody(Name enumName) {
3962         accept(LBRACE);
3963         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3964         boolean wasSemi = false;
3965         boolean hasStructuralErrors = false;
3966         boolean wasError = false;
3967         if (token.kind == COMMA) {
3968             nextToken();
3969             if (token.kind == SEMI) {
3970                 wasSemi = true;
3971                 nextToken();
3972             } else if (token.kind != RBRACE) {
3973                 reportSyntaxError(S.prevToken().endPos,
3974                                   Errors.Expected2(RBRACE, SEMI));
3975                 wasError = true;
3976             }
3977         }
3978         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3979             if (token.kind == SEMI) {
3980                 accept(SEMI);
3981                 wasSemi = true;
3982                 if (token.kind == RBRACE || token.kind == EOF) break;
3983             }
3984             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3985             if (memberType == EnumeratorEstimate.UNKNOWN) {
3986                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3987                                      : EnumeratorEstimate.ENUMERATOR;
3988             }
3989             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3990                 wasError = false;
3991                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3992                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3993                     hasStructuralErrors = true;
3994                 }
3995                 defs.append(enumeratorDeclaration(enumName));
3996                 if (token.pos &lt;= endPosTable.errorEndPos) {
3997                     // error recovery
3998                    skip(false, true, true, false);
3999                 } else {
4000                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
4001                         if (token.kind == COMMA) {
4002                             nextToken();
4003                         } else {
4004                             setErrorEndPos(token.pos);
4005                             reportSyntaxError(S.prevToken().endPos,
4006                                               Errors.Expected3(COMMA, RBRACE, SEMI));
4007                             wasError = true;
4008                         }
4009                     }
4010                 }
4011             } else {
4012                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
4013                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
4014                     hasStructuralErrors = true;
4015                 }
4016                 wasError = false;
4017                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
4018                                                                 false, false));
4019                 if (token.pos &lt;= endPosTable.errorEndPos) {
4020                     // error recovery
4021                    skip(false, true, true, false);
4022                 }
4023             }
4024         }
4025         accept(RBRACE);
4026         return defs.toList();
4027     }
4028 
4029     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
4030         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
4031             Token next = S.token(1);
4032             switch (next.kind) {
4033                 case LPAREN: case LBRACE: case COMMA: case SEMI:
4034                     return EnumeratorEstimate.ENUMERATOR;
4035             }
4036         }
4037         switch (token.kind) {
4038             case IDENTIFIER: case MONKEYS_AT: case LT:
4039                 return EnumeratorEstimate.UNKNOWN;
4040             default:
4041                 return EnumeratorEstimate.MEMBER;
4042         }
4043     }
4044 
4045     private enum EnumeratorEstimate {
4046         ENUMERATOR,
4047         MEMBER,
4048         UNKNOWN;
4049     }
4050 
4051     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
4052      */
4053     JCTree enumeratorDeclaration(Name enumName) {
4054         Comment dc = token.comment(CommentStyle.JAVADOC);
4055         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
4056         if (token.deprecatedFlag()) {
4057             flags |= Flags.DEPRECATED;
4058         }
4059         int pos = token.pos;
4060         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
4061         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
4062         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4063         int identPos = token.pos;
4064         Name name = ident();
4065         int createPos = token.pos;
4066         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4067             ? arguments() : List.nil();
4068         JCClassDecl body = null;
4069         if (token.kind == LBRACE) {
4070             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4071             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4072             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4073         }
4074         if (args.isEmpty() &amp;&amp; body == null)
4075             createPos = identPos;
4076         JCIdent ident = F.at(identPos).Ident(enumName);
4077         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4078         if (createPos != identPos)
4079             storeEnd(create, S.prevToken().endPos);
4080         ident = F.at(identPos).Ident(enumName);
4081         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4082         attach(result, dc);
4083         return result;
4084     }
4085 
4086     /** TypeList = Type {&quot;,&quot; Type}
4087      */
4088     List&lt;JCExpression&gt; typeList() {
4089         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4090         ts.append(parseType());
4091         while (token.kind == COMMA) {
4092             nextToken();
4093             ts.append(parseType());
4094         }
4095         return ts.toList();
4096     }
4097 
4098     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4099      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4100      */
4101     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4102         accept(LBRACE);
4103         if (token.pos &lt;= endPosTable.errorEndPos) {
4104             // error recovery
4105             skip(false, true, false, false);
4106             if (token.kind == LBRACE)
4107                 nextToken();
4108         }
4109         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4110         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4111             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4112             if (token.pos &lt;= endPosTable.errorEndPos) {
4113                // error recovery
4114                skip(false, true, true, false);
4115            }
4116         }
4117         accept(RBRACE);
4118         return defs.toList();
4119     }
4120 
4121     /** ClassBodyDeclaration =
4122      *      &quot;;&quot;
4123      *    | [STATIC] Block
4124      *    | ModifiersOpt
4125      *      ( Type Ident
4126      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4127      *      | VOID Ident VoidMethodDeclaratorRest
4128      *      | TypeParameters [Annotations]
4129      *        ( Type Ident MethodDeclaratorRest
4130      *        | VOID Ident VoidMethodDeclaratorRest
4131      *        )
4132      *      | Ident ConstructorDeclaratorRest
4133      *      | TypeParameters Ident ConstructorDeclaratorRest
4134      *      | ClassOrInterfaceOrEnumDeclaration
4135      *      )
4136      *  InterfaceBodyDeclaration =
4137      *      &quot;;&quot;
4138      *    | ModifiersOpt
4139      *      ( Type Ident
4140      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4141      *      | VOID Ident MethodDeclaratorRest
4142      *      | TypeParameters [Annotations]
4143      *        ( Type Ident MethodDeclaratorRest
4144      *        | VOID Ident VoidMethodDeclaratorRest
4145      *        )
4146      *      | ClassOrInterfaceOrEnumDeclaration
4147      *      )
4148      *
4149      */
4150     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4151         if (token.kind == SEMI) {
4152             nextToken();
4153             return List.nil();
4154         } else {
4155             Comment dc = token.comment(CommentStyle.JAVADOC);
4156             int pos = token.pos;
4157             JCModifiers mods = modifiersOpt();
4158             if (token.kind == CLASS ||
4159                 allowRecords &amp;&amp; isRecordStart() ||
4160                 token.kind == INTERFACE ||
4161                 token.kind == ENUM) {
4162                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4163             } else if (token.kind == LBRACE &amp;&amp;
4164                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4165                        mods.annotations.isEmpty()) {
4166                 if (isInterface) {
4167                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4168                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4169                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4170                 }
4171                 return List.of(block(pos, mods.flags));
4172             } else {
4173                 pos = token.pos;
4174                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4175                 // if there are type parameters but no modifiers, save the start
4176                 // position of the method in the modifiers.
4177                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4178                     mods.pos = pos;
4179                     storeEnd(mods, pos);
4180                 }
4181                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4182 
4183                 if (annosAfterParams.nonEmpty()) {
4184                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4185                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4186                     if (mods.pos == Position.NOPOS)
4187                         mods.pos = mods.annotations.head.pos;
4188                 }
4189 
4190                 Token tk = token;
4191                 pos = token.pos;
4192                 JCExpression type;
4193                 boolean isVoid = token.kind == VOID;
4194                 if (isVoid) {
4195                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4196                     nextToken();
4197                 } else {
4198                     // method returns types are un-annotated types
<a name="14" id="anc14"></a><span class="line-modified">4199                     type = unannotatedType(false);</span>
4200                 }
4201                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4202                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4203                     if (isInterface || tk.name() != className)
4204                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4205                     else if (annosAfterParams.nonEmpty())
4206                         illegal(annosAfterParams.head.pos);
4207                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4208                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4209                     }
4210                     return List.of(methodDeclaratorRest(
4211                         pos, mods, null, names.init, typarams,
4212                         isInterface, true, isRecord, dc));
4213                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4214                     // trying to define a compact constructor with a throws clause
4215                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4216                             Errors.InvalidCanonicalConstructorInRecord(
4217                                     Fragments.Compact,
4218                                     className,
4219                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4220                     skip(false, true, false, false);
4221                     return List.of(methodDeclaratorRest(
4222                             pos, mods, null, names.init, typarams,
4223                             isInterface, true, isRecord, dc));
4224                 } else {
4225                     pos = token.pos;
4226                     Name name = ident();
4227                     if (token.kind == LPAREN) {
4228                         return List.of(methodDeclaratorRest(
4229                             pos, mods, type, name, typarams,
4230                             isInterface, isVoid, false, dc));
4231                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4232                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4233                         List&lt;JCTree&gt; defs =
4234                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4235                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4236                         accept(SEMI);
4237                         storeEnd(defs.last(), S.prevToken().endPos);
4238                         return defs;
4239                     } else {
4240                             int errPos = pos;
4241                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4242                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4243                             accept(SEMI);
4244                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4245                         }
4246                     } else {
4247                         pos = token.pos;
4248                         List&lt;JCTree&gt; err;
4249                         if (isVoid || typarams.nonEmpty()) {
4250                             JCMethodDecl m =
4251                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4252                                                             List.nil(), List.nil(), null, null));
4253                             attach(m, dc);
4254                             err = List.of(m);
4255                         } else {
4256                             err = List.nil();
4257                         }
4258                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4259                     }
4260                 }
4261             }
4262         }
4263     }
4264 
4265     protected boolean isRecordStart() {
4266      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4267             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4268              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4269              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4270           checkSourceLevel(Feature.RECORDS);
4271           return true;
4272     } else {
4273        return false;
4274    }
4275 }
4276 
4277     /** MethodDeclaratorRest =
4278      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4279      *  VoidMethodDeclaratorRest =
4280      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4281      *  ConstructorDeclaratorRest =
4282      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4283      */
4284     protected JCTree methodDeclaratorRest(int pos,
4285                               JCModifiers mods,
4286                               JCExpression type,
4287                               Name name,
4288                               List&lt;JCTypeParameter&gt; typarams,
4289                               boolean isInterface, boolean isVoid,
4290                               boolean isRecord,
4291                               Comment dc) {
4292         if (isInterface) {
4293             if ((mods.flags &amp; Flags.STATIC) != 0) {
4294                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4295             }
4296             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4297                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4298             }
4299         }
4300         JCVariableDecl prevReceiverParam = this.receiverParam;
4301         try {
4302             this.receiverParam = null;
4303             // Parsing formalParameters sets the receiverParam, if present
4304             List&lt;JCVariableDecl&gt; params = List.nil();
4305             List&lt;JCExpression&gt; thrown = List.nil();
4306             if (!isRecord || name != names.init || token.kind == LPAREN) {
4307                 params = formalParameters();
4308                 if (!isVoid) type = bracketsOpt(type);
4309                 if (token.kind == THROWS) {
4310                     nextToken();
4311                     thrown = qualidentList(true);
4312                 }
4313             }
4314             JCBlock body = null;
4315             JCExpression defaultValue;
4316             if (token.kind == LBRACE) {
4317                 body = block();
4318                 defaultValue = null;
4319             } else {
4320                 if (token.kind == DEFAULT) {
4321                     accept(DEFAULT);
4322                     defaultValue = annotationValue();
4323                 } else {
4324                     defaultValue = null;
4325                 }
4326                 accept(SEMI);
4327                 if (token.pos &lt;= endPosTable.errorEndPos) {
4328                     // error recovery
4329                     skip(false, true, false, false);
4330                     if (token.kind == LBRACE) {
4331                         body = block();
4332                     }
4333                 }
4334             }
4335 
4336             JCMethodDecl result =
4337                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4338                                             receiverParam, params, thrown,
4339                                             body, defaultValue));
4340             attach(result, dc);
4341             return result;
4342         } finally {
4343             this.receiverParam = prevReceiverParam;
4344         }
4345     }
4346 
4347     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4348      */
4349     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4350         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4351 
4352         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4353         JCExpression qi = qualident(allowAnnos);
4354         if (!typeAnnos.isEmpty()) {
4355             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4356             ts.append(at);
4357         } else {
4358             ts.append(qi);
4359         }
4360         while (token.kind == COMMA) {
4361             nextToken();
4362 
4363             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4364             qi = qualident(allowAnnos);
4365             if (!typeAnnos.isEmpty()) {
4366                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4367                 ts.append(at);
4368             } else {
4369                 ts.append(qi);
4370             }
4371         }
4372         return ts.toList();
4373     }
4374 
4375     /**
4376      *  {@literal
4377      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4378      *  }
4379      */
4380     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4381         if (token.kind == LT) {
4382             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4383             nextToken();
4384             typarams.append(typeParameter());
4385             while (token.kind == COMMA) {
4386                 nextToken();
4387                 typarams.append(typeParameter());
4388             }
4389             accept(GT);
4390             return typarams.toList();
4391         } else {
4392             return List.nil();
4393         }
4394     }
4395 
4396     /**
4397      *  {@literal
4398      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4399      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4400      *  TypeVariable = Ident
4401      *  }
4402      */
4403     JCTypeParameter typeParameter() {
4404         int pos = token.pos;
4405         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4406         Name name = typeName();
4407         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4408         if (token.kind == EXTENDS) {
4409             nextToken();
4410             bounds.append(parseType());
4411             while (token.kind == AMP) {
4412                 nextToken();
4413                 bounds.append(parseType());
4414             }
4415         }
4416         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4417     }
4418 
4419     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4420      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4421      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4422      */
4423     List&lt;JCVariableDecl&gt; formalParameters() {
4424         return formalParameters(false, false);
4425     }
4426     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4427         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4428         JCVariableDecl lastParam;
4429         accept(LPAREN);
4430         if (token.kind != RPAREN) {
4431             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4432             lastParam = formalParameter(lambdaParameters, recordComponents);
4433             if (lastParam.nameexpr != null) {
4434                 this.receiverParam = lastParam;
4435             } else {
4436                 params.append(lastParam);
4437             }
4438             this.allowThisIdent = false;
4439             while (token.kind == COMMA) {
4440                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4441                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4442                 }
4443                 nextToken();
4444                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4445             }
4446         }
4447         if (token.kind == RPAREN) {
4448             nextToken();
4449         } else {
4450             setErrorEndPos(token.pos);
4451             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4452         }
4453         return params.toList();
4454     }
4455 
4456     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4457         if (hasParens) {
4458             accept(LPAREN);
4459         }
4460         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4461         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4462             params.append(implicitParameter());
4463             while (token.kind == COMMA) {
4464                 nextToken();
4465                 params.append(implicitParameter());
4466             }
4467         }
4468         if (hasParens) {
4469             accept(RPAREN);
4470         }
4471         return params.toList();
4472     }
4473 
4474     JCModifiers optFinal(long flags) {
4475         JCModifiers mods = modifiersOpt();
4476         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4477         mods.flags |= flags;
4478         return mods;
4479     }
4480 
4481     /**
4482      * Inserts the annotations (and possibly a new array level)
4483      * to the left-most type in an array or nested type.
4484      *
4485      * When parsing a type like {@code @B Outer.Inner @A []}, the
4486      * {@code @A} annotation should target the array itself, while
4487      * {@code @B} targets the nested type {@code Outer}.
4488      *
4489      * Currently the parser parses the annotation first, then
4490      * the array, and then inserts the annotation to the left-most
4491      * nested type.
4492      *
4493      * When {@code createNewLevel} is true, then a new array
4494      * level is inserted as the most inner type, and have the
4495      * annotations target it.  This is useful in the case of
4496      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4497      * first parses the type {@code String @A []} then inserts
4498      * a new array level with {@code @B} annotation.
4499      */
4500     private JCExpression insertAnnotationsToMostInner(
4501             JCExpression type, List&lt;JCAnnotation&gt; annos,
4502             boolean createNewLevel) {
4503         int origEndPos = getEndPos(type);
4504         JCExpression mostInnerType = type;
4505         JCArrayTypeTree mostInnerArrayType = null;
4506         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4507             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4508             mostInnerType = mostInnerArrayType.elemtype;
4509         }
4510 
4511         if (createNewLevel) {
4512             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4513         }
4514 
4515         JCExpression mostInnerTypeToReturn = mostInnerType;
4516         if (annos.nonEmpty()) {
4517             JCExpression lastToModify = mostInnerType;
4518 
4519             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4520                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4521                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4522                     lastToModify = mostInnerType;
4523                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4524                 }
4525                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4526                     lastToModify = mostInnerType;
4527                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4528                 }
4529             }
4530 
4531             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4532 
4533             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4534                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4535             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4536                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4537             } else {
4538                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4539                 mostInnerTypeToReturn = mostInnerType;
4540             }
4541         }
4542 
4543         if (mostInnerArrayType == null) {
4544             return mostInnerTypeToReturn;
4545         } else {
4546             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4547             storeEnd(type, origEndPos);
4548             return type;
4549         }
4550     }
4551 
4552     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4553      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4554      */
4555     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4556         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4557         if (recordComponent &amp;&amp; mods.flags != 0) {
4558             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4559         }
4560         if (recordComponent) {
4561             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4562         }
4563         // need to distinguish between vararg annos and array annos
4564         // look at typeAnnotationsPushedBack comment
4565         this.permitTypeAnnotationsPushBack = true;
4566         JCExpression type = parseType(lambdaParameter);
4567         this.permitTypeAnnotationsPushBack = false;
4568 
4569         if (token.kind == ELLIPSIS) {
4570             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4571             typeAnnotationsPushedBack = List.nil();
4572             mods.flags |= Flags.VARARGS;
4573             // insert var arg type annotations
4574             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4575             nextToken();
4576         } else {
4577             // if not a var arg, then typeAnnotationsPushedBack should be null
4578             if (typeAnnotationsPushedBack.nonEmpty()) {
4579                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4580             }
4581             typeAnnotationsPushedBack = List.nil();
4582         }
4583         return variableDeclaratorId(mods, type, lambdaParameter);
4584     }
4585 
4586     protected JCVariableDecl implicitParameter() {
4587         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4588         return variableDeclaratorId(mods, null, true);
4589     }
4590 
4591 /* ---------- auxiliary methods -------------- */
4592     /** Check that given tree is a legal expression statement.
4593      */
4594     protected JCExpression checkExprStat(JCExpression t) {
4595         if (!TreeInfo.isExpressionStatement(t)) {
4596             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4597             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4598             return ret;
4599         } else {
4600             return t;
4601         }
4602     }
4603 
4604     /** Return precedence of operator represented by token,
4605      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4606      */
4607     static int prec(TokenKind token) {
4608         JCTree.Tag oc = optag(token);
4609         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4610     }
4611 
4612     /**
4613      * Return the lesser of two positions, making allowance for either one
4614      * being unset.
4615      */
4616     static int earlier(int pos1, int pos2) {
4617         if (pos1 == Position.NOPOS)
4618             return pos2;
4619         if (pos2 == Position.NOPOS)
4620             return pos1;
4621         return (pos1 &lt; pos2 ? pos1 : pos2);
4622     }
4623 
4624     /** Return operation tag of binary operator represented by token,
4625      *  No_TAG if token is not a binary operator.
4626      */
4627     static JCTree.Tag optag(TokenKind token) {
4628         switch (token) {
4629         case BARBAR:
4630             return OR;
4631         case AMPAMP:
4632             return AND;
4633         case BAR:
4634             return BITOR;
4635         case BAREQ:
4636             return BITOR_ASG;
4637         case CARET:
4638             return BITXOR;
4639         case CARETEQ:
4640             return BITXOR_ASG;
4641         case AMP:
4642             return BITAND;
4643         case AMPEQ:
4644             return BITAND_ASG;
4645         case EQEQ:
4646             return JCTree.Tag.EQ;
4647         case BANGEQ:
4648             return NE;
4649         case LT:
4650             return JCTree.Tag.LT;
4651         case GT:
4652             return JCTree.Tag.GT;
4653         case LTEQ:
4654             return LE;
4655         case GTEQ:
4656             return GE;
4657         case LTLT:
4658             return SL;
4659         case LTLTEQ:
4660             return SL_ASG;
4661         case GTGT:
4662             return SR;
4663         case GTGTEQ:
4664             return SR_ASG;
4665         case GTGTGT:
4666             return USR;
4667         case GTGTGTEQ:
4668             return USR_ASG;
4669         case PLUS:
4670             return JCTree.Tag.PLUS;
4671         case PLUSEQ:
4672             return PLUS_ASG;
4673         case SUB:
4674             return MINUS;
4675         case SUBEQ:
4676             return MINUS_ASG;
4677         case STAR:
4678             return MUL;
4679         case STAREQ:
4680             return MUL_ASG;
4681         case SLASH:
4682             return DIV;
4683         case SLASHEQ:
4684             return DIV_ASG;
4685         case PERCENT:
4686             return MOD;
4687         case PERCENTEQ:
4688             return MOD_ASG;
4689         case INSTANCEOF:
4690             return TYPETEST;
4691         default:
4692             return NO_TAG;
4693         }
4694     }
4695 
4696     /** Return operation tag of unary operator represented by token,
4697      *  No_TAG if token is not a binary operator.
4698      */
4699     static JCTree.Tag unoptag(TokenKind token) {
4700         switch (token) {
4701         case PLUS:
4702             return POS;
4703         case SUB:
4704             return NEG;
4705         case BANG:
4706             return NOT;
4707         case TILDE:
4708             return COMPL;
4709         case PLUSPLUS:
4710             return PREINC;
4711         case SUBSUB:
4712             return PREDEC;
4713         default:
4714             return NO_TAG;
4715         }
4716     }
4717 
4718     /** Return type tag of basic type represented by token,
4719      *  NONE if token is not a basic type identifier.
4720      */
4721     static TypeTag typetag(TokenKind token) {
4722         switch (token) {
4723         case BYTE:
4724             return TypeTag.BYTE;
4725         case CHAR:
4726             return TypeTag.CHAR;
4727         case SHORT:
4728             return TypeTag.SHORT;
4729         case INT:
4730             return TypeTag.INT;
4731         case LONG:
4732             return TypeTag.LONG;
4733         case FLOAT:
4734             return TypeTag.FLOAT;
4735         case DOUBLE:
4736             return TypeTag.DOUBLE;
4737         case BOOLEAN:
4738             return TypeTag.BOOLEAN;
4739         default:
4740             return TypeTag.NONE;
4741         }
4742     }
4743 
4744     void checkSourceLevel(Feature feature) {
4745         checkSourceLevel(token.pos, feature);
4746     }
4747 
4748     protected void checkSourceLevel(int pos, Feature feature) {
4749         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4750             //preview feature without --preview flag, error
4751             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4752         } else if (!feature.allowedInSource(source)) {
4753             //incompatible source level, error
4754             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4755         } else if (preview.isPreview(feature)) {
4756             //use of preview feature, warn
4757             preview.warnPreview(pos, feature);
4758         }
4759     }
4760 
4761     /*
4762      * a functional source tree and end position mappings
4763      */
4764     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4765 
4766         private final IntHashTable endPosMap;
4767 
4768         SimpleEndPosTable(JavacParser parser) {
4769             super(parser);
4770             endPosMap = new IntHashTable();
4771         }
4772 
4773         public void storeEnd(JCTree tree, int endpos) {
4774             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4775                                  endPosMap.lookup(tree));
4776         }
4777 
4778         protected &lt;T extends JCTree&gt; T to(T t) {
4779             storeEnd(t, parser.token.endPos);
4780             return t;
4781         }
4782 
4783         protected &lt;T extends JCTree&gt; T toP(T t) {
4784             storeEnd(t, parser.S.prevToken().endPos);
4785             return t;
4786         }
4787 
4788         public int getEndPos(JCTree tree) {
4789             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4790             // As long as Position.NOPOS==-1, this just returns value.
4791             return (value == -1) ? Position.NOPOS : value;
4792         }
4793 
4794         public int replaceTree(JCTree oldTree, JCTree newTree) {
4795             int pos = endPosMap.remove(oldTree);
4796             if (pos != -1) {
4797                 storeEnd(newTree, pos);
4798                 return pos;
4799             }
4800             return Position.NOPOS;
4801         }
4802     }
4803 
4804     /*
4805      * a default skeletal implementation without any mapping overhead.
4806      */
4807     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4808 
4809         EmptyEndPosTable(JavacParser parser) {
4810             super(parser);
4811         }
4812 
4813         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4814 
4815         protected &lt;T extends JCTree&gt; T to(T t) {
4816             return t;
4817         }
4818 
4819         protected &lt;T extends JCTree&gt; T toP(T t) {
4820             return t;
4821         }
4822 
4823         public int getEndPos(JCTree tree) {
4824             return Position.NOPOS;
4825         }
4826 
4827         public int replaceTree(JCTree oldTree, JCTree newTree) {
4828             return Position.NOPOS;
4829         }
4830 
4831     }
4832 
4833     protected static abstract class AbstractEndPosTable implements EndPosTable {
4834         /**
4835          * The current parser.
4836          */
4837         protected JavacParser parser;
4838 
4839         /**
4840          * Store the last error position.
4841          */
4842         public int errorEndPos = Position.NOPOS;
4843 
4844         public AbstractEndPosTable(JavacParser parser) {
4845             this.parser = parser;
4846         }
4847 
4848         /**
4849          * Store current token&#39;s ending position for a tree, the value of which
4850          * will be the greater of last error position and the ending position of
4851          * the current token.
4852          * @param t The tree.
4853          */
4854         protected abstract &lt;T extends JCTree&gt; T to(T t);
4855 
4856         /**
4857          * Store current token&#39;s ending position for a tree, the value of which
4858          * will be the greater of last error position and the ending position of
4859          * the previous token.
4860          * @param t The tree.
4861          */
4862         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4863 
4864         /**
4865          * Set the error position during the parsing phases, the value of which
4866          * will be set only if it is greater than the last stored error position.
4867          * @param errPos The error position
4868          */
4869         public void setErrorEndPos(int errPos) {
4870             if (errPos &gt; errorEndPos) {
4871                 errorEndPos = errPos;
4872             }
4873         }
4874 
4875         public void setParser(JavacParser parser) {
4876             this.parser = parser;
4877         }
4878     }
4879 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
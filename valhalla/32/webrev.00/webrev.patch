diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Printer.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Printer.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Printer.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Printer.java
@@ -324,11 +324,11 @@
              s =  sym.getQualifiedName().toString();
         } else {
             s =  sym.name.toString();
         }
 
-        return sym.isProjectedNullable() ? s + '?' : s;
+        return s;
     }
 
     /**
      * Converts a set of method argument types into their corresponding
      * localized string representation.
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
@@ -297,18 +297,10 @@
      */
     public Symbol clone(Symbol newOwner) {
         throw new AssertionError();
     }
 
-    public boolean isProjectedNullable() {
-        return false;
-    }
-
-    public ClassSymbol nullFreeTypeSymbol() {
-        return this.type.hasTag(CLASS) && ((this.flags() & VALUE) != 0) ? (ClassSymbol) this : null;
-    }
-
     public <R, P> R accept(Symbol.Visitor<R, P> v, P p) {
         return v.visitSymbol(this, p);
     }
 
     /** The Java source which this symbol represents.
@@ -424,10 +416,33 @@
 
     public boolean isValue() {
         return (flags() & VALUE) != 0;
     }
 
+    /**
+     * Is this a *derived* reference projection symbol ??
+     */
+    public boolean isReferenceProjection() {
+        return false;
+    }
+
+    /**
+     * Return the value projection IFF `this' happens to be derived reference projection, null
+     * otherwise.
+     */
+    public Symbol valueProjection() {
+        return null;
+    }
+
+    /**
+     * Return the reference projection IFF `this' happens to be value projection, null
+     * otherwise.
+     */
+    public Symbol referenceProjection() {
+        return null;
+    }
+
     public boolean isPublic() {
         return (flags_field & Flags.AccessFlags) == PUBLIC;
     }
 
     public boolean isEnum() {
@@ -526,19 +541,21 @@
         }
         return (ClassSymbol)c;
     }
 
     /** The outermost class which indirectly owns this symbol.
+     * `outermost' being a lexical construct, should transcend
+     *  projections
      */
     public ClassSymbol outermostClass() {
         Symbol sym = this;
         Symbol prev = null;
         while (sym.kind != PCK) {
             prev = sym;
             sym = sym.owner;
         }
-        return (ClassSymbol) prev;
+        return (ClassSymbol) (prev!= null && prev.isReferenceProjection() ? prev.valueProjection() : prev);
     }
 
     /** The package which indirectly owns this symbol.
      */
     public PackageSymbol packge() {
@@ -1297,10 +1314,16 @@
         /* the list of any of record components, only non empty if the class is a record
          * and it has at least one record component
          */
         private List<RecordComponent> recordComponents = List.nil();
 
+        /* the `other' projection: If `this' is an inline class then 'projection' is its reference projection
+           and vice versa.
+         */
+        public ClassSymbol projection;
+
+
         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
             super(TYP, flags, name, type, owner);
             this.members_field = null;
             this.fullname = formFullName(name, owner);
             this.flatname = formFlatName(name, owner);
@@ -1357,12 +1380,11 @@
         public String className() {
             if (name.isEmpty())
                 return
                     Log.getLocalizedString("anonymous.class", flatname);
 
-                String s = fullname.toString();
-                return isProjectedNullable() ? s + '?' : s;
+                return fullname.toString();
         }
 
         @DefinedBy(Api.LANGUAGE_MODEL)
         public Name getQualifiedName() {
             return fullname;
@@ -1611,10 +1633,65 @@
         }
 
         public boolean isRecord() {
             return (flags_field & RECORD) != 0;
         }
+
+        @Override
+        public boolean isReferenceProjection() {
+            return projection != null && projection.isValue();
+        }
+
+        @Override
+        public ClassSymbol valueProjection() {
+            return isReferenceProjection() ? projection : null;
+        }
+
+        @Override
+        public ClassSymbol referenceProjection() {
+            if (!isValue() || projection != null)
+                return projection;
+
+            ClassType ct = (ClassType) this.type;
+            ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
+            projectedType.allparams_field = ct.allparams_field;
+            projectedType.supertype_field = ct.supertype_field;
+
+            projectedType.interfaces_field = ct.interfaces_field;
+            projectedType.all_interfaces_field = ct.all_interfaces_field;
+            projectedType.projection = ct;
+            ct.projection = projectedType;
+
+            Name projectionName = this.name.append('$', this.name.table.names.ref);
+            long projectionFlags = (this.flags() & ~(VALUE | UNATTRIBUTED));
+
+            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);
+            projection.members_field = WriteableScope.create(projection);
+            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) { // TODO: TYP?, CLINT?
+                Symbol clone = null;
+                if (s.kind == MTH) {
+                    MethodSymbol vMethod = (MethodSymbol)s;
+                    MethodSymbol rMethod = vMethod.clone(projection);
+                    vMethod.projection = rMethod;
+                    rMethod.projection = vMethod;
+                    clone = rMethod;
+                } else if (s.kind == VAR) {
+                    VarSymbol vVar = (VarSymbol)s;
+                    VarSymbol rVar = vVar.clone(projection);
+                    vVar.projection = rVar;
+                    rVar.projection = vVar;
+                    clone = rVar;
+                }
+                projection.members_field.enter(clone);
+            }
+            projection.completer = Completer.NULL_COMPLETER;
+            projection.sourcefile = this.sourcefile;
+            projection.flatname = this.flatname.append('$', this.name.table.names.ref);
+            projection.projection = this;
+            projectedType.tsym = projection;
+            return projection;
+        }
     }
 
 
     /** A class for variable symbols
      */
@@ -1633,10 +1710,15 @@
          *  Code generation:
          *    If this is a local variable, its logical slot number.
          */
         public int adr = -1;
 
+        /* The `other' projection: If `this' is a field of an inline class, then 'projection' is the
+           its doppleganger in its referene projection class and vice versa.
+        */
+        public VarSymbol projection;
+
         /** Construct a variable symbol, given its flags, name, type and owner.
          */
         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
             super(VAR, flags, name, type, owner);
         }
@@ -1665,10 +1747,11 @@
                 }
             };
             v.pos = pos;
             v.adr = adr;
             v.data = data;
+            v.projection = projection;
 //          System.out.println("clone " + v + " in " + newOwner);//DEBUG
             return v;
         }
 
         public String toString() {
@@ -1717,10 +1800,22 @@
                                       final JCVariableDecl variable)
         {
             setData((Callable<Object>)() -> attr.attribLazyConstantValue(env, variable, type));
         }
 
+        @Override
+        public VarSymbol referenceProjection() {
+            return this.owner.isValue() ?
+                    this.owner.referenceProjection() != null ? projection : null
+                               : null;
+        }
+
+        @Override
+        public VarSymbol valueProjection() {
+            return  projection != null ? projection.owner.isValue() ? projection : null: null;
+        }
+
         /**
          * The variable's constant value, if this is a constant.
          * Before the constant value is evaluated, it points to an
          * initializer environment.  If this is not a constant, it can
          * be used for other stuff.
@@ -1867,10 +1962,15 @@
          *  The value is null if none appeared in the method
          *  declaration.
          */
         public Attribute defaultValue = null;
 
+        /* The `other' projection: If `this' is a method of an inline class, then 'projection' is the
+           its doppleganger in its referene projection class and vice versa.
+        */
+        public MethodSymbol projection;
+
         /** Construct a method symbol, given its flags, name, type and owner.
          */
         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
             super(MTH, flags, name, type, owner);
             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + "." + name);
@@ -1889,10 +1989,11 @@
                 public Object poolKey(Types types) {
                     return new Pair<>(newOwner, baseSymbol());
                 }
             };
             m.code = code;
+            m.projection = projection;
             return m;
         }
 
         @Override @DefinedBy(Api.LANGUAGE_MODEL)
         public Set<Modifier> getModifiers() {
@@ -2037,10 +2138,20 @@
          */
         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
                                             boolean requireConcreteIfInherited) {
             if (isConstructor() || _other.kind != MTH) return false;
 
+
+            /* If any inline types are involved, ask the same question in the reference universe,
+               where the hierarchy is navigable
+            */
+            if (origin.isValue())
+                origin = (TypeSymbol) origin.referenceProjection();
+
+            if (this.owner.isValue())
+                return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);
+
             if (this == _other) return true;
             MethodSymbol other = (MethodSymbol)_other;
 
             // check for a direct implementation
             if (other.isOverridableIn((TypeSymbol)owner) &&
@@ -2091,10 +2202,19 @@
             }
         }
 
         @Override
         public boolean isInheritedIn(Symbol clazz, Types types) {
+
+            /* If any inline types are involved, ask the same question in the reference universe,
+               where the hierarchy is navigable
+            */
+            if (clazz.isValue())
+                clazz = clazz.referenceProjection();
+            if (this.owner.isValue())
+                return this.projection.isInheritedIn(clazz, types);
+
             switch ((int)(flags_field & Flags.AccessFlags)) {
                 case PUBLIC:
                     return !this.owner.isInterface() ||
                             clazz == owner ||
                             (flags_field & STATIC) == 0;
@@ -2105,10 +2225,22 @@
 
         public boolean isLambdaMethod() {
             return (flags() & LAMBDA_METHOD) == LAMBDA_METHOD;
         }
 
+        @Override
+        public MethodSymbol referenceProjection() {
+            return this.owner.isValue() ?
+                    this.owner.referenceProjection() != null ? projection : null
+                    : null;
+        }
+
+        @Override
+        public MethodSymbol valueProjection() {
+            return  projection != null ? projection.owner.isValue() ? projection : null : null;
+        }
+
         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
          *  lambda method
          */
         public MethodSymbol originalEnclosingMethod() {
             return this;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
@@ -233,10 +233,26 @@
         Assert.checkNonNull(metadata);
         this.tsym = tsym;
         this.metadata = metadata;
     }
 
+    public boolean isValue() {
+        return false;
+    }
+
+    public boolean isReferenceProjection() {
+        return false;
+    }
+
+    public Type valueProjection() {
+        return null;
+    }
+
+    public Type referenceProjection() {
+        return null;
+    }
+
     /**
      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
      * of a given type expression. This mapping returns the original type is no changes occurred
      * when recursively mapping the original type's subterms.
      */
@@ -1006,10 +1022,15 @@
 
         /** All the interfaces of this class, including missing ones.
          */
         public List<Type> all_interfaces_field;
 
+        /* The `other' projection: If `this' is type of an inline class, then 'projection' is the
+           its doppleganger in its referene projection world and vice versa.
+        */
+        public ClassType projection;
+
         public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym) {
             this(outer, typarams, tsym, TypeMetadata.EMPTY);
         }
 
         public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym,
@@ -1109,11 +1130,11 @@
                 if (longform) {
                     s =  sym.getQualifiedName().toString();
                 } else {
                     s = sym.name.toString();
                 }
-                return sym.isProjectedNullable() ? s + '?' : s;
+                return s;
             }
 
         @DefinedBy(Api.LANGUAGE_MODEL)
         public List<Type> getTypeArguments() {
             if (typarams_field == null) {
@@ -1159,10 +1180,58 @@
         @Override
         public boolean isReference() {
             return true;
         }
 
+        @Override
+        public boolean isValue() {
+            return tsym != null && tsym.isValue();
+        }
+
+        @Override
+        public boolean isReferenceProjection() {
+            return tsym != null && tsym.isReferenceProjection();
+        }
+
+        @Override
+        public Type valueProjection() {
+            if (!isReferenceProjection() || projection !=  null)
+                return projection;
+
+            // Make a best case effort to cache the other projection.
+            ClassSymbol valueClass = (ClassSymbol) tsym.valueProjection();
+
+            projection = new ClassType(outer_field, typarams_field, valueClass);
+            projection.allparams_field = allparams_field;
+            projection.supertype_field = supertype_field;
+
+            projection.interfaces_field = interfaces_field;
+            projection.all_interfaces_field = all_interfaces_field;
+            projection.projection = this;
+            return projection;
+        }
+
+        // return the reference projection type preserving parameterizations
+        @Override
+        public ClassType referenceProjection() {
+
+            if (!isValue() || projection != null)
+                return projection;
+
+            // make a best case effort to cache the other projection.
+            ClassSymbol refClass = (ClassSymbol) tsym.referenceProjection();
+
+            projection = new ClassType(outer_field, typarams_field, refClass);
+            projection.allparams_field = allparams_field;
+            projection.supertype_field = supertype_field;
+
+            projection.interfaces_field = interfaces_field;
+            projection.all_interfaces_field = all_interfaces_field;
+            projection.projection = this;
+            return projection;
+        }
+
         @Override
         public boolean isNullOrReference() {
             return true;
         }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
@@ -93,11 +93,10 @@
     final JavacMessages messages;
     final Names names;
     final boolean allowDefaultMethods;
     final boolean mapCapturesToBounds;
     final boolean allowValueBasedClasses;
-    final boolean nonCovariantValueArrays;
     final boolean injectTopInterfaceTypes;
     final Check chk;
     final Enter enter;
     JCDiagnostic.Factory diags;
     List<Warner> warnStack = List.nil();
@@ -126,11 +125,10 @@
         messages = JavacMessages.instance(context);
         diags = JCDiagnostic.Factory.instance(context);
         noWarnings = new Warner(null);
         Options options = Options.instance(context);
         allowValueBasedClasses = options.isSet("allowValueBasedClasses");
-        nonCovariantValueArrays = options.isSet("nonCovariantValueArrays");
         injectTopInterfaceTypes = Options.instance(context).isUnset("noTopInterfaceInjection") &&
                 Feature.INLINE_TYPES.allowedInSource(source) &&
                 Target.instance(context).hasTopInterfaces();
     }
     // </editor-fold>
@@ -610,10 +608,18 @@
     public boolean isConvertible(Type t, Type s, Warner warn) {
         if (t.hasTag(ERROR)) {
             return true;
         }
 
+        boolean tValue = t.isValue();
+        boolean sValue = s.isValue();
+        if (tValue != sValue) {
+            return tValue ?
+                    isSubtype(t.referenceProjection(), s) :
+                    (!t.hasTag(BOT) || isValueBased(s)) && isSubtype(t, s.referenceProjection());
+        }
+
         boolean tPrimitive = t.isPrimitive();
         boolean sPrimitive = s.isPrimitive();
         if (tPrimitive == sPrimitive) {
             return isSubtypeUnchecked(t, s, warn);
         }
@@ -1011,50 +1017,10 @@
 
     public boolean isValueBased(Type t) {
         return allowValueBasedClasses && t != null && t.tsym != null && (t.tsym.flags() & Flags.VALUEBASED) != 0;
     }
 
-    private final HashMap<ClassSymbol, ClassSymbol> nullableProjectionsMap = new HashMap<>();
-
-    public ClassSymbol projectedNullableType(ClassSymbol c) {
-        if (!c.isValue() || !c.type.hasTag(CLASS))
-            return null;
-        ClassSymbol lox = nullableProjectionsMap.get(c);
-        if (lox != null)
-            return lox;
-
-        ClassType ct = (ClassType) c.type;
-        ClassType loxType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
-        loxType.allparams_field = ct.allparams_field;
-        loxType.supertype_field = ct.supertype_field;
-        loxType.interfaces_field = List.nil();
-        for (Type t :ct.interfaces_field) {
-            if (t.tsym == syms.inlineObjectType.tsym) {
-                loxType.interfaces_field  = loxType.interfaces_field.append(syms.identityObjectType);
-            } else {
-                loxType.interfaces_field  = loxType.interfaces_field.append(t);
-            }
-        }
-        loxType.all_interfaces_field = ct.all_interfaces_field;
-        lox = new ClassSymbol((c.flags() & ~VALUE), c.name, loxType, c.owner) {
-            @Override
-            public boolean isProjectedNullable() {
-                return true;
-            }
-
-            @Override
-            public ClassSymbol nullFreeTypeSymbol() {
-                return c;
-            }
-        };
-        lox.members_field = c.members();
-        loxType.tsym = lox;
-
-        nullableProjectionsMap.put(c, lox);
-        return lox;
-    }
-
     // <editor-fold defaultstate="collapsed" desc="isSubtype">
     /**
      * Is t an unchecked subtype of s?
      */
     public boolean isSubtypeUnchecked(Type t, Type s) {
@@ -1074,19 +1040,20 @@
         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
             if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {
                 if (((ArrayType)t).elemtype.isPrimitive()) {
                     return isSameType(elemtype(t), elemtype(s));
                 } else {
-                    Type et = elemtype(t);
+                    // if T.ref <: S, then T[] <: S[]
                     Type es = elemtype(s);
+                    Type et = elemtype(t);
+                    if (isValue(et)) {
+                        et = et.referenceProjection();
+                        if (isValue(es))
+                            es = es.referenceProjection();  // V <: V, surely
+                    }
                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
                         return false;
-                    if (nonCovariantValueArrays) {
-                        if (isValue(et) || isValue(es)) {
-                            return isSameType(erasure(et), erasure(es));
-                        }
-                    }
                     return true;
                 }
             } else if (isSubtype(t, s, capture)) {
                 return true;
             } else if (t.hasTag(TYPEVAR)) {
@@ -1258,12 +1225,21 @@
             @Override
             public Boolean visitArrayType(ArrayType t, Type s) {
                 if (s.hasTag(ARRAY)) {
                     if (t.elemtype.isPrimitive())
                         return isSameType(t.elemtype, elemtype(s));
-                    else
-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));
+                    else {
+                        // if T.ref <: S, then T[] <: S[]
+                        Type es = elemtype(s);
+                        Type et = elemtype(t);
+                        if (isValue(et)) {
+                            et = et.referenceProjection();
+                            if (isValue(es))
+                                es = es.referenceProjection();  // V <: V, surely
+                        }
+                        return isSubtypeNoCapture(et, es);
+                    }
                 }
 
                 if (s.hasTag(CLASS)) {
                     Name sname = s.tsym.getQualifiedName();
                     return sname == names.java_lang_Object
@@ -1645,10 +1621,19 @@
             public Boolean visitWildcardType(WildcardType t, Type s) {
                 if (s.isPartial())
                     return containedBy(s, t);
                 else {
 //                    debugContainsType(t, s);
+
+                    // -----------------------------------  Unspecified behavior ----------------
+
+                    /* If a value class V implements an interface I, then does "? extends I" contain V?
+                       It seems widening must be applied here to answer yes to compile some common code
+                       patterns.
+                    */
+
+                    // ---------------------------------------------------------------------------
                     return isSameWildcard(t, s)
                         || isCaptureOf(s, t)
                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &&
                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
                 }
@@ -1769,10 +1754,18 @@
                             visitCompoundType((ClassType)s, t, true) :
                             visitCompoundType(t, s, false);
                 }
 
                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
+                    if (isValue(t)) {
+                        // (s) Value ? == (s) Value.ref
+                        t = t.referenceProjection();
+                    }
+                    if (isValue(s)) {
+                        // (Value) t ? == (Value.ref) t
+                        s = s.referenceProjection();
+                    }
                     boolean upcast;
                     if ((upcast = isSubtype(erasure(t), erasure(s)))
                         || isSubtype(erasure(s), erasure(t))) {
                         if (!upcast && s.hasTag(ARRAY)) {
                             if (!isReifiable(s))
@@ -1878,15 +1871,10 @@
                     } else {
                         Type et = elemtype(t);
                         Type es = elemtype(s);
                         if (!visit(et, es))
                             return false;
-                        if (nonCovariantValueArrays) {
-                            if (isValue(et) || isValue(es)) {
-                                return isSameType(erasure(et), erasure(es));
-                            }
-                        }
                         return true;
                     }
                 default:
                     return false;
                 }
@@ -2184,11 +2172,12 @@
          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) => c.s.s.t.Tree
          * (j.u.List<capture#160 of ? extends c.s.s.d.DocTree>, Iterable) =>
          *     Iterable<capture#160 of ? extends c.s.s.d.DocTree>
          */
         if (sym.type == syms.objectType) { //optimization
-            return syms.objectType;
+            if (!isValue(t))
+                return syms.objectType;
         }
         return asSuper.visit(t, sym);
     }
     // where
         private SimpleVisitor<Type,Symbol> asSuper = new SimpleVisitor<Type,Symbol>() {
@@ -2200,16 +2189,13 @@
             @Override
             public Type visitClassType(ClassType t, Symbol sym) {
                 if (t.tsym == sym)
                     return t;
 
-                /* For inline types, the wired in super type is j.l.O.
-                   So we need a special check for V <: V?
-                */
-                if (t.tsym == sym.nullFreeTypeSymbol()) {
-                    return new ClassType(t.getEnclosingType(), t.getTypeArguments(), (TypeSymbol)sym, t.getMetadata());
-                }
+               // No man may be an island, but the bell tolls for a value.
+                if (isValue(t))
+                    return null;
 
                 Type st = supertype(t);
                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
                     Type x = asSuper(st, sym);
                     if (x != null)
@@ -2310,13 +2296,25 @@
      *
      * @param t a type
      * @param sym a symbol
      */
     public Type memberType(Type t, Symbol sym) {
-        return (sym.flags() & STATIC) != 0
-            ? sym.type
-            : memberType.visit(t, sym);
+
+        if ((sym.flags() & STATIC) != 0)
+            return sym.type;
+
+        /* If any inline types are involved, switch over to the reference universe,
+           where the hierarchy is navigable. V and V.ref have identical membership
+           with no bridging needs.
+        */
+        if (t.isValue())
+            t = t.referenceProjection();
+
+        if (sym.owner.isValue())
+            sym = sym.referenceProjection();
+
+        return memberType.visit(t, sym);
         }
     // where
         private SimpleVisitor<Type,Symbol> memberType = new SimpleVisitor<Type,Symbol>() {
 
             public Type visitType(Type t, Symbol sym) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
@@ -169,11 +169,10 @@
         allowReifiableTypesInInstanceof =
                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &&
                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
         sourceName = source.name;
         useBeforeDeclarationWarning = options.isSet("useBeforeDeclarationWarning");
-        allowGenericsOverValues = options.isSet("allowGenericsOverValues");
         allowEmptyValues = options.isSet("allowEmptyValues");
         allowValueMemberCycles = options.isSet("allowValueMemberCycles");
 
         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
@@ -216,15 +215,10 @@
      * Switch: warn about use of variable before declaration?
      * RFE: 6425594
      */
     boolean useBeforeDeclarationWarning;
 
-    /**
-     * Switch: Allow value types to parameterize generic types?
-     */
-    boolean allowGenericsOverValues;
-
     /**
      * Switch: Allow value types with no instance state?
      */
     boolean allowEmptyValues;
 
@@ -829,13 +823,13 @@
         for (JCTypeParameter tvar : typarams) {
             TypeVar a = (TypeVar)tvar.type;
             a.tsym.flags_field |= UNATTRIBUTED;
             a.setUpperBound(Type.noType);
             if (!tvar.bounds.isEmpty()) {
-                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));
+                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));
                 for (JCExpression bound : tvar.bounds.tail)
-                    bounds = bounds.prepend(attribType(bound, env));
+                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));
                 types.setBounds(a, bounds.reverse());
             } else {
                 // if no bounds are given, assume a single bound of
                 // java.lang.Object.
                 types.setBounds(a, List.of(syms.objectType));
@@ -4075,17 +4069,11 @@
             env.info.pendingResolutionPhase = null;
             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
         } else if (tree.sym != null && tree.sym.kind != VAR) {
             sym = tree.sym;
         } else {
-            boolean wasQuestioned = env.info.isQuestioned;
-            try {
-                env.info.isQuestioned = tree.isQuestioned();
-                sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
-            } finally {
-                env.info.isQuestioned = wasQuestioned;
-            }
+            sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
         }
         tree.sym = sym;
 
         // (1) Also find the environment current for the class where
         //     sym is defined (`symEnv').
@@ -4197,31 +4185,18 @@
         // If qualifier symbol is a type or `super', assert `selectSuper'
         // for the selection. This is relevant for determining whether
         // protected symbols are accessible.
         Symbol sitesym = TreeInfo.symbol(tree.selected);
 
-        /* As we simply attach the members from the value type to its light weight box type
-           without reassigning ownership, always perform any lookups on the value type.
-         */
-        if (site.tsym.isProjectedNullable())
-            site = site.tsym.nullFreeTypeSymbol().type;
-
         boolean selectSuperPrev = env.info.selectSuper;
         env.info.selectSuper =
             sitesym != null &&
             sitesym.name == names._super;
 
         // Determine the symbol represented by the selection.
         env.info.pendingResolutionPhase = null;
-        boolean wasQuestioned = env.info.isQuestioned;
-        Symbol sym;
-        try {
-            env.info.isQuestioned = tree.isQuestioned();
-            sym = selectSym(tree, sitesym, site, env, resultInfo);
-        } finally {
-            env.info.isQuestioned = wasQuestioned;
-        }
+        Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
         if (sym.kind == VAR && sym.name != names._super && env.info.defaultSuperCallSite != null) {
             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
             sym = syms.errSymbol;
         }
         if (sym.exists() && !isType(sym) && pkind().contains(KindSelector.TYP_PCK)) {
@@ -4347,10 +4322,14 @@
                     // In this case, we have already made sure in
                     // visitSelect that qualifier expression is a type.
                     return syms.getClassField(site, types);
                 } else if (name == names._default) {
                     return new VarSymbol(STATIC, names._default, site, site.tsym);
+                } else if (name == names.ref && site.isValue() && resultInfo.pkind.contains(KindSelector.TYP)) {
+                    return site.tsym.referenceProjection();
+                } else if (name == names.val && site.isValue() && resultInfo.pkind.contains(KindSelector.TYP)) {
+                    return site.tsym;
                 } else {
                     // We are seeing a plain identifier as selector.
                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
                         sym = rs.accessBase(sym, pos, location, site, name, true);
                     return sym;
@@ -4839,13 +4818,10 @@
     public void visitTypeApply(JCTypeApply tree) {
         Type owntype = types.createErrorType(tree.type);
 
         // Attribute functor part of application and make sure it's a class.
         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
-        if (tree.isQuestioned() && clazztype != null && clazztype.tsym != null && clazztype.tsym.isValue()) {
-            clazztype = types.projectedNullableType((ClassSymbol) clazztype.tsym).type;
-        }
 
         // Attribute type parameters
         List<Type> actuals = attribTypes(tree.arguments, env);
 
         if (clazztype.hasTag(CLASS)) {
@@ -5028,11 +5004,11 @@
     public void visitWildcard(JCWildcard tree) {
         //- System.err.println("visitWildcard("+tree+");");//DEBUG
         Type type = (tree.kind.kind == BoundKind.UNBOUND)
             ? syms.objectType
             : attribType(tree.inner, env);
-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, allowGenericsOverValues),
+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),
                                               tree.kind.kind,
                                               syms.boundClass),
                 KindSelector.TYP, resultInfo);
     }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/AttrContext.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/AttrContext.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/AttrContext.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/AttrContext.java
@@ -87,15 +87,10 @@
     /**
      *  Is this an attribution environment for a withfield operation ?
      */
     boolean inWithField = false;
 
-    /**
-     *  Is this an attribution environment for a nullable value type (adorned with a ?) ?
-     */
-    boolean isQuestioned = false;
-
     /** Indicate if the type being visited is a service implementation
      */
     boolean visitingServiceImplementation = false;
 
     /** Are arguments to current function applications boxed into an array for varargs?
@@ -151,11 +146,10 @@
         info.isSerializableLambda = isSerializableLambda;
         info.attributionMode = attributionMode;
         info.isAnonymousDiamond = isAnonymousDiamond;
         info.isNewClass = isNewClass;
         info.inWithField = inWithField;
-        info.isQuestioned = isQuestioned;
         info.preferredTreeForDiagnostics = preferredTreeForDiagnostics;
         info.visitingServiceImplementation = visitingServiceImplementation;
         return info;
     }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
@@ -93,11 +93,10 @@
     private final Source source;
     private final Target target;
     private final Profile profile;
     private final Preview preview;
     private final boolean warnOnAnyAccessToMembers;
-    private final boolean allowGenericsOverValues;
     private final boolean allowValueBasedClasses;
 
     // The set of lint options currently in effect. It is initialized
     // from the context, and then is set/reset as needed by Attr as it
     // visits all the various parts of the trees during attribution.
@@ -135,11 +134,10 @@
         fileManager = context.get(JavaFileManager.class);
 
         source = Source.instance(context);
         target = Target.instance(context);
         warnOnAnyAccessToMembers = options.isSet("warnOnAccessToMembers");
-        allowGenericsOverValues = options.isSet("allowGenericsOverValues");
         allowValueBasedClasses = options.isSet("allowValueBasedClasses");
         Target target = Target.instance(context);
         syntheticNameChar = target.syntheticNameChar();
 
         profile = Profile.instance(context);
@@ -599,11 +597,12 @@
         if (inferenceContext.free(req) || inferenceContext.free(found)) {
             inferenceContext.addFreeTypeListener(List.of(req, found),
                     solvedContext -> checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
         } else {
             if (found.hasTag(CLASS)) {
-                checkParameterizationWithValues(pos, found);
+                if (inferenceContext != infer.emptyContext)
+                    checkParameterizationWithValues(pos, found);
             }
         }
         if (req.hasTag(ERROR))
             return req;
         if (req.hasTag(NONE))
@@ -860,11 +859,11 @@
      *  @param types         The types to be checked.
      */
     List<Type> checkRefTypes(List<JCExpression> trees, List<Type> types) {
         List<JCExpression> tl = trees;
         for (List<Type> l = types; l.nonEmpty(); l = l.tail) {
-            l.head = checkRefType(tl.head.pos(), l.head, allowGenericsOverValues);
+            l.head = checkRefType(tl.head.pos(), l.head, false);
             tl = tl.tail;
         }
         return types;
     }
 
@@ -897,11 +896,11 @@
         } else
             return true;
     }
 
     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {
-        if (!allowGenericsOverValues && t.tsym != syms.classType.tsym) { // tolerate Value.class for now.
+        if (t.tsym != syms.classType.tsym) { // tolerate Value.class for now.
             valueParameterizationChecker.visit(t, pos);
         }
     }
 
     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types
@@ -915,11 +914,11 @@
         }
 
         @Override
         public Void visitClassType(ClassType t, DiagnosticPosition pos) {
             for (Type targ : t.allparams()) {
-                if (types.isValue(targ) && !allowGenericsOverValues) {
+                if (types.isValue(targ)) {
                     log.error(pos, Errors.GenericParameterizationWithValueType(t));
                 }
                 visit(targ, pos);
             }
             return null;
@@ -2673,15 +2672,20 @@
             for (List<Type> m = supertypes; m != l; m = m.tail)
                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
                     return;
         }
         checkCompatibleConcretes(pos, c);
-        boolean isIdentityObject = types.asSuper(c, syms.identityObjectType.tsym) != null;
-        boolean isInlineObject = types.asSuper(c, syms.inlineObjectType.tsym) != null;
-        if (types.isValue(c) && isIdentityObject) {
+
+        /* Check for inline/identity incompatibilities: But first, we may need to switch to the
+           reference universe to make the hierarchy navigable.
+        */
+        Type asRefType = c.isValue() ? c.referenceProjection() : c;
+        boolean isIdentityObject = types.asSuper(asRefType, syms.identityObjectType.tsym) != null;
+        boolean isInlineObject = types.asSuper(asRefType, syms.inlineObjectType.tsym) != null;
+        if (c.isValue() && isIdentityObject) {
             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
-        } else if (!c.isInterface() && !types.isValue(c) && isInlineObject) {
+        } else if (!c.isInterface() && !c.tsym.isAbstract() && !c.isValue() && isInlineObject) {
             log.error(pos, Errors.IdentityTypeMustNotImplementInlineObject(c));
         } else if (isIdentityObject && isInlineObject) {
             log.error(pos, Errors.MutuallyIncompatibleInterfaces(c));
         }
     }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java
@@ -2097,11 +2097,12 @@
     }
 
     /** Visitor method: Translate a single node, boxing or unboxing if needed.
      */
     public <T extends JCExpression> T translate(T tree, Type type) {
-        return (tree == null) ? null : boxIfNeeded(translate(tree), type);
+        return (tree == null) ? null :
+                applyInlineConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);
     }
 
     /** Visitor method: Translate tree.
      */
     public <T extends JCTree> T translate(T tree, JCExpression enclOp) {
@@ -3087,10 +3088,27 @@
             if (!anyChanges) return _args;
         }
         return result.toList();
     }
 
+    /** Apply inline widening/narrowing conversions as needed */
+    @SuppressWarnings("unchecked")
+    <T extends JCExpression> T applyInlineConversionsAsNeeded(T tree, Type type) {
+        boolean haveValue = tree.type.isValue();
+        if (haveValue == type.isValue())
+            return tree;
+        if (haveValue) {
+            // widening coversion is a NOP for the VM due to subtyping relationship at class file
+            return tree;
+        } else {
+            // For narrowing conversion, insert a cast which should trigger a null check
+            return (T) make.TypeCast(type, tree);
+        }
+    }
+
+
+
     /** Expand a boxing or unboxing conversion if needed. */
     @SuppressWarnings("unchecked") // XXX unchecked
     <T extends JCExpression> T boxIfNeeded(T tree, Type type) {
         boolean havePrimitive = tree.type.isPrimitive();
         if (havePrimitive == type.isPrimitive())
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java
@@ -216,11 +216,18 @@
         if (lastParam != null && (lastParam.mods.flags & Flags.VARARGS) != 0)
             m.flags_field |= Flags.VARARGS;
 
         localEnv.info.scope.leave();
         if (chk.checkUnique(tree.pos(), m, enclScope)) {
-        enclScope.enter(m);
+            ClassSymbol refProjection = m.owner.isValue() ? (ClassSymbol) m.owner.referenceProjection() : null;
+            enclScope.enter(m);
+            if (refProjection != null) {
+                MethodSymbol clone = m.clone(refProjection);
+                clone.projection = m;
+                m.projection = clone;
+                refProjection.members_field.enter(clone);
+            }
         }
 
         annotate.annotateLater(tree.mods.annotations, localEnv, m, tree.pos());
         // Visit the signature of the method. Note that
         // TypeAnnotate doesn't descend into the body.
@@ -300,11 +307,18 @@
                 v.setLazyConstValue(initEnv(tree, initEnv), attr, tree);
             }
         }
         if (chk.checkUnique(tree.pos(), v, enclScope)) {
             chk.checkTransparentVar(tree.pos(), v, enclScope);
+            ClassSymbol refProjection =  v.owner.isValue() ? (ClassSymbol) v.owner.referenceProjection() : null;
             enclScope.enter(v);
+            if (refProjection != null) {
+                VarSymbol clone = v.clone(refProjection);
+                clone.projection = v;
+                v.projection = clone;
+                refProjection.members_field.enter(clone);
+            }
         } else if (v.owner.kind == MTH || (v.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {
             // if this is a parameter or a field obtained from a record component, enter it
             enclScope.enter(v);
         }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
@@ -405,47 +405,63 @@
         if (env.info.visitingServiceImplementation &&
             env.toplevel.modle == sym.packge().modle) {
             return true;
         }
 
-        switch ((short)(sym.flags() & AccessFlags)) {
-        case PRIVATE:
-            return
-                (env.enclClass.sym == sym.owner // fast special case
-                 ||
-                 env.enclClass.sym.outermostClass() ==
-                 sym.owner.outermostClass())
-                &&
-                sym.isInheritedIn(site.tsym, types);
-        case 0:
-            return
-                (env.toplevel.packge == sym.owner.owner // fast special case
-                 ||
-                 env.toplevel.packge == sym.packge())
-                &&
-                isAccessible(env, site, checkInner)
-                &&
-                sym.isInheritedIn(site.tsym, types)
-                &&
-                notOverriddenIn(site, sym);
-        case PROTECTED:
-            return
-                (env.toplevel.packge == sym.owner.owner // fast special case
-                 ||
-                 env.toplevel.packge == sym.packge()
-                 ||
-                 isProtectedAccessible(sym, env.enclClass.sym, site)
-                 ||
-                 // OK to select instance method or field from 'super' or type name
-                 // (but type names should be disallowed elsewhere!)
-                 env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)
-                &&
-                isAccessible(env, site, checkInner)
-                &&
-                notOverriddenIn(site, sym);
-        default: // this case includes erroneous combinations as well
-            return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);
+        ClassSymbol enclosingCsym = env.enclClass.sym;
+        if (sym.kind == MTH || sym.kind == VAR) {
+            /* If any inline types are involved, ask the same question in the reference universe,
+               where the hierarchy is navigable
+            */
+            if (site.isValue())
+                site = site.referenceProjection();
+            if (sym.owner.isValue())
+                sym = sym.referenceProjection();
+            if (env.enclClass.sym.isValue())
+                env.enclClass.sym = env.enclClass.sym.referenceProjection();
+        }
+        try {
+            switch ((short)(sym.flags() & AccessFlags)) {
+                case PRIVATE:
+                    return
+                            (env.enclClass.sym == sym.owner // fast special case
+                                    ||
+                                    env.enclClass.sym.outermostClass() ==
+                                            sym.owner.outermostClass())
+                                    &&
+                                    sym.isInheritedIn(site.tsym, types);
+                case 0:
+                    return
+                            (env.toplevel.packge == sym.owner.owner // fast special case
+                                    ||
+                                    env.toplevel.packge == sym.packge())
+                                    &&
+                                    isAccessible(env, site, checkInner)
+                                    &&
+                                    sym.isInheritedIn(site.tsym, types)
+                                    &&
+                                    notOverriddenIn(site, sym);
+                case PROTECTED:
+                    return
+                            (env.toplevel.packge == sym.owner.owner // fast special case
+                                    ||
+                                    env.toplevel.packge == sym.packge()
+                                    ||
+                                    isProtectedAccessible(sym, env.enclClass.sym, site)
+                                    ||
+                                    // OK to select instance method or field from 'super' or type name
+                                    // (but type names should be disallowed elsewhere!)
+                                    env.info.selectSuper && (sym.flags() & STATIC) == 0 && sym.kind != TYP)
+                                    &&
+                                    isAccessible(env, site, checkInner)
+                                    &&
+                                    notOverriddenIn(site, sym);
+                default: // this case includes erroneous combinations as well
+                    return isAccessible(env, site, checkInner) && notOverriddenIn(site, sym);
+            }
+        } finally {
+            env.enclClass.sym = enclosingCsym;
         }
     }
     //where
     /* `sym' is accessible only if not overridden by
      * another symbol which is a member of `site'
@@ -454,15 +470,22 @@
      * cannot be overridden (e.g. MH.invokeExact(Object[])).
      */
     private boolean notOverriddenIn(Type site, Symbol sym) {
         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
             return true;
-        else {
-            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
-            return (s2 == null || s2 == sym || sym.owner == s2.owner ||
-                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
-        }
+
+        /* If any inline types are involved, ask the same question in the reference universe,
+           where the hierarchy is navigable
+        */
+        if (site.isValue())
+            site = site.referenceProjection();
+        if (sym.owner.isValue())
+            sym = sym.referenceProjection();
+
+        Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
+        return (s2 == null || s2 == sym || sym.owner == s2.owner ||
+                !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
     }
     //where
         /** Is given protected symbol accessible if it is selected from given site
          *  and the selection takes place in given class?
          *  @param sym     The symbol with protected access
@@ -2232,12 +2255,11 @@
      */
     Symbol findMemberType(Env<AttrContext> env,
                           Type site,
                           Name name,
                           TypeSymbol c) {
-        Symbol sym = findMemberTypeInternal(env,site, name, c);
-        return env.info.isQuestioned && sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;
+        return findMemberTypeInternal(env,site, name, c);
     }
 
     /** Find qualified member type.
      *  @param env       The current environment.
      *  @param site      The original type from where the selection takes
@@ -2294,12 +2316,11 @@
     /** Find an unqualified type symbol.
      *  @param env       The current environment.
      *  @param name      The type's name.
      */
     Symbol findType(Env<AttrContext> env, Name name) {
-        Symbol sym = findTypeInternal(env, name);
-        return env.info.isQuestioned && sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;
+        return findTypeInternal(env, name);
     }
 
     /** Find an unqualified type symbol.
      *  @param env       The current environment.
      *  @param name      The type's name.
@@ -2411,12 +2432,11 @@
      *                   (a nonempty subset of TYP, PCK).
      */
     Symbol findIdentInPackage(DiagnosticPosition pos,
                               Env<AttrContext> env, TypeSymbol pck,
                               Name name, KindSelector kind) {
-        Symbol sym = checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
-        return env.info.isQuestioned && sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;
+        return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
     }
 
     Symbol findIdentInPackageInternal(Env<AttrContext> env, TypeSymbol pck,
                               Name name, KindSelector kind) {
         Name fullname = TypeSymbol.formFullName(name, pck);
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
@@ -286,11 +286,18 @@
 
         // Add bridge to `bridges' buffer
         bridges.append(md);
 
         // Add bridge to scope of enclosing class and keep track of the bridge span.
+        ClassSymbol refProjection = origin.isValue() ? origin.referenceProjection() : null;
         origin.members().enter(bridge);
+        if (refProjection != null) {
+            MethodSymbol clone = bridge.clone(refProjection);
+            clone.projection = bridge;
+            bridge.projection = clone;
+            refProjection.members().enter(clone);
+        }
     }
 
     private List<VarSymbol> createBridgeParams(MethodSymbol impl, MethodSymbol bridge,
             Type bridgeType) {
         List<VarSymbol> bridgeParams = null;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java
@@ -744,10 +744,19 @@
                 }
                 ct.interfaces_field = interfaces.toList();
                 ct.all_interfaces_field = (all_interfaces == null)
                         ? ct.interfaces_field : all_interfaces.toList();
             }
+            if (ct.isValue()) {
+                ClassSymbol cSym = (ClassSymbol) ct.tsym;
+                if (cSym.projection != null) {
+                    ClassType projectedType = (ClassType) cSym.projection.type;
+                    projectedType.supertype_field = ct.supertype_field;
+                    projectedType.interfaces_field = ct.interfaces_field;
+                    projectedType.all_interfaces_field = ct.all_interfaces_field;
+                }
+            }
         }
             //where:
             protected JCExpression clearTypeParams(JCExpression superType) {
                 return superType;
             }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java
@@ -2599,10 +2599,36 @@
         }
         readClass(c);
     }
 
     public void readClassFile(ClassSymbol c) {
+        readClassFileInternal(c);
+        if (c.isValue()) {
+            /* http://cr.openjdk.java.net/~briangoetz/valhalla/sov/04-translation.html
+               The relationship of value and reference projections differs between the language model
+               and the VM model. In the language, the value projection is not a subtype of the
+               reference projection; instead, the two are related by inline narrowing and widening
+               conversions, whereas in the VM, the two are related by actual subtyping.
+               Sever the subtyping relationship by rewiring the supertypes here and now.
+             */
+
+            Name flatname = TypeSymbol.formFlatName(names.ref, c);
+            ClassSymbol referenceProjection = syms.getClass(currentModule, flatname);
+            if (referenceProjection != null) {
+                if (referenceProjection.name != names.ref && referenceProjection.owner.kind == PCK) {
+                    readClassFileInternal(referenceProjection);
+                    ClassType classType = (ClassType) c.type;
+                    classType.supertype_field = ((ClassType) referenceProjection.type).supertype_field;
+                    classType.interfaces_field = ((ClassType) referenceProjection.type).interfaces_field;
+                    // Discard the projection, it will be recomputed on the fly.
+                    referenceProjection.owner.members().remove(referenceProjection);
+                }
+            }
+        }
+    }
+
+    private void readClassFileInternal(ClassSymbol c) {
         currentOwner = c;
         currentClassFile = c.classfile;
         warnedAttrs.clear();
         filling = true;
         target = null;
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java
@@ -139,10 +139,12 @@
     private final Log log;
 
     /** The name table. */
     private final Names names;
 
+    private final Symtab syms;
+
     /** Access to files. */
     private final JavaFileManager fileManager;
 
     /** The tags and constants used in compressed stackmap. */
     static final int SAME_FRAME_SIZE = 64;
@@ -172,10 +174,11 @@
         source = Source.instance(context);
         types = Types.instance(context);
         check = Check.instance(context);
         fileManager = context.get(JavaFileManager.class);
         poolWriter = Gen.instance(context).poolWriter;
+        syms = Symtab.instance(context);
 
         verbose        = options.isSet(VERBOSE);
         genCrt         = options.isSet(XJCOV);
         debugstackmap = options.isSet("debug.stackmap");
 
@@ -894,10 +897,13 @@
     private void listNested(Symbol sym, ListBuffer<ClassSymbol> seen) {
         if (sym.kind != TYP) return;
         ClassSymbol csym = (ClassSymbol)sym;
         if (csym.owner.kind != PCK) {
             seen.add(csym);
+            if (csym.isValue()) {
+                seen.add(csym.referenceProjection());
+            }
         }
         if (csym.members() != null) {
             for (Symbol s : sym.members().getSymbols()) {
                 listNested(s, seen);
             }
@@ -1472,10 +1478,22 @@
     /** Emit a class file for a given class.
      *  @param c      The class from which a class file is generated.
      */
     public JavaFileObject writeClass(ClassSymbol c)
         throws IOException, PoolOverflow, StringOverflow
+    {
+        JavaFileObject javaFileObject = writeClassInternal(c);
+        if (c.isValue()) {
+            ClassSymbol refProjection = c.referenceProjection();
+            refProjection.flags_field = (refProjection.flags_field & ~FINAL) | ABSTRACT;
+            writeClassInternal(refProjection);
+        }
+        return javaFileObject;
+    }
+
+    private JavaFileObject writeClassInternal(ClassSymbol c)
+        throws IOException, PoolOverflow, StringOverflow
     {
         String name = (c.owner.kind == MDL ? c.name : c.flatname).toString();
         Location outLocn;
         if (multiModuleMode) {
             ModuleSymbol msym = c.owner.kind == MDL ? (ModuleSymbol) c.owner : c.packge().modle;
@@ -1514,12 +1532,12 @@
         throws IOException, PoolOverflow, StringOverflow {
         Assert.check((c.flags() & COMPOUND) == 0);
         databuf.reset();
         poolbuf.reset();
 
-        Type supertype = types.supertype(c.type);
-        List<Type> interfaces = types.interfaces(c.type);
+        Type supertype = c.isValue() ? c.type.referenceProjection() : types.supertype(c.type);
+        List<Type> interfaces = c.isValue() ? List.of(syms.inlineObjectType) : types.interfaces(c.type);
         List<Type> typarams = c.type.getTypeArguments();
 
         int flags;
         if (c.owner.kind == MDL) {
             flags = ACC_MODULE;
@@ -1548,30 +1566,41 @@
         databuf.appendChar(interfaces.length());
         for (List<Type> l = interfaces; l.nonEmpty(); l = l.tail)
             databuf.appendChar(poolWriter.putClass((ClassSymbol)l.head.tsym));
         int fieldsCount = 0;
         int methodsCount = 0;
-        for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
-            switch (sym.kind) {
-            case VAR: fieldsCount++; break;
-            case MTH: if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;
-                      break;
-            case TYP: poolWriter.enterInner((ClassSymbol)sym); break;
-            default : Assert.error();
+        boolean referenceProjection = c.isReferenceProjection();
+        if (!referenceProjection) {
+            for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
+                switch (sym.kind) {
+                    case VAR:
+                        fieldsCount++;
+                        break;
+                    case MTH:
+                        if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;
+                        break;
+                    case TYP:
+                        poolWriter.enterInner((ClassSymbol)sym);
+                        break;
+                    default:
+                        Assert.error();
+                }
             }
-        }
 
-        if (c.trans_local != null) {
-            for (ClassSymbol local : c.trans_local) {
-                poolWriter.enterInner(local);
+            if (c.trans_local != null) {
+                for (ClassSymbol local : c.trans_local) {
+                    poolWriter.enterInner(local);
+                }
             }
         }
 
         databuf.appendChar(fieldsCount);
-        writeFields(c.members());
+        if (!referenceProjection)
+            writeFields(c.members());
         databuf.appendChar(methodsCount);
-        writeMethods(c.members());
+        if (!referenceProjection)
+            writeMethods(c.members());
 
         int acountIdx = beginAttrs();
         int acount = 0;
 
         boolean sigReq =
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
@@ -1779,12 +1779,12 @@
             switch (t.getTag()) {
             case CLASS:
             case ARRAY:
                 int width = width(t);
                 Type old = stack[stacksize-width];
-                Assert.check(types.isSubtype(types.erasure(old),
-                                       types.erasure(t)));
+                Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||
+                        (old.isValue() != t.isValue() && types.isConvertible(types.erasure(old), types.erasure(t))));
                 stack[stacksize-width] = t;
                 break;
             default:
             }
         }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
@@ -2328,12 +2328,14 @@
         setTypeAnnotationPositions(tree.pos);
         // Additional code is only needed if we cast to a reference type
         // which is not statically a supertype of the expression's type.
         // For basic types, the coerce(...) in genExpr(...) will do
         // the conversion.
+        // inline widening conversion is a nop, as the VM sees a subtyping relationship.
         if (!tree.clazz.type.isPrimitive() &&
            !types.isSameType(tree.expr.type, tree.clazz.type) &&
+            (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &&
            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
             checkDimension(tree.pos(), tree.clazz.type);
             if (types.isValue(tree.clazz.type)) {
                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
             } else {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/TransValues.java
@@ -27,13 +27,16 @@
 
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Scope.LookupKind;
 import com.sun.tools.javac.code.Scope.WriteableScope;
 import com.sun.tools.javac.code.Symbol;
+import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.MethodSymbol;
+import com.sun.tools.javac.code.Symbol.TypeSymbol;
 import com.sun.tools.javac.code.Symbol.VarSymbol;
 import com.sun.tools.javac.code.Symtab;
+import com.sun.tools.javac.code.Type.ClassType;
 import com.sun.tools.javac.code.Type.MethodType;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCAssign;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
@@ -216,10 +219,20 @@
 
                 MethodSymbol factorySym = getValueFactory(tree.sym);
                 currentMethod.setType(factorySym.type);
                 currentMethod.factoryProduct = product;
                 currentClass.sym.members().remove(tree.sym);
+                ClassSymbol refProjection = currentClass.sym.projection;
+                if (refProjection != null) {
+                    MethodSymbol projection = tree.sym.projection;
+                    Assert.check(projection != null);
+                    refProjection.members().remove(projection);
+                    projection = factorySym.clone(refProjection);
+                    projection.projection = factorySym;
+                    factorySym.projection = projection;
+                    refProjection.members().enter(projection);
+                }
                 tree.sym = factorySym;
                 currentClass.sym.members().enter(factorySym);
                 tree.mods.flags |= STATIC;
 
                 /* We may need an epilogue that returns the value product, but we can't eagerly insert
@@ -311,11 +324,31 @@
                     result = make.Select(facHandle, symbol);
                     return;
                 }
             }
         }
-        super.visitSelect(fieldAccess);
+        // Rewrite any accesses of the form V.ref.member to ((V) V.ref).member
+        fieldAccess.selected = translate(fieldAccess.selected);
+        if (fieldAccess.name != names._class && fieldAccess.name != names._default) {  // TODO: this and super ??
+            Symbol sym = TreeInfo.symbol(fieldAccess);
+            TypeSymbol selectedType = fieldAccess.selected.type.tsym;
+            if (selectedType.isReferenceProjection()) {
+                switch (sym.kind) {
+                    case MTH:
+                    case VAR:
+                        fieldAccess.selected =
+                                make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);
+                        if (sym.owner.isReferenceProjection()) // is an empty class file.
+                            sym = sym.valueProjection();
+                        break;
+                    case TYP:
+                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));
+                        break;
+                }
+            }
+        }
+        result = fieldAccess;
     }
 
     // Translate a reference style instance creation attempt on a value type to a static factory call.
     @Override
     public void visitNewClass(JCNewClass tree) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
@@ -239,19 +239,17 @@
      *     mode = EXPR        : an expression
      *     mode = TYPE        : a type
      *     mode = NOPARAMS    : no parameters allowed for type
      *     mode = TYPEARG     : type argument
      *     mode |= NOLAMBDA   : lambdas are not allowed
-     *     mode |= NOQUESTION   : type terminal ? is not allowed
      */
     protected static final int EXPR = 0x1;
     protected static final int TYPE = 0x2;
     protected static final int NOPARAMS = 0x4;
     protected static final int TYPEARG = 0x8;
     protected static final int DIAMOND = 0x10;
     protected static final int NOLAMBDA = 0x20;
-    protected static final int NOQUESTION = 0x40;
 
     protected void selectExprMode() {
         mode = (mode & NOLAMBDA) | EXPR;
     }
 
@@ -636,11 +634,11 @@
             return names.error;
         }
     }
 
     /**
-     * Qualident = Ident { DOT [Annotations] Ident } {?}
+     * Qualident = Ident { DOT [Annotations] Ident }
      */
     public JCExpression qualident(boolean allowAnnos) {
         JCExpression t = toP(F.at(token.pos).Ident(ident()));
         while (token.kind == DOT) {
             int pos = token.pos;
@@ -652,17 +650,10 @@
             t = toP(F.at(pos).Select(t, ident()));
             if (tyannos != null && tyannos.nonEmpty()) {
                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
             }
         }
-        /* if the qualified identifier being parsed is for a type name (as indicated by allowAnnos),
-           also process any terminal ? to signal nullable projection for a value type.
-        */
-        if (allowAnnos && token.kind == QUES) {
-            t.setQuestioned();
-            nextToken();
-        }
         return t;
     }
 
     JCExpression literal(Name prefix) {
         return literal(prefix, token.pos);
@@ -802,39 +793,27 @@
      */
     public JCExpression parseType() {
         return parseType(false);
     }
 
-    public JCExpression parseTypeSansQuestion() {
-        List<JCAnnotation> annotations = typeAnnotationsOpt();
-        boolean questionOK = peekToken(0, QUES) && peekToken(1, LBRACKET)  && peekToken(2, RBRACKET);
-        JCExpression result = unannotatedType(false, TYPE | (questionOK ? 0 : NOQUESTION));
-        mode &= ~NOQUESTION;
-        if (annotations.nonEmpty()) {
-            result = insertAnnotationsToMostInner(result, annotations, false);
-        }
-
-        return result;
-    }
-
     public JCExpression parseType(boolean allowVar) {
         List<JCAnnotation> annotations = typeAnnotationsOpt();
         return parseType(allowVar, annotations);
     }
 
     public JCExpression parseType(boolean allowVar, List<JCAnnotation> annotations) {
-        JCExpression result = unannotatedType(allowVar, TYPE);
+        JCExpression result = unannotatedType(allowVar);
 
         if (annotations.nonEmpty()) {
             result = insertAnnotationsToMostInner(result, annotations, false);
         }
 
         return result;
     }
 
-    public JCExpression unannotatedType(boolean allowVar, int termMode) {
-        JCExpression result = term(termMode);
+    public JCExpression unannotatedType(boolean allowVar) {
+        JCExpression result = term(TYPE);
         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 
         if (restrictedTypeName != null && (!allowVar || restrictedTypeName != names.var)) {
             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
         }
@@ -976,11 +955,11 @@
             opStack[top] = topOp;
 
             if (token.kind == INSTANCEOF) {
                 int pos = token.pos;
                 nextToken();
-                JCTree pattern = parseTypeSansQuestion();
+                JCTree pattern = parseType();
                 if (token.kind == IDENTIFIER) {
                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
                 }
                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
@@ -1293,11 +1272,10 @@
             if (typeArgs != null) return illegal();
             if ((mode & EXPR) != 0 && (mode & NOLAMBDA) == 0 && peekToken(ARROW)) {
                 t = lambdaExpressionOrStatement(false, false, pos);
             } else {
                 t = toP(F.at(token.pos).Ident(ident()));
-                handleQuestion(t);
                 loop: while (true) {
                     pos = token.pos;
                     final List<JCAnnotation> annos = typeAnnotationsOpt();
 
                     // need to report an error later if LBRACKET is for array
@@ -1385,11 +1363,10 @@
                         if ((mode & TYPE) != 0 && token.kind == MONKEYS_AT) {
                             tyannos = typeAnnotationsOpt();
                         }
                         // typeArgs saved for next loop iteration.
                         t = toP(F.at(pos).Select(t, ident()));
-                        handleQuestion(t);
                         if (tyannos != null && tyannos.nonEmpty()) {
                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
                         }
                         break;
                     case ELLIPSIS:
@@ -1499,21 +1476,10 @@
             return illegal();
         }
         return term3Rest(t, typeArgs);
     }
 
-    // where
-        private void handleQuestion(JCExpression t) {
-            if (token.kind == QUES) {
-                if (((mode & NOQUESTION) == 0 && (mode & TYPE) != 0) ||
-                        (peekToken(0, LBRACKET) && peekToken(1, RBRACKET) && peekToken(2, DOT) && peekToken(3, CLASS))) {
-                    t.setQuestioned();
-                    nextToken();
-                }
-            }
-        }
-
     private List<JCCase> switchExpressionStatementGroup() {
         ListBuffer<JCCase> caseExprs = new ListBuffer<>();
         int casePos = token.pos;
         ListBuffer<JCExpression> pats = new ListBuffer<>();
 
@@ -2181,20 +2147,17 @@
             result = toP(F.at(pos).Wildcard(t, null));
         }
         if (!annotations.isEmpty()) {
             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
         }
-        handleQuestion(result);
         return result;
     }
 
     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
         int pos = token.pos;
         List<JCExpression> args = typeArguments(diamondAllowed);
-        JCTypeApply ta = toP(F.at(pos).TypeApply(t, args));
-        handleQuestion(ta);
-        return ta;
+        return toP(F.at(pos).TypeApply(t, args));
     }
 
     /**
      * BracketsOpt = { [Annotations] "[" "]" }*
      *
@@ -4231,11 +4194,11 @@
                 if (isVoid) {
                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
                     nextToken();
                 } else {
                     // method returns types are un-annotated types
-                    type = unannotatedType(false, TYPE);
+                    type = unannotatedType(false);
                 }
                 if ((token.kind == LPAREN && !isInterface ||
                         isRecord && token.kind == LBRACE) && type.hasTag(IDENT)) {
                     if (isInterface || tk.name() != className)
                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
@@ -3699,11 +3699,11 @@
 compiler.warn.this.exposed.prematurely=\
     value based type instance should not be passed around before being fully initialized
 
 # 0: type
 compiler.err.generic.parameterization.with.value.type=\
-    Inferred type {0} involves generic parameterization by an inline type; This is allowed only with -XDallowGenericsOverValues
+    Inferred type {0} involves generic parameterization by an inline type
 
 # 0: type
 compiler.err.inline.type.must.not.implement.identity.object=\
     The inline type {0} attempts to implement the incompatible interface IdentityObject
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java
@@ -694,29 +694,20 @@
             return this;
         }
     }
 
     public static abstract class JCExpression extends JCTree implements ExpressionTree {
-        boolean questioned = false;
         @Override
         public JCExpression setType(Type type) {
             super.setType(type);
             return this;
         }
         @Override
         public JCExpression setPos(int pos) {
             super.setPos(pos);
             return this;
         }
-
-        public void setQuestioned() {
-            this.questioned = true;
-        }
-        public boolean isQuestioned() {
-            return this.questioned;
-        }
-
         public boolean isPoly() { return false; }
         public boolean isStandalone() { return true; }
     }
 
     /**
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
@@ -1337,12 +1337,10 @@
 
     public void visitSelect(JCFieldAccess tree) {
         try {
             printExpr(tree.selected, TreeInfo.postfixPrec);
             print("." + tree.name);
-            if (tree.isQuestioned())
-                print('?');
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
@@ -1362,12 +1360,10 @@
     }
 
     public void visitIdent(JCIdent tree) {
         try {
             print(tree.name);
-            if (tree.isQuestioned())
-                print('?');
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
@@ -1486,12 +1482,10 @@
         try {
             printExpr(tree.clazz);
             print("<");
             printExprs(tree.arguments);
             print(">");
-            if (tree.isQuestioned())
-                print('?');
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java
@@ -235,12 +235,10 @@
 
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitIdentifier(IdentifierTree node, P p) {
         JCIdent t = (JCIdent) node;
         JCIdent ident = M.at(t.pos).Ident(t.name);
-        if (t.isQuestioned())
-            ident.setQuestioned();
         return ident;
     }
 
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitIf(IfTree node, P p) {
@@ -354,13 +352,10 @@
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitMemberSelect(MemberSelectTree node, P p) {
         JCFieldAccess t = (JCFieldAccess) node;
         JCExpression selected = copy(t.selected, p);
         JCFieldAccess select = M.at(t.pos).Select(selected, t.name);
-        if (t.isQuestioned()) {
-            select.setQuestioned();
-        }
         return select;
     }
 
     @DefinedBy(Api.COMPILER_TREE)
     public JCTree visitMemberReference(MemberReferenceTree node, P p) {
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java
@@ -807,17 +807,23 @@
                 }
                 tp = TypeIntersection(la.toList());
                 break;
             }
             default: {
-                Type outer = t.getEnclosingType();
-                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP
-                        ? Select(Type(outer), t.tsym)
-                        : QualIdent(t.tsym);
-                tp = t.getTypeArguments().isEmpty()
-                        ? clazz
-                        : TypeApply(clazz, Types(t.getTypeArguments()));
+                if (t.isReferenceProjection()) {
+                    JCFieldAccess f = (JCFieldAccess) Select(Type(t.valueProjection()), t.tsym);
+                    f.name = names.ref;
+                    tp = f;
+                } else {
+                    Type outer = t.getEnclosingType();
+                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP
+                            ? Select(Type(outer), t.tsym)
+                            : QualIdent(t.tsym);
+                    tp = t.getTypeArguments().isEmpty()
+                            ? clazz
+                            : TypeApply(clazz, Types(t.getTypeArguments()));
+                }
                 break;
             }
             }
             break;
         case ARRAY:
@@ -827,12 +833,10 @@
             tp = TypeIdent(ERROR);
             break;
         default:
             throw new AssertionError("unexpected type: " + t);
         }
-        if (t.tsym.isProjectedNullable())
-            tp.setQuestioned();
         return tp.setType(t);
     }
 
     /** Create a list of trees representing given list of types.
      */
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
@@ -205,10 +205,13 @@
     public final Name makeConcat;
     public final Name makeConcatWithConstants;
 
     // values
     public final Name dollarValue;
+    public final Name ref;
+    public final Name val;
+
 
     // record related
     // members of java.lang.runtime.ObjectMethods
     public final Name bootstrap;
 
@@ -382,10 +385,12 @@
         makeConcat = fromString("makeConcat");
         makeConcatWithConstants = fromString("makeConcatWithConstants");
 
         // value types
         dollarValue = fromString("$value");
+        ref = fromString("ref");
+        val = fromString("val");
 
         bootstrap = fromString("bootstrap");
         record = fromString("record");
 
         serialPersistentFields = fromString("serialPersistentFields");
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java
@@ -392,11 +392,11 @@
             if (longform)
                 s =  nameSimplifier.simplify(sym).toString();
             else
                 s = sym.name.toString();
 
-            return sym.isProjectedNullable() ? s + '?' : s;
+            return s;
         }
 
         @Override
         public String visitTypeVar(TypeVar t, Locale locale) {
             if (unique(t) ||
diff a/src/jdk.jshell/share/classes/jdk/jshell/TaskFactory.java b/src/jdk.jshell/share/classes/jdk/jshell/TaskFactory.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/TaskFactory.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/TaskFactory.java
@@ -234,11 +234,13 @@
     }
 
     // Parse a snippet and return our parse task handler
     <Z> Z parse(final String source, Worker<ParseTask, Z> worker) {
         return parse(source, false, pt -> {
-            if (shouldParseAsExpression(pt)) {
+            if (!pt.units().isEmpty()
+                    && pt.units().get(0).getKind() == Kind.EXPRESSION_STATEMENT
+                    && pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
                 // It failed, it may be an expression being incorrectly
                 // parsed as having a leading type variable, example:   a < b
                 // Try forcing interpretation as an expression
                 return parse(source, true, ept -> {
                     if (!ept.getDiagnostics().hasOtherThanNotStatementErrors()) {
@@ -249,24 +251,10 @@
                 });
             }
             return worker.withTask(pt);
         });
     }
-        // where
-        private boolean shouldParseAsExpression(ParseTask pt) {
-            if (pt.units().isEmpty() || !pt.getDiagnostics().hasOtherThanNotStatementErrors())
-                return false;
-            Tree tree = pt.units().get(0);
-            if (tree.getKind() == Kind.EXPRESSION_STATEMENT)
-                return true;
-            if (tree.getKind() == Kind.VARIABLE) {
-                JCVariableDecl varDecl = (JCVariableDecl) tree;
-                if (varDecl.vartype != null && varDecl.vartype.isQuestioned())
-                    return true;
-            }
-            return false;
-        }
 
     private interface SourceHandler<T> {
 
         JavaFileObject sourceToFileObject(MemoryFileManager fm, T t);
 
diff a/src/jdk.jshell/share/classes/jdk/jshell/TypePrinter.java b/src/jdk.jshell/share/classes/jdk/jshell/TypePrinter.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/TypePrinter.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/TypePrinter.java
@@ -177,11 +177,11 @@
                     pkg
             );
         } else {
             s = sym.name.toString();
         }
-        return sym.isProjectedNullable() ? s + '?' : s;
+        return s;
     }
 
     @Override
     public String visitClassSymbol(ClassSymbol sym, Locale locale) {
         return sym.name.isEmpty()
diff a/test/langtools/tools/javac/diags/examples.not-yet.txt b/test/langtools/tools/javac/diags/examples.not-yet.txt
--- a/test/langtools/tools/javac/diags/examples.not-yet.txt
+++ b/test/langtools/tools/javac/diags/examples.not-yet.txt
@@ -216,5 +216,6 @@
 compiler.err.super.class.declares.init.block
 compiler.err.super.constructor.cannot.take.arguments
 compiler.err.super.field.not.allowed
 compiler.err.super.method.cannot.be.synchronized
 compiler.err.super.no.arg.constructor.must.be.empty
+compiler.err.generic.parameterization.with.value.type
diff a/test/langtools/tools/javac/diags/examples/GenericParameterizationWithValueType.java b/test/langtools/tools/javac/diags/examples/GenericParameterizationWithValueType.java
--- a/test/langtools/tools/javac/diags/examples/GenericParameterizationWithValueType.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// key: compiler.err.generic.parameterization.with.value.type
-
-import java.util.List;
-
-inline class X {
-
-    int x = 10;
-    
-    public static void main(String [] args) {
-       var list = List.of(new X());
-    }
-}
-
diff a/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out b/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CheckFinal.out
@@ -1,6 +1,7 @@
 CheckFinal.java:14:13: compiler.err.cant.assign.val.to.final.var: fi
 CheckFinal.java:15:13: compiler.err.cant.assign.val.to.final.var: fe
 CheckFinal.java:17:13: compiler.err.cant.assign.val.to.final.var: xsf
 CheckFinal.java:19:29: compiler.err.cant.inherit.from.final: CheckFinal
 CheckFinal.java:19:42: compiler.err.empty.value.not.yet
-5 errors
+CheckFinal.java:19:25: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.anonymous.class: java.lang.InlineObject, CheckFinal)
+6 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.java b/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.java
@@ -0,0 +1,24 @@
+/*
+ * @test /nodynamiccopyright/
+ * @bug 8215507 8218040
+ * @summary javac should NOT forbid conversion from value array to Object[]
+ * @compile/fail/ref=CovariantArrayTest.out -XDrawDiagnostics -XDdev CovariantArrayTest.java
+ */
+public class CovariantArrayTest {
+    static final inline class V {
+        public final int v1;
+        private V () {v1 = 0;}
+    }
+
+    public static void main(String args[]) {
+        int [] ia = new int[1];
+        Object oa[] = (Object[])ia;
+        oa = ia;
+
+        V [] va = new V[1];
+        Object oa2[] = (Object[])va;
+        oa2 = va;
+        va = oa2;
+        va = (V []) oa2;
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.out b/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.out
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/CovariantArrayTest.out
@@ -0,0 +1,4 @@
+CovariantArrayTest.java:15:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
+CovariantArrayTest.java:16:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
+CovariantArrayTest.java:21:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], CovariantArrayTest.V[])
+3 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.java b/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.java
@@ -0,0 +1,44 @@
+/*
+ * @test /nodynamiccopyright/
+ * @bug 8237072
+ * @summary Test various relationships between a value type and its reference projection.
+ * @compile/fail/ref=GenericInlineTest.out -XDrawDiagnostics GenericInlineTest.java
+ */
+
+abstract class Low<T, U> {}
+abstract class Mid<T, U> extends Low<U, T> {}
+abstract class High<T, U> extends Mid<U, T> {}
+
+inline
+class GenericInlineTest<T, U> extends High<U, T> {
+
+    int x = 0;
+
+    void foo() {
+
+        GenericInlineTest<String, Integer> g = new GenericInlineTest<String, Integer>();
+
+        High<String, Integer> h1 = g; // error.
+
+        High<Integer, String> h2 = g; // Ok.
+
+        Mid<String, Integer> m1 = g; // Ok
+
+        Mid<Integer, String> m2 = g; // error.
+
+        Low<String, Integer> l1 = g; // error.
+
+        Low<Integer, String> l2 = g; // Ok.
+
+        g = l2; // error.
+        g = (GenericInlineTest<String, Integer>) l2; // OK.
+
+        GenericInlineTest.ref<String, Integer> r1 = g; // ok.
+        GenericInlineTest.ref<Integer, String> r2 = g; // error
+
+        g = r1; // ok.
+        g = r2; // error.
+        g = (GenericInlineTest<String, Integer>) r2; // still error.
+
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.out b/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.out
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericInlineTest.out
@@ -0,0 +1,8 @@
+GenericInlineTest.java:21:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, High<java.lang.String,java.lang.Integer>)
+GenericInlineTest.java:27:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, Mid<java.lang.Integer,java.lang.String>)
+GenericInlineTest.java:29:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, Low<java.lang.String,java.lang.Integer>)
+GenericInlineTest.java:33:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: Low<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)
+GenericInlineTest.java:37:53: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, GenericInlineTest$ref<java.lang.Integer,java.lang.String>)
+GenericInlineTest.java:40:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest$ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)
+GenericInlineTest.java:41:50: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest$ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)
+7 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues1.java b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues1.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues1.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues1.java
@@ -25,21 +25,21 @@
 
 /*
  * @test
  * @bug 8222784
  * @summary Check generics and values interplay
- * @compile -XDallowGenericsOverValues GenericsAndValues1.java
+ * @compile GenericsAndValues1.java
  */
 
- @__inline__ class Foo implements Comparable<Foo>{
+ @__inline__ class Foo implements Comparable<Foo.ref>{
     final int value;
   
     public Foo(int value) {
       this.value = value;
     }
 
     @Override
-    public int compareTo(Foo o) {
+    public int compareTo(Foo.ref o) {
       return Integer.compare(value, o.value);
     }
  }
 
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues2.java b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues2.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues2.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues2.java
@@ -25,11 +25,11 @@
 
 /*
  * @test
  * @bug 8222784
  * @summary Check generics and values interplay
- * @compile -XDallowGenericsOverValues GenericsAndValues2.java
+ * @compile GenericsAndValues2.java
  */
 
 import java.util.function.Consumer;
 
   @__inline__ class CaptureBug {
@@ -37,11 +37,11 @@
   
     public CaptureBug(int value) {
       this.value = value;
     }
   
-    private static void accept(Consumer<? super CaptureBug> consumer) {
+    private static void accept(Consumer<? super CaptureBug.ref> consumer) {
       consumer.accept(new CaptureBug(3));
     }
   
     public static void main(String[] args) {
       accept(value -> System.out.println(value));
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues3.java b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues3.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues3.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericsAndValues3.java
@@ -25,11 +25,11 @@
 
 /*
  * @test
  * @bug 8222784
  * @summary Check generics and values interplay
- * @compile -XDallowGenericsOverValues GenericsAndValues3.java
+ * @compile GenericsAndValues3.java
  */
 
 import java.util.stream.IntStream;
 
 @__inline__ class StreamBug {
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.java b/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.java
@@ -1,21 +1,21 @@
 /*
  * @test /nodynamiccopyright/
  * @bug 8221545
  * @summary Test Generics with ?
- * @compile/fail/ref=GenericsWithQuestion.out -XDrawDiagnostics GenericsWithQuestion.java 
+ * @compile/fail/ref=GenericsWithQuestion.out -XDrawDiagnostics GenericsWithQuestion.java
  */
 
 import java.util.HashMap;
 
 public class GenericsWithQuestion {
 
     inline class V {
         int x = 10;
     }
 
-    HashMap<V?, V?>good1;
-    HashMap<V?, GenericsWithQuestion.V?>good2;
+    HashMap<V.ref, V.ref>good1;
+    HashMap<V.ref, GenericsWithQuestion.V.ref>good2;
     HashMap<V, V>  bad1; // error;
-    HashMap<V?, V> bad2; // error;
-    HashMap<V, V?> bad3; // error;
+    HashMap<V.ref, V> bad2; // error
+    HashMap<V, V.ref> bad3; // error
 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.out b/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/GenericsWithQuestion.out
@@ -1,5 +1,5 @@
 GenericsWithQuestion.java:18:13: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)
 GenericsWithQuestion.java:18:16: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)
-GenericsWithQuestion.java:19:17: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)
+GenericsWithQuestion.java:19:20: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)
 GenericsWithQuestion.java:20:13: compiler.err.type.found.req: GenericsWithQuestion.V, (compiler.misc.type.req.ref)
 4 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/InferredValueParameterizationTest.java b/test/langtools/tools/javac/valhalla/lworld-values/InferredValueParameterizationTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/InferredValueParameterizationTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/InferredValueParameterizationTest.java
@@ -1,15 +1,42 @@
 /*
- * @test /nodynamiccopyright/
- * @bug 8210346
- * @summary inferred value typed `type arguments' are allowed by Javac even without -XDallowGenericsOverValues
- * @compile/fail/ref=InferredValueParameterizationTest.out -XDrawDiagnostics -XDdev InferredValueParameterizationTest.java
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Test various inference scenarios.
+ * @run main InferredValueParameterizationTest
  *
  */
 
 import java.util.List;
 
+// This used to be negative test earlier in LW2.
+// Now no value type V <: T where T is a type variable.
+
 public inline class InferredValueParameterizationTest {
     int x = 10;
 
     static class Y<T> {
         Y(T t) {}
diff a/test/langtools/tools/javac/valhalla/lworld-values/NoCrashTest.java b/test/langtools/tools/javac/valhalla/lworld-values/NoCrashTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/NoCrashTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8237072
+ * @summary Test compiler on various constructs it had issues with.
+ */
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class NoCrashTest {
+
+    interface I {}
+    static class C implements I {}
+    static inline final class V implements I { int x = 0; }
+
+    static void triggerNPE(V.ref [] vra) {
+        vra[0] = null;
+    }
+
+    static String foo(V[] va) {
+        return "array of nonnull v's";
+    }
+
+    static String foo(Object [] oa) {
+        return "array of nullable o's";
+    }
+
+    static public void main(String[] args) {
+        I arg = args.length == 0 ? new V() : new C();
+        V [] xs = new V[0];
+        Object [] os = new Object [0];
+        Object [] o = args.length == 0 ? xs : os;
+        Object o2 = (o == null) ? new V()  : new Object();
+
+        triggerNPE(new V.ref[1]); // NO NPE.
+        try {
+            triggerNPE(new V[1]);
+            throw new RuntimeException("Should not get here!");
+        } catch (NullPointerException npe) {
+            // all is well.
+        }
+
+        V [] v = new V[0];
+        if (!foo((V.ref []) v).equals("array of nullable o's"))
+            throw new AssertionError("Broken");
+
+        ArrayList<V.ref> vList = new ArrayList<V.ref>(Arrays.asList(new V.ref[10]));
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.java b/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * @test /nodynamiccopyright/
- * @bug 8215507 8218040
- * @summary javac should forbid conversion from value array to Object[]
- * @compile/fail/ref=NoncovariantArrayTest.out -XDnonCovariantValueArrays -XDrawDiagnostics -XDdev NoncovariantArrayTest.java
- * @compile/fail/ref=NoncovariantArrayTest2.out -XDrawDiagnostics -XDdev NoncovariantArrayTest.java
- */
-public class NoncovariantArrayTest { 
-    static final inline class V { 
-        public final int v1; 
-        private V () {v1 = 0;} 
-    } 
-
-    public static void main(String args[]) { 
-        int [] ia = new int[1]; 
-        Object oa[] = (Object[])ia; 
-        oa = ia;
-
-        V [] va = new V[1]; 
-        Object oa2[] = (Object[])va; 
-        oa2 = va; 
-        va = oa2;
-        va = (V []) oa2;
-    } 
-}
diff a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.out b/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest.out
+++ /dev/null
@@ -1,7 +0,0 @@
-NoncovariantArrayTest.java:16:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
-NoncovariantArrayTest.java:17:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
-NoncovariantArrayTest.java:20:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: NoncovariantArrayTest.V[], java.lang.Object[])
-NoncovariantArrayTest.java:21:15: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: NoncovariantArrayTest.V[], java.lang.Object[])
-NoncovariantArrayTest.java:22:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], NoncovariantArrayTest.V[])
-NoncovariantArrayTest.java:23:21: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], NoncovariantArrayTest.V[])
-6 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest2.out b/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest2.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/NoncovariantArrayTest2.out
+++ /dev/null
@@ -1,4 +0,0 @@
-NoncovariantArrayTest.java:16:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
-NoncovariantArrayTest.java:17:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int[], java.lang.Object[])
-NoncovariantArrayTest.java:22:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], NoncovariantArrayTest.V[])
-3 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.java b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.java
@@ -0,0 +1,31 @@
+/*
+ * @test /nodynamiccopyright/
+ * @bug 8237072
+ * @summary Test various relationships between a value type and its reference projection.
+ * @compile/fail/ref=OverloadingPhaseTest.out -XDrawDiagnostics OverloadingPhaseTest.java
+ */
+
+public class OverloadingPhaseTest {
+
+    static inline class V {
+        int x = 0;
+    }
+
+    static String roo(V.ref v, int i) {
+        return "Phase 1";
+    }
+
+    static String roo(V.ref v, Integer i) {
+        return "Phase 2";
+    }
+
+    public static void main(String args) {
+        V o = new V();
+        String result;
+
+        if (!(result = roo(o, 0)).equals("phase 2"))
+            throw new AssertionError("Broken: got " + result);
+        if (!(result = roo(o, Integer.valueOf(0))).equals("phase 2"))
+            throw new AssertionError("Broken: got " + result);
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.out b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.out
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest.out
@@ -0,0 +1,3 @@
+OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V$ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V$ref,java.lang.Integer), OverloadingPhaseTest
+OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V$ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V$ref,java.lang.Integer), OverloadingPhaseTest
+2 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest2.java b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest2.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/OverloadingPhaseTest2.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8237072
+ * @summary Test overload resolution.
+   @run main OverloadingPhaseTest2
+ */
+
+public class OverloadingPhaseTest2 {
+
+    interface A {}
+    interface B extends A {}
+
+    static inline class X {
+
+        int x = 42;
+
+        static int m(X.ref xr, A a) {
+            return 0;
+        }
+
+        static int m(X.ref xr, B b) {
+            return 1;
+        }
+    }
+
+    public static void main(String [] args) {
+        B b = null;
+        X x = new X();
+        if (X.m(x, null) != 1)
+            throw new AssertionError("Failed");
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/ProjectionRelationsTest.java b/test/langtools/tools/javac/valhalla/lworld-values/ProjectionRelationsTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/ProjectionRelationsTest.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8237072
+ * @summary Test various relationships between a value type and its reference projection.
+ * @library /tools/lib
+ * @modules jdk.compiler/com.sun.tools.javac.api
+ *          jdk.compiler/com.sun.tools.javac.code
+ *          jdk.compiler/com.sun.tools.javac.util
+ */
+
+import java.io.StringWriter;
+import javax.tools.JavaFileObject;
+import javax.tools.ToolProvider;
+import javax.lang.model.element.Element;
+import com.sun.source.util.JavacTask;
+import com.sun.tools.javac.api.JavacTool;
+import com.sun.tools.javac.code.Type;
+import com.sun.tools.javac.code.Types;
+import com.sun.tools.javac.code.Symtab;
+import com.sun.tools.javac.code.Symbol;
+import com.sun.tools.javac.code.Symbol.ClassSymbol;
+import com.sun.tools.javac.util.Context;
+import com.sun.tools.javac.util.Assert;
+import com.sun.tools.javac.util.List;
+import com.sun.tools.javac.util.Names;
+
+import toolbox.ToolBox;
+
+public class ProjectionRelationsTest {
+
+    private static final ToolBox tb = new ToolBox();
+
+    enum Relation {
+        SUBTYPING,
+        CASTING,
+        ASSIGNING,
+    }
+
+    public static void main(String... args) throws Exception {
+        String code = "inline class C {\n" +
+                "         C.ref cref     = new C();\n" +
+                "         C []  ca       = null;\n" +
+                "         C.ref [] cra   = null;\n" +
+                "         Object[]  oa   = null;\n" +
+                      "}\n";
+        List<JavaFileObject> files = List.of(new ToolBox.JavaSource(code));
+
+        JavacTool compiler = (JavacTool) ToolProvider.getSystemJavaCompiler();
+        StringWriter out = new StringWriter();
+
+        Context context = new Context();
+
+        JavacTask task = (JavacTask) compiler.getTask(out, null, null, List.of("-XDinlinesAreIslands"), null, files, context);
+        Iterable<? extends Element> elements = task.analyze();
+        if (elements == null || !elements.iterator().hasNext()) {
+            throw new RuntimeException("Didn't compile alright!");
+        }
+
+        Names names =  Names.instance(context);
+
+        ClassSymbol valueCls = (ClassSymbol) elements.iterator().next();
+        Type vType = valueCls.type;
+        Type vDotRefType = valueCls.members().findFirst(names.fromString("cref")).type;
+        Type vArrayType = valueCls.members().findFirst(names.fromString("ca")).type;
+        Type vRefArrayType = valueCls.members().findFirst(names.fromString("cra")).type;
+        Type jlOArrayType = valueCls.members().findFirst(names.fromString("oa")).type;
+
+        for (Relation relation : Relation.values()) {
+            testRelation(context, relation, vType, vDotRefType);
+            testRelation(context, relation, vArrayType, vRefArrayType, jlOArrayType);
+        }
+    }
+
+    static void testRelation(Context context, Relation relation, Type vType, Type vDotRefType) {
+        Types types =  Types.instance(context);
+        Symtab syms =  Symtab.instance(context);
+        Type intType = syms.intType;
+        Type objectType = syms.objectType;
+        Type integerType = types.boxedTypeOrType(syms.intType);
+        Type stringType = syms.stringType;
+
+        System.out.println("Testing relation " + relation + " between " +
+                                       vType.tsym.name + " and " + vDotRefType.tsym.name);
+            switch (relation) {
+                case SUBTYPING:
+
+                    // self check
+                    Assert.check(types.isSubtype(vType, vType));
+                    Assert.check(types.isSubtype(vDotRefType, vDotRefType));
+
+                    Assert.check(types.isSubtype(vType, vDotRefType) ==
+                                 types.isSubtype(intType, integerType));
+                    Assert.check(types.isSubtype(vDotRefType, vType) ==
+                                 types.isSubtype(integerType, intType));
+
+                    Assert.check(types.isSubtype(vType, objectType) ==
+                                 types.isSubtype(intType, objectType));
+                    Assert.check(types.isSubtype(objectType, vType) ==
+                                 types.isSubtype(objectType, intType));
+
+                    Assert.check(types.isSubtype(vDotRefType, objectType) ==
+                                 types.isSubtype(integerType, objectType));
+                    Assert.check(types.isSubtype(objectType, vDotRefType) ==
+                                 types.isSubtype(objectType, integerType));
+
+                    // check against a totally unrelated class.
+                    Assert.check(types.isSubtype(vType, stringType) ==
+                                 types.isSubtype(intType, stringType));
+                    Assert.check(types.isSubtype(stringType, vType) ==
+                                 types.isSubtype(stringType, intType));
+
+                    Assert.check(types.isSubtype(vDotRefType, stringType) ==
+                                 types.isSubtype(integerType, stringType));
+                    Assert.check(types.isSubtype(stringType, vDotRefType) ==
+                                 types.isSubtype(stringType, integerType));
+                    break;
+
+                case CASTING:
+
+                    // self check
+                    Assert.check(types.isCastable(vType, vType));
+                    Assert.check(types.isCastable(vDotRefType, vDotRefType));
+
+                    Assert.check(types.isCastable(vType, vDotRefType) ==
+                                 types.isCastable(intType, integerType));
+                    Assert.check(types.isCastable(vDotRefType, vType) ==
+                                 types.isCastable(integerType, intType));
+                    Assert.check(types.isCastable(vType, objectType) ==
+                                 types.isCastable(intType, objectType));
+                    Assert.check(types.isCastable(objectType, vType) ==
+                                 types.isCastable(objectType, intType));
+                    Assert.check(types.isCastable(vDotRefType, objectType) ==
+                                 types.isCastable(integerType, objectType));
+                    Assert.check(types.isCastable(objectType, vDotRefType) ==
+                                 types.isCastable(objectType, integerType));
+                    // check against a totally unrelated class.
+                    Assert.check(types.isCastable(vType, stringType) ==
+                                 types.isCastable(intType, stringType));
+                    Assert.check(types.isCastable(stringType, vType) ==
+                                 types.isCastable(stringType, intType));
+
+                    Assert.check(types.isCastable(vDotRefType, stringType) ==
+                                 types.isCastable(integerType, stringType));
+                    Assert.check(types.isCastable(stringType, vDotRefType) ==
+                                 types.isCastable(stringType, integerType));
+                    break;
+
+                case ASSIGNING:
+
+                    // self check
+                    Assert.check(types.isAssignable(vType, vType));
+                    Assert.check(types.isAssignable(vDotRefType, vDotRefType));
+
+                    Assert.check(types.isAssignable(vType, vDotRefType) ==
+                                 types.isAssignable(intType, integerType));
+                    Assert.check(types.isAssignable(vDotRefType, vType) ==
+                                 types.isAssignable(integerType, intType));
+                    Assert.check(types.isAssignable(vType, objectType) ==
+                                 types.isAssignable(intType, objectType));
+                    Assert.check(types.isAssignable(objectType, vType) ==
+                                 types.isAssignable(objectType, intType));
+                    Assert.check(types.isAssignable(vDotRefType, objectType) ==
+                                 types.isAssignable(integerType, objectType));
+                    Assert.check(types.isAssignable(objectType, vDotRefType) ==
+                                 types.isAssignable(objectType, integerType));
+                    // check against a totally unrelated class.
+                    Assert.check(types.isAssignable(vType, stringType) ==
+                                 types.isAssignable(intType, stringType));
+                    Assert.check(types.isAssignable(stringType, vType) ==
+                                 types.isAssignable(stringType, intType));
+
+                    Assert.check(types.isAssignable(vDotRefType, stringType) ==
+                                 types.isAssignable(integerType, stringType));
+                    Assert.check(types.isAssignable(stringType, vDotRefType) ==
+                                 types.isAssignable(stringType, integerType));
+                    break;
+            }
+    }
+
+    static void testRelation(Context context, Relation relation, Type vArrayType, Type vDotRefArrayType, Type objectArrayType) {
+        Types types =  Types.instance(context);
+        Symtab syms =  Symtab.instance(context);
+
+        System.out.println("Testing relation " + relation + " between " +
+                                       vArrayType.tsym.name + " and " + vDotRefArrayType.tsym.name);
+            switch (relation) {
+                case SUBTYPING:
+
+                    /* check against self */
+                    Assert.check(types.isSubtype(vArrayType, vArrayType));
+                    Assert.check(types.isSubtype(vDotRefArrayType, vDotRefArrayType));
+
+                    /* check against valid supers */
+                    Assert.check(types.isSubtype(vArrayType, vDotRefArrayType));
+                    Assert.check(types.isSubtype(vArrayType, objectArrayType));
+                    Assert.check(types.isSubtype(vArrayType, syms.objectType));
+                    Assert.check(types.isSubtype(vDotRefArrayType, objectArrayType));
+                    Assert.check(types.isSubtype(vDotRefArrayType, syms.objectType));
+
+                    /* check negative cases */
+                    Assert.check(!types.isSubtype(vDotRefArrayType, vArrayType));
+                    Assert.check(!types.isSubtype(objectArrayType, vArrayType));
+                    Assert.check(!types.isSubtype(objectArrayType, vDotRefArrayType));
+
+                    break;
+
+                case CASTING:
+
+                    /* check self cast */
+                    Assert.check(types.isCastable(vArrayType, vArrayType));
+                    Assert.check(types.isCastable(vDotRefArrayType, vDotRefArrayType));
+
+                    /* check widening cast of V */
+                    Assert.check(types.isCastable(vArrayType, vDotRefArrayType));
+                    Assert.check(types.isCastable(vArrayType, objectArrayType));
+                    Assert.check(types.isCastable(vArrayType, syms.objectType));
+
+                    /* check cast of V.ref to supers */
+                    Assert.check(types.isCastable(vDotRefArrayType, objectArrayType));
+                    Assert.check(types.isCastable(vDotRefArrayType, syms.objectType));
+
+                    /* check downcasts */
+                    Assert.check(types.isCastable(vDotRefArrayType, vArrayType));
+                    Assert.check(types.isCastable(objectArrayType, vArrayType));
+                    Assert.check(types.isCastable(objectArrayType, vDotRefArrayType));
+                    Assert.check(types.isCastable(syms.objectType, vArrayType));
+                    Assert.check(types.isCastable(syms.objectType, vDotRefArrayType));
+
+                    break;
+
+                case ASSIGNING:
+
+                    /* check self  */
+                    Assert.check(types.isAssignable(vArrayType, vArrayType));
+                    Assert.check(types.isAssignable(vDotRefArrayType, vDotRefArrayType));
+
+                    /* check widening */
+                    Assert.check(types.isAssignable(vArrayType, vDotRefArrayType));
+                    Assert.check(types.isAssignable(vArrayType, objectArrayType));
+                    Assert.check(types.isAssignable(vArrayType, syms.objectType));
+
+                    /* check more widening */
+                    Assert.check(types.isAssignable(vDotRefArrayType, objectArrayType));
+                    Assert.check(types.isAssignable(vDotRefArrayType, syms.objectType));
+
+                    /* misc */
+                    Assert.check(!types.isAssignable(vDotRefArrayType, vArrayType));
+                    Assert.check(!types.isAssignable(objectArrayType, vArrayType));
+                    Assert.check(!types.isAssignable(objectArrayType, vDotRefArrayType));
+                    Assert.check(!types.isAssignable(syms.objectType, vArrayType));
+                    Assert.check(!types.isAssignable(syms.objectType, vDotRefArrayType));
+
+                    break;
+            }
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceNegativeTest.java
@@ -31,6 +31,7 @@
 
     void foo(V2 v) {
         if (v instanceof IdentityObject)
             throw new AssertionError("Expected inline object but found identity object");
     }
+    abstract class abs implements IdentityObject {} // OK
 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TopInterfaceTest.java
@@ -54,12 +54,17 @@
         if (!ca[0].getCanonicalName().equals("java.lang.InlineObject"))
             throw new AssertionError("Found wrong super interfaces");
         if (!(inln_o instanceof InlineObject)) // really really make sure...
             throw new AssertionError("Expected inline Object");
 
+        // Check that V's super class is V.ref in class file.
+        Class<?> vrefCls = inln_o.getClass().getSuperclass();
+        if (!vrefCls.getCanonicalName().equals("TopInterfaceTest.V$ref"))
+            throw new AssertionError("Wrong super type for value type");
+
         // Check that no injection has happened for jlO itself.
-        Class<?> jlo = inln_o.getClass().getSuperclass();
+        Class<?> jlo = vrefCls.getSuperclass();
         if (!jlo.getCanonicalName().equals("java.lang.Object"))
             throw new AssertionError("Wrong super type for value type");
         if (jlo.getInterfaces().length != 0)
             throw new AssertionError("Wrong number of super interfaces for jlO");
 
diff a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.java
@@ -7,24 +7,24 @@
 
 final inline class TypeRelationsNegativeTest {
 
     void foo() {
         TypeRelationsNegativeTest x = null; // error
-        TypeRelationsNegativeTest? xq = null;
+        TypeRelationsNegativeTest.ref xq = null;
 
         xq = x;
-        xq = (TypeRelationsNegativeTest?) x;
+        xq = (TypeRelationsNegativeTest.ref) x;
         xq = (TypeRelationsNegativeTest) x;
-        x = xq;  // error
-        x = (TypeRelationsNegativeTest?) xq; // error
+        x = xq;
+        x = (TypeRelationsNegativeTest.ref) xq;
         x = (TypeRelationsNegativeTest) xq;
  
         TypeRelationsNegativeTest [] xa = new TypeRelationsNegativeTest[] { null }; // error
-        TypeRelationsNegativeTest? [] xqa = new TypeRelationsNegativeTest?[] { null };
+        TypeRelationsNegativeTest.ref [] xqa = new TypeRelationsNegativeTest.ref[] { null };
 
         xqa = xa;
-        xqa = (TypeRelationsNegativeTest?[]) xa;
-        xa = xqa; // error
+        xqa = (TypeRelationsNegativeTest.ref[]) xa;
+        xa = xqa;// error
         xa = (TypeRelationsNegativeTest []) xqa;
     }
     int x = 10;
 }
diff a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.out b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.out
--- a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.out
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsNegativeTest.out
@@ -1,6 +1,4 @@
 TypeRelationsNegativeTest.java:11:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)
-TypeRelationsNegativeTest.java:17:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest?, TypeRelationsNegativeTest)
-TypeRelationsNegativeTest.java:18:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest?, TypeRelationsNegativeTest)
 TypeRelationsNegativeTest.java:21:77: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, TypeRelationsNegativeTest)
-TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest?[], TypeRelationsNegativeTest[])
-5 errors
+TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest$ref[], TypeRelationsNegativeTest[])
+3 errors
diff a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsTest.java b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsTest.java
--- a/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsTest.java
+++ b/test/langtools/tools/javac/valhalla/lworld-values/TypeRelationsTest.java
@@ -32,13 +32,13 @@
 
 public inline class TypeRelationsTest {
 
     int x = 42;
 
-    static boolean foo(TypeRelationsTest x, TypeRelationsTest? xq, boolean nullPassed) {
+    static boolean foo(TypeRelationsTest x, TypeRelationsTest.ref xq, boolean nullPassed) {
         TypeRelationsTest xl;
-        TypeRelationsTest? xql;
+        TypeRelationsTest.ref xql;
         boolean npe = false;
 
         xl = x;
         xl = (TypeRelationsTest) x;
         try {
@@ -46,13 +46,13 @@
         } catch (NullPointerException e) {
             npe = true;
         }
 
         xql = x;
-        xql = (TypeRelationsTest ?) x;
+        xql = (TypeRelationsTest.ref ) x;
         xql = xq;
-        xql = (TypeRelationsTest?) xq;
+        xql = (TypeRelationsTest.ref) xq;
         return npe;
     }
 
     static String foo(Object o) {
         return "Object";
@@ -60,27 +60,27 @@
 
     static String foo(TypeRelationsTest x) {
         return "TypeRelationsTest";
     }
 
-    static String foo(TypeRelationsTest? xq) {
-        return "TypeRelationsTest?";
+    static String foo(TypeRelationsTest.ref xq) {
+        return "TypeRelationsTest.ref";
     }
 
     public static void main(String [] args) {
        if (foo(new TypeRelationsTest(), new TypeRelationsTest(), false))
             throw new AssertionError("Unexpected NPE");
        if (!foo(new TypeRelationsTest(), null, true))
             throw new AssertionError("Missing NPE");
 
        TypeRelationsTest x = new TypeRelationsTest();
-       TypeRelationsTest? xq = null;
+       TypeRelationsTest.ref xq = null;
        if (!foo(x).equals("TypeRelationsTest"))
             throw new AssertionError("Wrong overload");
-       if (!foo(xq).equals("TypeRelationsTest?"))
+       if (!foo(xq).equals("TypeRelationsTest.ref"))
             throw new AssertionError("Wrong overload");
-       if (!foo((TypeRelationsTest?) x).equals("TypeRelationsTest?"))
+       if (!foo((TypeRelationsTest.ref) x).equals("TypeRelationsTest.ref"))
             throw new AssertionError("Wrong overload");
 
        boolean npe = false;
        try  {
            foo((TypeRelationsTest) xq);
@@ -89,27 +89,27 @@
        }
        if (!npe) {
             throw new AssertionError("Missing NPE");
        }
        xq = x;
-       if (!foo((TypeRelationsTest?) xq).equals("TypeRelationsTest?"))
+       if (!foo((TypeRelationsTest.ref) xq).equals("TypeRelationsTest.ref"))
             throw new AssertionError("Wrong overload");
        checkArrays();
     }
 
     static void checkArrays() {
         TypeRelationsTest [] xa = new TypeRelationsTest[10];
-        TypeRelationsTest? [] xqa;
+        TypeRelationsTest.ref [] xqa;
         Object [] oa;
         Object o;
 
         o = oa = xqa = xa;
-        xa = (TypeRelationsTest []) (xqa = (TypeRelationsTest?[]) (oa = (Object []) o));
+        xa = (TypeRelationsTest []) (xqa = (TypeRelationsTest.ref[]) (oa = (Object []) o));
         xa[0] = new TypeRelationsTest(); // OK, after round trip back and forth.
 
 
-        xqa = (TypeRelationsTest?[]) xa;
+        xqa = (TypeRelationsTest.ref[]) xa;
         boolean npe = false;
         try {
             xqa[0] = null;
         } catch (NullPointerException e) {
             npe = true;

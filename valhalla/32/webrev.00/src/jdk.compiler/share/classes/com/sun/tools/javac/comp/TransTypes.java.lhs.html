<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import java.util.*;
 29 
 30 import com.sun.tools.javac.code.*;
 31 import com.sun.tools.javac.code.Attribute.TypeCompound;
 32 import com.sun.tools.javac.code.Source.Feature;
 33 import com.sun.tools.javac.code.Symbol.*;
 34 import com.sun.tools.javac.code.Type.IntersectionClassType;
 35 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
 36 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 37 import com.sun.tools.javac.tree.*;
 38 import com.sun.tools.javac.tree.JCTree.*;
 39 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
 40 import com.sun.tools.javac.util.*;
 41 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 42 import com.sun.tools.javac.util.List;
 43 
 44 import static com.sun.tools.javac.code.Flags.*;
 45 import static com.sun.tools.javac.code.Kinds.Kind.*;
 46 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
 47 import static com.sun.tools.javac.code.TypeTag.CLASS;
 48 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
 49 import static com.sun.tools.javac.code.TypeTag.VOID;
 50 import static com.sun.tools.javac.comp.CompileStates.CompileState;
 51 import com.sun.tools.javac.tree.JCTree.JCBreak;
 52 
 53 /** This pass translates Generic Java to conventional Java.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
 59  */
 60 public class TransTypes extends TreeTranslator {
 61     /** The context key for the TransTypes phase. */
 62     protected static final Context.Key&lt;TransTypes&gt; transTypesKey = new Context.Key&lt;&gt;();
 63 
 64     /** Get the instance for this context. */
 65     public static TransTypes instance(Context context) {
 66         TransTypes instance = context.get(transTypesKey);
 67         if (instance == null)
 68             instance = new TransTypes(context);
 69         return instance;
 70     }
 71 
 72     private Names names;
 73     private Log log;
 74     private Symtab syms;
 75     private TreeMaker make;
 76     private Enter enter;
 77     private Types types;
 78     private Annotate annotate;
 79     private Attr attr;
 80     private final Resolve resolve;
 81     private final CompileStates compileStates;
 82 
 83     /** Switch: is complex graph inference supported? */
 84     private final boolean allowGraphInference;
 85 
 86     /** Switch: are default methods supported? */
 87     private final boolean allowInterfaceBridges;
 88 
 89     protected TransTypes(Context context) {
 90         context.put(transTypesKey, this);
 91         compileStates = CompileStates.instance(context);
 92         names = Names.instance(context);
 93         log = Log.instance(context);
 94         syms = Symtab.instance(context);
 95         enter = Enter.instance(context);
 96         types = Types.instance(context);
 97         make = TreeMaker.instance(context);
 98         resolve = Resolve.instance(context);
 99         Source source = Source.instance(context);
100         allowInterfaceBridges = Feature.DEFAULT_METHODS.allowedInSource(source);
101         allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source);
102         annotate = Annotate.instance(context);
103         attr = Attr.instance(context);
104     }
105 
106     /** Construct an attributed tree for a cast of expression to target type,
107      *  unless it already has precisely that type.
108      *  @param tree    The expression tree.
109      *  @param target  The target type.
110      */
111     JCExpression cast(JCExpression tree, Type target) {
112         int oldpos = make.pos;
113         make.at(tree.pos);
114         if (!types.isSameType(tree.type, target)) {
115             if (!resolve.isAccessible(env, target.tsym))
116                 resolve.logAccessErrorInternal(env, tree, target);
117             tree = make.TypeCast(make.Type(target), tree).setType(target);
118         }
119         make.pos = oldpos;
120         return tree;
121     }
122 
123     /** Construct an attributed tree to coerce an expression to some erased
124      *  target type, unless the expression is already assignable to that type.
125      *  If target type is a constant type, use its base type instead.
126      *  @param tree    The expression tree.
127      *  @param target  The target type.
128      */
129     public JCExpression coerce(Env&lt;AttrContext&gt; env, JCExpression tree, Type target) {
130         Env&lt;AttrContext&gt; prevEnv = this.env;
131         try {
132             this.env = env;
133             return coerce(tree, target);
134         }
135         finally {
136             this.env = prevEnv;
137         }
138     }
139     JCExpression coerce(JCExpression tree, Type target) {
140         Type btarget = target.baseType();
141         if (tree.type.isPrimitive() == target.isPrimitive()) {
142             return types.isAssignable(tree.type, btarget, types.noWarnings)
143                 ? tree
144                 : cast(tree, btarget);
145         }
146         return tree;
147     }
148 
149     /** Given an erased reference type, assume this type as the tree&#39;s type.
150      *  Then, coerce to some given target type unless target type is null.
151      *  This operation is used in situations like the following:
152      *
153      *  &lt;pre&gt;{@code
154      *  class Cell&lt;A&gt; { A value; }
155      *  ...
156      *  Cell&lt;Integer&gt; cell;
157      *  Integer x = cell.value;
158      *  }&lt;/pre&gt;
159      *
160      *  Since the erasure of Cell.value is Object, but the type
161      *  of cell.value in the assignment is Integer, we need to
162      *  adjust the original type of cell.value to Object, and insert
163      *  a cast to Integer. That is, the last assignment becomes:
164      *
165      *  &lt;pre&gt;{@code
166      *  Integer x = (Integer)cell.value;
167      *  }&lt;/pre&gt;
168      *
169      *  @param tree       The expression tree whose type might need adjustment.
170      *  @param erasedType The expression&#39;s type after erasure.
171      *  @param target     The target type, which is usually the erasure of the
172      *                    expression&#39;s original type.
173      */
174     JCExpression retype(JCExpression tree, Type erasedType, Type target) {
175 //      System.err.println(&quot;retype &quot; + tree + &quot; to &quot; + erasedType);//DEBUG
176         if (!erasedType.isPrimitive()) {
177             if (target != null &amp;&amp; target.isPrimitive()) {
178                 target = erasure(tree.type);
179             }
180             tree.type = erasedType;
181             if (target != null) {
182                 return coerce(tree, target);
183             }
184         }
185         return tree;
186     }
187 
188     /** Translate method argument list, casting each argument
189      *  to its corresponding type in a list of target types.
190      *  @param _args            The method argument list.
191      *  @param parameters       The list of target types.
192      *  @param varargsElement   The erasure of the varargs element type,
193      *  or null if translating a non-varargs invocation
194      */
195     &lt;T extends JCTree&gt; List&lt;T&gt; translateArgs(List&lt;T&gt; _args,
196                                            List&lt;Type&gt; parameters,
197                                            Type varargsElement) {
198         if (parameters.isEmpty()) return _args;
199         List&lt;T&gt; args = _args;
200         while (parameters.tail.nonEmpty()) {
201             args.head = translate(args.head, parameters.head);
202             args = args.tail;
203             parameters = parameters.tail;
204         }
205         Type parameter = parameters.head;
206         Assert.check(varargsElement != null || args.length() == 1);
207         if (varargsElement != null) {
208             while (args.nonEmpty()) {
209                 args.head = translate(args.head, varargsElement);
210                 args = args.tail;
211             }
212         } else {
213             args.head = translate(args.head, parameter);
214         }
215         return _args;
216     }
217 
218     public &lt;T extends JCTree&gt; List&lt;T&gt; translateArgs(List&lt;T&gt; _args,
219                                            List&lt;Type&gt; parameters,
220                                            Type varargsElement,
221                                            Env&lt;AttrContext&gt; localEnv) {
222         Env&lt;AttrContext&gt; prevEnv = env;
223         try {
224             env = localEnv;
225             return translateArgs(_args, parameters, varargsElement);
226         }
227         finally {
228             env = prevEnv;
229         }
230     }
231 
232     /** Add a bridge definition and enter corresponding method symbol in
233      *  local scope of origin.
234      *
235      *  @param pos     The source code position to be used for the definition.
236      *  @param meth    The method for which a bridge needs to be added
237      *  @param impl    That method&#39;s implementation (possibly the method itself)
238      *  @param origin  The class to which the bridge will be added
239      *  @param bridges The list buffer to which the bridge will be added
240      */
241     void addBridge(DiagnosticPosition pos,
242                    MethodSymbol meth,
243                    MethodSymbol impl,
244                    ClassSymbol origin,
245                    ListBuffer&lt;JCTree&gt; bridges) {
246         make.at(pos);
247         Type implTypeErasure = erasure(impl.type);
248 
249         // Create a bridge method symbol and a bridge definition without a body.
250         Type bridgeType = meth.erasure(types);
251         long flags = impl.flags() &amp; AccessFlags | SYNTHETIC | BRIDGE |
252                 (origin.isInterface() ? DEFAULT : 0);
253         MethodSymbol bridge = new MethodSymbol(flags,
254                                                meth.name,
255                                                bridgeType,
256                                                origin);
257         /* once JDK-6996415 is solved it should be checked if this approach can
258          * be applied to method addOverrideBridgesIfNeeded
259          */
260         bridge.params = createBridgeParams(impl, bridge, bridgeType);
261         bridge.setAttributes(impl);
262 
263         JCMethodDecl md = make.MethodDef(bridge, null);
264 
265         // The bridge calls this.impl(..), if we have an implementation
266         // in the current class, super.impl(...) otherwise.
267         JCExpression receiver = (impl.owner == origin)
268             ? make.This(origin.erasure(types))
269             : make.Super(types.supertype(origin.type).tsym.erasure(types), origin);
270 
271         // The type returned from the original method.
272         Type calltype = implTypeErasure.getReturnType();
273 
274         // Construct a call of  this.impl(params), or super.impl(params),
275         // casting params and possibly results as needed.
276         JCExpression call =
277             make.Apply(
278                        null,
279                        make.Select(receiver, impl).setType(calltype),
280                        translateArgs(make.Idents(md.params), implTypeErasure.getParameterTypes(), null))
281             .setType(calltype);
282         JCStatement stat = (implTypeErasure.getReturnType().hasTag(VOID))
283             ? make.Exec(call)
284             : make.Return(coerce(call, bridgeType.getReturnType()));
285         md.body = make.Block(0, List.of(stat));
286 
287         // Add bridge to `bridges&#39; buffer
288         bridges.append(md);
289 
290         // Add bridge to scope of enclosing class and keep track of the bridge span.
<a name="1" id="anc1"></a>
291         origin.members().enter(bridge);
<a name="2" id="anc2"></a>





292     }
293 
294     private List&lt;VarSymbol&gt; createBridgeParams(MethodSymbol impl, MethodSymbol bridge,
295             Type bridgeType) {
296         List&lt;VarSymbol&gt; bridgeParams = null;
297         if (impl.params != null) {
298             bridgeParams = List.nil();
299             List&lt;VarSymbol&gt; implParams = impl.params;
300             Type.MethodType mType = (Type.MethodType)bridgeType;
301             List&lt;Type&gt; argTypes = mType.argtypes;
302             while (implParams.nonEmpty() &amp;&amp; argTypes.nonEmpty()) {
303                 VarSymbol param = new VarSymbol(implParams.head.flags() | SYNTHETIC | PARAMETER,
304                         implParams.head.name, argTypes.head, bridge);
305                 param.setAttributes(implParams.head);
306                 bridgeParams = bridgeParams.append(param);
307                 implParams = implParams.tail;
308                 argTypes = argTypes.tail;
309             }
310         }
311         return bridgeParams;
312     }
313 
314     /** Add bridge if given symbol is a non-private, non-static member
315      *  of the given class, which is either defined in the class or non-final
316      *  inherited, and one of the two following conditions holds:
317      *  1. The method&#39;s type changes in the given class, as compared to the
318      *     class where the symbol was defined, (in this case
319      *     we have extended a parameterized class with non-trivial parameters).
320      *  2. The method has an implementation with a different erased return type.
321      *     (in this case we have used co-variant returns).
322      *  If a bridge already exists in some other class, no new bridge is added.
323      *  Instead, it is checked that the bridge symbol overrides the method symbol.
324      *  (Spec ???).
325      *  todo: what about bridges for privates???
326      *
327      *  @param pos     The source code position to be used for the definition.
328      *  @param sym     The symbol for which a bridge might have to be added.
329      *  @param origin  The class in which the bridge would go.
330      *  @param bridges The list buffer to which the bridge would be added.
331      */
332     void addBridgeIfNeeded(DiagnosticPosition pos,
333                            Symbol sym,
334                            ClassSymbol origin,
335                            ListBuffer&lt;JCTree&gt; bridges) {
336         if (sym.kind == MTH &amp;&amp;
337                 sym.name != names.init &amp;&amp;
338                 (sym.flags() &amp; (PRIVATE | STATIC)) == 0 &amp;&amp;
339                 (sym.flags() &amp; SYNTHETIC) != SYNTHETIC &amp;&amp;
340                 sym.isMemberOf(origin, types)) {
341             MethodSymbol meth = (MethodSymbol)sym;
342             MethodSymbol bridge = meth.binaryImplementation(origin, types);
343             MethodSymbol impl = meth.implementation(origin, types, true);
344             if (bridge == null ||
345                 bridge == meth ||
346                 (impl != null &amp;&amp; !bridge.owner.isSubClass(impl.owner, types))) {
347                 // No bridge was added yet.
348                 if (impl != null &amp;&amp; bridge != impl &amp;&amp; isBridgeNeeded(meth, impl, origin.type)) {
349                     addBridge(pos, meth, impl, origin, bridges);
350                 } else if (impl == meth
351                            &amp;&amp; impl.owner != origin
352                            &amp;&amp; (impl.flags() &amp; FINAL) == 0
353                            &amp;&amp; (meth.flags() &amp; (ABSTRACT|PUBLIC)) == PUBLIC
354                            &amp;&amp; (origin.flags() &amp; PUBLIC) &gt; (impl.owner.flags() &amp; PUBLIC)) {
355                     // this is to work around a horrible but permanent
356                     // reflection design error.
357                     addBridge(pos, meth, impl, origin, bridges);
358                 }
359             }
360         }
361     }
362     // where
363 
364         /**
365          * @param method The symbol for which a bridge might have to be added
366          * @param impl The implementation of method
367          * @param dest The type in which the bridge would go
368          */
369         private boolean isBridgeNeeded(MethodSymbol method,
370                                        MethodSymbol impl,
371                                        Type dest) {
372             if (impl != method) {
373                 // If either method or impl have different erasures as
374                 // members of dest, a bridge is needed.
375                 Type method_erasure = method.erasure(types);
376                 if (!isSameMemberWhenErased(dest, method, method_erasure))
377                     return true;
378                 Type impl_erasure = impl.erasure(types);
379                 if (!isSameMemberWhenErased(dest, impl, impl_erasure))
380                     return true;
381 
382                 /* Bottom line: A bridge is needed if the erasure of the implementation
383                    is different from that of the method that it overrides.
384                 */
385                 return !types.isSameType(impl_erasure, method_erasure);
386             } else {
387                // method and impl are the same...
388                 if ((method.flags() &amp; ABSTRACT) != 0) {
389                     // ...and abstract so a bridge is not needed.
390                     // Concrete subclasses will bridge as needed.
391                     return false;
392                 }
393 
394                 // The erasure of the return type is always the same
395                 // for the same symbol.  Reducing the three tests in
396                 // the other branch to just one:
397                 return !isSameMemberWhenErased(dest, method, method.erasure(types));
398             }
399         }
400         /**
401          * Lookup the method as a member of the type.  Compare the
402          * erasures.
403          * @param type the class where to look for the method
404          * @param method the method to look for in class
405          * @param erasure the erasure of method
406          */
407         private boolean isSameMemberWhenErased(Type type,
408                                                MethodSymbol method,
409                                                Type erasure) {
410             return types.isSameType(erasure(types.memberType(type, method)),
411                                     erasure);
412         }
413 
414     void addBridges(DiagnosticPosition pos,
415                     TypeSymbol i,
416                     ClassSymbol origin,
417                     ListBuffer&lt;JCTree&gt; bridges) {
418         for (Symbol sym : i.members().getSymbols(NON_RECURSIVE))
419             addBridgeIfNeeded(pos, sym, origin, bridges);
420         for (List&lt;Type&gt; l = types.interfaces(i.type); l.nonEmpty(); l = l.tail)
421             addBridges(pos, l.head.tsym, origin, bridges);
422     }
423 
424     /** Add all necessary bridges to some class appending them to list buffer.
425      *  @param pos     The source code position to be used for the bridges.
426      *  @param origin  The class in which the bridges go.
427      *  @param bridges The list buffer to which the bridges are added.
428      */
429     void addBridges(DiagnosticPosition pos, ClassSymbol origin, ListBuffer&lt;JCTree&gt; bridges) {
430         Type st = types.supertype(origin.type);
431         while (st.hasTag(CLASS)) {
432 //          if (isSpecialization(st))
433             addBridges(pos, st.tsym, origin, bridges);
434             st = types.supertype(st);
435         }
436         for (List&lt;Type&gt; l = types.interfaces(origin.type); l.nonEmpty(); l = l.tail)
437 //          if (isSpecialization(l.head))
438             addBridges(pos, l.head.tsym, origin, bridges);
439     }
440 
441 /* ************************************************************************
442  * Visitor methods
443  *************************************************************************/
444 
445     /** Visitor argument: proto-type.
446      */
447     private Type pt;
448 
449     /** Visitor method: perform a type translation on tree.
450      */
451     public &lt;T extends JCTree&gt; T translate(T tree, Type pt) {
452         Type prevPt = this.pt;
453         try {
454             this.pt = pt;
455             return translate(tree);
456         } finally {
457             this.pt = prevPt;
458         }
459     }
460 
461     /** Visitor method: perform a type translation on list of trees.
462      */
463     public &lt;T extends JCTree&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, Type pt) {
464         Type prevPt = this.pt;
465         List&lt;T&gt; res;
466         try {
467             this.pt = pt;
468             res = translate(trees);
469         } finally {
470             this.pt = prevPt;
471         }
472         return res;
473     }
474 
475     public void visitClassDef(JCClassDecl tree) {
476         translateClass(tree.sym);
477         result = tree;
478     }
479 
480     Type returnType = null;
481     public void visitMethodDef(JCMethodDecl tree) {
482         Type prevRetType = returnType;
483         try {
484             returnType = erasure(tree.type).getReturnType();
485             tree.restype = translate(tree.restype, null);
486             tree.typarams = List.nil();
487             tree.params = translateVarDefs(tree.params);
488             tree.recvparam = translate(tree.recvparam, null);
489             tree.thrown = translate(tree.thrown, null);
490             tree.body = translate(tree.body, tree.sym.erasure(types).getReturnType());
491             tree.type = erasure(tree.type);
492             result = tree;
493         } finally {
494             returnType = prevRetType;
495         }
496     }
497 
498     public void visitVarDef(JCVariableDecl tree) {
499         tree.vartype = translate(tree.vartype, null);
500         tree.init = translate(tree.init, tree.sym.erasure(types));
501         tree.type = erasure(tree.type);
502         result = tree;
503     }
504 
505     public void visitDoLoop(JCDoWhileLoop tree) {
506         tree.body = translate(tree.body);
507         tree.cond = translate(tree.cond, syms.booleanType);
508         result = tree;
509     }
510 
511     public void visitWhileLoop(JCWhileLoop tree) {
512         tree.cond = translate(tree.cond, syms.booleanType);
513         tree.body = translate(tree.body);
514         result = tree;
515     }
516 
517     public void visitWithField(JCWithField tree) {
518         tree.field = translate(tree.field, null);
519         tree.value = translate(tree.value, erasure(tree.field.type));
520         tree.type = erasure(tree.type);
521         result = retype(tree, tree.type, pt);
522     }
523 
524     public void visitForLoop(JCForLoop tree) {
525         tree.init = translate(tree.init, null);
526         if (tree.cond != null)
527             tree.cond = translate(tree.cond, syms.booleanType);
528         tree.step = translate(tree.step, null);
529         tree.body = translate(tree.body);
530         result = tree;
531     }
532 
533     public void visitForeachLoop(JCEnhancedForLoop tree) {
534         tree.var = translate(tree.var, null);
535         Type iterableType = tree.expr.type;
536         tree.expr = translate(tree.expr, erasure(tree.expr.type));
537         if (types.elemtype(tree.expr.type) == null)
538             tree.expr.type = iterableType; // preserve type for Lower
539         tree.body = translate(tree.body);
540         result = tree;
541     }
542 
543     public void visitLambda(JCLambda tree) {
544         Type prevRetType = returnType;
545         try {
546             returnType = erasure(tree.getDescriptorType(types)).getReturnType();
547             tree.params = translate(tree.params);
548             tree.body = translate(tree.body, tree.body.type == null || returnType.hasTag(VOID) ? null : returnType);
549             if (!tree.type.isIntersection()) {
550                 tree.type = erasure(tree.type);
551             } else {
552                 tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);
553             }
554             result = tree;
555         }
556         finally {
557             returnType = prevRetType;
558         }
559     }
560 
561     public void visitSwitch(JCSwitch tree) {
562         Type selsuper = types.supertype(tree.selector.type);
563         boolean enumSwitch = selsuper != null &amp;&amp;
564             selsuper.tsym == syms.enumSym;
565         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
566         tree.selector = translate(tree.selector, target);
567         tree.cases = translateCases(tree.cases);
568         result = tree;
569     }
570 
571     public void visitCase(JCCase tree) {
572         tree.pats = translate(tree.pats, null);
573         tree.stats = translate(tree.stats);
574         result = tree;
575     }
576 
577     public void visitBindingPattern(JCBindingPattern tree) {
578         if (tree.vartype != null) {
579             tree.vartype = translate(tree.vartype, null);
580         }
581         result = tree;
582     }
583 
584     public void visitSwitchExpression(JCSwitchExpression tree) {
585         Type selsuper = types.supertype(tree.selector.type);
586         boolean enumSwitch = selsuper != null &amp;&amp;
587             selsuper.tsym == syms.enumSym;
588         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
589         tree.selector = translate(tree.selector, target);
590         tree.cases = translate(tree.cases);
591         tree.type = erasure(tree.type);
592         result = retype(tree, tree.type, pt);
593     }
594 
595     public void visitSynchronized(JCSynchronized tree) {
596         tree.lock = translate(tree.lock, erasure(tree.lock.type));
597         tree.body = translate(tree.body);
598         result = tree;
599     }
600 
601     public void visitTry(JCTry tree) {
602         tree.resources = translate(tree.resources, syms.autoCloseableType);
603         tree.body = translate(tree.body);
604         tree.catchers = translateCatchers(tree.catchers);
605         tree.finalizer = translate(tree.finalizer);
606         result = tree;
607     }
608 
609     public void visitConditional(JCConditional tree) {
610         tree.cond = translate(tree.cond, syms.booleanType);
611         tree.truepart = translate(tree.truepart, erasure(tree.type));
612         tree.falsepart = translate(tree.falsepart, erasure(tree.type));
613         tree.type = erasure(tree.type);
614         result = retype(tree, tree.type, pt);
615     }
616 
617    public void visitIf(JCIf tree) {
618         tree.cond = translate(tree.cond, syms.booleanType);
619         tree.thenpart = translate(tree.thenpart);
620         tree.elsepart = translate(tree.elsepart);
621         result = tree;
622     }
623 
624     public void visitExec(JCExpressionStatement tree) {
625         tree.expr = translate(tree.expr, null);
626         result = tree;
627     }
628 
629     public void visitReturn(JCReturn tree) {
630         if (!returnType.hasTag(VOID))
631             tree.expr = translate(tree.expr, returnType);
632         result = tree;
633     }
634 
635     @Override
636     public void visitBreak(JCBreak tree) {
637         result = tree;
638     }
639 
640     @Override
641     public void visitYield(JCYield tree) {
642         tree.value = translate(tree.value, erasure(tree.value.type));
643         tree.value.type = erasure(tree.value.type);
644         tree.value = retype(tree.value, tree.value.type, pt);
645         result = tree;
646     }
647 
648     public void visitThrow(JCThrow tree) {
649         tree.expr = translate(tree.expr, erasure(tree.expr.type));
650         result = tree;
651     }
652 
653     public void visitAssert(JCAssert tree) {
654         tree.cond = translate(tree.cond, syms.booleanType);
655         if (tree.detail != null)
656             tree.detail = translate(tree.detail, erasure(tree.detail.type));
657         result = tree;
658     }
659 
660     public void visitApply(JCMethodInvocation tree) {
661         tree.meth = translate(tree.meth, null);
662         Symbol meth = TreeInfo.symbol(tree.meth);
663         Type mt = meth.erasure(types);
664         boolean useInstantiatedPtArgs =
665                 allowGraphInference &amp;&amp; !types.isSignaturePolymorphic((MethodSymbol)meth.baseSymbol());
666         List&lt;Type&gt; argtypes = useInstantiatedPtArgs ?
667                 tree.meth.type.getParameterTypes() :
668                 mt.getParameterTypes();
669         if (meth.name == names.init &amp;&amp; meth.owner == syms.enumSym)
670             argtypes = argtypes.tail.tail;
671         if (tree.varargsElement != null)
672             tree.varargsElement = types.erasure(tree.varargsElement);
673         else
674             if (tree.args.length() != argtypes.length()) {
675                 Assert.error(String.format(&quot;Incorrect number of arguments; expected %d, found %d&quot;,
676                         tree.args.length(), argtypes.length()));
677             }
678         tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);
679 
680         tree.type = types.erasure(tree.type);
681         // Insert casts of method invocation results as needed.
682         result = retype(tree, mt.getReturnType(), pt);
683     }
684 
685     public void visitNewClass(JCNewClass tree) {
686         if (tree.encl != null) {
687             if (tree.def == null) {
688                 tree.encl = translate(tree.encl, erasure(tree.encl.type));
689             } else {
690                 tree.args = tree.args.prepend(attr.makeNullCheck(tree.encl));
691                 tree.encl = null;
692             }
693         }
694 
695         Type erasedConstructorType = tree.constructorType != null ?
696                 erasure(tree.constructorType) :
697                 null;
698 
699         List&lt;Type&gt; argtypes = erasedConstructorType != null &amp;&amp; allowGraphInference ?
700                 erasedConstructorType.getParameterTypes() :
701                 tree.constructor.erasure(types).getParameterTypes();
702 
703         tree.clazz = translate(tree.clazz, null);
704         if (tree.varargsElement != null)
705             tree.varargsElement = types.erasure(tree.varargsElement);
706         tree.args = translateArgs(
707             tree.args, argtypes, tree.varargsElement);
708         tree.def = translate(tree.def, null);
709         if (erasedConstructorType != null)
710             tree.constructorType = erasedConstructorType;
711         tree.type = erasure(tree.type);
712         result = tree;
713     }
714 
715     public void visitNewArray(JCNewArray tree) {
716         tree.elemtype = translate(tree.elemtype, null);
717         translate(tree.dims, syms.intType);
718         if (tree.type != null) {
719             tree.elems = translate(tree.elems, erasure(types.elemtype(tree.type)));
720             tree.type = erasure(tree.type);
721         } else {
722             tree.elems = translate(tree.elems, null);
723         }
724 
725         result = tree;
726     }
727 
728     public void visitParens(JCParens tree) {
729         tree.expr = translate(tree.expr, pt);
730         tree.type = erasure(tree.expr.type);
731         result = tree;
732     }
733 
734     public void visitAssign(JCAssign tree) {
735         tree.lhs = translate(tree.lhs, null);
736         tree.rhs = translate(tree.rhs, erasure(tree.lhs.type));
737         tree.type = erasure(tree.lhs.type);
738         result = retype(tree, tree.type, pt);
739     }
740 
741     public void visitAssignop(JCAssignOp tree) {
742         tree.lhs = translate(tree.lhs, null);
743         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
744         tree.type = erasure(tree.type);
745         result = tree;
746     }
747 
748     public void visitUnary(JCUnary tree) {
749         tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK)
750             ? tree.type
751             : tree.operator.type.getParameterTypes().head);
752         result = tree;
753     }
754 
755     public void visitBinary(JCBinary tree) {
756         tree.lhs = translate(tree.lhs, tree.operator.type.getParameterTypes().head);
757         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
758         result = tree;
759     }
760 
761     public void visitAnnotatedType(JCAnnotatedType tree) {
762         // For now, we need to keep the annotations in the tree because of the current
763         // MultiCatch implementation wrt type annotations
764         List&lt;TypeCompound&gt; mirrors = annotate.fromAnnotations(tree.annotations);
765         tree.underlyingType = translate(tree.underlyingType);
766         tree.type = tree.underlyingType.type.annotatedType(mirrors);
767         result = tree;
768     }
769 
770     public void visitTypeCast(JCTypeCast tree) {
771         tree.clazz = translate(tree.clazz, null);
772         Type originalTarget = tree.type;
773         tree.type = erasure(tree.type);
774         JCExpression newExpression = translate(tree.expr, tree.type);
775         if (newExpression != tree.expr) {
776             JCTypeCast typeCast = newExpression.hasTag(Tag.TYPECAST)
777                 ? (JCTypeCast) newExpression
778                 : null;
779             tree.expr = typeCast != null &amp;&amp; types.isSameType(typeCast.type, originalTarget)
780                 ? typeCast.expr
781                 : newExpression;
782         }
783         if (originalTarget.isIntersection()) {
784             Type.IntersectionClassType ict = (Type.IntersectionClassType)originalTarget;
785             for (Type c : ict.getExplicitComponents()) {
786                 Type ec = erasure(c);
787                 if (!types.isSameType(ec, tree.type)) {
788                     tree.expr = coerce(tree.expr, ec);
789                 }
790             }
791         }
792         result = retype(tree, tree.type, pt);
793     }
794 
795     public void visitTypeTest(JCInstanceOf tree) {
796         tree.expr = translate(tree.expr, null);
797         tree.pattern = translate(tree.pattern, null);
798         result = tree;
799     }
800 
801     public void visitIndexed(JCArrayAccess tree) {
802         tree.indexed = translate(tree.indexed, erasure(tree.indexed.type));
803         tree.index = translate(tree.index, syms.intType);
804 
805         // Insert casts of indexed expressions as needed.
806         result = retype(tree, types.elemtype(tree.indexed.type), pt);
807     }
808 
809     // There ought to be nothing to rewrite here;
810     // we don&#39;t generate code.
811     public void visitAnnotation(JCAnnotation tree) {
812         result = tree;
813     }
814 
815     public void visitIdent(JCIdent tree) {
816         Type et = tree.sym.erasure(types);
817 
818         // Map type variables to their bounds.
819         if (tree.sym.kind == TYP &amp;&amp; tree.sym.type.hasTag(TYPEVAR)) {
820             result = make.at(tree.pos).Type(et);
821         } else
822         // Map constants expressions to themselves.
823         if (tree.type.constValue() != null) {
824             result = tree;
825         }
826         // Insert casts of variable uses as needed.
827         else if (tree.sym.kind == VAR) {
828             result = retype(tree, et, pt);
829         }
830         else {
831             tree.type = erasure(tree.type);
832             result = tree;
833         }
834     }
835 
836     public void visitSelect(JCFieldAccess tree) {
837         Type t = types.skipTypeVars(tree.selected.type, false);
838         if (t.isCompound()) {
839             tree.selected = coerce(
840                 translate(tree.selected, erasure(tree.selected.type)),
841                 erasure(tree.sym.owner.type));
842         } else
843             tree.selected = translate(tree.selected, erasure(t));
844 
845         // Map constants expressions to themselves.
846         if (tree.type.constValue() != null) {
847             result = tree;
848         }
849         // Insert casts of variable uses as needed.
850         else if (tree.sym.kind == VAR) {
851             result = retype(tree, tree.sym.erasure(types), pt);
852         }
853         else {
854             tree.type = erasure(tree.type);
855             result = tree;
856         }
857     }
858 
859     public void visitReference(JCMemberReference tree) {
860         Type t = types.skipTypeVars(tree.expr.type, false);
861         Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);
862         if (tree.kind == ReferenceKind.UNBOUND) {
863             tree.expr = make.Type(receiverTarget);
864         } else {
865             tree.expr = translate(tree.expr, receiverTarget);
866         }
867         if (!tree.type.isIntersection()) {
868             tree.type = erasure(tree.type);
869         } else {
870             tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);
871         }
872         if (tree.varargsElement != null)
873             tree.varargsElement = erasure(tree.varargsElement);
874         result = tree;
875     }
876 
877     public void visitTypeArray(JCArrayTypeTree tree) {
878         tree.elemtype = translate(tree.elemtype, null);
879         tree.type = erasure(tree.type);
880         result = tree;
881     }
882 
883     /** Visitor method for parameterized types.
884      */
885     public void visitTypeApply(JCTypeApply tree) {
886         JCTree clazz = translate(tree.clazz, null);
887         result = clazz;
888     }
889 
890     public void visitTypeIntersection(JCTypeIntersection tree) {
891         tree.bounds = translate(tree.bounds, null);
892         tree.type = erasure(tree.type);
893         result = tree;
894     }
895 
896 /**************************************************************************
897  * utility methods
898  *************************************************************************/
899 
900     private Type erasure(Type t) {
901         return types.erasure(t);
902     }
903 
904 /**************************************************************************
905  * main method
906  *************************************************************************/
907 
908     private Env&lt;AttrContext&gt; env;
909 
910     private static final String statePreviousToFlowAssertMsg =
911             &quot;The current compile state [%s] of class %s is previous to FLOW&quot;;
912 
913     void translateClass(ClassSymbol c) {
914         Type st = types.supertype(c.type);
915         // process superclass before derived
916         if (st.hasTag(CLASS)) {
917             translateClass((ClassSymbol)st.tsym);
918         }
919 
920         Env&lt;AttrContext&gt; myEnv = enter.getEnv(c);
921         if (myEnv == null || (c.flags_field &amp; TYPE_TRANSLATED) != 0) {
922             return;
923         }
924         c.flags_field |= TYPE_TRANSLATED;
925 
926         /*  The two assertions below are set for early detection of any attempt
927          *  to translate a class that:
928          *
929          *  1) has no compile state being it the most outer class.
930          *     We accept this condition for inner classes.
931          *
932          *  2) has a compile state which is previous to Flow state.
933          */
934         boolean envHasCompState = compileStates.get(myEnv) != null;
935         if (!envHasCompState &amp;&amp; c.outermostClass() == c) {
936             Assert.error(&quot;No info for outermost class: &quot; + myEnv.enclClass.sym);
937         }
938 
939         if (envHasCompState &amp;&amp;
940                 CompileState.FLOW.isAfter(compileStates.get(myEnv))) {
941             Assert.error(String.format(statePreviousToFlowAssertMsg,
942                     compileStates.get(myEnv), myEnv.enclClass.sym));
943         }
944 
945         Env&lt;AttrContext&gt; oldEnv = env;
946         try {
947             env = myEnv;
948             // class has not been translated yet
949 
950             TreeMaker savedMake = make;
951             Type savedPt = pt;
952             make = make.forToplevel(env.toplevel);
953             pt = null;
954             try {
955                 JCClassDecl tree = (JCClassDecl) env.tree;
956                 tree.typarams = List.nil();
957                 super.visitClassDef(tree);
958                 make.at(tree.pos);
959                 ListBuffer&lt;JCTree&gt; bridges = new ListBuffer&lt;&gt;();
960                 if (allowInterfaceBridges || (tree.sym.flags() &amp; INTERFACE) == 0) {
961                     addBridges(tree.pos(), c, bridges);
962                 }
963                 tree.defs = bridges.toList().prependList(tree.defs);
964                 tree.type = erasure(tree.type);
965             } finally {
966                 make = savedMake;
967                 pt = savedPt;
968             }
969         } finally {
970             env = oldEnv;
971         }
972     }
973 
974     /** Translate a toplevel class definition.
975      *  @param cdef    The definition to be translated.
976      */
977     public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {
978         // note that this method does NOT support recursion.
979         this.make = make;
980         pt = null;
981         return translate(cdef, null);
982     }
983 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
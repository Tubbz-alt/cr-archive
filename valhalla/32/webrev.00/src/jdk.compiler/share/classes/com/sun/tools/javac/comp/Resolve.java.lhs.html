<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
 111     private final boolean allowYieldStatement;
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
 135         Preview preview = Preview.instance(context);
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
 166     }
 167 
 168     private static Symbol bestOf(Symbol s1,
 169                                  Symbol s2) {
 170         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 171     }
 172 
 173     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 174     enum VerboseResolutionMode {
 175         SUCCESS(&quot;success&quot;),
 176         FAILURE(&quot;failure&quot;),
 177         APPLICABLE(&quot;applicable&quot;),
 178         INAPPLICABLE(&quot;inapplicable&quot;),
 179         DEFERRED_INST(&quot;deferred-inference&quot;),
 180         PREDEF(&quot;predef&quot;),
 181         OBJECT_INIT(&quot;object-init&quot;),
 182         INTERNAL(&quot;internal&quot;);
 183 
 184         final String opt;
 185 
 186         private VerboseResolutionMode(String opt) {
 187             this.opt = opt;
 188         }
 189 
 190         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 191             String s = opts.get(&quot;debug.verboseResolution&quot;);
 192             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 193             if (s == null) return res;
 194             if (s.contains(&quot;all&quot;)) {
 195                 res = EnumSet.allOf(VerboseResolutionMode.class);
 196             }
 197             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 198             for (VerboseResolutionMode mode : values()) {
 199                 if (args.contains(mode.opt)) {
 200                     res.add(mode);
 201                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 202                     res.remove(mode);
 203                 }
 204             }
 205             return res;
 206         }
 207     }
 208 
 209     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 210             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 211         boolean success = !bestSoFar.kind.isResolutionError();
 212 
 213         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 214             return;
 215         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 216             return;
 217         }
 218 
 219         if (bestSoFar.name == names.init &amp;&amp;
 220                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 221                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 222             return; //skip diags for Object constructor resolution
 223         } else if (site == syms.predefClass.type &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 225             return; //skip spurious diags for predef symbols (i.e. operators)
 226         } else if (currentResolutionContext.internalResolution &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 228             return;
 229         }
 230 
 231         int pos = 0;
 232         int mostSpecificPos = -1;
 233         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 234         for (Candidate c : currentResolutionContext.candidates) {
 235             if (currentResolutionContext.step != c.step ||
 236                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 237                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 238                 continue;
 239             } else {
 240                 subDiags.append(c.isApplicable() ?
 241                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 242                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 243                 if (c.sym == bestSoFar)
 244                     mostSpecificPos = pos;
 245                 pos++;
 246             }
 247         }
 248         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 249         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 250         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 251                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 252                 methodArguments(argtypes2),
 253                 methodArguments(typeargtypes));
 254         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 255         log.report(d);
 256     }
 257 
 258     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 259         JCDiagnostic subDiag = null;
 260         if (sym.type.hasTag(FORALL)) {
 261             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 262         }
 263 
 264         String key = subDiag == null ?
 265                 &quot;applicable.method.found&quot; :
 266                 &quot;applicable.method.found.1&quot;;
 267 
 268         return diags.fragment(key, pos, sym, subDiag);
 269     }
 270 
 271     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 272         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 273     }
 274     // &lt;/editor-fold&gt;
 275 
 276 /* ************************************************************************
 277  * Identifier resolution
 278  *************************************************************************/
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
 299     /** Is class accessible in given environment?
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
 320         boolean isAccessible = false;
 321         switch ((short)(c.flags() &amp; AccessFlags)) {
 322             case PRIVATE:
 323                 isAccessible =
 324                     env.enclClass.sym.outermostClass() ==
 325                     c.owner.outermostClass();
 326                 break;
 327             case 0:
 328                 isAccessible =
 329                     env.toplevel.packge == c.owner // fast special case
 330                     ||
 331                     env.toplevel.packge == c.packge();
 332                 break;
 333             default: // error recovery
 334                 isAccessible = true;
 335                 break;
 336             case PUBLIC:
 337                 if (allowModules) {
 338                     ModuleSymbol currModule = env.toplevel.modle;
 339                     currModule.complete();
 340                     PackageSymbol p = c.packge();
 341                     isAccessible =
 342                         currModule == p.modle ||
 343                         currModule.visiblePackages.get(p.fullname) == p ||
 344                         p == syms.rootPackage ||
 345                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 346                 } else {
 347                     isAccessible = true;
 348                 }
 349                 break;
 350             case PROTECTED:
 351                 isAccessible =
 352                     env.toplevel.packge == c.owner // fast special case
 353                     ||
 354                     env.toplevel.packge == c.packge()
 355                     ||
 356                     isInnerSubClass(env.enclClass.sym, c.owner);
 357                 break;
 358         }
 359         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 360             isAccessible :
 361             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 362     }
 363     //where
 364         /** Is given class a subclass of given base class, or an inner class
 365          *  of a subclass?
 366          *  Return null if no such class exists.
 367          *  @param c     The class which is the subclass or is contained in it.
 368          *  @param base  The base class
 369          */
 370         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 371             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 372                 c = c.owner.enclClass();
 373             }
 374             return c != null;
 375         }
 376 
 377     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 378         return isAccessible(env, t, false);
 379     }
 380 
 381     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 382         return (t.hasTag(ARRAY))
 383             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 384             : isAccessible(env, t.tsym, checkInner);
 385     }
 386 
 387     /** Is symbol accessible as a member of given type in given environment?
 388      *  @param env    The current environment.
 389      *  @param site   The type of which the tested symbol is regarded
 390      *                as a member.
 391      *  @param sym    The symbol.
 392      */
 393     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 394         return isAccessible(env, site, sym, false);
 395     }
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 397         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 398 
 399         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 400            to refer to an inaccessible type
 401         */
 402         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 403             return true;
 404 
 405         if (env.info.visitingServiceImplementation &amp;&amp;
 406             env.toplevel.modle == sym.packge().modle) {
 407             return true;
 408         }
 409 
<a name="1" id="anc1"></a><span class="line-modified"> 410         switch ((short)(sym.flags() &amp; AccessFlags)) {</span>
<span class="line-modified"> 411         case PRIVATE:</span>
<span class="line-modified"> 412             return</span>
<span class="line-modified"> 413                 (env.enclClass.sym == sym.owner // fast special case</span>
<span class="line-modified"> 414                  ||</span>
<span class="line-modified"> 415                  env.enclClass.sym.outermostClass() ==</span>
<span class="line-modified"> 416                  sym.owner.outermostClass())</span>
<span class="line-modified"> 417                 &amp;&amp;</span>
<span class="line-modified"> 418                 sym.isInheritedIn(site.tsym, types);</span>
<span class="line-modified"> 419         case 0:</span>
<span class="line-modified"> 420             return</span>
<span class="line-modified"> 421                 (env.toplevel.packge == sym.owner.owner // fast special case</span>
<span class="line-modified"> 422                  ||</span>
<span class="line-modified"> 423                  env.toplevel.packge == sym.packge())</span>
<span class="line-modified"> 424                 &amp;&amp;</span>
<span class="line-modified"> 425                 isAccessible(env, site, checkInner)</span>
<span class="line-modified"> 426                 &amp;&amp;</span>
<span class="line-modified"> 427                 sym.isInheritedIn(site.tsym, types)</span>
<span class="line-modified"> 428                 &amp;&amp;</span>
<span class="line-modified"> 429                 notOverriddenIn(site, sym);</span>
<span class="line-modified"> 430         case PROTECTED:</span>
<span class="line-modified"> 431             return</span>
<span class="line-modified"> 432                 (env.toplevel.packge == sym.owner.owner // fast special case</span>
<span class="line-modified"> 433                  ||</span>
<span class="line-modified"> 434                  env.toplevel.packge == sym.packge()</span>
<span class="line-modified"> 435                  ||</span>
<span class="line-modified"> 436                  isProtectedAccessible(sym, env.enclClass.sym, site)</span>
<span class="line-modified"> 437                  ||</span>
<span class="line-modified"> 438                  // OK to select instance method or field from &#39;super&#39; or type name</span>
<span class="line-modified"> 439                  // (but type names should be disallowed elsewhere!)</span>
<span class="line-modified"> 440                  env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)</span>
<span class="line-modified"> 441                 &amp;&amp;</span>
<span class="line-modified"> 442                 isAccessible(env, site, checkInner)</span>
<span class="line-modified"> 443                 &amp;&amp;</span>
<span class="line-modified"> 444                 notOverriddenIn(site, sym);</span>
<span class="line-modified"> 445         default: // this case includes erroneous combinations as well</span>
<span class="line-modified"> 446             return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);</span>
















 447         }
 448     }
 449     //where
 450     /* `sym&#39; is accessible only if not overridden by
 451      * another symbol which is a member of `site&#39;
 452      * (because, if it is overridden, `sym&#39; is not strictly
 453      * speaking a member of `site&#39;). A polymorphic signature method
 454      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 455      */
 456     private boolean notOverriddenIn(Type site, Symbol sym) {
 457         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 458             return true;
<a name="2" id="anc2"></a><span class="line-modified"> 459         else {</span>
<span class="line-modified"> 460             Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);</span>
<span class="line-modified"> 461             return (s2 == null || s2 == sym || sym.owner == s2.owner ||</span>
<span class="line-modified"> 462                     !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));</span>
<span class="line-modified"> 463         }</span>







 464     }
 465     //where
 466         /** Is given protected symbol accessible if it is selected from given site
 467          *  and the selection takes place in given class?
 468          *  @param sym     The symbol with protected access
 469          *  @param c       The class where the access takes place
 470          *  @site          The type of the qualifier
 471          */
 472         private
 473         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 474             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 475             while (c != null &amp;&amp;
 476                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 477                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 478                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 479                      // only to instance fields and methods -- types are excluded
 480                      // regardless of whether they are declared &#39;static&#39; or not.
 481                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 482                 c = c.owner.enclClass();
 483             return c != null;
 484         }
 485 
 486     /**
 487      * Performs a recursive scan of a type looking for accessibility problems
 488      * from current attribution environment
 489      */
 490     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 491         accessibilityChecker.visit(t, env);
 492     }
 493 
 494     /**
 495      * Accessibility type-visitor
 496      */
 497     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 498             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 499 
 500         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 501             for (Type t : ts) {
 502                 visit(t, env);
 503             }
 504         }
 505 
 506         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 507             return null;
 508         }
 509 
 510         @Override
 511         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 512             visit(t.elemtype, env);
 513             return null;
 514         }
 515 
 516         @Override
 517         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 518             visit(t.getTypeArguments(), env);
 519             if (!isAccessible(env, t, true)) {
 520                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 521             }
 522             return null;
 523         }
 524 
 525         @Override
 526         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 527             visit(t.type, env);
 528             return null;
 529         }
 530 
 531         @Override
 532         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 533             visit(t.getParameterTypes(), env);
 534             visit(t.getReturnType(), env);
 535             visit(t.getThrownTypes(), env);
 536             return null;
 537         }
 538     };
 539 
 540     /** Try to instantiate the type of a method so that it fits
 541      *  given type arguments and argument types. If successful, return
 542      *  the method&#39;s instantiated type, else return null.
 543      *  The instantiation will take into account an additional leading
 544      *  formal parameter if the method is an instance method seen as a member
 545      *  of an under determined site. In this case, we treat site as an additional
 546      *  parameter and the parameters of the class containing the method as
 547      *  additional type variables that get instantiated.
 548      *
 549      *  @param env         The current environment
 550      *  @param site        The type of which the method is a member.
 551      *  @param m           The method symbol.
 552      *  @param argtypes    The invocation&#39;s given value arguments.
 553      *  @param typeargtypes    The invocation&#39;s given type arguments.
 554      *  @param allowBoxing Allow boxing conversions of arguments.
 555      *  @param useVarargs Box trailing arguments into an array for varargs.
 556      */
 557     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 558                         Type site,
 559                         Symbol m,
 560                         ResultInfo resultInfo,
 561                         List&lt;Type&gt; argtypes,
 562                         List&lt;Type&gt; typeargtypes,
 563                         boolean allowBoxing,
 564                         boolean useVarargs,
 565                         Warner warn) throws Infer.InferenceException {
 566         Type mt = types.memberType(site, m);
 567         // tvars is the list of formal type variables for which type arguments
 568         // need to inferred.
 569         List&lt;Type&gt; tvars = List.nil();
 570         if (typeargtypes == null) typeargtypes = List.nil();
 571         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 572             // This is not a polymorphic method, but typeargs are supplied
 573             // which is fine, see JLS 15.12.2.1
 574         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 575             ForAll pmt = (ForAll) mt;
 576             if (typeargtypes.length() != pmt.tvars.length())
 577                  // not enough args
 578                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 579             // Check type arguments are within bounds
 580             List&lt;Type&gt; formals = pmt.tvars;
 581             List&lt;Type&gt; actuals = typeargtypes;
 582             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 583                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 584                                                 pmt.tvars, typeargtypes);
 585                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 586                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 587                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 588                     }
 589                 }
 590                 formals = formals.tail;
 591                 actuals = actuals.tail;
 592             }
 593             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 594         } else if (mt.hasTag(FORALL)) {
 595             ForAll pmt = (ForAll) mt;
 596             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 597             tvars = tvars.appendList(tvars1);
 598             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 599         }
 600 
 601         // find out whether we need to go the slow route via infer
 602         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 603         for (List&lt;Type&gt; l = argtypes;
 604              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 605              l = l.tail) {
 606             if (l.head.hasTag(FORALL)) instNeeded = true;
 607         }
 608 
 609         if (instNeeded) {
 610             return infer.instantiateMethod(env,
 611                                     tvars,
 612                                     (MethodType)mt,
 613                                     resultInfo,
 614                                     (MethodSymbol)m,
 615                                     argtypes,
 616                                     allowBoxing,
 617                                     useVarargs,
 618                                     currentResolutionContext,
 619                                     warn);
 620         }
 621 
 622         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 623         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 624                                 argtypes, mt.getParameterTypes(), warn);
 625         dc.complete();
 626         return mt;
 627     }
 628 
 629     Type checkMethod(Env&lt;AttrContext&gt; env,
 630                      Type site,
 631                      Symbol m,
 632                      ResultInfo resultInfo,
 633                      List&lt;Type&gt; argtypes,
 634                      List&lt;Type&gt; typeargtypes,
 635                      Warner warn) {
 636         MethodResolutionContext prevContext = currentResolutionContext;
 637         try {
 638             currentResolutionContext = new MethodResolutionContext();
 639             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 640                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 641             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 642                 //method/constructor references need special check class
 643                 //to handle inference variables in &#39;argtypes&#39; (might happen
 644                 //during an unsticking round)
 645                 currentResolutionContext.methodCheck =
 646                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 647             }
 648             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 649             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 650                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 651         }
 652         finally {
 653             currentResolutionContext = prevContext;
 654         }
 655     }
 656 
 657     /** Same but returns null instead throwing a NoInstanceException
 658      */
 659     Type instantiate(Env&lt;AttrContext&gt; env,
 660                      Type site,
 661                      Symbol m,
 662                      ResultInfo resultInfo,
 663                      List&lt;Type&gt; argtypes,
 664                      List&lt;Type&gt; typeargtypes,
 665                      boolean allowBoxing,
 666                      boolean useVarargs,
 667                      Warner warn) {
 668         try {
 669             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 670                                   allowBoxing, useVarargs, warn);
 671         } catch (InapplicableMethodException ex) {
 672             return null;
 673         }
 674     }
 675 
 676     /**
 677      * This interface defines an entry point that should be used to perform a
 678      * method check. A method check usually consist in determining as to whether
 679      * a set of types (actuals) is compatible with another set of types (formals).
 680      * Since the notion of compatibility can vary depending on the circumstances,
 681      * this interfaces allows to easily add new pluggable method check routines.
 682      */
 683     interface MethodCheck {
 684         /**
 685          * Main method check routine. A method check usually consist in determining
 686          * as to whether a set of types (actuals) is compatible with another set of
 687          * types (formals). If an incompatibility is found, an unchecked exception
 688          * is assumed to be thrown.
 689          */
 690         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 691                                 DeferredAttrContext deferredAttrContext,
 692                                 List&lt;Type&gt; argtypes,
 693                                 List&lt;Type&gt; formals,
 694                                 Warner warn);
 695 
 696         /**
 697          * Retrieve the method check object that will be used during a
 698          * most specific check.
 699          */
 700         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 701     }
 702 
 703     /**
 704      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 705      */
 706     enum MethodCheckDiag {
 707         /**
 708          * Actuals and formals differs in length.
 709          */
 710         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 711         /**
 712          * An actual is incompatible with a formal.
 713          */
 714         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 715         /**
 716          * An actual is incompatible with the varargs element type.
 717          */
 718         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 719         /**
 720          * The varargs element type is inaccessible.
 721          */
 722         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 723 
 724         final String basicKey;
 725         final String inferKey;
 726 
 727         MethodCheckDiag(String basicKey, String inferKey) {
 728             this.basicKey = basicKey;
 729             this.inferKey = inferKey;
 730         }
 731 
 732         String regex() {
 733             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 734         }
 735     }
 736 
 737     /**
 738      * Dummy method check object. All methods are deemed applicable, regardless
 739      * of their formal parameter types.
 740      */
 741     MethodCheck nilMethodCheck = new MethodCheck() {
 742         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 743             //do nothing - method always applicable regardless of actuals
 744         }
 745 
 746         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 747             return this;
 748         }
 749     };
 750 
 751     /**
 752      * Base class for &#39;real&#39; method checks. The class defines the logic for
 753      * iterating through formals and actuals and provides and entry point
 754      * that can be used by subclasses in order to define the actual check logic.
 755      */
 756     abstract class AbstractMethodCheck implements MethodCheck {
 757         @Override
 758         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 759                                     DeferredAttrContext deferredAttrContext,
 760                                     List&lt;Type&gt; argtypes,
 761                                     List&lt;Type&gt; formals,
 762                                     Warner warn) {
 763             //should we expand formals?
 764             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 765             JCTree callTree = treeForDiagnostics(env);
 766             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 767 
 768             //inference context used during this method check
 769             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 770 
 771             Type varargsFormal = useVarargs ? formals.last() : null;
 772 
 773             if (varargsFormal == null &amp;&amp;
 774                     argtypes.size() != formals.size()) {
 775                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 776             }
 777 
 778             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 779                 DiagnosticPosition pos = trees != null ? trees.head : null;
 780                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 781                 argtypes = argtypes.tail;
 782                 formals = formals.tail;
 783                 trees = trees != null ? trees.tail : trees;
 784             }
 785 
 786             if (formals.head != varargsFormal) {
 787                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 788             }
 789 
 790             if (useVarargs) {
 791                 //note: if applicability check is triggered by most specific test,
 792                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 793                 final Type elt = types.elemtype(varargsFormal);
 794                 while (argtypes.nonEmpty()) {
 795                     DiagnosticPosition pos = trees != null ? trees.head : null;
 796                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 797                     argtypes = argtypes.tail;
 798                     trees = trees != null ? trees.tail : trees;
 799                 }
 800             }
 801         }
 802 
 803             // where
 804             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 805                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 806             }
 807 
 808         /**
 809          * Does the actual argument conforms to the corresponding formal?
 810          */
 811         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 812 
 813         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 814             boolean inferDiag = inferenceContext != infer.emptyContext;
 815             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 816                 Object[] args2 = new Object[args.length + 1];
 817                 System.arraycopy(args, 0, args2, 1, args.length);
 818                 args2[0] = inferenceContext.inferenceVars();
 819                 args = args2;
 820             }
 821             String key = inferDiag ? diag.inferKey : diag.basicKey;
 822             throw inferDiag ?
 823                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 824                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 825         }
 826 
 827         /**
 828          * To eliminate the overhead associated with allocating an exception object in such an
 829          * hot execution path, we use flyweight pattern - and share the same exception instance
 830          * across multiple method check failures.
 831          */
 832         class SharedInapplicableMethodException extends InapplicableMethodException {
 833             private static final long serialVersionUID = 0;
 834 
 835             SharedInapplicableMethodException() {
 836                 super(null);
 837             }
 838 
 839             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 840                 this.diagnostic = details;
 841                 return this;
 842             }
 843         }
 844 
 845         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 846 
 847         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 848             return nilMethodCheck;
 849         }
 850 
 851     }
 852 
 853     /**
 854      * Arity-based method check. A method is applicable if the number of actuals
 855      * supplied conforms to the method signature.
 856      */
 857     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 858         @Override
 859         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 860             //do nothing - actual always compatible to formals
 861         }
 862 
 863         @Override
 864         public String toString() {
 865             return &quot;arityMethodCheck&quot;;
 866         }
 867     };
 868 
 869     /**
 870      * Main method applicability routine. Given a list of actual types A,
 871      * a list of formal types F, determines whether the types in A are
 872      * compatible (by method invocation conversion) with the types in F.
 873      *
 874      * Since this routine is shared between overload resolution and method
 875      * type-inference, a (possibly empty) inference context is used to convert
 876      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 877      * check so that constraints can be propagated and collected.
 878      *
 879      * Moreover, if one or more types in A is a deferred type, this routine uses
 880      * DeferredAttr in order to perform deferred attribution. If one or more actual
 881      * deferred types are stuck, they are placed in a queue and revisited later
 882      * after the remainder of the arguments have been seen. If this is not sufficient
 883      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 884      *
 885      * A method check handler (see above) is used in order to report errors.
 886      */
 887     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 888 
 889         @Override
 890         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 891             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 892             mresult.check(pos, actual);
 893         }
 894 
 895         @Override
 896         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 897                                     DeferredAttrContext deferredAttrContext,
 898                                     List&lt;Type&gt; argtypes,
 899                                     List&lt;Type&gt; formals,
 900                                     Warner warn) {
 901             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 902             // should we check varargs element type accessibility?
 903             if (deferredAttrContext.phase.isVarargsRequired()) {
 904                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 905                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 906                 }
 907             }
 908         }
 909 
 910         /**
 911          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 912          * varargs element type of either the method invocation type signature (after inference completes)
 913          * or the method declaration signature (before inference completes).
 914          */
 915         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 916             if (inferenceContext.free(t)) {
 917                 inferenceContext.addFreeTypeListener(List.of(t),
 918                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 919             } else {
 920                 if (!isAccessible(env, types.erasure(t))) {
 921                     Symbol location = env.enclClass.sym;
 922                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 923                 }
 924             }
 925         }
 926 
 927         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 928                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 929             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 930                 MethodCheckDiag methodDiag = varargsCheck ?
 931                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 932 
 933                 @Override
 934                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 935                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 936                 }
 937             };
 938             return new MethodResultInfo(to, checkContext);
 939         }
 940 
 941         @Override
 942         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 943             return new MostSpecificCheck(actuals);
 944         }
 945 
 946         @Override
 947         public String toString() {
 948             return &quot;resolveMethodCheck&quot;;
 949         }
 950     };
 951 
 952     /**
 953      * This class handles method reference applicability checks; since during
 954      * these checks it&#39;s sometime possible to have inference variables on
 955      * the actual argument types list, the method applicability check must be
 956      * extended so that inference variables are &#39;opened&#39; as needed.
 957      */
 958     class MethodReferenceCheck extends AbstractMethodCheck {
 959 
 960         InferenceContext pendingInferenceContext;
 961 
 962         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 963             this.pendingInferenceContext = pendingInferenceContext;
 964         }
 965 
 966         @Override
 967         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 968             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 969             mresult.check(pos, actual);
 970         }
 971 
 972         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 973                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 974             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 975                 MethodCheckDiag methodDiag = varargsCheck ?
 976                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 977 
 978                 @Override
 979                 public boolean compatible(Type found, Type req, Warner warn) {
 980                     found = pendingInferenceContext.asUndetVar(found);
 981                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
 982                         req = types.boxedClass(req).type;
 983                     }
 984                     return super.compatible(found, req, warn);
 985                 }
 986 
 987                 @Override
 988                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 989                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 990                 }
 991             };
 992             return new MethodResultInfo(to, checkContext);
 993         }
 994 
 995         @Override
 996         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 997             return new MostSpecificCheck(actuals);
 998         }
 999 
1000         @Override
1001         public String toString() {
1002             return &quot;MethodReferenceCheck&quot;;
1003         }
1004     }
1005 
1006     /**
1007      * Check context to be used during method applicability checks. A method check
1008      * context might contain inference variables.
1009      */
1010     abstract class MethodCheckContext implements CheckContext {
1011 
1012         boolean strict;
1013         DeferredAttrContext deferredAttrContext;
1014         Warner rsWarner;
1015 
1016         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1017            this.strict = strict;
1018            this.deferredAttrContext = deferredAttrContext;
1019            this.rsWarner = rsWarner;
1020         }
1021 
1022         public boolean compatible(Type found, Type req, Warner warn) {
1023             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1024             return strict ?
1025                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1026                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1027         }
1028 
1029         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1030             throw new InapplicableMethodException(details);
1031         }
1032 
1033         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1034             return rsWarner;
1035         }
1036 
1037         public InferenceContext inferenceContext() {
1038             return deferredAttrContext.inferenceContext;
1039         }
1040 
1041         public DeferredAttrContext deferredAttrContext() {
1042             return deferredAttrContext;
1043         }
1044 
1045         @Override
1046         public String toString() {
1047             return &quot;MethodCheckContext&quot;;
1048         }
1049     }
1050 
1051     /**
1052      * ResultInfo class to be used during method applicability checks. Check
1053      * for deferred types goes through special path.
1054      */
1055     class MethodResultInfo extends ResultInfo {
1056 
1057         public MethodResultInfo(Type pt, CheckContext checkContext) {
1058             attr.super(KindSelector.VAL, pt, checkContext);
1059         }
1060 
1061         @Override
1062         protected Type check(DiagnosticPosition pos, Type found) {
1063             if (found.hasTag(DEFERRED)) {
1064                 DeferredType dt = (DeferredType)found;
1065                 return dt.check(this);
1066             } else {
1067                 Type uResult = U(found);
1068                 Type capturedType = pos == null || pos.getTree() == null ?
1069                         types.capture(uResult) :
1070                         checkContext.inferenceContext()
1071                             .cachedCapture(pos.getTree(), uResult, true);
1072                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1073             }
1074         }
1075 
1076         /**
1077          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1078          * given an actual argument type, the method check is performed
1079          * on its upper bound. This leads to inconsistencies when an
1080          * argument type is checked against itself. For example, given
1081          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1082          * so we need to guard against that.
1083          */
1084         private Type U(Type found) {
1085             return found == pt ?
1086                     found : types.cvarUpperBound(found);
1087         }
1088 
1089         @Override
1090         protected MethodResultInfo dup(Type newPt) {
1091             return new MethodResultInfo(newPt, checkContext);
1092         }
1093 
1094         @Override
1095         protected ResultInfo dup(CheckContext newContext) {
1096             return new MethodResultInfo(pt, newContext);
1097         }
1098 
1099         @Override
1100         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1101             return new MethodResultInfo(newPt, newContext);
1102         }
1103     }
1104 
1105     /**
1106      * Most specific method applicability routine. Given a list of actual types A,
1107      * a list of formal types F1, and a list of formal types F2, the routine determines
1108      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1109      * argument types A.
1110      */
1111     class MostSpecificCheck implements MethodCheck {
1112 
1113         List&lt;Type&gt; actuals;
1114 
1115         MostSpecificCheck(List&lt;Type&gt; actuals) {
1116             this.actuals = actuals;
1117         }
1118 
1119         @Override
1120         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1121                                     DeferredAttrContext deferredAttrContext,
1122                                     List&lt;Type&gt; formals1,
1123                                     List&lt;Type&gt; formals2,
1124                                     Warner warn) {
1125             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1126             while (formals2.nonEmpty()) {
1127                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1128                 mresult.check(null, formals1.head);
1129                 formals1 = formals1.tail;
1130                 formals2 = formals2.tail;
1131                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1132             }
1133         }
1134 
1135        /**
1136         * Create a method check context to be used during the most specific applicability check
1137         */
1138         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1139                Warner rsWarner, Type actual) {
1140             return attr.new ResultInfo(KindSelector.VAL, to,
1141                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1142         }
1143 
1144         /**
1145          * Subclass of method check context class that implements most specific
1146          * method conversion. If the actual type under analysis is a deferred type
1147          * a full blown structural analysis is carried out.
1148          */
1149         class MostSpecificCheckContext extends MethodCheckContext {
1150 
1151             Type actual;
1152 
1153             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1154                 super(true, deferredAttrContext, rsWarner);
1155                 this.actual = actual;
1156             }
1157 
1158             public boolean compatible(Type found, Type req, Warner warn) {
1159                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1160                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1161                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1162                     DeferredType dt = (DeferredType) actual;
1163                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1164                     if (speculativeTree != deferredAttr.stuckTree) {
1165                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1166                     }
1167                 }
1168                 return compatibleBySubtyping(found, req);
1169             }
1170 
1171             private boolean compatibleBySubtyping(Type found, Type req) {
1172                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1173                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1174                 }
1175                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1176             }
1177 
1178             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1179             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1180                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1181                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1182                        unrelatedInterfaces(t, s);
1183             }
1184 
1185             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1186             private boolean unrelatedInterfaces(Type t, Type s) {
1187                 if (t.isCompound()) {
1188                     for (Type ti : types.interfaces(t)) {
1189                         if (!unrelatedInterfaces(ti, s)) {
1190                             return false;
1191                         }
1192                     }
1193                     return true;
1194                 } else if (s.isCompound()) {
1195                     for (Type si : types.interfaces(s)) {
1196                         if (!unrelatedInterfaces(t, si)) {
1197                             return false;
1198                         }
1199                     }
1200                     return true;
1201                 } else {
1202                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1203                 }
1204             }
1205 
1206             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1207             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1208                 Type tDesc = types.findDescriptorType(types.capture(t));
1209                 Type tDescNoCapture = types.findDescriptorType(t);
1210                 Type sDesc = types.findDescriptorType(s);
1211                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1212                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1213                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1214 
1215                 // compare type parameters
1216                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1217                     return false;
1218                 }
1219                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1220                 List&lt;Type&gt; tIter = tTypeParams;
1221                 List&lt;Type&gt; sIter = sTypeParams;
1222                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1223                     Type tBound = tIter.head.getUpperBound();
1224                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1225                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1226                         return false;
1227                     }
1228                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1229                         return false;
1230                     }
1231                     tIter = tIter.tail;
1232                     sIter = sIter.tail;
1233                 }
1234                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1235                     return false;
1236                 }
1237 
1238                 // compare parameters
1239                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1240                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1241                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1242                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1243                     Type tParam = tParams.head;
1244                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1245                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1246                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1247                         return false;
1248                     }
1249                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1250                         return false;
1251                     }
1252                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1253                         return false;
1254                     }
1255                     tParams = tParams.tail;
1256                     tParamsNoCapture = tParamsNoCapture.tail;
1257                     sParams = sParams.tail;
1258                 }
1259                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1260                     return false;
1261                 }
1262 
1263                 // compare returns
1264                 Type tRet = tDesc.getReturnType();
1265                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1266                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1267                     return false;
1268                 }
1269                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1270                 msc.scan(tree);
1271                 return msc.result;
1272             }
1273 
1274             /**
1275              * Tests whether one functional interface type can be considered more specific
1276              * than another unrelated functional interface type for the scanned expression.
1277              */
1278             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1279 
1280                 final Type tRet;
1281                 final Type sRet;
1282                 boolean result;
1283 
1284                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1285                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1286                     this.tRet = tRet;
1287                     this.sRet = sRet;
1288                     result = true;
1289                 }
1290 
1291                 @Override
1292                 void skip(JCTree tree) {
1293                     result &amp;= false;
1294                 }
1295 
1296                 @Override
1297                 public void visitConditional(JCConditional tree) {
1298                     scan(asExpr(tree.truepart));
1299                     scan(asExpr(tree.falsepart));
1300                 }
1301 
1302                 @Override
1303                 public void visitReference(JCMemberReference tree) {
1304                     if (sRet.hasTag(VOID)) {
1305                         result &amp;= true;
1306                     } else if (tRet.hasTag(VOID)) {
1307                         result &amp;= false;
1308                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1309                         boolean retValIsPrimitive =
1310                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1311                                 tree.sym.type.getReturnType().isPrimitive();
1312                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1313                                   (retValIsPrimitive != sRet.isPrimitive());
1314                     } else {
1315                         result &amp;= compatibleBySubtyping(tRet, sRet);
1316                     }
1317                 }
1318 
1319                 @Override
1320                 public void visitParens(JCParens tree) {
1321                     scan(asExpr(tree.expr));
1322                 }
1323 
1324                 @Override
1325                 public void visitLambda(JCLambda tree) {
1326                     if (sRet.hasTag(VOID)) {
1327                         result &amp;= true;
1328                     } else if (tRet.hasTag(VOID)) {
1329                         result &amp;= false;
1330                     } else {
1331                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1332                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1333                             for (JCExpression expr : lambdaResults) {
1334                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1335                             }
1336                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1337                             for (JCExpression expr : lambdaResults) {
1338                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1339                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1340                                         (retValIsPrimitive != sRet.isPrimitive());
1341                             }
1342                         } else {
1343                             result &amp;= compatibleBySubtyping(tRet, sRet);
1344                         }
1345                     }
1346                 }
1347                 //where
1348 
1349                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1350                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1351                         return List.of(asExpr((JCExpression) lambda.body));
1352                     } else {
1353                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1354                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1355                                 new DeferredAttr.LambdaReturnScanner() {
1356                                     @Override
1357                                     public void visitReturn(JCReturn tree) {
1358                                         if (tree.expr != null) {
1359                                             buffer.append(asExpr(tree.expr));
1360                                         }
1361                                     }
1362                                 };
1363                         lambdaScanner.scan(lambda.body);
1364                         return buffer.toList();
1365                     }
1366                 }
1367 
1368                 private JCExpression asExpr(JCExpression expr) {
1369                     if (expr.type.hasTag(DEFERRED)) {
1370                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1371                         if (speculativeTree != deferredAttr.stuckTree) {
1372                             expr = (JCExpression)speculativeTree;
1373                         }
1374                     }
1375                     return expr;
1376                 }
1377             }
1378 
1379         }
1380 
1381         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1382             Assert.error(&quot;Cannot get here!&quot;);
1383             return null;
1384         }
1385     }
1386 
1387     public static class InapplicableMethodException extends RuntimeException {
1388         private static final long serialVersionUID = 0;
1389 
1390         transient JCDiagnostic diagnostic;
1391 
1392         InapplicableMethodException(JCDiagnostic diag) {
1393             this.diagnostic = diag;
1394         }
1395 
1396         public JCDiagnostic getDiagnostic() {
1397             return diagnostic;
1398         }
1399     }
1400 
1401 /* ***************************************************************************
1402  *  Symbol lookup
1403  *  the following naming conventions for arguments are used
1404  *
1405  *       env      is the environment where the symbol was mentioned
1406  *       site     is the type of which the symbol is a member
1407  *       name     is the symbol&#39;s name
1408  *                if no arguments are given
1409  *       argtypes are the value arguments, if we search for a method
1410  *
1411  *  If no symbol was found, a ResolveError detailing the problem is returned.
1412  ****************************************************************************/
1413 
1414     /** Find field. Synthetic fields are always skipped.
1415      *  @param env     The current environment.
1416      *  @param site    The original type from where the selection takes place.
1417      *  @param name    The name of the field.
1418      *  @param c       The class to search for the field. This is always
1419      *                 a superclass or implemented interface of site&#39;s class.
1420      */
1421     Symbol findField(Env&lt;AttrContext&gt; env,
1422                      Type site,
1423                      Name name,
1424                      TypeSymbol c) {
1425         while (c.type.hasTag(TYPEVAR))
1426             c = c.type.getUpperBound().tsym;
1427         Symbol bestSoFar = varNotFound;
1428         Symbol sym;
1429         for (Symbol s : c.members().getSymbolsByName(name)) {
1430             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1431                 return isAccessible(env, site, s)
1432                     ? s : new AccessError(env, site, s);
1433             }
1434         }
1435         Type st = types.supertype(c.type);
1436         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1437             sym = findField(env, site, name, st.tsym);
1438             bestSoFar = bestOf(bestSoFar, sym);
1439         }
1440         for (List&lt;Type&gt; l = types.interfaces(c.type);
1441              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1442              l = l.tail) {
1443             sym = findField(env, site, name, l.head.tsym);
1444             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1445                 sym.owner != bestSoFar.owner)
1446                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1447             else
1448                 bestSoFar = bestOf(bestSoFar, sym);
1449         }
1450         return bestSoFar;
1451     }
1452 
1453     /** Resolve a field identifier, throw a fatal error if not found.
1454      *  @param pos       The position to use for error reporting.
1455      *  @param env       The environment current at the method invocation.
1456      *  @param site      The type of the qualifying expression, in which
1457      *                   identifier is searched.
1458      *  @param name      The identifier&#39;s name.
1459      */
1460     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1461                                           Type site, Name name) {
1462         Symbol sym = findField(env, site, name, site.tsym);
1463         if (sym.kind == VAR) return (VarSymbol)sym;
1464         else throw new FatalError(
1465                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1466     }
1467 
1468     /** Find unqualified variable or field with given name.
1469      *  Synthetic fields always skipped.
1470      *  @param env     The current environment.
1471      *  @param name    The name of the variable or field.
1472      */
1473     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1474         Symbol bestSoFar = varNotFound;
1475         Env&lt;AttrContext&gt; env1 = env;
1476         boolean staticOnly = false;
1477         while (env1.outer != null) {
1478             Symbol sym = null;
1479             if (isStatic(env1)) staticOnly = true;
1480             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1481                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1482                     sym = s;
1483                     break;
1484                 }
1485             }
1486             if (sym == null) {
1487                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1488             }
1489             if (sym.exists()) {
1490                 if (staticOnly &amp;&amp;
1491                     sym.kind == VAR &amp;&amp;
1492                         // if it is a field
1493                         (sym.owner.kind == TYP ||
1494                         // or it is a local variable but it is not declared inside of the static local type
1495                         // only records so far, then error
1496                         (sym.owner.kind == MTH) &amp;&amp;
1497                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;
1498                         sym.enclClass() != env.enclClass.sym) &amp;&amp;
1499                     (sym.flags() &amp; STATIC) == 0)
1500                     return new StaticError(sym);
1501                 else
1502                     return sym;
1503             } else {
1504                 bestSoFar = bestOf(bestSoFar, sym);
1505             }
1506 
1507             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1508             env1 = env1.outer;
1509         }
1510 
1511         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1512         if (sym.exists())
1513             return sym;
1514         if (bestSoFar.exists())
1515             return bestSoFar;
1516 
1517         Symbol origin = null;
1518         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1519             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1520                 if (currentSymbol.kind != VAR)
1521                     continue;
1522                 // invariant: sym.kind == Symbol.Kind.VAR
1523                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1524                     currentSymbol.owner != bestSoFar.owner)
1525                     return new AmbiguityError(bestSoFar, currentSymbol);
1526                 else if (!bestSoFar.kind.betterThan(VAR)) {
1527                     origin = sc.getOrigin(currentSymbol).owner;
1528                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1529                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1530                 }
1531             }
1532             if (bestSoFar.exists()) break;
1533         }
1534         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1535             return bestSoFar.clone(origin);
1536         else
1537             return bestSoFar;
1538     }
1539 
1540     Warner noteWarner = new Warner();
1541 
1542     /** Select the best method for a call site among two choices.
1543      *  @param env              The current environment.
1544      *  @param site             The original type from where the
1545      *                          selection takes place.
1546      *  @param argtypes         The invocation&#39;s value arguments,
1547      *  @param typeargtypes     The invocation&#39;s type arguments,
1548      *  @param sym              Proposed new best match.
1549      *  @param bestSoFar        Previously found best match.
1550      *  @param allowBoxing Allow boxing conversions of arguments.
1551      *  @param useVarargs Box trailing arguments into an array for varargs.
1552      */
1553     @SuppressWarnings(&quot;fallthrough&quot;)
1554     Symbol selectBest(Env&lt;AttrContext&gt; env,
1555                       Type site,
1556                       List&lt;Type&gt; argtypes,
1557                       List&lt;Type&gt; typeargtypes,
1558                       Symbol sym,
1559                       Symbol bestSoFar,
1560                       boolean allowBoxing,
1561                       boolean useVarargs) {
1562         if (sym.kind == ERR ||
1563                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1564                 !notOverriddenIn(site, sym)) {
1565             return bestSoFar;
1566         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1567             return bestSoFar.kind.isResolutionError() ?
1568                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1569                     bestSoFar;
1570         }
1571         Assert.check(!sym.kind.isResolutionError());
1572         try {
1573             types.noWarnings.clear();
1574             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1575                                allowBoxing, useVarargs, types.noWarnings);
1576             currentResolutionContext.addApplicableCandidate(sym, mt);
1577         } catch (InapplicableMethodException ex) {
1578             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1579             switch (bestSoFar.kind) {
1580                 case ABSENT_MTH:
1581                     return new InapplicableSymbolError(currentResolutionContext);
1582                 case WRONG_MTH:
1583                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1584                 default:
1585                     return bestSoFar;
1586             }
1587         }
1588         if (!isAccessible(env, site, sym)) {
1589             return (bestSoFar.kind == ABSENT_MTH)
1590                 ? new AccessError(env, site, sym)
1591                 : bestSoFar;
1592         }
1593         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1594             ? sym
1595             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1596     }
1597 
1598     /* Return the most specific of the two methods for a call,
1599      *  given that both are accessible and applicable.
1600      *  @param m1               A new candidate for most specific.
1601      *  @param m2               The previous most specific candidate.
1602      *  @param env              The current environment.
1603      *  @param site             The original type from where the selection
1604      *                          takes place.
1605      *  @param allowBoxing Allow boxing conversions of arguments.
1606      *  @param useVarargs Box trailing arguments into an array for varargs.
1607      */
1608     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1609                         Symbol m2,
1610                         Env&lt;AttrContext&gt; env,
1611                         final Type site,
1612                         boolean useVarargs) {
1613         switch (m2.kind) {
1614         case MTH:
1615             if (m1 == m2) return m1;
1616             boolean m1SignatureMoreSpecific =
1617                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1618             boolean m2SignatureMoreSpecific =
1619                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1620             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1621                 Type mt1 = types.memberType(site, m1);
1622                 Type mt2 = types.memberType(site, m2);
1623                 if (!types.overrideEquivalent(mt1, mt2))
1624                     return ambiguityError(m1, m2);
1625 
1626                 // same signature; select (a) the non-bridge method, or
1627                 // (b) the one that overrides the other, or (c) the concrete
1628                 // one, or (d) merge both abstract signatures
1629                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1630                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1631 
1632                 if (m1.baseSymbol() == m2.baseSymbol()) {
1633                     // this is the same imported symbol which has been cloned twice.
1634                     // Return the first one (either will do).
1635                     return m1;
1636                 }
1637 
1638                 // if one overrides or hides the other, use it
1639                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1640                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1641                 // the two owners can never be the same if the target methods are compiled from source,
1642                 // but we need to protect against cases where the methods are defined in some classfile
1643                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1644                 if (m1Owner != m2Owner) {
1645                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1646                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1647                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1648                         m1.overrides(m2, m1Owner, types, false))
1649                         return m1;
1650                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1651                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1652                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1653                         m2.overrides(m1, m2Owner, types, false))
1654                         return m2;
1655                 }
1656                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1657                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1658                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1659                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1660                 // both abstract or both concrete
1661                 return ambiguityError(m1, m2);
1662             }
1663             if (m1SignatureMoreSpecific) return m1;
1664             if (m2SignatureMoreSpecific) return m2;
1665             return ambiguityError(m1, m2);
1666         case AMBIGUOUS:
1667             //compare m1 to ambiguous methods in m2
1668             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1669             boolean m1MoreSpecificThanAnyAmbiguous = true;
1670             boolean allAmbiguousMoreSpecificThanM1 = true;
1671             for (Symbol s : e.ambiguousSyms) {
1672                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1673                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1674                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1675             }
1676             if (m1MoreSpecificThanAnyAmbiguous)
1677                 return m1;
1678             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1679             //more specific than m1, add it as a new ambiguous method:
1680             if (!allAmbiguousMoreSpecificThanM1)
1681                 e.addAmbiguousSymbol(m1);
1682             return e;
1683         default:
1684             throw new AssertionError();
1685         }
1686     }
1687     //where
1688     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1689         noteWarner.clear();
1690         int maxLength = Math.max(
1691                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1692                             m2.type.getParameterTypes().length());
1693         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1694         try {
1695             currentResolutionContext = new MethodResolutionContext();
1696             currentResolutionContext.step = prevResolutionContext.step;
1697             currentResolutionContext.methodCheck =
1698                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1699             Type mst = instantiate(env, site, m2, null,
1700                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1701                     false, useVarargs, noteWarner);
1702             return mst != null &amp;&amp;
1703                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1704         } finally {
1705             currentResolutionContext = prevResolutionContext;
1706         }
1707     }
1708 
1709     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1710         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1711             Type varargsElem = types.elemtype(args.last());
1712             if (varargsElem == null) {
1713                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1714             }
1715             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1716             while (newArgs.length() &lt; length) {
1717                 newArgs = newArgs.append(newArgs.last());
1718             }
1719             return newArgs;
1720         } else {
1721             return args;
1722         }
1723     }
1724     //where
1725     Symbol ambiguityError(Symbol m1, Symbol m2) {
1726         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1727             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1728         } else {
1729             return new AmbiguityError(m1, m2);
1730         }
1731     }
1732 
1733     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1734             Type site,
1735             Name name,
1736             List&lt;Type&gt; argtypes,
1737             List&lt;Type&gt; typeargtypes,
1738             Scope sc,
1739             Symbol bestSoFar,
1740             boolean allowBoxing,
1741             boolean useVarargs,
1742             boolean abstractok) {
1743         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1744             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1745                     bestSoFar, allowBoxing, useVarargs);
1746         }
1747         return bestSoFar;
1748     }
1749     //where
1750         class LookupFilter implements Filter&lt;Symbol&gt; {
1751 
1752             boolean abstractOk;
1753 
1754             LookupFilter(boolean abstractOk) {
1755                 this.abstractOk = abstractOk;
1756             }
1757 
1758             public boolean accepts(Symbol s) {
1759                 long flags = s.flags();
1760                 return s.kind == MTH &amp;&amp;
1761                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1762                         (abstractOk ||
1763                         (flags &amp; DEFAULT) != 0 ||
1764                         (flags &amp; ABSTRACT) == 0);
1765             }
1766         }
1767 
1768     /** Find best qualified method matching given name, type and value
1769      *  arguments.
1770      *  @param env       The current environment.
1771      *  @param site      The original type from where the selection
1772      *                   takes place.
1773      *  @param name      The method&#39;s name.
1774      *  @param argtypes  The method&#39;s value arguments.
1775      *  @param typeargtypes The method&#39;s type arguments
1776      *  @param allowBoxing Allow boxing conversions of arguments.
1777      *  @param useVarargs Box trailing arguments into an array for varargs.
1778      */
1779     Symbol findMethod(Env&lt;AttrContext&gt; env,
1780                       Type site,
1781                       Name name,
1782                       List&lt;Type&gt; argtypes,
1783                       List&lt;Type&gt; typeargtypes,
1784                       boolean allowBoxing,
1785                       boolean useVarargs) {
1786         Symbol bestSoFar = methodNotFound;
1787         bestSoFar = findMethod(env,
1788                           site,
1789                           name,
1790                           argtypes,
1791                           typeargtypes,
1792                           site.tsym.type,
1793                           bestSoFar,
1794                           allowBoxing,
1795                           useVarargs);
1796         return bestSoFar;
1797     }
1798     // where
1799     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1800                               Type site,
1801                               Name name,
1802                               List&lt;Type&gt; argtypes,
1803                               List&lt;Type&gt; typeargtypes,
1804                               Type intype,
1805                               Symbol bestSoFar,
1806                               boolean allowBoxing,
1807                               boolean useVarargs) {
1808         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1809         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1810 
1811         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1812         for (TypeSymbol s : superclasses(intype)) {
1813             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1814                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1815             if (name == names.init) return bestSoFar;
1816             iphase = (iphase == null) ? null : iphase.update(s, this);
1817             if (iphase != null) {
1818                 for (Type itype : types.interfaces(s.type)) {
1819                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1820                 }
1821             }
1822         }
1823 
1824         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1825                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1826                 bestSoFar : methodNotFound;
1827 
1828         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1829             //keep searching for abstract methods
1830             for (Type itype : itypes[iphase2.ordinal()]) {
1831                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1832                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1833                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1834                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1835                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1836                 if (concrete != bestSoFar &amp;&amp;
1837                     concrete.kind.isValid() &amp;&amp;
1838                     bestSoFar.kind.isValid() &amp;&amp;
1839                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1840                     //this is an hack - as javac does not do full membership checks
1841                     //most specific ends up comparing abstract methods that might have
1842                     //been implemented by some concrete method in a subclass and,
1843                     //because of raw override, it is possible for an abstract method
1844                     //to be more specific than the concrete method - so we need
1845                     //to explicitly call that out (see CR 6178365)
1846                     bestSoFar = concrete;
1847                 }
1848             }
1849         }
1850         return bestSoFar;
1851     }
1852 
1853     enum InterfaceLookupPhase {
1854         ABSTRACT_OK() {
1855             @Override
1856             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1857                 //We should not look for abstract methods if receiver is a concrete class
1858                 //(as concrete classes are expected to implement all abstracts coming
1859                 //from superinterfaces)
1860                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1861                     return this;
1862                 } else {
1863                     return DEFAULT_OK;
1864                 }
1865             }
1866         },
1867         DEFAULT_OK() {
1868             @Override
1869             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1870                 return this;
1871             }
1872         };
1873 
1874         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1875     }
1876 
1877     /**
1878      * Return an Iterable object to scan the superclasses of a given type.
1879      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1880      * access more supertypes than strictly needed (as this could trigger completion
1881      * errors if some of the not-needed supertypes are missing/ill-formed).
1882      */
1883     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1884         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1885 
1886             List&lt;TypeSymbol&gt; seen = List.nil();
1887             TypeSymbol currentSym = symbolFor(intype);
1888             TypeSymbol prevSym = null;
1889 
1890             public boolean hasNext() {
1891                 if (currentSym == syms.noSymbol) {
1892                     currentSym = symbolFor(types.supertype(prevSym.type));
1893                 }
1894                 return currentSym != null;
1895             }
1896 
1897             public TypeSymbol next() {
1898                 prevSym = currentSym;
1899                 currentSym = syms.noSymbol;
1900                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1901                 return prevSym;
1902             }
1903 
1904             public void remove() {
1905                 throw new UnsupportedOperationException();
1906             }
1907 
1908             TypeSymbol symbolFor(Type t) {
1909                 if (!t.hasTag(CLASS) &amp;&amp;
1910                         !t.hasTag(TYPEVAR)) {
1911                     return null;
1912                 }
1913                 t = types.skipTypeVars(t, false);
1914                 if (seen.contains(t.tsym)) {
1915                     //degenerate case in which we have a circular
1916                     //class hierarchy - because of ill-formed classfiles
1917                     return null;
1918                 }
1919                 seen = seen.prepend(t.tsym);
1920                 return t.tsym;
1921             }
1922         };
1923     }
1924 
1925     /** Find unqualified method matching given name, type and value arguments.
1926      *  @param env       The current environment.
1927      *  @param name      The method&#39;s name.
1928      *  @param argtypes  The method&#39;s value arguments.
1929      *  @param typeargtypes  The method&#39;s type arguments.
1930      *  @param allowBoxing Allow boxing conversions of arguments.
1931      *  @param useVarargs Box trailing arguments into an array for varargs.
1932      */
1933     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1934                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1935                    boolean allowBoxing, boolean useVarargs) {
1936         Symbol bestSoFar = methodNotFound;
1937         Env&lt;AttrContext&gt; env1 = env;
1938         boolean staticOnly = false;
1939         while (env1.outer != null) {
1940             if (isStatic(env1)) staticOnly = true;
1941             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1942             env1.info.preferredTreeForDiagnostics = env.tree;
1943             try {
1944                 Symbol sym = findMethod(
1945                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1946                     allowBoxing, useVarargs);
1947                 if (sym.exists()) {
1948                     if (staticOnly &amp;&amp;
1949                         sym.kind == MTH &amp;&amp;
1950                         sym.owner.kind == TYP &amp;&amp;
1951                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1952                     else return sym;
1953                 } else {
1954                     bestSoFar = bestOf(bestSoFar, sym);
1955                 }
1956             } finally {
1957                 env1.info.preferredTreeForDiagnostics = null;
1958             }
1959             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1960             env1 = env1.outer;
1961         }
1962 
1963         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1964                                 typeargtypes, allowBoxing, useVarargs);
1965         if (sym.exists())
1966             return sym;
1967 
1968         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1969             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1970             if (currentSym.kind == MTH) {
1971                 if (currentSym.owner.type != origin.type)
1972                     currentSym = currentSym.clone(origin);
1973                 if (!isAccessible(env, origin.type, currentSym))
1974                     currentSym = new AccessError(env, origin.type, currentSym);
1975                 bestSoFar = selectBest(env, origin.type,
1976                                        argtypes, typeargtypes,
1977                                        currentSym, bestSoFar,
1978                                        allowBoxing, useVarargs);
1979             }
1980         }
1981         if (bestSoFar.exists())
1982             return bestSoFar;
1983 
1984         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
1985             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
1986             if (currentSym.kind == MTH) {
1987                 if (currentSym.owner.type != origin.type)
1988                     currentSym = currentSym.clone(origin);
1989                 if (!isAccessible(env, origin.type, currentSym))
1990                     currentSym = new AccessError(env, origin.type, currentSym);
1991                 bestSoFar = selectBest(env, origin.type,
1992                                        argtypes, typeargtypes,
1993                                        currentSym, bestSoFar,
1994                                        allowBoxing, useVarargs);
1995             }
1996         }
1997         return bestSoFar;
1998     }
1999 
2000     /** Load toplevel or member class with given fully qualified name and
2001      *  verify that it is accessible.
2002      *  @param env       The current environment.
2003      *  @param name      The fully qualified name of the class to be loaded.
2004      */
2005     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2006         try {
2007             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2008             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2009         } catch (ClassFinder.BadClassFile err) {
2010             return new BadClassFileError(err);
2011         } catch (CompletionFailure ex) {
2012             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2013 
2014             if (candidate != null) {
2015                 return candidate;
2016             }
2017 
2018             return typeNotFound;
2019         }
2020     }
2021 
2022     public interface RecoveryLoadClass {
2023         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2024     }
2025 
2026     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2027 
2028     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2029         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2030             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2031             return lookupInvisibleSymbol(env, name,
2032                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2033                                                                            c -&gt; syms.getClassesForName(c)
2034                                                                                     .iterator()),
2035                                          (ms, n) -&gt; {
2036                 for (Name candidate : candidates) {
2037                     try {
2038                         return finder.loadClass(ms, candidate);
2039                     } catch (CompletionFailure cf) {
2040                         //ignore
2041                     }
2042                 }
2043                 return null;
2044             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2045         }
2046     };
2047 
2048     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2049         Scope importScope = env.toplevel.namedImportScope;
2050         Symbol existing = importScope.findFirst(Convert.shortName(name),
2051                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2052 
2053         if (existing != null) {
2054             return new InvisibleSymbolError(env, true, existing);
2055         }
2056         return null;
2057     };
2058 
2059     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2060         Scope importScope = env.toplevel.starImportScope;
2061         Symbol existing = importScope.findFirst(Convert.shortName(name),
2062                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2063 
2064         if (existing != null) {
2065             try {
2066                 existing = finder.loadClass(existing.packge().modle, name);
2067 
2068                 return new InvisibleSymbolError(env, true, existing);
2069             } catch (CompletionFailure cf) {
2070                 //ignore
2071             }
2072         }
2073 
2074         return null;
2075     };
2076 
2077     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2078         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2079 
2080         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2081             if (pack.members().isEmpty()) {
2082                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2083                     sym.complete();
2084                     return !sym.members().isEmpty();
2085                 }, pack);
2086             }
2087         }
2088 
2089         return pack;
2090     }
2091 
2092     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2093         if (!env.tree.hasTag(IMPORT))
2094             return false;
2095 
2096         JCTree qualid = ((JCImport) env.tree).qualid;
2097 
2098         if (!qualid.hasTag(SELECT))
2099             return false;
2100 
2101         if (TreeInfo.name(qualid) != names.asterisk)
2102             return false;
2103 
2104         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2105     }
2106 
2107     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2108                                                             Name name,
2109                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2110                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2111                                                             Predicate&lt;S&gt; validate,
2112                                                             Symbol defaultResult) {
2113         //even if a class/package cannot be found in the current module and among packages in modules
2114         //it depends on that are exported for any or this module, the class/package may exist internally
2115         //in some of these modules, or may exist in a module on which this module does not depend.
2116         //Provide better diagnostic in such cases by looking for the class in any module:
2117         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2118 
2119         for (S sym : candidates) {
2120             if (validate.test(sym))
2121                 return createInvisibleSymbolError(env, sym);
2122         }
2123 
2124         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2125 
2126         recoverableModules.add(syms.unnamedModule);
2127         recoverableModules.remove(env.toplevel.modle);
2128 
2129         for (ModuleSymbol ms : recoverableModules) {
2130             //avoid overly eager completing classes from source-based modules, as those
2131             //may not be completable with the current compiler settings:
2132             if (ms.sourceLocation == null) {
2133                 if (ms.classLocation == null) {
2134                     ms = moduleFinder.findModule(ms);
2135                 }
2136 
2137                 if (ms.kind != ERR) {
2138                     S sym = load.apply(ms, name);
2139 
2140                     if (sym != null &amp;&amp; validate.test(sym)) {
2141                         return createInvisibleSymbolError(env, sym);
2142                     }
2143                 }
2144             }
2145         }
2146 
2147         return defaultResult;
2148     }
2149 
2150     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2151         if (symbolPackageVisible(env, sym)) {
2152             return new AccessError(env, null, sym);
2153         } else {
2154             return new InvisibleSymbolError(env, false, sym);
2155         }
2156     }
2157 
2158     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2159         ModuleSymbol envMod = env.toplevel.modle;
2160         PackageSymbol symPack = sym.packge();
2161         return envMod == symPack.modle ||
2162                envMod.visiblePackages.containsKey(symPack.fullname);
2163     }
2164 
2165     /**
2166      * Find a type declared in a scope (not inherited).  Return null
2167      * if none is found.
2168      *  @param env       The current environment.
2169      *  @param site      The original type from where the selection takes
2170      *                   place.
2171      *  @param name      The type&#39;s name.
2172      *  @param c         The class to search for the member type. This is
2173      *                   always a superclass or implemented interface of
2174      *                   site&#39;s class.
2175      */
2176     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2177                                    Type site,
2178                                    Name name,
2179                                    TypeSymbol c) {
2180         for (Symbol sym : c.members().getSymbolsByName(name)) {
2181             if (sym.kind == TYP) {
2182                 return isAccessible(env, site, sym)
2183                     ? sym
2184                     : new AccessError(env, site, sym);
2185             }
2186         }
2187         return typeNotFound;
2188     }
2189 
2190     /** Find a member type inherited from a superclass or interface.
2191      *  @param env       The current environment.
2192      *  @param site      The original type from where the selection takes
2193      *                   place.
2194      *  @param name      The type&#39;s name.
2195      *  @param c         The class to search for the member type. This is
2196      *                   always a superclass or implemented interface of
2197      *                   site&#39;s class.
2198      */
2199     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2200                                    Type site,
2201                                    Name name,
2202                                    TypeSymbol c) {
2203         Symbol bestSoFar = typeNotFound;
2204         Symbol sym;
2205         Type st = types.supertype(c.type);
2206         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2207             sym = findMemberType(env, site, name, st.tsym);
2208             bestSoFar = bestOf(bestSoFar, sym);
2209         }
2210         for (List&lt;Type&gt; l = types.interfaces(c.type);
2211              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2212              l = l.tail) {
2213             sym = findMemberType(env, site, name, l.head.tsym);
2214             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2215                 !sym.kind.isResolutionError() &amp;&amp;
2216                 sym.owner != bestSoFar.owner)
2217                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2218             else
2219                 bestSoFar = bestOf(bestSoFar, sym);
2220         }
2221         return bestSoFar;
2222     }
2223 
2224     /** Find qualified member type.
2225      *  @param env       The current environment.
2226      *  @param site      The original type from where the selection takes
2227      *                   place.
2228      *  @param name      The type&#39;s name.
2229      *  @param c         The class to search for the member type. This is
2230      *                   always a superclass or implemented interface of
2231      *                   site&#39;s class.
2232      */
2233     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2234                           Type site,
2235                           Name name,
2236                           TypeSymbol c) {
<a name="3" id="anc3"></a><span class="line-modified">2237         Symbol sym = findMemberTypeInternal(env,site, name, c);</span>
<span class="line-removed">2238         return env.info.isQuestioned &amp;&amp; sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;</span>
2239     }
2240 
2241     /** Find qualified member type.
2242      *  @param env       The current environment.
2243      *  @param site      The original type from where the selection takes
2244      *                   place.
2245      *  @param name      The type&#39;s name.
2246      *  @param c         The class to search for the member type. This is
2247      *                   always a superclass or implemented interface of
2248      *                   site&#39;s class.
2249      */
2250     Symbol findMemberTypeInternal(Env&lt;AttrContext&gt; env,
2251                           Type site,
2252                           Name name,
2253                           TypeSymbol c) {
2254         Symbol sym = findImmediateMemberType(env, site, name, c);
2255 
2256         if (sym != typeNotFound)
2257             return sym;
2258 
2259         return findInheritedMemberType(env, site, name, c);
2260 
2261     }
2262 
2263     /** Find a global type in given scope and load corresponding class.
2264      *  @param env       The current environment.
2265      *  @param scope     The scope in which to look for the type.
2266      *  @param name      The type&#39;s name.
2267      */
2268     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2269         Symbol bestSoFar = typeNotFound;
2270         for (Symbol s : scope.getSymbolsByName(name)) {
2271             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2272             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2273                 bestSoFar != sym)
2274                 return new AmbiguityError(bestSoFar, sym);
2275             else
2276                 bestSoFar = bestOf(bestSoFar, sym);
2277         }
2278         return bestSoFar;
2279     }
2280 
2281     Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
2282         for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
2283             if (sym.kind == TYP) {
2284                 if (staticOnly &amp;&amp;
2285                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2286                     sym.owner.kind == TYP)
2287                     return new StaticError(sym);
2288                 return sym;
2289             }
2290         }
2291         return typeNotFound;
2292     }
2293 
2294     /** Find an unqualified type symbol.
2295      *  @param env       The current environment.
2296      *  @param name      The type&#39;s name.
2297      */
2298     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
<a name="4" id="anc4"></a><span class="line-modified">2299         Symbol sym = findTypeInternal(env, name);</span>
<span class="line-removed">2300         return env.info.isQuestioned &amp;&amp; sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;</span>
2301     }
2302 
2303     /** Find an unqualified type symbol.
2304      *  @param env       The current environment.
2305      *  @param name      The type&#39;s name.
2306      */
2307     Symbol findTypeInternal(Env&lt;AttrContext&gt; env, Name name) {
2308         if (name == names.empty)
2309             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2310         Symbol bestSoFar = typeNotFound;
2311         Symbol sym;
2312         boolean staticOnly = false;
2313         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2314             if (isStatic(env1)) staticOnly = true;
2315             // First, look for a type variable and the first member type
2316             final Symbol tyvar = findTypeVar(env1, name, staticOnly);
2317             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2318                                           name, env1.enclClass.sym);
2319 
2320             // Return the type variable if we have it, and have no
2321             // immediate member, OR the type variable is for a method.
2322             if (tyvar != typeNotFound) {
2323                 if (env.baseClause || sym == typeNotFound ||
2324                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2325                      tyvar.owner.kind == MTH)) {
2326                     return tyvar;
2327                 }
2328             }
2329 
2330             // If the environment is a class def, finish up,
2331             // otherwise, do the entire findMemberType
2332             if (sym == typeNotFound)
2333                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2334                                               name, env1.enclClass.sym);
2335 
2336             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2337                 sym.type.hasTag(CLASS) &amp;&amp;
2338                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2339                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2340                 sym.type.getEnclosingType().isParameterized())
2341                 return new StaticError(sym);
2342             else if (sym.exists()) return sym;
2343             else bestSoFar = bestOf(bestSoFar, sym);
2344 
2345             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2346             if ((encl.sym.flags() &amp; STATIC) != 0)
2347                 staticOnly = true;
2348         }
2349 
2350         if (!env.tree.hasTag(IMPORT)) {
2351             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2352             if (sym.exists()) return sym;
2353             else bestSoFar = bestOf(bestSoFar, sym);
2354 
2355             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2356             if (sym.exists()) return sym;
2357             else bestSoFar = bestOf(bestSoFar, sym);
2358 
2359             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2360             if (sym.exists()) return sym;
2361             else bestSoFar = bestOf(bestSoFar, sym);
2362 
2363             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2364             if (sym.exists()) return sym;
2365             else bestSoFar = bestOf(bestSoFar, sym);
2366         }
2367 
2368         return bestSoFar;
2369     }
2370 
2371     /** Find an unqualified identifier which matches a specified kind set.
2372      *  @param pos       position on which report warnings, if any;
2373      *                   null warnings should not be reported
2374      *  @param env       The current environment.
2375      *  @param name      The identifier&#39;s name.
2376      *  @param kind      Indicates the possible symbol kinds
2377      *                   (a subset of VAL, TYP, PCK).
2378      */
2379     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2380         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2381     }
2382 
2383     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2384         Symbol bestSoFar = typeNotFound;
2385         Symbol sym;
2386 
2387         if (kind.contains(KindSelector.VAL)) {
2388             sym = findVar(env, name);
2389             if (sym.exists()) return sym;
2390             else bestSoFar = bestOf(bestSoFar, sym);
2391         }
2392 
2393         if (kind.contains(KindSelector.TYP)) {
2394             sym = findType(env, name);
2395 
2396             if (sym.exists()) return sym;
2397             else bestSoFar = bestOf(bestSoFar, sym);
2398         }
2399 
2400         if (kind.contains(KindSelector.PCK))
2401             return lookupPackage(env, name);
2402         else return bestSoFar;
2403     }
2404 
2405     /** Find an identifier in a package which matches a specified kind set.
2406      *  @param pos       position on which report warnings, if any;
2407      *                   null warnings should not be reported
2408      *  @param env       The current environment.
2409      *  @param name      The identifier&#39;s name.
2410      *  @param kind      Indicates the possible symbol kinds
2411      *                   (a nonempty subset of TYP, PCK).
2412      */
2413     Symbol findIdentInPackage(DiagnosticPosition pos,
2414                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2415                               Name name, KindSelector kind) {
<a name="5" id="anc5"></a><span class="line-modified">2416         Symbol sym = checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);</span>
<span class="line-removed">2417         return env.info.isQuestioned &amp;&amp; sym.isValue() ? types.projectedNullableType((ClassSymbol) sym) : sym;</span>
2418     }
2419 
2420     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2421                               Name name, KindSelector kind) {
2422         Name fullname = TypeSymbol.formFullName(name, pck);
2423         Symbol bestSoFar = typeNotFound;
2424         if (kind.contains(KindSelector.TYP)) {
2425             RecoveryLoadClass recoveryLoadClass =
2426                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2427                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2428                         doRecoveryLoadClass : noRecovery;
2429             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2430             if (sym.exists()) {
2431                 // don&#39;t allow programs to use flatnames
2432                 if (name == sym.name) return sym;
2433             }
2434             else bestSoFar = bestOf(bestSoFar, sym);
2435         }
2436         if (kind.contains(KindSelector.PCK)) {
2437             return lookupPackage(env, fullname);
2438         }
2439         return bestSoFar;
2440     }
2441 
2442     /** Find an identifier among the members of a given type `site&#39;.
2443      *  @param pos       position on which report warnings, if any;
2444      *                   null warnings should not be reported
2445      *  @param env       The current environment.
2446      *  @param site      The type containing the symbol to be found.
2447      *  @param name      The identifier&#39;s name.
2448      *  @param kind      Indicates the possible symbol kinds
2449      *                   (a subset of VAL, TYP).
2450      */
2451     Symbol findIdentInType(DiagnosticPosition pos,
2452                            Env&lt;AttrContext&gt; env, Type site,
2453                            Name name, KindSelector kind) {
2454         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2455     }
2456 
2457     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2458                            Name name, KindSelector kind) {
2459         Symbol bestSoFar = typeNotFound;
2460         Symbol sym;
2461         if (kind.contains(KindSelector.VAL)) {
2462             sym = findField(env, site, name, site.tsym);
2463             if (sym.exists()) return sym;
2464             else bestSoFar = bestOf(bestSoFar, sym);
2465         }
2466 
2467         if (kind.contains(KindSelector.TYP)) {
2468             sym = findMemberType(env, site, name, site.tsym);
2469             if (sym.exists()) return sym;
2470             else bestSoFar = bestOf(bestSoFar, sym);
2471         }
2472         return bestSoFar;
2473     }
2474 
2475     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2476         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2477             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2478                 bestSoFar = new BadRestrictedTypeError(names.var);
2479             } else if (name.equals(names.yield)) {
2480                 if (allowYieldStatement) {
2481                     bestSoFar = new BadRestrictedTypeError(names.yield);
2482                 } else if (pos != null) {
2483                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2484                 }
2485             }
2486         }
2487         return bestSoFar;
2488     }
2489 
2490 /* ***************************************************************************
2491  *  Access checking
2492  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2493  *  an error message in the process
2494  ****************************************************************************/
2495 
2496     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2497      *  else pass through unchanged,
2498      *  additional arguments duplicate what has been used in trying to find the
2499      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2500      *  expect misses to happen frequently.
2501      *
2502      *  @param sym       The symbol that was found, or a ResolveError.
2503      *  @param pos       The position to use for error reporting.
2504      *  @param location  The symbol the served as a context for this lookup
2505      *  @param site      The original type from where the selection took place.
2506      *  @param name      The symbol&#39;s name.
2507      *  @param qualified Did we get here through a qualified expression resolution?
2508      *  @param argtypes  The invocation&#39;s value arguments,
2509      *                   if we looked for a method.
2510      *  @param typeargtypes  The invocation&#39;s type arguments,
2511      *                   if we looked for a method.
2512      *  @param logResolveHelper helper class used to log resolve errors
2513      */
2514     Symbol accessInternal(Symbol sym,
2515                   DiagnosticPosition pos,
2516                   Symbol location,
2517                   Type site,
2518                   Name name,
2519                   boolean qualified,
2520                   List&lt;Type&gt; argtypes,
2521                   List&lt;Type&gt; typeargtypes,
2522                   LogResolveHelper logResolveHelper) {
2523         if (sym.kind.isResolutionError()) {
2524             ResolveError errSym = (ResolveError)sym.baseSymbol();
2525             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2526             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2527             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2528                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2529             }
2530         }
2531         return sym;
2532     }
2533 
2534     /**
2535      * Variant of the generalized access routine, to be used for generating method
2536      * resolution diagnostics
2537      */
2538     Symbol accessMethod(Symbol sym,
2539                   DiagnosticPosition pos,
2540                   Symbol location,
2541                   Type site,
2542                   Name name,
2543                   boolean qualified,
2544                   List&lt;Type&gt; argtypes,
2545                   List&lt;Type&gt; typeargtypes) {
2546         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2547     }
2548 
2549     /** Same as original accessMethod(), but without location.
2550      */
2551     Symbol accessMethod(Symbol sym,
2552                   DiagnosticPosition pos,
2553                   Type site,
2554                   Name name,
2555                   boolean qualified,
2556                   List&lt;Type&gt; argtypes,
2557                   List&lt;Type&gt; typeargtypes) {
2558         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2559     }
2560 
2561     /**
2562      * Variant of the generalized access routine, to be used for generating variable,
2563      * type resolution diagnostics
2564      */
2565     Symbol accessBase(Symbol sym,
2566                   DiagnosticPosition pos,
2567                   Symbol location,
2568                   Type site,
2569                   Name name,
2570                   boolean qualified) {
2571         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2572     }
2573 
2574     /** Same as original accessBase(), but without location.
2575      */
2576     Symbol accessBase(Symbol sym,
2577                   DiagnosticPosition pos,
2578                   Type site,
2579                   Name name,
2580                   boolean qualified) {
2581         return accessBase(sym, pos, site.tsym, site, name, qualified);
2582     }
2583 
2584     interface LogResolveHelper {
2585         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2586         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2587     }
2588 
2589     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2590         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2591             return !site.isErroneous();
2592         }
2593         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2594             return argtypes;
2595         }
2596     };
2597 
2598     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2599         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2600             return !site.isErroneous() &amp;&amp;
2601                         !Type.isErroneous(argtypes) &amp;&amp;
2602                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2603         }
2604         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2605             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2606         }
2607     };
2608 
2609     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2610 
2611         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2612             deferredAttr.super(mode, msym, step);
2613         }
2614 
2615         @Override
2616         protected Type typeOf(DeferredType dt, Type pt) {
2617             Type res = super.typeOf(dt, pt);
2618             if (!res.isErroneous()) {
2619                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2620                     case LAMBDA:
2621                     case REFERENCE:
2622                         return dt;
2623                     case CONDEXPR:
2624                         return res == Type.recoveryType ?
2625                                 dt : res;
2626                 }
2627             }
2628             return res;
2629         }
2630     }
2631 
2632     /** Check that sym is not an abstract method.
2633      */
2634     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2635         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2636             log.error(pos,
2637                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2638     }
2639 
2640 /* ***************************************************************************
2641  *  Name resolution
2642  *  Naming conventions are as for symbol lookup
2643  *  Unlike the find... methods these methods will report access errors
2644  ****************************************************************************/
2645 
2646     /** Resolve an unqualified (non-method) identifier.
2647      *  @param pos       The position to use for error reporting.
2648      *  @param env       The environment current at the identifier use.
2649      *  @param name      The identifier&#39;s name.
2650      *  @param kind      The set of admissible symbol kinds for the identifier.
2651      */
2652     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2653                         Name name, KindSelector kind) {
2654         return accessBase(
2655             findIdent(pos, env, name, kind),
2656             pos, env.enclClass.sym.type, name, false);
2657     }
2658 
2659     /** Resolve an unqualified method identifier.
2660      *  @param pos       The position to use for error reporting.
2661      *  @param env       The environment current at the method invocation.
2662      *  @param name      The identifier&#39;s name.
2663      *  @param argtypes  The types of the invocation&#39;s value arguments.
2664      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2665      */
2666     Symbol resolveMethod(DiagnosticPosition pos,
2667                          Env&lt;AttrContext&gt; env,
2668                          Name name,
2669                          List&lt;Type&gt; argtypes,
2670                          List&lt;Type&gt; typeargtypes) {
2671         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2672                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2673                     @Override
2674                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2675                         return findFun(env, name, argtypes, typeargtypes,
2676                                 phase.isBoxingRequired(),
2677                                 phase.isVarargsRequired());
2678                     }});
2679     }
2680 
2681     /** Resolve a qualified method identifier
2682      *  @param pos       The position to use for error reporting.
2683      *  @param env       The environment current at the method invocation.
2684      *  @param site      The type of the qualifying expression, in which
2685      *                   identifier is searched.
2686      *  @param name      The identifier&#39;s name.
2687      *  @param argtypes  The types of the invocation&#39;s value arguments.
2688      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2689      */
2690     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2691                                   Type site, Name name, List&lt;Type&gt; argtypes,
2692                                   List&lt;Type&gt; typeargtypes) {
2693         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2694     }
2695     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2696                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2697                                   List&lt;Type&gt; typeargtypes) {
2698         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2699     }
2700     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2701                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2702                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2703                                   List&lt;Type&gt; typeargtypes) {
2704         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2705             @Override
2706             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2707                 return findMethod(env, site, name, argtypes, typeargtypes,
2708                         phase.isBoxingRequired(),
2709                         phase.isVarargsRequired());
2710             }
2711             @Override
2712             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2713                 if (sym.kind.isResolutionError()) {
2714                     sym = super.access(env, pos, location, sym);
2715                 } else {
2716                     MethodSymbol msym = (MethodSymbol)sym;
2717                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2718                         env.info.pendingResolutionPhase = BASIC;
2719                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2720                     }
2721                 }
2722                 return sym;
2723             }
2724         });
2725     }
2726 
2727     /** Find or create an implicit method of exactly the given type (after erasure).
2728      *  Searches in a side table, not the main scope of the site.
2729      *  This emulates the lookup process required by JSR 292 in JVM.
2730      *  @param env       Attribution environment
2731      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2732      *  @param argtypes  The required argument types
2733      */
2734     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2735                                             final Symbol spMethod,
2736                                             List&lt;Type&gt; argtypes) {
2737         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2738                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2739         return findPolymorphicSignatureInstance(spMethod, mtype);
2740     }
2741 
2742     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2743                                             Type mtype) {
2744         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2745             // Check that there is already a method symbol for the method
2746             // type and owner
2747             if (types.isSameType(mtype, sym.type) &amp;&amp;
2748                 spMethod.owner == sym.owner) {
2749                 return sym;
2750             }
2751         }
2752 
2753         // Create the desired method
2754         // Retain static modifier is to support invocations to
2755         // MethodHandle.linkTo* methods
2756         long flags = ABSTRACT | HYPOTHETICAL |
2757                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2758         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2759             @Override
2760             public Symbol baseSymbol() {
2761                 return spMethod;
2762             }
2763         };
2764         if (!mtype.isErroneous()) { // Cache only if kosher.
2765             polymorphicSignatureScope.enter(msym);
2766         }
2767         return msym;
2768     }
2769 
2770     /** Resolve a qualified method identifier, throw a fatal error if not
2771      *  found.
2772      *  @param pos       The position to use for error reporting.
2773      *  @param env       The environment current at the method invocation.
2774      *  @param site      The type of the qualifying expression, in which
2775      *                   identifier is searched.
2776      *  @param name      The identifier&#39;s name.
2777      *  @param argtypes  The types of the invocation&#39;s value arguments.
2778      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2779      */
2780     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2781                                         Type site, Name name,
2782                                         List&lt;Type&gt; argtypes,
2783                                         List&lt;Type&gt; typeargtypes) {
2784         MethodResolutionContext resolveContext = new MethodResolutionContext();
2785         resolveContext.internalResolution = true;
2786         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2787                 site, name, argtypes, typeargtypes);
2788         if (sym.kind == MTH) return (MethodSymbol)sym;
2789         else throw new FatalError(
2790                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2791     }
2792 
2793     /** Resolve constructor.
2794      *  @param pos       The position to use for error reporting.
2795      *  @param env       The environment current at the constructor invocation.
2796      *  @param site      The type of class for which a constructor is searched.
2797      *  @param argtypes  The types of the constructor invocation&#39;s value
2798      *                   arguments.
2799      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2800      *                   arguments.
2801      */
2802     Symbol resolveConstructor(DiagnosticPosition pos,
2803                               Env&lt;AttrContext&gt; env,
2804                               Type site,
2805                               List&lt;Type&gt; argtypes,
2806                               List&lt;Type&gt; typeargtypes) {
2807         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2808     }
2809 
2810     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2811                               final DiagnosticPosition pos,
2812                               Env&lt;AttrContext&gt; env,
2813                               Type site,
2814                               List&lt;Type&gt; argtypes,
2815                               List&lt;Type&gt; typeargtypes) {
2816         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2817             @Override
2818             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2819                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2820                         phase.isBoxingRequired(),
2821                         phase.isVarargsRequired());
2822             }
2823         });
2824     }
2825 
2826     /** Resolve a constructor, throw a fatal error if not found.
2827      *  @param pos       The position to use for error reporting.
2828      *  @param env       The environment current at the method invocation.
2829      *  @param site      The type to be constructed.
2830      *  @param argtypes  The types of the invocation&#39;s value arguments.
2831      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2832      */
2833     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2834                                         Type site,
2835                                         List&lt;Type&gt; argtypes,
2836                                         List&lt;Type&gt; typeargtypes) {
2837         MethodResolutionContext resolveContext = new MethodResolutionContext();
2838         resolveContext.internalResolution = true;
2839         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2840         if (sym.kind == MTH) return (MethodSymbol)sym;
2841         else throw new FatalError(
2842                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2843     }
2844 
2845     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2846                               Type site, List&lt;Type&gt; argtypes,
2847                               List&lt;Type&gt; typeargtypes,
2848                               boolean allowBoxing,
2849                               boolean useVarargs) {
2850         Symbol sym = findMethod(env, site,
2851                                     names.init, argtypes,
2852                                     typeargtypes, allowBoxing,
2853                                     useVarargs);
2854         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2855         chk.checkPreview(pos, sym);
2856         return sym;
2857     }
2858 
2859     /** Resolve constructor using diamond inference.
2860      *  @param pos       The position to use for error reporting.
2861      *  @param env       The environment current at the constructor invocation.
2862      *  @param site      The type of class for which a constructor is searched.
2863      *                   The scope of this class has been touched in attribution.
2864      *  @param argtypes  The types of the constructor invocation&#39;s value
2865      *                   arguments.
2866      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2867      *                   arguments.
2868      */
2869     Symbol resolveDiamond(DiagnosticPosition pos,
2870                               Env&lt;AttrContext&gt; env,
2871                               Type site,
2872                               List&lt;Type&gt; argtypes,
2873                               List&lt;Type&gt; typeargtypes) {
2874         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2875                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2876                     @Override
2877                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2878                         return findDiamond(env, site, argtypes, typeargtypes,
2879                                 phase.isBoxingRequired(),
2880                                 phase.isVarargsRequired());
2881                     }
2882                     @Override
2883                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2884                         if (sym.kind.isResolutionError()) {
2885                             if (sym.kind != WRONG_MTH &amp;&amp;
2886                                 sym.kind != WRONG_MTHS) {
2887                                 sym = super.access(env, pos, location, sym);
2888                             } else {
2889                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2890                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2891                                                 null;
2892                                 sym = new DiamondError(sym, currentResolutionContext);
2893                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2894                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2895                             }
2896                         }
2897                         return sym;
2898                     }});
2899     }
2900 
2901     /** This method scans all the constructor symbol in a given class scope -
2902      *  assuming that the original scope contains a constructor of the kind:
2903      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2904      *  a method check is executed against the modified constructor type:
2905      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2906      *  inference. The inferred return type of the synthetic constructor IS
2907      *  the inferred type for the diamond operator.
2908      */
2909     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2910                               Type site,
2911                               List&lt;Type&gt; argtypes,
2912                               List&lt;Type&gt; typeargtypes,
2913                               boolean allowBoxing,
2914                               boolean useVarargs) {
2915         Symbol bestSoFar = methodNotFound;
2916         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2917         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2918             //- System.out.println(&quot; e &quot; + e.sym);
2919             if (sym.kind == MTH &amp;&amp;
2920                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2921                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2922                             ((ForAll)sym.type).tvars :
2923                             List.nil();
2924                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2925                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2926                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2927                         @Override
2928                         public Symbol baseSymbol() {
2929                             return sym;
2930                         }
2931                     };
2932                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2933                             newConstr,
2934                             bestSoFar,
2935                             allowBoxing,
2936                             useVarargs);
2937             }
2938         }
2939         return bestSoFar;
2940     }
2941 
2942     Symbol getMemberReference(DiagnosticPosition pos,
2943             Env&lt;AttrContext&gt; env,
2944             JCMemberReference referenceTree,
2945             Type site,
2946             Name name) {
2947 
2948         site = types.capture(site);
2949 
2950         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2951                 referenceTree, site, name, List.nil(), null, VARARITY);
2952 
2953         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2954         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2955                 nilMethodCheck, lookupHelper);
2956 
2957         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2958 
2959         return sym;
2960     }
2961 
2962     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2963                                   Type site,
2964                                   Name name,
2965                                   List&lt;Type&gt; argtypes,
2966                                   List&lt;Type&gt; typeargtypes,
2967                                   MethodResolutionPhase maxPhase) {
2968         if (!name.equals(names.init)) {
2969             //method reference
2970             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2971         } else if (site.hasTag(ARRAY)) {
2972             //array constructor reference
2973             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2974         } else {
2975             //class constructor reference
2976             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2977         }
2978     }
2979 
2980     /**
2981      * Resolution of member references is typically done as a single
2982      * overload resolution step, where the argument types A are inferred from
2983      * the target functional descriptor.
2984      *
2985      * If the member reference is a method reference with a type qualifier,
2986      * a two-step lookup process is performed. The first step uses the
2987      * expected argument list A, while the second step discards the first
2988      * type from A (which is treated as a receiver type).
2989      *
2990      * There are two cases in which inference is performed: (i) if the member
2991      * reference is a constructor reference and the qualifier type is raw - in
2992      * which case diamond inference is used to infer a parameterization for the
2993      * type qualifier; (ii) if the member reference is an unbound reference
2994      * where the type qualifier is raw - in that case, during the unbound lookup
2995      * the receiver argument type is used to infer an instantiation for the raw
2996      * qualifier type.
2997      *
2998      * When a multi-step resolution process is exploited, the process of picking
2999      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
3000      *
3001      * This routine returns a pair (T,S), where S is the member reference symbol,
3002      * and T is the type of the class in which S is defined. This is necessary as
3003      * the type T might be dynamically inferred (i.e. if constructor reference
3004      * has a raw qualifier).
3005      */
3006     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3007                                   JCMemberReference referenceTree,
3008                                   Type site,
3009                                   Name name,
3010                                   List&lt;Type&gt; argtypes,
3011                                   List&lt;Type&gt; typeargtypes,
3012                                   Type descriptor,
3013                                   MethodCheck methodCheck,
3014                                   InferenceContext inferenceContext,
3015                                   ReferenceChooser referenceChooser) {
3016 
3017         //step 1 - bound lookup
3018         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3019                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3020         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3021         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3022         boundSearchResolveContext.methodCheck = methodCheck;
3023         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3024                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3025         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3026 
3027         //step 2 - unbound lookup
3028         Symbol unboundSym = methodNotFound;
3029         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3030         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3031         ReferenceLookupResult unboundRes = referenceNotFound;
3032         if (unboundLookupHelper != null) {
3033             MethodResolutionContext unboundSearchResolveContext =
3034                     new MethodResolutionContext();
3035             unboundSearchResolveContext.methodCheck = methodCheck;
3036             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3037                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3038             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3039         }
3040 
3041         //merge results
3042         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3043         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3044         res = new Pair&lt;&gt;(bestRes.sym,
3045                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3046         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3047                 unboundEnv.info.pendingResolutionPhase :
3048                 boundEnv.info.pendingResolutionPhase;
3049 
3050         if (!res.fst.kind.isResolutionError()) {
3051             //handle sigpoly method references
3052             MethodSymbol msym = (MethodSymbol)res.fst;
3053             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3054                 env.info.pendingResolutionPhase = BASIC;
3055                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3056             }
3057         }
3058 
3059         return res;
3060     }
3061 
3062     /**
3063      * This class is used to represent a method reference lookup result. It keeps track of two
3064      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3065      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3066      */
3067     static class ReferenceLookupResult {
3068 
3069         /**
3070          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3071          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3072          * depending on whether all applicable candidates are static or non-static methods,
3073          * respectively. If a successful lookup has both static and non-static applicable methods,
3074          * its kind is set to BOTH.
3075          */
3076         enum StaticKind {
3077             STATIC,
3078             NON_STATIC,
3079             BOTH,
3080             UNDEFINED;
3081 
3082             /**
3083              * Retrieve the static kind associated with a given (method) symbol.
3084              */
3085             static StaticKind from(Symbol s) {
3086                 return s.isStatic() ?
3087                         STATIC : NON_STATIC;
3088             }
3089 
3090             /**
3091              * Merge two static kinds together.
3092              */
3093             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3094                 if (sk1 == UNDEFINED) {
3095                     return sk2;
3096                 } else if (sk2 == UNDEFINED) {
3097                     return sk1;
3098                 } else {
3099                     return sk1 == sk2 ? sk1 : BOTH;
3100                 }
3101             }
3102         }
3103 
3104         /** The static kind. */
3105         StaticKind staticKind;
3106 
3107         /** The lookup result. */
3108         Symbol sym;
3109 
3110         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3111             this(sym, staticKind(sym, resolutionContext));
3112         }
3113 
3114         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3115             this.staticKind = staticKind;
3116             this.sym = sym;
3117         }
3118 
3119         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3120             switch (sym.kind) {
3121                 case MTH:
3122                 case AMBIGUOUS:
3123                     return resolutionContext.candidates.stream()
3124                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3125                             .map(c -&gt; StaticKind.from(c.sym))
3126                             .reduce(StaticKind::reduce)
3127                             .orElse(StaticKind.UNDEFINED);
3128                 default:
3129                     return StaticKind.UNDEFINED;
3130             }
3131         }
3132 
3133         /**
3134          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3135          */
3136         boolean isSuccess() {
3137             return staticKind != StaticKind.UNDEFINED;
3138         }
3139 
3140         /**
3141          * Does this result have given static kind?
3142          */
3143         boolean hasKind(StaticKind sk) {
3144             return this.staticKind == sk;
3145         }
3146 
3147         /**
3148          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3149          * some &#39;better&#39; result) ?
3150          */
3151         boolean canIgnore() {
3152             switch (sym.kind) {
3153                 case ABSENT_MTH:
3154                     return true;
3155                 case WRONG_MTH:
3156                     InapplicableSymbolError errSym =
3157                             (InapplicableSymbolError)sym.baseSymbol();
3158                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3159                             .matches(errSym.errCandidate().snd);
3160                 case WRONG_MTHS:
3161                     InapplicableSymbolsError errSyms =
3162                             (InapplicableSymbolsError)sym.baseSymbol();
3163                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3164                 default:
3165                     return false;
3166             }
3167         }
3168 
3169         static ReferenceLookupResult error(Symbol sym) {
3170             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3171         }
3172     }
3173 
3174     /**
3175      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3176      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3177      * result of method reference resolution.
3178      */
3179     abstract class ReferenceChooser {
3180         /**
3181          * Generate a result from a pair of lookup result objects. This method delegates to the
3182          * appropriate result generation routine.
3183          */
3184         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3185             return unboundRes != referenceNotFound ?
3186                     unboundResult(boundRes, unboundRes) :
3187                     boundResult(boundRes);
3188         }
3189 
3190         /**
3191          * Generate a symbol from a given bound lookup result.
3192          */
3193         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3194 
3195         /**
3196          * Generate a symbol from a pair of bound/unbound lookup results.
3197          */
3198         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3199     }
3200 
3201     /**
3202      * This chooser implements the selection strategy used during a full lookup; this logic
3203      * is described in JLS SE 8 (15.3.2).
3204      */
3205     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3206 
3207         @Override
3208         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3209             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3210                     boundRes : //the search produces a non-static method
3211                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3212         }
3213 
3214         @Override
3215         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3216             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3217                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3218                 //the first search produces a static method and no non-static method is applicable
3219                 //during the second search
3220                 return boundRes;
3221             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3222                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3223                 //the second search produces a non-static method and no static method is applicable
3224                 //during the first search
3225                 return unboundRes;
3226             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3227                 //both searches produce some result; ambiguity (error recovery)
3228                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3229             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3230                 //Both searches failed to produce a result with correct staticness (i.e. first search
3231                 //produces an non-static method). Alternatively, a given search produced a result
3232                 //with the right staticness, but the other search has applicable methods with wrong
3233                 //staticness (error recovery)
3234                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3235                         boundRes.sym : unboundRes.sym, true));
3236             } else {
3237                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3238                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3239                         unboundRes : boundRes;
3240             }
3241         }
3242     };
3243 
3244     /**
3245      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3246      * is described in JLS SE 8 (15.12.2.1).
3247      */
3248     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3249 
3250         @Override
3251         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3252             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3253                     boundRes : //the search has at least one applicable non-static method
3254                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3255         }
3256 
3257         @Override
3258         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3259             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3260                 //the first search has at least one applicable static method
3261                 return boundRes;
3262             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3263                 //the second search has at least one applicable non-static method
3264                 return unboundRes;
3265             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3266                 //either the first search produces a non-static method, or second search produces
3267                 //a non-static method (error recovery)
3268                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3269                         boundRes.sym : unboundRes.sym, true));
3270             } else {
3271                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3272                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3273                         unboundRes : boundRes;
3274             }
3275         }
3276     };
3277 
3278     /**
3279      * Helper for defining custom method-like lookup logic; a lookup helper
3280      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3281      * lookup result (this step might result in compiler diagnostics to be generated)
3282      */
3283     abstract class LookupHelper {
3284 
3285         /** name of the symbol to lookup */
3286         Name name;
3287 
3288         /** location in which the lookup takes place */
3289         Type site;
3290 
3291         /** actual types used during the lookup */
3292         List&lt;Type&gt; argtypes;
3293 
3294         /** type arguments used during the lookup */
3295         List&lt;Type&gt; typeargtypes;
3296 
3297         /** Max overload resolution phase handled by this helper */
3298         MethodResolutionPhase maxPhase;
3299 
3300         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3301             this.name = name;
3302             this.site = site;
3303             this.argtypes = argtypes;
3304             this.typeargtypes = typeargtypes;
3305             this.maxPhase = maxPhase;
3306         }
3307 
3308         /**
3309          * Should lookup stop at given phase with given result
3310          */
3311         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3312             return phase.ordinal() &gt; maxPhase.ordinal() ||
3313                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3314         }
3315 
3316         /**
3317          * Search for a symbol under a given overload resolution phase - this method
3318          * is usually called several times, once per each overload resolution phase
3319          */
3320         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3321 
3322         /**
3323          * Dump overload resolution info
3324          */
3325         void debug(DiagnosticPosition pos, Symbol sym) {
3326             //do nothing
3327         }
3328 
3329         /**
3330          * Validate the result of the lookup
3331          */
3332         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3333     }
3334 
3335     abstract class BasicLookupHelper extends LookupHelper {
3336 
3337         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3338             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3339         }
3340 
3341         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3342             super(name, site, argtypes, typeargtypes, maxPhase);
3343         }
3344 
3345         @Override
3346         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3347             Symbol sym = doLookup(env, phase);
3348             if (sym.kind == AMBIGUOUS) {
3349                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3350                 sym = a_err.mergeAbstracts(site);
3351             }
3352             return sym;
3353         }
3354 
3355         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3356 
3357         @Override
3358         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3359             if (sym.kind.isResolutionError()) {
3360                 //if nothing is found return the &#39;first&#39; error
3361                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3362             }
3363             return sym;
3364         }
3365 
3366         @Override
3367         void debug(DiagnosticPosition pos, Symbol sym) {
3368             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3369         }
3370     }
3371 
3372     /**
3373      * Helper class for member reference lookup. A reference lookup helper
3374      * defines the basic logic for member reference lookup; a method gives
3375      * access to an &#39;unbound&#39; helper used to perform an unbound member
3376      * reference lookup.
3377      */
3378     abstract class ReferenceLookupHelper extends LookupHelper {
3379 
3380         /** The member reference tree */
3381         JCMemberReference referenceTree;
3382 
3383         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3384                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3385             super(name, site, argtypes, typeargtypes, maxPhase);
3386             this.referenceTree = referenceTree;
3387         }
3388 
3389         /**
3390          * Returns an unbound version of this lookup helper. By default, this
3391          * method returns an dummy lookup helper.
3392          */
3393         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3394             return null;
3395         }
3396 
3397         /**
3398          * Get the kind of the member reference
3399          */
3400         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3401 
3402         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3403             if (sym.kind == AMBIGUOUS) {
3404                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3405                 sym = a_err.mergeAbstracts(site);
3406             }
3407             //skip error reporting
3408             return sym;
3409         }
3410     }
3411 
3412     /**
3413      * Helper class for method reference lookup. The lookup logic is based
3414      * upon Resolve.findMethod; in certain cases, this helper class has a
3415      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3416      * In such cases, non-static lookup results are thrown away.
3417      */
3418     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3419 
3420         /** The original method reference lookup site. */
3421         Type originalSite;
3422 
3423         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3424                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3425             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3426             this.originalSite = site;
3427         }
3428 
3429         @Override
3430         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3431             return findMethod(env, site, name, argtypes, typeargtypes,
3432                     phase.isBoxingRequired(), phase.isVarargsRequired());
3433         }
3434 
3435         @Override
3436         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3437             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3438                 if (argtypes.nonEmpty() &amp;&amp;
3439                         (argtypes.head.hasTag(NONE) ||
3440                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3441                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3442                             originalSite, argtypes, typeargtypes, maxPhase);
3443                 } else {
3444                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3445                         @Override
3446                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3447                             return this;
3448                         }
3449 
3450                         @Override
3451                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3452                             return methodNotFound;
3453                         }
3454 
3455                         @Override
3456                         ReferenceKind referenceKind(Symbol sym) {
3457                             Assert.error();
3458                             return null;
3459                         }
3460                     };
3461                 }
3462             } else {
3463                 return super.unboundLookup(inferenceContext);
3464             }
3465         }
3466 
3467         @Override
3468         ReferenceKind referenceKind(Symbol sym) {
3469             if (sym.isStatic()) {
3470                 return ReferenceKind.STATIC;
3471             } else {
3472                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3473                 return selName != null &amp;&amp; selName == names._super ?
3474                         ReferenceKind.SUPER :
3475                         ReferenceKind.BOUND;
3476             }
3477         }
3478     }
3479 
3480     /**
3481      * Helper class for unbound method reference lookup. Essentially the same
3482      * as the basic method reference lookup helper; main difference is that static
3483      * lookup results are thrown away. If qualifier type is raw, an attempt to
3484      * infer a parameterized type is made using the first actual argument (that
3485      * would otherwise be ignored during the lookup).
3486      */
3487     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3488 
3489         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3490                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3491             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3492             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3493                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3494                 this.site = types.skipTypeVars(asSuperSite, true);
3495             }
3496         }
3497 
3498         @Override
3499         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3500             return this;
3501         }
3502 
3503         @Override
3504         ReferenceKind referenceKind(Symbol sym) {
3505             return ReferenceKind.UNBOUND;
3506         }
3507     }
3508 
3509     /**
3510      * Helper class for array constructor lookup; an array constructor lookup
3511      * is simulated by looking up a method that returns the array type specified
3512      * as qualifier, and that accepts a single int parameter (size of the array).
3513      */
3514     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3515 
3516         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3517                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3518             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3519         }
3520 
3521         @Override
3522         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3523             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3524             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3525             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3526             sc.enter(arrayConstr);
3527             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3528         }
3529 
3530         @Override
3531         ReferenceKind referenceKind(Symbol sym) {
3532             return ReferenceKind.ARRAY_CTOR;
3533         }
3534     }
3535 
3536     /**
3537      * Helper class for constructor reference lookup. The lookup logic is based
3538      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3539      * whether the constructor reference needs diamond inference (this is the case
3540      * if the qualifier type is raw). A special erroneous symbol is returned
3541      * if the lookup returns the constructor of an inner class and there&#39;s no
3542      * enclosing instance in scope.
3543      */
3544     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3545 
3546         boolean needsInference;
3547 
3548         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3549                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3550             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3551             if (site.isRaw()) {
3552                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3553                 needsInference = true;
3554             }
3555         }
3556 
3557         @Override
3558         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3559             Symbol sym = needsInference ?
3560                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3561                 findMethod(env, site, name, argtypes, typeargtypes,
3562                         phase.isBoxingRequired(), phase.isVarargsRequired());
3563             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3564         }
3565 
3566         @Override
3567         ReferenceKind referenceKind(Symbol sym) {
3568             return site.getEnclosingType().hasTag(NONE) ?
3569                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3570         }
3571     }
3572 
3573     /**
3574      * Main overload resolution routine. On each overload resolution step, a
3575      * lookup helper class is used to perform the method/constructor lookup;
3576      * at the end of the lookup, the helper is used to validate the results
3577      * (this last step might trigger overload resolution diagnostics).
3578      */
3579     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3580         MethodResolutionContext resolveContext = new MethodResolutionContext();
3581         resolveContext.methodCheck = methodCheck;
3582         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3583     }
3584 
3585     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3586             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3587         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3588         try {
3589             Symbol bestSoFar = methodNotFound;
3590             currentResolutionContext = resolveContext;
3591             for (MethodResolutionPhase phase : methodResolutionSteps) {
3592                 if (lookupHelper.shouldStop(bestSoFar, phase))
3593                     break;
3594                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3595                 Symbol prevBest = bestSoFar;
3596                 currentResolutionContext.step = phase;
3597                 Symbol sym = lookupHelper.lookup(env, phase);
3598                 lookupHelper.debug(pos, sym);
3599                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3600                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3601             }
3602             return lookupHelper.access(env, pos, location, bestSoFar);
3603         } finally {
3604             currentResolutionContext = prevResolutionContext;
3605         }
3606     }
3607 
3608     /**
3609      * Resolve `c.name&#39; where name == this or name == super.
3610      * @param pos           The position to use for error reporting.
3611      * @param env           The environment current at the expression.
3612      * @param c             The qualifier.
3613      * @param name          The identifier&#39;s name.
3614      */
3615     Symbol resolveSelf(DiagnosticPosition pos,
3616                        Env&lt;AttrContext&gt; env,
3617                        TypeSymbol c,
3618                        Name name) {
3619         Env&lt;AttrContext&gt; env1 = env;
3620         boolean staticOnly = false;
3621         while (env1.outer != null) {
3622             if (isStatic(env1)) staticOnly = true;
3623             if (env1.enclClass.sym == c) {
3624                 Symbol sym = env1.info.scope.findFirst(name);
3625                 if (sym != null) {
3626                     if (staticOnly) sym = new StaticError(sym);
3627                     return accessBase(sym, pos, env.enclClass.sym.type,
3628                                   name, true);
3629                 }
3630             }
3631             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3632             env1 = env1.outer;
3633         }
3634         if (c.isInterface() &amp;&amp;
3635             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3636             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3637             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3638             for (Type t : pruneInterfaces(env.enclClass.type)) {
3639                 if (t.tsym == c) {
3640                     env.info.defaultSuperCallSite = t;
3641                     return new VarSymbol(0, names._super,
3642                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3643                 }
3644             }
3645             //find a direct super type that is a subtype of &#39;c&#39;
3646             for (Type i : types.directSupertypes(env.enclClass.type)) {
3647                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3648                     log.error(pos,
3649                               Errors.IllegalDefaultSuperCall(c,
3650                                                              Fragments.RedundantSupertype(c, i)));
3651                     return syms.errSymbol;
3652                 }
3653             }
3654             Assert.error();
3655         }
3656         log.error(pos, Errors.NotEnclClass(c));
3657         return syms.errSymbol;
3658     }
3659     //where
3660     private List&lt;Type&gt; pruneInterfaces(Type t) {
3661         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3662         for (Type t1 : types.interfaces(t)) {
3663             boolean shouldAdd = true;
3664             for (Type t2 : types.directSupertypes(t)) {
3665                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3666                     shouldAdd = false;
3667                 }
3668             }
3669             if (shouldAdd) {
3670                 result.append(t1);
3671             }
3672         }
3673         return result.toList();
3674     }
3675 
3676 
3677     /**
3678      * Resolve `c.this&#39; for an enclosing class c that contains the
3679      * named member.
3680      * @param pos           The position to use for error reporting.
3681      * @param env           The environment current at the expression.
3682      * @param member        The member that must be contained in the result.
3683      */
3684     Symbol resolveSelfContaining(DiagnosticPosition pos,
3685                                  Env&lt;AttrContext&gt; env,
3686                                  Symbol member,
3687                                  boolean isSuperCall) {
3688         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3689         if (sym == null) {
3690             log.error(pos, Errors.EnclClassRequired(member));
3691             return syms.errSymbol;
3692         } else {
3693             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3694         }
3695     }
3696 
3697     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3698         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3699             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3700             return encl == null || encl.kind.isResolutionError();
3701         }
3702         return false;
3703     }
3704 
3705     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3706                                  Symbol member,
3707                                  boolean isSuperCall) {
3708         Name name = names._this;
3709         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3710         boolean staticOnly = false;
3711         if (env1 != null) {
3712             while (env1 != null &amp;&amp; env1.outer != null) {
3713                 if (isStatic(env1)) staticOnly = true;
3714                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3715                     Symbol sym = env1.info.scope.findFirst(name);
3716                     if (sym != null) {
3717                         if (staticOnly) sym = new StaticError(sym);
3718                         return sym;
3719                     }
3720                 }
3721                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3722                     staticOnly = true;
3723                 env1 = env1.outer;
3724             }
3725         }
3726         return null;
3727     }
3728 
3729     /**
3730      * Resolve an appropriate implicit this instance for t&#39;s container.
3731      * JLS 8.8.5.1 and 15.9.2
3732      */
3733     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3734         return resolveImplicitThis(pos, env, t, false);
3735     }
3736 
3737     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3738         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3739                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3740                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3741         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3742             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3743         }
3744         return thisType;
3745     }
3746 
3747 /* ***************************************************************************
3748  *  ResolveError classes, indicating error situations when accessing symbols
3749  ****************************************************************************/
3750 
3751     //used by TransTypes when checking target type of synthetic cast
3752     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3753         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3754         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3755     }
3756     //where
3757     private void logResolveError(ResolveError error,
3758             DiagnosticPosition pos,
3759             Symbol location,
3760             Type site,
3761             Name name,
3762             List&lt;Type&gt; argtypes,
3763             List&lt;Type&gt; typeargtypes) {
3764         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3765                 pos, location, site, name, argtypes, typeargtypes);
3766         if (d != null) {
3767             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3768             log.report(d);
3769         }
3770     }
3771 
3772     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3773 
3774     public Object methodArguments(List&lt;Type&gt; argtypes) {
3775         if (argtypes == null || argtypes.isEmpty()) {
3776             return noArgs;
3777         } else {
3778             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3779             for (Type t : argtypes) {
3780                 if (t.hasTag(DEFERRED)) {
3781                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3782                 } else {
3783                     diagArgs.append(t);
3784                 }
3785             }
3786             return diagArgs;
3787         }
3788     }
3789 
3790     /**
3791      * Root class for resolution errors. Subclass of ResolveError
3792      * represent a different kinds of resolution error - as such they must
3793      * specify how they map into concrete compiler diagnostics.
3794      */
3795     abstract class ResolveError extends Symbol {
3796 
3797         /** The name of the kind of error, for debugging only. */
3798         final String debugName;
3799 
3800         ResolveError(Kind kind, String debugName) {
3801             super(kind, 0, null, null, null);
3802             this.debugName = debugName;
3803         }
3804 
3805         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3806         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3807             throw new AssertionError();
3808         }
3809 
3810         @Override
3811         public String toString() {
3812             return debugName;
3813         }
3814 
3815         @Override
3816         public boolean exists() {
3817             return false;
3818         }
3819 
3820         @Override
3821         public boolean isStatic() {
3822             return false;
3823         }
3824 
3825         /**
3826          * Create an external representation for this erroneous symbol to be
3827          * used during attribution - by default this returns the symbol of a
3828          * brand new error type which stores the original type found
3829          * during resolution.
3830          *
3831          * @param name     the name used during resolution
3832          * @param location the location from which the symbol is accessed
3833          */
3834         protected Symbol access(Name name, TypeSymbol location) {
3835             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3836         }
3837 
3838         /**
3839          * Create a diagnostic representing this resolution error.
3840          *
3841          * @param dkind     The kind of the diagnostic to be created (e.g error).
3842          * @param pos       The position to be used for error reporting.
3843          * @param site      The original type from where the selection took place.
3844          * @param name      The name of the symbol to be resolved.
3845          * @param argtypes  The invocation&#39;s value arguments,
3846          *                  if we looked for a method.
3847          * @param typeargtypes  The invocation&#39;s type arguments,
3848          *                      if we looked for a method.
3849          */
3850         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3851                 DiagnosticPosition pos,
3852                 Symbol location,
3853                 Type site,
3854                 Name name,
3855                 List&lt;Type&gt; argtypes,
3856                 List&lt;Type&gt; typeargtypes);
3857     }
3858 
3859     /**
3860      * This class is the root class of all resolution errors caused by
3861      * an invalid symbol being found during resolution.
3862      */
3863     abstract class InvalidSymbolError extends ResolveError {
3864 
3865         /** The invalid symbol found during resolution */
3866         Symbol sym;
3867 
3868         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3869             super(kind, debugName);
3870             this.sym = sym;
3871         }
3872 
3873         @Override
3874         public boolean exists() {
3875             return true;
3876         }
3877 
3878         @Override
3879         public String toString() {
3880              return super.toString() + &quot; wrongSym=&quot; + sym;
3881         }
3882 
3883         @Override
3884         public Symbol access(Name name, TypeSymbol location) {
3885             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3886                 return types.createErrorType(name, location, sym.type).tsym;
3887             else
3888                 return sym;
3889         }
3890     }
3891 
3892     class BadRestrictedTypeError extends ResolveError {
3893         private final Name typeName;
3894         BadRestrictedTypeError(Name typeName) {
3895             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3896             this.typeName = typeName;
3897         }
3898 
3899         @Override
3900         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3901             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3902         }
3903     }
3904 
3905     /**
3906      * InvalidSymbolError error class indicating that a symbol matching a
3907      * given name does not exists in a given site.
3908      */
3909     class SymbolNotFoundError extends ResolveError {
3910 
3911         SymbolNotFoundError(Kind kind) {
3912             this(kind, &quot;symbol not found error&quot;);
3913         }
3914 
3915         SymbolNotFoundError(Kind kind, String debugName) {
3916             super(kind, debugName);
3917         }
3918 
3919         @Override
3920         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3921                 DiagnosticPosition pos,
3922                 Symbol location,
3923                 Type site,
3924                 Name name,
3925                 List&lt;Type&gt; argtypes,
3926                 List&lt;Type&gt; typeargtypes) {
3927             argtypes = argtypes == null ? List.nil() : argtypes;
3928             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3929             if (name == names.error)
3930                 return null;
3931 
3932             boolean hasLocation = false;
3933             if (location == null) {
3934                 location = site.tsym;
3935             }
3936             if (!location.name.isEmpty()) {
3937                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3938                     return diags.create(dkind, log.currentSource(), pos,
3939                         &quot;doesnt.exist&quot;, location);
3940                 }
3941                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3942                         !location.name.equals(names._super);
3943             }
3944             boolean isConstructor = name == names.init;
3945             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3946             Name idname = isConstructor ? site.tsym.name : name;
3947             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3948             if (hasLocation) {
3949                 return diags.create(dkind, log.currentSource(), pos,
3950                         errKey, kindname, idname, //symbol kindname, name
3951                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3952                         getLocationDiag(location, site)); //location kindname, type
3953             }
3954             else {
3955                 return diags.create(dkind, log.currentSource(), pos,
3956                         errKey, kindname, idname, //symbol kindname, name
3957                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3958             }
3959         }
3960         //where
3961         private Object args(List&lt;Type&gt; args) {
3962             return args.isEmpty() ? args : methodArguments(args);
3963         }
3964 
3965         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3966             String key = &quot;cant.resolve&quot;;
3967             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3968             switch (kindname) {
3969                 case METHOD:
3970                 case CONSTRUCTOR: {
3971                     suffix += &quot;.args&quot;;
3972                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
3973                 }
3974             }
3975             return key + suffix;
3976         }
3977         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
3978             if (location.kind == VAR) {
3979                 return diags.fragment(Fragments.Location1(kindName(location),
3980                                                           location,
3981                                                           location.type));
3982             } else {
3983                 return diags.fragment(Fragments.Location(typeKindName(site),
3984                                       site,
3985                                       null));
3986             }
3987         }
3988     }
3989 
3990     /**
3991      * InvalidSymbolError error class indicating that a given symbol
3992      * (either a method, a constructor or an operand) is not applicable
3993      * given an actual arguments/type argument list.
3994      */
3995     class InapplicableSymbolError extends ResolveError {
3996 
3997         protected MethodResolutionContext resolveContext;
3998 
3999         InapplicableSymbolError(MethodResolutionContext context) {
4000             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
4001         }
4002 
4003         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
4004             super(kind, debugName);
4005             this.resolveContext = context;
4006         }
4007 
4008         @Override
4009         public String toString() {
4010             return super.toString();
4011         }
4012 
4013         @Override
4014         public boolean exists() {
4015             return true;
4016         }
4017 
4018         @Override
4019         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4020                 DiagnosticPosition pos,
4021                 Symbol location,
4022                 Type site,
4023                 Name name,
4024                 List&lt;Type&gt; argtypes,
4025                 List&lt;Type&gt; typeargtypes) {
4026             if (name == names.error)
4027                 return null;
4028 
4029             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4030             if (compactMethodDiags) {
4031                 JCDiagnostic simpleDiag =
4032                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4033                 if (simpleDiag != null) {
4034                     return simpleDiag;
4035                 }
4036             }
4037             Symbol ws = c.fst.asMemberOf(site, types);
4038             return diags.create(dkind, log.currentSource(), pos,
4039                       &quot;cant.apply.symbol&quot;,
4040                       kindName(ws),
4041                       ws.name == names.init ? ws.owner.name : ws.name,
4042                       methodArguments(ws.type.getParameterTypes()),
4043                       methodArguments(argtypes),
4044                       kindName(ws.owner),
4045                       ws.owner.type,
4046                       c.snd);
4047         }
4048 
4049         @Override
4050         public Symbol access(Name name, TypeSymbol location) {
4051             Symbol sym = bestCandidate();
4052             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4053         }
4054 
4055         protected Symbol bestCandidate() {
4056             return errCandidate().fst;
4057         }
4058 
4059         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4060             Candidate bestSoFar = null;
4061             for (Candidate c : resolveContext.candidates) {
4062                 if (c.isApplicable()) continue;
4063                 bestSoFar = c;
4064             }
4065             Assert.checkNonNull(bestSoFar);
4066             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4067         }
4068     }
4069 
4070     /**
4071      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4072      * is not applicable given an actual arguments/type argument list.
4073      */
4074     class InapplicableSymbolsError extends InapplicableSymbolError {
4075 
4076         InapplicableSymbolsError(MethodResolutionContext context) {
4077             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4078         }
4079 
4080         @Override
4081         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4082                 DiagnosticPosition pos,
4083                 Symbol location,
4084                 Type site,
4085                 Name name,
4086                 List&lt;Type&gt; argtypes,
4087                 List&lt;Type&gt; typeargtypes) {
4088             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4089             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4090                     filterCandidates(candidatesMap) :
4091                     mapCandidates();
4092             if (filteredCandidates.isEmpty()) {
4093                 filteredCandidates = candidatesMap;
4094             }
4095             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4096             if (filteredCandidates.size() &gt; 1) {
4097                 JCDiagnostic err = diags.create(dkind,
4098                         null,
4099                         truncatedDiag ?
4100                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4101                             EnumSet.noneOf(DiagnosticFlag.class),
4102                         log.currentSource(),
4103                         pos,
4104                         &quot;cant.apply.symbols&quot;,
4105                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4106                         name == names.init ? site.tsym.name : name,
4107                         methodArguments(argtypes));
4108                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4109             } else if (filteredCandidates.size() == 1) {
4110                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4111                                 filteredCandidates.entrySet().iterator().next();
4112                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4113                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4114                     @Override
4115                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4116                         return p;
4117                     }
4118                 }.getDiagnostic(dkind, pos,
4119                     location, site, name, argtypes, typeargtypes);
4120                 if (truncatedDiag) {
4121                     d.setFlag(DiagnosticFlag.COMPRESSED);
4122                 }
4123                 return d;
4124             } else {
4125                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4126                     location, site, name, argtypes, typeargtypes);
4127             }
4128         }
4129         //where
4130             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4131                 MostSpecificMap candidates = new MostSpecificMap();
4132                 for (Candidate c : resolveContext.candidates) {
4133                     if (c.isApplicable()) continue;
4134                     candidates.put(c);
4135                 }
4136                 return candidates;
4137             }
4138 
4139             @SuppressWarnings(&quot;serial&quot;)
4140             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4141                 private void put(Candidate c) {
4142                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4143                     for (Symbol s : keySet()) {
4144                         if (s == c.sym) {
4145                             continue;
4146                         }
4147                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4148                             overridden.add(s);
4149                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4150                             return;
4151                         }
4152                     }
4153                     for (Symbol s : overridden) {
4154                         remove(s);
4155                     }
4156                     put(c.sym, c.details);
4157                 }
4158             }
4159 
4160             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4161                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4162                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4163                     JCDiagnostic d = _entry.getValue();
4164                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4165                         candidates.put(_entry.getKey(), d);
4166                     }
4167                 }
4168                 return candidates;
4169             }
4170 
4171             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4172                 List&lt;JCDiagnostic&gt; details = List.nil();
4173                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4174                     Symbol sym = _entry.getKey();
4175                     JCDiagnostic detailDiag =
4176                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4177                                                                         sym.location(site, types),
4178                                                                         sym.asMemberOf(site, types),
4179                                                                         _entry.getValue()));
4180                     details = details.prepend(detailDiag);
4181                 }
4182                 //typically members are visited in reverse order (see Scope)
4183                 //so we need to reverse the candidate list so that candidates
4184                 //conform to source order
4185                 return details;
4186             }
4187 
4188         @Override
4189         protected Symbol bestCandidate() {
4190             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4191             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4192             if (filteredCandidates.size() == 1) {
4193                 return filteredCandidates.keySet().iterator().next();
4194             }
4195             return null;
4196         }
4197     }
4198 
4199     /**
4200      * DiamondError error class indicating that a constructor symbol is not applicable
4201      * given an actual arguments/type argument list using diamond inference.
4202      */
4203     class DiamondError extends InapplicableSymbolError {
4204 
4205         Symbol sym;
4206 
4207         public DiamondError(Symbol sym, MethodResolutionContext context) {
4208             super(sym.kind, &quot;diamondError&quot;, context);
4209             this.sym = sym;
4210         }
4211 
4212         JCDiagnostic getDetails() {
4213             return (sym.kind == WRONG_MTH) ?
4214                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4215                     null;
4216         }
4217 
4218         @Override
4219         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4220                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4221             JCDiagnostic details = getDetails();
4222             if (details != null &amp;&amp; compactMethodDiags) {
4223                 JCDiagnostic simpleDiag =
4224                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4225                 if (simpleDiag != null) {
4226                     return simpleDiag;
4227                 }
4228             }
4229             String key = details == null ?
4230                 &quot;cant.apply.diamond&quot; :
4231                 &quot;cant.apply.diamond.1&quot;;
4232             return diags.create(dkind, log.currentSource(), pos, key,
4233                     Fragments.Diamond(site.tsym), details);
4234         }
4235     }
4236 
4237     /**
4238      * An InvalidSymbolError error class indicating that a symbol is not
4239      * accessible from a given site
4240      */
4241     class AccessError extends InvalidSymbolError {
4242 
4243         private Env&lt;AttrContext&gt; env;
4244         private Type site;
4245 
4246         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4247             super(HIDDEN, sym, &quot;access error&quot;);
4248             this.env = env;
4249             this.site = site;
4250         }
4251 
4252         @Override
4253         public boolean exists() {
4254             return false;
4255         }
4256 
4257         @Override
4258         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4259                 DiagnosticPosition pos,
4260                 Symbol location,
4261                 Type site,
4262                 Name name,
4263                 List&lt;Type&gt; argtypes,
4264                 List&lt;Type&gt; typeargtypes) {
4265             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4266                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4267                         pos, location, site, name, argtypes, typeargtypes);
4268             }
4269             else if ((sym.flags() &amp; PUBLIC) != 0
4270                 || (env != null &amp;&amp; this.site != null
4271                     &amp;&amp; !isAccessible(env, this.site))) {
4272                 if (sym.owner.kind == PCK) {
4273                     return diags.create(dkind, log.currentSource(),
4274                             pos, &quot;not.def.access.package.cant.access&quot;,
4275                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4276                 } else if (   sym.packge() != syms.rootPackage
4277                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4278                     return diags.create(dkind, log.currentSource(),
4279                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4280                             sym, sym.location(), sym.location().packge(),
4281                             inaccessiblePackageReason(env, sym.packge()));
4282                 } else {
4283                     return diags.create(dkind, log.currentSource(),
4284                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4285                         sym, sym.location());
4286                 }
4287             }
4288             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4289                 return diags.create(dkind, log.currentSource(),
4290                         pos, &quot;report.access&quot;, sym,
4291                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4292                         sym.location());
4293             }
4294             else {
4295                 return diags.create(dkind, log.currentSource(),
4296                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4297             }
4298         }
4299 
4300         private String toString(Type type) {
4301             StringBuilder sb = new StringBuilder();
4302             sb.append(type);
4303             if (type != null) {
4304                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4305                 if (type.tsym != null)
4306                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4307                 sb.append(&quot;]&quot;);
4308             }
4309             return sb.toString();
4310         }
4311     }
4312 
4313     class InvisibleSymbolError extends InvalidSymbolError {
4314 
4315         private final Env&lt;AttrContext&gt; env;
4316         private final boolean suppressError;
4317 
4318         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4319             super(HIDDEN, sym, &quot;invisible class error&quot;);
4320             this.env = env;
4321             this.suppressError = suppressError;
4322             this.name = sym.name;
4323         }
4324 
4325         @Override
4326         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4327                 DiagnosticPosition pos,
4328                 Symbol location,
4329                 Type site,
4330                 Name name,
4331                 List&lt;Type&gt; argtypes,
4332                 List&lt;Type&gt; typeargtypes) {
4333             if (suppressError)
4334                 return null;
4335 
4336             if (sym.kind == PCK) {
4337                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4338                 return diags.create(dkind, log.currentSource(),
4339                         pos, &quot;package.not.visible&quot;, sym, details);
4340             }
4341 
4342             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4343 
4344             if (pos.getTree() != null) {
4345                 Symbol o = sym;
4346                 JCTree tree = pos.getTree();
4347 
4348                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4349                     o = o.owner;
4350                     tree = ((JCFieldAccess) tree).selected;
4351                 }
4352 
4353                 if (o.kind == PCK) {
4354                     pos = tree.pos();
4355 
4356                     return diags.create(dkind, log.currentSource(),
4357                             pos, &quot;package.not.visible&quot;, o, details);
4358                 }
4359             }
4360 
4361             return diags.create(dkind, log.currentSource(),
4362                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4363         }
4364     }
4365 
4366     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4367         //no dependency:
4368         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4369             //does not read:
4370             if (sym.modle != syms.unnamedModule) {
4371                 if (env.toplevel.modle != syms.unnamedModule) {
4372                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4373                                                                             sym,
4374                                                                             sym.modle));
4375                 } else {
4376                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4377                                                                                        sym.modle));
4378                 }
4379             } else {
4380                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4381                                                                                env.toplevel.modle));
4382             }
4383         } else {
4384             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4385                 //not exported to this module:
4386                 if (env.toplevel.modle != syms.unnamedModule) {
4387                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4388                                                                                     sym.modle,
4389                                                                                     env.toplevel.modle));
4390                 } else {
4391                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4392                                                                                                sym.modle));
4393                 }
4394             } else {
4395                 //not exported:
4396                 if (env.toplevel.modle != syms.unnamedModule) {
4397                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4398                                                                             sym.modle));
4399                 } else {
4400                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4401                                                                                        sym.modle));
4402                 }
4403             }
4404         }
4405     }
4406 
4407     /**
4408      * InvalidSymbolError error class indicating that an instance member
4409      * has erroneously been accessed from a static context.
4410      */
4411     class StaticError extends InvalidSymbolError {
4412 
4413         StaticError(Symbol sym) {
4414             super(STATICERR, sym, &quot;static error&quot;);
4415         }
4416 
4417         @Override
4418         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4419                 DiagnosticPosition pos,
4420                 Symbol location,
4421                 Type site,
4422                 Name name,
4423                 List&lt;Type&gt; argtypes,
4424                 List&lt;Type&gt; typeargtypes) {
4425             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4426                 ? types.erasure(sym.type).tsym
4427                 : sym);
4428             return diags.create(dkind, log.currentSource(), pos,
4429                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4430         }
4431     }
4432 
4433     /**
4434      * InvalidSymbolError error class indicating that a pair of symbols
4435      * (either methods, constructors or operands) are ambiguous
4436      * given an actual arguments/type argument list.
4437      */
4438     class AmbiguityError extends ResolveError {
4439 
4440         /** The other maximally specific symbol */
4441         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4442 
4443         @Override
4444         public boolean exists() {
4445             return true;
4446         }
4447 
4448         AmbiguityError(Symbol sym1, Symbol sym2) {
4449             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4450             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4451         }
4452 
4453         private List&lt;Symbol&gt; flatten(Symbol sym) {
4454             if (sym.kind == AMBIGUOUS) {
4455                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4456             } else {
4457                 return List.of(sym);
4458             }
4459         }
4460 
4461         AmbiguityError addAmbiguousSymbol(Symbol s) {
4462             ambiguousSyms = ambiguousSyms.prepend(s);
4463             return this;
4464         }
4465 
4466         @Override
4467         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4468                 DiagnosticPosition pos,
4469                 Symbol location,
4470                 Type site,
4471                 Name name,
4472                 List&lt;Type&gt; argtypes,
4473                 List&lt;Type&gt; typeargtypes) {
4474             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4475             Symbol s1 = diagSyms.head;
4476             Symbol s2 = diagSyms.tail.head;
4477             Name sname = s1.name;
4478             if (sname == names.init) sname = s1.owner.name;
4479             return diags.create(dkind, log.currentSource(),
4480                     pos, &quot;ref.ambiguous&quot;, sname,
4481                     kindName(s1),
4482                     s1,
4483                     s1.location(site, types),
4484                     kindName(s2),
4485                     s2,
4486                     s2.location(site, types));
4487         }
4488 
4489         /**
4490          * If multiple applicable methods are found during overload and none of them
4491          * is more specific than the others, attempt to merge their signatures.
4492          */
4493         Symbol mergeAbstracts(Type site) {
4494             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4495             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4496         }
4497 
4498         @Override
4499         protected Symbol access(Name name, TypeSymbol location) {
4500             Symbol firstAmbiguity = ambiguousSyms.last();
4501             return firstAmbiguity.kind == TYP ?
4502                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4503                     firstAmbiguity;
4504         }
4505     }
4506 
4507     class BadVarargsMethod extends ResolveError {
4508 
4509         ResolveError delegatedError;
4510 
4511         BadVarargsMethod(ResolveError delegatedError) {
4512             super(delegatedError.kind, &quot;badVarargs&quot;);
4513             this.delegatedError = delegatedError;
4514         }
4515 
4516         @Override
4517         public Symbol baseSymbol() {
4518             return delegatedError.baseSymbol();
4519         }
4520 
4521         @Override
4522         protected Symbol access(Name name, TypeSymbol location) {
4523             return delegatedError.access(name, location);
4524         }
4525 
4526         @Override
4527         public boolean exists() {
4528             return true;
4529         }
4530 
4531         @Override
4532         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4533             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4534         }
4535     }
4536 
4537     /**
4538      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4539      * but with the wrong staticness.
4540      */
4541     class BadMethodReferenceError extends StaticError {
4542 
4543         boolean unboundLookup;
4544 
4545         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4546             super(sym);
4547             this.unboundLookup = unboundLookup;
4548         }
4549 
4550         @Override
4551         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4552             final String key;
4553             if (!unboundLookup) {
4554                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4555             } else if (sym.isStatic()) {
4556                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4557             } else {
4558                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4559             }
4560             return sym.kind.isResolutionError() ?
4561                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4562                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4563         }
4564     }
4565 
4566     /**
4567      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4568      * but pointing to a class for which an enclosing instance is not available.
4569      */
4570     class BadConstructorReferenceError extends InvalidSymbolError {
4571 
4572         public BadConstructorReferenceError(Symbol sym) {
4573             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4574         }
4575 
4576         @Override
4577         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4578            return diags.create(dkind, log.currentSource(), pos,
4579                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4580         }
4581     }
4582 
4583     class BadClassFileError extends InvalidSymbolError {
4584 
4585         private final CompletionFailure ex;
4586 
4587         public BadClassFileError(CompletionFailure ex) {
4588             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4589             this.name = sym.name;
4590             this.ex = ex;
4591         }
4592 
4593         @Override
4594         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4595             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4596                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4597 
4598             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4599             return d;
4600         }
4601 
4602     }
4603 
4604     /**
4605      * Helper class for method resolution diagnostic simplification.
4606      * Certain resolution diagnostic are rewritten as simpler diagnostic
4607      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4608      * is stripped away, as it doesn&#39;t carry additional info. The logic
4609      * for matching a given diagnostic is given in terms of a template
4610      * hierarchy: a diagnostic template can be specified programmatically,
4611      * so that only certain diagnostics are matched. Each templete is then
4612      * associated with a rewriter object that carries out the task of rewtiting
4613      * the diagnostic to a simpler one.
4614      */
4615     static class MethodResolutionDiagHelper {
4616 
4617         /**
4618          * A diagnostic rewriter transforms a method resolution diagnostic
4619          * into a simpler one
4620          */
4621         interface DiagnosticRewriter {
4622             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4623                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4624                     DiagnosticType preferredKind, JCDiagnostic d);
4625         }
4626 
4627         /**
4628          * A diagnostic template is made up of two ingredients: (i) a regular
4629          * expression for matching a diagnostic key and (ii) a list of sub-templates
4630          * for matching diagnostic arguments.
4631          */
4632         static class Template {
4633 
4634             /** regex used to match diag key */
4635             String regex;
4636 
4637             /** templates used to match diagnostic args */
4638             Template[] subTemplates;
4639 
4640             Template(String key, Template... subTemplates) {
4641                 this.regex = key;
4642                 this.subTemplates = subTemplates;
4643             }
4644 
4645             /**
4646              * Returns true if the regex matches the diagnostic key and if
4647              * all diagnostic arguments are matches by corresponding sub-templates.
4648              */
4649             boolean matches(Object o) {
4650                 JCDiagnostic d = (JCDiagnostic)o;
4651                 Object[] args = d.getArgs();
4652                 if (!d.getCode().matches(regex) ||
4653                         subTemplates.length != d.getArgs().length) {
4654                     return false;
4655                 }
4656                 for (int i = 0; i &lt; args.length ; i++) {
4657                     if (!subTemplates[i].matches(args[i])) {
4658                         return false;
4659                     }
4660                 }
4661                 return true;
4662             }
4663         }
4664 
4665         /**
4666          * Common rewriter for all argument mismatch simplifications.
4667          */
4668         static class ArgMismatchRewriter implements DiagnosticRewriter {
4669 
4670             /** the index of the subdiagnostic to be used as primary. */
4671             int causeIndex;
4672 
4673             public ArgMismatchRewriter(int causeIndex) {
4674                 this.causeIndex = causeIndex;
4675             }
4676 
4677             @Override
4678             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4679                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4680                     DiagnosticType preferredKind, JCDiagnostic d) {
4681                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4682                 DiagnosticPosition pos = d.getDiagnosticPosition();
4683                 if (pos == null) {
4684                     pos = preferredPos;
4685                 }
4686                 return diags.create(preferredKind, preferredSource, pos,
4687                         &quot;prob.found.req&quot;, cause);
4688             }
4689         }
4690 
4691         /** a dummy template that match any diagnostic argument */
4692         static final Template skip = new Template(&quot;&quot;) {
4693             @Override
4694             boolean matches(Object d) {
4695                 return true;
4696             }
4697         };
4698 
4699         /** template for matching inference-free arguments mismatch failures */
4700         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4701 
4702         /** template for matching inference related arguments mismatch failures */
4703         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4704             @Override
4705             boolean matches(Object o) {
4706                 if (!super.matches(o)) {
4707                     return false;
4708                 }
4709                 JCDiagnostic d = (JCDiagnostic)o;
4710                 @SuppressWarnings(&quot;unchecked&quot;)
4711                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4712                 return !containsAny(d, tvars);
4713             }
4714 
4715             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4716                 if (o instanceof Type) {
4717                     return ((Type)o).containsAny(ts);
4718                 } else if (o instanceof JCDiagnostic) {
4719                     return containsAny((JCDiagnostic)o, ts);
4720                 } else {
4721                     return false;
4722                 }
4723             };
4724 
4725             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4726                 return Stream.of(d.getArgs())
4727                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4728             }
4729         };
4730 
4731         /** rewriter map used for method resolution simplification */
4732         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4733 
4734         static {
4735             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4736             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4737         }
4738 
4739         /**
4740          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4741          * and rewrite it accordingly.
4742          */
4743         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4744                                     DiagnosticType dkind, JCDiagnostic d) {
4745             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4746                 if (_entry.getKey().matches(d)) {
4747                     JCDiagnostic simpleDiag =
4748                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4749                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4750                     return simpleDiag;
4751                 }
4752             }
4753             return null;
4754         }
4755     }
4756 
4757     enum MethodResolutionPhase {
4758         BASIC(false, false),
4759         BOX(true, false),
4760         VARARITY(true, true) {
4761             @Override
4762             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4763                 //Check invariants (see {@code LookupHelper.shouldStop})
4764                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4765                 if (!sym.kind.isResolutionError()) {
4766                     //varargs resolution successful
4767                     return sym;
4768                 } else {
4769                     //pick best error
4770                     switch (bestSoFar.kind) {
4771                         case WRONG_MTH:
4772                         case WRONG_MTHS:
4773                             //Override previous errors if they were caused by argument mismatch.
4774                             //This generally means preferring current symbols - but we need to pay
4775                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4776                             //than the previous rounds, and adjust that accordingly.
4777                             switch (sym.kind) {
4778                                 case WRONG_MTH:
4779                                     //if the previous round matched more than one method, return that
4780                                     //result instead
4781                                     return bestSoFar.kind == WRONG_MTHS ?
4782                                             bestSoFar : sym;
4783                                 case ABSENT_MTH:
4784                                     //do not override erroneous symbol if the arity lookup did not
4785                                     //match any method
4786                                     return bestSoFar;
4787                                 case WRONG_MTHS:
4788                                 default:
4789                                     //safe to override
4790                                     return sym;
4791                             }
4792                         default:
4793                             //otherwise, return first error
4794                             return bestSoFar;
4795                     }
4796                 }
4797             }
4798         };
4799 
4800         final boolean isBoxingRequired;
4801         final boolean isVarargsRequired;
4802 
4803         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4804            this.isBoxingRequired = isBoxingRequired;
4805            this.isVarargsRequired = isVarargsRequired;
4806         }
4807 
4808         public boolean isBoxingRequired() {
4809             return isBoxingRequired;
4810         }
4811 
4812         public boolean isVarargsRequired() {
4813             return isVarargsRequired;
4814         }
4815 
4816         public Symbol mergeResults(Symbol prev, Symbol sym) {
4817             return sym;
4818         }
4819     }
4820 
4821     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4822 
4823     /**
4824      * A resolution context is used to keep track of intermediate results of
4825      * overload resolution, such as list of method that are not applicable
4826      * (used to generate more precise diagnostics) and so on. Resolution contexts
4827      * can be nested - this means that when each overload resolution routine should
4828      * work within the resolution context it created.
4829      */
4830     class MethodResolutionContext {
4831 
4832         private List&lt;Candidate&gt; candidates = List.nil();
4833 
4834         MethodResolutionPhase step = null;
4835 
4836         MethodCheck methodCheck = resolveMethodCheck;
4837 
4838         private boolean internalResolution = false;
4839         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4840 
4841         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4842             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4843             candidates = candidates.append(c);
4844         }
4845 
4846         void addApplicableCandidate(Symbol sym, Type mtype) {
4847             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4848             candidates = candidates.append(c);
4849         }
4850 
4851         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4852             DeferredAttrContext parent = (pendingResult == null)
4853                 ? deferredAttr.emptyDeferredAttrContext
4854                 : pendingResult.checkContext.deferredAttrContext();
4855             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4856                     inferenceContext, parent, warn);
4857         }
4858 
4859         /**
4860          * This class represents an overload resolution candidate. There are two
4861          * kinds of candidates: applicable methods and inapplicable methods;
4862          * applicable methods have a pointer to the instantiated method type,
4863          * while inapplicable candidates contain further details about the
4864          * reason why the method has been considered inapplicable.
4865          */
4866         @SuppressWarnings(&quot;overrides&quot;)
4867         class Candidate {
4868 
4869             final MethodResolutionPhase step;
4870             final Symbol sym;
4871             final JCDiagnostic details;
4872             final Type mtype;
4873 
4874             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4875                 this.step = step;
4876                 this.sym = sym;
4877                 this.details = details;
4878                 this.mtype = mtype;
4879             }
4880 
4881             boolean isApplicable() {
4882                 return mtype != null;
4883             }
4884         }
4885 
4886         DeferredAttr.AttrMode attrMode() {
4887             return attrMode;
4888         }
4889 
4890         boolean internal() {
4891             return internalResolution;
4892         }
4893     }
4894 
4895     MethodResolutionContext currentResolutionContext = null;
4896 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import java.util.*;
 29 
 30 import com.sun.tools.javac.code.*;
 31 import com.sun.tools.javac.code.Attribute.TypeCompound;
 32 import com.sun.tools.javac.code.Source.Feature;
 33 import com.sun.tools.javac.code.Symbol.*;
 34 import com.sun.tools.javac.code.Type.IntersectionClassType;
 35 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
 36 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 37 import com.sun.tools.javac.tree.*;
 38 import com.sun.tools.javac.tree.JCTree.*;
 39 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
 40 import com.sun.tools.javac.util.*;
 41 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 42 import com.sun.tools.javac.util.List;
 43 
 44 import static com.sun.tools.javac.code.Flags.*;
 45 import static com.sun.tools.javac.code.Kinds.Kind.*;
 46 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
 47 import static com.sun.tools.javac.code.TypeTag.CLASS;
 48 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
 49 import static com.sun.tools.javac.code.TypeTag.VOID;
 50 import static com.sun.tools.javac.comp.CompileStates.CompileState;
 51 import com.sun.tools.javac.tree.JCTree.JCBreak;
 52 
 53 /** This pass translates Generic Java to conventional Java.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
 59  */
 60 public class TransTypes extends TreeTranslator {
 61     /** The context key for the TransTypes phase. */
 62     protected static final Context.Key&lt;TransTypes&gt; transTypesKey = new Context.Key&lt;&gt;();
 63 
 64     /** Get the instance for this context. */
 65     public static TransTypes instance(Context context) {
 66         TransTypes instance = context.get(transTypesKey);
 67         if (instance == null)
 68             instance = new TransTypes(context);
 69         return instance;
 70     }
 71 
 72     private Names names;
 73     private Log log;
 74     private Symtab syms;
 75     private TreeMaker make;
 76     private Enter enter;
 77     private Types types;
 78     private Annotate annotate;
 79     private Attr attr;
 80     private final Resolve resolve;
 81     private final CompileStates compileStates;
 82 
 83     /** Switch: is complex graph inference supported? */
 84     private final boolean allowGraphInference;
 85 
 86     /** Switch: are default methods supported? */
 87     private final boolean allowInterfaceBridges;
 88 
 89     protected TransTypes(Context context) {
 90         context.put(transTypesKey, this);
 91         compileStates = CompileStates.instance(context);
 92         names = Names.instance(context);
 93         log = Log.instance(context);
 94         syms = Symtab.instance(context);
 95         enter = Enter.instance(context);
 96         types = Types.instance(context);
 97         make = TreeMaker.instance(context);
 98         resolve = Resolve.instance(context);
 99         Source source = Source.instance(context);
100         allowInterfaceBridges = Feature.DEFAULT_METHODS.allowedInSource(source);
101         allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source);
102         annotate = Annotate.instance(context);
103         attr = Attr.instance(context);
104     }
105 
106     /** Construct an attributed tree for a cast of expression to target type,
107      *  unless it already has precisely that type.
108      *  @param tree    The expression tree.
109      *  @param target  The target type.
110      */
111     JCExpression cast(JCExpression tree, Type target) {
112         int oldpos = make.pos;
113         make.at(tree.pos);
114         if (!types.isSameType(tree.type, target)) {
115             if (!resolve.isAccessible(env, target.tsym))
116                 resolve.logAccessErrorInternal(env, tree, target);
117             tree = make.TypeCast(make.Type(target), tree).setType(target);
118         }
119         make.pos = oldpos;
120         return tree;
121     }
122 
123     /** Construct an attributed tree to coerce an expression to some erased
124      *  target type, unless the expression is already assignable to that type.
125      *  If target type is a constant type, use its base type instead.
126      *  @param tree    The expression tree.
127      *  @param target  The target type.
128      */
129     public JCExpression coerce(Env&lt;AttrContext&gt; env, JCExpression tree, Type target) {
130         Env&lt;AttrContext&gt; prevEnv = this.env;
131         try {
132             this.env = env;
133             return coerce(tree, target);
134         }
135         finally {
136             this.env = prevEnv;
137         }
138     }
139     JCExpression coerce(JCExpression tree, Type target) {
140         Type btarget = target.baseType();
141         if (tree.type.isPrimitive() == target.isPrimitive()) {
142             return types.isAssignable(tree.type, btarget, types.noWarnings)
143                 ? tree
144                 : cast(tree, btarget);
145         }
146         return tree;
147     }
148 
149     /** Given an erased reference type, assume this type as the tree&#39;s type.
150      *  Then, coerce to some given target type unless target type is null.
151      *  This operation is used in situations like the following:
152      *
153      *  &lt;pre&gt;{@code
154      *  class Cell&lt;A&gt; { A value; }
155      *  ...
156      *  Cell&lt;Integer&gt; cell;
157      *  Integer x = cell.value;
158      *  }&lt;/pre&gt;
159      *
160      *  Since the erasure of Cell.value is Object, but the type
161      *  of cell.value in the assignment is Integer, we need to
162      *  adjust the original type of cell.value to Object, and insert
163      *  a cast to Integer. That is, the last assignment becomes:
164      *
165      *  &lt;pre&gt;{@code
166      *  Integer x = (Integer)cell.value;
167      *  }&lt;/pre&gt;
168      *
169      *  @param tree       The expression tree whose type might need adjustment.
170      *  @param erasedType The expression&#39;s type after erasure.
171      *  @param target     The target type, which is usually the erasure of the
172      *                    expression&#39;s original type.
173      */
174     JCExpression retype(JCExpression tree, Type erasedType, Type target) {
175 //      System.err.println(&quot;retype &quot; + tree + &quot; to &quot; + erasedType);//DEBUG
176         if (!erasedType.isPrimitive()) {
177             if (target != null &amp;&amp; target.isPrimitive()) {
178                 target = erasure(tree.type);
179             }
180             tree.type = erasedType;
181             if (target != null) {
182                 return coerce(tree, target);
183             }
184         }
185         return tree;
186     }
187 
188     /** Translate method argument list, casting each argument
189      *  to its corresponding type in a list of target types.
190      *  @param _args            The method argument list.
191      *  @param parameters       The list of target types.
192      *  @param varargsElement   The erasure of the varargs element type,
193      *  or null if translating a non-varargs invocation
194      */
195     &lt;T extends JCTree&gt; List&lt;T&gt; translateArgs(List&lt;T&gt; _args,
196                                            List&lt;Type&gt; parameters,
197                                            Type varargsElement) {
198         if (parameters.isEmpty()) return _args;
199         List&lt;T&gt; args = _args;
200         while (parameters.tail.nonEmpty()) {
201             args.head = translate(args.head, parameters.head);
202             args = args.tail;
203             parameters = parameters.tail;
204         }
205         Type parameter = parameters.head;
206         Assert.check(varargsElement != null || args.length() == 1);
207         if (varargsElement != null) {
208             while (args.nonEmpty()) {
209                 args.head = translate(args.head, varargsElement);
210                 args = args.tail;
211             }
212         } else {
213             args.head = translate(args.head, parameter);
214         }
215         return _args;
216     }
217 
218     public &lt;T extends JCTree&gt; List&lt;T&gt; translateArgs(List&lt;T&gt; _args,
219                                            List&lt;Type&gt; parameters,
220                                            Type varargsElement,
221                                            Env&lt;AttrContext&gt; localEnv) {
222         Env&lt;AttrContext&gt; prevEnv = env;
223         try {
224             env = localEnv;
225             return translateArgs(_args, parameters, varargsElement);
226         }
227         finally {
228             env = prevEnv;
229         }
230     }
231 
232     /** Add a bridge definition and enter corresponding method symbol in
233      *  local scope of origin.
234      *
235      *  @param pos     The source code position to be used for the definition.
236      *  @param meth    The method for which a bridge needs to be added
237      *  @param impl    That method&#39;s implementation (possibly the method itself)
238      *  @param origin  The class to which the bridge will be added
239      *  @param bridges The list buffer to which the bridge will be added
240      */
241     void addBridge(DiagnosticPosition pos,
242                    MethodSymbol meth,
243                    MethodSymbol impl,
244                    ClassSymbol origin,
245                    ListBuffer&lt;JCTree&gt; bridges) {
246         make.at(pos);
247         Type implTypeErasure = erasure(impl.type);
248 
249         // Create a bridge method symbol and a bridge definition without a body.
250         Type bridgeType = meth.erasure(types);
251         long flags = impl.flags() &amp; AccessFlags | SYNTHETIC | BRIDGE |
252                 (origin.isInterface() ? DEFAULT : 0);
253         MethodSymbol bridge = new MethodSymbol(flags,
254                                                meth.name,
255                                                bridgeType,
256                                                origin);
257         /* once JDK-6996415 is solved it should be checked if this approach can
258          * be applied to method addOverrideBridgesIfNeeded
259          */
260         bridge.params = createBridgeParams(impl, bridge, bridgeType);
261         bridge.setAttributes(impl);
262 
263         JCMethodDecl md = make.MethodDef(bridge, null);
264 
265         // The bridge calls this.impl(..), if we have an implementation
266         // in the current class, super.impl(...) otherwise.
267         JCExpression receiver = (impl.owner == origin)
268             ? make.This(origin.erasure(types))
269             : make.Super(types.supertype(origin.type).tsym.erasure(types), origin);
270 
271         // The type returned from the original method.
272         Type calltype = implTypeErasure.getReturnType();
273 
274         // Construct a call of  this.impl(params), or super.impl(params),
275         // casting params and possibly results as needed.
276         JCExpression call =
277             make.Apply(
278                        null,
279                        make.Select(receiver, impl).setType(calltype),
280                        translateArgs(make.Idents(md.params), implTypeErasure.getParameterTypes(), null))
281             .setType(calltype);
282         JCStatement stat = (implTypeErasure.getReturnType().hasTag(VOID))
283             ? make.Exec(call)
284             : make.Return(coerce(call, bridgeType.getReturnType()));
285         md.body = make.Block(0, List.of(stat));
286 
287         // Add bridge to `bridges&#39; buffer
288         bridges.append(md);
289 
290         // Add bridge to scope of enclosing class and keep track of the bridge span.
291         ClassSymbol refProjection = origin.isValue() ? origin.referenceProjection() : null;
292         origin.members().enter(bridge);
293         if (refProjection != null) {
294             MethodSymbol clone = bridge.clone(refProjection);
295             clone.projection = bridge;
296             bridge.projection = clone;
297             refProjection.members().enter(clone);
298         }
299     }
300 
301     private List&lt;VarSymbol&gt; createBridgeParams(MethodSymbol impl, MethodSymbol bridge,
302             Type bridgeType) {
303         List&lt;VarSymbol&gt; bridgeParams = null;
304         if (impl.params != null) {
305             bridgeParams = List.nil();
306             List&lt;VarSymbol&gt; implParams = impl.params;
307             Type.MethodType mType = (Type.MethodType)bridgeType;
308             List&lt;Type&gt; argTypes = mType.argtypes;
309             while (implParams.nonEmpty() &amp;&amp; argTypes.nonEmpty()) {
310                 VarSymbol param = new VarSymbol(implParams.head.flags() | SYNTHETIC | PARAMETER,
311                         implParams.head.name, argTypes.head, bridge);
312                 param.setAttributes(implParams.head);
313                 bridgeParams = bridgeParams.append(param);
314                 implParams = implParams.tail;
315                 argTypes = argTypes.tail;
316             }
317         }
318         return bridgeParams;
319     }
320 
321     /** Add bridge if given symbol is a non-private, non-static member
322      *  of the given class, which is either defined in the class or non-final
323      *  inherited, and one of the two following conditions holds:
324      *  1. The method&#39;s type changes in the given class, as compared to the
325      *     class where the symbol was defined, (in this case
326      *     we have extended a parameterized class with non-trivial parameters).
327      *  2. The method has an implementation with a different erased return type.
328      *     (in this case we have used co-variant returns).
329      *  If a bridge already exists in some other class, no new bridge is added.
330      *  Instead, it is checked that the bridge symbol overrides the method symbol.
331      *  (Spec ???).
332      *  todo: what about bridges for privates???
333      *
334      *  @param pos     The source code position to be used for the definition.
335      *  @param sym     The symbol for which a bridge might have to be added.
336      *  @param origin  The class in which the bridge would go.
337      *  @param bridges The list buffer to which the bridge would be added.
338      */
339     void addBridgeIfNeeded(DiagnosticPosition pos,
340                            Symbol sym,
341                            ClassSymbol origin,
342                            ListBuffer&lt;JCTree&gt; bridges) {
343         if (sym.kind == MTH &amp;&amp;
344                 sym.name != names.init &amp;&amp;
345                 (sym.flags() &amp; (PRIVATE | STATIC)) == 0 &amp;&amp;
346                 (sym.flags() &amp; SYNTHETIC) != SYNTHETIC &amp;&amp;
347                 sym.isMemberOf(origin, types)) {
348             MethodSymbol meth = (MethodSymbol)sym;
349             MethodSymbol bridge = meth.binaryImplementation(origin, types);
350             MethodSymbol impl = meth.implementation(origin, types, true);
351             if (bridge == null ||
352                 bridge == meth ||
353                 (impl != null &amp;&amp; !bridge.owner.isSubClass(impl.owner, types))) {
354                 // No bridge was added yet.
355                 if (impl != null &amp;&amp; bridge != impl &amp;&amp; isBridgeNeeded(meth, impl, origin.type)) {
356                     addBridge(pos, meth, impl, origin, bridges);
357                 } else if (impl == meth
358                            &amp;&amp; impl.owner != origin
359                            &amp;&amp; (impl.flags() &amp; FINAL) == 0
360                            &amp;&amp; (meth.flags() &amp; (ABSTRACT|PUBLIC)) == PUBLIC
361                            &amp;&amp; (origin.flags() &amp; PUBLIC) &gt; (impl.owner.flags() &amp; PUBLIC)) {
362                     // this is to work around a horrible but permanent
363                     // reflection design error.
364                     addBridge(pos, meth, impl, origin, bridges);
365                 }
366             }
367         }
368     }
369     // where
370 
371         /**
372          * @param method The symbol for which a bridge might have to be added
373          * @param impl The implementation of method
374          * @param dest The type in which the bridge would go
375          */
376         private boolean isBridgeNeeded(MethodSymbol method,
377                                        MethodSymbol impl,
378                                        Type dest) {
379             if (impl != method) {
380                 // If either method or impl have different erasures as
381                 // members of dest, a bridge is needed.
382                 Type method_erasure = method.erasure(types);
383                 if (!isSameMemberWhenErased(dest, method, method_erasure))
384                     return true;
385                 Type impl_erasure = impl.erasure(types);
386                 if (!isSameMemberWhenErased(dest, impl, impl_erasure))
387                     return true;
388 
389                 /* Bottom line: A bridge is needed if the erasure of the implementation
390                    is different from that of the method that it overrides.
391                 */
392                 return !types.isSameType(impl_erasure, method_erasure);
393             } else {
394                // method and impl are the same...
395                 if ((method.flags() &amp; ABSTRACT) != 0) {
396                     // ...and abstract so a bridge is not needed.
397                     // Concrete subclasses will bridge as needed.
398                     return false;
399                 }
400 
401                 // The erasure of the return type is always the same
402                 // for the same symbol.  Reducing the three tests in
403                 // the other branch to just one:
404                 return !isSameMemberWhenErased(dest, method, method.erasure(types));
405             }
406         }
407         /**
408          * Lookup the method as a member of the type.  Compare the
409          * erasures.
410          * @param type the class where to look for the method
411          * @param method the method to look for in class
412          * @param erasure the erasure of method
413          */
414         private boolean isSameMemberWhenErased(Type type,
415                                                MethodSymbol method,
416                                                Type erasure) {
417             return types.isSameType(erasure(types.memberType(type, method)),
418                                     erasure);
419         }
420 
421     void addBridges(DiagnosticPosition pos,
422                     TypeSymbol i,
423                     ClassSymbol origin,
424                     ListBuffer&lt;JCTree&gt; bridges) {
425         for (Symbol sym : i.members().getSymbols(NON_RECURSIVE))
426             addBridgeIfNeeded(pos, sym, origin, bridges);
427         for (List&lt;Type&gt; l = types.interfaces(i.type); l.nonEmpty(); l = l.tail)
428             addBridges(pos, l.head.tsym, origin, bridges);
429     }
430 
431     /** Add all necessary bridges to some class appending them to list buffer.
432      *  @param pos     The source code position to be used for the bridges.
433      *  @param origin  The class in which the bridges go.
434      *  @param bridges The list buffer to which the bridges are added.
435      */
436     void addBridges(DiagnosticPosition pos, ClassSymbol origin, ListBuffer&lt;JCTree&gt; bridges) {
437         Type st = types.supertype(origin.type);
438         while (st.hasTag(CLASS)) {
439 //          if (isSpecialization(st))
440             addBridges(pos, st.tsym, origin, bridges);
441             st = types.supertype(st);
442         }
443         for (List&lt;Type&gt; l = types.interfaces(origin.type); l.nonEmpty(); l = l.tail)
444 //          if (isSpecialization(l.head))
445             addBridges(pos, l.head.tsym, origin, bridges);
446     }
447 
448 /* ************************************************************************
449  * Visitor methods
450  *************************************************************************/
451 
452     /** Visitor argument: proto-type.
453      */
454     private Type pt;
455 
456     /** Visitor method: perform a type translation on tree.
457      */
458     public &lt;T extends JCTree&gt; T translate(T tree, Type pt) {
459         Type prevPt = this.pt;
460         try {
461             this.pt = pt;
462             return translate(tree);
463         } finally {
464             this.pt = prevPt;
465         }
466     }
467 
468     /** Visitor method: perform a type translation on list of trees.
469      */
470     public &lt;T extends JCTree&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, Type pt) {
471         Type prevPt = this.pt;
472         List&lt;T&gt; res;
473         try {
474             this.pt = pt;
475             res = translate(trees);
476         } finally {
477             this.pt = prevPt;
478         }
479         return res;
480     }
481 
482     public void visitClassDef(JCClassDecl tree) {
483         translateClass(tree.sym);
484         result = tree;
485     }
486 
487     Type returnType = null;
488     public void visitMethodDef(JCMethodDecl tree) {
489         Type prevRetType = returnType;
490         try {
491             returnType = erasure(tree.type).getReturnType();
492             tree.restype = translate(tree.restype, null);
493             tree.typarams = List.nil();
494             tree.params = translateVarDefs(tree.params);
495             tree.recvparam = translate(tree.recvparam, null);
496             tree.thrown = translate(tree.thrown, null);
497             tree.body = translate(tree.body, tree.sym.erasure(types).getReturnType());
498             tree.type = erasure(tree.type);
499             result = tree;
500         } finally {
501             returnType = prevRetType;
502         }
503     }
504 
505     public void visitVarDef(JCVariableDecl tree) {
506         tree.vartype = translate(tree.vartype, null);
507         tree.init = translate(tree.init, tree.sym.erasure(types));
508         tree.type = erasure(tree.type);
509         result = tree;
510     }
511 
512     public void visitDoLoop(JCDoWhileLoop tree) {
513         tree.body = translate(tree.body);
514         tree.cond = translate(tree.cond, syms.booleanType);
515         result = tree;
516     }
517 
518     public void visitWhileLoop(JCWhileLoop tree) {
519         tree.cond = translate(tree.cond, syms.booleanType);
520         tree.body = translate(tree.body);
521         result = tree;
522     }
523 
524     public void visitWithField(JCWithField tree) {
525         tree.field = translate(tree.field, null);
526         tree.value = translate(tree.value, erasure(tree.field.type));
527         tree.type = erasure(tree.type);
528         result = retype(tree, tree.type, pt);
529     }
530 
531     public void visitForLoop(JCForLoop tree) {
532         tree.init = translate(tree.init, null);
533         if (tree.cond != null)
534             tree.cond = translate(tree.cond, syms.booleanType);
535         tree.step = translate(tree.step, null);
536         tree.body = translate(tree.body);
537         result = tree;
538     }
539 
540     public void visitForeachLoop(JCEnhancedForLoop tree) {
541         tree.var = translate(tree.var, null);
542         Type iterableType = tree.expr.type;
543         tree.expr = translate(tree.expr, erasure(tree.expr.type));
544         if (types.elemtype(tree.expr.type) == null)
545             tree.expr.type = iterableType; // preserve type for Lower
546         tree.body = translate(tree.body);
547         result = tree;
548     }
549 
550     public void visitLambda(JCLambda tree) {
551         Type prevRetType = returnType;
552         try {
553             returnType = erasure(tree.getDescriptorType(types)).getReturnType();
554             tree.params = translate(tree.params);
555             tree.body = translate(tree.body, tree.body.type == null || returnType.hasTag(VOID) ? null : returnType);
556             if (!tree.type.isIntersection()) {
557                 tree.type = erasure(tree.type);
558             } else {
559                 tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);
560             }
561             result = tree;
562         }
563         finally {
564             returnType = prevRetType;
565         }
566     }
567 
568     public void visitSwitch(JCSwitch tree) {
569         Type selsuper = types.supertype(tree.selector.type);
570         boolean enumSwitch = selsuper != null &amp;&amp;
571             selsuper.tsym == syms.enumSym;
572         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
573         tree.selector = translate(tree.selector, target);
574         tree.cases = translateCases(tree.cases);
575         result = tree;
576     }
577 
578     public void visitCase(JCCase tree) {
579         tree.pats = translate(tree.pats, null);
580         tree.stats = translate(tree.stats);
581         result = tree;
582     }
583 
584     public void visitBindingPattern(JCBindingPattern tree) {
585         if (tree.vartype != null) {
586             tree.vartype = translate(tree.vartype, null);
587         }
588         result = tree;
589     }
590 
591     public void visitSwitchExpression(JCSwitchExpression tree) {
592         Type selsuper = types.supertype(tree.selector.type);
593         boolean enumSwitch = selsuper != null &amp;&amp;
594             selsuper.tsym == syms.enumSym;
595         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
596         tree.selector = translate(tree.selector, target);
597         tree.cases = translate(tree.cases);
598         tree.type = erasure(tree.type);
599         result = retype(tree, tree.type, pt);
600     }
601 
602     public void visitSynchronized(JCSynchronized tree) {
603         tree.lock = translate(tree.lock, erasure(tree.lock.type));
604         tree.body = translate(tree.body);
605         result = tree;
606     }
607 
608     public void visitTry(JCTry tree) {
609         tree.resources = translate(tree.resources, syms.autoCloseableType);
610         tree.body = translate(tree.body);
611         tree.catchers = translateCatchers(tree.catchers);
612         tree.finalizer = translate(tree.finalizer);
613         result = tree;
614     }
615 
616     public void visitConditional(JCConditional tree) {
617         tree.cond = translate(tree.cond, syms.booleanType);
618         tree.truepart = translate(tree.truepart, erasure(tree.type));
619         tree.falsepart = translate(tree.falsepart, erasure(tree.type));
620         tree.type = erasure(tree.type);
621         result = retype(tree, tree.type, pt);
622     }
623 
624    public void visitIf(JCIf tree) {
625         tree.cond = translate(tree.cond, syms.booleanType);
626         tree.thenpart = translate(tree.thenpart);
627         tree.elsepart = translate(tree.elsepart);
628         result = tree;
629     }
630 
631     public void visitExec(JCExpressionStatement tree) {
632         tree.expr = translate(tree.expr, null);
633         result = tree;
634     }
635 
636     public void visitReturn(JCReturn tree) {
637         if (!returnType.hasTag(VOID))
638             tree.expr = translate(tree.expr, returnType);
639         result = tree;
640     }
641 
642     @Override
643     public void visitBreak(JCBreak tree) {
644         result = tree;
645     }
646 
647     @Override
648     public void visitYield(JCYield tree) {
649         tree.value = translate(tree.value, erasure(tree.value.type));
650         tree.value.type = erasure(tree.value.type);
651         tree.value = retype(tree.value, tree.value.type, pt);
652         result = tree;
653     }
654 
655     public void visitThrow(JCThrow tree) {
656         tree.expr = translate(tree.expr, erasure(tree.expr.type));
657         result = tree;
658     }
659 
660     public void visitAssert(JCAssert tree) {
661         tree.cond = translate(tree.cond, syms.booleanType);
662         if (tree.detail != null)
663             tree.detail = translate(tree.detail, erasure(tree.detail.type));
664         result = tree;
665     }
666 
667     public void visitApply(JCMethodInvocation tree) {
668         tree.meth = translate(tree.meth, null);
669         Symbol meth = TreeInfo.symbol(tree.meth);
670         Type mt = meth.erasure(types);
671         boolean useInstantiatedPtArgs =
672                 allowGraphInference &amp;&amp; !types.isSignaturePolymorphic((MethodSymbol)meth.baseSymbol());
673         List&lt;Type&gt; argtypes = useInstantiatedPtArgs ?
674                 tree.meth.type.getParameterTypes() :
675                 mt.getParameterTypes();
676         if (meth.name == names.init &amp;&amp; meth.owner == syms.enumSym)
677             argtypes = argtypes.tail.tail;
678         if (tree.varargsElement != null)
679             tree.varargsElement = types.erasure(tree.varargsElement);
680         else
681             if (tree.args.length() != argtypes.length()) {
682                 Assert.error(String.format(&quot;Incorrect number of arguments; expected %d, found %d&quot;,
683                         tree.args.length(), argtypes.length()));
684             }
685         tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);
686 
687         tree.type = types.erasure(tree.type);
688         // Insert casts of method invocation results as needed.
689         result = retype(tree, mt.getReturnType(), pt);
690     }
691 
692     public void visitNewClass(JCNewClass tree) {
693         if (tree.encl != null) {
694             if (tree.def == null) {
695                 tree.encl = translate(tree.encl, erasure(tree.encl.type));
696             } else {
697                 tree.args = tree.args.prepend(attr.makeNullCheck(tree.encl));
698                 tree.encl = null;
699             }
700         }
701 
702         Type erasedConstructorType = tree.constructorType != null ?
703                 erasure(tree.constructorType) :
704                 null;
705 
706         List&lt;Type&gt; argtypes = erasedConstructorType != null &amp;&amp; allowGraphInference ?
707                 erasedConstructorType.getParameterTypes() :
708                 tree.constructor.erasure(types).getParameterTypes();
709 
710         tree.clazz = translate(tree.clazz, null);
711         if (tree.varargsElement != null)
712             tree.varargsElement = types.erasure(tree.varargsElement);
713         tree.args = translateArgs(
714             tree.args, argtypes, tree.varargsElement);
715         tree.def = translate(tree.def, null);
716         if (erasedConstructorType != null)
717             tree.constructorType = erasedConstructorType;
718         tree.type = erasure(tree.type);
719         result = tree;
720     }
721 
722     public void visitNewArray(JCNewArray tree) {
723         tree.elemtype = translate(tree.elemtype, null);
724         translate(tree.dims, syms.intType);
725         if (tree.type != null) {
726             tree.elems = translate(tree.elems, erasure(types.elemtype(tree.type)));
727             tree.type = erasure(tree.type);
728         } else {
729             tree.elems = translate(tree.elems, null);
730         }
731 
732         result = tree;
733     }
734 
735     public void visitParens(JCParens tree) {
736         tree.expr = translate(tree.expr, pt);
737         tree.type = erasure(tree.expr.type);
738         result = tree;
739     }
740 
741     public void visitAssign(JCAssign tree) {
742         tree.lhs = translate(tree.lhs, null);
743         tree.rhs = translate(tree.rhs, erasure(tree.lhs.type));
744         tree.type = erasure(tree.lhs.type);
745         result = retype(tree, tree.type, pt);
746     }
747 
748     public void visitAssignop(JCAssignOp tree) {
749         tree.lhs = translate(tree.lhs, null);
750         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
751         tree.type = erasure(tree.type);
752         result = tree;
753     }
754 
755     public void visitUnary(JCUnary tree) {
756         tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK)
757             ? tree.type
758             : tree.operator.type.getParameterTypes().head);
759         result = tree;
760     }
761 
762     public void visitBinary(JCBinary tree) {
763         tree.lhs = translate(tree.lhs, tree.operator.type.getParameterTypes().head);
764         tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
765         result = tree;
766     }
767 
768     public void visitAnnotatedType(JCAnnotatedType tree) {
769         // For now, we need to keep the annotations in the tree because of the current
770         // MultiCatch implementation wrt type annotations
771         List&lt;TypeCompound&gt; mirrors = annotate.fromAnnotations(tree.annotations);
772         tree.underlyingType = translate(tree.underlyingType);
773         tree.type = tree.underlyingType.type.annotatedType(mirrors);
774         result = tree;
775     }
776 
777     public void visitTypeCast(JCTypeCast tree) {
778         tree.clazz = translate(tree.clazz, null);
779         Type originalTarget = tree.type;
780         tree.type = erasure(tree.type);
781         JCExpression newExpression = translate(tree.expr, tree.type);
782         if (newExpression != tree.expr) {
783             JCTypeCast typeCast = newExpression.hasTag(Tag.TYPECAST)
784                 ? (JCTypeCast) newExpression
785                 : null;
786             tree.expr = typeCast != null &amp;&amp; types.isSameType(typeCast.type, originalTarget)
787                 ? typeCast.expr
788                 : newExpression;
789         }
790         if (originalTarget.isIntersection()) {
791             Type.IntersectionClassType ict = (Type.IntersectionClassType)originalTarget;
792             for (Type c : ict.getExplicitComponents()) {
793                 Type ec = erasure(c);
794                 if (!types.isSameType(ec, tree.type)) {
795                     tree.expr = coerce(tree.expr, ec);
796                 }
797             }
798         }
799         result = retype(tree, tree.type, pt);
800     }
801 
802     public void visitTypeTest(JCInstanceOf tree) {
803         tree.expr = translate(tree.expr, null);
804         tree.pattern = translate(tree.pattern, null);
805         result = tree;
806     }
807 
808     public void visitIndexed(JCArrayAccess tree) {
809         tree.indexed = translate(tree.indexed, erasure(tree.indexed.type));
810         tree.index = translate(tree.index, syms.intType);
811 
812         // Insert casts of indexed expressions as needed.
813         result = retype(tree, types.elemtype(tree.indexed.type), pt);
814     }
815 
816     // There ought to be nothing to rewrite here;
817     // we don&#39;t generate code.
818     public void visitAnnotation(JCAnnotation tree) {
819         result = tree;
820     }
821 
822     public void visitIdent(JCIdent tree) {
823         Type et = tree.sym.erasure(types);
824 
825         // Map type variables to their bounds.
826         if (tree.sym.kind == TYP &amp;&amp; tree.sym.type.hasTag(TYPEVAR)) {
827             result = make.at(tree.pos).Type(et);
828         } else
829         // Map constants expressions to themselves.
830         if (tree.type.constValue() != null) {
831             result = tree;
832         }
833         // Insert casts of variable uses as needed.
834         else if (tree.sym.kind == VAR) {
835             result = retype(tree, et, pt);
836         }
837         else {
838             tree.type = erasure(tree.type);
839             result = tree;
840         }
841     }
842 
843     public void visitSelect(JCFieldAccess tree) {
844         Type t = types.skipTypeVars(tree.selected.type, false);
845         if (t.isCompound()) {
846             tree.selected = coerce(
847                 translate(tree.selected, erasure(tree.selected.type)),
848                 erasure(tree.sym.owner.type));
849         } else
850             tree.selected = translate(tree.selected, erasure(t));
851 
852         // Map constants expressions to themselves.
853         if (tree.type.constValue() != null) {
854             result = tree;
855         }
856         // Insert casts of variable uses as needed.
857         else if (tree.sym.kind == VAR) {
858             result = retype(tree, tree.sym.erasure(types), pt);
859         }
860         else {
861             tree.type = erasure(tree.type);
862             result = tree;
863         }
864     }
865 
866     public void visitReference(JCMemberReference tree) {
867         Type t = types.skipTypeVars(tree.expr.type, false);
868         Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);
869         if (tree.kind == ReferenceKind.UNBOUND) {
870             tree.expr = make.Type(receiverTarget);
871         } else {
872             tree.expr = translate(tree.expr, receiverTarget);
873         }
874         if (!tree.type.isIntersection()) {
875             tree.type = erasure(tree.type);
876         } else {
877             tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);
878         }
879         if (tree.varargsElement != null)
880             tree.varargsElement = erasure(tree.varargsElement);
881         result = tree;
882     }
883 
884     public void visitTypeArray(JCArrayTypeTree tree) {
885         tree.elemtype = translate(tree.elemtype, null);
886         tree.type = erasure(tree.type);
887         result = tree;
888     }
889 
890     /** Visitor method for parameterized types.
891      */
892     public void visitTypeApply(JCTypeApply tree) {
893         JCTree clazz = translate(tree.clazz, null);
894         result = clazz;
895     }
896 
897     public void visitTypeIntersection(JCTypeIntersection tree) {
898         tree.bounds = translate(tree.bounds, null);
899         tree.type = erasure(tree.type);
900         result = tree;
901     }
902 
903 /**************************************************************************
904  * utility methods
905  *************************************************************************/
906 
907     private Type erasure(Type t) {
908         return types.erasure(t);
909     }
910 
911 /**************************************************************************
912  * main method
913  *************************************************************************/
914 
915     private Env&lt;AttrContext&gt; env;
916 
917     private static final String statePreviousToFlowAssertMsg =
918             &quot;The current compile state [%s] of class %s is previous to FLOW&quot;;
919 
920     void translateClass(ClassSymbol c) {
921         Type st = types.supertype(c.type);
922         // process superclass before derived
923         if (st.hasTag(CLASS)) {
924             translateClass((ClassSymbol)st.tsym);
925         }
926 
927         Env&lt;AttrContext&gt; myEnv = enter.getEnv(c);
928         if (myEnv == null || (c.flags_field &amp; TYPE_TRANSLATED) != 0) {
929             return;
930         }
931         c.flags_field |= TYPE_TRANSLATED;
932 
933         /*  The two assertions below are set for early detection of any attempt
934          *  to translate a class that:
935          *
936          *  1) has no compile state being it the most outer class.
937          *     We accept this condition for inner classes.
938          *
939          *  2) has a compile state which is previous to Flow state.
940          */
941         boolean envHasCompState = compileStates.get(myEnv) != null;
942         if (!envHasCompState &amp;&amp; c.outermostClass() == c) {
943             Assert.error(&quot;No info for outermost class: &quot; + myEnv.enclClass.sym);
944         }
945 
946         if (envHasCompState &amp;&amp;
947                 CompileState.FLOW.isAfter(compileStates.get(myEnv))) {
948             Assert.error(String.format(statePreviousToFlowAssertMsg,
949                     compileStates.get(myEnv), myEnv.enclClass.sym));
950         }
951 
952         Env&lt;AttrContext&gt; oldEnv = env;
953         try {
954             env = myEnv;
955             // class has not been translated yet
956 
957             TreeMaker savedMake = make;
958             Type savedPt = pt;
959             make = make.forToplevel(env.toplevel);
960             pt = null;
961             try {
962                 JCClassDecl tree = (JCClassDecl) env.tree;
963                 tree.typarams = List.nil();
964                 super.visitClassDef(tree);
965                 make.at(tree.pos);
966                 ListBuffer&lt;JCTree&gt; bridges = new ListBuffer&lt;&gt;();
967                 if (allowInterfaceBridges || (tree.sym.flags() &amp; INTERFACE) == 0) {
968                     addBridges(tree.pos(), c, bridges);
969                 }
970                 tree.defs = bridges.toList().prependList(tree.defs);
971                 tree.type = erasure(tree.type);
972             } finally {
973                 make = savedMake;
974                 pt = savedPt;
975             }
976         } finally {
977             env = oldEnv;
978         }
979     }
980 
981     /** Translate a toplevel class definition.
982      *  @param cdef    The definition to be translated.
983      */
984     public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {
985         // note that this method does NOT support recursion.
986         this.make = make;
987         pt = null;
988         return translate(cdef, null);
989     }
990 }
    </pre>
  </body>
</html>
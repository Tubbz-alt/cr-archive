<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jvm/TransValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 
 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed
<span class="line-removed"> 244      *     mode |= NOQUESTION   : type terminal ? is not allowed</span>
 245      */
 246     protected static final int EXPR = 0x1;
 247     protected static final int TYPE = 0x2;
 248     protected static final int NOPARAMS = 0x4;
 249     protected static final int TYPEARG = 0x8;
 250     protected static final int DIAMOND = 0x10;
 251     protected static final int NOLAMBDA = 0x20;
<span class="line-removed"> 252     protected static final int NOQUESTION = 0x40;</span>
 253 
 254     protected void selectExprMode() {
 255         mode = (mode &amp; NOLAMBDA) | EXPR;
 256     }
 257 
 258     protected void selectTypeMode() {
 259         mode = (mode &amp; NOLAMBDA) | TYPE;
 260     }
 261 
 262     /** The current mode.
 263      */
 264     protected int mode = 0;
 265 
 266     /** The mode of the term that was parsed last.
 267      */
 268     protected int lastmode = 0;
 269 
 270     /* ---------- token management -------------- */
 271 
 272     protected Token token;
</pre>
<hr />
<pre>
 621             }
 622         } else if (token.kind == UNDERSCORE) {
 623             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 624                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 625             } else {
 626                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 627             }
 628             Name name = token.name();
 629             nextToken();
 630             return name;
 631         } else {
 632             accept(IDENTIFIER);
 633             if (advanceOnErrors) {
 634                 nextToken();
 635             }
 636             return names.error;
 637         }
 638     }
 639 
 640     /**
<span class="line-modified"> 641      * Qualident = Ident { DOT [Annotations] Ident } {?}</span>
 642      */
 643     public JCExpression qualident(boolean allowAnnos) {
 644         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 645         while (token.kind == DOT) {
 646             int pos = token.pos;
 647             nextToken();
 648             List&lt;JCAnnotation&gt; tyannos = null;
 649             if (allowAnnos) {
 650                 tyannos = typeAnnotationsOpt();
 651             }
 652             t = toP(F.at(pos).Select(t, ident()));
 653             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 654                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 655             }
 656         }
<span class="line-removed"> 657         /* if the qualified identifier being parsed is for a type name (as indicated by allowAnnos),</span>
<span class="line-removed"> 658            also process any terminal ? to signal nullable projection for a value type.</span>
<span class="line-removed"> 659         */</span>
<span class="line-removed"> 660         if (allowAnnos &amp;&amp; token.kind == QUES) {</span>
<span class="line-removed"> 661             t.setQuestioned();</span>
<span class="line-removed"> 662             nextToken();</span>
<span class="line-removed"> 663         }</span>
 664         return t;
 665     }
 666 
 667     JCExpression literal(Name prefix) {
 668         return literal(prefix, token.pos);
 669     }
 670 
 671     /**
 672      * Literal =
 673      *     INTLITERAL
 674      *   | LONGLITERAL
 675      *   | FLOATLITERAL
 676      *   | DOUBLELITERAL
 677      *   | CHARLITERAL
 678      *   | STRINGLITERAL
 679      *   | TRUE
 680      *   | FALSE
 681      *   | NULL
 682      */
 683     JCExpression literal(Name prefix, int pos) {
</pre>
<hr />
<pre>
 787     public JCExpression parseExpression() {
 788         return term(EXPR);
 789     }
 790 
 791     /**
 792      * parses (optional) type annotations followed by a type. If the
 793      * annotations are present before the type and are not consumed during array
 794      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 795      * these annotations and the underlying type. Otherwise, it returns the
 796      * underlying type.
 797      *
 798      * &lt;p&gt;
 799      *
 800      * Note that this method sets {@code mode} to {@code TYPE} first, before
 801      * parsing annotations.
 802      */
 803     public JCExpression parseType() {
 804         return parseType(false);
 805     }
 806 
<span class="line-removed"> 807     public JCExpression parseTypeSansQuestion() {</span>
<span class="line-removed"> 808         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();</span>
<span class="line-removed"> 809         boolean questionOK = peekToken(0, QUES) &amp;&amp; peekToken(1, LBRACKET)  &amp;&amp; peekToken(2, RBRACKET);</span>
<span class="line-removed"> 810         JCExpression result = unannotatedType(false, TYPE | (questionOK ? 0 : NOQUESTION));</span>
<span class="line-removed"> 811         mode &amp;= ~NOQUESTION;</span>
<span class="line-removed"> 812         if (annotations.nonEmpty()) {</span>
<span class="line-removed"> 813             result = insertAnnotationsToMostInner(result, annotations, false);</span>
<span class="line-removed"> 814         }</span>
<span class="line-removed"> 815 </span>
<span class="line-removed"> 816         return result;</span>
<span class="line-removed"> 817     }</span>
<span class="line-removed"> 818 </span>
 819     public JCExpression parseType(boolean allowVar) {
 820         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 821         return parseType(allowVar, annotations);
 822     }
 823 
 824     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
<span class="line-modified"> 825         JCExpression result = unannotatedType(allowVar, TYPE);</span>
 826 
 827         if (annotations.nonEmpty()) {
 828             result = insertAnnotationsToMostInner(result, annotations, false);
 829         }
 830 
 831         return result;
 832     }
 833 
<span class="line-modified"> 834     public JCExpression unannotatedType(boolean allowVar, int termMode) {</span>
<span class="line-modified"> 835         JCExpression result = term(termMode);</span>
 836         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 837 
 838         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 839             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 840         }
 841 
 842         return result;
 843     }
 844 
 845 
 846 
 847     protected JCExpression term(int newmode) {
 848         int prevmode = mode;
 849         mode = newmode;
 850         JCExpression t = term();
 851         lastmode = mode;
 852         mode = prevmode;
 853         return t;
 854     }
 855 
</pre>
<hr />
<pre>
 961      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 962      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 963      *                  | &quot;+&quot; | &quot;-&quot;
 964      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 965      */
 966     JCExpression term2Rest(JCExpression t, int minprec) {
 967         JCExpression[] odStack = newOdStack();
 968         Token[] opStack = newOpStack();
 969 
 970         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 971         int top = 0;
 972         odStack[0] = t;
 973         int startPos = token.pos;
 974         Token topOp = Tokens.DUMMY;
 975         while (prec(token.kind) &gt;= minprec) {
 976             opStack[top] = topOp;
 977 
 978             if (token.kind == INSTANCEOF) {
 979                 int pos = token.pos;
 980                 nextToken();
<span class="line-modified"> 981                 JCTree pattern = parseTypeSansQuestion();</span>
 982                 if (token.kind == IDENTIFIER) {
 983                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 984                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 985                 }
 986                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 987             } else {
 988                 topOp = token;
 989                 nextToken();
 990                 top++;
 991                 odStack[top] = term3();
 992             }
 993             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 994                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 995                 top--;
 996                 topOp = opStack[top];
 997             }
 998         }
 999         Assert.check(top == 0);
1000         t = odStack[0];
1001 
</pre>
<hr />
<pre>
1278                     } else {
1279                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1280                         return expr;
1281                     }
1282                 }
1283                 default:
1284                     return illegal(typeAnnos.head.pos);
1285                 }
1286 
1287             } else {
1288                 // Type annotations targeting a cast
1289                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1290             }
1291             break;
1292         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1293             if (typeArgs != null) return illegal();
1294             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1295                 t = lambdaExpressionOrStatement(false, false, pos);
1296             } else {
1297                 t = toP(F.at(token.pos).Ident(ident()));
<span class="line-removed">1298                 handleQuestion(t);</span>
1299                 loop: while (true) {
1300                     pos = token.pos;
1301                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1302 
1303                     // need to report an error later if LBRACKET is for array
1304                     // index access rather than array creation level
1305                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1306                         return illegal(annos.head.pos);
1307 
1308                     switch (token.kind) {
1309                     case LBRACKET:
1310                         nextToken();
1311                         if (token.kind == RBRACKET) {
1312                             nextToken();
1313                             t = bracketsOpt(t);
1314                             t = toP(F.at(pos).TypeArray(t));
1315                             if (annos.nonEmpty()) {
1316                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1317                             }
1318                             t = bracketsSuffix(t);
</pre>
<hr />
<pre>
1370                                 typeArgs = null;
1371                                 break loop;
1372                             case NEW:
1373                                 if (typeArgs != null) return illegal();
1374                                 selectExprMode();
1375                                 int pos1 = token.pos;
1376                                 nextToken();
1377                                 if (token.kind == LT) typeArgs = typeArguments(false);
1378                                 t = innerCreator(pos1, typeArgs, t);
1379                                 typeArgs = null;
1380                                 break loop;
1381                             }
1382                         }
1383 
1384                         List&lt;JCAnnotation&gt; tyannos = null;
1385                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1386                             tyannos = typeAnnotationsOpt();
1387                         }
1388                         // typeArgs saved for next loop iteration.
1389                         t = toP(F.at(pos).Select(t, ident()));
<span class="line-removed">1390                         handleQuestion(t);</span>
1391                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1392                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1393                         }
1394                         break;
1395                     case ELLIPSIS:
1396                         if (this.permitTypeAnnotationsPushBack) {
1397                             this.typeAnnotationsPushedBack = annos;
1398                         } else if (annos.nonEmpty()) {
1399                             // Don&#39;t return here -- error recovery attempt
1400                             illegal(annos.head.pos);
1401                         }
1402                         break loop;
1403                     case LT:
1404                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {
1405                             //this is either an unbound method reference whose qualifier
1406                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of
1407                             //the form ValueType&lt;S&gt;.default
1408                             int pos1 = token.pos;
1409                             accept(LT);
1410                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
1484                 case DEFAULT:
1485                     cases.appendList(switchExpressionStatementGroup());
1486                     break;
1487                 case RBRACE: case EOF:
1488                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1489                                                                                cases.toList()));
1490                     e.endpos = token.pos;
1491                     accept(RBRACE);
1492                     return e;
1493                 default:
1494                     nextToken(); // to ensure progress
1495                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1496                 }
1497             }
1498         default:
1499             return illegal();
1500         }
1501         return term3Rest(t, typeArgs);
1502     }
1503 
<span class="line-removed">1504     // where</span>
<span class="line-removed">1505         private void handleQuestion(JCExpression t) {</span>
<span class="line-removed">1506             if (token.kind == QUES) {</span>
<span class="line-removed">1507                 if (((mode &amp; NOQUESTION) == 0 &amp;&amp; (mode &amp; TYPE) != 0) ||</span>
<span class="line-removed">1508                         (peekToken(0, LBRACKET) &amp;&amp; peekToken(1, RBRACKET) &amp;&amp; peekToken(2, DOT) &amp;&amp; peekToken(3, CLASS))) {</span>
<span class="line-removed">1509                     t.setQuestioned();</span>
<span class="line-removed">1510                     nextToken();</span>
<span class="line-removed">1511                 }</span>
<span class="line-removed">1512             }</span>
<span class="line-removed">1513         }</span>
<span class="line-removed">1514 </span>
1515     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1516         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1517         int casePos = token.pos;
1518         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1519 
1520         if (token.kind == DEFAULT) {
1521             nextToken();
1522         } else {
1523             accept(CASE);
1524             while (true) {
1525                 pats.append(term(EXPR | NOLAMBDA));
1526                 if (token.kind != COMMA) break;
1527                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1528                 nextToken();
1529             };
1530         }
1531         List&lt;JCStatement&gt; stats = null;
1532         JCTree body = null;
1533         CaseTree.CaseKind kind;
1534         switch (token.kind) {
</pre>
<hr />
<pre>
2166         } else if (token.kind == SUPER) {
2167             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2168             nextToken();
2169             JCExpression bound = parseType();
2170             result = F.at(pos).Wildcard(t, bound);
2171         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2172             //error recovery
2173             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2174             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2175             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2176             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2177             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2178             result = err;
2179         } else {
2180             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2181             result = toP(F.at(pos).Wildcard(t, null));
2182         }
2183         if (!annotations.isEmpty()) {
2184             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2185         }
<span class="line-removed">2186         handleQuestion(result);</span>
2187         return result;
2188     }
2189 
2190     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2191         int pos = token.pos;
2192         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
<span class="line-modified">2193         JCTypeApply ta = toP(F.at(pos).TypeApply(t, args));</span>
<span class="line-removed">2194         handleQuestion(ta);</span>
<span class="line-removed">2195         return ta;</span>
2196     }
2197 
2198     /**
2199      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2200      *
2201      * &lt;p&gt;
2202      *
2203      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2204      * the expression &lt;code&gt;t&lt;/code&gt;.
2205      */
2206     private JCExpression bracketsOpt(JCExpression t,
2207             List&lt;JCAnnotation&gt; annotations) {
2208         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2209 
2210         if (token.kind == LBRACKET) {
2211             int pos = token.pos;
2212             nextToken();
2213             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2214         } else if (!nextLevelAnnotations.isEmpty()) {
2215             if (permitTypeAnnotationsPushBack) {
</pre>
<hr />
<pre>
4216                     storeEnd(mods, pos);
4217                 }
4218                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4219 
4220                 if (annosAfterParams.nonEmpty()) {
4221                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4222                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4223                     if (mods.pos == Position.NOPOS)
4224                         mods.pos = mods.annotations.head.pos;
4225                 }
4226 
4227                 Token tk = token;
4228                 pos = token.pos;
4229                 JCExpression type;
4230                 boolean isVoid = token.kind == VOID;
4231                 if (isVoid) {
4232                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4233                     nextToken();
4234                 } else {
4235                     // method returns types are un-annotated types
<span class="line-modified">4236                     type = unannotatedType(false, TYPE);</span>
4237                 }
4238                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4239                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4240                     if (isInterface || tk.name() != className)
4241                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4242                     else if (annosAfterParams.nonEmpty())
4243                         illegal(annosAfterParams.head.pos);
4244                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4245                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4246                     }
4247                     return List.of(methodDeclaratorRest(
4248                         pos, mods, null, names.init, typarams,
4249                         isInterface, true, isRecord, dc));
4250                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4251                     // trying to define a compact constructor with a throws clause
4252                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4253                             Errors.InvalidCanonicalConstructorInRecord(
4254                                     Fragments.Compact,
4255                                     className,
4256                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
</pre>
</td>
<td>
<hr />
<pre>
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 
 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed

 244      */
 245     protected static final int EXPR = 0x1;
 246     protected static final int TYPE = 0x2;
 247     protected static final int NOPARAMS = 0x4;
 248     protected static final int TYPEARG = 0x8;
 249     protected static final int DIAMOND = 0x10;
 250     protected static final int NOLAMBDA = 0x20;

 251 
 252     protected void selectExprMode() {
 253         mode = (mode &amp; NOLAMBDA) | EXPR;
 254     }
 255 
 256     protected void selectTypeMode() {
 257         mode = (mode &amp; NOLAMBDA) | TYPE;
 258     }
 259 
 260     /** The current mode.
 261      */
 262     protected int mode = 0;
 263 
 264     /** The mode of the term that was parsed last.
 265      */
 266     protected int lastmode = 0;
 267 
 268     /* ---------- token management -------------- */
 269 
 270     protected Token token;
</pre>
<hr />
<pre>
 619             }
 620         } else if (token.kind == UNDERSCORE) {
 621             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 622                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 623             } else {
 624                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 625             }
 626             Name name = token.name();
 627             nextToken();
 628             return name;
 629         } else {
 630             accept(IDENTIFIER);
 631             if (advanceOnErrors) {
 632                 nextToken();
 633             }
 634             return names.error;
 635         }
 636     }
 637 
 638     /**
<span class="line-modified"> 639      * Qualident = Ident { DOT [Annotations] Ident }</span>
 640      */
 641     public JCExpression qualident(boolean allowAnnos) {
 642         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 643         while (token.kind == DOT) {
 644             int pos = token.pos;
 645             nextToken();
 646             List&lt;JCAnnotation&gt; tyannos = null;
 647             if (allowAnnos) {
 648                 tyannos = typeAnnotationsOpt();
 649             }
 650             t = toP(F.at(pos).Select(t, ident()));
 651             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 652                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 653             }
 654         }







 655         return t;
 656     }
 657 
 658     JCExpression literal(Name prefix) {
 659         return literal(prefix, token.pos);
 660     }
 661 
 662     /**
 663      * Literal =
 664      *     INTLITERAL
 665      *   | LONGLITERAL
 666      *   | FLOATLITERAL
 667      *   | DOUBLELITERAL
 668      *   | CHARLITERAL
 669      *   | STRINGLITERAL
 670      *   | TRUE
 671      *   | FALSE
 672      *   | NULL
 673      */
 674     JCExpression literal(Name prefix, int pos) {
</pre>
<hr />
<pre>
 778     public JCExpression parseExpression() {
 779         return term(EXPR);
 780     }
 781 
 782     /**
 783      * parses (optional) type annotations followed by a type. If the
 784      * annotations are present before the type and are not consumed during array
 785      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 786      * these annotations and the underlying type. Otherwise, it returns the
 787      * underlying type.
 788      *
 789      * &lt;p&gt;
 790      *
 791      * Note that this method sets {@code mode} to {@code TYPE} first, before
 792      * parsing annotations.
 793      */
 794     public JCExpression parseType() {
 795         return parseType(false);
 796     }
 797 












 798     public JCExpression parseType(boolean allowVar) {
 799         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 800         return parseType(allowVar, annotations);
 801     }
 802 
 803     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
<span class="line-modified"> 804         JCExpression result = unannotatedType(allowVar);</span>
 805 
 806         if (annotations.nonEmpty()) {
 807             result = insertAnnotationsToMostInner(result, annotations, false);
 808         }
 809 
 810         return result;
 811     }
 812 
<span class="line-modified"> 813     public JCExpression unannotatedType(boolean allowVar) {</span>
<span class="line-modified"> 814         JCExpression result = term(TYPE);</span>
 815         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 816 
 817         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 818             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 819         }
 820 
 821         return result;
 822     }
 823 
 824 
 825 
 826     protected JCExpression term(int newmode) {
 827         int prevmode = mode;
 828         mode = newmode;
 829         JCExpression t = term();
 830         lastmode = mode;
 831         mode = prevmode;
 832         return t;
 833     }
 834 
</pre>
<hr />
<pre>
 940      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 941      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 942      *                  | &quot;+&quot; | &quot;-&quot;
 943      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 944      */
 945     JCExpression term2Rest(JCExpression t, int minprec) {
 946         JCExpression[] odStack = newOdStack();
 947         Token[] opStack = newOpStack();
 948 
 949         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 950         int top = 0;
 951         odStack[0] = t;
 952         int startPos = token.pos;
 953         Token topOp = Tokens.DUMMY;
 954         while (prec(token.kind) &gt;= minprec) {
 955             opStack[top] = topOp;
 956 
 957             if (token.kind == INSTANCEOF) {
 958                 int pos = token.pos;
 959                 nextToken();
<span class="line-modified"> 960                 JCTree pattern = parseType();</span>
 961                 if (token.kind == IDENTIFIER) {
 962                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 963                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 964                 }
 965                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 966             } else {
 967                 topOp = token;
 968                 nextToken();
 969                 top++;
 970                 odStack[top] = term3();
 971             }
 972             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 973                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 974                 top--;
 975                 topOp = opStack[top];
 976             }
 977         }
 978         Assert.check(top == 0);
 979         t = odStack[0];
 980 
</pre>
<hr />
<pre>
1257                     } else {
1258                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1259                         return expr;
1260                     }
1261                 }
1262                 default:
1263                     return illegal(typeAnnos.head.pos);
1264                 }
1265 
1266             } else {
1267                 // Type annotations targeting a cast
1268                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1269             }
1270             break;
1271         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1272             if (typeArgs != null) return illegal();
1273             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1274                 t = lambdaExpressionOrStatement(false, false, pos);
1275             } else {
1276                 t = toP(F.at(token.pos).Ident(ident()));

1277                 loop: while (true) {
1278                     pos = token.pos;
1279                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1280 
1281                     // need to report an error later if LBRACKET is for array
1282                     // index access rather than array creation level
1283                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1284                         return illegal(annos.head.pos);
1285 
1286                     switch (token.kind) {
1287                     case LBRACKET:
1288                         nextToken();
1289                         if (token.kind == RBRACKET) {
1290                             nextToken();
1291                             t = bracketsOpt(t);
1292                             t = toP(F.at(pos).TypeArray(t));
1293                             if (annos.nonEmpty()) {
1294                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1295                             }
1296                             t = bracketsSuffix(t);
</pre>
<hr />
<pre>
1348                                 typeArgs = null;
1349                                 break loop;
1350                             case NEW:
1351                                 if (typeArgs != null) return illegal();
1352                                 selectExprMode();
1353                                 int pos1 = token.pos;
1354                                 nextToken();
1355                                 if (token.kind == LT) typeArgs = typeArguments(false);
1356                                 t = innerCreator(pos1, typeArgs, t);
1357                                 typeArgs = null;
1358                                 break loop;
1359                             }
1360                         }
1361 
1362                         List&lt;JCAnnotation&gt; tyannos = null;
1363                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1364                             tyannos = typeAnnotationsOpt();
1365                         }
1366                         // typeArgs saved for next loop iteration.
1367                         t = toP(F.at(pos).Select(t, ident()));

1368                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1369                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1370                         }
1371                         break;
1372                     case ELLIPSIS:
1373                         if (this.permitTypeAnnotationsPushBack) {
1374                             this.typeAnnotationsPushedBack = annos;
1375                         } else if (annos.nonEmpty()) {
1376                             // Don&#39;t return here -- error recovery attempt
1377                             illegal(annos.head.pos);
1378                         }
1379                         break loop;
1380                     case LT:
1381                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {
1382                             //this is either an unbound method reference whose qualifier
1383                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of
1384                             //the form ValueType&lt;S&gt;.default
1385                             int pos1 = token.pos;
1386                             accept(LT);
1387                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
1461                 case DEFAULT:
1462                     cases.appendList(switchExpressionStatementGroup());
1463                     break;
1464                 case RBRACE: case EOF:
1465                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1466                                                                                cases.toList()));
1467                     e.endpos = token.pos;
1468                     accept(RBRACE);
1469                     return e;
1470                 default:
1471                     nextToken(); // to ensure progress
1472                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1473                 }
1474             }
1475         default:
1476             return illegal();
1477         }
1478         return term3Rest(t, typeArgs);
1479     }
1480 











1481     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1482         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1483         int casePos = token.pos;
1484         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1485 
1486         if (token.kind == DEFAULT) {
1487             nextToken();
1488         } else {
1489             accept(CASE);
1490             while (true) {
1491                 pats.append(term(EXPR | NOLAMBDA));
1492                 if (token.kind != COMMA) break;
1493                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1494                 nextToken();
1495             };
1496         }
1497         List&lt;JCStatement&gt; stats = null;
1498         JCTree body = null;
1499         CaseTree.CaseKind kind;
1500         switch (token.kind) {
</pre>
<hr />
<pre>
2132         } else if (token.kind == SUPER) {
2133             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2134             nextToken();
2135             JCExpression bound = parseType();
2136             result = F.at(pos).Wildcard(t, bound);
2137         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2138             //error recovery
2139             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2140             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2141             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2142             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2143             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2144             result = err;
2145         } else {
2146             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2147             result = toP(F.at(pos).Wildcard(t, null));
2148         }
2149         if (!annotations.isEmpty()) {
2150             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2151         }

2152         return result;
2153     }
2154 
2155     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2156         int pos = token.pos;
2157         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
<span class="line-modified">2158         return toP(F.at(pos).TypeApply(t, args));</span>


2159     }
2160 
2161     /**
2162      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2163      *
2164      * &lt;p&gt;
2165      *
2166      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2167      * the expression &lt;code&gt;t&lt;/code&gt;.
2168      */
2169     private JCExpression bracketsOpt(JCExpression t,
2170             List&lt;JCAnnotation&gt; annotations) {
2171         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2172 
2173         if (token.kind == LBRACKET) {
2174             int pos = token.pos;
2175             nextToken();
2176             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2177         } else if (!nextLevelAnnotations.isEmpty()) {
2178             if (permitTypeAnnotationsPushBack) {
</pre>
<hr />
<pre>
4179                     storeEnd(mods, pos);
4180                 }
4181                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4182 
4183                 if (annosAfterParams.nonEmpty()) {
4184                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4185                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4186                     if (mods.pos == Position.NOPOS)
4187                         mods.pos = mods.annotations.head.pos;
4188                 }
4189 
4190                 Token tk = token;
4191                 pos = token.pos;
4192                 JCExpression type;
4193                 boolean isVoid = token.kind == VOID;
4194                 if (isVoid) {
4195                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4196                     nextToken();
4197                 } else {
4198                     // method returns types are un-annotated types
<span class="line-modified">4199                     type = unannotatedType(false);</span>
4200                 }
4201                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4202                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4203                     if (isInterface || tk.name() != className)
4204                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4205                     else if (annosAfterParams.nonEmpty())
4206                         illegal(annosAfterParams.head.pos);
4207                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4208                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4209                     }
4210                     return List.of(methodDeclaratorRest(
4211                         pos, mods, null, names.init, typarams,
4212                         isInterface, true, isRecord, dc));
4213                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4214                     // trying to define a compact constructor with a throws clause
4215                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4216                             Errors.InvalidCanonicalConstructorInRecord(
4217                                     Fragments.Compact,
4218                                     className,
4219                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
</pre>
</td>
</tr>
</table>
<center><a href="../jvm/TransValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
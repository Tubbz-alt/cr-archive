<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.jvm.Target;
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
  74  * &lt;dt&gt;t&lt;/dt&gt;
  75  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  76  * &lt;dt&gt;s&lt;/dt&gt;
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
<a name="1" id="anc1"></a><span class="line-removed">  98     final boolean nonCovariantValueArrays;</span>
  99     final boolean injectTopInterfaceTypes;
 100     final Check chk;
 101     final Enter enter;
 102     JCDiagnostic.Factory diags;
 103     List&lt;Warner&gt; warnStack = List.nil();
 104     final Name capturedName;
 105 
 106     public final Warner noWarnings;
 107 
 108     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 109     public static Types instance(Context context) {
 110         Types instance = context.get(typesKey);
 111         if (instance == null)
 112             instance = new Types(context);
 113         return instance;
 114     }
 115 
 116     protected Types(Context context) {
 117         context.put(typesKey, this);
 118         syms = Symtab.instance(context);
 119         names = Names.instance(context);
 120         Source source = Source.instance(context);
 121         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 122         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 123         chk = Check.instance(context);
 124         enter = Enter.instance(context);
 125         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 126         messages = JavacMessages.instance(context);
 127         diags = JCDiagnostic.Factory.instance(context);
 128         noWarnings = new Warner(null);
 129         Options options = Options.instance(context);
 130         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
<a name="2" id="anc2"></a><span class="line-removed"> 131         nonCovariantValueArrays = options.isSet(&quot;nonCovariantValueArrays&quot;);</span>
 132         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
 133                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
 134                 Target.instance(context).hasTopInterfaces();
 135     }
 136     // &lt;/editor-fold&gt;
 137 
 138     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 139     /**
 140      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 141      * @param t a type argument, either a wildcard or a type
 142      */
 143     public Type wildUpperBound(Type t) {
 144         if (t.hasTag(WILDCARD)) {
 145             WildcardType w = (WildcardType) t;
 146             if (w.isSuperBound())
 147                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 148             else
 149                 return wildUpperBound(w.type);
 150         }
 151         else return t;
 152     }
 153 
 154     /**
 155      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 156      * @param t a type
 157      */
 158     public Type cvarUpperBound(Type t) {
 159         if (t.hasTag(TYPEVAR)) {
 160             TypeVar v = (TypeVar) t;
 161             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 162         }
 163         else return t;
 164     }
 165 
 166     /**
 167      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 168      * @param t a type argument, either a wildcard or a type
 169      */
 170     public Type wildLowerBound(Type t) {
 171         if (t.hasTag(WILDCARD)) {
 172             WildcardType w = (WildcardType) t;
 173             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 174         }
 175         else return t;
 176     }
 177 
 178     /**
 179      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 180      * @param t a type
 181      */
 182     public Type cvarLowerBound(Type t) {
 183         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 184             return cvarLowerBound(t.getLowerBound());
 185         }
 186         else return t;
 187     }
 188 
 189     /**
 190      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 191      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 192      * suitable for a method lookup.
 193      */
 194     public Type skipTypeVars(Type site, boolean capture) {
 195         while (site.hasTag(TYPEVAR)) {
 196             site = site.getUpperBound();
 197         }
 198         return capture ? capture(site) : site;
 199     }
 200     // &lt;/editor-fold&gt;
 201 
 202     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 203 
 204     /**
 205      * A projection kind. See {@link TypeProjection}
 206      */
 207     enum ProjectionKind {
 208         UPWARDS() {
 209             @Override
 210             ProjectionKind complement() {
 211                 return DOWNWARDS;
 212             }
 213         },
 214         DOWNWARDS() {
 215             @Override
 216             ProjectionKind complement() {
 217                 return UPWARDS;
 218             }
 219         };
 220 
 221         abstract ProjectionKind complement();
 222     }
 223 
 224     /**
 225      * This visitor performs upwards and downwards projections on types.
 226      *
 227      * A projection is defined as a function that takes a type T, a set of type variables V and that
 228      * produces another type S.
 229      *
 230      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 231      * and (ii) S is an upper bound of T.
 232      *
 233      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 234      * and (ii) S is a lower bound of T.
 235      *
 236      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 237      * a projection to leave its input type unchanged if it does not contain any variables in V.
 238      *
 239      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 240      * a downwards projection is not always defined.
 241      *
 242      * Examples:
 243      *
 244      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 245      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 246      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 247      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 248      */
 249     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 250 
 251         List&lt;Type&gt; vars;
 252         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 253 
 254         public TypeProjection(List&lt;Type&gt; vars) {
 255             this.vars = vars;
 256         }
 257 
 258         @Override
 259         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 260             if (t.isCompound()) {
 261                 List&lt;Type&gt; components = directSupertypes(t);
 262                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 263                 if (components == components1) return t;
 264                 else return makeIntersectionType(components1);
 265             } else {
 266                 Type outer = t.getEnclosingType();
 267                 Type outer1 = visit(outer, pkind);
 268                 List&lt;Type&gt; typarams = t.getTypeArguments();
 269                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 270                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 271                 boolean changed = false;
 272                 for (Type actual : typarams) {
 273                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 274                     if (t2.hasTag(BOT)) {
 275                         //not defined
 276                         return syms.botType;
 277                     }
 278                     typarams1.add(t2);
 279                     changed |= actual != t2;
 280                     formals = formals.tail;
 281                 }
 282                 if (outer1 == outer &amp;&amp; !changed) return t;
 283                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 284                     @Override
 285                     protected boolean needsStripping() {
 286                         return true;
 287                     }
 288                 };
 289             }
 290         }
 291 
 292         @Override
 293         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 294             Type elemtype = t.elemtype;
 295             Type elemtype1 = visit(elemtype, s);
 296             if (elemtype1 == elemtype) {
 297                 return t;
 298             } else if (elemtype1.hasTag(BOT)) {
 299                 //undefined
 300                 return syms.botType;
 301             } else {
 302                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 303                     @Override
 304                     protected boolean needsStripping() {
 305                         return true;
 306                     }
 307                 };
 308             }
 309         }
 310 
 311         @Override
 312         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 313             if (vars.contains(t)) {
 314                 if (seen.add(t)) {
 315                     try {
 316                         final Type bound;
 317                         switch (pkind) {
 318                             case UPWARDS:
 319                                 bound = t.getUpperBound();
 320                                 break;
 321                             case DOWNWARDS:
 322                                 bound = (t.getLowerBound() == null) ?
 323                                         syms.botType :
 324                                         t.getLowerBound();
 325                                 break;
 326                             default:
 327                                 Assert.error();
 328                                 return null;
 329                         }
 330                         return bound.map(this, pkind);
 331                     } finally {
 332                         seen.remove(t);
 333                     }
 334                 } else {
 335                     //cycle
 336                     return pkind == ProjectionKind.UPWARDS ?
 337                             syms.objectType : syms.botType;
 338                 }
 339             } else {
 340                 return t;
 341             }
 342         }
 343 
 344         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 345             return t.containsAny(vars) ?
 346                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 347                     t;
 348         }
 349 
 350         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 351 
 352             Type site;
 353             Type declaredBound;
 354 
 355             TypeArgumentProjection(Type site, Type declaredBound) {
 356                 this.site = site;
 357                 this.declaredBound = declaredBound;
 358             }
 359 
 360             @Override
 361             public Type visitType(Type t, ProjectionKind pkind) {
 362                 //type argument is some type containing restricted vars
 363                 if (pkind == ProjectionKind.DOWNWARDS) {
 364                     //not defined
 365                     return syms.botType;
 366                 }
 367                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 368                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 369                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 370                 BoundKind bk;
 371                 Type bound;
 372                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 373                         (declaredBound.containsAny(formals) ||
 374                          !isSubtype(declaredBound, upper))) {
 375                     bound = upper;
 376                     bk = EXTENDS;
 377                 } else if (!lower.hasTag(BOT)) {
 378                     bound = lower;
 379                     bk = SUPER;
 380                 } else {
 381                     bound = syms.objectType;
 382                     bk = UNBOUND;
 383                 }
 384                 return makeWildcard(bound, bk);
 385             }
 386 
 387             @Override
 388             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 389                 //type argument is some wildcard whose bound contains restricted vars
 390                 Type bound = syms.botType;
 391                 BoundKind bk = wt.kind;
 392                 switch (wt.kind) {
 393                     case EXTENDS:
 394                         bound = wt.type.map(TypeProjection.this, pkind);
 395                         if (bound.hasTag(BOT)) {
 396                             return syms.botType;
 397                         }
 398                         break;
 399                     case SUPER:
 400                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 401                         if (bound.hasTag(BOT)) {
 402                             bound = syms.objectType;
 403                             bk = UNBOUND;
 404                         }
 405                         break;
 406                 }
 407                 return makeWildcard(bound, bk);
 408             }
 409 
 410             private Type makeWildcard(Type bound, BoundKind bk) {
 411                 return new WildcardType(bound, bk, syms.boundClass) {
 412                     @Override
 413                     protected boolean needsStripping() {
 414                         return true;
 415                     }
 416                 };
 417             }
 418         }
 419     }
 420 
 421     /**
 422      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 423      *
 424      * @param t the type to be projected
 425      * @param vars the set of type variables to be mapped
 426      * @return the type obtained as result of the projection
 427      */
 428     public Type upward(Type t, List&lt;Type&gt; vars) {
 429         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 430     }
 431 
 432     /**
 433      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 434      * This routine is typically used to computed the input set of variables to be used during
 435      * an upwards projection (see {@link Types#upward(Type, List)}).
 436      *
 437      * @param t the type where occurrences of captured variables have to be found
 438      * @return the set of captured variables found in t
 439      */
 440     public List&lt;Type&gt; captures(Type t) {
 441         CaptureScanner cs = new CaptureScanner();
 442         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 443         cs.visit(t, captures);
 444         return List.from(captures);
 445     }
 446 
 447     /**
 448      * This visitor scans a type recursively looking for occurrences of captured type variables.
 449      */
 450     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 451 
 452         @Override
 453         public Void visitType(Type t, Set&lt;Type&gt; types) {
 454             return null;
 455         }
 456 
 457         @Override
 458         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 459             if (t.isCompound()) {
 460                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 461             } else {
 462                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 463             }
 464             return null;
 465         }
 466 
 467         @Override
 468         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 469             return visit(t.elemtype, seen);
 470         }
 471 
 472         @Override
 473         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 474             visit(t.type, seen);
 475             return null;
 476         }
 477 
 478         @Override
 479         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 480             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 481                 visit(t.getUpperBound(), seen);
 482             }
 483             return null;
 484         }
 485 
 486         @Override
 487         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 488             if (seen.add(t)) {
 489                 visit(t.getUpperBound(), seen);
 490                 visit(t.getLowerBound(), seen);
 491             }
 492             return null;
 493         }
 494     }
 495 
 496     // &lt;/editor-fold&gt;
 497 
 498     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 499     /**
 500      * Checks that all the arguments to a class are unbounded
 501      * wildcards or something else that doesn&#39;t make any restrictions
 502      * on the arguments. If a class isUnbounded, a raw super- or
 503      * subclass can be cast to it without a warning.
 504      * @param t a type
 505      * @return true iff the given type is unbounded or raw
 506      */
 507     public boolean isUnbounded(Type t) {
 508         return isUnbounded.visit(t);
 509     }
 510     // where
 511         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 512 
 513             public Boolean visitType(Type t, Void ignored) {
 514                 return true;
 515             }
 516 
 517             @Override
 518             public Boolean visitClassType(ClassType t, Void ignored) {
 519                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 520                 List&lt;Type&gt; args = t.allparams();
 521                 while (parms.nonEmpty()) {
 522                     WildcardType unb = new WildcardType(syms.objectType,
 523                                                         BoundKind.UNBOUND,
 524                                                         syms.boundClass,
 525                                                         (TypeVar)parms.head);
 526                     if (!containsType(args.head, unb))
 527                         return false;
 528                     parms = parms.tail;
 529                     args = args.tail;
 530                 }
 531                 return true;
 532             }
 533         };
 534     // &lt;/editor-fold&gt;
 535 
 536     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 537     /**
 538      * Return the least specific subtype of t that starts with symbol
 539      * sym.  If none exists, return null.  The least specific subtype
 540      * is determined as follows:
 541      *
 542      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 543      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 544      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 545      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 546      * returned.
 547      */
 548     public Type asSub(Type t, Symbol sym) {
 549         return asSub.visit(t, sym);
 550     }
 551     // where
 552         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 553 
 554             public Type visitType(Type t, Symbol sym) {
 555                 return null;
 556             }
 557 
 558             @Override
 559             public Type visitClassType(ClassType t, Symbol sym) {
 560                 if (t.tsym == sym)
 561                     return t;
 562                 Type base = asSuper(sym.type, t.tsym);
 563                 if (base == null)
 564                     return null;
 565                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 566                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 567                 try {
 568                     adapt(base, t, from, to);
 569                 } catch (AdaptFailure ex) {
 570                     return null;
 571                 }
 572                 Type res = subst(sym.type, from.toList(), to.toList());
 573                 if (!isSubtype(res, t))
 574                     return null;
 575                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 576                 for (List&lt;Type&gt; l = sym.type.allparams();
 577                      l.nonEmpty(); l = l.tail)
 578                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 579                         openVars.append(l.head);
 580                 if (openVars.nonEmpty()) {
 581                     if (t.isRaw()) {
 582                         // The subtype of a raw type is raw
 583                         res = erasure(res);
 584                     } else {
 585                         // Unbound type arguments default to ?
 586                         List&lt;Type&gt; opens = openVars.toList();
 587                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 588                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 589                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 590                                                        syms.boundClass, (TypeVar) iter.head));
 591                         }
 592                         res = subst(res, opens, qs.toList());
 593                     }
 594                 }
 595                 return res;
 596             }
 597 
 598             @Override
 599             public Type visitErrorType(ErrorType t, Symbol sym) {
 600                 return t;
 601             }
 602         };
 603     // &lt;/editor-fold&gt;
 604 
 605     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 606     /**
 607      * Is t a subtype of or convertible via boxing/unboxing
 608      * conversion to s?
 609      */
 610     public boolean isConvertible(Type t, Type s, Warner warn) {
 611         if (t.hasTag(ERROR)) {
 612             return true;
 613         }
 614 
<a name="3" id="anc3"></a>







 615         boolean tPrimitive = t.isPrimitive();
 616         boolean sPrimitive = s.isPrimitive();
 617         if (tPrimitive == sPrimitive) {
 618             return isSubtypeUnchecked(t, s, warn);
 619         }
 620         boolean tUndet = t.hasTag(UNDETVAR);
 621         boolean sUndet = s.hasTag(UNDETVAR);
 622 
 623         if (tUndet || sUndet) {
 624             return tUndet ?
 625                     isSubtype(t, boxedTypeOrType(s)) :
 626                     isSubtype(boxedTypeOrType(t), s);
 627         }
 628 
 629         return tPrimitive
 630             ? isSubtype(boxedClass(t).type, s)
 631             : isSubtype(unboxedType(t), s);
 632     }
 633 
 634     /**
 635      * Is t a subtype of or convertible via boxing/unboxing
 636      * conversions to s?
 637      */
 638     public boolean isConvertible(Type t, Type s) {
 639         return isConvertible(t, s, noWarnings);
 640     }
 641     // &lt;/editor-fold&gt;
 642 
 643     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 644 
 645     /**
 646      * Exception used to report a function descriptor lookup failure. The exception
 647      * wraps a diagnostic that can be used to generate more details error
 648      * messages.
 649      */
 650     public static class FunctionDescriptorLookupError extends RuntimeException {
 651         private static final long serialVersionUID = 0;
 652 
 653         transient JCDiagnostic diagnostic;
 654 
 655         FunctionDescriptorLookupError() {
 656             this.diagnostic = null;
 657         }
 658 
 659         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 660             this.diagnostic = diag;
 661             return this;
 662         }
 663 
 664         public JCDiagnostic getDiagnostic() {
 665             return diagnostic;
 666         }
 667     }
 668 
 669     /**
 670      * A cache that keeps track of function descriptors associated with given
 671      * functional interfaces.
 672      */
 673     class DescriptorCache {
 674 
 675         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 676 
 677         class FunctionDescriptor {
 678             Symbol descSym;
 679 
 680             FunctionDescriptor(Symbol descSym) {
 681                 this.descSym = descSym;
 682             }
 683 
 684             public Symbol getSymbol() {
 685                 return descSym;
 686             }
 687 
 688             public Type getType(Type site) {
 689                 site = removeWildcards(site);
 690                 if (site.isIntersection()) {
 691                     IntersectionClassType ict = (IntersectionClassType)site;
 692                     for (Type component : ict.getExplicitComponents()) {
 693                         if (!chk.checkValidGenericType(component)) {
 694                             //if the inferred functional interface type is not well-formed,
 695                             //or if it&#39;s not a subtype of the original target, issue an error
 696                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 697                         }
 698                     }
 699                 } else {
 700                     if (!chk.checkValidGenericType(site)) {
 701                         //if the inferred functional interface type is not well-formed,
 702                         //or if it&#39;s not a subtype of the original target, issue an error
 703                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 704                     }
 705                 }
 706                 return memberType(site, descSym);
 707             }
 708         }
 709 
 710         class Entry {
 711             final FunctionDescriptor cachedDescRes;
 712             final int prevMark;
 713 
 714             public Entry(FunctionDescriptor cachedDescRes,
 715                     int prevMark) {
 716                 this.cachedDescRes = cachedDescRes;
 717                 this.prevMark = prevMark;
 718             }
 719 
 720             boolean matches(int mark) {
 721                 return  this.prevMark == mark;
 722             }
 723         }
 724 
 725         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 726             Entry e = _map.get(origin);
 727             CompoundScope members = membersClosure(origin.type, false);
 728             if (e == null ||
 729                     !e.matches(members.getMark())) {
 730                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 731                 _map.put(origin, new Entry(descRes, members.getMark()));
 732                 return descRes;
 733             }
 734             else {
 735                 return e.cachedDescRes;
 736             }
 737         }
 738 
 739         /**
 740          * Compute the function descriptor associated with a given functional interface
 741          */
 742         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 743                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 744             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0) {
 745                 //t must be an interface
 746                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 747             }
 748 
 749             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 750             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 751                 Type mtype = memberType(origin.type, sym);
 752                 if (abstracts.isEmpty()) {
 753                     abstracts.append(sym);
 754                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 755                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 756                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 757                             .map(msym -&gt; memberType(origin.type, msym))
 758                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 759                         abstracts.append(sym);
 760                     }
 761                 } else {
 762                     //the target method(s) should be the only abstract members of t
 763                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 764                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 765                 }
 766             }
 767             if (abstracts.isEmpty()) {
 768                 //t must define a suitable non-generic method
 769                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 770                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 771             } else if (abstracts.size() == 1) {
 772                 return new FunctionDescriptor(abstracts.first());
 773             } else { // size &gt; 1
 774                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 775                 if (descRes == null) {
 776                     //we can get here if the functional interface is ill-formed
 777                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 778                     for (Symbol desc : abstracts) {
 779                         String key = desc.type.getThrownTypes().nonEmpty() ?
 780                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 781                         descriptors.append(diags.fragment(key, desc.name,
 782                                 desc.type.getParameterTypes(),
 783                                 desc.type.getReturnType(),
 784                                 desc.type.getThrownTypes()));
 785                     }
 786                     JCDiagnostic msg =
 787                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 788                                                                                        origin));
 789                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 790                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 791                     throw failure(incompatibleDescriptors);
 792                 }
 793                 return descRes;
 794             }
 795         }
 796 
 797         /**
 798          * Compute a synthetic type for the target descriptor given a list
 799          * of override-equivalent methods in the functional interface type.
 800          * The resulting method type is a method type that is override-equivalent
 801          * and return-type substitutable with each method in the original list.
 802          */
 803         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 804             return mergeAbstracts(methodSyms, origin.type, false)
 805                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 806                         @Override
 807                         public Type getType(Type origin) {
 808                             Type mt = memberType(origin, getSymbol());
 809                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 810                         }
 811                     }).orElse(null);
 812         }
 813 
 814         FunctionDescriptorLookupError failure(String msg, Object... args) {
 815             return failure(diags.fragment(msg, args));
 816         }
 817 
 818         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 819             return new FunctionDescriptorLookupError().setMessage(diag);
 820         }
 821     }
 822 
 823     private DescriptorCache descCache = new DescriptorCache();
 824 
 825     /**
 826      * Find the method descriptor associated to this class symbol - if the
 827      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 828      */
 829     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 830         return descCache.get(origin).getSymbol();
 831     }
 832 
 833     /**
 834      * Find the type of the method descriptor associated to this class symbol -
 835      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 836      */
 837     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 838         return descCache.get(origin.tsym).getType(origin);
 839     }
 840 
 841     /**
 842      * Is given type a functional interface?
 843      */
 844     public boolean isFunctionalInterface(TypeSymbol tsym) {
 845         try {
 846             findDescriptorSymbol(tsym);
 847             return true;
 848         } catch (FunctionDescriptorLookupError ex) {
 849             return false;
 850         }
 851     }
 852 
 853     public boolean isFunctionalInterface(Type site) {
 854         try {
 855             findDescriptorType(site);
 856             return true;
 857         } catch (FunctionDescriptorLookupError ex) {
 858             return false;
 859         }
 860     }
 861 
 862     public Type removeWildcards(Type site) {
 863         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 864             //compute non-wildcard parameterization - JLS 9.9
 865             List&lt;Type&gt; actuals = site.getTypeArguments();
 866             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 867             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 868             for (Type formal : formals) {
 869                 Type actual = actuals.head;
 870                 Type bound = formal.getUpperBound();
 871                 if (actuals.head.hasTag(WILDCARD)) {
 872                     WildcardType wt = (WildcardType)actual;
 873                     //check that bound does not contain other formals
 874                     if (bound.containsAny(formals)) {
 875                         targs.add(wt.type);
 876                     } else {
 877                         //compute new type-argument based on declared bound and wildcard bound
 878                         switch (wt.kind) {
 879                             case UNBOUND:
 880                                 targs.add(bound);
 881                                 break;
 882                             case EXTENDS:
 883                                 targs.add(glb(bound, wt.type));
 884                                 break;
 885                             case SUPER:
 886                                 targs.add(wt.type);
 887                                 break;
 888                             default:
 889                                 Assert.error(&quot;Cannot get here!&quot;);
 890                         }
 891                     }
 892                 } else {
 893                     //not a wildcard - the new type argument remains unchanged
 894                     targs.add(actual);
 895                 }
 896                 actuals = actuals.tail;
 897             }
 898             return subst(site.tsym.type, formals, targs.toList());
 899         } else {
 900             return site;
 901         }
 902     }
 903 
 904     /**
 905      * Create a symbol for a class that implements a given functional interface
 906      * and overrides its functional descriptor. This routine is used for two
 907      * main purposes: (i) checking well-formedness of a functional interface;
 908      * (ii) perform functional interface bridge calculation.
 909      */
 910     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 911         if (target == null || target == syms.unknownType) {
 912             return null;
 913         }
 914         Symbol descSym = findDescriptorSymbol(target.tsym);
 915         Type descType = findDescriptorType(target);
 916         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 917         csym.completer = Completer.NULL_COMPLETER;
 918         csym.members_field = WriteableScope.create(csym);
 919         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 920         csym.members_field.enter(instDescSym);
 921         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 922         ctype.supertype_field = syms.objectType;
 923         ctype.interfaces_field = target.isIntersection() ?
 924                 directSupertypes(target) :
 925                 List.of(target);
 926         csym.type = ctype;
 927         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 928         return csym;
 929     }
 930 
 931     /**
 932      * Find the minimal set of methods that are overridden by the functional
 933      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 934      * erased signatures.
 935      */
 936     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 937         Assert.check(isFunctionalInterface(origin));
 938         Symbol descSym = findDescriptorSymbol(origin);
 939         CompoundScope members = membersClosure(origin.type, false);
 940         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 941         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 942             if (m2 == descSym) continue;
 943             else if (descSym.overrides(m2, origin, Types.this, false)) {
 944                 for (Symbol m3 : overridden) {
 945                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 946                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 947                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 948                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 949                         continue outer;
 950                     }
 951                 }
 952                 overridden.add(m2);
 953             }
 954         }
 955         return overridden.toList();
 956     }
 957     //where
 958         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 959             public boolean accepts(Symbol t) {
 960                 return t.kind == MTH &amp;&amp;
 961                         t.name != names.init &amp;&amp;
 962                         t.name != names.clinit &amp;&amp;
 963                         (t.flags() &amp; SYNTHETIC) == 0;
 964             }
 965         };
 966         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 967             //a symbol will be completed from a classfile if (a) symbol has
 968             //an associated file object with CLASS kind and (b) the symbol has
 969             //not been entered
 970             if (origin.classfile != null &amp;&amp;
 971                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 972                     enter.getEnv(origin) == null) {
 973                 return false;
 974             }
 975             if (origin == s) {
 976                 return true;
 977             }
 978             for (Type t : interfaces(origin.type)) {
 979                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 980                     return true;
 981                 }
 982             }
 983             return false;
 984         }
 985     // &lt;/editor-fold&gt;
 986 
 987    /**
 988     * Scope filter used to skip methods that should be ignored (such as methods
 989     * overridden by j.l.Object) during function interface conversion interface check
 990     */
 991     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 992 
 993        TypeSymbol origin;
 994 
 995        DescriptorFilter(TypeSymbol origin) {
 996            this.origin = origin;
 997        }
 998 
 999        @Override
1000        public boolean accepts(Symbol sym) {
1001            return sym.kind == MTH &amp;&amp;
1002                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1003                    !overridesObjectMethod(origin, sym) &amp;&amp;
1004                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1005        }
1006     }
1007 
1008     public boolean isValue(Type t) {
1009         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1010     }
1011 
1012     public boolean isValueBased(Type t) {
1013         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1014     }
1015 
<a name="4" id="anc4"></a><span class="line-removed">1016     private final HashMap&lt;ClassSymbol, ClassSymbol&gt; nullableProjectionsMap = new HashMap&lt;&gt;();</span>
<span class="line-removed">1017 </span>
<span class="line-removed">1018     public ClassSymbol projectedNullableType(ClassSymbol c) {</span>
<span class="line-removed">1019         if (!c.isValue() || !c.type.hasTag(CLASS))</span>
<span class="line-removed">1020             return null;</span>
<span class="line-removed">1021         ClassSymbol lox = nullableProjectionsMap.get(c);</span>
<span class="line-removed">1022         if (lox != null)</span>
<span class="line-removed">1023             return lox;</span>
<span class="line-removed">1024 </span>
<span class="line-removed">1025         ClassType ct = (ClassType) c.type;</span>
<span class="line-removed">1026         ClassType loxType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-removed">1027         loxType.allparams_field = ct.allparams_field;</span>
<span class="line-removed">1028         loxType.supertype_field = ct.supertype_field;</span>
<span class="line-removed">1029         loxType.interfaces_field = List.nil();</span>
<span class="line-removed">1030         for (Type t :ct.interfaces_field) {</span>
<span class="line-removed">1031             if (t.tsym == syms.inlineObjectType.tsym) {</span>
<span class="line-removed">1032                 loxType.interfaces_field  = loxType.interfaces_field.append(syms.identityObjectType);</span>
<span class="line-removed">1033             } else {</span>
<span class="line-removed">1034                 loxType.interfaces_field  = loxType.interfaces_field.append(t);</span>
<span class="line-removed">1035             }</span>
<span class="line-removed">1036         }</span>
<span class="line-removed">1037         loxType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-removed">1038         lox = new ClassSymbol((c.flags() &amp; ~VALUE), c.name, loxType, c.owner) {</span>
<span class="line-removed">1039             @Override</span>
<span class="line-removed">1040             public boolean isProjectedNullable() {</span>
<span class="line-removed">1041                 return true;</span>
<span class="line-removed">1042             }</span>
<span class="line-removed">1043 </span>
<span class="line-removed">1044             @Override</span>
<span class="line-removed">1045             public ClassSymbol nullFreeTypeSymbol() {</span>
<span class="line-removed">1046                 return c;</span>
<span class="line-removed">1047             }</span>
<span class="line-removed">1048         };</span>
<span class="line-removed">1049         lox.members_field = c.members();</span>
<span class="line-removed">1050         loxType.tsym = lox;</span>
<span class="line-removed">1051 </span>
<span class="line-removed">1052         nullableProjectionsMap.put(c, lox);</span>
<span class="line-removed">1053         return lox;</span>
<span class="line-removed">1054     }</span>
<span class="line-removed">1055 </span>
1056     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1057     /**
1058      * Is t an unchecked subtype of s?
1059      */
1060     public boolean isSubtypeUnchecked(Type t, Type s) {
1061         return isSubtypeUnchecked(t, s, noWarnings);
1062     }
1063     /**
1064      * Is t an unchecked subtype of s?
1065      */
1066     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1067         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1068         if (result) {
1069             checkUnsafeVarargsConversion(t, s, warn);
1070         }
1071         return result;
1072     }
1073     //where
1074         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1075             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1076                 if (((ArrayType)t).elemtype.isPrimitive()) {
1077                     return isSameType(elemtype(t), elemtype(s));
1078                 } else {
<a name="5" id="anc5"></a><span class="line-modified">1079                     Type et = elemtype(t);</span>
1080                     Type es = elemtype(s);
<a name="6" id="anc6"></a>





1081                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1082                         return false;
<a name="7" id="anc7"></a><span class="line-removed">1083                     if (nonCovariantValueArrays) {</span>
<span class="line-removed">1084                         if (isValue(et) || isValue(es)) {</span>
<span class="line-removed">1085                             return isSameType(erasure(et), erasure(es));</span>
<span class="line-removed">1086                         }</span>
<span class="line-removed">1087                     }</span>
1088                     return true;
1089                 }
1090             } else if (isSubtype(t, s, capture)) {
1091                 return true;
1092             } else if (t.hasTag(TYPEVAR)) {
1093                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1094             } else if (!s.isRaw()) {
1095                 Type t2 = asSuper(t, s.tsym);
1096                 if (t2 != null &amp;&amp; t2.isRaw()) {
1097                     if (isReifiable(s)) {
1098                         warn.silentWarn(LintCategory.UNCHECKED);
1099                     } else {
1100                         warn.warn(LintCategory.UNCHECKED);
1101                     }
1102                     return true;
1103                 }
1104             }
1105             return false;
1106         }
1107 
1108         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1109             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1110                 return;
1111             }
1112             ArrayType from = (ArrayType)t;
1113             boolean shouldWarn = false;
1114             switch (s.getTag()) {
1115                 case ARRAY:
1116                     ArrayType to = (ArrayType)s;
1117                     shouldWarn = from.isVarargs() &amp;&amp;
1118                             !to.isVarargs() &amp;&amp;
1119                             !isReifiable(from);
1120                     break;
1121                 case CLASS:
1122                     shouldWarn = from.isVarargs();
1123                     break;
1124             }
1125             if (shouldWarn) {
1126                 warn.warn(LintCategory.VARARGS);
1127             }
1128         }
1129 
1130     /**
1131      * Is t a subtype of s?&lt;br&gt;
1132      * (not defined for Method and ForAll types)
1133      */
1134     final public boolean isSubtype(Type t, Type s) {
1135         return isSubtype(t, s, true);
1136     }
1137     final public boolean isSubtypeNoCapture(Type t, Type s) {
1138         return isSubtype(t, s, false);
1139     }
1140     public boolean isSubtype(Type t, Type s, boolean capture) {
1141         if (t.equalsIgnoreMetadata(s))
1142             return true;
1143         if (s.isPartial())
1144             return isSuperType(s, t);
1145 
1146         if (s.isCompound()) {
1147             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1148                 if (!isSubtype(t, s2, capture))
1149                     return false;
1150             }
1151             return true;
1152         }
1153 
1154         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1155         // for inference variables and intersections, we need to keep &#39;s&#39;
1156         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1157         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1158             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1159             Type lower = cvarLowerBound(wildLowerBound(s));
1160             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1161                 return isSubtype(capture ? capture(t) : t, lower, false);
1162         }
1163 
1164         return isSubtype.visit(capture ? capture(t) : t, s);
1165     }
1166     // where
1167         private TypeRelation isSubtype = new TypeRelation()
1168         {
1169             @Override
1170             public Boolean visitType(Type t, Type s) {
1171                 switch (t.getTag()) {
1172                  case BYTE:
1173                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1174                  case CHAR:
1175                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1176                  case SHORT: case INT: case LONG:
1177                  case FLOAT: case DOUBLE:
1178                      return t.getTag().isSubRangeOf(s.getTag());
1179                  case BOOLEAN: case VOID:
1180                      return t.hasTag(s.getTag());
1181                  case TYPEVAR:
1182                      return isSubtypeNoCapture(t.getUpperBound(), s);
1183                  case BOT:
1184                      return
1185                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||
1186                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1187                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1188                  case NONE:
1189                      return false;
1190                  default:
1191                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1192                  }
1193             }
1194 
1195             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1196 
1197             private boolean containsTypeRecursive(Type t, Type s) {
1198                 TypePair pair = new TypePair(t, s);
1199                 if (cache.add(pair)) {
1200                     try {
1201                         return containsType(t.getTypeArguments(),
1202                                             s.getTypeArguments());
1203                     } finally {
1204                         cache.remove(pair);
1205                     }
1206                 } else {
1207                     return containsType(t.getTypeArguments(),
1208                                         rewriteSupers(s).getTypeArguments());
1209                 }
1210             }
1211 
1212             private Type rewriteSupers(Type t) {
1213                 if (!t.isParameterized())
1214                     return t;
1215                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1216                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1217                 adaptSelf(t, from, to);
1218                 if (from.isEmpty())
1219                     return t;
1220                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1221                 boolean changed = false;
1222                 for (Type orig : to.toList()) {
1223                     Type s = rewriteSupers(orig);
1224                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1225                         s = new WildcardType(syms.objectType,
1226                                              BoundKind.UNBOUND,
1227                                              syms.boundClass,
1228                                              s.getMetadata());
1229                         changed = true;
1230                     } else if (s != orig) {
1231                         s = new WildcardType(wildUpperBound(s),
1232                                              BoundKind.EXTENDS,
1233                                              syms.boundClass,
1234                                              s.getMetadata());
1235                         changed = true;
1236                     }
1237                     rewrite.append(s);
1238                 }
1239                 if (changed)
1240                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1241                 else
1242                     return t;
1243             }
1244 
1245             @Override
1246             public Boolean visitClassType(ClassType t, Type s) {
1247                 Type sup = asSuper(t, s.tsym);
1248                 if (sup == null) return false;
1249                 // If t is an intersection, sup might not be a class type
1250                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1251                 return sup.tsym == s.tsym
1252                      // Check type variable containment
1253                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1254                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1255                                           s.getEnclosingType());
1256             }
1257 
1258             @Override
1259             public Boolean visitArrayType(ArrayType t, Type s) {
1260                 if (s.hasTag(ARRAY)) {
1261                     if (t.elemtype.isPrimitive())
1262                         return isSameType(t.elemtype, elemtype(s));
<a name="8" id="anc8"></a><span class="line-modified">1263                     else</span>
<span class="line-modified">1264                         return isSubtypeNoCapture(t.elemtype, elemtype(s));</span>









1265                 }
1266 
1267                 if (s.hasTag(CLASS)) {
1268                     Name sname = s.tsym.getQualifiedName();
1269                     return sname == names.java_lang_Object
1270                         || sname == names.java_lang_Cloneable
1271                         || sname == names.java_io_Serializable
1272                         || (injectTopInterfaceTypes &amp;&amp; sname == names.java_lang_IdentityObject);
1273                 }
1274 
1275                 return false;
1276             }
1277 
1278             @Override
1279             public Boolean visitUndetVar(UndetVar t, Type s) {
1280                 //todo: test against origin needed? or replace with substitution?
1281                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1282                     return true;
1283                 } else if (s.hasTag(BOT)) {
1284                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1285                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1286                     return false;
1287                 }
1288 
1289                 t.addBound(InferenceBound.UPPER, s, Types.this);
1290                 return true;
1291             }
1292 
1293             @Override
1294             public Boolean visitErrorType(ErrorType t, Type s) {
1295                 return true;
1296             }
1297         };
1298 
1299     /**
1300      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1301      * (not defined for Method and ForAll types)&lt;br&gt;
1302      * Allows unchecked conversions.
1303      */
1304     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1305         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1306             if (!isSubtypeUnchecked(t, l.head, warn))
1307                 return false;
1308         return true;
1309     }
1310 
1311     /**
1312      * Are corresponding elements of ts subtypes of ss?  If lists are
1313      * of different length, return false.
1314      */
1315     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1316         while (ts.tail != null &amp;&amp; ss.tail != null
1317                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1318                isSubtype(ts.head, ss.head)) {
1319             ts = ts.tail;
1320             ss = ss.tail;
1321         }
1322         return ts.tail == null &amp;&amp; ss.tail == null;
1323         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1324     }
1325 
1326     /**
1327      * Are corresponding elements of ts subtypes of ss, allowing
1328      * unchecked conversions?  If lists are of different length,
1329      * return false.
1330      **/
1331     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1332         while (ts.tail != null &amp;&amp; ss.tail != null
1333                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1334                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1335             ts = ts.tail;
1336             ss = ss.tail;
1337         }
1338         return ts.tail == null &amp;&amp; ss.tail == null;
1339         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1340     }
1341     // &lt;/editor-fold&gt;
1342 
1343     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1344     /**
1345      * Is t a supertype of s?
1346      */
1347     public boolean isSuperType(Type t, Type s) {
1348         switch (t.getTag()) {
1349         case ERROR:
1350             return true;
1351         case UNDETVAR: {
1352             UndetVar undet = (UndetVar)t;
1353             if (t == s ||
1354                 undet.qtype == s ||
1355                 s.hasTag(ERROR) ||
1356                 s.hasTag(BOT)) {
1357                 return true;
1358             }
1359             undet.addBound(InferenceBound.LOWER, s, this);
1360             return true;
1361         }
1362         default:
1363             return isSubtype(s, t);
1364         }
1365     }
1366     // &lt;/editor-fold&gt;
1367 
1368     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1369     /**
1370      * Are corresponding elements of the lists the same type?  If
1371      * lists are of different length, return false.
1372      */
1373     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1374         while (ts.tail != null &amp;&amp; ss.tail != null
1375                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1376                isSameType(ts.head, ss.head)) {
1377             ts = ts.tail;
1378             ss = ss.tail;
1379         }
1380         return ts.tail == null &amp;&amp; ss.tail == null;
1381         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1382     }
1383 
1384     /**
1385      * A polymorphic signature method (JLS 15.12.3) is a method that
1386      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1387      *  (ii) takes a single variable arity parameter;
1388      * (iii) whose declared type is Object[];
1389      *  (iv) has any return type, Object signifying a polymorphic return type; and
1390      *   (v) is native.
1391     */
1392    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1393        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1394        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1395               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1396                argtypes.length() == 1 &amp;&amp;
1397                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1398                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1399    }
1400 
1401     /**
1402      * Is t the same type as s?
1403      */
1404     public boolean isSameType(Type t, Type s) {
1405         return isSameTypeVisitor.visit(t, s);
1406     }
1407     // where
1408 
1409         /**
1410          * Type-equality relation - type variables are considered
1411          * equals if they share the same object identity.
1412          */
1413         TypeRelation isSameTypeVisitor = new TypeRelation() {
1414 
1415             public Boolean visitType(Type t, Type s) {
1416                 if (t.equalsIgnoreMetadata(s))
1417                     return true;
1418 
1419                 if (s.isPartial())
1420                     return visit(s, t);
1421 
1422                 switch (t.getTag()) {
1423                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1424                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1425                     return t.hasTag(s.getTag());
1426                 case TYPEVAR: {
1427                     if (s.hasTag(TYPEVAR)) {
1428                         //type-substitution does not preserve type-var types
1429                         //check that type var symbols and bounds are indeed the same
1430                         return t == s;
1431                     }
1432                     else {
1433                         //special case for s == ? super X, where upper(s) = u
1434                         //check that u == t, where u has been set by Type.withTypeVar
1435                         return s.isSuperBound() &amp;&amp;
1436                                 !s.isExtendsBound() &amp;&amp;
1437                                 visit(t, wildUpperBound(s));
1438                     }
1439                 }
1440                 default:
1441                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1442                 }
1443             }
1444 
1445             @Override
1446             public Boolean visitWildcardType(WildcardType t, Type s) {
1447                 if (!s.hasTag(WILDCARD)) {
1448                     return false;
1449                 } else {
1450                     WildcardType t2 = (WildcardType)s;
1451                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1452                             isSameType(t.type, t2.type);
1453                 }
1454             }
1455 
1456             @Override
1457             public Boolean visitClassType(ClassType t, Type s) {
1458                 if (t == s)
1459                     return true;
1460 
1461                 if (s.isPartial())
1462                     return visit(s, t);
1463 
1464                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1465                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1466 
1467                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1468                     if (!visit(supertype(t), supertype(s)))
1469                         return false;
1470 
1471                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1472                     for (Type ti : interfaces(t)) {
1473                         if (tMap.containsKey(ti)) {
1474                             throw new AssertionError(&quot;Malformed intersection&quot;);
1475                         }
1476                         tMap.put(ti.tsym, ti);
1477                     }
1478                     for (Type si : interfaces(s)) {
1479                         if (!tMap.containsKey(si.tsym))
1480                             return false;
1481                         Type ti = tMap.remove(si.tsym);
1482                         if (!visit(ti, si))
1483                             return false;
1484                     }
1485                     return tMap.isEmpty();
1486                 }
1487                 return t.tsym == s.tsym
1488                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1489                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1490             }
1491 
1492             @Override
1493             public Boolean visitArrayType(ArrayType t, Type s) {
1494                 if (t == s)
1495                     return true;
1496 
1497                 if (s.isPartial())
1498                     return visit(s, t);
1499 
1500                 return s.hasTag(ARRAY)
1501                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1502             }
1503 
1504             @Override
1505             public Boolean visitMethodType(MethodType t, Type s) {
1506                 // isSameType for methods does not take thrown
1507                 // exceptions into account!
1508                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1509             }
1510 
1511             @Override
1512             public Boolean visitPackageType(PackageType t, Type s) {
1513                 return t == s;
1514             }
1515 
1516             @Override
1517             public Boolean visitForAll(ForAll t, Type s) {
1518                 if (!s.hasTag(FORALL)) {
1519                     return false;
1520                 }
1521 
1522                 ForAll forAll = (ForAll)s;
1523                 return hasSameBounds(t, forAll)
1524                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1525             }
1526 
1527             @Override
1528             public Boolean visitUndetVar(UndetVar t, Type s) {
1529                 if (s.hasTag(WILDCARD)) {
1530                     // FIXME, this might be leftovers from before capture conversion
1531                     return false;
1532                 }
1533 
1534                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1535                     return true;
1536                 }
1537 
1538                 t.addBound(InferenceBound.EQ, s, Types.this);
1539 
1540                 return true;
1541             }
1542 
1543             @Override
1544             public Boolean visitErrorType(ErrorType t, Type s) {
1545                 return true;
1546             }
1547         };
1548 
1549     // &lt;/editor-fold&gt;
1550 
1551     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1552     public boolean containedBy(Type t, Type s) {
1553         switch (t.getTag()) {
1554         case UNDETVAR:
1555             if (s.hasTag(WILDCARD)) {
1556                 UndetVar undetvar = (UndetVar)t;
1557                 WildcardType wt = (WildcardType)s;
1558                 switch(wt.kind) {
1559                     case UNBOUND:
1560                         break;
1561                     case EXTENDS: {
1562                         Type bound = wildUpperBound(s);
1563                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1564                         break;
1565                     }
1566                     case SUPER: {
1567                         Type bound = wildLowerBound(s);
1568                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1569                         break;
1570                     }
1571                 }
1572                 return true;
1573             } else {
1574                 return isSameType(t, s);
1575             }
1576         case ERROR:
1577             return true;
1578         default:
1579             return containsType(s, t);
1580         }
1581     }
1582 
1583     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1584         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1585                &amp;&amp; containsType(ts.head, ss.head)) {
1586             ts = ts.tail;
1587             ss = ss.tail;
1588         }
1589         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1590     }
1591 
1592     /**
1593      * Check if t contains s.
1594      *
1595      * &lt;p&gt;T contains S if:
1596      *
1597      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1598      *
1599      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1600      * is,
1601      *
1602      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1603      *
1604      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1605      * recursion.  Thus we must somehow break that recursion.  Notice
1606      * that containsType() is only called from ClassType.isSubtype().
1607      * Since the arguments have already been checked against their
1608      * bounds, we know:
1609      *
1610      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1611      *
1612      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1613      *
1614      * @param t a type
1615      * @param s a type
1616      */
1617     public boolean containsType(Type t, Type s) {
1618         return containsType.visit(t, s);
1619     }
1620     // where
1621         private TypeRelation containsType = new TypeRelation() {
1622 
1623             public Boolean visitType(Type t, Type s) {
1624                 if (s.isPartial())
1625                     return containedBy(s, t);
1626                 else
1627                     return isSameType(t, s);
1628             }
1629 
1630 //            void debugContainsType(WildcardType t, Type s) {
1631 //                System.err.println();
1632 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1633 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1634 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1635 //                                  t.isSuperBound()
1636 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1637 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1638 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1639 //                                  t.isExtendsBound()
1640 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1641 //                System.err.println();
1642 //            }
1643 
1644             @Override
1645             public Boolean visitWildcardType(WildcardType t, Type s) {
1646                 if (s.isPartial())
1647                     return containedBy(s, t);
1648                 else {
1649 //                    debugContainsType(t, s);
<a name="9" id="anc9"></a>








1650                     return isSameWildcard(t, s)
1651                         || isCaptureOf(s, t)
1652                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1653                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1654                 }
1655             }
1656 
1657             @Override
1658             public Boolean visitUndetVar(UndetVar t, Type s) {
1659                 if (!s.hasTag(WILDCARD)) {
1660                     return isSameType(t, s);
1661                 } else {
1662                     return false;
1663                 }
1664             }
1665 
1666             @Override
1667             public Boolean visitErrorType(ErrorType t, Type s) {
1668                 return true;
1669             }
1670         };
1671 
1672     public boolean isCaptureOf(Type s, WildcardType t) {
1673         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1674             return false;
1675         return isSameWildcard(t, ((CapturedType)s).wildcard);
1676     }
1677 
1678     public boolean isSameWildcard(WildcardType t, Type s) {
1679         if (!s.hasTag(WILDCARD))
1680             return false;
1681         WildcardType w = (WildcardType)s;
1682         return w.kind == t.kind &amp;&amp; w.type == t.type;
1683     }
1684 
1685     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1686         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1687                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1688             ts = ts.tail;
1689             ss = ss.tail;
1690         }
1691         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1692     }
1693     // &lt;/editor-fold&gt;
1694 
1695     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1696     public boolean isCastable(Type t, Type s) {
1697         return isCastable(t, s, noWarnings);
1698     }
1699 
1700     /**
1701      * Is t is castable to s?&lt;br&gt;
1702      * s is assumed to be an erased type.&lt;br&gt;
1703      * (not defined for Method and ForAll types).
1704      */
1705     public boolean isCastable(Type t, Type s, Warner warn) {
1706         if (t == s)
1707             return true;
1708         if (t.isPrimitive() != s.isPrimitive()) {
1709             t = skipTypeVars(t, false);
1710             return (isConvertible(t, s, warn)
1711                     || (s.isPrimitive() &amp;&amp;
1712                         isSubtype(boxedClass(s).type, t)));
1713         }
1714         if (warn != warnStack.head) {
1715             try {
1716                 warnStack = warnStack.prepend(warn);
1717                 checkUnsafeVarargsConversion(t, s, warn);
1718                 return isCastable.visit(t,s);
1719             } finally {
1720                 warnStack = warnStack.tail;
1721             }
1722         } else {
1723             return isCastable.visit(t,s);
1724         }
1725     }
1726     // where
1727         private TypeRelation isCastable = new TypeRelation() {
1728 
1729             public Boolean visitType(Type t, Type s) {
1730                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1731                     return true;
1732 
1733                 switch (t.getTag()) {
1734                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1735                 case DOUBLE:
1736                     return s.isNumeric();
1737                 case BOOLEAN:
1738                     return s.hasTag(BOOLEAN);
1739                 case VOID:
1740                     return false;
1741                 case BOT:
1742                     return isSubtype(t, s);
1743                 default:
1744                     throw new AssertionError();
1745                 }
1746             }
1747 
1748             @Override
1749             public Boolean visitWildcardType(WildcardType t, Type s) {
1750                 return isCastable(wildUpperBound(t), s, warnStack.head);
1751             }
1752 
1753             @Override
1754             public Boolean visitClassType(ClassType t, Type s) {
1755                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1756                     return true;
1757 
1758                 if (s.hasTag(TYPEVAR)) {
1759                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1760                         warnStack.head.warn(LintCategory.UNCHECKED);
1761                         return true;
1762                     } else {
1763                         return false;
1764                     }
1765                 }
1766 
1767                 if (t.isCompound() || s.isCompound()) {
1768                     return !t.isCompound() ?
1769                             visitCompoundType((ClassType)s, t, true) :
1770                             visitCompoundType(t, s, false);
1771                 }
1772 
1773                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
<a name="10" id="anc10"></a>







1774                     boolean upcast;
1775                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1776                         || isSubtype(erasure(s), erasure(t))) {
1777                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1778                             if (!isReifiable(s))
1779                                 warnStack.head.warn(LintCategory.UNCHECKED);
1780                             return true;
1781                         } else if (s.isRaw()) {
1782                             return true;
1783                         } else if (t.isRaw()) {
1784                             if (!isUnbounded(s))
1785                                 warnStack.head.warn(LintCategory.UNCHECKED);
1786                             return true;
1787                         }
1788                         // Assume |a| &lt;: |b|
1789                         final Type a = upcast ? t : s;
1790                         final Type b = upcast ? s : t;
1791                         final boolean HIGH = true;
1792                         final boolean LOW = false;
1793                         final boolean DONT_REWRITE_TYPEVARS = false;
1794                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1795                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1796                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1797                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1798                         Type lowSub = asSub(bLow, aLow.tsym);
1799                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1800                         if (highSub == null) {
1801                             final boolean REWRITE_TYPEVARS = true;
1802                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1803                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1804                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1805                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1806                             lowSub = asSub(bLow, aLow.tsym);
1807                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1808                         }
1809                         if (highSub != null) {
1810                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1811                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1812                             }
1813                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1814                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1815                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1816                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1817                                 if (upcast ? giveWarning(a, b) :
1818                                     giveWarning(b, a))
1819                                     warnStack.head.warn(LintCategory.UNCHECKED);
1820                                 return true;
1821                             }
1822                         }
1823                         if (isReifiable(s))
1824                             return isSubtypeUnchecked(a, b);
1825                         else
1826                             return isSubtypeUnchecked(a, b, warnStack.head);
1827                     }
1828 
1829                     // Sidecast
1830                     if (s.hasTag(CLASS)) {
1831                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1832                             return ((t.tsym.flags() &amp; FINAL) == 0)
1833                                 ? sideCast(t, s, warnStack.head)
1834                                 : sideCastFinal(t, s, warnStack.head);
1835                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1836                             return ((s.tsym.flags() &amp; FINAL) == 0)
1837                                 ? sideCast(t, s, warnStack.head)
1838                                 : sideCastFinal(t, s, warnStack.head);
1839                         } else {
1840                             // unrelated class types
1841                             return false;
1842                         }
1843                     }
1844                 }
1845                 return false;
1846             }
1847 
1848             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1849                 Warner warn = noWarnings;
1850                 for (Type c : directSupertypes(ct)) {
1851                     warn.clear();
1852                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1853                         return false;
1854                 }
1855                 if (warn.hasLint(LintCategory.UNCHECKED))
1856                     warnStack.head.warn(LintCategory.UNCHECKED);
1857                 return true;
1858             }
1859 
1860             @Override
1861             public Boolean visitArrayType(ArrayType t, Type s) {
1862                 switch (s.getTag()) {
1863                 case ERROR:
1864                 case BOT:
1865                     return true;
1866                 case TYPEVAR:
1867                     if (isCastable(s, t, noWarnings)) {
1868                         warnStack.head.warn(LintCategory.UNCHECKED);
1869                         return true;
1870                     } else {
1871                         return false;
1872                     }
1873                 case CLASS:
1874                     return isSubtype(t, s);
1875                 case ARRAY:
1876                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1877                         return elemtype(t).hasTag(elemtype(s).getTag());
1878                     } else {
1879                         Type et = elemtype(t);
1880                         Type es = elemtype(s);
1881                         if (!visit(et, es))
1882                             return false;
<a name="11" id="anc11"></a><span class="line-removed">1883                         if (nonCovariantValueArrays) {</span>
<span class="line-removed">1884                             if (isValue(et) || isValue(es)) {</span>
<span class="line-removed">1885                                 return isSameType(erasure(et), erasure(es));</span>
<span class="line-removed">1886                             }</span>
<span class="line-removed">1887                         }</span>
1888                         return true;
1889                     }
1890                 default:
1891                     return false;
1892                 }
1893             }
1894 
1895             @Override
1896             public Boolean visitTypeVar(TypeVar t, Type s) {
1897                 switch (s.getTag()) {
1898                 case ERROR:
1899                 case BOT:
1900                     return true;
1901                 case TYPEVAR:
1902                     if (isSubtype(t, s)) {
1903                         return true;
1904                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1905                         warnStack.head.warn(LintCategory.UNCHECKED);
1906                         return true;
1907                     } else {
1908                         return false;
1909                     }
1910                 default:
1911                     return isCastable(t.getUpperBound(), s, warnStack.head);
1912                 }
1913             }
1914 
1915             @Override
1916             public Boolean visitErrorType(ErrorType t, Type s) {
1917                 return true;
1918             }
1919         };
1920     // &lt;/editor-fold&gt;
1921 
1922     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1923     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1924         while (ts.tail != null &amp;&amp; ss.tail != null) {
1925             if (disjointType(ts.head, ss.head)) return true;
1926             ts = ts.tail;
1927             ss = ss.tail;
1928         }
1929         return false;
1930     }
1931 
1932     /**
1933      * Two types or wildcards are considered disjoint if it can be
1934      * proven that no type can be contained in both. It is
1935      * conservative in that it is allowed to say that two types are
1936      * not disjoint, even though they actually are.
1937      *
1938      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1939      * {@code X} and {@code Y} are not disjoint.
1940      */
1941     public boolean disjointType(Type t, Type s) {
1942         return disjointType.visit(t, s);
1943     }
1944     // where
1945         private TypeRelation disjointType = new TypeRelation() {
1946 
1947             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1948 
1949             @Override
1950             public Boolean visitType(Type t, Type s) {
1951                 if (s.hasTag(WILDCARD))
1952                     return visit(s, t);
1953                 else
1954                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1955             }
1956 
1957             private boolean isCastableRecursive(Type t, Type s) {
1958                 TypePair pair = new TypePair(t, s);
1959                 if (cache.add(pair)) {
1960                     try {
1961                         return Types.this.isCastable(t, s);
1962                     } finally {
1963                         cache.remove(pair);
1964                     }
1965                 } else {
1966                     return true;
1967                 }
1968             }
1969 
1970             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1971                 TypePair pair = new TypePair(t, s);
1972                 if (cache.add(pair)) {
1973                     try {
1974                         return Types.this.notSoftSubtype(t, s);
1975                     } finally {
1976                         cache.remove(pair);
1977                     }
1978                 } else {
1979                     return false;
1980                 }
1981             }
1982 
1983             @Override
1984             public Boolean visitWildcardType(WildcardType t, Type s) {
1985                 if (t.isUnbound())
1986                     return false;
1987 
1988                 if (!s.hasTag(WILDCARD)) {
1989                     if (t.isExtendsBound())
1990                         return notSoftSubtypeRecursive(s, t.type);
1991                     else
1992                         return notSoftSubtypeRecursive(t.type, s);
1993                 }
1994 
1995                 if (s.isUnbound())
1996                     return false;
1997 
1998                 if (t.isExtendsBound()) {
1999                     if (s.isExtendsBound())
2000                         return !isCastableRecursive(t.type, wildUpperBound(s));
2001                     else if (s.isSuperBound())
2002                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
2003                 } else if (t.isSuperBound()) {
2004                     if (s.isExtendsBound())
2005                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
2006                 }
2007                 return false;
2008             }
2009         };
2010     // &lt;/editor-fold&gt;
2011 
2012     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
2013     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
2014         return ts.map(cvarLowerBoundMapping);
2015     }
2016         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
2017             @Override
2018             public Type visitCapturedType(CapturedType t, Void _unused) {
2019                 return cvarLowerBound(t);
2020             }
2021         };
2022     // &lt;/editor-fold&gt;
2023 
2024     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
2025     /**
2026      * This relation answers the question: is impossible that
2027      * something of type `t&#39; can be a subtype of `s&#39;? This is
2028      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
2029      * when type variables are involved: Integer is not a subtype of T
2030      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
2031      * possibly be a subtype of T.
2032      */
2033     public boolean notSoftSubtype(Type t, Type s) {
2034         if (t == s) return false;
2035         if (t.hasTag(TYPEVAR)) {
2036             TypeVar tv = (TypeVar) t;
2037             return !isCastable(tv.getUpperBound(),
2038                                relaxBound(s),
2039                                noWarnings);
2040         }
2041         if (!s.hasTag(WILDCARD))
2042             s = cvarUpperBound(s);
2043 
2044         return !isSubtype(t, relaxBound(s));
2045     }
2046 
2047     private Type relaxBound(Type t) {
2048         return (t.hasTag(TYPEVAR)) ?
2049                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
2050                 t;
2051     }
2052     // &lt;/editor-fold&gt;
2053 
2054     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
2055     public boolean isReifiable(Type t) {
2056         return isReifiable.visit(t);
2057     }
2058     // where
2059         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
2060 
2061             public Boolean visitType(Type t, Void ignored) {
2062                 return true;
2063             }
2064 
2065             @Override
2066             public Boolean visitClassType(ClassType t, Void ignored) {
2067                 if (t.isCompound())
2068                     return false;
2069                 else {
2070                     if (!t.isParameterized())
2071                         return true;
2072 
2073                     for (Type param : t.allparams()) {
2074                         if (!param.isUnbound())
2075                             return false;
2076                     }
2077                     return true;
2078                 }
2079             }
2080 
2081             @Override
2082             public Boolean visitArrayType(ArrayType t, Void ignored) {
2083                 return visit(t.elemtype);
2084             }
2085 
2086             @Override
2087             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2088                 return false;
2089             }
2090         };
2091     // &lt;/editor-fold&gt;
2092 
2093     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2094     public boolean isArray(Type t) {
2095         while (t.hasTag(WILDCARD))
2096             t = wildUpperBound(t);
2097         return t.hasTag(ARRAY);
2098     }
2099 
2100     /**
2101      * The element type of an array.
2102      */
2103     public Type elemtype(Type t) {
2104         switch (t.getTag()) {
2105         case WILDCARD:
2106             return elemtype(wildUpperBound(t));
2107         case ARRAY:
2108             return ((ArrayType)t).elemtype;
2109         case FORALL:
2110             return elemtype(((ForAll)t).qtype);
2111         case ERROR:
2112             return t;
2113         default:
2114             return null;
2115         }
2116     }
2117 
2118     public Type elemtypeOrType(Type t) {
2119         Type elemtype = elemtype(t);
2120         return elemtype != null ?
2121             elemtype :
2122             t;
2123     }
2124 
2125     /**
2126      * Mapping to take element type of an arraytype
2127      */
2128     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2129         @Override
2130         public Type visitArrayType(ArrayType t, Void _unused) {
2131             return t.elemtype;
2132         }
2133 
2134         @Override
2135         public Type visitTypeVar(TypeVar t, Void _unused) {
2136             return visit(skipTypeVars(t, false));
2137         }
2138     };
2139 
2140     /**
2141      * The number of dimensions of an array type.
2142      */
2143     public int dimensions(Type t) {
2144         int result = 0;
2145         while (t.hasTag(ARRAY)) {
2146             result++;
2147             t = elemtype(t);
2148         }
2149         return result;
2150     }
2151 
2152     /**
2153      * Returns an ArrayType with the component type t
2154      *
2155      * @param t The component type of the ArrayType
2156      * @return the ArrayType for the given component
2157      */
2158     public ArrayType makeArrayType(Type t) {
2159         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2160             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2161         }
2162         return new ArrayType(t, syms.arrayClass);
2163     }
2164     // &lt;/editor-fold&gt;
2165 
2166     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2167     /**
2168      * Return the (most specific) base type of t that starts with the
2169      * given symbol.  If none exists, return null.
2170      *
2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2173      * this method could yield surprising answers when invoked on arrays. For example when
2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2175      *
2176      * @param t a type
2177      * @param sym a symbol
2178      */
2179     public Type asSuper(Type t, Symbol sym) {
2180         /* Some examples:
2181          *
2182          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2183          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2184          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2185          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2186          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2187          */
2188         if (sym.type == syms.objectType) { //optimization
<a name="12" id="anc12"></a><span class="line-modified">2189             return syms.objectType;</span>

2190         }
2191         return asSuper.visit(t, sym);
2192     }
2193     // where
2194         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2195 
2196             public Type visitType(Type t, Symbol sym) {
2197                 return null;
2198             }
2199 
2200             @Override
2201             public Type visitClassType(ClassType t, Symbol sym) {
2202                 if (t.tsym == sym)
2203                     return t;
2204 
<a name="13" id="anc13"></a><span class="line-modified">2205                 /* For inline types, the wired in super type is j.l.O.</span>
<span class="line-modified">2206                    So we need a special check for V &lt;: V?</span>
<span class="line-modified">2207                 */</span>
<span class="line-removed">2208                 if (t.tsym == sym.nullFreeTypeSymbol()) {</span>
<span class="line-removed">2209                     return new ClassType(t.getEnclosingType(), t.getTypeArguments(), (TypeSymbol)sym, t.getMetadata());</span>
<span class="line-removed">2210                 }</span>
2211 
2212                 Type st = supertype(t);
2213                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2214                     Type x = asSuper(st, sym);
2215                     if (x != null)
2216                         return x;
2217                 }
2218                 if ((sym.flags() &amp; INTERFACE) != 0) {
2219                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2220                         if (!l.head.hasTag(ERROR)) {
2221                             Type x = asSuper(l.head, sym);
2222                             if (x != null)
2223                                 return x;
2224                         }
2225                     }
2226                 }
2227                 return null;
2228             }
2229 
2230             @Override
2231             public Type visitArrayType(ArrayType t, Symbol sym) {
2232                 return isSubtype(t, sym.type) ? sym.type : null;
2233             }
2234 
2235             @Override
2236             public Type visitTypeVar(TypeVar t, Symbol sym) {
2237                 if (t.tsym == sym)
2238                     return t;
2239                 else
2240                     return asSuper(t.getUpperBound(), sym);
2241             }
2242 
2243             @Override
2244             public Type visitErrorType(ErrorType t, Symbol sym) {
2245                 return t;
2246             }
2247         };
2248 
2249     /**
2250      * Return the base type of t or any of its outer types that starts
2251      * with the given symbol.  If none exists, return null.
2252      *
2253      * @param t a type
2254      * @param sym a symbol
2255      */
2256     public Type asOuterSuper(Type t, Symbol sym) {
2257         switch (t.getTag()) {
2258         case CLASS:
2259             do {
2260                 Type s = asSuper(t, sym);
2261                 if (s != null) return s;
2262                 t = t.getEnclosingType();
2263             } while (t.hasTag(CLASS));
2264             return null;
2265         case ARRAY:
2266             return isSubtype(t, sym.type) ? sym.type : null;
2267         case TYPEVAR:
2268             return asSuper(t, sym);
2269         case ERROR:
2270             return t;
2271         default:
2272             return null;
2273         }
2274     }
2275 
2276     /**
2277      * Return the base type of t or any of its enclosing types that
2278      * starts with the given symbol.  If none exists, return null.
2279      *
2280      * @param t a type
2281      * @param sym a symbol
2282      */
2283     public Type asEnclosingSuper(Type t, Symbol sym) {
2284         switch (t.getTag()) {
2285         case CLASS:
2286             do {
2287                 Type s = asSuper(t, sym);
2288                 if (s != null) return s;
2289                 Type outer = t.getEnclosingType();
2290                 t = (outer.hasTag(CLASS)) ? outer :
2291                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2292                     Type.noType;
2293             } while (t.hasTag(CLASS));
2294             return null;
2295         case ARRAY:
2296             return isSubtype(t, sym.type) ? sym.type : null;
2297         case TYPEVAR:
2298             return asSuper(t, sym);
2299         case ERROR:
2300             return t;
2301         default:
2302             return null;
2303         }
2304     }
2305     // &lt;/editor-fold&gt;
2306 
2307     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2308     /**
2309      * The type of given symbol, seen as a member of t.
2310      *
2311      * @param t a type
2312      * @param sym a symbol
2313      */
2314     public Type memberType(Type t, Symbol sym) {
<a name="14" id="anc14"></a><span class="line-modified">2315         return (sym.flags() &amp; STATIC) != 0</span>
<span class="line-modified">2316             ? sym.type</span>
<span class="line-modified">2317             : memberType.visit(t, sym);</span>












2318         }
2319     // where
2320         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2321 
2322             public Type visitType(Type t, Symbol sym) {
2323                 return sym.type;
2324             }
2325 
2326             @Override
2327             public Type visitWildcardType(WildcardType t, Symbol sym) {
2328                 return memberType(wildUpperBound(t), sym);
2329             }
2330 
2331             @Override
2332             public Type visitClassType(ClassType t, Symbol sym) {
2333                 Symbol owner = sym.owner;
2334                 long flags = sym.flags();
2335                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2336                     Type base = asOuterSuper(t, owner);
2337                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2338                     //its supertypes CT, I1, ... In might contain wildcards
2339                     //so we need to go through capture conversion
2340                     base = t.isCompound() ? capture(base) : base;
2341                     if (base != null) {
2342                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2343                         List&lt;Type&gt; baseParams = base.allparams();
2344                         if (ownerParams.nonEmpty()) {
2345                             if (baseParams.isEmpty()) {
2346                                 // then base is a raw type
2347                                 return erasure(sym.type);
2348                             } else {
2349                                 return subst(sym.type, ownerParams, baseParams);
2350                             }
2351                         }
2352                     }
2353                 }
2354                 return sym.type;
2355             }
2356 
2357             @Override
2358             public Type visitTypeVar(TypeVar t, Symbol sym) {
2359                 return memberType(t.getUpperBound(), sym);
2360             }
2361 
2362             @Override
2363             public Type visitErrorType(ErrorType t, Symbol sym) {
2364                 return t;
2365             }
2366         };
2367     // &lt;/editor-fold&gt;
2368 
2369     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2370     public boolean isAssignable(Type t, Type s) {
2371         return isAssignable(t, s, noWarnings);
2372     }
2373 
2374     /**
2375      * Is t assignable to s?&lt;br&gt;
2376      * Equivalent to subtype except for constant values and raw
2377      * types.&lt;br&gt;
2378      * (not defined for Method and ForAll types)
2379      */
2380     public boolean isAssignable(Type t, Type s, Warner warn) {
2381         if (t.hasTag(ERROR))
2382             return true;
2383         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2384             int value = ((Number)t.constValue()).intValue();
2385             switch (s.getTag()) {
2386             case BYTE:
2387             case CHAR:
2388             case SHORT:
2389             case INT:
2390                 if (s.getTag().checkRange(value))
2391                     return true;
2392                 break;
2393             case CLASS:
2394                 switch (unboxedType(s).getTag()) {
2395                 case BYTE:
2396                 case CHAR:
2397                 case SHORT:
2398                     return isAssignable(t, unboxedType(s), warn);
2399                 }
2400                 break;
2401             }
2402         }
2403         return isConvertible(t, s, warn);
2404     }
2405     // &lt;/editor-fold&gt;
2406 
2407     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2408     /**
2409      * The erasure of t {@code |t|} -- the type that results when all
2410      * type parameters in t are deleted.
2411      */
2412     public Type erasure(Type t) {
2413         return eraseNotNeeded(t) ? t : erasure(t, false);
2414     }
2415     //where
2416     private boolean eraseNotNeeded(Type t) {
2417         // We don&#39;t want to erase primitive types and String type as that
2418         // operation is idempotent. Also, erasing these could result in loss
2419         // of information such as constant values attached to such types.
2420         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2421     }
2422 
2423     private Type erasure(Type t, boolean recurse) {
2424         if (t.isPrimitive()) {
2425             return t; /* fast special case */
2426         } else {
2427             Type out = erasure.visit(t, recurse);
2428             return out;
2429         }
2430     }
2431     // where
2432         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2433             private Type combineMetadata(final Type s,
2434                                          final Type t) {
2435                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2436                     switch (s.getKind()) {
2437                         case OTHER:
2438                         case UNION:
2439                         case INTERSECTION:
2440                         case PACKAGE:
2441                         case EXECUTABLE:
2442                         case NONE:
2443                         case VOID:
2444                         case ERROR:
2445                             return s;
2446                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2447                     }
2448                 } else {
2449                     return s;
2450                 }
2451             }
2452 
2453             public Type visitType(Type t, Boolean recurse) {
2454                 if (t.isPrimitive())
2455                     return t; /*fast special case*/
2456                 else {
2457                     //other cases already handled
2458                     return combineMetadata(t, t);
2459                 }
2460             }
2461 
2462             @Override
2463             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2464                 Type erased = erasure(wildUpperBound(t), recurse);
2465                 return combineMetadata(erased, t);
2466             }
2467 
2468             @Override
2469             public Type visitClassType(ClassType t, Boolean recurse) {
2470                 Type erased = t.tsym.erasure(Types.this);
2471                 if (recurse) {
2472                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2473                             t.getMetadata().without(Kind.ANNOTATIONS));
2474                     return erased;
2475                 } else {
2476                     return combineMetadata(erased, t);
2477                 }
2478             }
2479 
2480             @Override
2481             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2482                 Type erased = erasure(t.getUpperBound(), recurse);
2483                 return combineMetadata(erased, t);
2484             }
2485         };
2486 
2487     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2488         return erasure.visit(ts, false);
2489     }
2490 
2491     public Type erasureRecursive(Type t) {
2492         return erasure(t, true);
2493     }
2494 
2495     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2496         return erasure.visit(ts, true);
2497     }
2498     // &lt;/editor-fold&gt;
2499 
2500     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2501     /**
2502      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2503      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2504      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2505      *
2506      * @param bounds    the types from which the intersection type is formed
2507      */
2508     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2509         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2510     }
2511 
2512     /**
2513      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2514      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2515      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2516      * supertype is implicitly assumed to be &#39;Object&#39;.
2517      *
2518      * @param bounds        the types from which the intersection type is formed
2519      * @param allInterfaces are all bounds interface types?
2520      */
2521     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2522         Assert.check(bounds.nonEmpty());
2523         Type firstExplicitBound = bounds.head;
2524         if (allInterfaces) {
2525             bounds = bounds.prepend(syms.objectType);
2526         }
2527         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;
2528         if (isValue(bounds.head))
2529             flags |= VALUE;
2530         ClassSymbol bc =
2531             new ClassSymbol(flags,
2532                             Type.moreInfo
2533                                 ? names.fromString(bounds.toString())
2534                                 : names.empty,
2535                             null,
2536                             syms.noSymbol);
2537         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2538         bc.type = intersectionType;
2539         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2540                 syms.objectType : // error condition, recover
2541                 erasure(firstExplicitBound);
2542         bc.members_field = WriteableScope.create(bc);
2543         return intersectionType;
2544     }
2545     // &lt;/editor-fold&gt;
2546 
2547     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2548     public Type supertype(Type t) {
2549         return supertype.visit(t);
2550     }
2551     // where
2552         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2553 
2554             public Type visitType(Type t, Void ignored) {
2555                 // A note on wildcards: there is no good way to
2556                 // determine a supertype for a super bounded wildcard.
2557                 return Type.noType;
2558             }
2559 
2560             @Override
2561             public Type visitClassType(ClassType t, Void ignored) {
2562                 if (t.supertype_field == null) {
2563                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2564                     // An interface has no superclass; its supertype is Object.
2565                     if (t.isInterface())
2566                         supertype = ((ClassType)t.tsym.type).supertype_field;
2567                     if (t.supertype_field == null) {
2568                         List&lt;Type&gt; actuals = classBound(t).allparams();
2569                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2570                         if (t.hasErasedSupertypes()) {
2571                             t.supertype_field = erasureRecursive(supertype);
2572                         } else if (formals.nonEmpty()) {
2573                             t.supertype_field = subst(supertype, formals, actuals);
2574                         }
2575                         else {
2576                             t.supertype_field = supertype;
2577                         }
2578                     }
2579                 }
2580                 return t.supertype_field;
2581             }
2582 
2583             /**
2584              * The supertype is always a class type. If the type
2585              * variable&#39;s bounds start with a class type, this is also
2586              * the supertype.  Otherwise, the supertype is
2587              * java.lang.Object.
2588              */
2589             @Override
2590             public Type visitTypeVar(TypeVar t, Void ignored) {
2591                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2592                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2593                     return t.getUpperBound();
2594                 } else {
2595                     return supertype(t.getUpperBound());
2596                 }
2597             }
2598 
2599             @Override
2600             public Type visitArrayType(ArrayType t, Void ignored) {
2601                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2602                     return arraySuperType();
2603                 else
2604                     return new ArrayType(supertype(t.elemtype), t.tsym);
2605             }
2606 
2607             @Override
2608             public Type visitErrorType(ErrorType t, Void ignored) {
2609                 return Type.noType;
2610             }
2611         };
2612     // &lt;/editor-fold&gt;
2613 
2614     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2615     /**
2616      * Return the interfaces implemented by this class.
2617      */
2618     public List&lt;Type&gt; interfaces(Type t) {
2619         return interfaces.visit(t);
2620     }
2621     // where
2622         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2623 
2624             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2625                 return List.nil();
2626             }
2627 
2628             @Override
2629             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2630                 if (t.interfaces_field == null) {
2631                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2632                     if (t.interfaces_field == null) {
2633                         // If t.interfaces_field is null, then t must
2634                         // be a parameterized type (not to be confused
2635                         // with a generic type declaration).
2636                         // Terminology:
2637                         //    Parameterized type: List&lt;String&gt;
2638                         //    Generic type declaration: class List&lt;E&gt; { ... }
2639                         // So t corresponds to List&lt;String&gt; and
2640                         // t.tsym.type corresponds to List&lt;E&gt;.
2641                         // The reason t must be parameterized type is
2642                         // that completion will happen as a side
2643                         // effect of calling
2644                         // ClassSymbol.getInterfaces.  Since
2645                         // t.interfaces_field is null after
2646                         // completion, we can assume that t is not the
2647                         // type of a class/interface declaration.
2648                         Assert.check(t != t.tsym.type, t);
2649                         List&lt;Type&gt; actuals = t.allparams();
2650                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2651                         if (t.hasErasedSupertypes()) {
2652                             t.interfaces_field = erasureRecursive(interfaces);
2653                         } else if (formals.nonEmpty()) {
2654                             t.interfaces_field = subst(interfaces, formals, actuals);
2655                         }
2656                         else {
2657                             t.interfaces_field = interfaces;
2658                         }
2659                     }
2660                 }
2661                 return t.interfaces_field;
2662             }
2663 
2664             @Override
2665             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2666                 if (t.getUpperBound().isCompound())
2667                     return interfaces(t.getUpperBound());
2668 
2669                 if (t.getUpperBound().isInterface())
2670                     return List.of(t.getUpperBound());
2671 
2672                 return List.nil();
2673             }
2674         };
2675 
2676     public List&lt;Type&gt; directSupertypes(Type t) {
2677         return directSupertypes.visit(t);
2678     }
2679     // where
2680         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2681 
2682             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2683                 if (!type.isIntersection()) {
2684                     final Type sup = supertype(type);
2685                     return (sup == Type.noType || sup == type || sup == null)
2686                         ? interfaces(type)
2687                         : interfaces(type).prepend(sup);
2688                 } else {
2689                     return ((IntersectionClassType)type).getExplicitComponents();
2690                 }
2691             }
2692         };
2693 
2694     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2695         for (Type i2 : interfaces(origin.type)) {
2696             if (isym == i2.tsym) return true;
2697         }
2698         return false;
2699     }
2700     // &lt;/editor-fold&gt;
2701 
2702     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2703     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2704 
2705     public boolean isDerivedRaw(Type t) {
2706         Boolean result = isDerivedRawCache.get(t);
2707         if (result == null) {
2708             result = isDerivedRawInternal(t);
2709             isDerivedRawCache.put(t, result);
2710         }
2711         return result;
2712     }
2713 
2714     public boolean isDerivedRawInternal(Type t) {
2715         if (t.isErroneous())
2716             return false;
2717         return
2718             t.isRaw() ||
2719             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2720             isDerivedRaw(interfaces(t));
2721     }
2722 
2723     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2724         List&lt;Type&gt; l = ts;
2725         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2726         return l.nonEmpty();
2727     }
2728     // &lt;/editor-fold&gt;
2729 
2730     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2731     /**
2732      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2733      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2734      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2735      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2736      * Hence, this version of setBounds may not be called during a classfile read.
2737      *
2738      * @param t         a type variable
2739      * @param bounds    the bounds, must be nonempty
2740      */
2741     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2742         setBounds(t, bounds, bounds.head.tsym.isInterface());
2743     }
2744 
2745     /**
2746      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2747      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2748      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2749      *
2750      * @param t             a type variable
2751      * @param bounds        the bounds, must be nonempty
2752      * @param allInterfaces are all bounds interface types?
2753      */
2754     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2755         t.setUpperBound( bounds.tail.isEmpty() ?
2756                 bounds.head :
2757                 makeIntersectionType(bounds, allInterfaces) );
2758         t.rank_field = -1;
2759     }
2760     // &lt;/editor-fold&gt;
2761 
2762     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2763     /**
2764      * Return list of bounds of the given type variable.
2765      */
2766     public List&lt;Type&gt; getBounds(TypeVar t) {
2767         if (t.getUpperBound().hasTag(NONE))
2768             return List.nil();
2769         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2770             return List.of(t.getUpperBound());
2771         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2772             return interfaces(t).prepend(supertype(t));
2773         else
2774             // No superclass was given in bounds.
2775             // In this case, supertype is Object, erasure is first interface.
2776             return interfaces(t);
2777     }
2778     // &lt;/editor-fold&gt;
2779 
2780     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2781     /**
2782      * If the given type is a (possibly selected) type variable,
2783      * return the bounding class of this type, otherwise return the
2784      * type itself.
2785      */
2786     public Type classBound(Type t) {
2787         return classBound.visit(t);
2788     }
2789     // where
2790         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2791 
2792             public Type visitType(Type t, Void ignored) {
2793                 return t;
2794             }
2795 
2796             @Override
2797             public Type visitClassType(ClassType t, Void ignored) {
2798                 Type outer1 = classBound(t.getEnclosingType());
2799                 if (outer1 != t.getEnclosingType())
2800                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2801                                          t.getMetadata());
2802                 else
2803                     return t;
2804             }
2805 
2806             @Override
2807             public Type visitTypeVar(TypeVar t, Void ignored) {
2808                 return classBound(supertype(t));
2809             }
2810 
2811             @Override
2812             public Type visitErrorType(ErrorType t, Void ignored) {
2813                 return t;
2814             }
2815         };
2816     // &lt;/editor-fold&gt;
2817 
2818     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2819     /**
2820      * Returns true iff the first signature is a &lt;em&gt;sub
2821      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2822      * relation.
2823      *
2824      * @jls 8.4.2 Method Signature
2825      * @see #overrideEquivalent(Type t, Type s)
2826      * @param t first signature (possibly raw).
2827      * @param s second signature (could be subjected to erasure).
2828      * @return true if t is a sub signature of s.
2829      */
2830     public boolean isSubSignature(Type t, Type s) {
2831         return isSubSignature(t, s, true);
2832     }
2833 
2834     public boolean isSubSignature(Type t, Type s, boolean strict) {
2835         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2836     }
2837 
2838     /**
2839      * Returns true iff these signatures are related by &lt;em&gt;override
2840      * equivalence&lt;/em&gt;.  This is the natural extension of
2841      * isSubSignature to an equivalence relation.
2842      *
2843      * @jls 8.4.2 Method Signature
2844      * @see #isSubSignature(Type t, Type s)
2845      * @param t a signature (possible raw, could be subjected to
2846      * erasure).
2847      * @param s a signature (possible raw, could be subjected to
2848      * erasure).
2849      * @return true if either argument is a sub signature of the other.
2850      */
2851     public boolean overrideEquivalent(Type t, Type s) {
2852         return hasSameArgs(t, s) ||
2853             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2854     }
2855 
2856     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2857         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2858             if (msym.overrides(sym, origin, Types.this, true)) {
2859                 return true;
2860             }
2861         }
2862         return false;
2863     }
2864 
2865     /**
2866      * This enum defines the strategy for implementing most specific return type check
2867      * during the most specific and functional interface checks.
2868      */
2869     public enum MostSpecificReturnCheck {
2870         /**
2871          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2872          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2873          * by type-equivalence for primitives. This is essentially an inlined version of
2874          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2875          * replaced with a strict subtyping check.
2876          */
2877         BASIC() {
2878             @Override
2879             public boolean test(Type mt1, Type mt2, Types types) {
2880                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2881                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2882                 Type t = mt1.getReturnType();
2883                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2884                 return types.isSameType(t, s) ||
2885                     !t.isPrimitive() &amp;&amp;
2886                     !s.isPrimitive() &amp;&amp;
2887                     types.isSubtype(t, s);
2888             }
2889         },
2890         /**
2891          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2892          */
2893         RTS() {
2894             @Override
2895             public boolean test(Type mt1, Type mt2, Types types) {
2896                 return types.returnTypeSubstitutable(mt1, mt2);
2897             }
2898         };
2899 
2900         public abstract boolean test(Type mt1, Type mt2, Types types);
2901     }
2902 
2903     /**
2904      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2905      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2906      * The resulting preferred method has a thrown clause that is the intersection of the merged
2907      * methods&#39; clauses.
2908      */
2909     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2910         //first check for preconditions
2911         boolean shouldErase = false;
2912         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2913         for (Symbol s : ambiguousInOrder) {
2914             if ((s.flags() &amp; ABSTRACT) == 0 ||
2915                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2916                 return Optional.empty();
2917             } else if (s.type.hasTag(FORALL)) {
2918                 shouldErase = true;
2919             }
2920         }
2921         //then merge abstracts
2922         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2923             outer: for (Symbol s : ambiguousInOrder) {
2924                 Type mt = memberType(site, s);
2925                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2926                 for (Symbol s2 : ambiguousInOrder) {
2927                     if (s != s2) {
2928                         Type mt2 = memberType(site, s2);
2929                         if (!isSubSignature(mt, mt2) ||
2930                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2931                             //ambiguity cannot be resolved
2932                             continue outer;
2933                         } else {
2934                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2935                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2936                                 thrownTypes2 = erasure(thrownTypes2);
2937                             } else if (mt.hasTag(FORALL)) {
2938                                 //subsignature implies that if most specific is generic, then all other
2939                                 //methods are too
2940                                 Assert.check(mt2.hasTag(FORALL));
2941                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2942                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2943                             }
2944                             allThrown = chk.intersect(allThrown, thrownTypes2);
2945                         }
2946                     }
2947                 }
2948                 return (allThrown == mt.getThrownTypes()) ?
2949                         Optional.of(s) :
2950                         Optional.of(new MethodSymbol(
2951                                 s.flags(),
2952                                 s.name,
2953                                 createMethodTypeWithThrown(s.type, allThrown),
2954                                 s.owner) {
2955                             @Override
2956                             public Symbol baseSymbol() {
2957                                 return s;
2958                             }
2959                         });
2960             }
2961         }
2962         return Optional.empty();
2963     }
2964 
2965     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
2966     class ImplementationCache {
2967 
2968         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
2969 
2970         class Entry {
2971             final MethodSymbol cachedImpl;
2972             final Filter&lt;Symbol&gt; implFilter;
2973             final boolean checkResult;
2974             final int prevMark;
2975 
2976             public Entry(MethodSymbol cachedImpl,
2977                     Filter&lt;Symbol&gt; scopeFilter,
2978                     boolean checkResult,
2979                     int prevMark) {
2980                 this.cachedImpl = cachedImpl;
2981                 this.implFilter = scopeFilter;
2982                 this.checkResult = checkResult;
2983                 this.prevMark = prevMark;
2984             }
2985 
2986             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
2987                 return this.implFilter == scopeFilter &amp;&amp;
2988                         this.checkResult == checkResult &amp;&amp;
2989                         this.prevMark == mark;
2990             }
2991         }
2992 
2993         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2994             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
2995             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
2996             if (cache == null) {
2997                 cache = new HashMap&lt;&gt;();
2998                 _map.put(ms, new SoftReference&lt;&gt;(cache));
2999             }
3000             Entry e = cache.get(origin);
3001             CompoundScope members = membersClosure(origin.type, true);
3002             if (e == null ||
3003                     !e.matches(implFilter, checkResult, members.getMark())) {
3004                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
3005                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
3006                 return impl;
3007             }
3008             else {
3009                 return e.cachedImpl;
3010             }
3011         }
3012 
3013         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3014             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
3015                 t = skipTypeVars(t, false);
3016                 TypeSymbol c = t.tsym;
3017                 Symbol bestSoFar = null;
3018                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
3019                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
3020                         bestSoFar = sym;
3021                         if ((sym.flags() &amp; ABSTRACT) == 0) {
3022                             //if concrete impl is found, exit immediately
3023                             break;
3024                         }
3025                     }
3026                 }
3027                 if (bestSoFar != null) {
3028                     //return either the (only) concrete implementation or the first abstract one
3029                     return (MethodSymbol)bestSoFar;
3030                 }
3031             }
3032             return null;
3033         }
3034     }
3035 
3036     private ImplementationCache implCache = new ImplementationCache();
3037 
3038     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3039         return implCache.get(ms, origin, checkResult, implFilter);
3040     }
3041     // &lt;/editor-fold&gt;
3042 
3043     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
3044     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
3045 
3046         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
3047 
3048         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
3049 
3050         class MembersScope extends CompoundScope {
3051 
3052             CompoundScope scope;
3053 
3054             public MembersScope(CompoundScope scope) {
3055                 super(scope.owner);
3056                 this.scope = scope;
3057             }
3058 
3059             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
3060                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
3061             }
3062 
3063             @Override
3064             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3065                 return scope.getSymbols(combine(sf), lookupKind);
3066             }
3067 
3068             @Override
3069             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3070                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
3071             }
3072 
3073             @Override
3074             public int getMark() {
3075                 return scope.getMark();
3076             }
3077         }
3078 
3079         CompoundScope nilScope;
3080 
3081         /** members closure visitor methods **/
3082 
3083         public CompoundScope visitType(Type t, Void _unused) {
3084             if (nilScope == null) {
3085                 nilScope = new CompoundScope(syms.noSymbol);
3086             }
3087             return nilScope;
3088         }
3089 
3090         @Override
3091         public CompoundScope visitClassType(ClassType t, Void _unused) {
3092             if (!seenTypes.add(t.tsym)) {
3093                 //this is possible when an interface is implemented in multiple
3094                 //superclasses, or when a class hierarchy is circular - in such
3095                 //cases we don&#39;t need to recurse (empty scope is returned)
3096                 return new CompoundScope(t.tsym);
3097             }
3098             try {
3099                 seenTypes.add(t.tsym);
3100                 ClassSymbol csym = (ClassSymbol)t.tsym;
3101                 CompoundScope membersClosure = _map.get(csym);
3102                 if (membersClosure == null) {
3103                     membersClosure = new CompoundScope(csym);
3104                     for (Type i : interfaces(t)) {
3105                         membersClosure.prependSubScope(visit(i, null));
3106                     }
3107                     membersClosure.prependSubScope(visit(supertype(t), null));
3108                     membersClosure.prependSubScope(csym.members());
3109                     _map.put(csym, membersClosure);
3110                 }
3111                 return membersClosure;
3112             }
3113             finally {
3114                 seenTypes.remove(t.tsym);
3115             }
3116         }
3117 
3118         @Override
3119         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3120             return visit(t.getUpperBound(), null);
3121         }
3122     }
3123 
3124     private MembersClosureCache membersCache = new MembersClosureCache();
3125 
3126     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3127         CompoundScope cs = membersCache.visit(site, null);
3128         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3129         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3130     }
3131     // &lt;/editor-fold&gt;
3132 
3133 
3134     /** Return first abstract member of class `sym&#39;.
3135      */
3136     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3137         try {
3138             return firstUnimplementedAbstractImpl(sym, sym);
3139         } catch (CompletionFailure ex) {
3140             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3141             return null;
3142         }
3143     }
3144         //where:
3145         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3146             MethodSymbol undef = null;
3147             // Do not bother to search in classes that are not abstract,
3148             // since they cannot have abstract members.
3149             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3150                 Scope s = c.members();
3151                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3152                     if (sym.kind == MTH &amp;&amp;
3153                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3154                         MethodSymbol absmeth = (MethodSymbol)sym;
3155                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3156                         if (implmeth == null || implmeth == absmeth) {
3157                             //look for default implementations
3158                             if (allowDefaultMethods) {
3159                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3160                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3161                                     implmeth = prov;
3162                                 }
3163                             }
3164                         }
3165                         if (implmeth == null || implmeth == absmeth) {
3166                             undef = absmeth;
3167                             break;
3168                         }
3169                     }
3170                 }
3171                 if (undef == null) {
3172                     Type st = supertype(c.type);
3173                     if (st.hasTag(CLASS))
3174                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3175                 }
3176                 for (List&lt;Type&gt; l = interfaces(c.type);
3177                      undef == null &amp;&amp; l.nonEmpty();
3178                      l = l.tail) {
3179                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3180                 }
3181             }
3182             return undef;
3183         }
3184 
3185     public class CandidatesCache {
3186         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3187 
3188         class Entry {
3189             Type site;
3190             MethodSymbol msym;
3191 
3192             Entry(Type site, MethodSymbol msym) {
3193                 this.site = site;
3194                 this.msym = msym;
3195             }
3196 
3197             @Override
3198             public boolean equals(Object obj) {
3199                 if (obj instanceof Entry) {
3200                     Entry e = (Entry)obj;
3201                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3202                 } else {
3203                     return false;
3204                 }
3205             }
3206 
3207             @Override
3208             public int hashCode() {
3209                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3210             }
3211         }
3212 
3213         public List&lt;MethodSymbol&gt; get(Entry e) {
3214             return cache.get(e);
3215         }
3216 
3217         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3218             cache.put(e, msymbols);
3219         }
3220     }
3221 
3222     public CandidatesCache candidatesCache = new CandidatesCache();
3223 
3224     //where
3225     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3226         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3227         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3228         if (candidates == null) {
3229             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3230             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3231             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3232                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3233                     return List.of((MethodSymbol)s);
3234                 } else if (!candidates2.contains(s)) {
3235                     candidates2 = candidates2.prepend((MethodSymbol)s);
3236                 }
3237             }
3238             candidates = prune(candidates2);
3239             candidatesCache.put(e, candidates);
3240         }
3241         return candidates;
3242     }
3243 
3244     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3245         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3246         for (MethodSymbol m1 : methods) {
3247             boolean isMin_m1 = true;
3248             for (MethodSymbol m2 : methods) {
3249                 if (m1 == m2) continue;
3250                 if (m2.owner != m1.owner &amp;&amp;
3251                         asSuper(m2.owner.type, m1.owner) != null) {
3252                     isMin_m1 = false;
3253                     break;
3254                 }
3255             }
3256             if (isMin_m1)
3257                 methodsMin.append(m1);
3258         }
3259         return methodsMin.toList();
3260     }
3261     // where
3262             private class MethodFilter implements Filter&lt;Symbol&gt; {
3263 
3264                 Symbol msym;
3265                 Type site;
3266 
3267                 MethodFilter(Symbol msym, Type site) {
3268                     this.msym = msym;
3269                     this.site = site;
3270                 }
3271 
3272                 public boolean accepts(Symbol s) {
3273                     return s.kind == MTH &amp;&amp;
3274                             s.name == msym.name &amp;&amp;
3275                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3276                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3277                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3278                 }
3279             }
3280     // &lt;/editor-fold&gt;
3281 
3282     /**
3283      * Does t have the same arguments as s?  It is assumed that both
3284      * types are (possibly polymorphic) method types.  Monomorphic
3285      * method types &quot;have the same arguments&quot;, if their argument lists
3286      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3287      * if they have the same arguments after renaming all type
3288      * variables of one to corresponding type variables in the other,
3289      * where correspondence is by position in the type parameter list.
3290      */
3291     public boolean hasSameArgs(Type t, Type s) {
3292         return hasSameArgs(t, s, true);
3293     }
3294 
3295     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3296         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3297     }
3298 
3299     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3300         return hasSameArgs.visit(t, s);
3301     }
3302     // where
3303         private class HasSameArgs extends TypeRelation {
3304 
3305             boolean strict;
3306 
3307             public HasSameArgs(boolean strict) {
3308                 this.strict = strict;
3309             }
3310 
3311             public Boolean visitType(Type t, Type s) {
3312                 throw new AssertionError();
3313             }
3314 
3315             @Override
3316             public Boolean visitMethodType(MethodType t, Type s) {
3317                 return s.hasTag(METHOD)
3318                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3319             }
3320 
3321             @Override
3322             public Boolean visitForAll(ForAll t, Type s) {
3323                 if (!s.hasTag(FORALL))
3324                     return strict ? false : visitMethodType(t.asMethodType(), s);
3325 
3326                 ForAll forAll = (ForAll)s;
3327                 return hasSameBounds(t, forAll)
3328                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3329             }
3330 
3331             @Override
3332             public Boolean visitErrorType(ErrorType t, Type s) {
3333                 return false;
3334             }
3335         }
3336 
3337     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3338         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3339 
3340     // &lt;/editor-fold&gt;
3341 
3342     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3343     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3344                             List&lt;Type&gt; from,
3345                             List&lt;Type&gt; to) {
3346         return ts.map(new Subst(from, to));
3347     }
3348 
3349     /**
3350      * Substitute all occurrences of a type in `from&#39; with the
3351      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3352      * from the right: If lists have different length, discard leading
3353      * elements of the longer list.
3354      */
3355     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3356         return t.map(new Subst(from, to));
3357     }
3358 
3359     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3360         List&lt;Type&gt; from;
3361         List&lt;Type&gt; to;
3362 
3363         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3364             int fromLength = from.length();
3365             int toLength = to.length();
3366             while (fromLength &gt; toLength) {
3367                 fromLength--;
3368                 from = from.tail;
3369             }
3370             while (fromLength &lt; toLength) {
3371                 toLength--;
3372                 to = to.tail;
3373             }
3374             this.from = from;
3375             this.to = to;
3376         }
3377 
3378         @Override
3379         public Type visitTypeVar(TypeVar t, Void ignored) {
3380             for (List&lt;Type&gt; from = this.from, to = this.to;
3381                  from.nonEmpty();
3382                  from = from.tail, to = to.tail) {
3383                 if (t.equalsIgnoreMetadata(from.head)) {
3384                     return to.head.withTypeVar(t);
3385                 }
3386             }
3387             return t;
3388         }
3389 
3390         @Override
3391         public Type visitClassType(ClassType t, Void ignored) {
3392             if (!t.isCompound()) {
3393                 return super.visitClassType(t, ignored);
3394             } else {
3395                 Type st = visit(supertype(t));
3396                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3397                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3398                     return t;
3399                 else
3400                     return makeIntersectionType(is.prepend(st));
3401             }
3402         }
3403 
3404         @Override
3405         public Type visitWildcardType(WildcardType t, Void ignored) {
3406             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3407             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3408                 t2.type = wildUpperBound(t2.type);
3409             }
3410             return t2;
3411         }
3412 
3413         @Override
3414         public Type visitForAll(ForAll t, Void ignored) {
3415             if (Type.containsAny(to, t.tvars)) {
3416                 //perform alpha-renaming of free-variables in &#39;t&#39;
3417                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3418                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3419                 t = new ForAll(freevars,
3420                                Types.this.subst(t.qtype, t.tvars, freevars));
3421             }
3422             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3423             Type qtype1 = visit(t.qtype);
3424             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3425                 return t;
3426             } else if (tvars1 == t.tvars) {
3427                 return new ForAll(tvars1, qtype1) {
3428                     @Override
3429                     public boolean needsStripping() {
3430                         return true;
3431                     }
3432                 };
3433             } else {
3434                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3435                     @Override
3436                     public boolean needsStripping() {
3437                         return true;
3438                     }
3439                 };
3440             }
3441         }
3442     }
3443 
3444     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3445                                   List&lt;Type&gt; from,
3446                                   List&lt;Type&gt; to) {
3447         if (tvars.isEmpty())
3448             return tvars;
3449         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3450         boolean changed = false;
3451         // calculate new bounds
3452         for (Type t : tvars) {
3453             TypeVar tv = (TypeVar) t;
3454             Type bound = subst(tv.getUpperBound(), from, to);
3455             if (bound != tv.getUpperBound())
3456                 changed = true;
3457             newBoundsBuf.append(bound);
3458         }
3459         if (!changed)
3460             return tvars;
3461         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3462         // create new type variables without bounds
3463         for (Type t : tvars) {
3464             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3465                                         t.getMetadata()));
3466         }
3467         // the new bounds should use the new type variables in place
3468         // of the old
3469         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3470         from = tvars;
3471         to = newTvars.toList();
3472         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3473             newBounds.head = subst(newBounds.head, from, to);
3474         }
3475         newBounds = newBoundsBuf.toList();
3476         // set the bounds of new type variables to the new bounds
3477         for (Type t : newTvars.toList()) {
3478             TypeVar tv = (TypeVar) t;
3479             tv.setUpperBound( newBounds.head );
3480             newBounds = newBounds.tail;
3481         }
3482         return newTvars.toList();
3483     }
3484 
3485     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3486         Type bound1 = subst(t.getUpperBound(), from, to);
3487         if (bound1 == t.getUpperBound())
3488             return t;
3489         else {
3490             // create new type variable without bounds
3491             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3492                                      t.getMetadata());
3493             // the new bound should use the new type variable in place
3494             // of the old
3495             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3496             return tv;
3497         }
3498     }
3499     // &lt;/editor-fold&gt;
3500 
3501     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3502     /**
3503      * Does t have the same bounds for quantified variables as s?
3504      */
3505     public boolean hasSameBounds(ForAll t, ForAll s) {
3506         List&lt;Type&gt; l1 = t.tvars;
3507         List&lt;Type&gt; l2 = s.tvars;
3508         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3509                isSameType(l1.head.getUpperBound(),
3510                           subst(l2.head.getUpperBound(),
3511                                 s.tvars,
3512                                 t.tvars))) {
3513             l1 = l1.tail;
3514             l2 = l2.tail;
3515         }
3516         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3517     }
3518     // &lt;/editor-fold&gt;
3519 
3520     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3521     /** Create new vector of type variables from list of variables
3522      *  changing all recursive bounds from old to new list.
3523      */
3524     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3525         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3526         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3527             TypeVar tv = (TypeVar) l.head;
3528             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3529         }
3530         return tvars1;
3531     }
3532         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3533             @Override
3534             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3535                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3536             }
3537         };
3538     // &lt;/editor-fold&gt;
3539 
3540     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3541         return original.accept(methodWithParameters, newParams);
3542     }
3543     // where
3544         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3545             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3546                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3547             }
3548             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3549                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3550             }
3551             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3552                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3553             }
3554         };
3555 
3556     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3557         return original.accept(methodWithThrown, newThrown);
3558     }
3559     // where
3560         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3561             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3562                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3563             }
3564             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3565                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3566             }
3567             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3568                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3569             }
3570         };
3571 
3572     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3573         return original.accept(methodWithReturn, newReturn);
3574     }
3575     // where
3576         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3577             public Type visitType(Type t, Type newReturn) {
3578                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3579             }
3580             public Type visitMethodType(MethodType t, Type newReturn) {
3581                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3582                     @Override
3583                     public Type baseType() {
3584                         return t;
3585                     }
3586                 };
3587             }
3588             public Type visitForAll(ForAll t, Type newReturn) {
3589                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3590                     @Override
3591                     public Type baseType() {
3592                         return t;
3593                     }
3594                 };
3595             }
3596         };
3597 
3598     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3599     public Type createErrorType(Type originalType) {
3600         return new ErrorType(originalType, syms.errSymbol);
3601     }
3602 
3603     public Type createErrorType(ClassSymbol c, Type originalType) {
3604         return new ErrorType(c, originalType);
3605     }
3606 
3607     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3608         return new ErrorType(name, container, originalType);
3609     }
3610     // &lt;/editor-fold&gt;
3611 
3612     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3613     /**
3614      * The rank of a class is the length of the longest path between
3615      * the class and java.lang.Object in the class inheritance
3616      * graph. Undefined for all but reference types.
3617      */
3618     public int rank(Type t) {
3619         switch(t.getTag()) {
3620         case CLASS: {
3621             ClassType cls = (ClassType)t;
3622             if (cls.rank_field &lt; 0) {
3623                 Name fullname = cls.tsym.getQualifiedName();
3624                 if (fullname == names.java_lang_Object)
3625                     cls.rank_field = 0;
3626                 else {
3627                     int r = rank(supertype(cls));
3628                     for (List&lt;Type&gt; l = interfaces(cls);
3629                          l.nonEmpty();
3630                          l = l.tail) {
3631                         if (rank(l.head) &gt; r)
3632                             r = rank(l.head);
3633                     }
3634                     cls.rank_field = r + 1;
3635                 }
3636             }
3637             return cls.rank_field;
3638         }
3639         case TYPEVAR: {
3640             TypeVar tvar = (TypeVar)t;
3641             if (tvar.rank_field &lt; 0) {
3642                 int r = rank(supertype(tvar));
3643                 for (List&lt;Type&gt; l = interfaces(tvar);
3644                      l.nonEmpty();
3645                      l = l.tail) {
3646                     if (rank(l.head) &gt; r) r = rank(l.head);
3647                 }
3648                 tvar.rank_field = r + 1;
3649             }
3650             return tvar.rank_field;
3651         }
3652         case ERROR:
3653         case NONE:
3654             return 0;
3655         default:
3656             throw new AssertionError();
3657         }
3658     }
3659     // &lt;/editor-fold&gt;
3660 
3661     /**
3662      * Helper method for generating a string representation of a given type
3663      * accordingly to a given locale
3664      */
3665     public String toString(Type t, Locale locale) {
3666         return Printer.createStandardPrinter(messages).visit(t, locale);
3667     }
3668 
3669     /**
3670      * Helper method for generating a string representation of a given type
3671      * accordingly to a given locale
3672      */
3673     public String toString(Symbol t, Locale locale) {
3674         return Printer.createStandardPrinter(messages).visit(t, locale);
3675     }
3676 
3677     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3678     /**
3679      * This toString is slightly more descriptive than the one on Type.
3680      *
3681      * @deprecated Types.toString(Type t, Locale l) provides better support
3682      * for localization
3683      */
3684     @Deprecated
3685     public String toString(Type t) {
3686         if (t.hasTag(FORALL)) {
3687             ForAll forAll = (ForAll)t;
3688             return typaramsString(forAll.tvars) + forAll.qtype;
3689         }
3690         return &quot;&quot; + t;
3691     }
3692     // where
3693         private String typaramsString(List&lt;Type&gt; tvars) {
3694             StringBuilder s = new StringBuilder();
3695             s.append(&#39;&lt;&#39;);
3696             boolean first = true;
3697             for (Type t : tvars) {
3698                 if (!first) s.append(&quot;, &quot;);
3699                 first = false;
3700                 appendTyparamString(((TypeVar)t), s);
3701             }
3702             s.append(&#39;&gt;&#39;);
3703             return s.toString();
3704         }
3705         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3706             buf.append(t);
3707             if (t.getUpperBound() == null ||
3708                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3709                 return;
3710             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3711             Type bound = t.getUpperBound();
3712             if (!bound.isCompound()) {
3713                 buf.append(bound);
3714             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3715                 buf.append(supertype(t));
3716                 for (Type intf : interfaces(t)) {
3717                     buf.append(&#39;&amp;&#39;);
3718                     buf.append(intf);
3719                 }
3720             } else {
3721                 // No superclass was given in bounds.
3722                 // In this case, supertype is Object, erasure is first interface.
3723                 boolean first = true;
3724                 for (Type intf : interfaces(t)) {
3725                     if (!first) buf.append(&#39;&amp;&#39;);
3726                     first = false;
3727                     buf.append(intf);
3728                 }
3729             }
3730         }
3731     // &lt;/editor-fold&gt;
3732 
3733     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3734     /**
3735      * A cache for closures.
3736      *
3737      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3738      * a class or interface type, ordered by ClassSymbol.precedes
3739      * (that is, subclasses come first, arbitrary but fixed
3740      * otherwise).
3741      */
3742     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3743 
3744     /**
3745      * Returns the closure of a class or interface type.
3746      */
3747     public List&lt;Type&gt; closure(Type t) {
3748         List&lt;Type&gt; cl = closureCache.get(t);
3749         if (cl == null) {
3750             Type st = supertype(t);
3751             if (!t.isCompound()) {
3752                 if (st.hasTag(CLASS)) {
3753                     cl = insert(closure(st), t);
3754                 } else if (st.hasTag(TYPEVAR)) {
3755                     cl = closure(st).prepend(t);
3756                 } else {
3757                     cl = List.of(t);
3758                 }
3759             } else {
3760                 cl = closure(supertype(t));
3761             }
3762             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3763                 cl = union(cl, closure(l.head));
3764             closureCache.put(t, cl);
3765         }
3766         return cl;
3767     }
3768 
3769     /**
3770      * Collect types into a new closure (using a @code{ClosureHolder})
3771      */
3772     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3773         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3774                 ClosureHolder::add,
3775                 ClosureHolder::merge,
3776                 ClosureHolder::closure);
3777     }
3778     //where
3779         class ClosureHolder {
3780             List&lt;Type&gt; closure;
3781             final boolean minClosure;
3782             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3783 
3784             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3785                 this.closure = List.nil();
3786                 this.minClosure = minClosure;
3787                 this.shouldSkip = shouldSkip;
3788             }
3789 
3790             void add(Type type) {
3791                 closure = insert(closure, type, shouldSkip);
3792             }
3793 
3794             ClosureHolder merge(ClosureHolder other) {
3795                 closure = union(closure, other.closure, shouldSkip);
3796                 return this;
3797             }
3798 
3799             List&lt;Type&gt; closure() {
3800                 return minClosure ? closureMin(closure) : closure;
3801             }
3802         }
3803 
3804     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3805 
3806     /**
3807      * Insert a type in a closure
3808      */
3809     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3810         if (cl.isEmpty()) {
3811             return cl.prepend(t);
3812         } else if (shouldSkip.test(t, cl.head)) {
3813             return cl;
3814         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3815             return cl.prepend(t);
3816         } else {
3817             // t comes after head, or the two are unrelated
3818             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3819         }
3820     }
3821 
3822     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3823         return insert(cl, t, basicClosureSkip);
3824     }
3825 
3826     /**
3827      * Form the union of two closures
3828      */
3829     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3830         if (cl1.isEmpty()) {
3831             return cl2;
3832         } else if (cl2.isEmpty()) {
3833             return cl1;
3834         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3835             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3836         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3837             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3838         } else {
3839             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3840         }
3841     }
3842 
3843     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3844         return union(cl1, cl2, basicClosureSkip);
3845     }
3846 
3847     /**
3848      * Intersect two closures
3849      */
3850     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3851         if (cl1 == cl2)
3852             return cl1;
3853         if (cl1.isEmpty() || cl2.isEmpty())
3854             return List.nil();
3855         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3856             return intersect(cl1.tail, cl2);
3857         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3858             return intersect(cl1, cl2.tail);
3859         if (isSameType(cl1.head, cl2.head))
3860             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3861         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3862             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3863             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3864                 Type merge = merge(cl1.head,cl2.head);
3865                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3866             }
3867             if (cl1.head.isRaw() || cl2.head.isRaw())
3868                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3869         }
3870         return intersect(cl1.tail, cl2.tail);
3871     }
3872     // where
3873         class TypePair {
3874             final Type t1;
3875             final Type t2;;
3876 
3877             TypePair(Type t1, Type t2) {
3878                 this.t1 = t1;
3879                 this.t2 = t2;
3880             }
3881             @Override
3882             public int hashCode() {
3883                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3884             }
3885             @Override
3886             public boolean equals(Object obj) {
3887                 if (!(obj instanceof TypePair))
3888                     return false;
3889                 TypePair typePair = (TypePair)obj;
3890                 return isSameType(t1, typePair.t1)
3891                     &amp;&amp; isSameType(t2, typePair.t2);
3892             }
3893         }
3894         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3895         private Type merge(Type c1, Type c2) {
3896             ClassType class1 = (ClassType) c1;
3897             List&lt;Type&gt; act1 = class1.getTypeArguments();
3898             ClassType class2 = (ClassType) c2;
3899             List&lt;Type&gt; act2 = class2.getTypeArguments();
3900             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3901             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3902 
3903             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3904                 if (containsType(act1.head, act2.head)) {
3905                     merged.append(act1.head);
3906                 } else if (containsType(act2.head, act1.head)) {
3907                     merged.append(act2.head);
3908                 } else {
3909                     TypePair pair = new TypePair(c1, c2);
3910                     Type m;
3911                     if (mergeCache.add(pair)) {
3912                         m = new WildcardType(lub(wildUpperBound(act1.head),
3913                                                  wildUpperBound(act2.head)),
3914                                              BoundKind.EXTENDS,
3915                                              syms.boundClass);
3916                         mergeCache.remove(pair);
3917                     } else {
3918                         m = new WildcardType(syms.objectType,
3919                                              BoundKind.UNBOUND,
3920                                              syms.boundClass);
3921                     }
3922                     merged.append(m.withTypeVar(typarams.head));
3923                 }
3924                 act1 = act1.tail;
3925                 act2 = act2.tail;
3926                 typarams = typarams.tail;
3927             }
3928             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3929             // There is no spec detailing how type annotations are to
3930             // be inherited.  So set it to noAnnotations for now
3931             return new ClassType(class1.getEnclosingType(), merged.toList(),
3932                                  class1.tsym);
3933         }
3934 
3935     /**
3936      * Return the minimum type of a closure, a compound type if no
3937      * unique minimum exists.
3938      */
3939     private Type compoundMin(List&lt;Type&gt; cl) {
3940         if (cl.isEmpty()) return syms.objectType;
3941         List&lt;Type&gt; compound = closureMin(cl);
3942         if (compound.isEmpty())
3943             return null;
3944         else if (compound.tail.isEmpty())
3945             return compound.head;
3946         else
3947             return makeIntersectionType(compound);
3948     }
3949 
3950     /**
3951      * Return the minimum types of a closure, suitable for computing
3952      * compoundMin or glb.
3953      */
3954     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3955         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3956         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3957         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3958         while (!cl.isEmpty()) {
3959             Type current = cl.head;
3960             boolean keep = !toSkip.contains(current);
3961             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
3962                 // skip lower-bounded variables with a subtype in cl.tail
3963                 for (Type t : cl.tail) {
3964                     if (isSubtypeNoCapture(t, current)) {
3965                         keep = false;
3966                         break;
3967                     }
3968                 }
3969             }
3970             if (keep) {
3971                 if (current.isInterface())
3972                     interfaces.append(current);
3973                 else
3974                     classes.append(current);
3975                 for (Type t : cl.tail) {
3976                     // skip supertypes of &#39;current&#39; in cl.tail
3977                     if (isSubtypeNoCapture(current, t))
3978                         toSkip.add(t);
3979                 }
3980             }
3981             cl = cl.tail;
3982         }
3983         return classes.appendList(interfaces).toList();
3984     }
3985 
3986     /**
3987      * Return the least upper bound of list of types.  if the lub does
3988      * not exist return null.
3989      */
3990     public Type lub(List&lt;Type&gt; ts) {
3991         return lub(ts.toArray(new Type[ts.length()]));
3992     }
3993 
3994     /**
3995      * Return the least upper bound (lub) of set of types.  If the lub
3996      * does not exist return the type of null (bottom).
3997      */
3998     public Type lub(Type... ts) {
3999         final int UNKNOWN_BOUND = 0;
4000         final int ARRAY_BOUND = 1;
4001         final int CLASS_BOUND = 2;
4002 
4003         int[] kinds = new int[ts.length];
4004 
4005         int boundkind = UNKNOWN_BOUND;
4006         for (int i = 0 ; i &lt; ts.length ; i++) {
4007             Type t = ts[i];
4008             switch (t.getTag()) {
4009             case CLASS:
4010                 boundkind |= kinds[i] = CLASS_BOUND;
4011                 break;
4012             case ARRAY:
4013                 boundkind |= kinds[i] = ARRAY_BOUND;
4014                 break;
4015             case  TYPEVAR:
4016                 do {
4017                     t = t.getUpperBound();
4018                 } while (t.hasTag(TYPEVAR));
4019                 if (t.hasTag(ARRAY)) {
4020                     boundkind |= kinds[i] = ARRAY_BOUND;
4021                 } else {
4022                     boundkind |= kinds[i] = CLASS_BOUND;
4023                 }
4024                 break;
4025             default:
4026                 kinds[i] = UNKNOWN_BOUND;
4027                 if (t.isPrimitive())
4028                     return syms.errType;
4029             }
4030         }
4031         switch (boundkind) {
4032         case 0:
4033             return syms.botType;
4034 
4035         case ARRAY_BOUND:
4036             // calculate lub(A[], B[])
4037             Type[] elements = new Type[ts.length];
4038             for (int i = 0 ; i &lt; ts.length ; i++) {
4039                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
4040                 if (elem.isPrimitive()) {
4041                     // if a primitive type is found, then return
4042                     // arraySuperType unless all the types are the
4043                     // same
4044                     Type first = ts[0];
4045                     for (int j = 1 ; j &lt; ts.length ; j++) {
4046                         if (!isSameType(first, ts[j])) {
4047                              // lub(int[], B[]) is Cloneable &amp; Serializable
4048                             return arraySuperType();
4049                         }
4050                     }
4051                     // all the array types are the same, return one
4052                     // lub(int[], int[]) is int[]
4053                     return first;
4054                 }
4055             }
4056             // lub(A[], B[]) is lub(A, B)[]
4057             return new ArrayType(lub(elements), syms.arrayClass);
4058 
4059         case CLASS_BOUND:
4060             // calculate lub(A, B)
4061             int startIdx = 0;
4062             for (int i = 0; i &lt; ts.length ; i++) {
4063                 Type t = ts[i];
4064                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
4065                     break;
4066                 } else {
4067                     startIdx++;
4068                 }
4069             }
4070             Assert.check(startIdx &lt; ts.length);
4071             //step 1 - compute erased candidate set (EC)
4072             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
4073             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4074                 Type t = ts[i];
4075                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
4076                     cl = intersect(cl, erasedSupertypes(t));
4077             }
4078             //step 2 - compute minimal erased candidate set (MEC)
4079             List&lt;Type&gt; mec = closureMin(cl);
4080             //step 3 - for each element G in MEC, compute lci(Inv(G))
4081             List&lt;Type&gt; candidates = List.nil();
4082             for (Type erasedSupertype : mec) {
4083                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4084                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4085                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4086                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4087                 }
4088                 candidates = candidates.appendList(lci);
4089             }
4090             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4091             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4092             return compoundMin(candidates);
4093 
4094         default:
4095             // calculate lub(A, B[])
4096             List&lt;Type&gt; classes = List.of(arraySuperType());
4097             for (int i = 0 ; i &lt; ts.length ; i++) {
4098                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4099                     classes = classes.prepend(ts[i]);
4100             }
4101             // lub(A, B[]) is lub(A, arraySuperType)
4102             return lub(classes);
4103         }
4104     }
4105     // where
4106         List&lt;Type&gt; erasedSupertypes(Type t) {
4107             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4108             for (Type sup : closure(t)) {
4109                 if (sup.hasTag(TYPEVAR)) {
4110                     buf.append(sup);
4111                 } else {
4112                     buf.append(erasure(sup));
4113                 }
4114             }
4115             return buf.toList();
4116         }
4117 
4118         private Type arraySuperType = null;
4119         private Type arraySuperType() {
4120             // initialized lazily to avoid problems during compiler startup
4121             if (arraySuperType == null) {
4122                 synchronized (this) {
4123                     if (arraySuperType == null) {
4124                         // JLS 10.8: all arrays implement Cloneable and Serializable.
4125                         List&lt;Type&gt; ifaces = injectTopInterfaceTypes ?
4126                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType):
4127                                 List.of(syms.serializableType, syms.cloneableType);
4128                         arraySuperType = makeIntersectionType(ifaces, true);
4129                     }
4130                 }
4131             }
4132             return arraySuperType;
4133         }
4134     // &lt;/editor-fold&gt;
4135 
4136     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4137     public Type glb(List&lt;Type&gt; ts) {
4138         Type t1 = ts.head;
4139         for (Type t2 : ts.tail) {
4140             if (t1.isErroneous())
4141                 return t1;
4142             t1 = glb(t1, t2);
4143         }
4144         return t1;
4145     }
4146     //where
4147     public Type glb(Type t, Type s) {
4148         if (s == null)
4149             return t;
4150         else if (t.isPrimitive() || s.isPrimitive())
4151             return syms.errType;
4152         else if (isSubtypeNoCapture(t, s))
4153             return t;
4154         else if (isSubtypeNoCapture(s, t))
4155             return s;
4156 
4157         List&lt;Type&gt; closure = union(closure(t), closure(s));
4158         return glbFlattened(closure, t);
4159     }
4160     //where
4161     /**
4162      * Perform glb for a list of non-primitive, non-error, non-compound types;
4163      * redundant elements are removed.  Bounds should be ordered according to
4164      * {@link Symbol#precedes(TypeSymbol,Types)}.
4165      *
4166      * @param flatBounds List of type to glb
4167      * @param errT Original type to use if the result is an error type
4168      */
4169     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4170         List&lt;Type&gt; bounds = closureMin(flatBounds);
4171 
4172         if (bounds.isEmpty()) {             // length == 0
4173             return syms.objectType;
4174         } else if (bounds.tail.isEmpty()) { // length == 1
4175             return bounds.head;
4176         } else {                            // length &gt; 1
4177             int classCount = 0;
4178             List&lt;Type&gt; cvars = List.nil();
4179             List&lt;Type&gt; lowers = List.nil();
4180             for (Type bound : bounds) {
4181                 if (!bound.isInterface()) {
4182                     classCount++;
4183                     Type lower = cvarLowerBound(bound);
4184                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4185                         cvars = cvars.append(bound);
4186                         lowers = lowers.append(lower);
4187                     }
4188                 }
4189             }
4190             if (classCount &gt; 1) {
4191                 if (lowers.isEmpty()) {
4192                     return createErrorType(errT);
4193                 } else {
4194                     // try again with lower bounds included instead of capture variables
4195                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4196                     return glb(newBounds);
4197                 }
4198             }
4199         }
4200         return makeIntersectionType(bounds);
4201     }
4202     // &lt;/editor-fold&gt;
4203 
4204     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4205     /**
4206      * Compute a hash code on a type.
4207      */
4208     public int hashCode(Type t) {
4209         return hashCode(t, false);
4210     }
4211 
4212     public int hashCode(Type t, boolean strict) {
4213         return strict ?
4214                 hashCodeStrictVisitor.visit(t) :
4215                 hashCodeVisitor.visit(t);
4216     }
4217     // where
4218         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4219         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4220             @Override
4221             public Integer visitTypeVar(TypeVar t, Void ignored) {
4222                 return System.identityHashCode(t);
4223             }
4224         };
4225 
4226         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4227             public Integer visitType(Type t, Void ignored) {
4228                 return t.getTag().ordinal();
4229             }
4230 
4231             @Override
4232             public Integer visitClassType(ClassType t, Void ignored) {
4233                 int result = visit(t.getEnclosingType());
4234                 result *= 127;
4235                 result += t.tsym.flatName().hashCode();
4236                 for (Type s : t.getTypeArguments()) {
4237                     result *= 127;
4238                     result += visit(s);
4239                 }
4240                 return result;
4241             }
4242 
4243             @Override
4244             public Integer visitMethodType(MethodType t, Void ignored) {
4245                 int h = METHOD.ordinal();
4246                 for (List&lt;Type&gt; thisargs = t.argtypes;
4247                      thisargs.tail != null;
4248                      thisargs = thisargs.tail)
4249                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4250                 return (h &lt;&lt; 5) + visit(t.restype);
4251             }
4252 
4253             @Override
4254             public Integer visitWildcardType(WildcardType t, Void ignored) {
4255                 int result = t.kind.hashCode();
4256                 if (t.type != null) {
4257                     result *= 127;
4258                     result += visit(t.type);
4259                 }
4260                 return result;
4261             }
4262 
4263             @Override
4264             public Integer visitArrayType(ArrayType t, Void ignored) {
4265                 return visit(t.elemtype) + 12;
4266             }
4267 
4268             @Override
4269             public Integer visitTypeVar(TypeVar t, Void ignored) {
4270                 return System.identityHashCode(t);
4271             }
4272 
4273             @Override
4274             public Integer visitUndetVar(UndetVar t, Void ignored) {
4275                 return System.identityHashCode(t);
4276             }
4277 
4278             @Override
4279             public Integer visitErrorType(ErrorType t, Void ignored) {
4280                 return 0;
4281             }
4282         }
4283     // &lt;/editor-fold&gt;
4284 
4285     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4286     /**
4287      * Does t have a result that is a subtype of the result type of s,
4288      * suitable for covariant returns?  It is assumed that both types
4289      * are (possibly polymorphic) method types.  Monomorphic method
4290      * types are handled in the obvious way.  Polymorphic method types
4291      * require renaming all type variables of one to corresponding
4292      * type variables in the other, where correspondence is by
4293      * position in the type parameter list. */
4294     public boolean resultSubtype(Type t, Type s, Warner warner) {
4295         List&lt;Type&gt; tvars = t.getTypeArguments();
4296         List&lt;Type&gt; svars = s.getTypeArguments();
4297         Type tres = t.getReturnType();
4298         Type sres = subst(s.getReturnType(), svars, tvars);
4299         return covariantReturnType(tres, sres, warner);
4300     }
4301 
4302     /**
4303      * Return-Type-Substitutable.
4304      * @jls 8.4.5 Method Result
4305      */
4306     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4307         if (hasSameArgs(r1, r2))
4308             return resultSubtype(r1, r2, noWarnings);
4309         else
4310             return covariantReturnType(r1.getReturnType(),
4311                                        erasure(r2.getReturnType()),
4312                                        noWarnings);
4313     }
4314 
4315     public boolean returnTypeSubstitutable(Type r1,
4316                                            Type r2, Type r2res,
4317                                            Warner warner) {
4318         if (isSameType(r1.getReturnType(), r2res))
4319             return true;
4320         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4321             return false;
4322 
4323         if (hasSameArgs(r1, r2))
4324             return covariantReturnType(r1.getReturnType(), r2res, warner);
4325         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4326             return true;
4327         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4328             return false;
4329         warner.warn(LintCategory.UNCHECKED);
4330         return true;
4331     }
4332 
4333     /**
4334      * Is t an appropriate return type in an overrider for a
4335      * method that returns s?
4336      */
4337     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4338         return
4339             isSameType(t, s) ||
4340             !t.isPrimitive() &amp;&amp;
4341             !s.isPrimitive() &amp;&amp;
4342             isAssignable(t, s, warner);
4343     }
4344     // &lt;/editor-fold&gt;
4345 
4346     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4347     /**
4348      * Return the class that boxes the given primitive.
4349      */
4350     public ClassSymbol boxedClass(Type t) {
4351         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4352     }
4353 
4354     /**
4355      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4356      */
4357     public Type boxedTypeOrType(Type t) {
4358         return t.isPrimitive() ?
4359             boxedClass(t).type :
4360             t;
4361     }
4362 
4363     /**
4364      * Return the primitive type corresponding to a boxed type.
4365      */
4366     public Type unboxedType(Type t) {
4367         for (int i=0; i&lt;syms.boxedName.length; i++) {
4368             Name box = syms.boxedName[i];
4369             if (box != null &amp;&amp;
4370                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4371                 return syms.typeOfTag[i];
4372         }
4373         return Type.noType;
4374     }
4375 
4376     /**
4377      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4378      */
4379     public Type unboxedTypeOrType(Type t) {
4380         Type unboxedType = unboxedType(t);
4381         return unboxedType.hasTag(NONE) ? t : unboxedType;
4382     }
4383     // &lt;/editor-fold&gt;
4384 
4385     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4386     /*
4387      * JLS 5.1.10 Capture Conversion:
4388      *
4389      * Let G name a generic type declaration with n formal type
4390      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4391      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4392      * where, for 1 &lt;= i &lt;= n:
4393      *
4394      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4395      *   Si is a fresh type variable whose upper bound is
4396      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4397      *   type.
4398      *
4399      * + If Ti is a wildcard type argument of the form ? extends Bi,
4400      *   then Si is a fresh type variable whose upper bound is
4401      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4402      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4403      *   a compile-time error if for any two classes (not interfaces)
4404      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4405      *
4406      * + If Ti is a wildcard type argument of the form ? super Bi,
4407      *   then Si is a fresh type variable whose upper bound is
4408      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4409      *
4410      * + Otherwise, Si = Ti.
4411      *
4412      * Capture conversion on any type other than a parameterized type
4413      * (4.5) acts as an identity conversion (5.1.1). Capture
4414      * conversions never require a special action at run time and
4415      * therefore never throw an exception at run time.
4416      *
4417      * Capture conversion is not applied recursively.
4418      */
4419     /**
4420      * Capture conversion as specified by the JLS.
4421      */
4422 
4423     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4424         List&lt;Type&gt; buf = List.nil();
4425         for (Type t : ts) {
4426             buf = buf.prepend(capture(t));
4427         }
4428         return buf.reverse();
4429     }
4430 
4431     public Type capture(Type t) {
4432         if (!t.hasTag(CLASS)) {
4433             return t;
4434         }
4435         if (t.getEnclosingType() != Type.noType) {
4436             Type capturedEncl = capture(t.getEnclosingType());
4437             if (capturedEncl != t.getEnclosingType()) {
4438                 Type type1 = memberType(capturedEncl, t.tsym);
4439                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4440             }
4441         }
4442         ClassType cls = (ClassType)t;
4443         if (cls.isRaw() || !cls.isParameterized())
4444             return cls;
4445 
4446         ClassType G = (ClassType)cls.asElement().asType();
4447         List&lt;Type&gt; A = G.getTypeArguments();
4448         List&lt;Type&gt; T = cls.getTypeArguments();
4449         List&lt;Type&gt; S = freshTypeVariables(T);
4450 
4451         List&lt;Type&gt; currentA = A;
4452         List&lt;Type&gt; currentT = T;
4453         List&lt;Type&gt; currentS = S;
4454         boolean captured = false;
4455         while (!currentA.isEmpty() &amp;&amp;
4456                !currentT.isEmpty() &amp;&amp;
4457                !currentS.isEmpty()) {
4458             if (currentS.head != currentT.head) {
4459                 captured = true;
4460                 WildcardType Ti = (WildcardType)currentT.head;
4461                 Type Ui = currentA.head.getUpperBound();
4462                 CapturedType Si = (CapturedType)currentS.head;
4463                 if (Ui == null)
4464                     Ui = syms.objectType;
4465                 switch (Ti.kind) {
4466                 case UNBOUND:
4467                     Si.setUpperBound( subst(Ui, A, S) );
4468                     Si.lower = syms.botType;
4469                     break;
4470                 case EXTENDS:
4471                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4472                     Si.lower = syms.botType;
4473                     break;
4474                 case SUPER:
4475                     Si.setUpperBound( subst(Ui, A, S) );
4476                     Si.lower = Ti.getSuperBound();
4477                     break;
4478                 }
4479                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4480                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4481                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4482                     !Si.lower.hasTag(ERROR) &amp;&amp;
4483                     isSameType(tmpBound, tmpLower)) {
4484                     currentS.head = Si.getUpperBound();
4485                 }
4486             }
4487             currentA = currentA.tail;
4488             currentT = currentT.tail;
4489             currentS = currentS.tail;
4490         }
4491         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4492             return erasure(t); // some &quot;rare&quot; type involved
4493 
4494         if (captured)
4495             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4496                                  cls.getMetadata());
4497         else
4498             return t;
4499     }
4500     // where
4501         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4502             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4503             for (Type t : types) {
4504                 if (t.hasTag(WILDCARD)) {
4505                     Type bound = ((WildcardType)t).getExtendsBound();
4506                     if (bound == null)
4507                         bound = syms.objectType;
4508                     result.append(new CapturedType(capturedName,
4509                                                    syms.noSymbol,
4510                                                    bound,
4511                                                    syms.botType,
4512                                                    (WildcardType)t));
4513                 } else {
4514                     result.append(t);
4515                 }
4516             }
4517             return result.toList();
4518         }
4519     // &lt;/editor-fold&gt;
4520 
4521     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4522     private boolean sideCast(Type from, Type to, Warner warn) {
4523         // We are casting from type $from$ to type $to$, which are
4524         // non-final unrelated types.  This method
4525         // tries to reject a cast by transferring type parameters
4526         // from $to$ to $from$ by common superinterfaces.
4527         boolean reverse = false;
4528         Type target = to;
4529         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4530             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4531             reverse = true;
4532             to = from;
4533             from = target;
4534         }
4535         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4536         boolean giveWarning = commonSupers.isEmpty();
4537         // The arguments to the supers could be unified here to
4538         // get a more accurate analysis
4539         while (commonSupers.nonEmpty()) {
4540             Type t1 = asSuper(from, commonSupers.head.tsym);
4541             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4542             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4543                 return false;
4544             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4545             commonSupers = commonSupers.tail;
4546         }
4547         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4548             warn.warn(LintCategory.UNCHECKED);
4549         return true;
4550     }
4551 
4552     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4553         // We are casting from type $from$ to type $to$, which are
4554         // unrelated types one of which is final and the other of
4555         // which is an interface.  This method
4556         // tries to reject a cast by transferring type parameters
4557         // from the final class to the interface.
4558         boolean reverse = false;
4559         Type target = to;
4560         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4561             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4562             reverse = true;
4563             to = from;
4564             from = target;
4565         }
4566         Assert.check((from.tsym.flags() &amp; FINAL) != 0);
4567         Type t1 = asSuper(from, to.tsym);
4568         if (t1 == null) return false;
4569         Type t2 = to;
4570         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4571             return false;
4572         if (!isReifiable(target) &amp;&amp;
4573             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4574             warn.warn(LintCategory.UNCHECKED);
4575         return true;
4576     }
4577 
4578     private boolean giveWarning(Type from, Type to) {
4579         List&lt;Type&gt; bounds = to.isCompound() ?
4580                 directSupertypes(to) : List.of(to);
4581         for (Type b : bounds) {
4582             Type subFrom = asSub(from, b.tsym);
4583             if (b.isParameterized() &amp;&amp;
4584                     (!(isUnbounded(b) ||
4585                     isSubtype(from, b) ||
4586                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4587                 return true;
4588             }
4589         }
4590         return false;
4591     }
4592 
4593     private List&lt;Type&gt; superClosure(Type t, Type s) {
4594         List&lt;Type&gt; cl = List.nil();
4595         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4596             if (isSubtype(s, erasure(l.head))) {
4597                 cl = insert(cl, l.head);
4598             } else {
4599                 cl = union(cl, superClosure(l.head, s));
4600             }
4601         }
4602         return cl;
4603     }
4604 
4605     private boolean containsTypeEquivalent(Type t, Type s) {
4606         return isSameType(t, s) || // shortcut
4607             containsType(t, s) &amp;&amp; containsType(s, t);
4608     }
4609 
4610     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4611     /**
4612      * Adapt a type by computing a substitution which maps a source
4613      * type to a target type.
4614      *
4615      * @param source    the source type
4616      * @param target    the target type
4617      * @param from      the type variables of the computed substitution
4618      * @param to        the types of the computed substitution.
4619      */
4620     public void adapt(Type source,
4621                        Type target,
4622                        ListBuffer&lt;Type&gt; from,
4623                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4624         new Adapter(from, to).adapt(source, target);
4625     }
4626 
4627     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4628 
4629         ListBuffer&lt;Type&gt; from;
4630         ListBuffer&lt;Type&gt; to;
4631         Map&lt;Symbol,Type&gt; mapping;
4632 
4633         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4634             this.from = from;
4635             this.to = to;
4636             mapping = new HashMap&lt;&gt;();
4637         }
4638 
4639         public void adapt(Type source, Type target) throws AdaptFailure {
4640             visit(source, target);
4641             List&lt;Type&gt; fromList = from.toList();
4642             List&lt;Type&gt; toList = to.toList();
4643             while (!fromList.isEmpty()) {
4644                 Type val = mapping.get(fromList.head.tsym);
4645                 if (toList.head != val)
4646                     toList.head = val;
4647                 fromList = fromList.tail;
4648                 toList = toList.tail;
4649             }
4650         }
4651 
4652         @Override
4653         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4654             if (target.hasTag(CLASS))
4655                 adaptRecursive(source.allparams(), target.allparams());
4656             return null;
4657         }
4658 
4659         @Override
4660         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4661             if (target.hasTag(ARRAY))
4662                 adaptRecursive(elemtype(source), elemtype(target));
4663             return null;
4664         }
4665 
4666         @Override
4667         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4668             if (source.isExtendsBound())
4669                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4670             else if (source.isSuperBound())
4671                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4672             return null;
4673         }
4674 
4675         @Override
4676         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4677             // Check to see if there is
4678             // already a mapping for $source$, in which case
4679             // the old mapping will be merged with the new
4680             Type val = mapping.get(source.tsym);
4681             if (val != null) {
4682                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4683                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4684                         ? target : val;
4685                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4686                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4687                         ? val : target;
4688                 } else if (!isSameType(val, target)) {
4689                     throw new AdaptFailure();
4690                 }
4691             } else {
4692                 val = target;
4693                 from.append(source);
4694                 to.append(target);
4695             }
4696             mapping.put(source.tsym, val);
4697             return null;
4698         }
4699 
4700         @Override
4701         public Void visitType(Type source, Type target) {
4702             return null;
4703         }
4704 
4705         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4706 
4707         private void adaptRecursive(Type source, Type target) {
4708             TypePair pair = new TypePair(source, target);
4709             if (cache.add(pair)) {
4710                 try {
4711                     visit(source, target);
4712                 } finally {
4713                     cache.remove(pair);
4714                 }
4715             }
4716         }
4717 
4718         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4719             if (source.length() == target.length()) {
4720                 while (source.nonEmpty()) {
4721                     adaptRecursive(source.head, target.head);
4722                     source = source.tail;
4723                     target = target.tail;
4724                 }
4725             }
4726         }
4727     }
4728 
4729     public static class AdaptFailure extends RuntimeException {
4730         static final long serialVersionUID = -7490231548272701566L;
4731     }
4732 
4733     private void adaptSelf(Type t,
4734                            ListBuffer&lt;Type&gt; from,
4735                            ListBuffer&lt;Type&gt; to) {
4736         try {
4737             //if (t.tsym.type != t)
4738                 adapt(t.tsym.type, t, from, to);
4739         } catch (AdaptFailure ex) {
4740             // Adapt should never fail calculating a mapping from
4741             // t.tsym.type to t as there can be no merge problem.
4742             throw new AssertionError(ex);
4743         }
4744     }
4745     // &lt;/editor-fold&gt;
4746 
4747     /**
4748      * Rewrite all type variables (universal quantifiers) in the given
4749      * type to wildcards (existential quantifiers).  This is used to
4750      * determine if a cast is allowed.  For example, if high is true
4751      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4752      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4753      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4754      * List&lt;Integer&gt;} with a warning.
4755      * @param t a type
4756      * @param high if true return an upper bound; otherwise a lower
4757      * bound
4758      * @param rewriteTypeVars only rewrite captured wildcards if false;
4759      * otherwise rewrite all type variables
4760      * @return the type rewritten with wildcards (existential
4761      * quantifiers) only
4762      */
4763     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4764         return new Rewriter(high, rewriteTypeVars).visit(t);
4765     }
4766 
4767     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4768 
4769         boolean high;
4770         boolean rewriteTypeVars;
4771 
4772         Rewriter(boolean high, boolean rewriteTypeVars) {
4773             this.high = high;
4774             this.rewriteTypeVars = rewriteTypeVars;
4775         }
4776 
4777         @Override
4778         public Type visitClassType(ClassType t, Void s) {
4779             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4780             boolean changed = false;
4781             for (Type arg : t.allparams()) {
4782                 Type bound = visit(arg);
4783                 if (arg != bound) {
4784                     changed = true;
4785                 }
4786                 rewritten.append(bound);
4787             }
4788             if (changed)
4789                 return subst(t.tsym.type,
4790                         t.tsym.type.allparams(),
4791                         rewritten.toList());
4792             else
4793                 return t;
4794         }
4795 
4796         public Type visitType(Type t, Void s) {
4797             return t;
4798         }
4799 
4800         @Override
4801         public Type visitCapturedType(CapturedType t, Void s) {
4802             Type w_bound = t.wildcard.type;
4803             Type bound = w_bound.contains(t) ?
4804                         erasure(w_bound) :
4805                         visit(w_bound);
4806             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4807         }
4808 
4809         @Override
4810         public Type visitTypeVar(TypeVar t, Void s) {
4811             if (rewriteTypeVars) {
4812                 Type bound = t.getUpperBound().contains(t) ?
4813                         erasure(t.getUpperBound()) :
4814                         visit(t.getUpperBound());
4815                 return rewriteAsWildcardType(bound, t, EXTENDS);
4816             } else {
4817                 return t;
4818             }
4819         }
4820 
4821         @Override
4822         public Type visitWildcardType(WildcardType t, Void s) {
4823             Type bound2 = visit(t.type);
4824             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4825         }
4826 
4827         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4828             switch (bk) {
4829                case EXTENDS: return high ?
4830                        makeExtendsWildcard(B(bound), formal) :
4831                        makeExtendsWildcard(syms.objectType, formal);
4832                case SUPER: return high ?
4833                        makeSuperWildcard(syms.botType, formal) :
4834                        makeSuperWildcard(B(bound), formal);
4835                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4836                default:
4837                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4838                    return null;
4839             }
4840         }
4841 
4842         Type B(Type t) {
4843             while (t.hasTag(WILDCARD)) {
4844                 WildcardType w = (WildcardType)t;
4845                 t = high ?
4846                     w.getExtendsBound() :
4847                     w.getSuperBound();
4848                 if (t == null) {
4849                     t = high ? syms.objectType : syms.botType;
4850                 }
4851             }
4852             return t;
4853         }
4854     }
4855 
4856 
4857     /**
4858      * Create a wildcard with the given upper (extends) bound; create
4859      * an unbounded wildcard if bound is Object.
4860      *
4861      * @param bound the upper bound
4862      * @param formal the formal type parameter that will be
4863      * substituted by the wildcard
4864      */
4865     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4866         if (bound == syms.objectType) {
4867             return new WildcardType(syms.objectType,
4868                                     BoundKind.UNBOUND,
4869                                     syms.boundClass,
4870                                     formal);
4871         } else {
4872             return new WildcardType(bound,
4873                                     BoundKind.EXTENDS,
4874                                     syms.boundClass,
4875                                     formal);
4876         }
4877     }
4878 
4879     /**
4880      * Create a wildcard with the given lower (super) bound; create an
4881      * unbounded wildcard if bound is bottom (type of {@code null}).
4882      *
4883      * @param bound the lower bound
4884      * @param formal the formal type parameter that will be
4885      * substituted by the wildcard
4886      */
4887     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4888         if (bound.hasTag(BOT)) {
4889             return new WildcardType(syms.objectType,
4890                                     BoundKind.UNBOUND,
4891                                     syms.boundClass,
4892                                     formal);
4893         } else {
4894             return new WildcardType(bound,
4895                                     BoundKind.SUPER,
4896                                     syms.boundClass,
4897                                     formal);
4898         }
4899     }
4900 
4901     /**
4902      * A wrapper for a type that allows use in sets.
4903      */
4904     public static class UniqueType {
4905         public final Type type;
4906         final Types types;
4907         private boolean encodeTypeSig;
4908 
4909         public UniqueType(Type type, Types types, boolean encodeTypeSig) {
4910             this.type = type;
4911             this.types = types;
4912             this.encodeTypeSig = encodeTypeSig;
4913         }
4914 
4915         public UniqueType(Type type, Types types) {
4916             this(type, types, true);
4917         }
4918 
4919         public int hashCode() {
4920             return types.hashCode(type);
4921         }
4922 
4923         public boolean equals(Object obj) {
4924             return (obj instanceof UniqueType) &amp;&amp;
4925                 types.isSameType(type, ((UniqueType)obj).type);
4926         }
4927 
4928         public boolean encodeTypeSig() {
4929             return encodeTypeSig;
4930         }
4931 
4932         public String toString() {
4933             return type.toString();
4934         }
4935 
4936     }
4937     // &lt;/editor-fold&gt;
4938 
4939     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4940     /**
4941      * A default visitor for types.  All visitor methods except
4942      * visitType are implemented by delegating to visitType.  Concrete
4943      * subclasses must provide an implementation of visitType and can
4944      * override other methods as needed.
4945      *
4946      * @param &lt;R&gt; the return type of the operation implemented by this
4947      * visitor; use Void if no return type is needed.
4948      * @param &lt;S&gt; the type of the second argument (the first being the
4949      * type itself) of the operation implemented by this visitor; use
4950      * Void if a second argument is not needed.
4951      */
4952     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4953         final public R visit(Type t, S s)               { return t.accept(this, s); }
4954         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4955         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
4956         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
4957         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
4958         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
4959         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
4960         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
4961         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
4962         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
4963         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
4964         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
4965     }
4966 
4967     /**
4968      * A default visitor for symbols.  All visitor methods except
4969      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
4970      * subclasses must provide an implementation of visitSymbol and can
4971      * override other methods as needed.
4972      *
4973      * @param &lt;R&gt; the return type of the operation implemented by this
4974      * visitor; use Void if no return type is needed.
4975      * @param &lt;S&gt; the type of the second argument (the first being the
4976      * symbol itself) of the operation implemented by this visitor; use
4977      * Void if a second argument is not needed.
4978      */
4979     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
4980         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
4981         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
4982         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
4983         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
4984         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
4985         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
4986         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
4987     }
4988 
4989     /**
4990      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
4991      * captured wildcards, for-all types (generic methods), and
4992      * undetermined type variables (part of inference) are hidden.
4993      * Captured wildcards are hidden by treating them as type
4994      * variables and the rest are hidden by visiting their qtypes.
4995      *
4996      * @param &lt;R&gt; the return type of the operation implemented by this
4997      * visitor; use Void if no return type is needed.
4998      * @param &lt;S&gt; the type of the second argument (the first being the
4999      * type itself) of the operation implemented by this visitor; use
5000      * Void if a second argument is not needed.
5001      */
5002     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
5003         @Override
5004         public R visitCapturedType(CapturedType t, S s) {
5005             return visitTypeVar(t, s);
5006         }
5007         @Override
5008         public R visitForAll(ForAll t, S s) {
5009             return visit(t.qtype, s);
5010         }
5011         @Override
5012         public R visitUndetVar(UndetVar t, S s) {
5013             return visit(t.qtype, s);
5014         }
5015     }
5016 
5017     /**
5018      * A plain relation on types.  That is a 2-ary function on the
5019      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
5020      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
5021      */
5022     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
5023 
5024     /**
5025      * A convenience visitor for implementing operations that only
5026      * require one argument (the type itself), that is, unary
5027      * operations.
5028      *
5029      * @param &lt;R&gt; the return type of the operation implemented by this
5030      * visitor; use Void if no return type is needed.
5031      */
5032     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
5033         final public R visit(Type t) { return t.accept(this, null); }
5034     }
5035 
5036     /**
5037      * A visitor for implementing a mapping from types to types.  The
5038      * default behavior of this class is to implement the identity
5039      * mapping (mapping a type to itself).  This can be overridden in
5040      * subclasses.
5041      *
5042      * @param &lt;S&gt; the type of the second argument (the first being the
5043      * type itself) of this mapping; use Void if a second argument is
5044      * not needed.
5045      */
5046     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
5047         final public Type visit(Type t) { return t.accept(this, null); }
5048         public Type visitType(Type t, S s) { return t; }
5049     }
5050 
5051     /**
5052      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
5053      * This class implements the functional interface {@code Function}, that allows it to be used
5054      * fluently in stream-like processing.
5055      */
5056     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
5057         @Override
5058         public Type apply(Type type) { return visit(type); }
5059 
5060         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
5061             return ts.map(t -&gt; visit(t, s));
5062         }
5063 
5064         @Override
5065         public Type visitCapturedType(CapturedType t, S s) {
5066             return visitTypeVar(t, s);
5067         }
5068     }
5069     // &lt;/editor-fold&gt;
5070 
5071 
5072     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
5073 
5074     public RetentionPolicy getRetention(Attribute.Compound a) {
5075         return getRetention(a.type.tsym);
5076     }
5077 
5078     public RetentionPolicy getRetention(TypeSymbol sym) {
5079         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
5080         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
5081         if (c != null) {
5082             Attribute value = c.member(names.value);
5083             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
5084                 Name levelName = ((Attribute.Enum)value).value.name;
5085                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
5086                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
5087                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
5088                 else ;// /* fail soft */ throw new AssertionError(levelName);
5089             }
5090         }
5091         return vis;
5092     }
5093     // &lt;/editor-fold&gt;
5094 
5095     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5096 
5097     public static abstract class SignatureGenerator {
5098 
5099         public static class InvalidSignatureException extends RuntimeException {
5100             private static final long serialVersionUID = 0;
5101 
5102             private final transient Type type;
5103 
5104             InvalidSignatureException(Type type) {
5105                 this.type = type;
5106             }
5107 
5108             public Type type() {
5109                 return type;
5110             }
5111         }
5112 
5113         private final Types types;
5114 
5115         protected abstract void append(char ch);
5116         protected abstract void append(byte[] ba);
5117         protected abstract void append(Name name);
5118         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5119 
5120         protected SignatureGenerator(Types types) {
5121             this.types = types;
5122         }
5123 
5124         protected void reportIllegalSignature(Type t) {
5125             throw new InvalidSignatureException(t);
5126         }
5127 
5128         /**
5129          * Assemble signature of given type in string buffer.
5130          */
5131         public void assembleSig(Type type) {
5132             switch (type.getTag()) {
5133                 case BYTE:
5134                     append(&#39;B&#39;);
5135                     break;
5136                 case SHORT:
5137                     append(&#39;S&#39;);
5138                     break;
5139                 case CHAR:
5140                     append(&#39;C&#39;);
5141                     break;
5142                 case INT:
5143                     append(&#39;I&#39;);
5144                     break;
5145                 case LONG:
5146                     append(&#39;J&#39;);
5147                     break;
5148                 case FLOAT:
5149                     append(&#39;F&#39;);
5150                     break;
5151                 case DOUBLE:
5152                     append(&#39;D&#39;);
5153                     break;
5154                 case BOOLEAN:
5155                     append(&#39;Z&#39;);
5156                     break;
5157                 case VOID:
5158                     append(&#39;V&#39;);
5159                     break;
5160                 case CLASS:
5161                     if (type.isCompound()) {
5162                         reportIllegalSignature(type);
5163                     }
5164                     if (types.isValue(type))
5165                         append(&#39;Q&#39;);
5166                     else
5167                         append(&#39;L&#39;);
5168                     assembleClassSig(type);
5169                     append(&#39;;&#39;);
5170                     break;
5171                 case ARRAY:
5172                     ArrayType at = (ArrayType) type;
5173                     append(&#39;[&#39;);
5174                     assembleSig(at.elemtype);
5175                     break;
5176                 case METHOD:
5177                     MethodType mt = (MethodType) type;
5178                     append(&#39;(&#39;);
5179                     assembleSig(mt.argtypes);
5180                     append(&#39;)&#39;);
5181                     assembleSig(mt.restype);
5182                     if (hasTypeVar(mt.thrown)) {
5183                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5184                             append(&#39;^&#39;);
5185                             assembleSig(l.head);
5186                         }
5187                     }
5188                     break;
5189                 case WILDCARD: {
5190                     Type.WildcardType ta = (Type.WildcardType) type;
5191                     switch (ta.kind) {
5192                         case SUPER:
5193                             append(&#39;-&#39;);
5194                             assembleSig(ta.type);
5195                             break;
5196                         case EXTENDS:
5197                             append(&#39;+&#39;);
5198                             assembleSig(ta.type);
5199                             break;
5200                         case UNBOUND:
5201                             append(&#39;*&#39;);
5202                             break;
5203                         default:
5204                             throw new AssertionError(ta.kind);
5205                     }
5206                     break;
5207                 }
5208                 case TYPEVAR:
5209                     if (((TypeVar)type).isCaptured()) {
5210                         reportIllegalSignature(type);
5211                     }
5212                     append(&#39;T&#39;);
5213                     append(type.tsym.name);
5214                     append(&#39;;&#39;);
5215                     break;
5216                 case FORALL:
5217                     Type.ForAll ft = (Type.ForAll) type;
5218                     assembleParamsSig(ft.tvars);
5219                     assembleSig(ft.qtype);
5220                     break;
5221                 default:
5222                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5223             }
5224         }
5225 
5226         public boolean hasTypeVar(List&lt;Type&gt; l) {
5227             while (l.nonEmpty()) {
5228                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5229                     return true;
5230                 }
5231                 l = l.tail;
5232             }
5233             return false;
5234         }
5235 
5236         public void assembleClassSig(Type type) {
5237             ClassType ct = (ClassType) type;
5238             ClassSymbol c = (ClassSymbol) ct.tsym;
5239             classReference(c);
5240             Type outer = ct.getEnclosingType();
5241             if (outer.allparams().nonEmpty()) {
5242                 boolean rawOuter =
5243                         c.owner.kind == MTH || // either a local class
5244                         c.name == types.names.empty; // or anonymous
5245                 assembleClassSig(rawOuter
5246                         ? types.erasure(outer)
5247                         : outer);
5248                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5249                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5250                 append(rawOuter
5251                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5252                         : c.name);
5253             } else {
5254                 append(externalize(c.flatname));
5255             }
5256             if (ct.getTypeArguments().nonEmpty()) {
5257                 append(&#39;&lt;&#39;);
5258                 assembleSig(ct.getTypeArguments());
5259                 append(&#39;&gt;&#39;);
5260             }
5261         }
5262 
5263         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5264             append(&#39;&lt;&#39;);
5265             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5266                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5267                 append(tvar.tsym.name);
5268                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5269                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5270                     append(&#39;:&#39;);
5271                 }
5272                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5273                     append(&#39;:&#39;);
5274                     assembleSig(l.head);
5275                 }
5276             }
5277             append(&#39;&gt;&#39;);
5278         }
5279 
5280         public void assembleSig(List&lt;Type&gt; types) {
5281             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5282                 assembleSig(ts.head);
5283             }
5284         }
5285     }
5286 
5287     public Type constantType(LoadableConstant c) {
5288         switch (c.poolTag()) {
5289             case ClassFile.CONSTANT_Class:
5290                 return syms.classType;
5291             case ClassFile.CONSTANT_String:
5292                 return syms.stringType;
5293             case ClassFile.CONSTANT_Integer:
5294                 return syms.intType;
5295             case ClassFile.CONSTANT_Float:
5296                 return syms.floatType;
5297             case ClassFile.CONSTANT_Long:
5298                 return syms.longType;
5299             case ClassFile.CONSTANT_Double:
5300                 return syms.doubleType;
5301             case ClassFile.CONSTANT_MethodHandle:
5302                 return syms.methodHandleType;
5303             case ClassFile.CONSTANT_MethodType:
5304                 return syms.methodTypeType;
5305             case ClassFile.CONSTANT_Dynamic:
5306                 return ((DynamicVarSymbol)c).type;
5307             default:
5308                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5309         }
5310     }
5311     // &lt;/editor-fold&gt;
5312 
5313     public void newRound() {
5314         descCache._map.clear();
5315         isDerivedRawCache.clear();
5316         implCache._map.clear();
5317         membersCache._map.clear();
5318         closureCache.clear();
5319     }
5320 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
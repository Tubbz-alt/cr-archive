<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Flags.Flag;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
  52 import static com.sun.tools.javac.code.Flags.asFlagSet;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
  82     private static final int infixPrecedenceLevels = 10;
  83 
  84     /** Is the parser instantiated to parse a module-info file ?
  85      */
  86     private final boolean parseModuleInfo;
  87 
  88     /** The scanner used for lexical analysis.
  89      */
  90     protected Lexer S;
  91 
  92     /** The factory to be used for abstract syntax tree construction.
  93      */
  94     protected TreeMaker F;
  95 
  96     /** The log to be used for error diagnostics.
  97      */
  98     private Log log;
  99 
 100     /** The Source language setting. */
 101     private Source source;
 102 
 103     /** The Preview language setting. */
 104     private Preview preview;
 105 
 106     /** The name table. */
 107     private Names names;
 108 
 109     /** End position mappings container */
 110     protected final AbstractEndPosTable endPosTable;
 111 
 112     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 113     // the presence of type annotations even though they are not ambiguous
 114     // in the absence of type annotations.  Consider this code:
 115     //   void m(String [] m) { }
 116     //   void m(String ... m) { }
 117     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 118     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 119     // if the next token is ... and in that case parse an ellipsis.  But in
 120     // the presence of type annotations:
 121     //   void m(String @A [] m) { }
 122     //   void m(String @A ... m) { }
 123     // no finite lookahead is enough to determine whether to read array
 124     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 125     // bracketsOpt first reads all the leading annotations and only then
 126     // discovers that it needs to fail.  bracketsOpt needs a way to push
 127     // back the extra annotations that it read.  (But, bracketsOpt should
 128     // not *always* be allowed to push back extra annotations that it finds
 129     // -- in most contexts, any such extra annotation is an error.
 130     //
 131     // The following two variables permit type annotations that have
 132     // already been read to be stored for later use.  Alternate
 133     // implementations are possible but would cause much larger changes to
 134     // the parser.
 135 
 136     /** Type annotations that have already been read but have not yet been used. **/
 137     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 138 
 139     /**
 140      * If the parser notices extra annotations, then it either immediately
 141      * issues an error (if this variable is false) or places the extra
 142      * annotations in variable typeAnnotationsPushedBack (if this variable
 143      * is true).
 144      */
 145     private boolean permitTypeAnnotationsPushBack = false;
 146 
 147     interface ErrorRecoveryAction {
 148         JCTree doRecover(JavacParser parser);
 149     }
 150 
 151     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 152         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 153         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 154     }
 155 
 156     /** Construct a parser from a given scanner, tree factory and log.
 157      */
 158     protected JavacParser(ParserFactory fac,
 159                           Lexer S,
 160                           boolean keepDocComments,
 161                           boolean keepLineMap,
 162                           boolean keepEndPositions) {
 163         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 164 
 165     }
 166     /** Construct a parser from a given scanner, tree factory and log.
 167      */
 168     protected JavacParser(ParserFactory fac,
 169                      Lexer S,
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
 193     }
 194 
 195     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 196         return  keepEndPositions
 197                 ? new SimpleEndPosTable(this)
 198                 : new EmptyEndPosTable(this);
 199     }
 200 
 201     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 202         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 203     }
 204 
 205     /** Switch: should we fold strings?
 206      */
 207     boolean allowStringFolding;
 208 
 209     /** Switch: should we allow withField operator at source level ?
 210     */
 211     boolean allowWithFieldOperator;
 212 
 213     /** Switch: should we keep docComments?
 214      */
 215     boolean keepDocComments;
 216 
 217     /** Switch: should we keep line table?
 218      */
 219     boolean keepLineMap;
 220 
 221     /** Switch: is &quot;this&quot; allowed as an identifier?
 222      * This is needed to parse receiver types.
 223      */
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 
 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed
 244      *     mode |= NOQUESTION   : type terminal ? is not allowed
 245      */
 246     protected static final int EXPR = 0x1;
 247     protected static final int TYPE = 0x2;
 248     protected static final int NOPARAMS = 0x4;
 249     protected static final int TYPEARG = 0x8;
 250     protected static final int DIAMOND = 0x10;
 251     protected static final int NOLAMBDA = 0x20;
 252     protected static final int NOQUESTION = 0x40;
 253 
 254     protected void selectExprMode() {
 255         mode = (mode &amp; NOLAMBDA) | EXPR;
 256     }
 257 
 258     protected void selectTypeMode() {
 259         mode = (mode &amp; NOLAMBDA) | TYPE;
 260     }
 261 
 262     /** The current mode.
 263      */
 264     protected int mode = 0;
 265 
 266     /** The mode of the term that was parsed last.
 267      */
 268     protected int lastmode = 0;
 269 
 270     /* ---------- token management -------------- */
 271 
 272     protected Token token;
 273 
 274     public Token token() {
 275         return token;
 276     }
 277 
 278     public void nextToken() {
 279         S.nextToken();
 280         token = S.token();
 281     }
 282 
 283     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 284         return peekToken(0, tk);
 285     }
 286 
 287     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 288         return tk.accepts(S.token(lookahead + 1).kind);
 289     }
 290 
 291     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 292         return peekToken(0, tk1, tk2);
 293     }
 294 
 295     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 296         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 297                 tk2.accepts(S.token(lookahead + 2).kind);
 298     }
 299 
 300     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 301         return peekToken(0, tk1, tk2, tk3);
 302     }
 303 
 304     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 305         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 306                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 307                 tk3.accepts(S.token(lookahead + 3).kind);
 308     }
 309 
 310     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {
 311         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 312                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 313                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;
 314                 tk4.accepts(S.token(lookahead + 4).kind);
 315     }
 316 
 317     @SuppressWarnings(&quot;unchecked&quot;)
 318     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 319         return peekToken(0, kinds);
 320     }
 321 
 322     @SuppressWarnings(&quot;unchecked&quot;)
 323     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 324         for (; lookahead &lt; kinds.length ; lookahead++) {
 325             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 326                 return false;
 327             }
 328         }
 329         return true;
 330     }
 331 
 332     /* ---------- error recovery -------------- */
 333 
 334     private JCErroneous errorTree;
 335 
 336     /** Skip forward until a suitable stop token is found.
 337      */
 338     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 339          while (true) {
 340              switch (token.kind) {
 341                 case SEMI:
 342                     nextToken();
 343                     return;
 344                 case PUBLIC:
 345                 case FINAL:
 346                 case ABSTRACT:
 347                 case MONKEYS_AT:
 348                 case EOF:
 349                 case CLASS:
 350                 case INTERFACE:
 351                 case ENUM:
 352                     return;
 353                 case IMPORT:
 354                     if (stopAtImport)
 355                         return;
 356                     break;
 357                 case LBRACE:
 358                 case RBRACE:
 359                 case PRIVATE:
 360                 case PROTECTED:
 361                 case STATIC:
 362                 case TRANSIENT:
 363                 case NATIVE:
 364                 case VOLATILE:
 365                 case SYNCHRONIZED:
 366                 case STRICTFP:
 367                 case LT:
 368                 case BYTE:
 369                 case SHORT:
 370                 case CHAR:
 371                 case INT:
 372                 case LONG:
 373                 case FLOAT:
 374                 case DOUBLE:
 375                 case BOOLEAN:
 376                 case VOID:
 377                     if (stopAtMemberDecl)
 378                         return;
 379                     break;
 380                 case UNDERSCORE:
 381                 case IDENTIFIER:
 382                    if (stopAtIdentifier)
 383                         return;
 384                     break;
 385                 case CASE:
 386                 case DEFAULT:
 387                 case IF:
 388                 case FOR:
 389                 case WHILE:
 390                 case DO:
 391                 case TRY:
 392                 case SWITCH:
 393                 case RETURN:
 394                 case THROW:
 395                 case BREAK:
 396                 case CONTINUE:
 397                 case ELSE:
 398                 case FINALLY:
 399                 case CATCH:
 400                 case THIS:
 401                 case SUPER:
 402                 case NEW:
 403                     if (stopAtStatement)
 404                         return;
 405                     break;
 406                 case ASSERT:
 407                     if (stopAtStatement)
 408                         return;
 409                     break;
 410             }
 411             nextToken();
 412         }
 413     }
 414 
 415     protected JCErroneous syntaxError(int pos, Error errorKey) {
 416         return syntaxError(pos, List.nil(), errorKey);
 417     }
 418 
 419     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 420         setErrorEndPos(pos);
 421         JCErroneous err = F.at(pos).Erroneous(errs);
 422         reportSyntaxError(err, errorKey);
 423         if (errs != null) {
 424             JCTree last = errs.last();
 425             if (last != null)
 426                 storeEnd(last, pos);
 427         }
 428         return toP(err);
 429     }
 430 
 431     private static final int RECOVERY_THRESHOLD = 50;
 432     private int errorPos = Position.NOPOS;
 433     private int count = 0;
 434 
 435     /**
 436      * Report a syntax using the given the position parameter and arguments,
 437      * unless one was already reported at the same position.
 438      */
 439     protected void reportSyntaxError(int pos, Error errorKey) {
 440         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 441         reportSyntaxError(diag, errorKey);
 442     }
 443 
 444     /**
 445      * Report a syntax error using the given DiagnosticPosition object and
 446      * arguments, unless one was already reported at the same position.
 447      */
 448     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 449         int pos = diagPos.getPreferredPosition();
 450         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 451             if (token.kind == EOF) {
 452                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 453             } else {
 454                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 455             }
 456         }
 457         S.errPos(pos);
 458         if (token.pos == errorPos) {
 459             //check for a possible infinite loop in parsing:
 460             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 461         } else {
 462             count = 0;
 463             errorPos = token.pos;
 464         }
 465     }
 466 
 467     /** If next input token matches given token, skip it, otherwise report
 468      *  an error.
 469      */
 470     public void accept(TokenKind tk) {
 471         accept(tk, Errors::Expected);
 472     }
 473 
 474     /** If next input token matches given token, skip it, otherwise report
 475      *  an error.
 476      */
 477     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 478         if (token.kind == tk) {
 479             nextToken();
 480         } else {
 481             setErrorEndPos(token.pos);
 482             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 483         }
 484     }
 485 
 486     /** If next input token matches one of the two given tokens, skip it, otherwise report
 487      *  an error.
 488      *
 489      * @return The actual token kind.
 490      */
 491     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {
 492         TokenKind returnValue = token.kind;
 493         if (token.kind == tk1 || token.kind == tk2) {
 494             nextToken();
 495         } else {
 496             setErrorEndPos(token.pos);
 497             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));
 498         }
 499         return returnValue;
 500     }
 501 
 502     /** Report an illegal start of expression/type error at given position.
 503      */
 504     JCExpression illegal(int pos) {
 505         setErrorEndPos(pos);
 506         if ((mode &amp; EXPR) != 0)
 507             return syntaxError(pos, Errors.IllegalStartOfExpr);
 508         else
 509             return syntaxError(pos, Errors.IllegalStartOfType);
 510 
 511     }
 512 
 513     /** Report an illegal start of expression/type error at current position.
 514      */
 515     JCExpression illegal() {
 516         return illegal(token.pos);
 517     }
 518 
 519     /** Diagnose a modifier flag from the set, if any. */
 520     protected void checkNoMods(long mods) {
 521         if (mods != 0) {
 522             long lowestMod = mods &amp; -mods;
 523             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 524         }
 525     }
 526 
 527 /* ---------- doc comments --------- */
 528 
 529     /** A table to store all documentation comments
 530      *  indexed by the tree nodes they refer to.
 531      *  defined only if option flag keepDocComment is set.
 532      */
 533     private final DocCommentTable docComments;
 534 
 535     /** Make an entry into docComments hashtable,
 536      *  provided flag keepDocComments is set and given doc comment is non-null.
 537      *  @param tree   The tree to be used as index in the hashtable
 538      *  @param dc     The doc comment to associate with the tree, or null.
 539      */
 540     protected void attach(JCTree tree, Comment dc) {
 541         if (keepDocComments &amp;&amp; dc != null) {
 542 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 543             docComments.putComment(tree, dc);
 544         }
 545     }
 546 
 547 /* -------- source positions ------- */
 548 
 549     protected void setErrorEndPos(int errPos) {
 550         endPosTable.setErrorEndPos(errPos);
 551     }
 552 
 553     protected void storeEnd(JCTree tree, int endpos) {
 554         endPosTable.storeEnd(tree, endpos);
 555     }
 556 
 557     protected &lt;T extends JCTree&gt; T to(T t) {
 558         return endPosTable.to(t);
 559     }
 560 
 561     protected &lt;T extends JCTree&gt; T toP(T t) {
 562         return endPosTable.toP(t);
 563     }
 564 
 565     /** Get the start position for a tree node.  The start position is
 566      * defined to be the position of the first character of the first
 567      * token of the node&#39;s source text.
 568      * @param tree  The tree node
 569      */
 570     public int getStartPos(JCTree tree) {
 571         return TreeInfo.getStartPos(tree);
 572     }
 573 
 574     /**
 575      * Get the end position for a tree node.  The end position is
 576      * defined to be the position of the last character of the last
 577      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 578      * positions are not generated or the position is otherwise not
 579      * found.
 580      * @param tree  The tree node
 581      */
 582     public int getEndPos(JCTree tree) {
 583         return endPosTable.getEndPos(tree);
 584     }
 585 
 586 
 587 
 588 /* ---------- parsing -------------- */
 589 
 590     /**
 591      * Ident = IDENTIFIER
 592      */
 593     public Name ident() {
 594         return ident(false);
 595     }
 596 
 597     protected Name ident(boolean advanceOnErrors) {
 598         if (token.kind == IDENTIFIER) {
 599             Name name = token.name();
 600             nextToken();
 601             return name;
 602         } else if (token.kind == ASSERT) {
 603             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 604             nextToken();
 605             return names.error;
 606         } else if (token.kind == ENUM) {
 607             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 608             nextToken();
 609             return names.error;
 610         } else if (token.kind == THIS) {
 611             if (allowThisIdent) {
 612                 // Make sure we&#39;re using a supported source version.
 613                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 614                 Name name = token.name();
 615                 nextToken();
 616                 return name;
 617             } else {
 618                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 619                 nextToken();
 620                 return names.error;
 621             }
 622         } else if (token.kind == UNDERSCORE) {
 623             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 624                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 625             } else {
 626                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 627             }
 628             Name name = token.name();
 629             nextToken();
 630             return name;
 631         } else {
 632             accept(IDENTIFIER);
 633             if (advanceOnErrors) {
 634                 nextToken();
 635             }
 636             return names.error;
 637         }
 638     }
 639 
 640     /**
 641      * Qualident = Ident { DOT [Annotations] Ident } {?}
 642      */
 643     public JCExpression qualident(boolean allowAnnos) {
 644         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 645         while (token.kind == DOT) {
 646             int pos = token.pos;
 647             nextToken();
 648             List&lt;JCAnnotation&gt; tyannos = null;
 649             if (allowAnnos) {
 650                 tyannos = typeAnnotationsOpt();
 651             }
 652             t = toP(F.at(pos).Select(t, ident()));
 653             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 654                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 655             }
 656         }
 657         /* if the qualified identifier being parsed is for a type name (as indicated by allowAnnos),
 658            also process any terminal ? to signal nullable projection for a value type.
 659         */
 660         if (allowAnnos &amp;&amp; token.kind == QUES) {
 661             t.setQuestioned();
 662             nextToken();
 663         }
 664         return t;
 665     }
 666 
 667     JCExpression literal(Name prefix) {
 668         return literal(prefix, token.pos);
 669     }
 670 
 671     /**
 672      * Literal =
 673      *     INTLITERAL
 674      *   | LONGLITERAL
 675      *   | FLOATLITERAL
 676      *   | DOUBLELITERAL
 677      *   | CHARLITERAL
 678      *   | STRINGLITERAL
 679      *   | TRUE
 680      *   | FALSE
 681      *   | NULL
 682      */
 683     JCExpression literal(Name prefix, int pos) {
 684         JCExpression t = errorTree;
 685         switch (token.kind) {
 686         case INTLITERAL:
 687             try {
 688                 t = F.at(pos).Literal(
 689                     TypeTag.INT,
 690                     Convert.string2int(strval(prefix), token.radix()));
 691             } catch (NumberFormatException ex) {
 692                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 693             }
 694             break;
 695         case LONGLITERAL:
 696             try {
 697                 t = F.at(pos).Literal(
 698                     TypeTag.LONG,
 699                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 700             } catch (NumberFormatException ex) {
 701                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 702             }
 703             break;
 704         case FLOATLITERAL: {
 705             String proper = token.radix() == 16 ?
 706                     (&quot;0x&quot;+ token.stringVal()) :
 707                     token.stringVal();
 708             Float n;
 709             try {
 710                 n = Float.valueOf(proper);
 711             } catch (NumberFormatException ex) {
 712                 // error already reported in scanner
 713                 n = Float.NaN;
 714             }
 715             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 716                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 717             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 718                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 719             else
 720                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 721             break;
 722         }
 723         case DOUBLELITERAL: {
 724             String proper = token.radix() == 16 ?
 725                     (&quot;0x&quot;+ token.stringVal()) :
 726                     token.stringVal();
 727             Double n;
 728             try {
 729                 n = Double.valueOf(proper);
 730             } catch (NumberFormatException ex) {
 731                 // error already reported in scanner
 732                 n = Double.NaN;
 733             }
 734             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 735                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 736             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 737                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 738             else
 739                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 740             break;
 741         }
 742         case CHARLITERAL:
 743             t = F.at(pos).Literal(
 744                 TypeTag.CHAR,
 745                 token.stringVal().charAt(0) + 0);
 746             break;
 747         case STRINGLITERAL:
 748             t = F.at(pos).Literal(
 749                 TypeTag.CLASS,
 750                 token.stringVal());
 751             break;
 752         case TRUE: case FALSE:
 753             t = F.at(pos).Literal(
 754                 TypeTag.BOOLEAN,
 755                 (token.kind == TRUE ? 1 : 0));
 756             break;
 757         case NULL:
 758             t = F.at(pos).Literal(
 759                 TypeTag.BOT,
 760                 null);
 761             break;
 762         default:
 763             Assert.error();
 764         }
 765         if (t == errorTree)
 766             t = F.at(pos).Erroneous();
 767         storeEnd(t, token.endPos);
 768         nextToken();
 769         return t;
 770     }
 771     //where
 772         boolean isZero(String s) {
 773             char[] cs = s.toCharArray();
 774             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 775             int i = ((base==16) ? 2 : 0);
 776             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 777             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 778         }
 779 
 780         String strval(Name prefix) {
 781             String s = token.stringVal();
 782             return prefix.isEmpty() ? s : prefix + s;
 783         }
 784 
 785     /** terms can be either expressions or types.
 786      */
 787     public JCExpression parseExpression() {
 788         return term(EXPR);
 789     }
 790 
 791     /**
 792      * parses (optional) type annotations followed by a type. If the
 793      * annotations are present before the type and are not consumed during array
 794      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 795      * these annotations and the underlying type. Otherwise, it returns the
 796      * underlying type.
 797      *
 798      * &lt;p&gt;
 799      *
 800      * Note that this method sets {@code mode} to {@code TYPE} first, before
 801      * parsing annotations.
 802      */
 803     public JCExpression parseType() {
 804         return parseType(false);
 805     }
 806 
 807     public JCExpression parseTypeSansQuestion() {
 808         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 809         boolean questionOK = peekToken(0, QUES) &amp;&amp; peekToken(1, LBRACKET)  &amp;&amp; peekToken(2, RBRACKET);
 810         JCExpression result = unannotatedType(false, TYPE | (questionOK ? 0 : NOQUESTION));
 811         mode &amp;= ~NOQUESTION;
 812         if (annotations.nonEmpty()) {
 813             result = insertAnnotationsToMostInner(result, annotations, false);
 814         }
 815 
 816         return result;
 817     }
 818 
 819     public JCExpression parseType(boolean allowVar) {
 820         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 821         return parseType(allowVar, annotations);
 822     }
 823 
 824     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 825         JCExpression result = unannotatedType(allowVar, TYPE);
 826 
 827         if (annotations.nonEmpty()) {
 828             result = insertAnnotationsToMostInner(result, annotations, false);
 829         }
 830 
 831         return result;
 832     }
 833 
 834     public JCExpression unannotatedType(boolean allowVar, int termMode) {
 835         JCExpression result = term(termMode);
 836         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 837 
 838         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 839             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 840         }
 841 
 842         return result;
 843     }
 844 
 845 
 846 
 847     protected JCExpression term(int newmode) {
 848         int prevmode = mode;
 849         mode = newmode;
 850         JCExpression t = term();
 851         lastmode = mode;
 852         mode = prevmode;
 853         return t;
 854     }
 855 
 856     /**
 857      *  {@literal
 858      *  Expression = Expression1 [ExpressionRest]
 859      *  ExpressionRest = [AssignmentOperator Expression1]
 860      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 861      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 862      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 863      *  Type = Type1
 864      *  TypeNoParams = TypeNoParams1
 865      *  StatementExpression = Expression
 866      *  ConstantExpression = Expression
 867      *  }
 868      */
 869     JCExpression term() {
 870         JCExpression t = term1();
 871         if ((mode &amp; EXPR) != 0 &amp;&amp;
 872             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 873             return termRest(t);
 874         else
 875             return t;
 876     }
 877 
 878     JCExpression termRest(JCExpression t) {
 879         switch (token.kind) {
 880         case EQ: {
 881             int pos = token.pos;
 882             nextToken();
 883             selectExprMode();
 884             JCExpression t1 = term();
 885             return toP(F.at(pos).Assign(t, t1));
 886         }
 887         case PLUSEQ:
 888         case SUBEQ:
 889         case STAREQ:
 890         case SLASHEQ:
 891         case PERCENTEQ:
 892         case AMPEQ:
 893         case BAREQ:
 894         case CARETEQ:
 895         case LTLTEQ:
 896         case GTGTEQ:
 897         case GTGTGTEQ:
 898             int pos = token.pos;
 899             TokenKind tk = token.kind;
 900             nextToken();
 901             selectExprMode();
 902             JCExpression t1 = term();
 903             return F.at(pos).Assignop(optag(tk), t, t1);
 904         default:
 905             return t;
 906         }
 907     }
 908 
 909     /** Expression1   = Expression2 [Expression1Rest]
 910      *  Type1         = Type2
 911      *  TypeNoParams1 = TypeNoParams2
 912      */
 913     JCExpression term1() {
 914         JCExpression t = term2();
 915         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 916             selectExprMode();
 917             return term1Rest(t);
 918         } else {
 919             return t;
 920         }
 921     }
 922 
 923     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 924      */
 925     JCExpression term1Rest(JCExpression t) {
 926         if (token.kind == QUES) {
 927             int pos = token.pos;
 928             nextToken();
 929             JCExpression t1 = term();
 930             accept(COLON);
 931             JCExpression t2 = term1();
 932             return F.at(pos).Conditional(t, t1, t2);
 933         } else {
 934             return t;
 935         }
 936     }
 937 
 938     /** Expression2   = Expression3 [Expression2Rest]
 939      *  Type2         = Type3
 940      *  TypeNoParams2 = TypeNoParams3
 941      */
 942     JCExpression term2() {
 943         JCExpression t = term3();
 944         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 945             selectExprMode();
 946             return term2Rest(t, TreeInfo.orPrec);
 947         } else {
 948             return t;
 949         }
 950     }
 951 
 952     /*  Expression2Rest = {infixop Expression3}
 953      *                  | Expression3 instanceof Type
 954      *                  | Expression3 instanceof Pattern
 955      *  infixop         = &quot;||&quot;
 956      *                  | &quot;&amp;&amp;&quot;
 957      *                  | &quot;|&quot;
 958      *                  | &quot;^&quot;
 959      *                  | &quot;&amp;&quot;
 960      *                  | &quot;==&quot; | &quot;!=&quot;
 961      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 962      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 963      *                  | &quot;+&quot; | &quot;-&quot;
 964      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 965      */
 966     JCExpression term2Rest(JCExpression t, int minprec) {
 967         JCExpression[] odStack = newOdStack();
 968         Token[] opStack = newOpStack();
 969 
 970         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 971         int top = 0;
 972         odStack[0] = t;
 973         int startPos = token.pos;
 974         Token topOp = Tokens.DUMMY;
 975         while (prec(token.kind) &gt;= minprec) {
 976             opStack[top] = topOp;
 977 
 978             if (token.kind == INSTANCEOF) {
 979                 int pos = token.pos;
 980                 nextToken();
 981                 JCTree pattern = parseTypeSansQuestion();
 982                 if (token.kind == IDENTIFIER) {
 983                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 984                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 985                 }
 986                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 987             } else {
 988                 topOp = token;
 989                 nextToken();
 990                 top++;
 991                 odStack[top] = term3();
 992             }
 993             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 994                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 995                 top--;
 996                 topOp = opStack[top];
 997             }
 998         }
 999         Assert.check(top == 0);
1000         t = odStack[0];
1001 
1002         if (t.hasTag(JCTree.Tag.PLUS)) {
1003             t = foldStrings(t);
1004         }
1005 
1006         odStackSupply.add(odStack);
1007         opStackSupply.add(opStack);
1008         return t;
1009     }
1010     //where
1011         /** If tree is a concatenation of string literals, replace it
1012          *  by a single literal representing the concatenated string.
1013          */
1014         protected JCExpression foldStrings(JCExpression tree) {
1015             if (!allowStringFolding)
1016                 return tree;
1017             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1018             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1019             boolean needsFolding = false;
1020             JCExpression curr = tree;
1021             while (true) {
1022                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1023                     JCBinary op = (JCBinary)curr;
1024                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1025                     curr = op.lhs;
1026                 } else {
1027                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1028                     break; //last one!
1029                 }
1030             }
1031             if (needsFolding) {
1032                 List&lt;JCExpression&gt; ops = opStack.toList();
1033                 JCExpression res = ops.head;
1034                 for (JCExpression op : ops.tail) {
1035                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1036                     storeEnd(res, getEndPos(op));
1037                 }
1038                 return res;
1039             } else {
1040                 return tree;
1041             }
1042         }
1043 
1044         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1045                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1046             JCLiteral str = stringLiteral(tree);
1047             if (str != null) {
1048                 litBuf.prepend(str);
1049                 return last &amp;&amp; merge(litBuf, opStack);
1050             } else {
1051                 boolean res = merge(litBuf, opStack);
1052                 litBuf.clear();
1053                 opStack.prepend(tree);
1054                 return res;
1055             }
1056         }
1057 
1058         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1059             if (litBuf.isEmpty()) {
1060                 return false;
1061             } else if (litBuf.size() == 1) {
1062                 opStack.prepend(litBuf.first());
1063                 return false;
1064             } else {
1065                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1066                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1067                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1068                 opStack.prepend(t);
1069                 return true;
1070             }
1071         }
1072 
1073         private JCLiteral stringLiteral(JCTree tree) {
1074             if (tree.hasTag(LITERAL)) {
1075                 JCLiteral lit = (JCLiteral)tree;
1076                 if (lit.typetag == TypeTag.CLASS) {
1077                     return lit;
1078                 }
1079             }
1080             return null;
1081         }
1082 
1083 
1084         /** optimization: To save allocating a new operand/operator stack
1085          *  for every binary operation, we use supplys.
1086          */
1087         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1088         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1089 
1090         private JCExpression[] newOdStack() {
1091             if (odStackSupply.isEmpty())
1092                 return new JCExpression[infixPrecedenceLevels + 1];
1093             return odStackSupply.remove(odStackSupply.size() - 1);
1094         }
1095 
1096         private Token[] newOpStack() {
1097             if (opStackSupply.isEmpty())
1098                 return new Token[infixPrecedenceLevels + 1];
1099             return opStackSupply.remove(opStackSupply.size() - 1);
1100         }
1101 
1102     /**
1103      *  Expression3    = PrefixOp Expression3
1104      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1105      *                 | Primary {Selector} {PostfixOp}
1106      *
1107      *  {@literal
1108      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1109      *                 | Literal
1110      *                 | [TypeArguments] THIS [Arguments]
1111      *                 | [TypeArguments] SUPER SuperSuffix
1112      *                 | NEW [TypeArguments] Creator
1113      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1114      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1115      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1116      *                 | Expression3 MemberReferenceSuffix
1117      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1118      *                   | Arguments
1119      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1120      *                   ]
1121      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1122      *  }
1123      *
1124      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1125      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1126      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1127      *                 | BasicType
1128      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1129      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1130      *                 | &quot;.&quot; THIS
1131      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1132      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1133      *                 | &quot;[&quot; Expression &quot;]&quot;
1134      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1135      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1136      */
1137     protected JCExpression term3() {
1138         int pos = token.pos;
1139         JCExpression t;
1140         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1141         switch (token.kind) {
1142         case QUES:
1143             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1144                 selectTypeMode();
1145                 return typeArgument();
1146             } else
1147                 return illegal();
1148         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1149             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1150                 TokenKind tk = token.kind;
1151                 nextToken();
1152                 selectExprMode();
1153                 if (tk == SUB &amp;&amp;
1154                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1155                     token.radix() == 10) {
1156                     selectExprMode();
1157                     t = literal(names.hyphen, pos);
1158                 } else {
1159                     t = term3();
1160                     return F.at(pos).Unary(unoptag(tk), t);
1161                 }
1162             } else return illegal();
1163             break;
1164         case WITHFIELD:
1165             if (!allowWithFieldOperator) {
1166                 log.error(pos, Errors.WithFieldOperatorDisallowed);
1167             }
1168             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1169                 nextToken();
1170                 accept(LPAREN);
1171                 mode = EXPR;
1172                 t = term();
1173                 accept(COMMA);
1174                 mode = EXPR;
1175                 JCExpression v = term();
1176                 accept(RPAREN);
1177                 return F.at(pos).WithField(t, v);
1178             } else return illegal();
1179         case LPAREN:
1180             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1181                 ParensResult pres = analyzeParens();
1182                 switch (pres) {
1183                     case CAST:
1184                        accept(LPAREN);
1185                        selectTypeMode();
1186                        int pos1 = pos;
1187                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1188                        while (token.kind == AMP) {
1189                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1190                            accept(AMP);
1191                            targets = targets.prepend(parseType());
1192                        }
1193                        if (targets.length() &gt; 1) {
1194                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1195                        }
1196                        accept(RPAREN);
1197                        selectExprMode();
1198                        JCExpression t1 = term3();
1199                        return F.at(pos).TypeCast(t, t1);
1200                     case IMPLICIT_LAMBDA:
1201                     case EXPLICIT_LAMBDA:
1202                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1203                         break;
1204                     default: //PARENS
1205                         accept(LPAREN);
1206                         selectExprMode();
1207                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1208                         accept(RPAREN);
1209                         t = toP(F.at(pos).Parens(t));
1210                         break;
1211                 }
1212             } else {
1213                 return illegal();
1214             }
1215             break;
1216         case THIS:
1217             if ((mode &amp; EXPR) != 0) {
1218                 selectExprMode();
1219                 t = to(F.at(pos).Ident(names._this));
1220                 nextToken();
1221                 if (typeArgs == null)
1222                     t = argumentsOpt(null, t);
1223                 else
1224                     t = arguments(typeArgs, t);
1225                 typeArgs = null;
1226             } else return illegal();
1227             break;
1228         case SUPER:
1229             if ((mode &amp; EXPR) != 0) {
1230                 selectExprMode();
1231                 t = to(F.at(pos).Ident(names._super));
1232                 t = superSuffix(typeArgs, t);
1233                 typeArgs = null;
1234             } else return illegal();
1235             break;
1236         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1237         case CHARLITERAL: case STRINGLITERAL:
1238         case TRUE: case FALSE: case NULL:
1239             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1240                 selectExprMode();
1241                 t = literal(names.empty);
1242             } else return illegal();
1243             break;
1244         case NEW:
1245             if (typeArgs != null) return illegal();
1246             if ((mode &amp; EXPR) != 0) {
1247                 selectExprMode();
1248                 nextToken();
1249                 if (token.kind == LT) typeArgs = typeArguments(false);
1250                 t = creator(pos, typeArgs);
1251                 typeArgs = null;
1252             } else return illegal();
1253             break;
1254         case MONKEYS_AT:
1255             // Only annotated cast types and method references are valid
1256             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1257             if (typeAnnos.isEmpty()) {
1258                 // else there would be no &#39;@&#39;
1259                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1260             }
1261 
1262             JCExpression expr = term3();
1263 
1264             if ((mode &amp; TYPE) == 0) {
1265                 // Type annotations on class literals no longer legal
1266                 switch (expr.getTag()) {
1267                 case REFERENCE: {
1268                     JCMemberReference mref = (JCMemberReference) expr;
1269                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1270                     t = mref;
1271                     break;
1272                 }
1273                 case SELECT: {
1274                     JCFieldAccess sel = (JCFieldAccess) expr;
1275 
1276                     if (sel.name != names._class) {
1277                         return illegal();
1278                     } else {
1279                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1280                         return expr;
1281                     }
1282                 }
1283                 default:
1284                     return illegal(typeAnnos.head.pos);
1285                 }
1286 
1287             } else {
1288                 // Type annotations targeting a cast
1289                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1290             }
1291             break;
1292         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1293             if (typeArgs != null) return illegal();
1294             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1295                 t = lambdaExpressionOrStatement(false, false, pos);
1296             } else {
1297                 t = toP(F.at(token.pos).Ident(ident()));
1298                 handleQuestion(t);
1299                 loop: while (true) {
1300                     pos = token.pos;
1301                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1302 
1303                     // need to report an error later if LBRACKET is for array
1304                     // index access rather than array creation level
1305                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1306                         return illegal(annos.head.pos);
1307 
1308                     switch (token.kind) {
1309                     case LBRACKET:
1310                         nextToken();
1311                         if (token.kind == RBRACKET) {
1312                             nextToken();
1313                             t = bracketsOpt(t);
1314                             t = toP(F.at(pos).TypeArray(t));
1315                             if (annos.nonEmpty()) {
1316                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1317                             }
1318                             t = bracketsSuffix(t);
1319                         } else {
1320                             if ((mode &amp; EXPR) != 0) {
1321                                 selectExprMode();
1322                                 JCExpression t1 = term();
1323                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1324                                 t = to(F.at(pos).Indexed(t, t1));
1325                             }
1326                             accept(RBRACKET);
1327                         }
1328                         break loop;
1329                     case LPAREN:
1330                         if ((mode &amp; EXPR) != 0) {
1331                             selectExprMode();
1332                             t = arguments(typeArgs, t);
1333                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1334                             typeArgs = null;
1335                         }
1336                         break loop;
1337                     case DOT:
1338                         nextToken();
1339                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1340                             return illegal();
1341                         }
1342                         int oldmode = mode;
1343                         mode &amp;= ~NOPARAMS;
1344                         typeArgs = typeArgumentsOpt(EXPR);
1345                         mode = oldmode;
1346                         if ((mode &amp; EXPR) != 0) {
1347                             switch (token.kind) {
1348                             case DEFAULT:
1349                                 if (typeArgs != null) return illegal();
1350                                 selectExprMode();
1351                                 t = to(F.at(pos).Select(t, names._default));
1352                                 nextToken();
1353                                 break loop;
1354                             case CLASS:
1355                                 if (typeArgs != null) return illegal();
1356                                 selectExprMode();
1357                                 t = to(F.at(pos).Select(t, names._class));
1358                                 nextToken();
1359                                 break loop;
1360                             case THIS:
1361                                 if (typeArgs != null) return illegal();
1362                                 selectExprMode();
1363                                 t = to(F.at(pos).Select(t, names._this));
1364                                 nextToken();
1365                                 break loop;
1366                             case SUPER:
1367                                 selectExprMode();
1368                                 t = to(F.at(pos).Select(t, names._super));
1369                                 t = superSuffix(typeArgs, t);
1370                                 typeArgs = null;
1371                                 break loop;
1372                             case NEW:
1373                                 if (typeArgs != null) return illegal();
1374                                 selectExprMode();
1375                                 int pos1 = token.pos;
1376                                 nextToken();
1377                                 if (token.kind == LT) typeArgs = typeArguments(false);
1378                                 t = innerCreator(pos1, typeArgs, t);
1379                                 typeArgs = null;
1380                                 break loop;
1381                             }
1382                         }
1383 
1384                         List&lt;JCAnnotation&gt; tyannos = null;
1385                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1386                             tyannos = typeAnnotationsOpt();
1387                         }
1388                         // typeArgs saved for next loop iteration.
1389                         t = toP(F.at(pos).Select(t, ident()));
1390                         handleQuestion(t);
1391                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1392                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1393                         }
1394                         break;
1395                     case ELLIPSIS:
1396                         if (this.permitTypeAnnotationsPushBack) {
1397                             this.typeAnnotationsPushedBack = annos;
1398                         } else if (annos.nonEmpty()) {
1399                             // Don&#39;t return here -- error recovery attempt
1400                             illegal(annos.head.pos);
1401                         }
1402                         break loop;
1403                     case LT:
1404                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {
1405                             //this is either an unbound method reference whose qualifier
1406                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of
1407                             //the form ValueType&lt;S&gt;.default
1408                             int pos1 = token.pos;
1409                             accept(LT);
1410                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1411                             args.append(typeArgument());
1412                             while (token.kind == COMMA) {
1413                                 nextToken();
1414                                 args.append(typeArgument());
1415                             }
1416                             accept(GT);
1417                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1418                             while (token.kind == DOT) {
1419                                 nextToken();
1420                                 if (token.kind == DEFAULT) {
1421                                     t =  toP(F.at(token.pos).Select(t, names._default));
1422                                     nextToken();
1423                                     selectExprMode();
1424                                     return term3Rest(t, typeArgs);
1425                                 }
1426                                 selectTypeMode();
1427                                 t = toP(F.at(token.pos).Select(t, ident()));
1428                                 t = typeArgumentsOpt(t);
1429                             }
1430                             t = bracketsOpt(t);
1431                             if (token.kind != COLCOL) {
1432                                 //method reference expected here
1433                                 t = illegal();
1434                             }
1435                             selectExprMode();
1436                             return term3Rest(t, typeArgs);
1437                         }
1438                         break loop;
1439                     default:
1440                         break loop;
1441                     }
1442                 }
1443             }
1444             if (typeArgs != null) illegal();
1445             t = typeArgumentsOpt(t);
1446             break;
1447         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1448         case DOUBLE: case BOOLEAN:
1449             if (typeArgs != null) illegal();
1450             t = bracketsSuffix(bracketsOpt(basicType()));
1451             break;
1452         case VOID:
1453             if (typeArgs != null) illegal();
1454             if ((mode &amp; EXPR) != 0) {
1455                 nextToken();
1456                 if (token.kind == DOT) {
1457                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1458                     t = bracketsSuffix(ti);
1459                 } else {
1460                     return illegal(pos);
1461                 }
1462             } else {
1463                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1464                 // a void type (like other primitive types) to the next phase.
1465                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1466                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1467                 nextToken();
1468                 return ti;
1469                 //return illegal();
1470             }
1471             break;
1472         case SWITCH:
1473             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1474             allowYieldStatement = true;
1475             int switchPos = token.pos;
1476             nextToken();
1477             JCExpression selector = parExpression();
1478             accept(LBRACE);
1479             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1480             while (true) {
1481                 pos = token.pos;
1482                 switch (token.kind) {
1483                 case CASE:
1484                 case DEFAULT:
1485                     cases.appendList(switchExpressionStatementGroup());
1486                     break;
1487                 case RBRACE: case EOF:
1488                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1489                                                                                cases.toList()));
1490                     e.endpos = token.pos;
1491                     accept(RBRACE);
1492                     return e;
1493                 default:
1494                     nextToken(); // to ensure progress
1495                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1496                 }
1497             }
1498         default:
1499             return illegal();
1500         }
1501         return term3Rest(t, typeArgs);
1502     }
1503 
1504     // where
1505         private void handleQuestion(JCExpression t) {
1506             if (token.kind == QUES) {
1507                 if (((mode &amp; NOQUESTION) == 0 &amp;&amp; (mode &amp; TYPE) != 0) ||
1508                         (peekToken(0, LBRACKET) &amp;&amp; peekToken(1, RBRACKET) &amp;&amp; peekToken(2, DOT) &amp;&amp; peekToken(3, CLASS))) {
1509                     t.setQuestioned();
1510                     nextToken();
1511                 }
1512             }
1513         }
1514 
1515     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1516         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1517         int casePos = token.pos;
1518         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1519 
1520         if (token.kind == DEFAULT) {
1521             nextToken();
1522         } else {
1523             accept(CASE);
1524             while (true) {
1525                 pats.append(term(EXPR | NOLAMBDA));
1526                 if (token.kind != COMMA) break;
1527                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1528                 nextToken();
1529             };
1530         }
1531         List&lt;JCStatement&gt; stats = null;
1532         JCTree body = null;
1533         CaseTree.CaseKind kind;
1534         switch (token.kind) {
1535             case ARROW:
1536                 checkSourceLevel(Feature.SWITCH_RULE);
1537                 nextToken();
1538                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1539                     stats = List.of(parseStatement());
1540                     body = stats.head;
1541                     kind = JCCase.RULE;
1542                 } else {
1543                     JCExpression value = parseExpression();
1544                     stats = List.of(to(F.at(value).Yield(value)));
1545                     body = value;
1546                     kind = JCCase.RULE;
1547                     accept(SEMI);
1548                 }
1549                 break;
1550             default:
1551                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1552                 stats = blockStatements();
1553                 kind = JCCase.STATEMENT;
1554                 break;
1555         }
1556         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1557         return caseExprs.toList();
1558     }
1559 
1560     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1561         if (typeArgs != null) illegal();
1562         while (true) {
1563             int pos1 = token.pos;
1564             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1565 
1566             if (token.kind == LBRACKET) {
1567                 nextToken();
1568                 if ((mode &amp; TYPE) != 0) {
1569                     int oldmode = mode;
1570                     selectTypeMode();
1571                     if (token.kind == RBRACKET) {
1572                         nextToken();
1573                         t = bracketsOpt(t);
1574                         t = toP(F.at(pos1).TypeArray(t));
1575                         if (token.kind == COLCOL) {
1576                             selectExprMode();
1577                             continue;
1578                         }
1579                         if (annos.nonEmpty()) {
1580                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1581                         }
1582                         return t;
1583                     }
1584                     mode = oldmode;
1585                 }
1586                 if ((mode &amp; EXPR) != 0) {
1587                     selectExprMode();
1588                     JCExpression t1 = term();
1589                     t = to(F.at(pos1).Indexed(t, t1));
1590                 }
1591                 accept(RBRACKET);
1592             } else if (token.kind == DOT) {
1593                 nextToken();
1594                 typeArgs = typeArgumentsOpt(EXPR);
1595                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1596                     selectExprMode();
1597                     t = to(F.at(pos1).Select(t, names._super));
1598                     nextToken();
1599                     t = arguments(typeArgs, t);
1600                     typeArgs = null;
1601                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {
1602                     if (typeArgs != null) return illegal();
1603                     selectExprMode();
1604                     int pos2 = token.pos;
1605                     nextToken();
1606                     if (token.kind == LT) typeArgs = typeArguments(false);
1607                     t = innerCreator(pos2, typeArgs, t);
1608                     typeArgs = null;
1609                 } else {
1610                     List&lt;JCAnnotation&gt; tyannos = null;
1611                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1612                         // is the mode check needed?
1613                         tyannos = typeAnnotationsOpt();
1614                     }
1615                     t = toP(F.at(pos1).Select(t, ident(true)));
1616                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1617                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1618                     }
1619                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1620                     typeArgs = null;
1621                 }
1622             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1623                 selectExprMode();
1624                 if (typeArgs != null) return illegal();
1625                 accept(COLCOL);
1626                 t = memberReferenceSuffix(pos1, t);
1627             } else {
1628                 if (!annos.isEmpty()) {
1629                     if (permitTypeAnnotationsPushBack)
1630                         typeAnnotationsPushedBack = annos;
1631                     else
1632                         return illegal(annos.head.pos);
1633                 }
1634                 break;
1635             }
1636         }
1637         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1638             selectExprMode();
1639             t = to(F.at(token.pos).Unary(
1640                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1641             nextToken();
1642         }
1643         return toP(t);
1644     }
1645 
1646     /**
1647      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1648      * method reference or a default value creation that uses a parameterized type
1649      * or a binary expression. To disambiguate, look for a
1650      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1651      */
1652     @SuppressWarnings(&quot;fallthrough&quot;)
1653     boolean isParameterizedTypePrefix() {
1654         int pos = 0, depth = 0;
1655         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1656             switch (t.kind) {
1657                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1658                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1659                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1660                 case DOUBLE: case BOOLEAN: case CHAR:
1661                 case MONKEYS_AT:
1662                     break;
1663 
1664                 case LPAREN:
1665                     // skip annotation values
1666                     int nesting = 0;
1667                     for (; ; pos++) {
1668                         TokenKind tk2 = S.token(pos).kind;
1669                         switch (tk2) {
1670                             case EOF:
1671                                 return false;
1672                             case LPAREN:
1673                                 nesting++;
1674                                 break;
1675                             case RPAREN:
1676                                 nesting--;
1677                                 if (nesting == 0) {
1678                                     continue outer;
1679                                 }
1680                                 break;
1681                         }
1682                     }
1683 
1684                 case LT:
1685                     depth++; break;
1686                 case GTGTGT:
1687                     depth--;
1688                 case GTGT:
1689                     depth--;
1690                 case GT:
1691                     depth--;
1692                     if (depth == 0) {
1693                         TokenKind nextKind = S.token(pos + 1).kind;
1694                         return
1695                             nextKind == TokenKind.DOT ||
1696                             nextKind == TokenKind.LBRACKET ||
1697                             nextKind == TokenKind.COLCOL;
1698                     }
1699                     break;
1700                 default:
1701                     return false;
1702             }
1703         }
1704     }
1705 
1706     /**
1707      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1708      * method reference or a binary expression. To disambiguate, look for a
1709      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1710      */
1711     @SuppressWarnings(&quot;fallthrough&quot;)
1712     ParensResult analyzeParens() {
1713         int depth = 0;
1714         boolean type = false;
1715         ParensResult defaultResult = ParensResult.PARENS;
1716         outer: for (int lookahead = 0; ; lookahead++) {
1717             TokenKind tk = S.token(lookahead).kind;
1718             switch (tk) {
1719                 case COMMA:
1720                     type = true;
1721                 case EXTENDS: case SUPER: case DOT: case AMP:
1722                     //skip
1723                     break;
1724                 case QUES:
1725                     if (peekToken(lookahead, EXTENDS) ||
1726                             peekToken(lookahead, SUPER)) {
1727                         //wildcards
1728                         type = true;
1729                     }
1730                     break;
1731                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1732                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1733                     if (peekToken(lookahead, RPAREN)) {
1734                         //Type, &#39;)&#39; -&gt; cast
1735                         return ParensResult.CAST;
1736                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1737                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1738                         return ParensResult.EXPLICIT_LAMBDA;
1739                     }
1740                     break;
1741                 case LPAREN:
1742                     if (lookahead != 0) {
1743                         // &#39;(&#39; in a non-starting position -&gt; parens
1744                         return ParensResult.PARENS;
1745                     } else if (peekToken(lookahead, RPAREN)) {
1746                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1747                         return ParensResult.EXPLICIT_LAMBDA;
1748                     }
1749                     break;
1750                 case RPAREN:
1751                     // if we have seen something that looks like a type,
1752                     // then it&#39;s a cast expression
1753                     if (type) return ParensResult.CAST;
1754                     // otherwise, disambiguate cast vs. parenthesized expression
1755                     // based on subsequent token.
1756                     switch (S.token(lookahead + 1).kind) {
1757                         /*case PLUSPLUS: case SUBSUB: */
1758                         case BANG: case TILDE:
1759                         case LPAREN: case THIS: case SUPER:
1760                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1761                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1762                         case TRUE: case FALSE: case NULL:
1763                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1764                         case SWITCH:
1765                         case BYTE: case SHORT: case CHAR: case INT:
1766                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1767                             return ParensResult.CAST;
1768                         default:
1769                             return defaultResult;
1770                     }
1771                 case UNDERSCORE:
1772                 case ASSERT:
1773                 case ENUM:
1774                 case IDENTIFIER:
1775                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {
1776                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1777                         return ParensResult.EXPLICIT_LAMBDA;
1778                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1779                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1780                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1781                                                       : ParensResult.PARENS;
1782                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1783                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1784                     }
1785                     type = false;
1786                     break;
1787                 case FINAL:
1788                 case ELLIPSIS:
1789                     //those can only appear in explicit lambdas
1790                     return ParensResult.EXPLICIT_LAMBDA;
1791                 case MONKEYS_AT:
1792                     type = true;
1793                     lookahead += 1; //skip &#39;@&#39;
1794                     while (peekToken(lookahead, DOT)) {
1795                         lookahead += 2;
1796                     }
1797                     if (peekToken(lookahead, LPAREN)) {
1798                         lookahead++;
1799                         //skip annotation values
1800                         int nesting = 0;
1801                         for (; ; lookahead++) {
1802                             TokenKind tk2 = S.token(lookahead).kind;
1803                             switch (tk2) {
1804                                 case EOF:
1805                                     return ParensResult.PARENS;
1806                                 case LPAREN:
1807                                     nesting++;
1808                                     break;
1809                                 case RPAREN:
1810                                     nesting--;
1811                                     if (nesting == 0) {
1812                                         continue outer;
1813                                     }
1814                                 break;
1815                             }
1816                         }
1817                     }
1818                     break;
1819                 case LBRACKET:
1820                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1821                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1822                         return ParensResult.EXPLICIT_LAMBDA;
1823                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1824                             peekToken(lookahead, RBRACKET, AMP)) {
1825                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1826                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1827                         return ParensResult.CAST;
1828                     } else if (peekToken(lookahead, RBRACKET)) {
1829                         //consume the &#39;]&#39; and skip
1830                         type = true;
1831                         lookahead++;
1832                         break;
1833                     } else {
1834                         return ParensResult.PARENS;
1835                     }
1836                 case LT:
1837                     depth++; break;
1838                 case GTGTGT:
1839                     depth--;
1840                 case GTGT:
1841                     depth--;
1842                 case GT:
1843                     depth--;
1844                     if (depth == 0) {
1845                         if (peekToken(lookahead, RPAREN) ||
1846                                 peekToken(lookahead, AMP)) {
1847                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1848                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1849                             return ParensResult.CAST;
1850                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1851                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1852                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||
1853                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||
1854                                 peekToken(lookahead, ELLIPSIS)) {
1855                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1856                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1857                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1858                             return ParensResult.EXPLICIT_LAMBDA;
1859                         }
1860                         //it looks a type, but could still be (i) a cast to generic type,
1861                         //(ii) an unbound method reference or (iii) an explicit lambda
1862                         type = true;
1863                         break;
1864                     } else if (depth &lt; 0) {
1865                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1866                         return ParensResult.PARENS;
1867                     }
1868                     break;
1869                 default:
1870                     //this includes EOF
1871                     return defaultResult;
1872             }
1873         }
1874     }
1875 
1876     /** Accepts all identifier-like tokens */
1877     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1878 
1879     enum ParensResult {
1880         CAST,
1881         EXPLICIT_LAMBDA,
1882         IMPLICIT_LAMBDA,
1883         PARENS
1884     }
1885 
1886     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1887         List&lt;JCVariableDecl&gt; params = explicitParams ?
1888                 formalParameters(true, false) :
1889                 implicitParameters(hasParens);
1890         if (explicitParams) {
1891             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1892             for (JCVariableDecl param: params) {
1893                 Name restrictedTypeName;
1894                 if (param.vartype != null &amp;&amp;
1895                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1896                         param.vartype.hasTag(TYPEARRAY)) {
1897                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1898                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1899                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1900                 }
1901                 lambdaClassifier.addParameter(param);
1902                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1903                     break;
1904                 }
1905             }
1906             if (lambdaClassifier.diagFragment != null) {
1907                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1908             }
1909             for (JCVariableDecl param: params) {
1910                 if (param.vartype != null
1911                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1912                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1913                     param.startPos = TreeInfo.getStartPos(param.vartype);
1914                     param.vartype = null;
1915                 }
1916             }
1917         }
1918         return lambdaExpressionOrStatementRest(params, pos);
1919     }
1920 
1921     enum LambdaParameterKind {
1922         VAR(0),
1923         EXPLICIT(1),
1924         IMPLICIT(2),
1925         ERROR(-1);
1926 
1927         private final int index;
1928 
1929         LambdaParameterKind(int index) {
1930             this.index = index;
1931         }
1932     }
1933 
1934     private final static Fragment[][] decisionTable = new Fragment[][] {
1935         /*              VAR                              EXPLICIT                         IMPLICIT  */
1936         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1937         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1938         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1939     };
1940 
1941     class LambdaClassifier {
1942 
1943         LambdaParameterKind kind;
1944         Fragment diagFragment;
1945         List&lt;JCVariableDecl&gt; params;
1946 
1947         void addParameter(JCVariableDecl param) {
1948             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1949                 if (restrictedTypeName(param.vartype, false) != null) {
1950                     reduce(LambdaParameterKind.VAR);
1951                 } else {
1952                     reduce(LambdaParameterKind.EXPLICIT);
1953                 }
1954             }
1955             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1956                 param.vartype != null &amp;&amp; param.name == names.empty) {
1957                 reduce(LambdaParameterKind.IMPLICIT);
1958             }
1959         }
1960 
1961         private void reduce(LambdaParameterKind newKind) {
1962             if (kind == null) {
1963                 kind = newKind;
1964             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1965                 LambdaParameterKind currentKind = kind;
1966                 kind = LambdaParameterKind.ERROR;
1967                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1968                         newKind.index == LambdaParameterKind.VAR.index;
1969                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1970                         decisionTable[currentKind.index][newKind.index] : null;
1971             }
1972         }
1973 
1974         LambdaParameterKind result() {
1975             return kind;
1976         }
1977     }
1978 
1979     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1980         checkSourceLevel(Feature.LAMBDA);
1981         accept(ARROW);
1982 
1983         return token.kind == LBRACE ?
1984             lambdaStatement(args, pos, token.pos) :
1985             lambdaExpression(args, pos);
1986     }
1987 
1988     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1989         JCBlock block = block(pos2, 0);
1990         return toP(F.at(pos).Lambda(args, block));
1991     }
1992 
1993     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1994         JCTree expr = parseExpression();
1995         return toP(F.at(pos).Lambda(args, expr));
1996     }
1997 
1998     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1999      */
2000     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2001         nextToken();
2002         if (token.kind == LPAREN || typeArgs != null) {
2003             t = arguments(typeArgs, t);
2004         } else if (token.kind == COLCOL) {
2005             if (typeArgs != null) return illegal();
2006             t = memberReferenceSuffix(t);
2007         } else {
2008             int pos = token.pos;
2009             accept(DOT);
2010             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
2011             t = toP(F.at(pos).Select(t, ident()));
2012             t = argumentsOpt(typeArgs, t);
2013         }
2014         return t;
2015     }
2016 
2017     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
2018      */
2019     JCPrimitiveTypeTree basicType() {
2020         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
2021         nextToken();
2022         return t;
2023     }
2024 
2025     /** ArgumentsOpt = [ Arguments ]
2026      */
2027     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2028         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
2029             selectExprMode();
2030             return arguments(typeArgs, t);
2031         } else {
2032             return t;
2033         }
2034     }
2035 
2036     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
2037      */
2038     List&lt;JCExpression&gt; arguments() {
2039         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2040         if (token.kind == LPAREN) {
2041             nextToken();
2042             if (token.kind != RPAREN) {
2043                 args.append(parseExpression());
2044                 while (token.kind == COMMA) {
2045                     nextToken();
2046                     args.append(parseExpression());
2047                 }
2048             }
2049             accept(RPAREN);
2050         } else {
2051             syntaxError(token.pos, Errors.Expected(LPAREN));
2052         }
2053         return args.toList();
2054     }
2055 
2056     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2057         int pos = token.pos;
2058         List&lt;JCExpression&gt; args = arguments();
2059         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2060         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2061                                                                     ((JCIdent) t).name)) {
2062             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2063             mi = F.Erroneous(List.of(mi));
2064         }
2065         return toP(mi);
2066     }
2067 
2068     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2069         if (name == names.yield) {
2070             if (allowYieldStatement) {
2071                 return true;
2072             } else {
2073                 log.warning(pos, Warnings.InvalidYield);
2074             }
2075         }
2076         return false;
2077     }
2078 
2079     /**  TypeArgumentsOpt = [ TypeArguments ]
2080      */
2081     JCExpression typeArgumentsOpt(JCExpression t) {
2082         if (token.kind == LT &amp;&amp;
2083             (mode &amp; TYPE) != 0 &amp;&amp;
2084             (mode &amp; NOPARAMS) == 0) {
2085             selectTypeMode();
2086             return typeArguments(t, false);
2087         } else {
2088             return t;
2089         }
2090     }
2091     List&lt;JCExpression&gt; typeArgumentsOpt() {
2092         return typeArgumentsOpt(TYPE);
2093     }
2094 
2095     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2096         if (token.kind == LT) {
2097             if ((mode &amp; useMode) == 0 ||
2098                 (mode &amp; NOPARAMS) != 0) {
2099                 illegal();
2100             }
2101             mode = useMode;
2102             return typeArguments(false);
2103         }
2104         return null;
2105     }
2106 
2107     /**
2108      *  {@literal
2109      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2110      *  }
2111      */
2112     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2113         if (token.kind == LT) {
2114             nextToken();
2115             if (token.kind == GT &amp;&amp; diamondAllowed) {
2116                 checkSourceLevel(Feature.DIAMOND);
2117                 mode |= DIAMOND;
2118                 nextToken();
2119                 return List.nil();
2120             } else {
2121                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2122                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2123                 while (token.kind == COMMA) {
2124                     nextToken();
2125                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2126                 }
2127                 switch (token.kind) {
2128 
2129                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2130                 case GTGTGT: case GTGT:
2131                     token = S.split();
2132                     break;
2133                 case GT:
2134                     nextToken();
2135                     break;
2136                 default:
2137                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2138                     break;
2139                 }
2140                 return args.toList();
2141             }
2142         } else {
2143             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2144         }
2145     }
2146 
2147     /**
2148      *  {@literal
2149      *  TypeArgument = Type
2150      *               | [Annotations] &quot;?&quot;
2151      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2152      *               | [Annotations] &quot;?&quot; SUPER Type
2153      *  }
2154      */
2155     JCExpression typeArgument() {
2156         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2157         if (token.kind != QUES) return parseType(false, annotations);
2158         int pos = token.pos;
2159         nextToken();
2160         JCExpression result;
2161         if (token.kind == EXTENDS) {
2162             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2163             nextToken();
2164             JCExpression bound = parseType();
2165             result = F.at(pos).Wildcard(t, bound);
2166         } else if (token.kind == SUPER) {
2167             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2168             nextToken();
2169             JCExpression bound = parseType();
2170             result = F.at(pos).Wildcard(t, bound);
2171         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2172             //error recovery
2173             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2174             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2175             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2176             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2177             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2178             result = err;
2179         } else {
2180             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2181             result = toP(F.at(pos).Wildcard(t, null));
2182         }
2183         if (!annotations.isEmpty()) {
2184             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2185         }
2186         handleQuestion(result);
2187         return result;
2188     }
2189 
2190     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2191         int pos = token.pos;
2192         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2193         JCTypeApply ta = toP(F.at(pos).TypeApply(t, args));
2194         handleQuestion(ta);
2195         return ta;
2196     }
2197 
2198     /**
2199      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2200      *
2201      * &lt;p&gt;
2202      *
2203      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2204      * the expression &lt;code&gt;t&lt;/code&gt;.
2205      */
2206     private JCExpression bracketsOpt(JCExpression t,
2207             List&lt;JCAnnotation&gt; annotations) {
2208         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2209 
2210         if (token.kind == LBRACKET) {
2211             int pos = token.pos;
2212             nextToken();
2213             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2214         } else if (!nextLevelAnnotations.isEmpty()) {
2215             if (permitTypeAnnotationsPushBack) {
2216                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2217             } else {
2218                 return illegal(nextLevelAnnotations.head.pos);
2219             }
2220         }
2221 
2222         if (!annotations.isEmpty()) {
2223             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2224         }
2225         return t;
2226     }
2227 
2228     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2229      */
2230     private JCExpression bracketsOpt(JCExpression t) {
2231         return bracketsOpt(t, List.nil());
2232     }
2233 
2234     private JCExpression bracketsOptCont(JCExpression t, int pos,
2235             List&lt;JCAnnotation&gt; annotations) {
2236         accept(RBRACKET);
2237         t = bracketsOpt(t);
2238         t = toP(F.at(pos).TypeArray(t));
2239         if (annotations.nonEmpty()) {
2240             t = toP(F.at(pos).AnnotatedType(annotations, t));
2241         }
2242         return t;
2243     }
2244 
2245     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2246      *  BracketsSuffixType =
2247      */
2248     JCExpression bracketsSuffix(JCExpression t) {
2249         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2250             selectExprMode();
2251             int pos = token.pos;
2252             nextToken();
2253             TokenKind selector = accept2(CLASS, DEFAULT);
2254             if (token.pos == endPosTable.errorEndPos) {
2255                 // error recovery
2256                 Name name;
2257                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2258                     name = token.name();
2259                     nextToken();
2260                 } else {
2261                     name = names.error;
2262                 }
2263                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2264             } else {
2265                 Tag tag = t.getTag();
2266                 // Type annotations are illegal on class literals. Annotated non array class literals
2267                 // are complained about directly in term3(), Here check for type annotations on dimensions
2268                 // taking care to handle some interior dimension(s) being annotated.
2269                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2270                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2271                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));
2272             }
2273         } else if ((mode &amp; TYPE) != 0) {
2274             if (token.kind != COLCOL) {
2275                 selectTypeMode();
2276             }
2277         } else if (token.kind != COLCOL) {
2278             syntaxError(token.pos, Errors.DotClassExpected);
2279         }
2280         return t;
2281     }
2282 
2283     /**
2284      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2285      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2286      */
2287     JCExpression memberReferenceSuffix(JCExpression t) {
2288         int pos1 = token.pos;
2289         accept(COLCOL);
2290         return memberReferenceSuffix(pos1, t);
2291     }
2292 
2293     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2294         checkSourceLevel(Feature.METHOD_REFERENCES);
2295         selectExprMode();
2296         List&lt;JCExpression&gt; typeArgs = null;
2297         if (token.kind == LT) {
2298             typeArgs = typeArguments(false);
2299         }
2300         Name refName;
2301         ReferenceMode refMode;
2302         if (token.kind == NEW) {
2303             refMode = ReferenceMode.NEW;
2304             refName = names.init;
2305             nextToken();
2306         } else {
2307             refMode = ReferenceMode.INVOKE;
2308             refName = ident();
2309         }
2310         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2311     }
2312 
2313     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2314      */
2315     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2316         final JCModifiers mods = modifiersOpt();
2317         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;
2318         if (!newAnnotations.isEmpty()) {
2319             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);
2320         }
2321         switch (token.kind) {
2322         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2323         case DOUBLE: case BOOLEAN:
2324             if (mods.flags != 0) {
2325                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2326                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2327             }
2328             if (typeArgs == null) {
2329                 if (newAnnotations.isEmpty()) {
2330                     return arrayCreatorRest(newpos, basicType());
2331                 } else {
2332                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2333                 }
2334             }
2335             break;
2336         default:
2337         }
2338         JCExpression t = qualident(true);
2339 
2340         int oldmode = mode;
2341         selectTypeMode();
2342         boolean diamondFound = false;
2343         int lastTypeargsPos = -1;
2344         if (token.kind == LT) {
2345             lastTypeargsPos = token.pos;
2346             t = typeArguments(t, true);
2347             diamondFound = (mode &amp; DIAMOND) != 0;
2348         }
2349         while (token.kind == DOT) {
2350             if (diamondFound) {
2351                 //cannot select after a diamond
2352                 illegal();
2353             }
2354             int pos = token.pos;
2355             nextToken();
2356             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2357             t = toP(F.at(pos).Select(t, ident()));
2358 
2359             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2360                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2361             }
2362 
2363             if (token.kind == LT) {
2364                 lastTypeargsPos = token.pos;
2365                 t = typeArguments(t, true);
2366                 diamondFound = (mode &amp; DIAMOND) != 0;
2367             }
2368         }
2369         mode = oldmode;
2370         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2371             // handle type annotations for non primitive arrays
2372             if (newAnnotations.nonEmpty()) {
2373                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2374             }
2375 
2376             JCExpression e = arrayCreatorRest(newpos, t);
2377             if (diamondFound) {
2378                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2379                 return toP(F.at(newpos).Erroneous(List.of(e)));
2380             }
2381             else if (typeArgs != null) {
2382                 int pos = newpos;
2383                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2384                     // note: this should always happen but we should
2385                     // not rely on this as the parser is continuously
2386                     // modified to improve error recovery.
2387                     pos = typeArgs.head.pos;
2388                 }
2389                 setErrorEndPos(S.prevToken().endPos);
2390                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2391                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2392                 return toP(err);
2393             }
2394             return e;
2395         } else if (token.kind == LPAREN) {
2396             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);
2397             if (badModifiers != 0)
2398                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2399             // handle type annotations for instantiations and anonymous classes
2400             if (newAnnotations.nonEmpty()) {
2401                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2402             }
2403             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);
2404             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {
2405                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2406                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2407             }
2408             return newClass;
2409         } else {
2410             setErrorEndPos(token.pos);
2411             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2412             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2413             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2414         }
2415     }
2416 
2417     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2418      */
2419     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2420         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2421 
2422         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2423 
2424         if (newAnnotations.nonEmpty()) {
2425             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2426         }
2427 
2428         if (token.kind == LT) {
2429             int oldmode = mode;
2430             t = typeArguments(t, true);
2431             mode = oldmode;
2432         }
2433         return classCreatorRest(newpos, encl, typeArgs, t, 0);
2434     }
2435 
2436     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2437      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2438      */
2439     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2440         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2441 
2442         accept(LBRACKET);
2443         if (token.kind == RBRACKET) {
2444             accept(RBRACKET);
2445             elemtype = bracketsOpt(elemtype, annos);
2446             if (token.kind == LBRACE) {
2447                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2448                 if (annos.nonEmpty()) {
2449                     // when an array initializer is present then
2450                     // the parsed annotations should target the
2451                     // new array tree
2452                     // bracketsOpt inserts the annotation in
2453                     // elemtype, and it needs to be corrected
2454                     //
2455                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2456                     assert annotated.annotations == annos;
2457                     na.annotations = annotated.annotations;
2458                     na.elemtype = annotated.underlyingType;
2459                 }
2460                 return na;
2461             } else {
2462                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2463                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2464             }
2465         } else {
2466             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2467 
2468             // maintain array dimension type annotations
2469             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2470             dimAnnotations.append(annos);
2471 
2472             dims.append(parseExpression());
2473             accept(RBRACKET);
2474             while (token.kind == LBRACKET
2475                     || token.kind == MONKEYS_AT) {
2476                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2477                 int pos = token.pos;
2478                 nextToken();
2479                 if (token.kind == RBRACKET) {
2480                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2481                 } else {
2482                     if (token.kind == RBRACKET) { // no dimension
2483                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2484                     } else {
2485                         dimAnnotations.append(maybeDimAnnos);
2486                         dims.append(parseExpression());
2487                         accept(RBRACKET);
2488                     }
2489                 }
2490             }
2491 
2492             List&lt;JCExpression&gt; elems = null;
2493             int errpos = token.pos;
2494 
2495             if (token.kind == LBRACE) {
2496                 elems = arrayInitializerElements(newpos, elemtype);
2497             }
2498 
2499             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2500             na.dimAnnotations = dimAnnotations.toList();
2501 
2502             if (elems != null) {
2503                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2504             }
2505 
2506             return na;
2507         }
2508     }
2509 
2510     /** ClassCreatorRest = Arguments [ClassBody]
2511      */
2512     JCNewClass classCreatorRest(int newpos,
2513                                   JCExpression encl,
2514                                   List&lt;JCExpression&gt; typeArgs,
2515                                   JCExpression t,
2516                                   long flags)
2517     {
2518         List&lt;JCExpression&gt; args = arguments();
2519         JCClassDecl body = null;
2520         if (token.kind == LBRACE) {
2521             int pos = token.pos;
2522             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2523             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);
2524             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2525         }
2526         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2527         return newClass;
2528     }
2529 
2530     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2531      */
2532     JCExpression arrayInitializer(int newpos, JCExpression t) {
2533         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2534         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2535     }
2536 
2537     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2538         accept(LBRACE);
2539         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2540         if (token.kind == COMMA) {
2541             nextToken();
2542         } else if (token.kind != RBRACE) {
2543             elems.append(variableInitializer());
2544             while (token.kind == COMMA) {
2545                 nextToken();
2546                 if (token.kind == RBRACE) break;
2547                 elems.append(variableInitializer());
2548             }
2549         }
2550         accept(RBRACE);
2551         return elems.toList();
2552     }
2553 
2554     /** VariableInitializer = ArrayInitializer | Expression
2555      */
2556     public JCExpression variableInitializer() {
2557         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2558     }
2559 
2560     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2561      */
2562     JCExpression parExpression() {
2563         int pos = token.pos;
2564         accept(LPAREN);
2565         JCExpression t = parseExpression();
2566         accept(RPAREN);
2567         return toP(F.at(pos).Parens(t));
2568     }
2569 
2570     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2571      */
2572     JCBlock block(int pos, long flags) {
2573         accept(LBRACE);
2574         List&lt;JCStatement&gt; stats = blockStatements();
2575         JCBlock t = F.at(pos).Block(flags, stats);
2576         while (token.kind == CASE || token.kind == DEFAULT) {
2577             syntaxError(token.pos, Errors.Orphaned(token.kind));
2578             switchBlockStatementGroups();
2579         }
2580         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2581         // usually but not necessarily the last char of the last token.
2582         t.endpos = token.pos;
2583         accept(RBRACE);
2584         return toP(t);
2585     }
2586 
2587     public JCBlock block() {
2588         return block(token.pos, 0);
2589     }
2590 
2591     /** BlockStatements = { BlockStatement }
2592      *  BlockStatement  = LocalVariableDeclarationStatement
2593      *                  | ClassOrInterfaceOrEnumDeclaration
2594      *                  | [Ident &quot;:&quot;] Statement
2595      *  LocalVariableDeclarationStatement
2596      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2597      */
2598     @SuppressWarnings(&quot;fallthrough&quot;)
2599     List&lt;JCStatement&gt; blockStatements() {
2600         //todo: skip to anchor on error(?)
2601         int lastErrPos = -1;
2602         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2603         while (true) {
2604             List&lt;JCStatement&gt; stat = blockStatement();
2605             if (stat.isEmpty()) {
2606                 return stats.toList();
2607             } else {
2608                 // error recovery
2609                 if (token.pos == lastErrPos)
2610                     return stats.toList();
2611                 if (token.pos &lt;= endPosTable.errorEndPos) {
2612                     skip(false, true, true, true);
2613                     lastErrPos = token.pos;
2614                 }
2615                 stats.addAll(stat);
2616             }
2617         }
2618     }
2619 
2620     /*
2621      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2622      * this method will also recognize variable and class declarations (which are
2623      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2624      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2625      * and an error will be produced by this method.
2626      */
2627     JCStatement parseStatementAsBlock() {
2628         int pos = token.pos;
2629         List&lt;JCStatement&gt; stats = blockStatement();
2630         if (stats.isEmpty()) {
2631             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2632             return toP(F.at(pos).Exec(e));
2633         } else {
2634             JCStatement first = stats.head;
2635             Error error = null;
2636             switch (first.getTag()) {
2637             case CLASSDEF:
2638                 error = Errors.ClassNotAllowed;
2639                 break;
2640             case VARDEF:
2641                 error = Errors.VariableNotAllowed;
2642                 break;
2643             }
2644             if (error != null) {
2645                 log.error(DiagnosticFlag.SYNTAX, first, error);
2646                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2647                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2648             }
2649             return first;
2650         }
2651     }
2652 
2653     /**This method parses a statement appearing inside a block.
2654      */
2655     @SuppressWarnings(&quot;fallthrough&quot;)
2656     List&lt;JCStatement&gt; blockStatement() {
2657         //todo: skip to anchor on error(?)
2658         token = recastToken(token);
2659         Comment dc;
2660         int pos = token.pos;
2661         switch (token.kind) {
2662         case RBRACE: case CASE: case DEFAULT: case EOF:
2663             return List.nil();
2664         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2665         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2666         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2667         case ASSERT:
2668             return List.of(parseSimpleStatement());
2669         case VALUE:
2670         case MONKEYS_AT:
2671         case FINAL: {
2672             dc = token.comment(CommentStyle.JAVADOC);
2673             JCModifiers mods = modifiersOpt();
2674             if (token.kind == INTERFACE ||
2675                 token.kind == CLASS ||
2676                 token.kind == ENUM ||
2677                 isRecordStart()) {
2678                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2679             } else {
2680                 JCExpression t = parseType(true);
2681                 return localVariableDeclarations(mods, t);
2682             }
2683         }
2684         case ABSTRACT: case STRICTFP: {
2685             dc = token.comment(CommentStyle.JAVADOC);
2686             JCModifiers mods = modifiersOpt();
2687             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2688         }
2689         case INTERFACE:
2690         case CLASS:
2691             dc = token.comment(CommentStyle.JAVADOC);
2692             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2693         case ENUM:
2694             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2695             dc = token.comment(CommentStyle.JAVADOC);
2696             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2697         case IDENTIFIER:
2698             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2699                 Token next = S.token(1);
2700                 boolean isYieldStatement;
2701                 switch (next.kind) {
2702                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2703                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2704                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2705                     case NEW: case SWITCH: case THIS: case SUPER:
2706                         isYieldStatement = true;
2707                         break;
2708                     case PLUSPLUS: case SUBSUB:
2709                         isYieldStatement = S.token(2).kind != SEMI;
2710                         break;
2711                     case LPAREN:
2712                         int lookahead = 2;
2713                         int balance = 1;
2714                         boolean hasComma = false;
2715                         Token l;
2716                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2717                             switch (l.kind) {
2718                                 case LPAREN: balance++; break;
2719                                 case RPAREN: balance--; break;
2720                                 case COMMA: if (balance == 1) hasComma = true; break;
2721                             }
2722                             lookahead++;
2723                         }
2724                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2725                         break;
2726                     case SEMI: //error recovery - this is not a valid statement:
2727                         isYieldStatement = true;
2728                         break;
2729                     default:
2730                         isYieldStatement = false;
2731                         break;
2732                 }
2733 
2734                 if (isYieldStatement) {
2735                     nextToken();
2736                     JCExpression t = term(EXPR);
2737                     accept(SEMI);
2738                     return List.of(toP(F.at(pos).Yield(t)));
2739                 }
2740 
2741                 //else intentional fall-through
2742             }
2743         }
2744         if (isRecordStart() &amp;&amp; allowRecords) {
2745             dc = token.comment(CommentStyle.JAVADOC);
2746             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2747         } else {
2748             Token prevToken = token;
2749             JCExpression t = term(EXPR | TYPE);
2750             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2751                 nextToken();
2752                 JCStatement stat = parseStatementAsBlock();
2753                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2754             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2755                 pos = token.pos;
2756                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2757                 F.at(pos);
2758                 return localVariableDeclarations(mods, t);
2759             } else {
2760                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2761                 t = checkExprStat(t);
2762                 accept(SEMI);
2763                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2764                 return List.of(expr);
2765             }
2766         }
2767     }
2768     //where
2769         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2770             ListBuffer&lt;JCStatement&gt; stats =
2771                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2772             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2773             accept(SEMI);
2774             storeEnd(stats.last(), S.prevToken().endPos);
2775             return stats.toList();
2776         }
2777 
2778     /** Statement =
2779      *       Block
2780      *     | IF ParExpression Statement [ELSE Statement]
2781      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2782      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2783      *     | WHILE ParExpression Statement
2784      *     | DO Statement WHILE ParExpression &quot;;&quot;
2785      *     | TRY Block ( Catches | [Catches] FinallyPart )
2786      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2787      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2788      *     | SYNCHRONIZED ParExpression Block
2789      *     | RETURN [Expression] &quot;;&quot;
2790      *     | THROW Expression &quot;;&quot;
2791      *     | BREAK [Ident] &quot;;&quot;
2792      *     | CONTINUE [Ident] &quot;;&quot;
2793      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2794      *     | &quot;;&quot;
2795      */
2796     public JCStatement parseSimpleStatement() {
2797         int pos = token.pos;
2798         switch (token.kind) {
2799         case LBRACE:
2800             return block();
2801         case IF: {
2802             nextToken();
2803             JCExpression cond = parExpression();
2804             JCStatement thenpart = parseStatementAsBlock();
2805             JCStatement elsepart = null;
2806             if (token.kind == ELSE) {
2807                 nextToken();
2808                 elsepart = parseStatementAsBlock();
2809             }
2810             return F.at(pos).If(cond, thenpart, elsepart);
2811         }
2812         case FOR: {
2813             nextToken();
2814             accept(LPAREN);
2815             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2816             if (inits.length() == 1 &amp;&amp;
2817                 inits.head.hasTag(VARDEF) &amp;&amp;
2818                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2819                 token.kind == COLON) {
2820                 JCVariableDecl var = (JCVariableDecl)inits.head;
2821                 accept(COLON);
2822                 JCExpression expr = parseExpression();
2823                 accept(RPAREN);
2824                 JCStatement body = parseStatementAsBlock();
2825                 return F.at(pos).ForeachLoop(var, expr, body);
2826             } else {
2827                 accept(SEMI);
2828                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2829                 accept(SEMI);
2830                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2831                 accept(RPAREN);
2832                 JCStatement body = parseStatementAsBlock();
2833                 return F.at(pos).ForLoop(inits, cond, steps, body);
2834             }
2835         }
2836         case WHILE: {
2837             nextToken();
2838             JCExpression cond = parExpression();
2839             JCStatement body = parseStatementAsBlock();
2840             return F.at(pos).WhileLoop(cond, body);
2841         }
2842         case DO: {
2843             nextToken();
2844             JCStatement body = parseStatementAsBlock();
2845             accept(WHILE);
2846             JCExpression cond = parExpression();
2847             accept(SEMI);
2848             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2849             return t;
2850         }
2851         case TRY: {
2852             nextToken();
2853             List&lt;JCTree&gt; resources = List.nil();
2854             if (token.kind == LPAREN) {
2855                 nextToken();
2856                 resources = resources();
2857                 accept(RPAREN);
2858             }
2859             JCBlock body = block();
2860             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2861             JCBlock finalizer = null;
2862             if (token.kind == CATCH || token.kind == FINALLY) {
2863                 while (token.kind == CATCH) catchers.append(catchClause());
2864                 if (token.kind == FINALLY) {
2865                     nextToken();
2866                     finalizer = block();
2867                 }
2868             } else {
2869                 if (resources.isEmpty()) {
2870                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2871                 }
2872             }
2873             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2874         }
2875         case SWITCH: {
2876             nextToken();
2877             JCExpression selector = parExpression();
2878             accept(LBRACE);
2879             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2880             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2881             accept(RBRACE);
2882             return t;
2883         }
2884         case SYNCHRONIZED: {
2885             nextToken();
2886             JCExpression lock = parExpression();
2887             JCBlock body = block();
2888             return F.at(pos).Synchronized(lock, body);
2889         }
2890         case RETURN: {
2891             nextToken();
2892             JCExpression result = token.kind == SEMI ? null : parseExpression();
2893             accept(SEMI);
2894             JCReturn t = toP(F.at(pos).Return(result));
2895             return t;
2896         }
2897         case THROW: {
2898             nextToken();
2899             JCExpression exc = parseExpression();
2900             accept(SEMI);
2901             JCThrow t = toP(F.at(pos).Throw(exc));
2902             return t;
2903         }
2904         case BREAK: {
2905             nextToken();
2906             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2907             accept(SEMI);
2908             JCBreak t = toP(F.at(pos).Break(label));
2909             return t;
2910         }
2911         case CONTINUE: {
2912             nextToken();
2913             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2914             accept(SEMI);
2915             JCContinue t =  toP(F.at(pos).Continue(label));
2916             return t;
2917         }
2918         case SEMI:
2919             nextToken();
2920             return toP(F.at(pos).Skip());
2921         case ELSE:
2922             int elsePos = token.pos;
2923             nextToken();
2924             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2925         case FINALLY:
2926             int finallyPos = token.pos;
2927             nextToken();
2928             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2929         case CATCH:
2930             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2931         case ASSERT: {
2932             nextToken();
2933             JCExpression assertion = parseExpression();
2934             JCExpression message = null;
2935             if (token.kind == COLON) {
2936                 nextToken();
2937                 message = parseExpression();
2938             }
2939             accept(SEMI);
2940             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2941             return t;
2942         }
2943         default:
2944             Assert.error();
2945             return null;
2946         }
2947     }
2948 
2949     @Override
2950     public JCStatement parseStatement() {
2951         return parseStatementAsBlock();
2952     }
2953 
2954     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2955         int errPos = S.errPos();
2956         JCTree stm = action.doRecover(this);
2957         S.errPos(errPos);
2958         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2959     }
2960 
2961     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2962      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2963      */
2964     protected JCCatch catchClause() {
2965         int pos = token.pos;
2966         accept(CATCH);
2967         accept(LPAREN);
2968         JCModifiers mods = optFinal(Flags.PARAMETER);
2969         List&lt;JCExpression&gt; catchTypes = catchTypes();
2970         JCExpression paramType = catchTypes.size() &gt; 1 ?
2971                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2972                 catchTypes.head;
2973         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2974         accept(RPAREN);
2975         JCBlock body = block();
2976         return F.at(pos).Catch(formal, body);
2977     }
2978 
2979     List&lt;JCExpression&gt; catchTypes() {
2980         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2981         catchTypes.add(parseType());
2982         while (token.kind == BAR) {
2983             nextToken();
2984             // Instead of qualident this is now parseType.
2985             // But would that allow too much, e.g. arrays or generics?
2986             catchTypes.add(parseType());
2987         }
2988         return catchTypes.toList();
2989     }
2990 
2991     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2992      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2993      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2994      */
2995     List&lt;JCCase&gt; switchBlockStatementGroups() {
2996         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2997         while (true) {
2998             int pos = token.pos;
2999             switch (token.kind) {
3000             case CASE:
3001             case DEFAULT:
3002                 cases.appendList(switchBlockStatementGroup());
3003                 break;
3004             case RBRACE: case EOF:
3005                 return cases.toList();
3006             default:
3007                 nextToken(); // to ensure progress
3008                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
3009             }
3010         }
3011     }
3012 
3013     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
3014         int pos = token.pos;
3015         List&lt;JCStatement&gt; stats;
3016         JCCase c;
3017         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
3018         switch (token.kind) {
3019         case CASE: {
3020             nextToken();
3021             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
3022             while (true) {
3023                 pats.append(term(EXPR | NOLAMBDA));
3024                 if (token.kind != COMMA) break;
3025                 nextToken();
3026                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
3027             };
3028             CaseTree.CaseKind caseKind;
3029             JCTree body = null;
3030             if (token.kind == ARROW) {
3031                 checkSourceLevel(Feature.SWITCH_RULE);
3032                 accept(ARROW);
3033                 caseKind = JCCase.RULE;
3034                 JCStatement statement = parseStatementAsBlock();
3035                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3036                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3037                 }
3038                 stats = List.of(statement);
3039                 body = stats.head;
3040             } else {
3041                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3042                 caseKind = JCCase.STATEMENT;
3043                 stats = blockStatements();
3044             }
3045             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
3046             if (stats.isEmpty())
3047                 storeEnd(c, S.prevToken().endPos);
3048             return cases.append(c).toList();
3049         }
3050         case DEFAULT: {
3051             nextToken();
3052             CaseTree.CaseKind caseKind;
3053             JCTree body = null;
3054             if (token.kind == ARROW) {
3055                 checkSourceLevel(Feature.SWITCH_RULE);
3056                 accept(ARROW);
3057                 caseKind = JCCase.RULE;
3058                 JCStatement statement = parseStatementAsBlock();
3059                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3060                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3061                 }
3062                 stats = List.of(statement);
3063                 body = stats.head;
3064             } else {
3065                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3066                 caseKind = JCCase.STATEMENT;
3067                 stats = blockStatements();
3068             }
3069             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3070             if (stats.isEmpty())
3071                 storeEnd(c, S.prevToken().endPos);
3072             return cases.append(c).toList();
3073         }
3074         }
3075         throw new AssertionError(&quot;should not reach here&quot;);
3076     }
3077 
3078     /** MoreStatementExpressions = { COMMA StatementExpression }
3079      */
3080     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3081                                                                     JCExpression first,
3082                                                                     T stats) {
3083         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3084         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3085         while (token.kind == COMMA) {
3086             nextToken();
3087             pos = token.pos;
3088             JCExpression t = parseExpression();
3089             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3090             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3091         }
3092         return stats;
3093     }
3094 
3095     /** ForInit = StatementExpression MoreStatementExpressions
3096      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3097      */
3098     List&lt;JCStatement&gt; forInit() {
3099         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3100         int pos = token.pos;
3101         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3102             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3103         } else {
3104             JCExpression t = term(EXPR | TYPE);
3105             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3106                 pos = token.pos;
3107                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
3108                 F.at(pos);
3109                 return variableDeclarators(mods, t, stats, true).toList();
3110             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3111                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3112                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3113             } else {
3114                 return moreStatementExpressions(pos, t, stats).toList();
3115             }
3116         }
3117     }
3118 
3119     /** ForUpdate = StatementExpression MoreStatementExpressions
3120      */
3121     List&lt;JCExpressionStatement&gt; forUpdate() {
3122         return moreStatementExpressions(token.pos,
3123                                         parseExpression(),
3124                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3125     }
3126 
3127     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3128      *
3129      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3130      */
3131     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3132         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3133         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3134         int prevmode = mode;
3135         while (token.kind == MONKEYS_AT) {
3136             int pos = token.pos;
3137             nextToken();
3138             buf.append(annotation(pos, kind));
3139         }
3140         lastmode = mode;
3141         mode = prevmode;
3142         List&lt;JCAnnotation&gt; annotations = buf.toList();
3143 
3144         return annotations;
3145     }
3146 
3147     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3148         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3149         return annotations;
3150     }
3151 
3152     /** ModifiersOpt = { Modifier }
3153      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3154      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3155      *           | &quot;@&quot; Annotation
3156      */
3157     protected JCModifiers modifiersOpt() {
3158         return modifiersOpt(null);
3159     }
3160     protected JCModifiers modifiersOpt(JCModifiers partial) {
3161         long flags;
3162         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3163         int pos;
3164         if (partial == null) {
3165             flags = 0;
3166             pos = token.pos;
3167         } else {
3168             flags = partial.flags;
3169             annotations.appendList(partial.annotations);
3170             pos = partial.pos;
3171         }
3172         if (token.deprecatedFlag()) {
3173             flags |= Flags.DEPRECATED;
3174         }
3175         int lastPos;
3176     loop:
3177         while (true) {
3178             long flag;
3179             token = recastToken(token);
3180             switch (token.kind) {
3181             case PRIVATE     : flag = Flags.PRIVATE; break;
3182             case PROTECTED   : flag = Flags.PROTECTED; break;
3183             case PUBLIC      : flag = Flags.PUBLIC; break;
3184             case STATIC      : flag = Flags.STATIC; break;
3185             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3186             case FINAL       : flag = Flags.FINAL; break;
3187             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3188             case NATIVE      : flag = Flags.NATIVE; break;
3189             case VALUE       : flag = Flags.VALUE; break;
3190             case VOLATILE    : flag = Flags.VOLATILE; break;
3191             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3192             case STRICTFP    : flag = Flags.STRICTFP; break;
3193             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3194             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3195             case ERROR       : flag = 0; nextToken(); break;
3196             default: break loop;
3197             }
3198             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3199             lastPos = token.pos;
3200             nextToken();
3201             if (flag == Flags.ANNOTATION) {
3202                 if (token.kind != INTERFACE) {
3203                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3204                     // if first modifier is an annotation, set pos to annotation&#39;s.
3205                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3206                         pos = ann.pos;
3207                     final Name name = TreeInfo.name(ann.annotationType);
3208                     if (name == names.__inline__ || name == names.java_lang___inline__) {
3209                         flag = Flags.VALUE;
3210                     } else {
3211                         annotations.append(ann);
3212                         flag = 0;
3213                     }
3214                 }
3215             }
3216             flags |= flag;
3217         }
3218         switch (token.kind) {
3219         case ENUM: flags |= Flags.ENUM; break;
3220         case INTERFACE: flags |= Flags.INTERFACE; break;
3221         default: break;
3222         }
3223 
3224         /* A modifiers tree with no modifier tokens or annotations
3225          * has no text position. */
3226         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3227             pos = Position.NOPOS;
3228 
3229         // Force value classes to be automatically final.
3230         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {
3231             flags |= Flags.FINAL;
3232         }
3233 
3234         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3235         if (pos != Position.NOPOS)
3236             storeEnd(mods, S.prevToken().endPos);
3237         return mods;
3238     }
3239 
3240     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3241      *
3242      * @param pos position of &quot;@&quot; token
3243      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3244      */
3245     JCAnnotation annotation(int pos, Tag kind) {
3246         // accept(AT); // AT consumed by caller
3247         if (kind == Tag.TYPE_ANNOTATION) {
3248             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3249         }
3250         JCTree ident = qualident(false);
3251         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3252         JCAnnotation ann;
3253         if (kind == Tag.ANNOTATION) {
3254             ann = F.at(pos).Annotation(ident, fieldValues);
3255         } else if (kind == Tag.TYPE_ANNOTATION) {
3256             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3257         } else {
3258             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3259         }
3260 
3261         storeEnd(ann, S.prevToken().endPos);
3262         return ann;
3263     }
3264 
3265     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3266         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3267     }
3268 
3269     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3270     List&lt;JCExpression&gt; annotationFieldValues() {
3271         accept(LPAREN);
3272         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3273         if (token.kind != RPAREN) {
3274             buf.append(annotationFieldValue());
3275             while (token.kind == COMMA) {
3276                 nextToken();
3277                 buf.append(annotationFieldValue());
3278             }
3279         }
3280         accept(RPAREN);
3281         return buf.toList();
3282     }
3283 
3284     /** AnnotationFieldValue    = AnnotationValue
3285      *                          | Identifier &quot;=&quot; AnnotationValue
3286      */
3287     JCExpression annotationFieldValue() {
3288         if (LAX_IDENTIFIER.accepts(token.kind)) {
3289             selectExprMode();
3290             JCExpression t1 = term1();
3291             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3292                 int pos = token.pos;
3293                 accept(EQ);
3294                 JCExpression v = annotationValue();
3295                 return toP(F.at(pos).Assign(t1, v));
3296             } else {
3297                 return t1;
3298             }
3299         }
3300         return annotationValue();
3301     }
3302 
3303     /* AnnotationValue          = ConditionalExpression
3304      *                          | Annotation
3305      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3306      */
3307     JCExpression annotationValue() {
3308         int pos;
3309         switch (token.kind) {
3310         case MONKEYS_AT:
3311             pos = token.pos;
3312             nextToken();
3313             return annotation(pos, Tag.ANNOTATION);
3314         case LBRACE:
3315             pos = token.pos;
3316             accept(LBRACE);
3317             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3318             if (token.kind == COMMA) {
3319                 nextToken();
3320             } else if (token.kind != RBRACE) {
3321                 buf.append(annotationValue());
3322                 while (token.kind == COMMA) {
3323                     nextToken();
3324                     if (token.kind == RBRACE) break;
3325                     buf.append(annotationValue());
3326                 }
3327             }
3328             accept(RBRACE);
3329             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3330         default:
3331             selectExprMode();
3332             return term1();
3333         }
3334     }
3335 
3336     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3337      */
3338     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3339                                                                          JCExpression type,
3340                                                                          T vdefs,
3341                                                                          boolean localDecl)
3342     {
3343         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3344     }
3345 
3346     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3347      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3348      *
3349      *  @param reqInit  Is an initializer always required?
3350      *  @param dc       The documentation comment for the variable declarations, or null.
3351      */
3352     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3353                                                                      JCModifiers mods,
3354                                                                      JCExpression type,
3355                                                                      Name name,
3356                                                                      boolean reqInit,
3357                                                                      Comment dc,
3358                                                                      T vdefs,
3359                                                                      boolean localDecl)
3360     {
3361         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3362         vdefs.append(head);
3363         while (token.kind == COMMA) {
3364             // All but last of multiple declarators subsume a comma
3365             storeEnd((JCTree)vdefs.last(), token.endPos);
3366             nextToken();
3367             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3368         }
3369         return vdefs;
3370     }
3371 
3372     /** VariableDeclarator = Ident VariableDeclaratorRest
3373      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3374      */
3375     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3376         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3377     }
3378 
3379     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3380      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3381      *
3382      *  @param reqInit  Is an initializer always required?
3383      *  @param dc       The documentation comment for the variable declarations, or null.
3384      */
3385     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3386                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3387         type = bracketsOpt(type);
3388         JCExpression init = null;
3389         if (token.kind == EQ) {
3390             nextToken();
3391             init = variableInitializer();
3392         }
3393         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3394         JCTree elemType = TreeInfo.innermostType(type, true);
3395         int startPos = Position.NOPOS;
3396         if (elemType.hasTag(IDENT)) {
3397             Name typeName = ((JCIdent)elemType).name;
3398             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3399                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3400                     //error - &#39;var&#39; and arrays
3401                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3402                 } else {
3403                     if(compound)
3404                         //error - &#39;var&#39; in compound local var decl
3405                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3406                     startPos = TreeInfo.getStartPos(mods);
3407                     if (startPos == Position.NOPOS)
3408                         startPos = TreeInfo.getStartPos(type);
3409                     //implicit type
3410                     type = null;
3411                 }
3412             }
3413         }
3414         JCVariableDecl result =
3415             toP(F.at(pos).VarDef(mods, name, type, init));
3416         attach(result, dc);
3417         result.startPos = startPos;
3418         return result;
3419     }
3420 
3421     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.
3422     Token recastToken(Token token) {
3423         if (token.kind != IDENTIFIER || token.name() != names.inline) {
3424             return token;
3425         }
3426         if (peekToken(t-&gt;t == PRIVATE ||
3427                          t == PROTECTED ||
3428                          t == PUBLIC ||
3429                          t == STATIC ||
3430                          t == TRANSIENT ||
3431                          t == FINAL ||
3432                          t == ABSTRACT ||
3433                          t == NATIVE ||
3434                          t == VOLATILE ||
3435                          t == SYNCHRONIZED ||
3436                          t == STRICTFP ||
3437                          t == MONKEYS_AT ||
3438                          t == DEFAULT ||
3439                          t == BYTE ||
3440                          t == SHORT ||
3441                          t == CHAR ||
3442                          t == INT ||
3443                          t == LONG ||
3444                          t == FLOAT ||
3445                          t == DOUBLE ||
3446                          t == BOOLEAN ||
3447                          t == CLASS ||
3448                          t == INTERFACE ||
3449                          t == ENUM ||
3450                          t == IDENTIFIER)) { // new value Comparable() {}
3451             checkSourceLevel(Feature.INLINE_TYPES);
3452             return new Token(VALUE, token.pos, token.endPos, token.comments);
3453         }
3454         return token;
3455     }
3456 
3457     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3458         switch (e.getTag()) {
3459             case IDENT:
3460                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3461             case TYPEARRAY:
3462                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3463             default:
3464                 return null;
3465         }
3466     }
3467 
3468     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3469         if (name == names.var) {
3470             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3471                 return Source.JDK10;
3472             } else if (shouldWarn) {
3473                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3474             }
3475         }
3476         if (name == names.yield) {
3477             if (allowYieldStatement) {
3478                 return Source.JDK14;
3479             } else if (shouldWarn) {
3480                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3481             }
3482         }
3483         if (name == names.record) {
3484             if (allowRecords) {
3485                 return Source.JDK14;
3486             } else if (shouldWarn) {
3487                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3488             }
3489         }
3490         return null;
3491     }
3492 
3493     /** VariableDeclaratorId = Ident BracketsOpt
3494      */
3495     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3496         return variableDeclaratorId(mods, type, false);
3497     }
3498     //where
3499     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3500         int pos = token.pos;
3501         Name name;
3502         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3503             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3504             name = token.name();
3505             nextToken();
3506         } else {
3507             if (allowThisIdent ||
3508                 !lambdaParameter ||
3509                 LAX_IDENTIFIER.accepts(token.kind) ||
3510                 mods.flags != Flags.PARAMETER ||
3511                 mods.annotations.nonEmpty()) {
3512                 JCExpression pn = qualident(false);
3513                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3514                     name = ((JCIdent)pn).name;
3515                 } else {
3516                     if (allowThisIdent) {
3517                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3518                             log.error(token.pos, Errors.VarargsAndReceiver);
3519                         }
3520                         if (token.kind == LBRACKET) {
3521                             log.error(token.pos, Errors.ArrayAndReceiver);
3522                         }
3523                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3524                             log.error(token.pos, Errors.WrongReceiver);
3525                         }
3526                     }
3527                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3528                 }
3529             } else {
3530                 /** if it is a lambda parameter and the token kind is not an identifier,
3531                  *  and there are no modifiers or annotations, then this means that the compiler
3532                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3533                  *  var or explicit parameters. So we assign the error name to the parameter name
3534                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3535                  *  a higher level.
3536                  */
3537                 name = names.empty;
3538             }
3539         }
3540         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3541                 token.kind == LBRACKET) {
3542             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3543         }
3544         type = bracketsOpt(type);
3545 
3546         return toP(F.at(pos).VarDef(mods, name, type, null));
3547     }
3548 
3549     /** Resources = Resource { &quot;;&quot; Resources }
3550      */
3551     List&lt;JCTree&gt; resources() {
3552         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3553         defs.append(resource());
3554         while (token.kind == SEMI) {
3555             // All but last of multiple declarators must subsume a semicolon
3556             storeEnd(defs.last(), token.endPos);
3557             int semiColonPos = token.pos;
3558             nextToken();
3559             if (token.kind == RPAREN) { // Optional trailing semicolon
3560                                        // after last resource
3561                 break;
3562             }
3563             defs.append(resource());
3564         }
3565         return defs.toList();
3566     }
3567 
3568     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3569      *           | Expression
3570      */
3571     protected JCTree resource() {
3572         int startPos = token.pos;
3573         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3574             JCModifiers mods = optFinal(Flags.FINAL);
3575             JCExpression t = parseType(true);
3576             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3577         }
3578         JCExpression t = term(EXPR | TYPE);
3579         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3580             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3581             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3582         } else {
3583             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3584             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3585                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3586             }
3587 
3588             return t;
3589         }
3590     }
3591 
3592     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3593      */
3594     public JCTree.JCCompilationUnit parseCompilationUnit() {
3595         Token firstToken = token;
3596         JCModifiers mods = null;
3597         boolean consumedToplevelDoc = false;
3598         boolean seenImport = false;
3599         boolean seenPackage = false;
3600         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3601         if (token.kind == MONKEYS_AT)
3602             mods = modifiersOpt();
3603 
3604         if (token.kind == PACKAGE) {
3605             int packagePos = token.pos;
3606             List&lt;JCAnnotation&gt; annotations = List.nil();
3607             seenPackage = true;
3608             if (mods != null) {
3609                 checkNoMods(mods.flags);
3610                 annotations = mods.annotations;
3611                 mods = null;
3612             }
3613             nextToken();
3614             JCExpression pid = qualident(false);
3615             accept(SEMI);
3616             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3617             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3618             consumedToplevelDoc = true;
3619             defs.append(pd);
3620         }
3621 
3622         boolean checkForImports = true;
3623         boolean firstTypeDecl = true;
3624         while (token.kind != EOF) {
3625             if (token.pos &lt;= endPosTable.errorEndPos) {
3626                 // error recovery
3627                 skip(checkForImports, false, false, false);
3628                 if (token.kind == EOF)
3629                     break;
3630             }
3631             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3632                 seenImport = true;
3633                 defs.append(importDeclaration());
3634             } else {
3635                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3636                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3637                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3638                     consumedToplevelDoc = true;
3639                 }
3640                 if (mods != null || token.kind != SEMI)
3641                     mods = modifiersOpt(mods);
3642                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3643                     ModuleKind kind = ModuleKind.STRONG;
3644                     if (token.name() == names.open) {
3645                         kind = ModuleKind.OPEN;
3646                         nextToken();
3647                     }
3648                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3649                         if (mods != null) {
3650                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3651                         }
3652                         defs.append(moduleDecl(mods, kind, docComment));
3653                         consumedToplevelDoc = true;
3654                         break;
3655                     } else if (kind != ModuleKind.STRONG) {
3656                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3657                     }
3658                 }
3659                 JCTree def = typeDeclaration(mods, docComment);
3660                 if (def instanceof JCExpressionStatement)
3661                     def = ((JCExpressionStatement)def).expr;
3662                 defs.append(def);
3663                 if (def instanceof JCClassDecl)
3664                     checkForImports = false;
3665                 mods = null;
3666                 firstTypeDecl = false;
3667             }
3668         }
3669         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3670         if (!consumedToplevelDoc)
3671             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3672         if (defs.isEmpty())
3673             storeEnd(toplevel, S.prevToken().endPos);
3674         if (keepDocComments)
3675             toplevel.docComments = docComments;
3676         if (keepLineMap)
3677             toplevel.lineMap = S.getLineMap();
3678         this.endPosTable.setParser(null); // remove reference to parser
3679         toplevel.endPositions = this.endPosTable;
3680         return toplevel;
3681     }
3682 
3683     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3684         int pos = token.pos;
3685         checkSourceLevel(Feature.MODULES);
3686 
3687         nextToken();
3688         JCExpression name = qualident(false);
3689         List&lt;JCDirective&gt; directives = null;
3690 
3691         accept(LBRACE);
3692         directives = moduleDirectiveList();
3693         accept(RBRACE);
3694         accept(EOF);
3695 
3696         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3697         attach(result, dc);
3698         return result;
3699     }
3700 
3701     List&lt;JCDirective&gt; moduleDirectiveList() {
3702         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3703         while (token.kind == IDENTIFIER) {
3704             int pos = token.pos;
3705             if (token.name() == names.requires) {
3706                 nextToken();
3707                 boolean isTransitive = false;
3708                 boolean isStaticPhase = false;
3709             loop:
3710                 while (true) {
3711                     switch (token.kind) {
3712                         case IDENTIFIER:
3713                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3714                                 Token t1 = S.token(1);
3715                                 if (t1.kind == SEMI || t1.kind == DOT) {
3716                                     break loop;
3717                                 }
3718                                 isTransitive = true;
3719                                 break;
3720                             } else {
3721                                 break loop;
3722                             }
3723                         case STATIC:
3724                             if (isStaticPhase) {
3725                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3726                             }
3727                             isStaticPhase = true;
3728                             break;
3729                         default:
3730                             break loop;
3731                     }
3732                     nextToken();
3733                 }
3734                 JCExpression moduleName = qualident(false);
3735                 accept(SEMI);
3736                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3737             } else if (token.name() == names.exports || token.name() == names.opens) {
3738                 boolean exports = token.name() == names.exports;
3739                 nextToken();
3740                 JCExpression pkgName = qualident(false);
3741                 List&lt;JCExpression&gt; moduleNames = null;
3742                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3743                     nextToken();
3744                     moduleNames = qualidentList(false);
3745                 }
3746                 accept(SEMI);
3747                 JCDirective d;
3748                 if (exports) {
3749                     d = F.at(pos).Exports(pkgName, moduleNames);
3750                 } else {
3751                     d = F.at(pos).Opens(pkgName, moduleNames);
3752                 }
3753                 defs.append(toP(d));
3754             } else if (token.name() == names.provides) {
3755                 nextToken();
3756                 JCExpression serviceName = qualident(false);
3757                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3758                     nextToken();
3759                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3760                     accept(SEMI);
3761                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3762                 } else {
3763                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3764                     skip(false, false, false, false);
3765                 }
3766             } else if (token.name() == names.uses) {
3767                 nextToken();
3768                 JCExpression service = qualident(false);
3769                 accept(SEMI);
3770                 defs.append(toP(F.at(pos).Uses(service)));
3771             } else {
3772                 setErrorEndPos(pos);
3773                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3774                 break;
3775             }
3776         }
3777         return defs.toList();
3778     }
3779 
3780     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3781      */
3782     protected JCTree importDeclaration() {
3783         int pos = token.pos;
3784         nextToken();
3785         boolean importStatic = false;
3786         if (token.kind == STATIC) {
3787             importStatic = true;
3788             nextToken();
3789         }
3790         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3791         do {
3792             int pos1 = token.pos;
3793             accept(DOT);
3794             if (token.kind == STAR) {
3795                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3796                 nextToken();
3797                 break;
3798             } else {
3799                 pid = toP(F.at(pos1).Select(pid, ident()));
3800             }
3801         } while (token.kind == DOT);
3802         accept(SEMI);
3803         return toP(F.at(pos).Import(pid, importStatic));
3804     }
3805 
3806     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3807      *                  | &quot;;&quot;
3808      */
3809     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3810         int pos = token.pos;
3811         if (mods == null &amp;&amp; token.kind == SEMI) {
3812             nextToken();
3813             return toP(F.at(pos).Skip());
3814         } else {
3815             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3816         }
3817     }
3818 
3819     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3820      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3821      *  @param mods     Any modifiers starting the class or interface declaration
3822      *  @param dc       The documentation comment for the class, or null.
3823      */
3824     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3825         if (token.kind == CLASS) {
3826             return classDeclaration(mods, dc);
3827         } if (isRecordStart()) {
3828             return recordDeclaration(mods, dc);
3829         } else if (token.kind == INTERFACE) {
3830             return interfaceDeclaration(mods, dc);
3831         } else if (token.kind == ENUM) {
3832             return enumDeclaration(mods, dc);
3833         } else {
3834             int pos = token.pos;
3835             List&lt;JCTree&gt; errs;
3836             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3837                 checkSourceLevel(Feature.RECORDS);
3838                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3839                 return toP(F.Exec(erroneousTree));
3840             } else {
3841                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3842                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3843                     setErrorEndPos(token.pos);
3844                 } else {
3845                     errs = List.of(mods);
3846                 }
3847                 final JCErroneous erroneousTree;
3848                 if (parseModuleInfo) {
3849                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3850                 } else {
3851                     if (allowRecords) {
3852                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3853                     } else {
3854                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3855                     }
3856                 }
3857                 return toP(F.Exec(erroneousTree));
3858             }
3859         }
3860     }
3861 
3862     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3863      *                     [IMPLEMENTS TypeList] ClassBody
3864      *  @param mods    The modifiers starting the class declaration
3865      *  @param dc       The documentation comment for the class, or null.
3866      */
3867     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3868         int pos = token.pos;
3869         accept(CLASS);
3870         Name name = typeName();
3871 
3872         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3873 
3874         JCExpression extending = null;
3875         if (token.kind == EXTENDS) {
3876             nextToken();
3877             extending = parseType();
3878         }
3879         List&lt;JCExpression&gt; implementing = List.nil();
3880         if (token.kind == IMPLEMENTS) {
3881             nextToken();
3882             implementing = typeList();
3883         }
3884         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3885         JCClassDecl result = toP(F.at(pos).ClassDef(
3886             mods, name, typarams, extending, implementing, defs));
3887         attach(result, dc);
3888         return result;
3889     }
3890 
3891     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3892         int pos = token.pos;
3893         nextToken();
3894         mods.flags |= Flags.RECORD;
3895         Name name = typeName();
3896 
3897         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3898 
3899         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3900 
3901         List&lt;JCExpression&gt; implementing = List.nil();
3902         if (token.kind == IMPLEMENTS) {
3903             nextToken();
3904             implementing = typeList();
3905         }
3906         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3907         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3908         for (JCVariableDecl field : headerFields) {
3909             fields.add(field);
3910         }
3911         for (JCTree def : defs) {
3912             if (def.hasTag(METHODDEF)) {
3913                 JCMethodDecl methDef = (JCMethodDecl) def;
3914                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3915                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3916                     for (JCVariableDecl param : headerFields) {
3917                         tmpParams.add(F.at(param)
3918                                 // we will get flags plus annotations from the record component
3919                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3920                                 param.name, param.vartype, null));
3921                     }
3922                     methDef.params = tmpParams.toList();
3923                 }
3924             }
3925         }
3926         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3927             JCVariableDecl field = fields.get(i);
3928             defs = defs.prepend(field);
3929         }
3930         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3931         attach(result, dc);
3932         return result;
3933     }
3934 
3935     Name typeName() {
3936         int pos = token.pos;
3937         Name name = ident();
3938         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3939         if (source != null) {
3940             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3941         }
3942         return name;
3943     }
3944 
3945     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3946      *                         [EXTENDS TypeList] InterfaceBody
3947      *  @param mods    The modifiers starting the interface declaration
3948      *  @param dc       The documentation comment for the interface, or null.
3949      */
3950     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3951         int pos = token.pos;
3952         accept(INTERFACE);
3953 
3954         Name name = typeName();
3955 
3956         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3957 
3958         List&lt;JCExpression&gt; extending = List.nil();
3959         if (token.kind == EXTENDS) {
3960             nextToken();
3961             extending = typeList();
3962         }
3963         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3964         JCClassDecl result = toP(F.at(pos).ClassDef(
3965             mods, name, typarams, null, extending, defs));
3966         attach(result, dc);
3967         return result;
3968     }
3969 
3970     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3971      *  @param mods    The modifiers starting the enum declaration
3972      *  @param dc       The documentation comment for the enum, or null.
3973      */
3974     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3975         int pos = token.pos;
3976         accept(ENUM);
3977 
3978         Name name = typeName();
3979 
3980         List&lt;JCExpression&gt; implementing = List.nil();
3981         if (token.kind == IMPLEMENTS) {
3982             nextToken();
3983             implementing = typeList();
3984         }
3985 
3986         List&lt;JCTree&gt; defs = enumBody(name);
3987         mods.flags |= Flags.ENUM;
3988         JCClassDecl result = toP(F.at(pos).
3989             ClassDef(mods, name, List.nil(),
3990                      null, implementing, defs));
3991         attach(result, dc);
3992         return result;
3993     }
3994 
3995     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3996      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3997      */
3998     List&lt;JCTree&gt; enumBody(Name enumName) {
3999         accept(LBRACE);
4000         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4001         boolean wasSemi = false;
4002         boolean hasStructuralErrors = false;
4003         boolean wasError = false;
4004         if (token.kind == COMMA) {
4005             nextToken();
4006             if (token.kind == SEMI) {
4007                 wasSemi = true;
4008                 nextToken();
4009             } else if (token.kind != RBRACE) {
4010                 reportSyntaxError(S.prevToken().endPos,
4011                                   Errors.Expected2(RBRACE, SEMI));
4012                 wasError = true;
4013             }
4014         }
4015         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4016             if (token.kind == SEMI) {
4017                 accept(SEMI);
4018                 wasSemi = true;
4019                 if (token.kind == RBRACE || token.kind == EOF) break;
4020             }
4021             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
4022             if (memberType == EnumeratorEstimate.UNKNOWN) {
4023                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
4024                                      : EnumeratorEstimate.ENUMERATOR;
4025             }
4026             if (memberType == EnumeratorEstimate.ENUMERATOR) {
4027                 wasError = false;
4028                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
4029                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
4030                     hasStructuralErrors = true;
4031                 }
4032                 defs.append(enumeratorDeclaration(enumName));
4033                 if (token.pos &lt;= endPosTable.errorEndPos) {
4034                     // error recovery
4035                    skip(false, true, true, false);
4036                 } else {
4037                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
4038                         if (token.kind == COMMA) {
4039                             nextToken();
4040                         } else {
4041                             setErrorEndPos(token.pos);
4042                             reportSyntaxError(S.prevToken().endPos,
4043                                               Errors.Expected3(COMMA, RBRACE, SEMI));
4044                             wasError = true;
4045                         }
4046                     }
4047                 }
4048             } else {
4049                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
4050                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
4051                     hasStructuralErrors = true;
4052                 }
4053                 wasError = false;
4054                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
4055                                                                 false, false));
4056                 if (token.pos &lt;= endPosTable.errorEndPos) {
4057                     // error recovery
4058                    skip(false, true, true, false);
4059                 }
4060             }
4061         }
4062         accept(RBRACE);
4063         return defs.toList();
4064     }
4065 
4066     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
4067         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
4068             Token next = S.token(1);
4069             switch (next.kind) {
4070                 case LPAREN: case LBRACE: case COMMA: case SEMI:
4071                     return EnumeratorEstimate.ENUMERATOR;
4072             }
4073         }
4074         switch (token.kind) {
4075             case IDENTIFIER: case MONKEYS_AT: case LT:
4076                 return EnumeratorEstimate.UNKNOWN;
4077             default:
4078                 return EnumeratorEstimate.MEMBER;
4079         }
4080     }
4081 
4082     private enum EnumeratorEstimate {
4083         ENUMERATOR,
4084         MEMBER,
4085         UNKNOWN;
4086     }
4087 
4088     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
4089      */
4090     JCTree enumeratorDeclaration(Name enumName) {
4091         Comment dc = token.comment(CommentStyle.JAVADOC);
4092         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
4093         if (token.deprecatedFlag()) {
4094             flags |= Flags.DEPRECATED;
4095         }
4096         int pos = token.pos;
4097         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
4098         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
4099         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4100         int identPos = token.pos;
4101         Name name = ident();
4102         int createPos = token.pos;
4103         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4104             ? arguments() : List.nil();
4105         JCClassDecl body = null;
4106         if (token.kind == LBRACE) {
4107             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4108             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4109             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4110         }
4111         if (args.isEmpty() &amp;&amp; body == null)
4112             createPos = identPos;
4113         JCIdent ident = F.at(identPos).Ident(enumName);
4114         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4115         if (createPos != identPos)
4116             storeEnd(create, S.prevToken().endPos);
4117         ident = F.at(identPos).Ident(enumName);
4118         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4119         attach(result, dc);
4120         return result;
4121     }
4122 
4123     /** TypeList = Type {&quot;,&quot; Type}
4124      */
4125     List&lt;JCExpression&gt; typeList() {
4126         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4127         ts.append(parseType());
4128         while (token.kind == COMMA) {
4129             nextToken();
4130             ts.append(parseType());
4131         }
4132         return ts.toList();
4133     }
4134 
4135     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4136      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4137      */
4138     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4139         accept(LBRACE);
4140         if (token.pos &lt;= endPosTable.errorEndPos) {
4141             // error recovery
4142             skip(false, true, false, false);
4143             if (token.kind == LBRACE)
4144                 nextToken();
4145         }
4146         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4147         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4148             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4149             if (token.pos &lt;= endPosTable.errorEndPos) {
4150                // error recovery
4151                skip(false, true, true, false);
4152            }
4153         }
4154         accept(RBRACE);
4155         return defs.toList();
4156     }
4157 
4158     /** ClassBodyDeclaration =
4159      *      &quot;;&quot;
4160      *    | [STATIC] Block
4161      *    | ModifiersOpt
4162      *      ( Type Ident
4163      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4164      *      | VOID Ident VoidMethodDeclaratorRest
4165      *      | TypeParameters [Annotations]
4166      *        ( Type Ident MethodDeclaratorRest
4167      *        | VOID Ident VoidMethodDeclaratorRest
4168      *        )
4169      *      | Ident ConstructorDeclaratorRest
4170      *      | TypeParameters Ident ConstructorDeclaratorRest
4171      *      | ClassOrInterfaceOrEnumDeclaration
4172      *      )
4173      *  InterfaceBodyDeclaration =
4174      *      &quot;;&quot;
4175      *    | ModifiersOpt
4176      *      ( Type Ident
4177      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4178      *      | VOID Ident MethodDeclaratorRest
4179      *      | TypeParameters [Annotations]
4180      *        ( Type Ident MethodDeclaratorRest
4181      *        | VOID Ident VoidMethodDeclaratorRest
4182      *        )
4183      *      | ClassOrInterfaceOrEnumDeclaration
4184      *      )
4185      *
4186      */
4187     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4188         if (token.kind == SEMI) {
4189             nextToken();
4190             return List.nil();
4191         } else {
4192             Comment dc = token.comment(CommentStyle.JAVADOC);
4193             int pos = token.pos;
4194             JCModifiers mods = modifiersOpt();
4195             if (token.kind == CLASS ||
4196                 allowRecords &amp;&amp; isRecordStart() ||
4197                 token.kind == INTERFACE ||
4198                 token.kind == ENUM) {
4199                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4200             } else if (token.kind == LBRACE &amp;&amp;
4201                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4202                        mods.annotations.isEmpty()) {
4203                 if (isInterface) {
4204                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4205                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4206                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4207                 }
4208                 return List.of(block(pos, mods.flags));
4209             } else {
4210                 pos = token.pos;
4211                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4212                 // if there are type parameters but no modifiers, save the start
4213                 // position of the method in the modifiers.
4214                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4215                     mods.pos = pos;
4216                     storeEnd(mods, pos);
4217                 }
4218                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4219 
4220                 if (annosAfterParams.nonEmpty()) {
4221                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4222                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4223                     if (mods.pos == Position.NOPOS)
4224                         mods.pos = mods.annotations.head.pos;
4225                 }
4226 
4227                 Token tk = token;
4228                 pos = token.pos;
4229                 JCExpression type;
4230                 boolean isVoid = token.kind == VOID;
4231                 if (isVoid) {
4232                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4233                     nextToken();
4234                 } else {
4235                     // method returns types are un-annotated types
4236                     type = unannotatedType(false, TYPE);
4237                 }
4238                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4239                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4240                     if (isInterface || tk.name() != className)
4241                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4242                     else if (annosAfterParams.nonEmpty())
4243                         illegal(annosAfterParams.head.pos);
4244                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4245                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4246                     }
4247                     return List.of(methodDeclaratorRest(
4248                         pos, mods, null, names.init, typarams,
4249                         isInterface, true, isRecord, dc));
4250                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4251                     // trying to define a compact constructor with a throws clause
4252                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4253                             Errors.InvalidCanonicalConstructorInRecord(
4254                                     Fragments.Compact,
4255                                     className,
4256                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4257                     skip(false, true, false, false);
4258                     return List.of(methodDeclaratorRest(
4259                             pos, mods, null, names.init, typarams,
4260                             isInterface, true, isRecord, dc));
4261                 } else {
4262                     pos = token.pos;
4263                     Name name = ident();
4264                     if (token.kind == LPAREN) {
4265                         return List.of(methodDeclaratorRest(
4266                             pos, mods, type, name, typarams,
4267                             isInterface, isVoid, false, dc));
4268                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4269                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4270                         List&lt;JCTree&gt; defs =
4271                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4272                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4273                         accept(SEMI);
4274                         storeEnd(defs.last(), S.prevToken().endPos);
4275                         return defs;
4276                     } else {
4277                             int errPos = pos;
4278                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4279                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4280                             accept(SEMI);
4281                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4282                         }
4283                     } else {
4284                         pos = token.pos;
4285                         List&lt;JCTree&gt; err;
4286                         if (isVoid || typarams.nonEmpty()) {
4287                             JCMethodDecl m =
4288                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4289                                                             List.nil(), List.nil(), null, null));
4290                             attach(m, dc);
4291                             err = List.of(m);
4292                         } else {
4293                             err = List.nil();
4294                         }
4295                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4296                     }
4297                 }
4298             }
4299         }
4300     }
4301 
4302     protected boolean isRecordStart() {
4303      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4304             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4305              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4306              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4307           checkSourceLevel(Feature.RECORDS);
4308           return true;
4309     } else {
4310        return false;
4311    }
4312 }
4313 
4314     /** MethodDeclaratorRest =
4315      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4316      *  VoidMethodDeclaratorRest =
4317      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4318      *  ConstructorDeclaratorRest =
4319      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4320      */
4321     protected JCTree methodDeclaratorRest(int pos,
4322                               JCModifiers mods,
4323                               JCExpression type,
4324                               Name name,
4325                               List&lt;JCTypeParameter&gt; typarams,
4326                               boolean isInterface, boolean isVoid,
4327                               boolean isRecord,
4328                               Comment dc) {
4329         if (isInterface) {
4330             if ((mods.flags &amp; Flags.STATIC) != 0) {
4331                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4332             }
4333             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4334                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4335             }
4336         }
4337         JCVariableDecl prevReceiverParam = this.receiverParam;
4338         try {
4339             this.receiverParam = null;
4340             // Parsing formalParameters sets the receiverParam, if present
4341             List&lt;JCVariableDecl&gt; params = List.nil();
4342             List&lt;JCExpression&gt; thrown = List.nil();
4343             if (!isRecord || name != names.init || token.kind == LPAREN) {
4344                 params = formalParameters();
4345                 if (!isVoid) type = bracketsOpt(type);
4346                 if (token.kind == THROWS) {
4347                     nextToken();
4348                     thrown = qualidentList(true);
4349                 }
4350             }
4351             JCBlock body = null;
4352             JCExpression defaultValue;
4353             if (token.kind == LBRACE) {
4354                 body = block();
4355                 defaultValue = null;
4356             } else {
4357                 if (token.kind == DEFAULT) {
4358                     accept(DEFAULT);
4359                     defaultValue = annotationValue();
4360                 } else {
4361                     defaultValue = null;
4362                 }
4363                 accept(SEMI);
4364                 if (token.pos &lt;= endPosTable.errorEndPos) {
4365                     // error recovery
4366                     skip(false, true, false, false);
4367                     if (token.kind == LBRACE) {
4368                         body = block();
4369                     }
4370                 }
4371             }
4372 
4373             JCMethodDecl result =
4374                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4375                                             receiverParam, params, thrown,
4376                                             body, defaultValue));
4377             attach(result, dc);
4378             return result;
4379         } finally {
4380             this.receiverParam = prevReceiverParam;
4381         }
4382     }
4383 
4384     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4385      */
4386     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4387         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4388 
4389         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4390         JCExpression qi = qualident(allowAnnos);
4391         if (!typeAnnos.isEmpty()) {
4392             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4393             ts.append(at);
4394         } else {
4395             ts.append(qi);
4396         }
4397         while (token.kind == COMMA) {
4398             nextToken();
4399 
4400             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4401             qi = qualident(allowAnnos);
4402             if (!typeAnnos.isEmpty()) {
4403                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4404                 ts.append(at);
4405             } else {
4406                 ts.append(qi);
4407             }
4408         }
4409         return ts.toList();
4410     }
4411 
4412     /**
4413      *  {@literal
4414      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4415      *  }
4416      */
4417     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4418         if (token.kind == LT) {
4419             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4420             nextToken();
4421             typarams.append(typeParameter());
4422             while (token.kind == COMMA) {
4423                 nextToken();
4424                 typarams.append(typeParameter());
4425             }
4426             accept(GT);
4427             return typarams.toList();
4428         } else {
4429             return List.nil();
4430         }
4431     }
4432 
4433     /**
4434      *  {@literal
4435      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4436      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4437      *  TypeVariable = Ident
4438      *  }
4439      */
4440     JCTypeParameter typeParameter() {
4441         int pos = token.pos;
4442         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4443         Name name = typeName();
4444         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4445         if (token.kind == EXTENDS) {
4446             nextToken();
4447             bounds.append(parseType());
4448             while (token.kind == AMP) {
4449                 nextToken();
4450                 bounds.append(parseType());
4451             }
4452         }
4453         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4454     }
4455 
4456     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4457      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4458      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4459      */
4460     List&lt;JCVariableDecl&gt; formalParameters() {
4461         return formalParameters(false, false);
4462     }
4463     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4464         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4465         JCVariableDecl lastParam;
4466         accept(LPAREN);
4467         if (token.kind != RPAREN) {
4468             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4469             lastParam = formalParameter(lambdaParameters, recordComponents);
4470             if (lastParam.nameexpr != null) {
4471                 this.receiverParam = lastParam;
4472             } else {
4473                 params.append(lastParam);
4474             }
4475             this.allowThisIdent = false;
4476             while (token.kind == COMMA) {
4477                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4478                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4479                 }
4480                 nextToken();
4481                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4482             }
4483         }
4484         if (token.kind == RPAREN) {
4485             nextToken();
4486         } else {
4487             setErrorEndPos(token.pos);
4488             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4489         }
4490         return params.toList();
4491     }
4492 
4493     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4494         if (hasParens) {
4495             accept(LPAREN);
4496         }
4497         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4498         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4499             params.append(implicitParameter());
4500             while (token.kind == COMMA) {
4501                 nextToken();
4502                 params.append(implicitParameter());
4503             }
4504         }
4505         if (hasParens) {
4506             accept(RPAREN);
4507         }
4508         return params.toList();
4509     }
4510 
4511     JCModifiers optFinal(long flags) {
4512         JCModifiers mods = modifiersOpt();
4513         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4514         mods.flags |= flags;
4515         return mods;
4516     }
4517 
4518     /**
4519      * Inserts the annotations (and possibly a new array level)
4520      * to the left-most type in an array or nested type.
4521      *
4522      * When parsing a type like {@code @B Outer.Inner @A []}, the
4523      * {@code @A} annotation should target the array itself, while
4524      * {@code @B} targets the nested type {@code Outer}.
4525      *
4526      * Currently the parser parses the annotation first, then
4527      * the array, and then inserts the annotation to the left-most
4528      * nested type.
4529      *
4530      * When {@code createNewLevel} is true, then a new array
4531      * level is inserted as the most inner type, and have the
4532      * annotations target it.  This is useful in the case of
4533      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4534      * first parses the type {@code String @A []} then inserts
4535      * a new array level with {@code @B} annotation.
4536      */
4537     private JCExpression insertAnnotationsToMostInner(
4538             JCExpression type, List&lt;JCAnnotation&gt; annos,
4539             boolean createNewLevel) {
4540         int origEndPos = getEndPos(type);
4541         JCExpression mostInnerType = type;
4542         JCArrayTypeTree mostInnerArrayType = null;
4543         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4544             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4545             mostInnerType = mostInnerArrayType.elemtype;
4546         }
4547 
4548         if (createNewLevel) {
4549             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4550         }
4551 
4552         JCExpression mostInnerTypeToReturn = mostInnerType;
4553         if (annos.nonEmpty()) {
4554             JCExpression lastToModify = mostInnerType;
4555 
4556             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4557                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4558                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4559                     lastToModify = mostInnerType;
4560                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4561                 }
4562                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4563                     lastToModify = mostInnerType;
4564                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4565                 }
4566             }
4567 
4568             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4569 
4570             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4571                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4572             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4573                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4574             } else {
4575                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4576                 mostInnerTypeToReturn = mostInnerType;
4577             }
4578         }
4579 
4580         if (mostInnerArrayType == null) {
4581             return mostInnerTypeToReturn;
4582         } else {
4583             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4584             storeEnd(type, origEndPos);
4585             return type;
4586         }
4587     }
4588 
4589     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4590      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4591      */
4592     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4593         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4594         if (recordComponent &amp;&amp; mods.flags != 0) {
4595             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4596         }
4597         if (recordComponent) {
4598             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4599         }
4600         // need to distinguish between vararg annos and array annos
4601         // look at typeAnnotationsPushedBack comment
4602         this.permitTypeAnnotationsPushBack = true;
4603         JCExpression type = parseType(lambdaParameter);
4604         this.permitTypeAnnotationsPushBack = false;
4605 
4606         if (token.kind == ELLIPSIS) {
4607             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4608             typeAnnotationsPushedBack = List.nil();
4609             mods.flags |= Flags.VARARGS;
4610             // insert var arg type annotations
4611             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4612             nextToken();
4613         } else {
4614             // if not a var arg, then typeAnnotationsPushedBack should be null
4615             if (typeAnnotationsPushedBack.nonEmpty()) {
4616                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4617             }
4618             typeAnnotationsPushedBack = List.nil();
4619         }
4620         return variableDeclaratorId(mods, type, lambdaParameter);
4621     }
4622 
4623     protected JCVariableDecl implicitParameter() {
4624         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4625         return variableDeclaratorId(mods, null, true);
4626     }
4627 
4628 /* ---------- auxiliary methods -------------- */
4629     /** Check that given tree is a legal expression statement.
4630      */
4631     protected JCExpression checkExprStat(JCExpression t) {
4632         if (!TreeInfo.isExpressionStatement(t)) {
4633             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4634             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4635             return ret;
4636         } else {
4637             return t;
4638         }
4639     }
4640 
4641     /** Return precedence of operator represented by token,
4642      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4643      */
4644     static int prec(TokenKind token) {
4645         JCTree.Tag oc = optag(token);
4646         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4647     }
4648 
4649     /**
4650      * Return the lesser of two positions, making allowance for either one
4651      * being unset.
4652      */
4653     static int earlier(int pos1, int pos2) {
4654         if (pos1 == Position.NOPOS)
4655             return pos2;
4656         if (pos2 == Position.NOPOS)
4657             return pos1;
4658         return (pos1 &lt; pos2 ? pos1 : pos2);
4659     }
4660 
4661     /** Return operation tag of binary operator represented by token,
4662      *  No_TAG if token is not a binary operator.
4663      */
4664     static JCTree.Tag optag(TokenKind token) {
4665         switch (token) {
4666         case BARBAR:
4667             return OR;
4668         case AMPAMP:
4669             return AND;
4670         case BAR:
4671             return BITOR;
4672         case BAREQ:
4673             return BITOR_ASG;
4674         case CARET:
4675             return BITXOR;
4676         case CARETEQ:
4677             return BITXOR_ASG;
4678         case AMP:
4679             return BITAND;
4680         case AMPEQ:
4681             return BITAND_ASG;
4682         case EQEQ:
4683             return JCTree.Tag.EQ;
4684         case BANGEQ:
4685             return NE;
4686         case LT:
4687             return JCTree.Tag.LT;
4688         case GT:
4689             return JCTree.Tag.GT;
4690         case LTEQ:
4691             return LE;
4692         case GTEQ:
4693             return GE;
4694         case LTLT:
4695             return SL;
4696         case LTLTEQ:
4697             return SL_ASG;
4698         case GTGT:
4699             return SR;
4700         case GTGTEQ:
4701             return SR_ASG;
4702         case GTGTGT:
4703             return USR;
4704         case GTGTGTEQ:
4705             return USR_ASG;
4706         case PLUS:
4707             return JCTree.Tag.PLUS;
4708         case PLUSEQ:
4709             return PLUS_ASG;
4710         case SUB:
4711             return MINUS;
4712         case SUBEQ:
4713             return MINUS_ASG;
4714         case STAR:
4715             return MUL;
4716         case STAREQ:
4717             return MUL_ASG;
4718         case SLASH:
4719             return DIV;
4720         case SLASHEQ:
4721             return DIV_ASG;
4722         case PERCENT:
4723             return MOD;
4724         case PERCENTEQ:
4725             return MOD_ASG;
4726         case INSTANCEOF:
4727             return TYPETEST;
4728         default:
4729             return NO_TAG;
4730         }
4731     }
4732 
4733     /** Return operation tag of unary operator represented by token,
4734      *  No_TAG if token is not a binary operator.
4735      */
4736     static JCTree.Tag unoptag(TokenKind token) {
4737         switch (token) {
4738         case PLUS:
4739             return POS;
4740         case SUB:
4741             return NEG;
4742         case BANG:
4743             return NOT;
4744         case TILDE:
4745             return COMPL;
4746         case PLUSPLUS:
4747             return PREINC;
4748         case SUBSUB:
4749             return PREDEC;
4750         default:
4751             return NO_TAG;
4752         }
4753     }
4754 
4755     /** Return type tag of basic type represented by token,
4756      *  NONE if token is not a basic type identifier.
4757      */
4758     static TypeTag typetag(TokenKind token) {
4759         switch (token) {
4760         case BYTE:
4761             return TypeTag.BYTE;
4762         case CHAR:
4763             return TypeTag.CHAR;
4764         case SHORT:
4765             return TypeTag.SHORT;
4766         case INT:
4767             return TypeTag.INT;
4768         case LONG:
4769             return TypeTag.LONG;
4770         case FLOAT:
4771             return TypeTag.FLOAT;
4772         case DOUBLE:
4773             return TypeTag.DOUBLE;
4774         case BOOLEAN:
4775             return TypeTag.BOOLEAN;
4776         default:
4777             return TypeTag.NONE;
4778         }
4779     }
4780 
4781     void checkSourceLevel(Feature feature) {
4782         checkSourceLevel(token.pos, feature);
4783     }
4784 
4785     protected void checkSourceLevel(int pos, Feature feature) {
4786         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4787             //preview feature without --preview flag, error
4788             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4789         } else if (!feature.allowedInSource(source)) {
4790             //incompatible source level, error
4791             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4792         } else if (preview.isPreview(feature)) {
4793             //use of preview feature, warn
4794             preview.warnPreview(pos, feature);
4795         }
4796     }
4797 
4798     /*
4799      * a functional source tree and end position mappings
4800      */
4801     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4802 
4803         private final IntHashTable endPosMap;
4804 
4805         SimpleEndPosTable(JavacParser parser) {
4806             super(parser);
4807             endPosMap = new IntHashTable();
4808         }
4809 
4810         public void storeEnd(JCTree tree, int endpos) {
4811             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4812                                  endPosMap.lookup(tree));
4813         }
4814 
4815         protected &lt;T extends JCTree&gt; T to(T t) {
4816             storeEnd(t, parser.token.endPos);
4817             return t;
4818         }
4819 
4820         protected &lt;T extends JCTree&gt; T toP(T t) {
4821             storeEnd(t, parser.S.prevToken().endPos);
4822             return t;
4823         }
4824 
4825         public int getEndPos(JCTree tree) {
4826             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4827             // As long as Position.NOPOS==-1, this just returns value.
4828             return (value == -1) ? Position.NOPOS : value;
4829         }
4830 
4831         public int replaceTree(JCTree oldTree, JCTree newTree) {
4832             int pos = endPosMap.remove(oldTree);
4833             if (pos != -1) {
4834                 storeEnd(newTree, pos);
4835                 return pos;
4836             }
4837             return Position.NOPOS;
4838         }
4839     }
4840 
4841     /*
4842      * a default skeletal implementation without any mapping overhead.
4843      */
4844     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4845 
4846         EmptyEndPosTable(JavacParser parser) {
4847             super(parser);
4848         }
4849 
4850         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4851 
4852         protected &lt;T extends JCTree&gt; T to(T t) {
4853             return t;
4854         }
4855 
4856         protected &lt;T extends JCTree&gt; T toP(T t) {
4857             return t;
4858         }
4859 
4860         public int getEndPos(JCTree tree) {
4861             return Position.NOPOS;
4862         }
4863 
4864         public int replaceTree(JCTree oldTree, JCTree newTree) {
4865             return Position.NOPOS;
4866         }
4867 
4868     }
4869 
4870     protected static abstract class AbstractEndPosTable implements EndPosTable {
4871         /**
4872          * The current parser.
4873          */
4874         protected JavacParser parser;
4875 
4876         /**
4877          * Store the last error position.
4878          */
4879         public int errorEndPos = Position.NOPOS;
4880 
4881         public AbstractEndPosTable(JavacParser parser) {
4882             this.parser = parser;
4883         }
4884 
4885         /**
4886          * Store current token&#39;s ending position for a tree, the value of which
4887          * will be the greater of last error position and the ending position of
4888          * the current token.
4889          * @param t The tree.
4890          */
4891         protected abstract &lt;T extends JCTree&gt; T to(T t);
4892 
4893         /**
4894          * Store current token&#39;s ending position for a tree, the value of which
4895          * will be the greater of last error position and the ending position of
4896          * the previous token.
4897          * @param t The tree.
4898          */
4899         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4900 
4901         /**
4902          * Set the error position during the parsing phases, the value of which
4903          * will be set only if it is greater than the last stored error position.
4904          * @param errPos The error position
4905          */
4906         public void setErrorEndPos(int errPos) {
4907             if (errPos &gt; errorEndPos) {
4908                 errorEndPos = errPos;
4909             }
4910         }
4911 
4912         public void setParser(JavacParser parser) {
4913             this.parser = parser;
4914         }
4915     }
4916 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Code.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransValues.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2313                     code.emitop0(opcode &gt;&gt; preShift);
2314                     opcode = opcode &amp; 0xFF;
2315                 }
2316             }
2317             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2318                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2319                 return items.makeCondItem(opcode);
2320             } else {
2321                 code.emitop0(opcode);
2322                 return items.makeStackItem(optype.restype);
2323             }
2324         }
2325 
2326     public void visitTypeCast(JCTypeCast tree) {
2327         result = genExpr(tree.expr, tree.clazz.type).load();
2328         setTypeAnnotationPositions(tree.pos);
2329         // Additional code is only needed if we cast to a reference type
2330         // which is not statically a supertype of the expression&#39;s type.
2331         // For basic types, the coerce(...) in genExpr(...) will do
2332         // the conversion.

2333         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2334            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;

2335            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2336             checkDimension(tree.pos(), tree.clazz.type);
2337             if (types.isValue(tree.clazz.type)) {
2338                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2339             } else {
2340                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2341             }
2342 
2343         }
2344     }
2345 
2346     public void visitWildcard(JCWildcard tree) {
2347         throw new AssertionError(this.getClass().getName());
2348     }
2349 
2350     public void visitTypeTest(JCInstanceOf tree) {
2351         genExpr(tree.expr, tree.expr.type).load();
2352         setTypeAnnotationPositions(tree.pos);
2353         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2354         result = items.makeStackItem(syms.booleanType);
</pre>
</td>
<td>
<hr />
<pre>
2313                     code.emitop0(opcode &gt;&gt; preShift);
2314                     opcode = opcode &amp; 0xFF;
2315                 }
2316             }
2317             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2318                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2319                 return items.makeCondItem(opcode);
2320             } else {
2321                 code.emitop0(opcode);
2322                 return items.makeStackItem(optype.restype);
2323             }
2324         }
2325 
2326     public void visitTypeCast(JCTypeCast tree) {
2327         result = genExpr(tree.expr, tree.clazz.type).load();
2328         setTypeAnnotationPositions(tree.pos);
2329         // Additional code is only needed if we cast to a reference type
2330         // which is not statically a supertype of the expression&#39;s type.
2331         // For basic types, the coerce(...) in genExpr(...) will do
2332         // the conversion.
<span class="line-added">2333         // inline widening conversion is a nop, as the VM sees a subtyping relationship.</span>
2334         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2335            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
<span class="line-added">2336             (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &amp;&amp;</span>
2337            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
2338             checkDimension(tree.pos(), tree.clazz.type);
2339             if (types.isValue(tree.clazz.type)) {
2340                 code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);
2341             } else {
2342                 code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);
2343             }
2344 
2345         }
2346     }
2347 
2348     public void visitWildcard(JCWildcard tree) {
2349         throw new AssertionError(this.getClass().getName());
2350     }
2351 
2352     public void visitTypeTest(JCInstanceOf tree) {
2353         genExpr(tree.expr, tree.expr.type).load();
2354         setTypeAnnotationPositions(tree.pos);
2355         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
2356         result = items.makeStackItem(syms.booleanType);
</pre>
</td>
</tr>
</table>
<center><a href="Code.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransValues.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
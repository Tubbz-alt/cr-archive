<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isValue() {
 418         return (flags() &amp; VALUE) != 0;
 419     }
 420 
 421     /**
 422      * Is this a *derived* reference projection symbol ??
 423      */
 424     public boolean isReferenceProjection() {
 425         return false;
 426     }
 427 
 428     /**
<span class="line-modified"> 429      * Return the value projection IFF `this&#39; happens to be derived reference projection, null</span>
 430      * otherwise.
 431      */
 432     public Symbol valueProjection() {
 433         return null;
 434     }
 435 
 436     /**
<span class="line-modified"> 437      * Return the reference projection IFF `this&#39; happens to be value projection, null</span>
 438      * otherwise.
 439      */
 440     public Symbol referenceProjection() {
 441         return null;
 442     }
 443 
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
</pre>
<hr />
<pre>
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<span class="line-modified"> 546      * `outermost&#39; being a lexical construct, should transcend</span>
 547      *  projections
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
</pre>
<hr />
<pre>
1299         public JavaFileObject sourcefile;
1300 
1301         /** the classfile from where to load this class
1302          *  this will have extension .class or .java
1303          */
1304         public JavaFileObject classfile;
1305 
1306         /** the list of translated local classes (used for generating
1307          * InnerClasses attribute)
1308          */
1309         public List&lt;ClassSymbol&gt; trans_local;
1310 
1311         /** the annotation metadata attached to this class */
1312         private AnnotationTypeMetadata annotationTypeMetadata;
1313 
1314         /* the list of any of record components, only non empty if the class is a record
1315          * and it has at least one record component
1316          */
1317         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1318 
<span class="line-modified">1319         /* the `other&#39; projection: If `this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
1320            and vice versa.
1321          */
1322         public ClassSymbol projection;
1323 
1324 
1325         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1326             super(TYP, flags, name, type, owner);
1327             this.members_field = null;
1328             this.fullname = formFullName(name, owner);
1329             this.flatname = formFlatName(name, owner);
1330             this.sourcefile = null;
1331             this.classfile = null;
1332             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1333         }
1334 
1335         public ClassSymbol(long flags, Name name, Symbol owner) {
1336             this(
1337                 flags,
1338                 name,
1339                 new ClassType(Type.noType, null, null),
</pre>
<hr />
<pre>
1649         @Override
1650         public ClassSymbol referenceProjection() {
1651             if (!isValue() || projection != null)
1652                 return projection;
1653 
1654             ClassType ct = (ClassType) this.type;
1655             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
1656             projectedType.allparams_field = ct.allparams_field;
1657             projectedType.supertype_field = ct.supertype_field;
1658 
1659             projectedType.interfaces_field = ct.interfaces_field;
1660             projectedType.all_interfaces_field = ct.all_interfaces_field;
1661             projectedType.projection = ct;
1662             ct.projection = projectedType;
1663 
1664             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);
1665             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));
1666 
1667             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);
1668             projection.members_field = WriteableScope.create(projection);
<span class="line-modified">1669             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) { // TODO: TYP?, CLINT?</span>
1670                 Symbol clone = null;
1671                 if (s.kind == MTH) {
<span class="line-modified">1672                     MethodSymbol vMethod = (MethodSymbol)s;</span>
<span class="line-modified">1673                     MethodSymbol rMethod = vMethod.clone(projection);</span>
<span class="line-modified">1674                     vMethod.projection = rMethod;</span>
<span class="line-modified">1675                     rMethod.projection = vMethod;</span>
<span class="line-modified">1676                     clone = rMethod;</span>
1677                 } else if (s.kind == VAR) {
<span class="line-modified">1678                     VarSymbol vVar = (VarSymbol)s;</span>
<span class="line-modified">1679                     VarSymbol rVar = vVar.clone(projection);</span>
<span class="line-modified">1680                     vVar.projection = rVar;</span>
<span class="line-modified">1681                     rVar.projection = vVar;</span>
<span class="line-modified">1682                     clone = rVar;</span>
1683                 }
1684                 projection.members_field.enter(clone);
1685             }
1686             projection.completer = Completer.NULL_COMPLETER;
1687             projection.sourcefile = this.sourcefile;
1688             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);
1689             projection.projection = this;
1690             projectedType.tsym = projection;
1691             return projection;
1692         }
1693     }
1694 
1695 
1696     /** A class for variable symbols
1697      */
1698     public static class VarSymbol extends Symbol implements VariableElement {
1699 
1700         /** The variable&#39;s declaration position.
1701          */
1702         public int pos = Position.NOPOS;
1703 
1704         /** The variable&#39;s address. Used for different purposes during
1705          *  flow analysis, translation and code generation.
1706          *  Flow analysis:
1707          *    If this is a blank final or local variable, its sequence number.
1708          *  Translation:
1709          *    If this is a private field, its access number.
1710          *  Code generation:
1711          *    If this is a local variable, its logical slot number.
1712          */
1713         public int adr = -1;
1714 
<span class="line-modified">1715         /* The `other&#39; projection: If `this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
1716            its doppleganger in its referene projection class and vice versa.
1717         */
1718         public VarSymbol projection;
1719 
1720         /** Construct a variable symbol, given its flags, name, type and owner.
1721          */
1722         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1723             super(VAR, flags, name, type, owner);
1724         }
1725 
1726         @Override
1727         public int poolTag() {
1728             return ClassFile.CONSTANT_Fieldref;
1729         }
1730 
1731         public MethodHandleSymbol asMethodHandle(boolean getter) {
1732             return new MethodHandleSymbol(this, getter);
1733         }
1734 
1735         /** Clone this symbol with new owner.
</pre>
<hr />
<pre>
1947     public static class MethodSymbol extends Symbol implements ExecutableElement {
1948 
1949         /** The code of the method. */
1950         public Code code = null;
1951 
1952         /** The extra (synthetic/mandated) parameters of the method. */
1953         public List&lt;VarSymbol&gt; extraParams = List.nil();
1954 
1955         /** The captured local variables in an anonymous class */
1956         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1957 
1958         /** The parameters of the method. */
1959         public List&lt;VarSymbol&gt; params = null;
1960 
1961         /** For an annotation type element, its default value if any.
1962          *  The value is null if none appeared in the method
1963          *  declaration.
1964          */
1965         public Attribute defaultValue = null;
1966 
<span class="line-modified">1967         /* The `other&#39; projection: If `this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
1968            its doppleganger in its referene projection class and vice versa.
1969         */
1970         public MethodSymbol projection;
1971 
1972         /** Construct a method symbol, given its flags, name, type and owner.
1973          */
1974         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1975             super(MTH, flags, name, type, owner);
1976             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1977         }
1978 
1979         /** Clone this symbol with new owner.
1980          */
1981         public MethodSymbol clone(Symbol newOwner) {
1982             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1983                 @Override
1984                 public Symbol baseSymbol() {
1985                     return MethodSymbol.this;
1986                 }
1987 
</pre>
</td>
<td>
<hr />
<pre>
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
 417     public boolean isValue() {
 418         return (flags() &amp; VALUE) != 0;
 419     }
 420 
 421     /**
 422      * Is this a *derived* reference projection symbol ??
 423      */
 424     public boolean isReferenceProjection() {
 425         return false;
 426     }
 427 
 428     /**
<span class="line-modified"> 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null</span>
 430      * otherwise.
 431      */
 432     public Symbol valueProjection() {
 433         return null;
 434     }
 435 
 436     /**
<span class="line-modified"> 437      * Return the reference projection IFF &#39;this&#39; happens to be value projection, null</span>
 438      * otherwise.
 439      */
 440     public Symbol referenceProjection() {
 441         return null;
 442     }
 443 
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
</pre>
<hr />
<pre>
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<span class="line-modified"> 546      * &#39;outermost&#39; being a lexical construct, should transcend</span>
 547      *  projections
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
</pre>
<hr />
<pre>
1299         public JavaFileObject sourcefile;
1300 
1301         /** the classfile from where to load this class
1302          *  this will have extension .class or .java
1303          */
1304         public JavaFileObject classfile;
1305 
1306         /** the list of translated local classes (used for generating
1307          * InnerClasses attribute)
1308          */
1309         public List&lt;ClassSymbol&gt; trans_local;
1310 
1311         /** the annotation metadata attached to this class */
1312         private AnnotationTypeMetadata annotationTypeMetadata;
1313 
1314         /* the list of any of record components, only non empty if the class is a record
1315          * and it has at least one record component
1316          */
1317         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1318 
<span class="line-modified">1319         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
1320            and vice versa.
1321          */
1322         public ClassSymbol projection;
1323 
1324 
1325         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1326             super(TYP, flags, name, type, owner);
1327             this.members_field = null;
1328             this.fullname = formFullName(name, owner);
1329             this.flatname = formFlatName(name, owner);
1330             this.sourcefile = null;
1331             this.classfile = null;
1332             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1333         }
1334 
1335         public ClassSymbol(long flags, Name name, Symbol owner) {
1336             this(
1337                 flags,
1338                 name,
1339                 new ClassType(Type.noType, null, null),
</pre>
<hr />
<pre>
1649         @Override
1650         public ClassSymbol referenceProjection() {
1651             if (!isValue() || projection != null)
1652                 return projection;
1653 
1654             ClassType ct = (ClassType) this.type;
1655             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);
1656             projectedType.allparams_field = ct.allparams_field;
1657             projectedType.supertype_field = ct.supertype_field;
1658 
1659             projectedType.interfaces_field = ct.interfaces_field;
1660             projectedType.all_interfaces_field = ct.all_interfaces_field;
1661             projectedType.projection = ct;
1662             ct.projection = projectedType;
1663 
1664             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);
1665             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));
1666 
1667             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);
1668             projection.members_field = WriteableScope.create(projection);
<span class="line-modified">1669             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {</span>
1670                 Symbol clone = null;
1671                 if (s.kind == MTH) {
<span class="line-modified">1672                     MethodSymbol valMethod = (MethodSymbol)s;</span>
<span class="line-modified">1673                     MethodSymbol refMethod = valMethod.clone(projection);</span>
<span class="line-modified">1674                     valMethod.projection = refMethod;</span>
<span class="line-modified">1675                     refMethod.projection = valMethod;</span>
<span class="line-modified">1676                     clone = refMethod;</span>
1677                 } else if (s.kind == VAR) {
<span class="line-modified">1678                     VarSymbol valVar = (VarSymbol)s;</span>
<span class="line-modified">1679                     VarSymbol refVar = valVar.clone(projection);</span>
<span class="line-modified">1680                     valVar.projection = refVar;</span>
<span class="line-modified">1681                     refVar.projection = valVar;</span>
<span class="line-modified">1682                     clone = refVar;</span>
1683                 }
1684                 projection.members_field.enter(clone);
1685             }
1686             projection.completer = Completer.NULL_COMPLETER;
1687             projection.sourcefile = this.sourcefile;
1688             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);
1689             projection.projection = this;
1690             projectedType.tsym = projection;
1691             return projection;
1692         }
1693     }
1694 
1695 
1696     /** A class for variable symbols
1697      */
1698     public static class VarSymbol extends Symbol implements VariableElement {
1699 
1700         /** The variable&#39;s declaration position.
1701          */
1702         public int pos = Position.NOPOS;
1703 
1704         /** The variable&#39;s address. Used for different purposes during
1705          *  flow analysis, translation and code generation.
1706          *  Flow analysis:
1707          *    If this is a blank final or local variable, its sequence number.
1708          *  Translation:
1709          *    If this is a private field, its access number.
1710          *  Code generation:
1711          *    If this is a local variable, its logical slot number.
1712          */
1713         public int adr = -1;
1714 
<span class="line-modified">1715         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
1716            its doppleganger in its referene projection class and vice versa.
1717         */
1718         public VarSymbol projection;
1719 
1720         /** Construct a variable symbol, given its flags, name, type and owner.
1721          */
1722         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1723             super(VAR, flags, name, type, owner);
1724         }
1725 
1726         @Override
1727         public int poolTag() {
1728             return ClassFile.CONSTANT_Fieldref;
1729         }
1730 
1731         public MethodHandleSymbol asMethodHandle(boolean getter) {
1732             return new MethodHandleSymbol(this, getter);
1733         }
1734 
1735         /** Clone this symbol with new owner.
</pre>
<hr />
<pre>
1947     public static class MethodSymbol extends Symbol implements ExecutableElement {
1948 
1949         /** The code of the method. */
1950         public Code code = null;
1951 
1952         /** The extra (synthetic/mandated) parameters of the method. */
1953         public List&lt;VarSymbol&gt; extraParams = List.nil();
1954 
1955         /** The captured local variables in an anonymous class */
1956         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1957 
1958         /** The parameters of the method. */
1959         public List&lt;VarSymbol&gt; params = null;
1960 
1961         /** For an annotation type element, its default value if any.
1962          *  The value is null if none appeared in the method
1963          *  declaration.
1964          */
1965         public Attribute defaultValue = null;
1966 
<span class="line-modified">1967         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
1968            its doppleganger in its referene projection class and vice versa.
1969         */
1970         public MethodSymbol projection;
1971 
1972         /** Construct a method symbol, given its flags, name, type and owner.
1973          */
1974         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1975             super(MTH, flags, name, type, owner);
1976             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1977         }
1978 
1979         /** Clone this symbol with new owner.
1980          */
1981         public MethodSymbol clone(Symbol newOwner) {
1982             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1983                 @Override
1984                 public Symbol baseSymbol() {
1985                     return MethodSymbol.this;
1986                 }
1987 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdwp.agent/share/native/libjdwp/util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;transport.h&quot;
  30 #include &quot;eventHandler.h&quot;
  31 #include &quot;threadControl.h&quot;
  32 #include &quot;outStream.h&quot;
  33 #include &quot;inStream.h&quot;
  34 #include &quot;invoker.h&quot;
  35 #include &quot;signature.h&quot;
  36 
  37 
  38 /* Global data area */
  39 BackendGlobalData *gdata = NULL;
  40 
  41 /* Forward declarations */
  42 static jboolean isInterface(jclass clazz);
  43 static jboolean isArrayClass(jclass clazz);
  44 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  45 
  46 /* Save an object reference for use later (create a NewGlobalRef) */
  47 void
  48 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  49 {
  50     jobject newobj;
  51 
  52     if ( pobj == NULL ) {
  53         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  54     }
  55     if ( *pobj != NULL ) {
  56         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
  57     }
  58     if ( env == NULL ) {
  59         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef env&quot;);
  60     }
  61     if ( obj == NULL ) {
  62         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef obj&quot;);
  63     }
  64     newobj = JNI_FUNC_PTR(env,NewGlobalRef)(env, obj);
  65     if ( newobj == NULL ) {
  66         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;NewGlobalRef&quot;);
  67     }
  68     *pobj = newobj;
  69 }
  70 
  71 /* Toss a previously saved object reference */
  72 void
  73 tossGlobalRef(JNIEnv *env, jobject *pobj)
  74 {
  75     jobject obj;
  76 
  77     if ( pobj == NULL ) {
  78         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef pobj&quot;);
  79     }
  80     obj = *pobj;
  81     if ( env == NULL ) {
  82         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef env&quot;);
  83     }
  84     if ( obj == NULL ) {
  85         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;tossGlobalRef obj&quot;);
  86     }
  87     JNI_FUNC_PTR(env,DeleteGlobalRef)(env, obj);
  88     *pobj = NULL;
  89 }
  90 
  91 jclass
  92 findClass(JNIEnv *env, const char * name)
  93 {
  94     jclass x;
  95 
  96     if ( env == NULL ) {
  97         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass env&quot;);
  98     }
  99     if ( name == NULL || name[0] == 0 ) {
 100         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass name&quot;);
 101     }
 102     x = JNI_FUNC_PTR(env,FindClass)(env, name);
 103     if (x == NULL) {
 104         ERROR_MESSAGE((&quot;JDWP Can&#39;t find class %s&quot;, name));
 105         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 106     }
 107     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 108         ERROR_MESSAGE((&quot;JDWP Exception occurred finding class %s&quot;, name));
 109         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 110     }
 111     return x;
 112 }
 113 
 114 jmethodID
 115 getMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 116 {
 117     jmethodID method;
 118 
 119     if ( env == NULL ) {
 120         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod env&quot;);
 121     }
 122     if ( clazz == NULL ) {
 123         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod clazz&quot;);
 124     }
 125     if ( name == NULL || name[0] == 0 ) {
 126         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod name&quot;);
 127     }
 128     if ( signature == NULL || signature[0] == 0 ) {
 129         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod signature&quot;);
 130     }
 131     method = JNI_FUNC_PTR(env,GetMethodID)(env, clazz, name, signature);
 132     if (method == NULL) {
 133         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 134                                 name, signature));
 135         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 136     }
 137     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 138         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 139                                 name, signature));
 140         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 141     }
 142     return method;
 143 }
 144 
 145 static jmethodID
 146 getStaticMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 147 {
 148     jmethodID method;
 149 
 150     if ( env == NULL ) {
 151         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod env&quot;);
 152     }
 153     if ( clazz == NULL ) {
 154         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod clazz&quot;);
 155     }
 156     if ( name == NULL || name[0] == 0 ) {
 157         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 158     }
 159     if ( signature == NULL || signature[0] == 0 ) {
 160         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 161     }
 162     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 163     if (method == NULL) {
 164         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 165                                 name, signature));
 166         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 167     }
 168     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 169         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 170                                 name, signature));
 171         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 172     }
 173     return method;
 174 }
 175 
 176 
 177 
 178 void
 179 util_initialize(JNIEnv *env)
 180 {
 181     WITH_LOCAL_REFS(env, 6) {
 182 
 183         jvmtiError error;
 184         jclass localClassClass;
 185         jclass localThreadClass;
 186         jclass localThreadGroupClass;
 187         jclass localClassLoaderClass;
 188         jclass localStringClass;
 189         jclass localSystemClass;
 190         jclass localPropertiesClass;
 191         jclass localVMSupportClass;
 192         jobject localAgentProperties;
 193         jmethodID getAgentProperties;
 194         jint groupCount;
 195         jthreadGroup *groups;
 196         jthreadGroup localSystemThreadGroup;
 197 
 198         /* Find some standard classes */
 199 
 200         localClassClass         = findClass(env,&quot;java/lang/Class&quot;);
 201         localThreadClass        = findClass(env,&quot;java/lang/Thread&quot;);
 202         localThreadGroupClass   = findClass(env,&quot;java/lang/ThreadGroup&quot;);
 203         localClassLoaderClass   = findClass(env,&quot;java/lang/ClassLoader&quot;);
 204         localStringClass        = findClass(env,&quot;java/lang/String&quot;);
 205         localSystemClass        = findClass(env,&quot;java/lang/System&quot;);
 206         localPropertiesClass    = findClass(env,&quot;java/util/Properties&quot;);
 207 
 208         /* Save references */
 209 
 210         saveGlobalRef(env, localClassClass,       &amp;(gdata-&gt;classClass));
 211         saveGlobalRef(env, localThreadClass,      &amp;(gdata-&gt;threadClass));
 212         saveGlobalRef(env, localThreadGroupClass, &amp;(gdata-&gt;threadGroupClass));
 213         saveGlobalRef(env, localClassLoaderClass, &amp;(gdata-&gt;classLoaderClass));
 214         saveGlobalRef(env, localStringClass,      &amp;(gdata-&gt;stringClass));
 215         saveGlobalRef(env, localSystemClass,      &amp;(gdata-&gt;systemClass));
 216 
 217         /* Find some standard methods */
 218 
 219         gdata-&gt;threadConstructor =
 220                 getMethod(env, gdata-&gt;threadClass,
 221                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/ThreadGroup;Ljava/lang/String;)V&quot;);
 222         gdata-&gt;threadSetDaemon =
 223                 getMethod(env, gdata-&gt;threadClass, &quot;setDaemon&quot;, &quot;(Z)V&quot;);
 224         gdata-&gt;threadResume =
 225                 getMethod(env, gdata-&gt;threadClass, &quot;resume&quot;, &quot;()V&quot;);
 226         gdata-&gt;systemGetProperty =
 227                 getStaticMethod(env, gdata-&gt;systemClass,
 228                     &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
 229         gdata-&gt;setProperty =
 230                 getMethod(env, localPropertiesClass,
 231                     &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 232 
 233         /* Find the system thread group */
 234 
 235         groups = NULL;
 236         groupCount = 0;
 237         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetTopThreadGroups)
 238                     (gdata-&gt;jvmti, &amp;groupCount, &amp;groups);
 239         if (error != JVMTI_ERROR_NONE ) {
 240             EXIT_ERROR(error, &quot;Can&#39;t get system thread group&quot;);
 241         }
 242         if ( groupCount == 0 ) {
 243             EXIT_ERROR(AGENT_ERROR_NULL_POINTER, &quot;Can&#39;t get system thread group&quot;);
 244         }
 245         localSystemThreadGroup = groups[0];
 246         saveGlobalRef(env, localSystemThreadGroup, &amp;(gdata-&gt;systemThreadGroup));
 247 
 248         /* Get some basic Java property values we will need at some point */
 249         gdata-&gt;property_java_version
 250                         = getPropertyUTF8(env, &quot;java.version&quot;);
 251         gdata-&gt;property_java_vm_name
 252                         = getPropertyUTF8(env, &quot;java.vm.name&quot;);
 253         gdata-&gt;property_java_vm_info
 254                         = getPropertyUTF8(env, &quot;java.vm.info&quot;);
 255         gdata-&gt;property_java_class_path
 256                         = getPropertyUTF8(env, &quot;java.class.path&quot;);
 257         gdata-&gt;property_sun_boot_library_path
 258                         = getPropertyUTF8(env, &quot;sun.boot.library.path&quot;);
 259         gdata-&gt;property_path_separator
 260                         = getPropertyUTF8(env, &quot;path.separator&quot;);
 261         gdata-&gt;property_user_dir
 262                         = getPropertyUTF8(env, &quot;user.dir&quot;);
 263 
 264         /* Get agent properties: invoke VMSupport.getAgentProperties */
 265         localVMSupportClass = JNI_FUNC_PTR(env,FindClass)
 266                                           (env, &quot;jdk/internal/vm/VMSupport&quot;);
 267         if (localVMSupportClass == NULL) {
 268             gdata-&gt;agent_properties = NULL;
 269             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 270                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 271             }
 272         } else {
 273             getAgentProperties  =
 274                 getStaticMethod(env, localVMSupportClass,
 275                                 &quot;getAgentProperties&quot;, &quot;()Ljava/util/Properties;&quot;);
 276             localAgentProperties =
 277                 JNI_FUNC_PTR(env,CallStaticObjectMethod)
 278                             (env, localVMSupportClass, getAgentProperties);
 279             saveGlobalRef(env, localAgentProperties, &amp;(gdata-&gt;agent_properties));
 280             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 281                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 282                 EXIT_ERROR(AGENT_ERROR_INTERNAL,
 283                     &quot;Exception occurred calling VMSupport.getAgentProperties&quot;);
 284             }
 285         }
 286 
 287     } END_WITH_LOCAL_REFS(env);
 288 
 289 }
 290 
 291 void
 292 util_reset(void)
 293 {
 294 }
 295 
 296 jboolean
 297 isObjectTag(jbyte tag) {
 298     return (tag == JDWP_TAG(OBJECT)) ||
 299            (tag == JDWP_TAG(INLINE_OBJECT)) ||
 300            (tag == JDWP_TAG(STRING)) ||
 301            (tag == JDWP_TAG(THREAD)) ||
 302            (tag == JDWP_TAG(THREAD_GROUP)) ||
 303            (tag == JDWP_TAG(CLASS_LOADER)) ||
 304            (tag == JDWP_TAG(CLASS_OBJECT)) ||
 305            (tag == JDWP_TAG(ARRAY));
 306 }
 307 
 308 jbyte
 309 specificTypeKey(JNIEnv *env, jobject object)
 310 {
 311     if (object == NULL) {
 312         return JDWP_TAG(OBJECT);
 313     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass)) {
 314         return JDWP_TAG(STRING);
 315     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass)) {
 316         return JDWP_TAG(THREAD);
 317     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass)) {
 318         return JDWP_TAG(THREAD_GROUP);
 319     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass)) {
 320         return JDWP_TAG(CLASS_LOADER);
 321     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass)) {
 322         return JDWP_TAG(CLASS_OBJECT);
 323     } else {
 324         jboolean classIsArray;
 325 
 326         WITH_LOCAL_REFS(env, 1) {
 327             jclass clazz;
 328             clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 329             classIsArray = isArrayClass(clazz);
 330         } END_WITH_LOCAL_REFS(env);
 331 
 332         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 333     }
 334 }
 335 
 336 static void
 337 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 338                 jfieldID field)
 339 {
 340     jclass clazz;
 341     char *signature = NULL;
 342     jvmtiError error;
 343     jbyte typeKey;
 344 
 345     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 346     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 347     if (error != JVMTI_ERROR_NONE) {
 348         outStream_setError(out, map2jdwpError(error));
 349         return;
 350     }
 351     typeKey = jdwpTag(signature);
 352     jvmtiDeallocate(signature);
 353 
 354     if (isReferenceTag(typeKey)) {
 355 
 356         jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);
 357         (void)outStream_writeByte(out, specificTypeKey(env, value));
 358         (void)outStream_writeObjectRef(env, out, value);
 359         return;
 360 
 361     }
 362 
 363     /*
 364      * For primitive types, the type key is bounced back as is.
 365      */
 366     (void)outStream_writeByte(out, typeKey);
 367 
 368     switch (typeKey) {
 369         case JDWP_TAG(BYTE):
 370             (void)outStream_writeByte(out,
 371                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 372             break;
 373 
 374         case JDWP_TAG(CHAR):
 375             (void)outStream_writeChar(out,
 376                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 377             break;
 378 
 379         case JDWP_TAG(FLOAT):
 380             (void)outStream_writeFloat(out,
 381                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 382             break;
 383 
 384         case JDWP_TAG(DOUBLE):
 385             (void)outStream_writeDouble(out,
 386                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 387             break;
 388 
 389         case JDWP_TAG(INT):
 390             (void)outStream_writeInt(out,
 391                       JNI_FUNC_PTR(env,GetIntField)(env, object, field));
 392             break;
 393 
 394         case JDWP_TAG(LONG):
 395             (void)outStream_writeLong(out,
 396                       JNI_FUNC_PTR(env,GetLongField)(env, object, field));
 397             break;
 398 
 399         case JDWP_TAG(SHORT):
 400             (void)outStream_writeShort(out,
 401                       JNI_FUNC_PTR(env,GetShortField)(env, object, field));
 402             break;
 403 
 404         case JDWP_TAG(BOOLEAN):
 405             (void)outStream_writeBoolean(out,
 406                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 407             break;
 408     }
 409 }
 410 
 411 static void
 412 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 413                       jfieldID field)
 414 {
 415     jvmtiError error;
 416     char *signature = NULL;
 417     jbyte typeKey;
 418 
 419     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 420     if (error != JVMTI_ERROR_NONE) {
 421         outStream_setError(out, map2jdwpError(error));
 422         return;
 423     }
 424     typeKey = jdwpTag(signature);
 425     jvmtiDeallocate(signature);
 426 
 427 
 428     if (isReferenceTag(typeKey)) {
 429 
 430         jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);
 431         (void)outStream_writeByte(out, specificTypeKey(env, value));
 432         (void)outStream_writeObjectRef(env, out, value);
 433 
 434         return;
 435     }
 436 
 437     /*
 438      * For primitive types, the type key is bounced back as is.
 439      */
 440     (void)outStream_writeByte(out, typeKey);
 441     switch (typeKey) {
 442         case JDWP_TAG(BYTE):
 443             (void)outStream_writeByte(out,
 444                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 445             break;
 446 
 447         case JDWP_TAG(CHAR):
 448             (void)outStream_writeChar(out,
 449                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 450             break;
 451 
 452         case JDWP_TAG(FLOAT):
 453             (void)outStream_writeFloat(out,
 454                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 455             break;
 456 
 457         case JDWP_TAG(DOUBLE):
 458             (void)outStream_writeDouble(out,
 459                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 460             break;
 461 
 462         case JDWP_TAG(INT):
 463             (void)outStream_writeInt(out,
 464                       JNI_FUNC_PTR(env,GetStaticIntField)(env, clazz, field));
 465             break;
 466 
 467         case JDWP_TAG(LONG):
 468             (void)outStream_writeLong(out,
 469                       JNI_FUNC_PTR(env,GetStaticLongField)(env, clazz, field));
 470             break;
 471 
 472         case JDWP_TAG(SHORT):
 473             (void)outStream_writeShort(out,
 474                       JNI_FUNC_PTR(env,GetStaticShortField)(env, clazz, field));
 475             break;
 476 
 477         case JDWP_TAG(BOOLEAN):
 478             (void)outStream_writeBoolean(out,
 479                       JNI_FUNC_PTR(env,GetStaticBooleanField)(env, clazz, field));
 480             break;
 481     }
 482 }
 483 
 484 void
 485 sharedGetFieldValues(PacketInputStream *in, PacketOutputStream *out,
 486                      jboolean isStatic)
 487 {
 488     JNIEnv *env = getEnv();
 489     jint length;
 490     jobject object;
 491     jclass clazz;
 492 
 493     object = NULL;
 494     clazz  = NULL;
 495 
 496     if (isStatic) {
 497         clazz = inStream_readClassRef(env, in);
 498     } else {
 499         object = inStream_readObjectRef(env, in);
 500     }
 501 
 502     length = inStream_readInt(in);
 503     if (inStream_error(in)) {
 504         return;
 505     }
 506 
 507     WITH_LOCAL_REFS(env, length + 1) { /* +1 for class with instance fields */
 508 
 509         int i;
 510 
 511         (void)outStream_writeInt(out, length);
 512         for (i = 0; (i &lt; length) &amp;&amp; !outStream_error(out); i++) {
 513             jfieldID field = inStream_readFieldID(in);
 514 
 515             if (isStatic) {
 516                 writeStaticFieldValue(env, out, clazz, field);
 517             } else {
 518                 writeFieldValue(env, out, object, field);
 519             }
 520         }
 521 
 522     } END_WITH_LOCAL_REFS(env);
 523 }
 524 
 525 jboolean
 526 sharedInvoke(PacketInputStream *in, PacketOutputStream *out)
 527 {
 528     jvalue *arguments = NULL;
 529     jint options;
 530     jvmtiError error;
 531     jbyte invokeType;
 532     jclass clazz;
 533     jmethodID method;
 534     jint argumentCount;
 535     jobject instance;
 536     jthread thread;
 537     JNIEnv *env;
 538 
 539     /*
 540      * Instance methods start with the instance, thread and class,
 541      * and statics and constructors start with the class and then the
 542      * thread.
 543      */
 544     env = getEnv();
 545     if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 546         instance = inStream_readObjectRef(env, in);
 547         thread = inStream_readThreadRef(env, in);
 548         clazz = inStream_readClassRef(env, in);
 549     } else { /* static method or constructor */
 550         instance = NULL;
 551         clazz = inStream_readClassRef(env, in);
 552         thread = inStream_readThreadRef(env, in);
 553     }
 554 
 555     /*
 556      * ... and the rest of the packet is identical for all commands
 557      */
 558     method = inStream_readMethodID(in);
 559     argumentCount = inStream_readInt(in);
 560     if (inStream_error(in)) {
 561         return JNI_TRUE;
 562     }
 563 
 564     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 565     if ( argumentCount &gt; 0 ) {
 566         int i;
 567         /*LINTED*/
 568         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 569         if (arguments == NULL) {
 570             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 571             return JNI_TRUE;
 572         }
 573         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
 574             arguments[i] = inStream_readValue(in);
 575         }
 576         if (inStream_error(in)) {
 577             return JNI_TRUE;
 578         }
 579     }
 580 
 581     options = inStream_readInt(in);
 582     if (inStream_error(in)) {
 583         if ( arguments != NULL ) {
 584             jvmtiDeallocate(arguments);
 585         }
 586         return JNI_TRUE;
 587     }
 588 
 589     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 590         invokeType = INVOKE_CONSTRUCTOR;
 591     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 592         invokeType = INVOKE_STATIC;
 593     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 594         invokeType = INVOKE_STATIC;
 595     } else if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 596         invokeType = INVOKE_INSTANCE;
 597     } else {
 598         outStream_setError(out, JDWP_ERROR(INTERNAL));
 599         if ( arguments != NULL ) {
 600             jvmtiDeallocate(arguments);
 601         }
 602         return JNI_TRUE;
 603     }
 604 
 605     /*
 606      * Request the invoke. If there are no errors in the request,
 607      * the interrupting thread will actually do the invoke and a
 608      * reply will be generated subsequently, so we don&#39;t reply here.
 609      */
 610     error = invoker_requestInvoke(invokeType, (jbyte)options, inStream_id(in),
 611                                   thread, clazz, method,
 612                                   instance, arguments, argumentCount);
 613     if (error != JVMTI_ERROR_NONE) {
 614         outStream_setError(out, map2jdwpError(error));
 615         if ( arguments != NULL ) {
 616             jvmtiDeallocate(arguments);
 617         }
 618         return JNI_TRUE;
 619     }
 620 
 621     return JNI_FALSE;   /* Don&#39;t reply */
 622 }
 623 
 624 jint
 625 uniqueID(void)
 626 {
 627     static jint currentID = 0;
 628     return currentID++;
 629 }
 630 
 631 int
 632 filterDebugThreads(jthread *threads, int count)
 633 {
 634     int i;
 635     int current;
 636 
 637     /* Squish out all of the debugger-spawned threads */
 638     for (i = 0, current = 0; i &lt; count; i++) {
 639         jthread thread = threads[i];
 640         if (!threadControl_isDebugThread(thread)) {
 641             if (i &gt; current) {
 642                 threads[current] = thread;
 643             }
 644             current++;
 645         }
 646     }
 647     return current;
 648 }
 649 
 650 jbyte
 651 referenceTypeTag(jclass clazz)
 652 {
 653     jbyte tag;
 654 
 655     if (isInterface(clazz)) {
 656         tag = JDWP_TYPE_TAG(INTERFACE);
 657     } else if (isArrayClass(clazz)) {
 658         tag = JDWP_TYPE_TAG(ARRAY);
 659     } else {
 660         tag = JDWP_TYPE_TAG(CLASS);
 661     }
 662 
 663     return tag;
 664 }
 665 
 666 /**
 667  * Get field modifiers
 668  */
 669 jvmtiError
 670 fieldModifiers(jclass clazz, jfieldID field, jint *pmodifiers)
 671 {
 672     jvmtiError error;
 673 
 674     *pmodifiers = 0;
 675     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldModifiers)
 676             (gdata-&gt;jvmti, clazz, field, pmodifiers);
 677     return error;
 678 }
 679 
 680 /**
 681  * Get method modifiers
 682  */
 683 jvmtiError
 684 methodModifiers(jmethodID method, jint *pmodifiers)
 685 {
 686     jvmtiError error;
 687 
 688     *pmodifiers = 0;
 689     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodModifiers)
 690             (gdata-&gt;jvmti, method, pmodifiers);
 691     return error;
 692 }
 693 
 694 /* Returns a local ref to the declaring class for a method, or NULL. */
 695 jvmtiError
 696 methodClass(jmethodID method, jclass *pclazz)
 697 {
 698     jvmtiError error;
 699 
 700     *pclazz = NULL;
 701     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodDeclaringClass)
 702                                 (gdata-&gt;jvmti, method, pclazz);
 703     return error;
 704 }
 705 
 706 /* Returns a local ref to the declaring class for a method, or NULL. */
 707 jvmtiError
 708 methodLocation(jmethodID method, jlocation *ploc1, jlocation *ploc2)
 709 {
 710     jvmtiError error;
 711 
 712     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodLocation)
 713                                 (gdata-&gt;jvmti, method, ploc1, ploc2);
 714     return error;
 715 }
 716 
 717 /**
 718  * Get method signature
 719  */
 720 jvmtiError
 721 methodSignature(jmethodID method,
 722         char **pname, char **psignature, char **pgeneric_signature)
 723 {
 724     jvmtiError error;
 725     char *name = NULL;
 726     char *signature = NULL;
 727     char *generic_signature = NULL;
 728 
 729     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodName)
 730             (gdata-&gt;jvmti, method, &amp;name, &amp;signature, &amp;generic_signature);
 731 
 732     if ( pname != NULL ) {
 733         *pname = name;
 734     } else if ( name != NULL )  {
 735         jvmtiDeallocate(name);
 736     }
 737     if ( psignature != NULL ) {
 738         *psignature = signature;
 739     } else if ( signature != NULL ) {
 740         jvmtiDeallocate(signature);
 741     }
 742     if ( pgeneric_signature != NULL ) {
 743         *pgeneric_signature = generic_signature;
 744     } else if ( generic_signature != NULL )  {
 745         jvmtiDeallocate(generic_signature);
 746     }
 747     return error;
 748 }
 749 
 750 /*
 751  * Get the return type key of the method
 752  *     V or B C D F I J S Z L  [
 753  */
 754 jvmtiError
 755 methodReturnType(jmethodID method, char *typeKey)
 756 {
 757     char       *signature;
 758     jvmtiError  error;
 759 
 760     signature = NULL;
 761     error     = methodSignature(method, NULL, &amp;signature, NULL);
 762     if (error == JVMTI_ERROR_NONE) {
 763         if (signature == NULL ) {
 764             error = AGENT_ERROR_INVALID_TAG;
 765         } else {
 766             char * xx;
 767 
 768             xx = strchr(signature, &#39;)&#39;);
 769             if (xx == NULL || *(xx + 1) == 0) {
 770                 error = AGENT_ERROR_INVALID_TAG;
 771             } else {
 772                *typeKey = *(xx + 1);
 773             }
 774             jvmtiDeallocate(signature);
 775         }
 776     }
 777     return error;
 778 }
 779 
 780 
 781 /**
 782  * Return class loader for a class (must be inside a WITH_LOCAL_REFS)
 783  */
 784 jvmtiError
 785 classLoader(jclass clazz, jobject *pclazz)
 786 {
 787     jvmtiError error;
 788 
 789     *pclazz = NULL;
 790     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoader)
 791             (gdata-&gt;jvmti, clazz, pclazz);
 792     return error;
 793 }
 794 
 795 /**
 796  * Get field signature
 797  */
 798 jvmtiError
 799 fieldSignature(jclass clazz, jfieldID field,
 800         char **pname, char **psignature, char **pgeneric_signature)
 801 {
 802     jvmtiError error;
 803     char *name = NULL;
 804     char *signature = NULL;
 805     char *generic_signature = NULL;
 806 
 807     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldName)
 808             (gdata-&gt;jvmti, clazz, field, &amp;name, &amp;signature, &amp;generic_signature);
 809 
 810     if ( pname != NULL ) {
 811         *pname = name;
 812     } else if ( name != NULL )  {
 813         jvmtiDeallocate(name);
 814     }
 815     if ( psignature != NULL ) {
 816         *psignature = signature;
 817     } else if ( signature != NULL )  {
 818         jvmtiDeallocate(signature);
 819     }
 820     if ( pgeneric_signature != NULL ) {
 821         *pgeneric_signature = generic_signature;
 822     } else if ( generic_signature != NULL )  {
 823         jvmtiDeallocate(generic_signature);
 824     }
 825     return error;
 826 }
 827 
 828 JNIEnv *
 829 getEnv(void)
 830 {
 831     JNIEnv *env = NULL;
 832     jint rc;
 833 
 834     rc = FUNC_PTR(gdata-&gt;jvm,GetEnv)
 835                 (gdata-&gt;jvm, (void **)&amp;env, JNI_VERSION_1_2);
 836     if (rc != JNI_OK) {
 837         ERROR_MESSAGE((&quot;JDWP Unable to get JNI 1.2 environment, jvm-&gt;GetEnv() return code = %d&quot;,
 838                 rc));
 839         EXIT_ERROR(AGENT_ERROR_NO_JNI_ENV,NULL);
 840     }
 841     return env;
 842 }
 843 
 844 jvmtiError
 845 spawnNewThread(jvmtiStartFunction func, void *arg, char *name)
 846 {
 847     JNIEnv *env = getEnv();
 848     jvmtiError error;
 849 
 850     LOG_MISC((&quot;Spawning new thread: %s&quot;, name));
 851 
 852     WITH_LOCAL_REFS(env, 3) {
 853 
 854         jthread thread;
 855         jstring nameString;
 856 
 857         nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, name);
 858         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 859             JNI_FUNC_PTR(env,ExceptionClear)(env);
 860             error = AGENT_ERROR_OUT_OF_MEMORY;
 861             goto err;
 862         }
 863 
 864         thread = JNI_FUNC_PTR(env,NewObject)
 865                         (env, gdata-&gt;threadClass, gdata-&gt;threadConstructor,
 866                                    gdata-&gt;systemThreadGroup, nameString);
 867         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 868             JNI_FUNC_PTR(env,ExceptionClear)(env);
 869             error = AGENT_ERROR_OUT_OF_MEMORY;
 870             goto err;
 871         }
 872 
 873         /*
 874          * Make the debugger thread a daemon
 875          */
 876         JNI_FUNC_PTR(env,CallVoidMethod)
 877                         (env, thread, gdata-&gt;threadSetDaemon, JNI_TRUE);
 878         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 879             JNI_FUNC_PTR(env,ExceptionClear)(env);
 880             error = AGENT_ERROR_JNI_EXCEPTION;
 881             goto err;
 882         }
 883 
 884         error = threadControl_addDebugThread(thread);
 885         if (error == JVMTI_ERROR_NONE) {
 886             /*
 887              * Debugger threads need cycles in all sorts of strange
 888              * situations (e.g. infinite cpu-bound loops), so give the
 889              * thread a high priority. Note that if the VM has an application
 890              * thread running at the max priority, there is still a chance
 891              * that debugger threads will be starved. (There needs to be
 892              * a way to give debugger threads a priority higher than any
 893              * application thread).
 894              */
 895             error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,RunAgentThread)
 896                         (gdata-&gt;jvmti, thread, func, arg,
 897                                         JVMTI_THREAD_MAX_PRIORITY);
 898         }
 899 
 900         err: ;
 901 
 902     } END_WITH_LOCAL_REFS(env);
 903 
 904     return error;
 905 }
 906 
 907 jvmtiError
 908 jvmtiGetCapabilities(jvmtiCapabilities *caps)
 909 {
 910     if ( gdata-&gt;vmDead ) {
 911         return AGENT_ERROR_VM_DEAD;
 912     }
 913     if (!gdata-&gt;haveCachedJvmtiCapabilities) {
 914         jvmtiError error;
 915 
 916         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetCapabilities)
 917                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiCapabilities));
 918         if (error != JVMTI_ERROR_NONE) {
 919             return error;
 920         }
 921         gdata-&gt;haveCachedJvmtiCapabilities = JNI_TRUE;
 922     }
 923 
 924     *caps = gdata-&gt;cachedJvmtiCapabilities;
 925 
 926     return JVMTI_ERROR_NONE;
 927 }
 928 
 929 static jint
 930 jvmtiVersion(void)
 931 {
 932     if (gdata-&gt;cachedJvmtiVersion == 0) {
 933         jvmtiError error;
 934         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetVersionNumber)
 935                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiVersion));
 936         if (error != JVMTI_ERROR_NONE) {
 937             EXIT_ERROR(error, &quot;on getting the JVMTI version number&quot;);
 938         }
 939     }
 940     return gdata-&gt;cachedJvmtiVersion;
 941 }
 942 
 943 jint
 944 jvmtiMajorVersion(void)
 945 {
 946     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MAJOR)
 947                     &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 948 }
 949 
 950 jint
 951 jvmtiMinorVersion(void)
 952 {
 953     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MINOR)
 954                     &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 955 }
 956 
 957 jint
 958 jvmtiMicroVersion(void)
 959 {
 960     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MICRO)
 961                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 962 }
 963 
 964 jboolean
 965 canSuspendResumeThreadLists(void)
 966 {
 967     jvmtiError error;
 968     jvmtiCapabilities cap;
 969 
 970     error = jvmtiGetCapabilities(&amp;cap);
 971     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 972 }
 973 
 974 jvmtiError
 975 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 976 {
 977     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 978                 (gdata-&gt;jvmti, clazz, extensionPtr);
 979 }
 980 
 981 
 982 static void
 983 handleInterrupt(void)
 984 {
 985     /*
 986      * An interrupt is handled:
 987      *
 988      * 1) for running application threads by deferring the interrupt
 989      * until the current event handler has concluded.
 990      *
 991      * 2) for debugger threads by ignoring the interrupt; this is the
 992      * most robust solution since debugger threads don&#39;t use interrupts
 993      * to signal any condition.
 994      *
 995      * 3) for application threads that have not started or already
 996      * ended by ignoring the interrupt. In the former case, the application
 997      * is relying on timing to determine whether or not the thread sees
 998      * the interrupt; in the latter case, the interrupt is meaningless.
 999      */
1000     jthread thread = threadControl_currentThread();
1001     if ((thread != NULL) &amp;&amp; (!threadControl_isDebugThread(thread))) {
1002         threadControl_setPendingInterrupt(thread);
1003     }
1004 }
1005 
1006 static jvmtiError
1007 ignore_vm_death(jvmtiError error)
1008 {
1009     if (error == JVMTI_ERROR_WRONG_PHASE) {
1010         LOG_MISC((&quot;VM_DEAD, in debugMonitor*()?&quot;));
1011         return JVMTI_ERROR_NONE; /* JVMTI does this, not JVMDI? */
1012     }
1013     return error;
1014 }
1015 
1016 void
1017 debugMonitorEnter(jrawMonitorID monitor)
1018 {
1019     jvmtiError error;
1020     while (JNI_TRUE) {
1021         error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorEnter)
1022                         (gdata-&gt;jvmti, monitor);
1023         error = ignore_vm_death(error);
1024         if (error == JVMTI_ERROR_INTERRUPT) {
1025             handleInterrupt();
1026         } else {
1027             break;
1028         }
1029     }
1030     if (error != JVMTI_ERROR_NONE) {
1031         EXIT_ERROR(error, &quot;on raw monitor enter&quot;);
1032     }
1033 }
1034 
1035 void
1036 debugMonitorExit(jrawMonitorID monitor)
1037 {
1038     jvmtiError error;
1039 
1040     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorExit)
1041                 (gdata-&gt;jvmti, monitor);
1042     error = ignore_vm_death(error);
1043     if (error != JVMTI_ERROR_NONE) {
1044         EXIT_ERROR(error, &quot;on raw monitor exit&quot;);
1045     }
1046 }
1047 
1048 void
1049 debugMonitorWait(jrawMonitorID monitor)
1050 {
1051     jvmtiError error;
1052     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1053         (gdata-&gt;jvmti, monitor, ((jlong)(-1)));
1054 
1055     /*
1056      * According to the JLS (17.8), here we have
1057      * either :
1058      * a- been notified
1059      * b- gotten a suprious wakeup
1060      * c- been interrupted
1061      * If both a and c have happened, the VM must choose
1062      * which way to return - a or c.  If it chooses c
1063      * then the notify is gone - either to some other
1064      * thread that is also waiting, or it is dropped
1065      * on the floor.
1066      *
1067      * a is what we expect.  b won&#39;t hurt us any -
1068      * callers should be programmed to handle
1069      * spurious wakeups.  In case of c,
1070      * then the interrupt has been cleared, but
1071      * we don&#39;t want to consume it.  It came from
1072      * user code and is intended for user code, not us.
1073      * So, we will remember that the interrupt has
1074      * occurred and re-activate it when this thread
1075      * goes back into user code.
1076      * That being said, what do we do here?  Since
1077      * we could have been notified too, here we will
1078      * just pretend that we have been.  It won&#39;t hurt
1079      * anything to return in the same way as if
1080      * we were notified since callers have to be able to
1081      * handle spurious wakeups anyway.
1082      */
1083     if (error == JVMTI_ERROR_INTERRUPT) {
1084         handleInterrupt();
1085         error = JVMTI_ERROR_NONE;
1086     }
1087     error = ignore_vm_death(error);
1088     if (error != JVMTI_ERROR_NONE) {
1089         EXIT_ERROR(error, &quot;on raw monitor wait&quot;);
1090     }
1091 }
1092 
1093 void
1094 debugMonitorTimedWait(jrawMonitorID monitor, jlong millis)
1095 {
1096     jvmtiError error;
1097     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1098         (gdata-&gt;jvmti, monitor, millis);
1099     if (error == JVMTI_ERROR_INTERRUPT) {
1100         /* See comment above */
1101         handleInterrupt();
1102         error = JVMTI_ERROR_NONE;
1103     }
1104     error = ignore_vm_death(error);
1105     if (error != JVMTI_ERROR_NONE) {
1106         EXIT_ERROR(error, &quot;on raw monitor timed wait&quot;);
1107     }
1108 }
1109 
1110 void
1111 debugMonitorNotify(jrawMonitorID monitor)
1112 {
1113     jvmtiError error;
1114 
1115     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotify)
1116                 (gdata-&gt;jvmti, monitor);
1117     error = ignore_vm_death(error);
1118     if (error != JVMTI_ERROR_NONE) {
1119         EXIT_ERROR(error, &quot;on raw monitor notify&quot;);
1120     }
1121 }
1122 
1123 void
1124 debugMonitorNotifyAll(jrawMonitorID monitor)
1125 {
1126     jvmtiError error;
1127 
1128     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotifyAll)
1129                 (gdata-&gt;jvmti, monitor);
1130     error = ignore_vm_death(error);
1131     if (error != JVMTI_ERROR_NONE) {
1132         EXIT_ERROR(error, &quot;on raw monitor notify all&quot;);
1133     }
1134 }
1135 
1136 jrawMonitorID
1137 debugMonitorCreate(char *name)
1138 {
1139     jrawMonitorID monitor;
1140     jvmtiError error;
1141 
1142     error = FUNC_PTR(gdata-&gt;jvmti,CreateRawMonitor)
1143                 (gdata-&gt;jvmti, name, &amp;monitor);
1144     if (error != JVMTI_ERROR_NONE) {
1145         EXIT_ERROR(error, &quot;on creation of a raw monitor&quot;);
1146     }
1147     return monitor;
1148 }
1149 
1150 void
1151 debugMonitorDestroy(jrawMonitorID monitor)
1152 {
1153     jvmtiError error;
1154 
1155     error = FUNC_PTR(gdata-&gt;jvmti,DestroyRawMonitor)
1156                 (gdata-&gt;jvmti, monitor);
1157     error = ignore_vm_death(error);
1158     if (error != JVMTI_ERROR_NONE) {
1159         EXIT_ERROR(error, &quot;on destruction of raw monitor&quot;);
1160     }
1161 }
1162 
1163 /**
1164  * Return array of all threads (must be inside a WITH_LOCAL_REFS)
1165  */
1166 jthread *
1167 allThreads(jint *count)
1168 {
1169     jthread *threads;
1170     jvmtiError error;
1171 
1172     *count = 0;
1173     threads = NULL;
1174     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetAllThreads)
1175                 (gdata-&gt;jvmti, count, &amp;threads);
1176     if (error == AGENT_ERROR_OUT_OF_MEMORY) {
1177         return NULL; /* Let caller deal with no memory? */
1178     }
1179     if (error != JVMTI_ERROR_NONE) {
1180         EXIT_ERROR(error, &quot;getting all threads&quot;);
1181     }
1182     return threads;
1183 }
1184 
1185 /**
1186  * Fill the passed in structure with thread group info.
1187  * name field is JVMTI allocated.  parent is global ref.
1188  */
1189 void
1190 threadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo *info)
1191 {
1192     jvmtiError error;
1193 
1194     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetThreadGroupInfo)
1195                 (gdata-&gt;jvmti, group, info);
1196     if (error != JVMTI_ERROR_NONE) {
1197         EXIT_ERROR(error, &quot;on getting thread group info&quot;);
1198     }
1199 }
1200 
1201 /**
1202  * Return class signature string
1203  */
1204 jvmtiError
1205 classSignature(jclass clazz, char **psignature, char **pgeneric_signature)
1206 {
1207     jvmtiError error;
1208     char *signature = NULL;
1209 
1210     /*
1211      * pgeneric_signature can be NULL, and GetClassSignature
1212      * accepts NULL.
1213      */
1214     error = FUNC_PTR(gdata-&gt;jvmti,GetClassSignature)
1215                 (gdata-&gt;jvmti, clazz, &amp;signature, pgeneric_signature);
1216 
1217     if ( psignature != NULL ) {
1218         *psignature = signature;
1219     } else if ( signature != NULL )  {
1220         jvmtiDeallocate(signature);
1221     }
1222     return error;
1223 }
1224 
1225 /* Get class name (not signature) */
1226 char *
1227 getClassname(jclass clazz)
1228 {
1229     char *classname;
1230 
1231     classname = NULL;
1232     if ( clazz != NULL ) {
1233         if (classSignature(clazz, &amp;classname, NULL) != JVMTI_ERROR_NONE) {
1234             classname = NULL;
1235         } else {
1236             /* Convert in place */
1237             convertSignatureToClassname(classname);
1238         }
1239     }
1240     return classname; /* Caller must free this memory */
1241 }
1242 
1243 void
1244 writeGenericSignature(PacketOutputStream *out, char *genericSignature)
1245 {
1246     if (genericSignature == NULL) {
1247         (void)outStream_writeString(out, &quot;&quot;);
1248     } else {
1249         (void)outStream_writeString(out, genericSignature);
1250     }
1251 }
1252 
1253 jint
1254 classStatus(jclass clazz)
1255 {
1256     jint status;
1257     jvmtiError error;
1258 
1259     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassStatus)
1260                 (gdata-&gt;jvmti, clazz, &amp;status);
1261     if (error != JVMTI_ERROR_NONE) {
1262         EXIT_ERROR(error, &quot;on getting class status&quot;);
1263     }
1264     return status;
1265 }
1266 
1267 static jboolean
1268 isArrayClass(jclass clazz)
1269 {
1270     jboolean isArray = JNI_FALSE;
1271     jvmtiError error;
1272 
1273     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsArrayClass)
1274                 (gdata-&gt;jvmti, clazz, &amp;isArray);
1275     if (error != JVMTI_ERROR_NONE) {
1276         EXIT_ERROR(error, &quot;on checking for an array class&quot;);
1277     }
1278     return isArray;
1279 }
1280 
1281 static jboolean
1282 isInterface(jclass clazz)
1283 {
1284     jboolean isInterface = JNI_FALSE;
1285     jvmtiError error;
1286 
1287     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsInterface)
1288                 (gdata-&gt;jvmti, clazz, &amp;isInterface);
1289     if (error != JVMTI_ERROR_NONE) {
1290         EXIT_ERROR(error, &quot;on checking for an interface&quot;);
1291     }
1292     return isInterface;
1293 }
1294 
1295 jvmtiError
1296 isFieldSynthetic(jclass clazz, jfieldID field, jboolean *psynthetic)
1297 {
1298     jvmtiError error;
1299 
1300     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsFieldSynthetic)
1301                 (gdata-&gt;jvmti, clazz, field, psynthetic);
1302     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1303         /* If the query is not supported, we assume it is not synthetic. */
1304         *psynthetic = JNI_FALSE;
1305         return JVMTI_ERROR_NONE;
1306     }
1307     return error;
1308 }
1309 
1310 jvmtiError
1311 isMethodSynthetic(jmethodID method, jboolean *psynthetic)
1312 {
1313     jvmtiError error;
1314 
1315     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodSynthetic)
1316                 (gdata-&gt;jvmti, method, psynthetic);
1317     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1318         /* If the query is not supported, we assume it is not synthetic. */
1319         *psynthetic = JNI_FALSE;
1320         return JVMTI_ERROR_NONE;
1321     }
1322     return error;
1323 }
1324 
1325 jboolean
1326 isMethodNative(jmethodID method)
1327 {
1328     jboolean isNative = JNI_FALSE;
1329     jvmtiError error;
1330 
1331     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodNative)
1332                 (gdata-&gt;jvmti, method, &amp;isNative);
1333     if (error != JVMTI_ERROR_NONE) {
1334         EXIT_ERROR(error, &quot;on checking for a native interface&quot;);
1335     }
1336     return isNative;
1337 }
1338 
1339 jboolean
1340 isSameObject(JNIEnv *env, jobject o1, jobject o2)
1341 {
1342     if ( o1==o2 ) {
1343         return JNI_TRUE;
1344     }
1345     return FUNC_PTR(env,IsSameObject)(env, o1, o2);
1346 }
1347 
1348 jint
1349 objectHashCode(jobject object)
1350 {
1351     jint hashCode = 0;
1352     jvmtiError error;
1353 
1354     if ( object!=NULL ) {
1355         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetObjectHashCode)
1356                     (gdata-&gt;jvmti, object, &amp;hashCode);
1357         if (error != JVMTI_ERROR_NONE) {
1358             EXIT_ERROR(error, &quot;on getting an object hash code&quot;);
1359         }
1360     }
1361     return hashCode;
1362 }
1363 
1364 /* Get all implemented interfaces (must be inside a WITH_LOCAL_REFS) */
1365 jvmtiError
1366 allInterfaces(jclass clazz, jclass **ppinterfaces, jint *pcount)
1367 {
1368     jvmtiError error;
1369 
1370     *pcount = 0;
1371     *ppinterfaces = NULL;
1372     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetImplementedInterfaces)
1373                 (gdata-&gt;jvmti, clazz, pcount, ppinterfaces);
1374     return error;
1375 }
1376 
1377 /* Get all loaded classes (must be inside a WITH_LOCAL_REFS) */
1378 jvmtiError
1379 allLoadedClasses(jclass **ppclasses, jint *pcount)
1380 {
1381     jvmtiError error;
1382 
1383     *pcount = 0;
1384     *ppclasses = NULL;
1385     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetLoadedClasses)
1386                 (gdata-&gt;jvmti, pcount, ppclasses);
1387     return error;
1388 }
1389 
1390 /* Get all loaded classes for a loader (must be inside a WITH_LOCAL_REFS) */
1391 jvmtiError
1392 allClassLoaderClasses(jobject loader, jclass **ppclasses, jint *pcount)
1393 {
1394     jvmtiError error;
1395 
1396     *pcount = 0;
1397     *ppclasses = NULL;
1398     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoaderClasses)
1399                 (gdata-&gt;jvmti, loader, pcount, ppclasses);
1400     return error;
1401 }
1402 
1403 static jboolean
1404 is_a_nested_class(char *outer_sig, int outer_sig_len, char *sig, int sep)
1405 {
1406     char *inner;
1407 
1408     /* Assumed outer class signature is  &quot;LOUTERCLASSNAME;&quot;
1409      *         inner class signature is  &quot;LOUTERCLASSNAME$INNERNAME;&quot;
1410      *
1411      * INNERNAME can take the form:
1412      *    [0-9][1-9]*        anonymous class somewhere in the file
1413      *    [0-9][1-9]*NAME    local class somewhere in the OUTER class
1414      *    NAME               nested class in OUTER
1415      *
1416      * If NAME itself contains a $ (sep) then classname is further nested
1417      *    inside another class.
1418      *
1419      */
1420 
1421     /* Check prefix first */
1422     if ( strncmp(sig, outer_sig, outer_sig_len-1) != 0 ) {
1423         return JNI_FALSE;
1424     }
1425 
1426     /* Prefix must be followed by a $ (sep) */
1427     if ( sig[outer_sig_len-1] != sep ) {
1428         return JNI_FALSE;  /* No sep follows the match, must not be nested. */
1429     }
1430 
1431     /* Walk past any digits, if we reach the end, must be pure anonymous */
1432     inner = sig + outer_sig_len;
1433 #if 1 /* We want to return local classes */
1434     while ( *inner &amp;&amp; isdigit(*inner) ) {
1435         inner++;
1436     }
1437     /* But anonymous class names can&#39;t be trusted. */
1438     if ( *inner == &#39;;&#39; ) {
1439         return JNI_FALSE;  /* A pure anonymous class */
1440     }
1441 #else
1442     if ( *inner &amp;&amp; isdigit(*inner) ) {
1443         return JNI_FALSE;  /* A pure anonymous or local class */
1444     }
1445 #endif
1446 
1447     /* Nested deeper? */
1448     if ( strchr(inner, sep) != NULL ) {
1449         return JNI_FALSE;  /* Nested deeper than we want? */
1450     }
1451     return JNI_TRUE;
1452 }
1453 
1454 /* Get all nested classes for a class (must be inside a WITH_LOCAL_REFS) */
1455 jvmtiError
1456 allNestedClasses(jclass parent_clazz, jclass **ppnested, jint *pcount)
1457 {
1458     jvmtiError error;
1459     jobject parent_loader;
1460     jclass *classes;
1461     char *signature;
1462     size_t len;
1463     jint count;
1464     jint ncount;
1465     int i;
1466 
1467     *ppnested   = NULL;
1468     *pcount     = 0;
1469 
1470     parent_loader = NULL;
1471     classes       = NULL;
1472     signature     = NULL;
1473     count         = 0;
1474     ncount        = 0;
1475 
1476     error = classLoader(parent_clazz, &amp;parent_loader);
1477     if (error != JVMTI_ERROR_NONE) {
1478         return error;
1479     }
1480     error = classSignature(parent_clazz, &amp;signature, NULL);
1481     if (error != JVMTI_ERROR_NONE) {
1482         return error;
1483     }
1484     len = strlen(signature);
1485 
1486     error = allClassLoaderClasses(parent_loader, &amp;classes, &amp;count);
1487     if ( error != JVMTI_ERROR_NONE ) {
1488         jvmtiDeallocate(signature);
1489         return error;
1490     }
1491 
1492     for (i=0; i&lt;count; i++) {
1493         jclass clazz;
1494         char *candidate_signature;
1495 
1496         clazz = classes[i];
1497         candidate_signature = NULL;
1498         error = classSignature(clazz, &amp;candidate_signature, NULL);
1499         if (error != JVMTI_ERROR_NONE) {
1500             break;
1501         }
1502 
1503         if ( is_a_nested_class(signature, (int)len, candidate_signature, &#39;$&#39;) ||
1504              is_a_nested_class(signature, (int)len, candidate_signature, &#39;#&#39;) ) {
1505             /* Float nested classes to top */
1506             classes[i] = classes[ncount];
1507             classes[ncount++] = clazz;
1508         }
1509         jvmtiDeallocate(candidate_signature);
1510     }
1511 
1512     jvmtiDeallocate(signature);
1513 
1514     if ( count != 0 &amp;&amp;  ncount == 0 ) {
1515         jvmtiDeallocate(classes);
1516         classes = NULL;
1517     }
1518 
1519     *ppnested = classes;
1520     *pcount = ncount;
1521     return error;
1522 }
1523 
1524 void
1525 createLocalRefSpace(JNIEnv *env, jint capacity)
1526 {
1527     /*
1528      * Save current exception since it might get overwritten by
1529      * the calls below. Note we must depend on space in the existing
1530      * frame because asking for a new frame may generate an exception.
1531      */
1532     jobject throwable = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
1533 
1534     /*
1535      * Use the current frame if necessary; otherwise create a new one
1536      */
1537     if (JNI_FUNC_PTR(env,PushLocalFrame)(env, capacity) &lt; 0) {
1538         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;PushLocalFrame: Unable to push JNI frame&quot;);
1539     }
1540 
1541     /*
1542      * TO DO: This could be more efficient if it used EnsureLocalCapacity,
1543      * but that would not work if two functions on the call stack
1544      * use this function. We would need to either track reserved
1545      * references on a per-thread basis or come up with a convention
1546      * that would prevent two functions from depending on this function
1547      * at the same time.
1548      */
1549 
1550     /*
1551      * Restore exception state from before call
1552      */
1553     if (throwable != NULL) {
1554         JNI_FUNC_PTR(env,Throw)(env, throwable);
1555     } else {
1556         JNI_FUNC_PTR(env,ExceptionClear)(env);
1557     }
1558 }
1559 
1560 jboolean
1561 isClass(jobject object)
1562 {
1563     JNIEnv *env = getEnv();
1564     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass);
1565 }
1566 
1567 jboolean
1568 isThread(jobject object)
1569 {
1570     JNIEnv *env = getEnv();
1571     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass);
1572 }
1573 
1574 jboolean
1575 isThreadGroup(jobject object)
1576 {
1577     JNIEnv *env = getEnv();
1578     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass);
1579 }
1580 
1581 jboolean
1582 isString(jobject object)
1583 {
1584     JNIEnv *env = getEnv();
1585     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass);
1586 }
1587 
1588 jboolean
1589 isClassLoader(jobject object)
1590 {
1591     JNIEnv *env = getEnv();
1592     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass);
1593 }
1594 
1595 jboolean
1596 isArray(jobject object)
1597 {
1598     JNIEnv *env = getEnv();
1599     jboolean is;
1600 
1601     WITH_LOCAL_REFS(env, 1) {
1602         jclass clazz;
1603         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
1604         is = isArrayClass(clazz);
1605     } END_WITH_LOCAL_REFS(env);
1606 
1607     return is;
1608 }
1609 
1610 /**
1611  * Return property value as jstring
1612  */
1613 static jstring
1614 getPropertyValue(JNIEnv *env, char *propertyName)
1615 {
1616     jstring valueString;
1617     jstring nameString;
1618 
1619     valueString = NULL;
1620 
1621     /* Create new String object to hold the property name */
1622     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1623     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1624         JNI_FUNC_PTR(env,ExceptionClear)(env);
1625         /* NULL will be returned below */
1626     } else {
1627         /* Call valueString = System.getProperty(nameString) */
1628         valueString = JNI_FUNC_PTR(env,CallStaticObjectMethod)
1629             (env, gdata-&gt;systemClass, gdata-&gt;systemGetProperty, nameString);
1630         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1631             JNI_FUNC_PTR(env,ExceptionClear)(env);
1632             valueString = NULL;
1633         }
1634     }
1635     return valueString;
1636 }
1637 
1638 /**
1639  * Set an agent property
1640  */
1641 void
1642 setAgentPropertyValue(JNIEnv *env, char *propertyName, char* propertyValue)
1643 {
1644     jstring nameString;
1645     jstring valueString;
1646 
1647     if (gdata-&gt;agent_properties == NULL) {
1648         /* VMSupport doesn&#39;t exist; so ignore */
1649         return;
1650     }
1651 
1652     /* Create jstrings for property name and value */
1653     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1654     if (nameString != NULL) {
1655         valueString = JNU_NewStringPlatform(env, propertyValue);
1656         if (valueString != NULL) {
1657             /* invoke Properties.setProperty */
1658             JNI_FUNC_PTR(env,CallObjectMethod)
1659                 (env, gdata-&gt;agent_properties,
1660                  gdata-&gt;setProperty,
1661                  nameString, valueString);
1662         }
1663     }
1664     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1665         JNI_FUNC_PTR(env,ExceptionClear)(env);
1666     }
1667 }
1668 
1669 /**
1670  * Return property value as JDWP allocated string in UTF8 encoding
1671  */
1672 static char *
1673 getPropertyUTF8(JNIEnv *env, char *propertyName)
1674 {
1675     jvmtiError  error;
1676     char       *value;
1677 
1678     value = NULL;
1679     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSystemProperty)
1680                 (gdata-&gt;jvmti, (const char *)propertyName, &amp;value);
1681     if (error != JVMTI_ERROR_NONE) {
1682         jstring valueString;
1683 
1684         value = NULL;
1685         valueString = getPropertyValue(env, propertyName);
1686 
1687         if (valueString != NULL) {
1688             const char *utf;
1689 
1690             /* Get the UTF8 encoding for this property value string */
1691             utf = JNI_FUNC_PTR(env,GetStringUTFChars)(env, valueString, NULL);
1692             /* Make a copy for returning, release the JNI copy */
1693             value = jvmtiAllocate((int)strlen(utf) + 1);
1694             if (value != NULL) {
1695                 (void)strcpy(value, utf);
1696             }
1697             JNI_FUNC_PTR(env,ReleaseStringUTFChars)(env, valueString, utf);
1698         }
1699     }
1700     if ( value == NULL ) {
1701         ERROR_MESSAGE((&quot;JDWP Can&#39;t get property value for %s&quot;, propertyName));
1702         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
1703     }
1704     return value;
1705 }
1706 
1707 jboolean
1708 isMethodObsolete(jmethodID method)
1709 {
1710     jvmtiError error;
1711     jboolean obsolete = JNI_TRUE;
1712 
1713     if ( method != NULL ) {
1714         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodObsolete)
1715                     (gdata-&gt;jvmti, method, &amp;obsolete);
1716         if (error != JVMTI_ERROR_NONE) {
1717             obsolete = JNI_TRUE;
1718         }
1719     }
1720     return obsolete;
1721 }
1722 
1723 /* Get the jvmti environment to be used with tags */
1724 jvmtiEnv *
1725 getSpecialJvmti(void)
1726 {
1727     jvmtiEnv  *jvmti;
1728     jvmtiError error;
1729     int        rc;
1730 
1731     /* Get one time use JVMTI Env */
1732     jvmtiCapabilities caps;
1733 
1734     rc = JVM_FUNC_PTR(gdata-&gt;jvm,GetEnv)
1735                      (gdata-&gt;jvm, (void **)&amp;jvmti, JVMTI_VERSION_1);
1736     if (rc != JNI_OK) {
1737         return NULL;
1738     }
1739     (void)memset(&amp;caps, 0, (int)sizeof(caps));
1740     caps.can_tag_objects = 1;
1741     error = JVMTI_FUNC_PTR(jvmti,AddCapabilities)(jvmti, &amp;caps);
1742     if ( error != JVMTI_ERROR_NONE ) {
1743         return NULL;
1744     }
1745     return jvmti;
1746 }
1747 
1748 void
1749 writeCodeLocation(PacketOutputStream *out, jclass clazz,
1750                        jmethodID method, jlocation location)
1751 {
1752     jbyte tag;
1753 
1754     if (clazz != NULL) {
1755         tag = referenceTypeTag(clazz);
1756     } else {
1757         tag = JDWP_TYPE_TAG(CLASS);
1758     }
1759     (void)outStream_writeByte(out, tag);
1760     (void)outStream_writeObjectRef(getEnv(), out, clazz);
1761     (void)outStream_writeMethodID(out, isMethodObsolete(method)?NULL:method);
1762     (void)outStream_writeLocation(out, location);
1763 }
1764 
1765 void *
1766 jvmtiAllocate(jint numBytes)
1767 {
1768     void *ptr;
1769     jvmtiError error;
1770     if ( numBytes == 0 ) {
1771         return NULL;
1772     }
1773     error = FUNC_PTR(gdata-&gt;jvmti,Allocate)
1774                 (gdata-&gt;jvmti, numBytes, (unsigned char**)&amp;ptr);
1775     if (error != JVMTI_ERROR_NONE ) {
1776         EXIT_ERROR(error, &quot;Can&#39;t allocate jvmti memory&quot;);
1777     }
1778     return ptr;
1779 }
1780 
1781 void
1782 jvmtiDeallocate(void *ptr)
1783 {
1784     jvmtiError error;
1785     if ( ptr == NULL ) {
1786         return;
1787     }
1788     error = FUNC_PTR(gdata-&gt;jvmti,Deallocate)
1789                 (gdata-&gt;jvmti, ptr);
1790     if (error != JVMTI_ERROR_NONE ) {
1791         EXIT_ERROR(error, &quot;Can&#39;t deallocate jvmti memory&quot;);
1792     }
1793 }
1794 
1795 /* Rarely needed, transport library uses JDWP errors, only use? */
1796 jvmtiError
1797 map2jvmtiError(jdwpError error)
1798 {
1799     switch ( error ) {
1800         case JDWP_ERROR(NONE):
1801             return JVMTI_ERROR_NONE;
1802         case JDWP_ERROR(INVALID_THREAD):
1803             return JVMTI_ERROR_INVALID_THREAD;
1804         case JDWP_ERROR(INVALID_THREAD_GROUP):
1805             return JVMTI_ERROR_INVALID_THREAD_GROUP;
1806         case JDWP_ERROR(INVALID_PRIORITY):
1807             return JVMTI_ERROR_INVALID_PRIORITY;
1808         case JDWP_ERROR(THREAD_NOT_SUSPENDED):
1809             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1810         case JDWP_ERROR(THREAD_SUSPENDED):
1811             return JVMTI_ERROR_THREAD_SUSPENDED;
1812         case JDWP_ERROR(INVALID_OBJECT):
1813             return JVMTI_ERROR_INVALID_OBJECT;
1814         case JDWP_ERROR(INVALID_CLASS):
1815             return JVMTI_ERROR_INVALID_CLASS;
1816         case JDWP_ERROR(CLASS_NOT_PREPARED):
1817             return JVMTI_ERROR_CLASS_NOT_PREPARED;
1818         case JDWP_ERROR(INVALID_METHODID):
1819             return JVMTI_ERROR_INVALID_METHODID;
1820         case JDWP_ERROR(INVALID_LOCATION):
1821             return JVMTI_ERROR_INVALID_LOCATION;
1822         case JDWP_ERROR(INVALID_FIELDID):
1823             return JVMTI_ERROR_INVALID_FIELDID;
1824         case JDWP_ERROR(INVALID_FRAMEID):
1825             return AGENT_ERROR_INVALID_FRAMEID;
1826         case JDWP_ERROR(NO_MORE_FRAMES):
1827             return JVMTI_ERROR_NO_MORE_FRAMES;
1828         case JDWP_ERROR(OPAQUE_FRAME):
1829             return JVMTI_ERROR_OPAQUE_FRAME;
1830         case JDWP_ERROR(NOT_CURRENT_FRAME):
1831             return AGENT_ERROR_NOT_CURRENT_FRAME;
1832         case JDWP_ERROR(TYPE_MISMATCH):
1833             return JVMTI_ERROR_TYPE_MISMATCH;
1834         case JDWP_ERROR(INVALID_SLOT):
1835             return JVMTI_ERROR_INVALID_SLOT;
1836         case JDWP_ERROR(DUPLICATE):
1837             return JVMTI_ERROR_DUPLICATE;
1838         case JDWP_ERROR(NOT_FOUND):
1839             return JVMTI_ERROR_NOT_FOUND;
1840         case JDWP_ERROR(INVALID_MONITOR):
1841             return JVMTI_ERROR_INVALID_MONITOR;
1842         case JDWP_ERROR(NOT_MONITOR_OWNER):
1843             return JVMTI_ERROR_NOT_MONITOR_OWNER;
1844         case JDWP_ERROR(INTERRUPT):
1845             return JVMTI_ERROR_INTERRUPT;
1846         case JDWP_ERROR(INVALID_CLASS_FORMAT):
1847             return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1848         case JDWP_ERROR(CIRCULAR_CLASS_DEFINITION):
1849             return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1850         case JDWP_ERROR(FAILS_VERIFICATION):
1851             return JVMTI_ERROR_FAILS_VERIFICATION;
1852         case JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED):
1853             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1854         case JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED):
1855             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1856         case JDWP_ERROR(INVALID_TYPESTATE):
1857             return JVMTI_ERROR_INVALID_TYPESTATE;
1858         case JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED):
1859             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
1860         case JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED):
1861             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1862         case JDWP_ERROR(UNSUPPORTED_VERSION):
1863             return JVMTI_ERROR_UNSUPPORTED_VERSION;
1864         case JDWP_ERROR(NAMES_DONT_MATCH):
1865             return JVMTI_ERROR_NAMES_DONT_MATCH;
1866         case JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1867             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
1868         case JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1869             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1870         case JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED):
1871             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
1872         case JDWP_ERROR(NOT_IMPLEMENTED):
1873             return JVMTI_ERROR_NOT_AVAILABLE;
1874         case JDWP_ERROR(NULL_POINTER):
1875             return JVMTI_ERROR_NULL_POINTER;
1876         case JDWP_ERROR(ABSENT_INFORMATION):
1877             return JVMTI_ERROR_ABSENT_INFORMATION;
1878         case JDWP_ERROR(INVALID_EVENT_TYPE):
1879             return JVMTI_ERROR_INVALID_EVENT_TYPE;
1880         case JDWP_ERROR(ILLEGAL_ARGUMENT):
1881             return JVMTI_ERROR_ILLEGAL_ARGUMENT;
1882         case JDWP_ERROR(OUT_OF_MEMORY):
1883             return JVMTI_ERROR_OUT_OF_MEMORY;
1884         case JDWP_ERROR(ACCESS_DENIED):
1885             return JVMTI_ERROR_ACCESS_DENIED;
1886         case JDWP_ERROR(VM_DEAD):
1887             return JVMTI_ERROR_WRONG_PHASE;
1888         case JDWP_ERROR(UNATTACHED_THREAD):
1889             return JVMTI_ERROR_UNATTACHED_THREAD;
1890         case JDWP_ERROR(INVALID_TAG):
1891             return AGENT_ERROR_INVALID_TAG;
1892         case JDWP_ERROR(ALREADY_INVOKING):
1893             return AGENT_ERROR_ALREADY_INVOKING;
1894         case JDWP_ERROR(INVALID_INDEX):
1895             return AGENT_ERROR_INVALID_INDEX;
1896         case JDWP_ERROR(INVALID_LENGTH):
1897             return AGENT_ERROR_INVALID_LENGTH;
1898         case JDWP_ERROR(INVALID_STRING):
1899             return AGENT_ERROR_INVALID_STRING;
1900         case JDWP_ERROR(INVALID_CLASS_LOADER):
1901             return AGENT_ERROR_INVALID_CLASS_LOADER;
1902         case JDWP_ERROR(INVALID_ARRAY):
1903             return AGENT_ERROR_INVALID_ARRAY;
1904         case JDWP_ERROR(TRANSPORT_LOAD):
1905             return AGENT_ERROR_TRANSPORT_LOAD;
1906         case JDWP_ERROR(TRANSPORT_INIT):
1907             return AGENT_ERROR_TRANSPORT_INIT;
1908         case JDWP_ERROR(NATIVE_METHOD):
1909             return AGENT_ERROR_NATIVE_METHOD;
1910         case JDWP_ERROR(INVALID_COUNT):
1911             return AGENT_ERROR_INVALID_COUNT;
1912         case JDWP_ERROR(INTERNAL):
1913             return AGENT_ERROR_JDWP_INTERNAL;
1914     }
1915     return AGENT_ERROR_INTERNAL;
1916 }
1917 
1918 static jvmtiEvent index2jvmti[EI_max-EI_min+1];
1919 static jdwpEvent  index2jdwp [EI_max-EI_min+1];
1920 
1921 void
1922 eventIndexInit(void)
1923 {
1924     (void)memset(index2jvmti, 0, (int)sizeof(index2jvmti));
1925     (void)memset(index2jdwp,  0, (int)sizeof(index2jdwp));
1926 
1927     index2jvmti[EI_SINGLE_STEP        -EI_min] = JVMTI_EVENT_SINGLE_STEP;
1928     index2jvmti[EI_BREAKPOINT         -EI_min] = JVMTI_EVENT_BREAKPOINT;
1929     index2jvmti[EI_FRAME_POP          -EI_min] = JVMTI_EVENT_FRAME_POP;
1930     index2jvmti[EI_EXCEPTION          -EI_min] = JVMTI_EVENT_EXCEPTION;
1931     index2jvmti[EI_THREAD_START       -EI_min] = JVMTI_EVENT_THREAD_START;
1932     index2jvmti[EI_THREAD_END         -EI_min] = JVMTI_EVENT_THREAD_END;
1933     index2jvmti[EI_CLASS_PREPARE      -EI_min] = JVMTI_EVENT_CLASS_PREPARE;
1934     index2jvmti[EI_GC_FINISH          -EI_min] = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;
1935     index2jvmti[EI_CLASS_LOAD         -EI_min] = JVMTI_EVENT_CLASS_LOAD;
1936     index2jvmti[EI_FIELD_ACCESS       -EI_min] = JVMTI_EVENT_FIELD_ACCESS;
1937     index2jvmti[EI_FIELD_MODIFICATION -EI_min] = JVMTI_EVENT_FIELD_MODIFICATION;
1938     index2jvmti[EI_EXCEPTION_CATCH    -EI_min] = JVMTI_EVENT_EXCEPTION_CATCH;
1939     index2jvmti[EI_METHOD_ENTRY       -EI_min] = JVMTI_EVENT_METHOD_ENTRY;
1940     index2jvmti[EI_METHOD_EXIT        -EI_min] = JVMTI_EVENT_METHOD_EXIT;
1941     index2jvmti[EI_MONITOR_CONTENDED_ENTER      -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTER;
1942     index2jvmti[EI_MONITOR_CONTENDED_ENTERED    -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTERED;
1943     index2jvmti[EI_MONITOR_WAIT       -EI_min] = JVMTI_EVENT_MONITOR_WAIT;
1944     index2jvmti[EI_MONITOR_WAITED     -EI_min] = JVMTI_EVENT_MONITOR_WAITED;
1945     index2jvmti[EI_VM_INIT            -EI_min] = JVMTI_EVENT_VM_INIT;
1946     index2jvmti[EI_VM_DEATH           -EI_min] = JVMTI_EVENT_VM_DEATH;
1947 
1948     index2jdwp[EI_SINGLE_STEP         -EI_min] = JDWP_EVENT(SINGLE_STEP);
1949     index2jdwp[EI_BREAKPOINT          -EI_min] = JDWP_EVENT(BREAKPOINT);
1950     index2jdwp[EI_FRAME_POP           -EI_min] = JDWP_EVENT(FRAME_POP);
1951     index2jdwp[EI_EXCEPTION           -EI_min] = JDWP_EVENT(EXCEPTION);
1952     index2jdwp[EI_THREAD_START        -EI_min] = JDWP_EVENT(THREAD_START);
1953     index2jdwp[EI_THREAD_END          -EI_min] = JDWP_EVENT(THREAD_END);
1954     index2jdwp[EI_CLASS_PREPARE       -EI_min] = JDWP_EVENT(CLASS_PREPARE);
1955     index2jdwp[EI_GC_FINISH           -EI_min] = JDWP_EVENT(CLASS_UNLOAD);
1956     index2jdwp[EI_CLASS_LOAD          -EI_min] = JDWP_EVENT(CLASS_LOAD);
1957     index2jdwp[EI_FIELD_ACCESS        -EI_min] = JDWP_EVENT(FIELD_ACCESS);
1958     index2jdwp[EI_FIELD_MODIFICATION  -EI_min] = JDWP_EVENT(FIELD_MODIFICATION);
1959     index2jdwp[EI_EXCEPTION_CATCH     -EI_min] = JDWP_EVENT(EXCEPTION_CATCH);
1960     index2jdwp[EI_METHOD_ENTRY        -EI_min] = JDWP_EVENT(METHOD_ENTRY);
1961     index2jdwp[EI_METHOD_EXIT         -EI_min] = JDWP_EVENT(METHOD_EXIT);
1962     index2jdwp[EI_MONITOR_CONTENDED_ENTER             -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTER);
1963     index2jdwp[EI_MONITOR_CONTENDED_ENTERED           -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTERED);
1964     index2jdwp[EI_MONITOR_WAIT        -EI_min] = JDWP_EVENT(MONITOR_WAIT);
1965     index2jdwp[EI_MONITOR_WAITED      -EI_min] = JDWP_EVENT(MONITOR_WAITED);
1966     index2jdwp[EI_VM_INIT             -EI_min] = JDWP_EVENT(VM_INIT);
1967     index2jdwp[EI_VM_DEATH            -EI_min] = JDWP_EVENT(VM_DEATH);
1968 }
1969 
1970 jdwpEvent
1971 eventIndex2jdwp(EventIndex i)
1972 {
1973     if ( i &lt; EI_min || i &gt; EI_max ) {
1974         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
1975     }
1976     return index2jdwp[i-EI_min];
1977 }
1978 
1979 jvmtiEvent
1980 eventIndex2jvmti(EventIndex i)
1981 {
1982     if ( i &lt; EI_min || i &gt; EI_max ) {
1983         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
1984     }
1985     return index2jvmti[i-EI_min];
1986 }
1987 
1988 EventIndex
1989 jdwp2EventIndex(jdwpEvent eventType)
1990 {
1991     switch ( eventType ) {
1992         case JDWP_EVENT(SINGLE_STEP):
1993             return EI_SINGLE_STEP;
1994         case JDWP_EVENT(BREAKPOINT):
1995             return EI_BREAKPOINT;
1996         case JDWP_EVENT(FRAME_POP):
1997             return EI_FRAME_POP;
1998         case JDWP_EVENT(EXCEPTION):
1999             return EI_EXCEPTION;
2000         case JDWP_EVENT(THREAD_START):
2001             return EI_THREAD_START;
2002         case JDWP_EVENT(THREAD_END):
2003             return EI_THREAD_END;
2004         case JDWP_EVENT(CLASS_PREPARE):
2005             return EI_CLASS_PREPARE;
2006         case JDWP_EVENT(CLASS_UNLOAD):
2007             return EI_GC_FINISH;
2008         case JDWP_EVENT(CLASS_LOAD):
2009             return EI_CLASS_LOAD;
2010         case JDWP_EVENT(FIELD_ACCESS):
2011             return EI_FIELD_ACCESS;
2012         case JDWP_EVENT(FIELD_MODIFICATION):
2013             return EI_FIELD_MODIFICATION;
2014         case JDWP_EVENT(EXCEPTION_CATCH):
2015             return EI_EXCEPTION_CATCH;
2016         case JDWP_EVENT(METHOD_ENTRY):
2017             return EI_METHOD_ENTRY;
2018         case JDWP_EVENT(METHOD_EXIT):
2019             return EI_METHOD_EXIT;
2020         case JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE):
2021             return EI_METHOD_EXIT;
2022         case JDWP_EVENT(MONITOR_CONTENDED_ENTER):
2023             return EI_MONITOR_CONTENDED_ENTER;
2024         case JDWP_EVENT(MONITOR_CONTENDED_ENTERED):
2025             return EI_MONITOR_CONTENDED_ENTERED;
2026         case JDWP_EVENT(MONITOR_WAIT):
2027             return EI_MONITOR_WAIT;
2028         case JDWP_EVENT(MONITOR_WAITED):
2029             return EI_MONITOR_WAITED;
2030         case JDWP_EVENT(VM_INIT):
2031             return EI_VM_INIT;
2032         case JDWP_EVENT(VM_DEATH):
2033             return EI_VM_DEATH;
2034         default:
2035             break;
2036     }
2037 
2038     /*
2039      * Event type not recognized - don&#39;t exit with error as caller
2040      * may wish to return error to debugger.
2041      */
2042     return (EventIndex)0;
2043 }
2044 
2045 EventIndex
2046 jvmti2EventIndex(jvmtiEvent kind)
2047 {
2048     switch ( kind ) {
2049         case JVMTI_EVENT_SINGLE_STEP:
2050             return EI_SINGLE_STEP;
2051         case JVMTI_EVENT_BREAKPOINT:
2052             return EI_BREAKPOINT;
2053         case JVMTI_EVENT_FRAME_POP:
2054             return EI_FRAME_POP;
2055         case JVMTI_EVENT_EXCEPTION:
2056             return EI_EXCEPTION;
2057         case JVMTI_EVENT_THREAD_START:
2058             return EI_THREAD_START;
2059         case JVMTI_EVENT_THREAD_END:
2060             return EI_THREAD_END;
2061         case JVMTI_EVENT_CLASS_PREPARE:
2062             return EI_CLASS_PREPARE;
2063         case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:
2064             return EI_GC_FINISH;
2065         case JVMTI_EVENT_CLASS_LOAD:
2066             return EI_CLASS_LOAD;
2067         case JVMTI_EVENT_FIELD_ACCESS:
2068             return EI_FIELD_ACCESS;
2069         case JVMTI_EVENT_FIELD_MODIFICATION:
2070             return EI_FIELD_MODIFICATION;
2071         case JVMTI_EVENT_EXCEPTION_CATCH:
2072             return EI_EXCEPTION_CATCH;
2073         case JVMTI_EVENT_METHOD_ENTRY:
2074             return EI_METHOD_ENTRY;
2075         case JVMTI_EVENT_METHOD_EXIT:
2076             return EI_METHOD_EXIT;
2077         /*
2078          * There is no JVMTI_EVENT_METHOD_EXIT_WITH_RETURN_VALUE.
2079          * The normal JVMTI_EVENT_METHOD_EXIT always contains the return value.
2080          */
2081         case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:
2082             return EI_MONITOR_CONTENDED_ENTER;
2083         case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:
2084             return EI_MONITOR_CONTENDED_ENTERED;
2085         case JVMTI_EVENT_MONITOR_WAIT:
2086             return EI_MONITOR_WAIT;
2087         case JVMTI_EVENT_MONITOR_WAITED:
2088             return EI_MONITOR_WAITED;
2089         case JVMTI_EVENT_VM_INIT:
2090             return EI_VM_INIT;
2091         case JVMTI_EVENT_VM_DEATH:
2092             return EI_VM_DEATH;
2093         default:
2094             EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;JVMTI to EventIndex mapping&quot;);
2095             break;
2096     }
2097     return (EventIndex)0;
2098 }
2099 
2100 /* This routine is commonly used, maps jvmti and agent errors to the best
2101  *    jdwp error code we can map to.
2102  */
2103 jdwpError
2104 map2jdwpError(jvmtiError error)
2105 {
2106     switch ( (int)error ) {
2107         case JVMTI_ERROR_NONE:
2108             return JDWP_ERROR(NONE);
2109         case AGENT_ERROR_INVALID_THREAD:
2110         case JVMTI_ERROR_INVALID_THREAD:
2111             return JDWP_ERROR(INVALID_THREAD);
2112         case JVMTI_ERROR_INVALID_THREAD_GROUP:
2113             return JDWP_ERROR(INVALID_THREAD_GROUP);
2114         case JVMTI_ERROR_INVALID_PRIORITY:
2115             return JDWP_ERROR(INVALID_PRIORITY);
2116         case JVMTI_ERROR_THREAD_NOT_SUSPENDED:
2117             return JDWP_ERROR(THREAD_NOT_SUSPENDED);
2118         case JVMTI_ERROR_THREAD_SUSPENDED:
2119             return JDWP_ERROR(THREAD_SUSPENDED);
2120         case JVMTI_ERROR_THREAD_NOT_ALIVE:
2121             return JDWP_ERROR(INVALID_THREAD);
2122         case AGENT_ERROR_INVALID_OBJECT:
2123         case JVMTI_ERROR_INVALID_OBJECT:
2124             return JDWP_ERROR(INVALID_OBJECT);
2125         case JVMTI_ERROR_INVALID_CLASS:
2126             return JDWP_ERROR(INVALID_CLASS);
2127         case JVMTI_ERROR_CLASS_NOT_PREPARED:
2128             return JDWP_ERROR(CLASS_NOT_PREPARED);
2129         case JVMTI_ERROR_INVALID_METHODID:
2130             return JDWP_ERROR(INVALID_METHODID);
2131         case JVMTI_ERROR_INVALID_LOCATION:
2132             return JDWP_ERROR(INVALID_LOCATION);
2133         case JVMTI_ERROR_INVALID_FIELDID:
2134             return JDWP_ERROR(INVALID_FIELDID);
2135         case AGENT_ERROR_NO_MORE_FRAMES:
2136         case JVMTI_ERROR_NO_MORE_FRAMES:
2137             return JDWP_ERROR(NO_MORE_FRAMES);
2138         case JVMTI_ERROR_OPAQUE_FRAME:
2139             return JDWP_ERROR(OPAQUE_FRAME);
2140         case JVMTI_ERROR_TYPE_MISMATCH:
2141             return JDWP_ERROR(TYPE_MISMATCH);
2142         case JVMTI_ERROR_INVALID_SLOT:
2143             return JDWP_ERROR(INVALID_SLOT);
2144         case JVMTI_ERROR_DUPLICATE:
2145             return JDWP_ERROR(DUPLICATE);
2146         case JVMTI_ERROR_NOT_FOUND:
2147             return JDWP_ERROR(NOT_FOUND);
2148         case JVMTI_ERROR_INVALID_MONITOR:
2149             return JDWP_ERROR(INVALID_MONITOR);
2150         case JVMTI_ERROR_NOT_MONITOR_OWNER:
2151             return JDWP_ERROR(NOT_MONITOR_OWNER);
2152         case JVMTI_ERROR_INTERRUPT:
2153             return JDWP_ERROR(INTERRUPT);
2154         case JVMTI_ERROR_INVALID_CLASS_FORMAT:
2155             return JDWP_ERROR(INVALID_CLASS_FORMAT);
2156         case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:
2157             return JDWP_ERROR(CIRCULAR_CLASS_DEFINITION);
2158         case JVMTI_ERROR_FAILS_VERIFICATION:
2159             return JDWP_ERROR(FAILS_VERIFICATION);
2160         case JVMTI_ERROR_INVALID_TYPESTATE:
2161             return JDWP_ERROR(INVALID_TYPESTATE);
2162         case JVMTI_ERROR_UNSUPPORTED_VERSION:
2163             return JDWP_ERROR(UNSUPPORTED_VERSION);
2164         case JVMTI_ERROR_NAMES_DONT_MATCH:
2165             return JDWP_ERROR(NAMES_DONT_MATCH);
2166         case AGENT_ERROR_NULL_POINTER:
2167         case JVMTI_ERROR_NULL_POINTER:
2168             return JDWP_ERROR(NULL_POINTER);
2169         case JVMTI_ERROR_ABSENT_INFORMATION:
2170             return JDWP_ERROR(ABSENT_INFORMATION);
2171         case AGENT_ERROR_INVALID_EVENT_TYPE:
2172         case JVMTI_ERROR_INVALID_EVENT_TYPE:
2173             return JDWP_ERROR(INVALID_EVENT_TYPE);
2174         case AGENT_ERROR_ILLEGAL_ARGUMENT:
2175         case JVMTI_ERROR_ILLEGAL_ARGUMENT:
2176             return JDWP_ERROR(ILLEGAL_ARGUMENT);
2177         case JVMTI_ERROR_OUT_OF_MEMORY:
2178         case AGENT_ERROR_OUT_OF_MEMORY:
2179             return JDWP_ERROR(OUT_OF_MEMORY);
2180         case JVMTI_ERROR_ACCESS_DENIED:
2181             return JDWP_ERROR(ACCESS_DENIED);
2182         case JVMTI_ERROR_WRONG_PHASE:
2183         case AGENT_ERROR_VM_DEAD:
2184         case AGENT_ERROR_NO_JNI_ENV:
2185             return JDWP_ERROR(VM_DEAD);
2186         case AGENT_ERROR_JNI_EXCEPTION:
2187         case JVMTI_ERROR_UNATTACHED_THREAD:
2188             return JDWP_ERROR(UNATTACHED_THREAD);
2189         case JVMTI_ERROR_NOT_AVAILABLE:
2190         case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:
2191             return JDWP_ERROR(NOT_IMPLEMENTED);
2192         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:
2193             return JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED);
2194         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:
2195             return JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED);
2196         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:
2197             return JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED);
2198         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:
2199             return JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED);
2200         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:
2201             return JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2202         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:
2203             return JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2204         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED:
2205             return JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED);
2206         case AGENT_ERROR_NOT_CURRENT_FRAME:
2207             return JDWP_ERROR(NOT_CURRENT_FRAME);
2208         case AGENT_ERROR_INVALID_TAG:
2209             return JDWP_ERROR(INVALID_TAG);
2210         case AGENT_ERROR_ALREADY_INVOKING:
2211             return JDWP_ERROR(ALREADY_INVOKING);
2212         case AGENT_ERROR_INVALID_INDEX:
2213             return JDWP_ERROR(INVALID_INDEX);
2214         case AGENT_ERROR_INVALID_LENGTH:
2215             return JDWP_ERROR(INVALID_LENGTH);
2216         case AGENT_ERROR_INVALID_STRING:
2217             return JDWP_ERROR(INVALID_STRING);
2218         case AGENT_ERROR_INVALID_CLASS_LOADER:
2219             return JDWP_ERROR(INVALID_CLASS_LOADER);
2220         case AGENT_ERROR_INVALID_ARRAY:
2221             return JDWP_ERROR(INVALID_ARRAY);
2222         case AGENT_ERROR_TRANSPORT_LOAD:
2223             return JDWP_ERROR(TRANSPORT_LOAD);
2224         case AGENT_ERROR_TRANSPORT_INIT:
2225             return JDWP_ERROR(TRANSPORT_INIT);
2226         case AGENT_ERROR_NATIVE_METHOD:
2227             return JDWP_ERROR(NATIVE_METHOD);
2228         case AGENT_ERROR_INVALID_COUNT:
2229             return JDWP_ERROR(INVALID_COUNT);
2230         case AGENT_ERROR_INVALID_FRAMEID:
2231             return JDWP_ERROR(INVALID_FRAMEID);
2232         case JVMTI_ERROR_INTERNAL:
2233         case JVMTI_ERROR_INVALID_ENVIRONMENT:
2234         case AGENT_ERROR_INTERNAL:
2235         case AGENT_ERROR_JVMTI_INTERNAL:
2236         case AGENT_ERROR_JDWP_INTERNAL:
2237             return JDWP_ERROR(INTERNAL);
2238         default:
2239             break;
2240     }
2241     return JDWP_ERROR(INTERNAL);
2242 }
2243 
2244 jint
2245 map2jdwpSuspendStatus(jint state)
2246 {
2247     jint status = 0;
2248     if ( ( state &amp; JVMTI_THREAD_STATE_SUSPENDED ) != 0 )  {
2249         status = JDWP_SUSPEND_STATUS(SUSPENDED);
2250     }
2251     return status;
2252 }
2253 
2254 jdwpThreadStatus
2255 map2jdwpThreadStatus(jint state)
2256 {
2257     jdwpThreadStatus status;
2258 
2259     status = (jdwpThreadStatus)(-1);
2260 
2261     if ( ! ( state &amp; JVMTI_THREAD_STATE_ALIVE ) ) {
2262         if ( state &amp; JVMTI_THREAD_STATE_TERMINATED ) {
2263             status = JDWP_THREAD_STATUS(ZOMBIE);
2264         } else {
2265             /* FIXUP? New JDWP #define for not started? */
2266             status = (jdwpThreadStatus)(-1);
2267         }
2268     } else {
2269         if ( state &amp; JVMTI_THREAD_STATE_SLEEPING ) {
2270             status = JDWP_THREAD_STATUS(SLEEPING);
2271         } else if ( state &amp; JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER ) {
2272             status = JDWP_THREAD_STATUS(MONITOR);
2273         } else if ( state &amp; JVMTI_THREAD_STATE_WAITING ) {
2274             status = JDWP_THREAD_STATUS(WAIT);
2275         } else if ( state &amp; JVMTI_THREAD_STATE_RUNNABLE ) {
2276             status = JDWP_THREAD_STATUS(RUNNING);
2277         }
2278     }
2279     return status;
2280 }
2281 
2282 jint
2283 map2jdwpClassStatus(jint classStatus)
2284 {
2285     jint status = 0;
2286     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_VERIFIED ) != 0 ) {
2287         status |= JDWP_CLASS_STATUS(VERIFIED);
2288     }
2289     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_PREPARED ) != 0 ) {
2290         status |= JDWP_CLASS_STATUS(PREPARED);
2291     }
2292     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_INITIALIZED ) != 0 ) {
2293         status |= JDWP_CLASS_STATUS(INITIALIZED);
2294     }
2295     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_ERROR ) != 0 ) {
2296         status |= JDWP_CLASS_STATUS(ERROR);
2297     }
2298     return status;
2299 }
2300 
2301 void
2302 log_debugee_location(const char *func,
2303         jthread thread, jmethodID method, jlocation location)
2304 {
2305     int logging_locations = LOG_TEST(JDWP_LOG_LOC);
2306 
2307     if ( logging_locations ) {
2308         char *method_name;
2309         char *class_sig;
2310         jvmtiError error;
2311         jvmtiThreadInfo info;
2312         jint state;
2313 
2314         /* Get thread information */
2315         info.name = NULL;
2316         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadInfo)
2317                                 (gdata-&gt;jvmti, thread, &amp;info);
2318         if ( error != JVMTI_ERROR_NONE) {
2319             info.name = NULL;
2320         }
2321         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadState)
2322                                 (gdata-&gt;jvmti, thread, &amp;state);
2323         if ( error != JVMTI_ERROR_NONE) {
2324             state = 0;
2325         }
2326 
2327         /* Get method if necessary */
2328         if ( method==NULL ) {
2329             error = FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
2330                         (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
2331             if ( error != JVMTI_ERROR_NONE ) {
2332                 method = NULL;
2333                 location = 0;
2334             }
2335         }
2336 
2337         /* Get method name */
2338         method_name = NULL;
2339         if ( method != NULL ) {
2340             error = methodSignature(method, &amp;method_name, NULL, NULL);
2341             if ( error != JVMTI_ERROR_NONE ) {
2342                 method_name = NULL;
2343             }
2344         }
2345 
2346         /* Get class signature */
2347         class_sig = NULL;
2348         if ( method != NULL ) {
2349             jclass clazz;
2350 
2351             error = methodClass(method, &amp;clazz);
2352             if ( error == JVMTI_ERROR_NONE ) {
2353                 error = classSignature(clazz, &amp;class_sig, NULL);
2354                 if ( error != JVMTI_ERROR_NONE ) {
2355                     class_sig = NULL;
2356                 }
2357             }
2358         }
2359 
2360         /* Issue log message */
2361         LOG_LOC((&quot;%s: debugee: thread=%p(%s:0x%x),method=%p(%s@%d;%s)&quot;,
2362                 func,
2363                 thread, info.name==NULL ? &quot;?&quot; : info.name, state,
2364                 method, method_name==NULL ? &quot;?&quot; : method_name,
2365                 (int)location, class_sig==NULL ? &quot;?&quot; : class_sig));
2366 
2367         /* Free memory */
2368         if ( class_sig != NULL ) {
2369             jvmtiDeallocate(class_sig);
2370         }
2371         if ( method_name != NULL ) {
2372             jvmtiDeallocate(method_name);
2373         }
2374         if ( info.name != NULL ) {
2375             jvmtiDeallocate(info.name);
2376         }
2377     }
2378 }
2379 
2380 /* ********************************************************************* */
2381 /* JDK 6.0: Use of new Heap Iteration functions */
2382 /* ********************************************************************* */
2383 
2384 /* ********************************************************************* */
2385 /* Instances */
2386 
2387 /* Structure to hold class instances heap iteration data (arg user_data) */
2388 typedef struct ClassInstancesData {
2389     jint         instCount;
2390     jint         maxInstances;
2391     jlong        objTag;
2392     jvmtiError   error;
2393 } ClassInstancesData;
2394 
2395 /* Callback for instance object tagging (heap_reference_callback). */
2396 static jint JNICALL
2397 cbObjectTagInstance(jvmtiHeapReferenceKind reference_kind,
2398      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2399      jlong referrer_class_tag, jlong size,
2400      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2401 {
2402     ClassInstancesData  *data;
2403 
2404     /* Check data structure */
2405     data = (ClassInstancesData*)user_data;
2406     if (data == NULL) {
2407         return JVMTI_VISIT_ABORT;
2408     }
2409 
2410     /* If we have tagged enough objects, just abort */
2411     if ( data-&gt;maxInstances != 0 &amp;&amp; data-&gt;instCount &gt;= data-&gt;maxInstances ) {
2412         return JVMTI_VISIT_ABORT;
2413     }
2414 
2415     /* If tagged already, just continue */
2416     if ( (*tag_ptr) != (jlong)0 ) {
2417         return JVMTI_VISIT_OBJECTS;
2418     }
2419 
2420     /* Tag the object so we don&#39;t count it again, and so we can retrieve it */
2421     (*tag_ptr) = data-&gt;objTag;
2422     data-&gt;instCount++;
2423     return JVMTI_VISIT_OBJECTS;
2424 }
2425 
2426 /* Get instances for one class */
2427 jvmtiError
2428 classInstances(jclass klass, ObjectBatch *instances, int maxInstances)
2429 {
2430     ClassInstancesData data;
2431     jvmtiHeapCallbacks heap_callbacks;
2432     jvmtiError         error;
2433     jvmtiEnv          *jvmti;
2434 
2435     /* Check interface assumptions */
2436 
2437     if (klass == NULL) {
2438         return AGENT_ERROR_INVALID_OBJECT;
2439     }
2440 
2441     if ( maxInstances &lt; 0 || instances == NULL) {
2442         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2443     }
2444 
2445     /* Initialize return information */
2446     instances-&gt;count   = 0;
2447     instances-&gt;objects = NULL;
2448 
2449     /* Get jvmti environment to use */
2450     jvmti = getSpecialJvmti();
2451     if ( jvmti == NULL ) {
2452         return AGENT_ERROR_INTERNAL;
2453     }
2454 
2455     /* Setup data to passed around the callbacks */
2456     data.instCount    = 0;
2457     data.maxInstances = maxInstances;
2458     data.objTag       = (jlong)1;
2459     data.error        = JVMTI_ERROR_NONE;
2460 
2461     /* Clear out callbacks structure */
2462     (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2463 
2464     /* Set the callbacks we want */
2465     heap_callbacks.heap_reference_callback = &amp;cbObjectTagInstance;
2466 
2467     /* Follow references, no initiating object, just this class, all objects */
2468     error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2469                  (jvmti, 0, klass, NULL, &amp;heap_callbacks, &amp;data);
2470     if ( error == JVMTI_ERROR_NONE ) {
2471         error = data.error;
2472     }
2473 
2474     /* Get all the instances now that they are tagged */
2475     if ( error == JVMTI_ERROR_NONE ) {
2476         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2477                       (jvmti, 1, &amp;(data.objTag), &amp;(instances-&gt;count),
2478                        &amp;(instances-&gt;objects), NULL);
2479         /* Verify we got the count we expected */
2480         if ( data.instCount != instances-&gt;count ) {
2481             error = AGENT_ERROR_INTERNAL;
2482         }
2483     }
2484 
2485     /* Dispose of any special jvmti environment */
2486     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2487     return error;
2488 }
2489 
2490 /* ********************************************************************* */
2491 /* Instance counts. */
2492 
2493 /* Macros to convert a class or instance tag to an index and back again */
2494 #define INDEX2CLASSTAG(i)      ((jlong)((i)+1))
2495 #define CLASSTAG2INDEX(t)      (((int)(t))-1)
2496 #define JLONG_ABS(x)           (((x)&lt;(jlong)0)?-(x):(x))
2497 
2498 /* Structure to hold class count heap traversal data (arg user_data) */
2499 typedef struct ClassCountData {
2500     int          classCount;
2501     jlong       *counts;
2502     jlong        negObjTag;
2503     jvmtiError   error;
2504 } ClassCountData;
2505 
2506 /* Two different cbObjectCounter&#39;s, one for FollowReferences, one for
2507  *    IterateThroughHeap. Pick a card, any card.
2508  */
2509 
2510 /* Callback for object count heap traversal (heap_reference_callback) */
2511 static jint JNICALL
2512 cbObjectCounterFromRef(jvmtiHeapReferenceKind reference_kind,
2513      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2514      jlong referrer_class_tag, jlong size,
2515      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2516 {
2517     ClassCountData  *data;
2518     int              index;
2519     jlong            jindex;
2520     jlong            tag;
2521 
2522     /* Check data structure */
2523     data = (ClassCountData*)user_data;
2524     if (data == NULL) {
2525         return JVMTI_VISIT_ABORT;
2526     }
2527 
2528     /* Classes with no class_tag should have been filtered out. */
2529     if ( class_tag == (jlong)0 ) {
2530         data-&gt;error = AGENT_ERROR_INTERNAL;
2531         return JVMTI_VISIT_ABORT;
2532     }
2533 
2534     /* Class tag not one we really want (jclass not in supplied list) */
2535     if ( class_tag == data-&gt;negObjTag ) {
2536         return JVMTI_VISIT_OBJECTS;
2537     }
2538 
2539     /* If object tag is negative, just continue, we counted it */
2540     tag = (*tag_ptr);
2541     if ( tag &lt; (jlong)0 ) {
2542         return JVMTI_VISIT_OBJECTS;
2543     }
2544 
2545     /* Tag the object with a negative value just so we don&#39;t count it again */
2546     if ( tag == (jlong)0 ) {
2547         /* This object had no tag value, so we give it the negObjTag value */
2548         (*tag_ptr) = data-&gt;negObjTag;
2549     } else {
2550         /* If this object had a positive tag value, it must be one of the
2551          *    jclass objects we tagged. We need to preserve the value of
2552          *    this tag for later objects that might have this as a class
2553          *    tag, so we just make the existing tag value negative.
2554          */
2555         (*tag_ptr) = -tag;
2556     }
2557 
2558     /* Absolute value of class tag is an index into the counts[] array */
2559     jindex = JLONG_ABS(class_tag);
2560     index = CLASSTAG2INDEX(jindex);
2561     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2562         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2563         return JVMTI_VISIT_ABORT;
2564     }
2565 
2566     /* Bump instance count on this class */
2567     data-&gt;counts[index]++;
2568     return JVMTI_VISIT_OBJECTS;
2569 }
2570 
2571 /* Callback for instance count heap traversal (heap_iteration_callback) */
2572 static jint JNICALL
2573 cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,
2574                         void* user_data)
2575 {
2576     ClassCountData  *data;
2577     int              index;
2578 
2579     /* Check data structure */
2580     data = (ClassCountData*)user_data;
2581     if (data == NULL) {
2582         return JVMTI_VISIT_ABORT;
2583     }
2584 
2585     /* Classes with no tag should be filtered out. */
2586     if ( class_tag == (jlong)0 ) {
2587         data-&gt;error = AGENT_ERROR_INTERNAL;
2588         return JVMTI_VISIT_ABORT;
2589     }
2590 
2591     /* Class tag is actually an index into data arrays */
2592     index = CLASSTAG2INDEX(class_tag);
2593     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2594         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2595         return JVMTI_VISIT_ABORT;
2596     }
2597 
2598     /* Bump instance count on this class */
2599     data-&gt;counts[index]++;
2600     return JVMTI_VISIT_OBJECTS;
2601 }
2602 
2603 /* Get instance counts for a set of classes */
2604 jvmtiError
2605 classInstanceCounts(jint classCount, jclass *classes, jlong *counts)
2606 {
2607     jvmtiHeapCallbacks heap_callbacks;
2608     ClassCountData     data;
2609     jvmtiError         error;
2610     jvmtiEnv          *jvmti;
2611     int                i;
2612 
2613     /* Check interface assumptions */
2614     if ( classes == NULL || classCount &lt;= 0 || counts == NULL ) {
2615         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2616     }
2617 
2618     /* Initialize return information */
2619     for ( i = 0 ; i &lt; classCount ; i++ ) {
2620         counts[i] = (jlong)0;
2621     }
2622 
2623     /* Get jvmti environment to use */
2624     jvmti = getSpecialJvmti();
2625     if ( jvmti == NULL ) {
2626         return AGENT_ERROR_INTERNAL;
2627     }
2628 
2629     /* Setup class data structure */
2630     data.error        = JVMTI_ERROR_NONE;
2631     data.classCount   = classCount;
2632     data.counts       = counts;
2633 
2634     error = JVMTI_ERROR_NONE;
2635     /* Set tags on classes, use index in classes[] as the tag value. */
2636     error             = JVMTI_ERROR_NONE;
2637     for ( i = 0 ; i &lt; classCount ; i++ ) {
2638         if (classes[i] != NULL) {
2639             jlong tag;
2640 
2641             tag = INDEX2CLASSTAG(i);
2642             error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, classes[i], tag);
2643             if ( error != JVMTI_ERROR_NONE ) {
2644                 break;
2645             }
2646         }
2647     }
2648 
2649     /* Traverse heap, two ways to do this for instance counts. */
2650     if ( error == JVMTI_ERROR_NONE ) {
2651 
2652         /* Clear out callbacks structure */
2653         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2654 
2655         /* Check debug flags to see how to do this. */
2656         if ( (gdata-&gt;debugflags &amp; USE_ITERATE_THROUGH_HEAP) == 0 ) {
2657 
2658             /* Using FollowReferences only gives us live objects, but we
2659              *   need to tag the objects to avoid counting them twice since
2660              *   the callback is per reference.
2661              *   The jclass objects have been tagged with their index in the
2662              *   supplied list, and that tag may flip to negative if it
2663              *   is also an object of interest.
2664              *   All other objects being counted that weren&#39;t in the
2665              *   supplied classes list will have a negative classCount
2666              *   tag value. So all objects counted will have negative tags.
2667              *   If the absolute tag value is an index in the supplied
2668              *   list, then it&#39;s one of the supplied classes.
2669              */
2670             data.negObjTag = -INDEX2CLASSTAG(classCount);
2671 
2672             /* Setup callbacks, only using object reference callback */
2673             heap_callbacks.heap_reference_callback = &amp;cbObjectCounterFromRef;
2674 
2675             /* Follow references, no initiating object, tagged classes only */
2676             error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2677                           (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2678                            NULL, NULL, &amp;heap_callbacks, &amp;data);
2679 
2680         } else {
2681 
2682             /* Using IterateThroughHeap means that we will visit each object
2683              *   once, so no special tag tricks here. Just simple counting.
2684              *   However in this case the object might not be live, so we do
2685              *   a GC beforehand to make sure we minimize this.
2686              */
2687 
2688             /* FIXUP: Need some kind of trigger here to avoid excessive GC&#39;s? */
2689             error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);
2690             if ( error != JVMTI_ERROR_NONE ) {
2691 
2692                 /* Setup callbacks, just need object callback */
2693                 heap_callbacks.heap_iteration_callback = &amp;cbObjectCounter;
2694 
2695                 /* Iterate through entire heap, tagged classes only */
2696                 error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)
2697                               (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2698                                NULL, &amp;heap_callbacks, &amp;data);
2699 
2700             }
2701         }
2702 
2703         /* Use data error if needed */
2704         if ( error == JVMTI_ERROR_NONE ) {
2705             error = data.error;
2706         }
2707 
2708     }
2709 
2710     /* Dispose of any special jvmti environment */
2711     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2712     return error;
2713 }
2714 
2715 /* ********************************************************************* */
2716 /* Referrers */
2717 
2718 /* Structure to hold object referrer heap traversal data (arg user_data) */
2719 typedef struct ReferrerData {
2720   int        refCount;
2721   int        maxObjects;
2722   jlong      refTag;
2723   jlong      objTag;
2724   jboolean   selfRef;
2725   jvmtiError error;
2726 } ReferrerData;
2727 
2728 /* Callback for referrers object tagging (heap_reference_callback). */
2729 static jint JNICALL
2730 cbObjectTagReferrer(jvmtiHeapReferenceKind reference_kind,
2731      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2732      jlong referrer_class_tag, jlong size,
2733      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2734 {
2735     ReferrerData  *data;
2736 
2737     /* Check data structure */
2738     data = (ReferrerData*)user_data;
2739     if (data == NULL) {
2740         return JVMTI_VISIT_ABORT;
2741     }
2742 
2743     /* If we have tagged enough objects, just abort */
2744     if ( data-&gt;maxObjects != 0 &amp;&amp; data-&gt;refCount &gt;= data-&gt;maxObjects ) {
2745         return JVMTI_VISIT_ABORT;
2746     }
2747 
2748     /* If not of interest, just continue */
2749     if ( (*tag_ptr) != data-&gt;objTag ) {
2750         return JVMTI_VISIT_OBJECTS;
2751     }
2752 
2753     /* Self reference that we haven&#39;t counted? */
2754     if ( tag_ptr == referrer_tag_ptr ) {
2755         if ( data-&gt;selfRef == JNI_FALSE ) {
2756             data-&gt;selfRef = JNI_TRUE;
2757             data-&gt;refCount++;
2758         }
2759         return JVMTI_VISIT_OBJECTS;
2760     }
2761 
2762     /* If the referrer can be tagged, and hasn&#39;t been tagged, tag it */
2763     if ( referrer_tag_ptr != NULL ) {
2764         if ( (*referrer_tag_ptr) == (jlong)0 ) {
2765             *referrer_tag_ptr = data-&gt;refTag;
2766             data-&gt;refCount++;
2767         }
2768     }
2769     return JVMTI_VISIT_OBJECTS;
2770 }
2771 
2772 /* Heap traversal to find referrers of an object */
2773 jvmtiError
2774 objectReferrers(jobject obj, ObjectBatch *referrers, int maxObjects)
2775 {
2776     jvmtiHeapCallbacks heap_callbacks;
2777     ReferrerData       data;
2778     jvmtiError         error;
2779     jvmtiEnv          *jvmti;
2780 
2781     /* Check interface assumptions */
2782     if (obj == NULL) {
2783         return AGENT_ERROR_INVALID_OBJECT;
2784     }
2785     if (referrers == NULL || maxObjects &lt; 0 ) {
2786         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2787     }
2788 
2789     /* Initialize return information */
2790     referrers-&gt;count = 0;
2791     referrers-&gt;objects = NULL;
2792 
2793     /* Get jvmti environment to use */
2794     jvmti = getSpecialJvmti();
2795     if ( jvmti == NULL ) {
2796         return AGENT_ERROR_INTERNAL;
2797     }
2798 
2799     /* Fill in the data structure passed around the callbacks */
2800     data.refCount   = 0;
2801     data.maxObjects = maxObjects;
2802     data.objTag     = (jlong)1;
2803     data.refTag     = (jlong)2;
2804     data.selfRef    = JNI_FALSE;
2805     data.error      = JVMTI_ERROR_NONE;
2806 
2807     /* Tag the object of interest */
2808     error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.objTag);
2809 
2810     /* No need to go any further if we can&#39;t tag the object */
2811     if ( error == JVMTI_ERROR_NONE ) {
2812 
2813         /* Clear out callbacks structure */
2814         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2815 
2816         /* Setup callbacks we want */
2817         heap_callbacks.heap_reference_callback = &amp;cbObjectTagReferrer;
2818 
2819         /* Follow references, no initiating object, all classes, 1 tagged objs */
2820         error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2821                       (jvmti, JVMTI_HEAP_FILTER_UNTAGGED,
2822                        NULL, NULL, &amp;heap_callbacks, &amp;data);
2823 
2824         /* Use data error if needed */
2825         if ( error == JVMTI_ERROR_NONE ) {
2826             error = data.error;
2827         }
2828 
2829     }
2830 
2831     /* Watch out for self-reference */
2832     if ( error == JVMTI_ERROR_NONE &amp;&amp; data.selfRef == JNI_TRUE ) {
2833         /* Tag itself as a referer */
2834         error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.refTag);
2835     }
2836 
2837     /* Get the jobjects for the tagged referrer objects.  */
2838     if ( error == JVMTI_ERROR_NONE ) {
2839         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2840                     (jvmti, 1, &amp;(data.refTag), &amp;(referrers-&gt;count),
2841                           &amp;(referrers-&gt;objects), NULL);
2842         /* Verify we got the count we expected */
2843         if ( data.refCount != referrers-&gt;count ) {
2844             error = AGENT_ERROR_INTERNAL;
2845         }
2846     }
2847 
2848     /* Dispose of any special jvmti environment */
2849     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2850     return error;
2851 }
    </pre>
  </body>
</html>
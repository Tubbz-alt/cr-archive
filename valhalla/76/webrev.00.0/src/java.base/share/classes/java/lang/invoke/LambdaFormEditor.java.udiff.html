<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -60,48 +60,182 @@</span>
          // Always use uncustomized version for editing.
          // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
          return new LambdaFormEditor(lambdaForm.uncustomize());
      }
  
<span class="udiff-line-modified-removed">-     /** A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="udiff-line-modified-removed">-      *  The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="udiff-line-modified-removed">-      *  The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="udiff-line-modified-removed">-      *  Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
<span class="udiff-line-modified-added">+     // Transform types</span>
<span class="udiff-line-modified-added">+     // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="udiff-line-modified-added">+     private static final byte</span>
<span class="udiff-line-modified-added">+             BIND_ARG = 1,</span>
<span class="udiff-line-added">+             ADD_ARG = 2,</span>
<span class="udiff-line-added">+             DUP_ARG = 3,</span>
<span class="udiff-line-added">+             SPREAD_ARGS = 4,</span>
<span class="udiff-line-added">+             FILTER_ARG = 5,</span>
<span class="udiff-line-added">+             FILTER_RETURN = 6,</span>
<span class="udiff-line-added">+             FILTER_RETURN_TO_ZERO = 7,</span>
<span class="udiff-line-added">+             COLLECT_ARGS = 8,</span>
<span class="udiff-line-added">+             COLLECT_ARGS_TO_VOID = 9,</span>
<span class="udiff-line-added">+             COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="udiff-line-added">+             FOLD_ARGS = 11,</span>
<span class="udiff-line-added">+             FOLD_ARGS_TO_VOID = 12,</span>
<span class="udiff-line-added">+             PERMUTE_ARGS = 13,</span>
<span class="udiff-line-added">+             LOCAL_TYPES = 14,</span>
<span class="udiff-line-added">+             FOLD_SELECT_ARGS = 15,</span>
<span class="udiff-line-added">+             FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="udiff-line-added">+             FILTER_SELECT_ARGS = 17,</span>
<span class="udiff-line-added">+             REPEAT_FILTER_ARGS = 18;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="udiff-line-added">+      * The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="udiff-line-added">+      * The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="udiff-line-added">+      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Tightly coupled with the TransformKey class, which is used to lookup existing</span>
<span class="udiff-line-added">+      * Transforms.</span>
       */
      private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
          final long packedBytes;
          final byte[] fullBytes;
  
<span class="udiff-line-modified-removed">-         // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="udiff-line-modified-removed">-         private static final byte</span>
<span class="udiff-line-modified-removed">-                 BIND_ARG = 1,</span>
<span class="udiff-line-modified-removed">-                 ADD_ARG = 2,</span>
<span class="udiff-line-modified-removed">-                 DUP_ARG = 3,</span>
<span class="udiff-line-modified-removed">-                 SPREAD_ARGS = 4,</span>
<span class="udiff-line-modified-removed">-                 FILTER_ARG = 5,</span>
<span class="udiff-line-modified-removed">-                 FILTER_RETURN = 6,</span>
<span class="udiff-line-modified-removed">-                 FILTER_RETURN_TO_ZERO = 7,</span>
<span class="udiff-line-modified-removed">-                 COLLECT_ARGS = 8,</span>
<span class="udiff-line-modified-removed">-                 COLLECT_ARGS_TO_VOID = 9,</span>
<span class="udiff-line-modified-removed">-                 COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="udiff-line-modified-removed">-                 FOLD_ARGS = 11,</span>
<span class="udiff-line-modified-removed">-                 FOLD_ARGS_TO_VOID = 12,</span>
<span class="udiff-line-modified-removed">-                 PERMUTE_ARGS = 13,</span>
<span class="udiff-line-modified-removed">-                 LOCAL_TYPES = 14,</span>
<span class="udiff-line-modified-removed">-                 FOLD_SELECT_ARGS = 15,</span>
<span class="udiff-line-modified-removed">-                 FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="udiff-line-modified-removed">-                 FILTER_SELECT_ARGS = 17,</span>
<span class="udiff-line-modified-removed">-                 REPEAT_FILTER_ARGS = 18;</span>
<span class="udiff-line-modified-added">+         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="udiff-line-modified-added">+             super(result);</span>
<span class="udiff-line-modified-added">+             this.packedBytes = packedBytes;</span>
<span class="udiff-line-modified-added">+             this.fullBytes = fullBytes;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-modified-added">+         public boolean equals(Object obj) {</span>
<span class="udiff-line-modified-added">+             if (obj instanceof TransformKey) {</span>
<span class="udiff-line-modified-added">+                 return equals((TransformKey) obj);</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         private boolean equals(TransformKey that) {</span>
<span class="udiff-line-modified-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         private boolean equals(Transform that) {</span>
<span class="udiff-line-modified-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int hashCode() {</span>
<span class="udiff-line-added">+             if (packedBytes != 0) {</span>
<span class="udiff-line-added">+                 assert(fullBytes == null);</span>
<span class="udiff-line-added">+                 return Long.hashCode(packedBytes);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return Arrays.hashCode(fullBytes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             StringBuilder buf = new StringBuilder();</span>
<span class="udiff-line-added">+             buf.append(new TransformKey(packedBytes, fullBytes).toString());</span>
<span class="udiff-line-added">+             LambdaForm result = get();</span>
<span class="udiff-line-added">+             if (result != null) {</span>
<span class="udiff-line-added">+                 buf.append(&quot; result=&quot;);</span>
<span class="udiff-line-added">+                 buf.append(result);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return buf.toString();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Used as a lookup key to find existing Transforms</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private static final class TransformKey {</span>
<span class="udiff-line-added">+         final long packedBytes;</span>
<span class="udiff-line-added">+         final byte[] fullBytes;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private TransformKey(long packedBytes) {</span>
<span class="udiff-line-added">+             this.packedBytes = packedBytes;</span>
<span class="udiff-line-added">+             this.fullBytes = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private TransformKey(byte[] fullBytes) {</span>
<span class="udiff-line-added">+             this.fullBytes = fullBytes;</span>
<span class="udiff-line-added">+             this.packedBytes = 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private TransformKey(long packedBytes, byte[] fullBytes) {</span>
<span class="udiff-line-added">+             this.fullBytes = fullBytes;</span>
<span class="udiff-line-added">+             this.packedBytes = packedBytes;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private static byte bval(int b) {</span>
<span class="udiff-line-added">+             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="udiff-line-added">+             return (byte)b;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         static TransformKey of(byte k, int b1) {</span>
<span class="udiff-line-added">+             byte b0 = bval(k);</span>
<span class="udiff-line-added">+             if (inRange(b0 | b1))</span>
<span class="udiff-line-added">+                 return new TransformKey(packedBytes(b0, b1));</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 return new TransformKey(fullBytes(b0, b1));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         static TransformKey of(byte b0, int b1, int b2) {</span>
<span class="udiff-line-added">+             if (inRange(b0 | b1 | b2))</span>
<span class="udiff-line-added">+                 return new TransformKey(packedBytes(b0, b1, b2));</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 return new TransformKey(fullBytes(b0, b1, b2));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         static TransformKey of(byte b0, int b1, int b2, int b3) {</span>
<span class="udiff-line-added">+             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="udiff-line-added">+                 return new TransformKey(packedBytes(b0, b1, b2, b3));</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 return new TransformKey(fullBytes(b0, b1, b2, b3));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         private static final byte[] NO_BYTES = {};</span>
<span class="udiff-line-added">+         static TransformKey of(byte kind, int... b123) {</span>
<span class="udiff-line-added">+             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static TransformKey of(byte kind, int b1, int[] b23456) {</span>
<span class="udiff-line-added">+             byte[] fullBytes = new byte[b23456.length + 2];</span>
<span class="udiff-line-added">+             fullBytes[0] = kind;</span>
<span class="udiff-line-added">+             fullBytes[1] = bval(b1);</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; b23456.length; i++) {</span>
<span class="udiff-line-added">+                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             long packedBytes = packedBytes(fullBytes);</span>
<span class="udiff-line-added">+             if (packedBytes != 0)</span>
<span class="udiff-line-added">+                 return new TransformKey(packedBytes);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 return new TransformKey(fullBytes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="udiff-line-added">+             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="udiff-line-added">+             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="udiff-line-added">+             int i = 0;</span>
<span class="udiff-line-added">+             fullBytes[i++] = bval(kind);</span>
<span class="udiff-line-added">+             for (int bv : b123) {</span>
<span class="udiff-line-added">+                 fullBytes[i++] = bval(bv);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (byte bv : b456) {</span>
<span class="udiff-line-added">+                 fullBytes[i++] = bv;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             long packedBytes = packedBytes(fullBytes);</span>
<span class="udiff-line-added">+             if (packedBytes != 0)</span>
<span class="udiff-line-added">+                 return new TransformKey(packedBytes);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 return new TransformKey(fullBytes);</span>
<span class="udiff-line-added">+         }</span>
  
          private static final boolean STRESS_TEST = false; // turn on to disable most packing
          private static final int
                  PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
                  PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
                  PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
  
          private static long packedBytes(byte[] bytes) {
<span class="udiff-line-modified-removed">-             if (bytes.length &gt; PACKED_BYTE_MAX_LENGTH)  return 0;</span>
<span class="udiff-line-modified-added">+             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)</span>
<span class="udiff-line-added">+                 return 0;</span>
              long pb = 0;
              int bitset = 0;
              for (int i = 0; i &lt; bytes.length; i++) {
                  int b = bytes[i] &amp; 0xFF;
                  bitset |= b;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141,92 +275,14 @@</span>
              }
              assert(packedBytes(bytes) == 0);
              return bytes;
          }
  
<span class="udiff-line-removed">-         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="udiff-line-removed">-             super(result);</span>
<span class="udiff-line-removed">-             this.packedBytes = packedBytes;</span>
<span class="udiff-line-removed">-             this.fullBytes = fullBytes;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private Transform(long packedBytes) {</span>
<span class="udiff-line-removed">-             this(packedBytes, null, null);</span>
<span class="udiff-line-removed">-             assert(packedBytes != 0);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private Transform(byte[] fullBytes) {</span>
<span class="udiff-line-removed">-             this(0, fullBytes, null);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static byte bval(int b) {</span>
<span class="udiff-line-removed">-             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="udiff-line-removed">-             return (byte)b;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static Transform of(byte k, int b1) {</span>
<span class="udiff-line-removed">-             byte b0 = bval(k);</span>
<span class="udiff-line-removed">-             if (inRange(b0 | b1))</span>
<span class="udiff-line-removed">-                 return new Transform(packedBytes(b0, b1));</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 return new Transform(fullBytes(b0, b1));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static Transform of(byte b0, int b1, int b2) {</span>
<span class="udiff-line-removed">-             if (inRange(b0 | b1 | b2))</span>
<span class="udiff-line-removed">-                 return new Transform(packedBytes(b0, b1, b2));</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 return new Transform(fullBytes(b0, b1, b2));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static Transform of(byte b0, int b1, int b2, int b3) {</span>
<span class="udiff-line-removed">-             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="udiff-line-removed">-                 return new Transform(packedBytes(b0, b1, b2, b3));</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 return new Transform(fullBytes(b0, b1, b2, b3));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private static final byte[] NO_BYTES = {};</span>
<span class="udiff-line-removed">-         static Transform of(byte kind, int... b123) {</span>
<span class="udiff-line-removed">-             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static Transform of(byte kind, int b1, byte[] b234) {</span>
<span class="udiff-line-removed">-             return ofBothArrays(kind, new int[]{ b1 }, b234);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         static Transform of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="udiff-line-removed">-             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         private static Transform ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="udiff-line-removed">-             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="udiff-line-removed">-             int i = 0;</span>
<span class="udiff-line-removed">-             fullBytes[i++] = bval(kind);</span>
<span class="udiff-line-removed">-             for (int bv : b123) {</span>
<span class="udiff-line-removed">-                 fullBytes[i++] = bval(bv);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             for (byte bv : b456) {</span>
<span class="udiff-line-removed">-                 fullBytes[i++] = bv;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             long packedBytes = packedBytes(fullBytes);</span>
<span class="udiff-line-removed">-             if (packedBytes != 0)</span>
<span class="udiff-line-removed">-                 return new Transform(packedBytes);</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 return new Transform(fullBytes);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          Transform withResult(LambdaForm result) {
              return new Transform(this.packedBytes, this.fullBytes, result);
          }
  
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public boolean equals(Object obj) {</span>
<span class="udiff-line-removed">-             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         public boolean equals(Transform that) {</span>
<span class="udiff-line-removed">-             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public int hashCode() {</span>
<span class="udiff-line-removed">-             if (packedBytes != 0) {</span>
<span class="udiff-line-removed">-                 assert(fullBytes == null);</span>
<span class="udiff-line-removed">-                 return Long.hashCode(packedBytes);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return Arrays.hashCode(fullBytes);</span>
<span class="udiff-line-removed">-         }</span>
          @Override
          public String toString() {
              StringBuilder buf = new StringBuilder();
              long bits = packedBytes;
              if (bits != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -240,22 +296,41 @@</span>
              }
              if (fullBytes != null) {
                  buf.append(&quot;unpacked&quot;);
                  buf.append(Arrays.toString(fullBytes));
              }
<span class="udiff-line-removed">-             LambdaForm result = get();</span>
<span class="udiff-line-removed">-             if (result != null) {</span>
<span class="udiff-line-removed">-                 buf.append(&quot; result=&quot;);</span>
<span class="udiff-line-removed">-                 buf.append(result);</span>
<span class="udiff-line-removed">-             }</span>
              return buf.toString();
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean equals(Object obj) {</span>
<span class="udiff-line-added">+             if (obj instanceof TransformKey) {</span>
<span class="udiff-line-added">+                 return equals((TransformKey) obj);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private boolean equals(TransformKey that) {</span>
<span class="udiff-line-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private boolean equals(Transform that) {</span>
<span class="udiff-line-added">+             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int hashCode() {</span>
<span class="udiff-line-added">+             if (packedBytes != 0) {</span>
<span class="udiff-line-added">+                 assert(fullBytes == null);</span>
<span class="udiff-line-added">+                 return Long.hashCode(packedBytes);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return Arrays.hashCode(fullBytes);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="udiff-line-modified-removed">-     private LambdaForm getInCache(Transform key) {</span>
<span class="udiff-line-removed">-         assert(key.get() == null);</span>
<span class="udiff-line-modified-added">+     private LambdaForm getInCache(TransformKey key) {</span>
          // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
          Object c = lambdaForm.transformCache;
          Transform k = null;
          if (c instanceof ConcurrentHashMap) {
              @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -283,24 +358,24 @@</span>
      private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
  
      /** Cache a transform with its result, and return that result.
       *  But if an equivalent transform has already been cached, return its result instead.
       */
<span class="udiff-line-modified-removed">-     private LambdaForm putInCache(Transform key, LambdaForm form) {</span>
<span class="udiff-line-modified-removed">-         key = key.withResult(form);</span>
<span class="udiff-line-modified-added">+     private LambdaForm putInCache(TransformKey key, LambdaForm form) {</span>
<span class="udiff-line-modified-added">+         Transform transform = key.withResult(form);</span>
          for (int pass = 0; ; pass++) {
              Object c = lambdaForm.transformCache;
              if (c instanceof ConcurrentHashMap) {
                  @SuppressWarnings(&quot;unchecked&quot;)
                  ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="udiff-line-modified-removed">-                 Transform k = m.putIfAbsent(key, key);</span>
<span class="udiff-line-modified-added">+                 Transform k = m.putIfAbsent(transform, transform);</span>
                  if (k == null) return form;
                  LambdaForm result = k.get();
                  if (result != null) {
                      return result;
                  } else {
<span class="udiff-line-modified-removed">-                     if (m.replace(key, k, key)) {</span>
<span class="udiff-line-modified-added">+                     if (m.replace(transform, k, transform)) {</span>
                          return form;
                      } else {
                          continue;
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,26 +384,26 @@</span>
              synchronized (lambdaForm) {
                  c = lambdaForm.transformCache;
                  if (c instanceof ConcurrentHashMap)
                      continue;
                  if (c == null) {
<span class="udiff-line-modified-removed">-                     lambdaForm.transformCache = key;</span>
<span class="udiff-line-modified-added">+                     lambdaForm.transformCache = transform;</span>
                      return form;
                  }
                  Transform[] ta;
                  if (c instanceof Transform) {
                      Transform k = (Transform)c;
                      if (k.equals(key)) {
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="udiff-line-modified-removed">-                             lambdaForm.transformCache = key;</span>
<span class="udiff-line-modified-added">+                             lambdaForm.transformCache = transform;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (k.get() == null) { // overwrite stale entry
<span class="udiff-line-modified-removed">-                         lambdaForm.transformCache = key;</span>
<span class="udiff-line-modified-added">+                         lambdaForm.transformCache = transform;</span>
                          return form;
                      }
                      // expand one-element cache to small array
                      ta = new Transform[MIN_CACHE_ARRAY_SIZE];
                      ta[0] = k;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -343,14 +418,14 @@</span>
                  for (i = 0; i &lt; len; i++) {
                      Transform k = ta[i];
                      if (k == null) {
                          break;
                      }
<span class="udiff-line-modified-removed">-                     if (k.equals(key)) {</span>
<span class="udiff-line-modified-added">+                     if (k.equals(transform)) {</span>
                          LambdaForm result = k.get();
                          if (result == null) {
<span class="udiff-line-modified-removed">-                             ta[i] = key;</span>
<span class="udiff-line-modified-added">+                             ta[i] = transform;</span>
                              return form;
                          } else {
                              return result;
                          }
                      } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,11 +446,11 @@</span>
                      lambdaForm.transformCache = m;
                      // The second iteration will update for this query, concurrently.
                      continue;
                  }
                  int idx = (stale &gt;= 0) ? stale : i;
<span class="udiff-line-modified-removed">-                 ta[idx] = key;</span>
<span class="udiff-line-modified-added">+                 ta[idx] = transform;</span>
                  return form;
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -441,11 +516,11 @@</span>
  
      /// Editing methods for lambda forms.
      // Each editing method can (potentially) cache the edited LF so that it can be reused later.
  
      LambdaForm bindArgumentForm(int pos) {
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.BIND_ARG, pos);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(BIND_ARG, pos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,11 +551,11 @@</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.ADD_ARG, pos, type.ordinal());</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity+1);
              assert(form.parameterType(pos) == type);
              return form;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -493,11 +568,11 @@</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.DUP_ARG, srcPos, dstPos);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity-1);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -522,11 +597,11 @@</span>
          if (bt.basicTypeClass() != elementType) {
              if (elementType.isPrimitive()) {
                  elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
              }
          }
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - arrayLength + 1);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,16 +636,14 @@</span>
          int collectorArity = collectorType.parameterCount();
          boolean dropResult = (collectorType.returnType() == void.class);
          if (collectorArity == 1 &amp;&amp; !dropResult) {
              return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
          }
<span class="udiff-line-modified-removed">-         byte[] newTypes = BasicType.basicTypesOrd(collectorType.parameterArray());</span>
<span class="udiff-line-modified-removed">-         byte kind = (dropResult</span>
<span class="udiff-line-removed">-                 ? Transform.COLLECT_ARGS_TO_VOID</span>
<span class="udiff-line-removed">-                 : Transform.COLLECT_ARGS);</span>
<span class="udiff-line-modified-added">+         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());</span>
<span class="udiff-line-modified-added">+         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);</span>
          if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(kind, pos, collectorArity, newTypes);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -591,12 +664,12 @@</span>
              if (!elementType.isPrimitive())
                  return null;
              argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
          }
          assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="udiff-line-modified-removed">-         byte kind = Transform.COLLECT_ARGS_TO_ARRAY;</span>
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(kind, pos, collectorArity, argTypeKey);</span>
<span class="udiff-line-modified-added">+         byte kind = COLLECT_ARGS_TO_ARRAY;</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity - 1 + collectorArity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -628,11 +701,11 @@</span>
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.FILTER_ARG, pos, newType.ordinal());</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.parameterType(pos) == newType);
              return form;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -652,17 +725,11 @@</span>
       * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
       * no worse in the worst case.
       */
      LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
          assert (argPositions.length &gt; 1);
<span class="udiff-line-modified-removed">-         byte[] keyArgs = new byte[argPositions.length + 2];</span>
<span class="udiff-line-removed">-         keyArgs[0] = Transform.REPEAT_FILTER_ARGS;</span>
<span class="udiff-line-removed">-         keyArgs[argPositions.length + 1] = (byte)newType.ordinal();</span>
<span class="udiff-line-removed">-         for (int i = 0; i &lt; argPositions.length; i++) {</span>
<span class="udiff-line-removed">-             keyArgs[i + 1] = (byte)argPositions[i];</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         Transform key = new Transform(keyArgs);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity &amp;&amp;
                      formParametersMatch(form, newType, argPositions));
              return form;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -871,12 +938,12 @@</span>
  
          return buf.endEdit();
      }
  
      LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="udiff-line-modified-removed">-         byte kind = (constantZero ? Transform.FILTER_RETURN_TO_ZERO : Transform.FILTER_RETURN);</span>
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(kind, newType.ordinal());</span>
<span class="udiff-line-modified-added">+         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(kind, newType.ordinal());</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              assert(form.returnType() == newType);
              return form;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -921,43 +988,88 @@</span>
  
          form = buf.endEdit();
          return putInCache(key, form);
      }
  
<span class="udiff-line-added">+     LambdaForm collectReturnValueForm(MethodType combinerType) {</span>
<span class="udiff-line-added">+         LambdaFormBuffer buf = buffer();</span>
<span class="udiff-line-added">+         buf.startEdit();</span>
<span class="udiff-line-added">+         int combinerArity = combinerType.parameterCount();</span>
<span class="udiff-line-added">+         int argPos = lambdaForm.arity();</span>
<span class="udiff-line-added">+         int exprPos = lambdaForm.names.length;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();</span>
<span class="udiff-line-added">+         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // The newly created LF will run with a different BMH.</span>
<span class="udiff-line-added">+         // Switch over any pre-existing BMH field references to the new BMH class.</span>
<span class="udiff-line-added">+         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values</span>
<span class="udiff-line-added">+         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);</span>
<span class="udiff-line-added">+         Name newBaseAddress = oldBaseAddress.withConstraint(newData);</span>
<span class="udiff-line-added">+         buf.renameParameter(0, newBaseAddress);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Now we set up the call to the filter</span>
<span class="udiff-line-added">+         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Object[] combinerArgs = new Object[combinerArity + 1];</span>
<span class="udiff-line-added">+         combinerArgs[0] = getCombiner; // first (synthetic) argument should be the MH that acts as a target of the invoke</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // set up additional adapter parameters (in case the combiner is not a unary function)</span>
<span class="udiff-line-added">+         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; newParams.length; i++) {</span>
<span class="udiff-line-added">+             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // set up remaining filter parameters to point to the corresponding adapter parameters (see above)</span>
<span class="udiff-line-added">+         System.arraycopy(newParams, 0,</span>
<span class="udiff-line-added">+                 combinerArgs, 1, combinerArity - 1);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // the last filter argument is set to point at the result of the target method handle</span>
<span class="udiff-line-added">+         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);</span>
<span class="udiff-line-added">+         Name callCombiner = new Name(combinerType, combinerArgs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // insert the two new expressions</span>
<span class="udiff-line-added">+         buf.insertExpression(exprPos, getCombiner);</span>
<span class="udiff-line-added">+         buf.insertExpression(exprPos + 1, callCombiner);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // insert additional arguments</span>
<span class="udiff-line-added">+         int insPos = argPos;</span>
<span class="udiff-line-added">+         for (Name newParam : newParams) {</span>
<span class="udiff-line-added">+             buf.insertParameter(insPos++, newParam);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         buf.setResult(callCombiner);</span>
<span class="udiff-line-added">+         return buf.endEdit();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
          int combinerArity = combinerType.parameterCount();
<span class="udiff-line-modified-removed">-         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);</span>
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(kind, foldPos, combinerArity);</span>
<span class="udiff-line-modified-added">+         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="udiff-line-modified-removed">-             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));</span>
<span class="udiff-line-modified-added">+             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="udiff-line-modified-removed">-         byte kind = (dropResult ? Transform.FOLD_SELECT_ARGS_TO_VOID</span>
<span class="udiff-line-modified-removed">-                                 : Transform.FOLD_SELECT_ARGS);</span>
<span class="udiff-line-removed">-         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="udiff-line-removed">-         keyArgs[argPositions.length] = foldPos;</span>
<span class="udiff-line-removed">-         Transform key = Transform.of(kind, keyArgs);</span>
<span class="udiff-line-modified-added">+         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(kind, foldPos, argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
<span class="udiff-line-modified-removed">-             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_SELECT_ARGS ? 1 : 0));</span>
<span class="udiff-line-modified-added">+             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));</span>
              return form;
          }
          form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
          return putInCache(key, form);
      }
  
      LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="udiff-line-modified-removed">-         byte kind = Transform.FILTER_SELECT_ARGS;</span>
<span class="udiff-line-removed">-         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="udiff-line-removed">-         keyArgs[argPositions.length] = filterPos;</span>
<span class="udiff-line-removed">-         Transform key = Transform.of(kind, keyArgs);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == lambdaForm.arity);
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -976,11 +1088,11 @@</span>
              if (inArg != i)  nullPerm = false;
              inTypes = Math.max(inTypes, inArg+1);
          }
          assert(skip + reorder.length == lambdaForm.arity);
          if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.PERMUTE_ARGS, reorder);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              assert(form.arity == skip+inTypes) : form;
              return form;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1045,11 +1157,11 @@</span>
      LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
          assert(lambdaForm.isLoop(pos));
          int[] desc = BasicType.basicTypeOrds(localTypes);
          desc = Arrays.copyOf(desc, desc.length + 1);
          desc[desc.length - 1] = pos;
<span class="udiff-line-modified-removed">-         Transform key = Transform.of(Transform.LOCAL_TYPES, desc);</span>
<span class="udiff-line-modified-added">+         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);</span>
          LambdaForm form = getInCache(key);
          if (form != null) {
              return form;
          }
  
</pre>
<center><a href="InvokerBytecodeGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
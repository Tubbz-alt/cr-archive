<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  45  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  46  *  To support this caching, a LF has an optional pointer to its editor.
  47  */
  48 class LambdaFormEditor {
  49     final LambdaForm lambdaForm;
  50 
  51     private LambdaFormEditor(LambdaForm lambdaForm) {
  52         this.lambdaForm = lambdaForm;
  53     }
  54 
  55     // Factory method.
  56     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  57         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  58         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  59 
  60         // Always use uncustomized version for editing.
  61         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  62         return new LambdaFormEditor(lambdaForm.uncustomize());
  63     }
  64 
<span class="line-modified">  65     /** A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-modified">  66      *  The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-modified">  67      *  The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-modified">  68      *  Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>


























  69      */
  70     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  71         final long packedBytes;
  72         final byte[] fullBytes;
  73 
<span class="line-modified">  74         // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">  75         private static final byte</span>
<span class="line-modified">  76                 BIND_ARG = 1,</span>
<span class="line-modified">  77                 ADD_ARG = 2,</span>
<span class="line-modified">  78                 DUP_ARG = 3,</span>
<span class="line-modified">  79                 SPREAD_ARGS = 4,</span>
<span class="line-modified">  80                 FILTER_ARG = 5,</span>
<span class="line-modified">  81                 FILTER_RETURN = 6,</span>
<span class="line-modified">  82                 FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-modified">  83                 COLLECT_ARGS = 8,</span>
<span class="line-modified">  84                 COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-modified">  85                 COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-modified">  86                 FOLD_ARGS = 11,</span>
<span class="line-modified">  87                 FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-modified">  88                 PERMUTE_ARGS = 13,</span>
<span class="line-modified">  89                 LOCAL_TYPES = 14,</span>
<span class="line-modified">  90                 FOLD_SELECT_ARGS = 15,</span>
<span class="line-modified">  91                 FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-modified">  92                 FILTER_SELECT_ARGS = 17,</span>
<span class="line-modified">  93                 REPEAT_FILTER_ARGS = 18;</span>











































































































  94 
  95         private static final boolean STRESS_TEST = false; // turn on to disable most packing
  96         private static final int
  97                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
  98                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
  99                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 100 
 101         private static long packedBytes(byte[] bytes) {
<span class="line-modified"> 102             if (bytes.length &gt; PACKED_BYTE_MAX_LENGTH)  return 0;</span>

 103             long pb = 0;
 104             int bitset = 0;
 105             for (int i = 0; i &lt; bytes.length; i++) {
 106                 int b = bytes[i] &amp; 0xFF;
 107                 bitset |= b;
 108                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 109             }
 110             if (!inRange(bitset))
 111                 return 0;
 112             return pb;
 113         }
 114         private static long packedBytes(int b0, int b1) {
 115             assert(inRange(b0 | b1));
 116             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 117                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 118         }
 119         private static long packedBytes(int b0, int b1, int b2) {
 120             assert(inRange(b0 | b1 | b2));
 121             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 122                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
</pre>
<hr />
<pre>
 126             assert(inRange(b0 | b1 | b2 | b3));
 127             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 128                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 129                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 130                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 131         }
 132         private static boolean inRange(int bitset) {
 133             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 134             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 135         }
 136         private static byte[] fullBytes(int... byteValues) {
 137             byte[] bytes = new byte[byteValues.length];
 138             int i = 0;
 139             for (int bv : byteValues) {
 140                 bytes[i++] = bval(bv);
 141             }
 142             assert(packedBytes(bytes) == 0);
 143             return bytes;
 144         }
 145 
<span class="line-removed"> 146         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-removed"> 147             super(result);</span>
<span class="line-removed"> 148             this.packedBytes = packedBytes;</span>
<span class="line-removed"> 149             this.fullBytes = fullBytes;</span>
<span class="line-removed"> 150         }</span>
<span class="line-removed"> 151         private Transform(long packedBytes) {</span>
<span class="line-removed"> 152             this(packedBytes, null, null);</span>
<span class="line-removed"> 153             assert(packedBytes != 0);</span>
<span class="line-removed"> 154         }</span>
<span class="line-removed"> 155         private Transform(byte[] fullBytes) {</span>
<span class="line-removed"> 156             this(0, fullBytes, null);</span>
<span class="line-removed"> 157         }</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159         private static byte bval(int b) {</span>
<span class="line-removed"> 160             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-removed"> 161             return (byte)b;</span>
<span class="line-removed"> 162         }</span>
<span class="line-removed"> 163         static Transform of(byte k, int b1) {</span>
<span class="line-removed"> 164             byte b0 = bval(k);</span>
<span class="line-removed"> 165             if (inRange(b0 | b1))</span>
<span class="line-removed"> 166                 return new Transform(packedBytes(b0, b1));</span>
<span class="line-removed"> 167             else</span>
<span class="line-removed"> 168                 return new Transform(fullBytes(b0, b1));</span>
<span class="line-removed"> 169         }</span>
<span class="line-removed"> 170         static Transform of(byte b0, int b1, int b2) {</span>
<span class="line-removed"> 171             if (inRange(b0 | b1 | b2))</span>
<span class="line-removed"> 172                 return new Transform(packedBytes(b0, b1, b2));</span>
<span class="line-removed"> 173             else</span>
<span class="line-removed"> 174                 return new Transform(fullBytes(b0, b1, b2));</span>
<span class="line-removed"> 175         }</span>
<span class="line-removed"> 176         static Transform of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-removed"> 177             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-removed"> 178                 return new Transform(packedBytes(b0, b1, b2, b3));</span>
<span class="line-removed"> 179             else</span>
<span class="line-removed"> 180                 return new Transform(fullBytes(b0, b1, b2, b3));</span>
<span class="line-removed"> 181         }</span>
<span class="line-removed"> 182         private static final byte[] NO_BYTES = {};</span>
<span class="line-removed"> 183         static Transform of(byte kind, int... b123) {</span>
<span class="line-removed"> 184             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-removed"> 185         }</span>
<span class="line-removed"> 186         static Transform of(byte kind, int b1, byte[] b234) {</span>
<span class="line-removed"> 187             return ofBothArrays(kind, new int[]{ b1 }, b234);</span>
<span class="line-removed"> 188         }</span>
<span class="line-removed"> 189         static Transform of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-removed"> 190             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-removed"> 191         }</span>
<span class="line-removed"> 192         private static Transform ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-removed"> 193             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-removed"> 194             int i = 0;</span>
<span class="line-removed"> 195             fullBytes[i++] = bval(kind);</span>
<span class="line-removed"> 196             for (int bv : b123) {</span>
<span class="line-removed"> 197                 fullBytes[i++] = bval(bv);</span>
<span class="line-removed"> 198             }</span>
<span class="line-removed"> 199             for (byte bv : b456) {</span>
<span class="line-removed"> 200                 fullBytes[i++] = bv;</span>
<span class="line-removed"> 201             }</span>
<span class="line-removed"> 202             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-removed"> 203             if (packedBytes != 0)</span>
<span class="line-removed"> 204                 return new Transform(packedBytes);</span>
<span class="line-removed"> 205             else</span>
<span class="line-removed"> 206                 return new Transform(fullBytes);</span>
<span class="line-removed"> 207         }</span>
<span class="line-removed"> 208 </span>
 209         Transform withResult(LambdaForm result) {
 210             return new Transform(this.packedBytes, this.fullBytes, result);
 211         }
 212 
<span class="line-removed"> 213         @Override</span>
<span class="line-removed"> 214         public boolean equals(Object obj) {</span>
<span class="line-removed"> 215             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-removed"> 216         }</span>
<span class="line-removed"> 217         public boolean equals(Transform that) {</span>
<span class="line-removed"> 218             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-removed"> 219         }</span>
<span class="line-removed"> 220         @Override</span>
<span class="line-removed"> 221         public int hashCode() {</span>
<span class="line-removed"> 222             if (packedBytes != 0) {</span>
<span class="line-removed"> 223                 assert(fullBytes == null);</span>
<span class="line-removed"> 224                 return Long.hashCode(packedBytes);</span>
<span class="line-removed"> 225             }</span>
<span class="line-removed"> 226             return Arrays.hashCode(fullBytes);</span>
<span class="line-removed"> 227         }</span>
 228         @Override
 229         public String toString() {
 230             StringBuilder buf = new StringBuilder();
 231             long bits = packedBytes;
 232             if (bits != 0) {
 233                 buf.append(&quot;(&quot;);
 234                 while (bits != 0) {
 235                     buf.append(bits &amp; PACKED_BYTE_MASK);
 236                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 237                     if (bits != 0)  buf.append(&quot;,&quot;);
 238                 }
 239                 buf.append(&quot;)&quot;);
 240             }
 241             if (fullBytes != null) {
 242                 buf.append(&quot;unpacked&quot;);
 243                 buf.append(Arrays.toString(fullBytes));
 244             }
<span class="line-removed"> 245             LambdaForm result = get();</span>
<span class="line-removed"> 246             if (result != null) {</span>
<span class="line-removed"> 247                 buf.append(&quot; result=&quot;);</span>
<span class="line-removed"> 248                 buf.append(result);</span>
<span class="line-removed"> 249             }</span>
 250             return buf.toString();
 251         }

























 252     }
 253 
 254     /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified"> 255     private LambdaForm getInCache(Transform key) {</span>
<span class="line-removed"> 256         assert(key.get() == null);</span>
 257         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 258         Object c = lambdaForm.transformCache;
 259         Transform k = null;
 260         if (c instanceof ConcurrentHashMap) {
 261             @SuppressWarnings(&quot;unchecked&quot;)
 262             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 263             k = m.get(key);
 264         } else if (c == null) {
 265             return null;
 266         } else if (c instanceof Transform) {
 267             // one-element cache avoids overhead of an array
 268             Transform t = (Transform)c;
 269             if (t.equals(key))  k = t;
 270         } else {
 271             Transform[] ta = (Transform[])c;
 272             for (int i = 0; i &lt; ta.length; i++) {
 273                 Transform t = ta[i];
 274                 if (t == null)  break;
 275                 if (t.equals(key)) { k = t; break; }
 276             }
 277         }
 278         assert(k == null || key.equals(k));
 279         return (k != null) ? k.get() : null;
 280     }
 281 
 282     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 283     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 284 
 285     /** Cache a transform with its result, and return that result.
 286      *  But if an equivalent transform has already been cached, return its result instead.
 287      */
<span class="line-modified"> 288     private LambdaForm putInCache(Transform key, LambdaForm form) {</span>
<span class="line-modified"> 289         key = key.withResult(form);</span>
 290         for (int pass = 0; ; pass++) {
 291             Object c = lambdaForm.transformCache;
 292             if (c instanceof ConcurrentHashMap) {
 293                 @SuppressWarnings(&quot;unchecked&quot;)
 294                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified"> 295                 Transform k = m.putIfAbsent(key, key);</span>
 296                 if (k == null) return form;
 297                 LambdaForm result = k.get();
 298                 if (result != null) {
 299                     return result;
 300                 } else {
<span class="line-modified"> 301                     if (m.replace(key, k, key)) {</span>
 302                         return form;
 303                     } else {
 304                         continue;
 305                     }
 306                 }
 307             }
 308             assert(pass == 0);
 309             synchronized (lambdaForm) {
 310                 c = lambdaForm.transformCache;
 311                 if (c instanceof ConcurrentHashMap)
 312                     continue;
 313                 if (c == null) {
<span class="line-modified"> 314                     lambdaForm.transformCache = key;</span>
 315                     return form;
 316                 }
 317                 Transform[] ta;
 318                 if (c instanceof Transform) {
 319                     Transform k = (Transform)c;
 320                     if (k.equals(key)) {
 321                         LambdaForm result = k.get();
 322                         if (result == null) {
<span class="line-modified"> 323                             lambdaForm.transformCache = key;</span>
 324                             return form;
 325                         } else {
 326                             return result;
 327                         }
 328                     } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified"> 329                         lambdaForm.transformCache = key;</span>
 330                         return form;
 331                     }
 332                     // expand one-element cache to small array
 333                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 334                     ta[0] = k;
 335                     lambdaForm.transformCache = ta;
 336                 } else {
 337                     // it is already expanded
 338                     ta = (Transform[])c;
 339                 }
 340                 int len = ta.length;
 341                 int stale = -1;
 342                 int i;
 343                 for (i = 0; i &lt; len; i++) {
 344                     Transform k = ta[i];
 345                     if (k == null) {
 346                         break;
 347                     }
<span class="line-modified"> 348                     if (k.equals(key)) {</span>
 349                         LambdaForm result = k.get();
 350                         if (result == null) {
<span class="line-modified"> 351                             ta[i] = key;</span>
 352                             return form;
 353                         } else {
 354                             return result;
 355                         }
 356                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 357                         stale = i; // remember 1st stale entry index
 358                     }
 359                 }
 360                 if (i &lt; len || stale &gt;= 0) {
 361                     // just fall through to cache update
 362                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 363                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 364                     ta = Arrays.copyOf(ta, len);
 365                     lambdaForm.transformCache = ta;
 366                 } else {
 367                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 368                     for (Transform k : ta) {
 369                         m.put(k, k);
 370                     }
 371                     lambdaForm.transformCache = m;
 372                     // The second iteration will update for this query, concurrently.
 373                     continue;
 374                 }
 375                 int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified"> 376                 ta[idx] = key;</span>
 377                 return form;
 378             }
 379         }
 380     }
 381 
 382     private LambdaFormBuffer buffer() {
 383         return new LambdaFormBuffer(lambdaForm);
 384     }
 385 
 386     /// Editing methods for method handles.  These need to have fast paths.
 387 
 388     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 389         return BoundMethodHandle.speciesDataFor(lambdaForm);
 390     }
 391 
 392     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 393         return oldSpeciesData().extendWith((byte) type.ordinal());
 394     }
 395 
 396     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
</pre>
<hr />
<pre>
 426 
 427     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 428         assert(mh.speciesData() == oldSpeciesData());
 429         BasicType bt = D_TYPE;
 430         MethodType type2 = bindArgumentType(mh, pos, bt);
 431         LambdaForm form2 = bindArgumentForm(1+pos);
 432         return mh.copyWithExtendD(type2, form2, value);
 433     }
 434 
 435     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 436         assert(mh.form.uncustomize() == lambdaForm);
 437         assert(mh.form.names[1+pos].type == bt);
 438         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 439         return mh.type().dropParameterTypes(pos, pos+1);
 440     }
 441 
 442     /// Editing methods for lambda forms.
 443     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 444 
 445     LambdaForm bindArgumentForm(int pos) {
<span class="line-modified"> 446         Transform key = Transform.of(Transform.BIND_ARG, pos);</span>
 447         LambdaForm form = getInCache(key);
 448         if (form != null) {
 449             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 450             return form;
 451         }
 452         LambdaFormBuffer buf = buffer();
 453         buf.startEdit();
 454 
 455         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 456         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 457         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 458         Name newBaseAddress;
 459         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 460 
 461         if (pos != 0) {
 462             // The newly created LF will run with a different BMH.
 463             // Switch over any pre-existing BMH field references to the new BMH class.
 464             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 465             newBaseAddress = oldBaseAddress.withConstraint(newData);
 466             buf.renameParameter(0, newBaseAddress);
 467             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 468         } else {
 469             // cannot bind the MH arg itself, unless oldData is empty
 470             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 471             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 472             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 473             buf.insertParameter(0, newBaseAddress);
 474         }
 475 
 476         form = buf.endEdit();
 477         return putInCache(key, form);
 478     }
 479 
 480     LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified"> 481         Transform key = Transform.of(Transform.ADD_ARG, pos, type.ordinal());</span>
 482         LambdaForm form = getInCache(key);
 483         if (form != null) {
 484             assert(form.arity == lambdaForm.arity+1);
 485             assert(form.parameterType(pos) == type);
 486             return form;
 487         }
 488         LambdaFormBuffer buf = buffer();
 489         buf.startEdit();
 490 
 491         buf.insertParameter(pos, new Name(type));
 492 
 493         form = buf.endEdit();
 494         return putInCache(key, form);
 495     }
 496 
 497     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified"> 498         Transform key = Transform.of(Transform.DUP_ARG, srcPos, dstPos);</span>
 499         LambdaForm form = getInCache(key);
 500         if (form != null) {
 501             assert(form.arity == lambdaForm.arity-1);
 502             return form;
 503         }
 504         LambdaFormBuffer buf = buffer();
 505         buf.startEdit();
 506 
 507         assert(lambdaForm.parameter(srcPos).constraint == null);
 508         assert(lambdaForm.parameter(dstPos).constraint == null);
 509         buf.replaceParameterByCopy(dstPos, srcPos);
 510 
 511         form = buf.endEdit();
 512         return putInCache(key, form);
 513     }
 514 
 515     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 516         Class&lt;?&gt; elementType = arrayType.getComponentType();
 517         Class&lt;?&gt; erasedArrayType = arrayType;
 518         if (!elementType.isPrimitive())
 519             erasedArrayType = Object[].class;
 520         BasicType bt = basicType(elementType);
 521         int elementTypeKey = bt.ordinal();
 522         if (bt.basicTypeClass() != elementType) {
 523             if (elementType.isPrimitive()) {
 524                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 525             }
 526         }
<span class="line-modified"> 527         Transform key = Transform.of(Transform.SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
 528         LambdaForm form = getInCache(key);
 529         if (form != null) {
 530             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 531             return form;
 532         }
 533         LambdaFormBuffer buf = buffer();
 534         buf.startEdit();
 535 
 536         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 537         assert(pos + arrayLength &lt;= lambdaForm.arity);
 538         assert(pos &gt; 0);  // cannot spread the MH arg itself
 539 
 540         Name spreadParam = new Name(L_TYPE);
 541         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 542                 spreadParam, arrayLength);
 543 
 544         // insert the new expressions
 545         int exprPos = lambdaForm.arity();
 546         buf.insertExpression(exprPos++, checkSpread);
 547         // adjust the arguments
 548         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 549         for (int i = 0; i &lt; arrayLength; i++) {
 550             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 551             buf.insertExpression(exprPos + i, loadArgument);
 552             buf.replaceParameterByCopy(pos + i, exprPos + i);
 553         }
 554         buf.insertParameter(pos, spreadParam);
 555 
 556         form = buf.endEdit();
 557         return putInCache(key, form);
 558     }
 559 
 560     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 561         int collectorArity = collectorType.parameterCount();
 562         boolean dropResult = (collectorType.returnType() == void.class);
 563         if (collectorArity == 1 &amp;&amp; !dropResult) {
 564             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 565         }
<span class="line-modified"> 566         byte[] newTypes = BasicType.basicTypesOrd(collectorType.parameterArray());</span>
<span class="line-modified"> 567         byte kind = (dropResult</span>
<span class="line-removed"> 568                 ? Transform.COLLECT_ARGS_TO_VOID</span>
<span class="line-removed"> 569                 : Transform.COLLECT_ARGS);</span>
 570         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified"> 571         Transform key = Transform.of(kind, pos, collectorArity, newTypes);</span>
 572         LambdaForm form = getInCache(key);
 573         if (form != null) {
 574             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 575             return form;
 576         }
 577         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 578         return putInCache(key, form);
 579     }
 580 
 581     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 582         MethodType collectorType = arrayCollector.type();
 583         int collectorArity = collectorType.parameterCount();
 584         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 585         Class&lt;?&gt; arrayType = collectorType.returnType();
 586         Class&lt;?&gt; elementType = arrayType.getComponentType();
 587         BasicType argType = basicType(elementType);
 588         int argTypeKey = argType.ordinal();
 589         if (argType.basicTypeClass() != elementType) {
 590             // return null if it requires more metadata (like String[].class)
 591             if (!elementType.isPrimitive())
 592                 return null;
 593             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 594         }
 595         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified"> 596         byte kind = Transform.COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified"> 597         Transform key = Transform.of(kind, pos, collectorArity, argTypeKey);</span>
 598         LambdaForm form = getInCache(key);
 599         if (form != null) {
 600             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 601             return form;
 602         }
 603         LambdaFormBuffer buf = buffer();
 604         buf.startEdit();
 605 
 606         assert(pos + 1 &lt;= lambdaForm.arity);
 607         assert(pos &gt; 0);  // cannot filter the MH arg itself
 608 
 609         Name[] newParams = new Name[collectorArity];
 610         for (int i = 0; i &lt; collectorArity; i++) {
 611             newParams[i] = new Name(pos + i, argType);
 612         }
 613         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 614                                         (Object[]) /*...*/ newParams);
 615 
 616         // insert the new expression
 617         int exprPos = lambdaForm.arity();
 618         buf.insertExpression(exprPos, callCombiner);
 619 
 620         // insert new arguments
 621         int argPos = pos + 1;  // skip result parameter
 622         for (Name newParam : newParams) {
 623             buf.insertParameter(argPos++, newParam);
 624         }
 625         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 626         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 627 
 628         form = buf.endEdit();
 629         return putInCache(key, form);
 630     }
 631 
 632     LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified"> 633         Transform key = Transform.of(Transform.FILTER_ARG, pos, newType.ordinal());</span>
 634         LambdaForm form = getInCache(key);
 635         if (form != null) {
 636             assert(form.arity == lambdaForm.arity);
 637             assert(form.parameterType(pos) == newType);
 638             return form;
 639         }
 640 
 641         BasicType oldType = lambdaForm.parameterType(pos);
 642         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 643                 newType.basicTypeClass());
 644         form = makeArgumentCombinationForm(pos, filterType, false, false);
 645         return putInCache(key, form);
 646     }
 647 
 648     /**
 649      * This creates a LF that will repeatedly invoke some unary filter function
 650      * at each of the given positions. This allows fewer LFs and BMH species
 651      * classes to be generated in typical cases compared to building up the form
 652      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 653      * no worse in the worst case.
 654      */
 655     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 656         assert (argPositions.length &gt; 1);
<span class="line-modified"> 657         byte[] keyArgs = new byte[argPositions.length + 2];</span>
<span class="line-removed"> 658         keyArgs[0] = Transform.REPEAT_FILTER_ARGS;</span>
<span class="line-removed"> 659         keyArgs[argPositions.length + 1] = (byte)newType.ordinal();</span>
<span class="line-removed"> 660         for (int i = 0; i &lt; argPositions.length; i++) {</span>
<span class="line-removed"> 661             keyArgs[i + 1] = (byte)argPositions[i];</span>
<span class="line-removed"> 662         }</span>
<span class="line-removed"> 663         Transform key = new Transform(keyArgs);</span>
 664         LambdaForm form = getInCache(key);
 665         if (form != null) {
 666             assert(form.arity == lambdaForm.arity &amp;&amp;
 667                     formParametersMatch(form, newType, argPositions));
 668             return form;
 669         }
 670         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 671         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 672                 newType.basicTypeClass());
 673         form = makeRepeatedFilterForm(filterType, argPositions);
 674         assert (formParametersMatch(form, newType, argPositions));
 675         return putInCache(key, form);
 676     }
 677 
 678     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 679         for (int i : argPositions) {
 680             if (form.parameterType(i) != newType) {
 681                 return false;
 682             }
 683         }
</pre>
<hr />
<pre>
 856         // insert the two new expressions
 857         int exprPos = lambdaForm.arity();
 858         buf.insertExpression(exprPos+0, getCombiner);
 859         buf.insertExpression(exprPos+1, callCombiner);
 860 
 861         // insert new arguments, if needed
 862         int argPos = pos + resultArity;  // skip result parameter
 863         if (newParam != null) {
 864             buf.insertParameter(argPos++, newParam);
 865             exprPos++;
 866         }
 867         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 868         if (!dropResult) {
 869             buf.replaceParameterByCopy(pos, exprPos+1);
 870         }
 871 
 872         return buf.endEdit();
 873     }
 874 
 875     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified"> 876         byte kind = (constantZero ? Transform.FILTER_RETURN_TO_ZERO : Transform.FILTER_RETURN);</span>
<span class="line-modified"> 877         Transform key = Transform.of(kind, newType.ordinal());</span>
 878         LambdaForm form = getInCache(key);
 879         if (form != null) {
 880             assert(form.arity == lambdaForm.arity);
 881             assert(form.returnType() == newType);
 882             return form;
 883         }
 884         LambdaFormBuffer buf = buffer();
 885         buf.startEdit();
 886 
 887         int insPos = lambdaForm.names.length;
 888         Name callFilter;
 889         if (constantZero) {
 890             // Synthesize a constant zero value for the given type.
 891             if (newType == V_TYPE)
 892                 callFilter = null;
 893             else
 894                 callFilter = new Name(constantZero(newType));
 895         } else {
 896             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 897             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
</pre>
<hr />
<pre>
 906             Name getFilter = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 907             buf.insertExpression(insPos++, getFilter);
 908             BasicType oldType = lambdaForm.returnType();
 909             if (oldType == V_TYPE) {
 910                 MethodType filterType = MethodType.methodType(newType.basicTypeClass());
 911                 callFilter = new Name(filterType, getFilter);
 912             } else {
 913                 MethodType filterType = MethodType.methodType(newType.basicTypeClass(), oldType.basicTypeClass());
 914                 callFilter = new Name(filterType, getFilter, lambdaForm.names[lambdaForm.result]);
 915             }
 916         }
 917 
 918         if (callFilter != null)
 919             buf.insertExpression(insPos++, callFilter);
 920         buf.setResult(callFilter);
 921 
 922         form = buf.endEdit();
 923         return putInCache(key, form);
 924     }
 925 



















































 926     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
 927         int combinerArity = combinerType.parameterCount();
<span class="line-modified"> 928         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);</span>
<span class="line-modified"> 929         Transform key = Transform.of(kind, foldPos, combinerArity);</span>
 930         LambdaForm form = getInCache(key);
 931         if (form != null) {
<span class="line-modified"> 932             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));</span>
 933             return form;
 934         }
 935         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
 936         return putInCache(key, form);
 937     }
 938 
 939     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified"> 940         byte kind = (dropResult ? Transform.FOLD_SELECT_ARGS_TO_VOID</span>
<span class="line-modified"> 941                                 : Transform.FOLD_SELECT_ARGS);</span>
<span class="line-removed"> 942         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed"> 943         keyArgs[argPositions.length] = foldPos;</span>
<span class="line-removed"> 944         Transform key = Transform.of(kind, keyArgs);</span>
 945         LambdaForm form = getInCache(key);
 946         if (form != null) {
<span class="line-modified"> 947             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_SELECT_ARGS ? 1 : 0));</span>
 948             return form;
 949         }
 950         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
 951         return putInCache(key, form);
 952     }
 953 
 954     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified"> 955         byte kind = Transform.FILTER_SELECT_ARGS;</span>
<span class="line-removed"> 956         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);</span>
<span class="line-removed"> 957         keyArgs[argPositions.length] = filterPos;</span>
<span class="line-removed"> 958         Transform key = Transform.of(kind, keyArgs);</span>
 959         LambdaForm form = getInCache(key);
 960         if (form != null) {
 961             assert(form.arity == lambdaForm.arity);
 962             return form;
 963         }
 964         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
 965         return putInCache(key, form);
 966     }
 967 
 968     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
 969         assert(skip == 1);  // skip only the leading MH argument, names[0]
 970         int length = lambdaForm.names.length;
 971         int outArgs = reorder.length;
 972         int inTypes = 0;
 973         boolean nullPerm = true;
 974         for (int i = 0; i &lt; reorder.length; i++) {
 975             int inArg = reorder[i];
 976             if (inArg != i)  nullPerm = false;
 977             inTypes = Math.max(inTypes, inArg+1);
 978         }
 979         assert(skip + reorder.length == lambdaForm.arity);
 980         if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified"> 981         Transform key = Transform.of(Transform.PERMUTE_ARGS, reorder);</span>
 982         LambdaForm form = getInCache(key);
 983         if (form != null) {
 984             assert(form.arity == skip+inTypes) : form;
 985             return form;
 986         }
 987 
 988         BasicType[] types = new BasicType[inTypes];
 989         for (int i = 0; i &lt; outArgs; i++) {
 990             int inArg = reorder[i];
 991             types[inArg] = lambdaForm.names[skip + i].type;
 992         }
 993         assert (skip + outArgs == lambdaForm.arity);
 994         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
 995         int pos = 0;
 996         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
 997             pos += 1;
 998         }
 999         Name[] names2 = new Name[length - outArgs + inTypes];
1000         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1001         int bodyLength = length - lambdaForm.arity;
</pre>
<hr />
<pre>
1030         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1031             int i = j - lambdaForm.arity + arity2;
1032             Name n = lambdaForm.names[j];
1033             Name n2 = names2[i];
1034             if (n != n2) {
1035                 for (int k = i + 1; k &lt; names2.length; k++) {
1036                     names2[k] = names2[k].replaceName(n, n2);
1037                 }
1038             }
1039         }
1040 
1041         form = new LambdaForm(arity2, names2, result2);
1042         return putInCache(key, form);
1043     }
1044 
1045     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1046         assert(lambdaForm.isLoop(pos));
1047         int[] desc = BasicType.basicTypeOrds(localTypes);
1048         desc = Arrays.copyOf(desc, desc.length + 1);
1049         desc[desc.length - 1] = pos;
<span class="line-modified">1050         Transform key = Transform.of(Transform.LOCAL_TYPES, desc);</span>
1051         LambdaForm form = getInCache(key);
1052         if (form != null) {
1053             return form;
1054         }
1055 
1056         // replace the null entry in the MHImpl.loop invocation with localTypes
1057         Name invokeLoop = lambdaForm.names[pos + 1];
1058         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1059         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1060         assert(args[0] == null);
1061         args[0] = localTypes;
1062 
1063         LambdaFormBuffer buf = buffer();
1064         buf.startEdit();
1065         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1066         form = buf.endEdit();
1067 
1068         return putInCache(key, form);
1069     }
1070 
</pre>
</td>
<td>
<hr />
<pre>
  45  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  46  *  To support this caching, a LF has an optional pointer to its editor.
  47  */
  48 class LambdaFormEditor {
  49     final LambdaForm lambdaForm;
  50 
  51     private LambdaFormEditor(LambdaForm lambdaForm) {
  52         this.lambdaForm = lambdaForm;
  53     }
  54 
  55     // Factory method.
  56     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  57         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  58         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  59 
  60         // Always use uncustomized version for editing.
  61         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  62         return new LambdaFormEditor(lambdaForm.uncustomize());
  63     }
  64 
<span class="line-modified">  65     // Transform types</span>
<span class="line-modified">  66     // maybe add more for guard with test, catch exception, pointwise type conversions</span>
<span class="line-modified">  67     private static final byte</span>
<span class="line-modified">  68             BIND_ARG = 1,</span>
<span class="line-added">  69             ADD_ARG = 2,</span>
<span class="line-added">  70             DUP_ARG = 3,</span>
<span class="line-added">  71             SPREAD_ARGS = 4,</span>
<span class="line-added">  72             FILTER_ARG = 5,</span>
<span class="line-added">  73             FILTER_RETURN = 6,</span>
<span class="line-added">  74             FILTER_RETURN_TO_ZERO = 7,</span>
<span class="line-added">  75             COLLECT_ARGS = 8,</span>
<span class="line-added">  76             COLLECT_ARGS_TO_VOID = 9,</span>
<span class="line-added">  77             COLLECT_ARGS_TO_ARRAY = 10,</span>
<span class="line-added">  78             FOLD_ARGS = 11,</span>
<span class="line-added">  79             FOLD_ARGS_TO_VOID = 12,</span>
<span class="line-added">  80             PERMUTE_ARGS = 13,</span>
<span class="line-added">  81             LOCAL_TYPES = 14,</span>
<span class="line-added">  82             FOLD_SELECT_ARGS = 15,</span>
<span class="line-added">  83             FOLD_SELECT_ARGS_TO_VOID = 16,</span>
<span class="line-added">  84             FILTER_SELECT_ARGS = 17,</span>
<span class="line-added">  85             REPEAT_FILTER_ARGS = 18;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87     /**</span>
<span class="line-added">  88      * A description of a cached transform, possibly associated with the result of the transform.</span>
<span class="line-added">  89      * The logical content is a sequence of byte values, starting with a kind value.</span>
<span class="line-added">  90      * The sequence is unterminated, ending with an indefinite number of zero bytes.</span>
<span class="line-added">  91      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.</span>
<span class="line-added">  92      *</span>
<span class="line-added">  93      * Tightly coupled with the TransformKey class, which is used to lookup existing</span>
<span class="line-added">  94      * Transforms.</span>
  95      */
  96     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  97         final long packedBytes;
  98         final byte[] fullBytes;
  99 
<span class="line-modified"> 100         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {</span>
<span class="line-modified"> 101             super(result);</span>
<span class="line-modified"> 102             this.packedBytes = packedBytes;</span>
<span class="line-modified"> 103             this.fullBytes = fullBytes;</span>
<span class="line-modified"> 104         }</span>
<span class="line-modified"> 105 </span>
<span class="line-modified"> 106         @Override</span>
<span class="line-modified"> 107         public boolean equals(Object obj) {</span>
<span class="line-modified"> 108             if (obj instanceof TransformKey) {</span>
<span class="line-modified"> 109                 return equals((TransformKey) obj);</span>
<span class="line-modified"> 110             }</span>
<span class="line-modified"> 111             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-modified"> 112         }</span>
<span class="line-modified"> 113 </span>
<span class="line-modified"> 114         private boolean equals(TransformKey that) {</span>
<span class="line-modified"> 115             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-modified"> 116         }</span>
<span class="line-modified"> 117 </span>
<span class="line-modified"> 118         private boolean equals(Transform that) {</span>
<span class="line-modified"> 119             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 120         }</span>
<span class="line-added"> 121 </span>
<span class="line-added"> 122         @Override</span>
<span class="line-added"> 123         public int hashCode() {</span>
<span class="line-added"> 124             if (packedBytes != 0) {</span>
<span class="line-added"> 125                 assert(fullBytes == null);</span>
<span class="line-added"> 126                 return Long.hashCode(packedBytes);</span>
<span class="line-added"> 127             }</span>
<span class="line-added"> 128             return Arrays.hashCode(fullBytes);</span>
<span class="line-added"> 129         }</span>
<span class="line-added"> 130 </span>
<span class="line-added"> 131         @Override</span>
<span class="line-added"> 132         public String toString() {</span>
<span class="line-added"> 133             StringBuilder buf = new StringBuilder();</span>
<span class="line-added"> 134             buf.append(new TransformKey(packedBytes, fullBytes).toString());</span>
<span class="line-added"> 135             LambdaForm result = get();</span>
<span class="line-added"> 136             if (result != null) {</span>
<span class="line-added"> 137                 buf.append(&quot; result=&quot;);</span>
<span class="line-added"> 138                 buf.append(result);</span>
<span class="line-added"> 139             }</span>
<span class="line-added"> 140             return buf.toString();</span>
<span class="line-added"> 141         }</span>
<span class="line-added"> 142     }</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144     /**</span>
<span class="line-added"> 145      * Used as a lookup key to find existing Transforms</span>
<span class="line-added"> 146      */</span>
<span class="line-added"> 147     private static final class TransformKey {</span>
<span class="line-added"> 148         final long packedBytes;</span>
<span class="line-added"> 149         final byte[] fullBytes;</span>
<span class="line-added"> 150 </span>
<span class="line-added"> 151         private TransformKey(long packedBytes) {</span>
<span class="line-added"> 152             this.packedBytes = packedBytes;</span>
<span class="line-added"> 153             this.fullBytes = null;</span>
<span class="line-added"> 154         }</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156         private TransformKey(byte[] fullBytes) {</span>
<span class="line-added"> 157             this.fullBytes = fullBytes;</span>
<span class="line-added"> 158             this.packedBytes = 0;</span>
<span class="line-added"> 159         }</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161         private TransformKey(long packedBytes, byte[] fullBytes) {</span>
<span class="line-added"> 162             this.fullBytes = fullBytes;</span>
<span class="line-added"> 163             this.packedBytes = packedBytes;</span>
<span class="line-added"> 164         }</span>
<span class="line-added"> 165 </span>
<span class="line-added"> 166         private static byte bval(int b) {</span>
<span class="line-added"> 167             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte</span>
<span class="line-added"> 168             return (byte)b;</span>
<span class="line-added"> 169         }</span>
<span class="line-added"> 170         static TransformKey of(byte k, int b1) {</span>
<span class="line-added"> 171             byte b0 = bval(k);</span>
<span class="line-added"> 172             if (inRange(b0 | b1))</span>
<span class="line-added"> 173                 return new TransformKey(packedBytes(b0, b1));</span>
<span class="line-added"> 174             else</span>
<span class="line-added"> 175                 return new TransformKey(fullBytes(b0, b1));</span>
<span class="line-added"> 176         }</span>
<span class="line-added"> 177         static TransformKey of(byte b0, int b1, int b2) {</span>
<span class="line-added"> 178             if (inRange(b0 | b1 | b2))</span>
<span class="line-added"> 179                 return new TransformKey(packedBytes(b0, b1, b2));</span>
<span class="line-added"> 180             else</span>
<span class="line-added"> 181                 return new TransformKey(fullBytes(b0, b1, b2));</span>
<span class="line-added"> 182         }</span>
<span class="line-added"> 183         static TransformKey of(byte b0, int b1, int b2, int b3) {</span>
<span class="line-added"> 184             if (inRange(b0 | b1 | b2 | b3))</span>
<span class="line-added"> 185                 return new TransformKey(packedBytes(b0, b1, b2, b3));</span>
<span class="line-added"> 186             else</span>
<span class="line-added"> 187                 return new TransformKey(fullBytes(b0, b1, b2, b3));</span>
<span class="line-added"> 188         }</span>
<span class="line-added"> 189         private static final byte[] NO_BYTES = {};</span>
<span class="line-added"> 190         static TransformKey of(byte kind, int... b123) {</span>
<span class="line-added"> 191             return ofBothArrays(kind, b123, NO_BYTES);</span>
<span class="line-added"> 192         }</span>
<span class="line-added"> 193 </span>
<span class="line-added"> 194         static TransformKey of(byte kind, int b1, int[] b23456) {</span>
<span class="line-added"> 195             byte[] fullBytes = new byte[b23456.length + 2];</span>
<span class="line-added"> 196             fullBytes[0] = kind;</span>
<span class="line-added"> 197             fullBytes[1] = bval(b1);</span>
<span class="line-added"> 198             for (int i = 0; i &lt; b23456.length; i++) {</span>
<span class="line-added"> 199                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);</span>
<span class="line-added"> 200             }</span>
<span class="line-added"> 201             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added"> 202             if (packedBytes != 0)</span>
<span class="line-added"> 203                 return new TransformKey(packedBytes);</span>
<span class="line-added"> 204             else</span>
<span class="line-added"> 205                 return new TransformKey(fullBytes);</span>
<span class="line-added"> 206         }</span>
<span class="line-added"> 207 </span>
<span class="line-added"> 208         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {</span>
<span class="line-added"> 209             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);</span>
<span class="line-added"> 210         }</span>
<span class="line-added"> 211         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {</span>
<span class="line-added"> 212             byte[] fullBytes = new byte[1 + b123.length + b456.length];</span>
<span class="line-added"> 213             int i = 0;</span>
<span class="line-added"> 214             fullBytes[i++] = bval(kind);</span>
<span class="line-added"> 215             for (int bv : b123) {</span>
<span class="line-added"> 216                 fullBytes[i++] = bval(bv);</span>
<span class="line-added"> 217             }</span>
<span class="line-added"> 218             for (byte bv : b456) {</span>
<span class="line-added"> 219                 fullBytes[i++] = bv;</span>
<span class="line-added"> 220             }</span>
<span class="line-added"> 221             long packedBytes = packedBytes(fullBytes);</span>
<span class="line-added"> 222             if (packedBytes != 0)</span>
<span class="line-added"> 223                 return new TransformKey(packedBytes);</span>
<span class="line-added"> 224             else</span>
<span class="line-added"> 225                 return new TransformKey(fullBytes);</span>
<span class="line-added"> 226         }</span>
 227 
 228         private static final boolean STRESS_TEST = false; // turn on to disable most packing
 229         private static final int
 230                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
 231                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
 232                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 233 
 234         private static long packedBytes(byte[] bytes) {
<span class="line-modified"> 235             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)</span>
<span class="line-added"> 236                 return 0;</span>
 237             long pb = 0;
 238             int bitset = 0;
 239             for (int i = 0; i &lt; bytes.length; i++) {
 240                 int b = bytes[i] &amp; 0xFF;
 241                 bitset |= b;
 242                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 243             }
 244             if (!inRange(bitset))
 245                 return 0;
 246             return pb;
 247         }
 248         private static long packedBytes(int b0, int b1) {
 249             assert(inRange(b0 | b1));
 250             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 251                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 252         }
 253         private static long packedBytes(int b0, int b1, int b2) {
 254             assert(inRange(b0 | b1 | b2));
 255             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 256                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
</pre>
<hr />
<pre>
 260             assert(inRange(b0 | b1 | b2 | b3));
 261             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 262                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 263                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 264                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 265         }
 266         private static boolean inRange(int bitset) {
 267             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 268             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 269         }
 270         private static byte[] fullBytes(int... byteValues) {
 271             byte[] bytes = new byte[byteValues.length];
 272             int i = 0;
 273             for (int bv : byteValues) {
 274                 bytes[i++] = bval(bv);
 275             }
 276             assert(packedBytes(bytes) == 0);
 277             return bytes;
 278         }
 279 































































 280         Transform withResult(LambdaForm result) {
 281             return new Transform(this.packedBytes, this.fullBytes, result);
 282         }
 283 















 284         @Override
 285         public String toString() {
 286             StringBuilder buf = new StringBuilder();
 287             long bits = packedBytes;
 288             if (bits != 0) {
 289                 buf.append(&quot;(&quot;);
 290                 while (bits != 0) {
 291                     buf.append(bits &amp; PACKED_BYTE_MASK);
 292                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 293                     if (bits != 0)  buf.append(&quot;,&quot;);
 294                 }
 295                 buf.append(&quot;)&quot;);
 296             }
 297             if (fullBytes != null) {
 298                 buf.append(&quot;unpacked&quot;);
 299                 buf.append(Arrays.toString(fullBytes));
 300             }





 301             return buf.toString();
 302         }
<span class="line-added"> 303 </span>
<span class="line-added"> 304         @Override</span>
<span class="line-added"> 305         public boolean equals(Object obj) {</span>
<span class="line-added"> 306             if (obj instanceof TransformKey) {</span>
<span class="line-added"> 307                 return equals((TransformKey) obj);</span>
<span class="line-added"> 308             }</span>
<span class="line-added"> 309             return obj instanceof Transform &amp;&amp; equals((Transform)obj);</span>
<span class="line-added"> 310         }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312         private boolean equals(TransformKey that) {</span>
<span class="line-added"> 313             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 314         }</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316         private boolean equals(Transform that) {</span>
<span class="line-added"> 317             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);</span>
<span class="line-added"> 318         }</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320         @Override</span>
<span class="line-added"> 321         public int hashCode() {</span>
<span class="line-added"> 322             if (packedBytes != 0) {</span>
<span class="line-added"> 323                 assert(fullBytes == null);</span>
<span class="line-added"> 324                 return Long.hashCode(packedBytes);</span>
<span class="line-added"> 325             }</span>
<span class="line-added"> 326             return Arrays.hashCode(fullBytes);</span>
<span class="line-added"> 327         }</span>
 328     }
 329 
 330     /** Find a previously cached transform equivalent to the given one, and return its result. */
<span class="line-modified"> 331     private LambdaForm getInCache(TransformKey key) {</span>

 332         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 333         Object c = lambdaForm.transformCache;
 334         Transform k = null;
 335         if (c instanceof ConcurrentHashMap) {
 336             @SuppressWarnings(&quot;unchecked&quot;)
 337             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 338             k = m.get(key);
 339         } else if (c == null) {
 340             return null;
 341         } else if (c instanceof Transform) {
 342             // one-element cache avoids overhead of an array
 343             Transform t = (Transform)c;
 344             if (t.equals(key))  k = t;
 345         } else {
 346             Transform[] ta = (Transform[])c;
 347             for (int i = 0; i &lt; ta.length; i++) {
 348                 Transform t = ta[i];
 349                 if (t == null)  break;
 350                 if (t.equals(key)) { k = t; break; }
 351             }
 352         }
 353         assert(k == null || key.equals(k));
 354         return (k != null) ? k.get() : null;
 355     }
 356 
 357     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 358     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 359 
 360     /** Cache a transform with its result, and return that result.
 361      *  But if an equivalent transform has already been cached, return its result instead.
 362      */
<span class="line-modified"> 363     private LambdaForm putInCache(TransformKey key, LambdaForm form) {</span>
<span class="line-modified"> 364         Transform transform = key.withResult(form);</span>
 365         for (int pass = 0; ; pass++) {
 366             Object c = lambdaForm.transformCache;
 367             if (c instanceof ConcurrentHashMap) {
 368                 @SuppressWarnings(&quot;unchecked&quot;)
 369                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
<span class="line-modified"> 370                 Transform k = m.putIfAbsent(transform, transform);</span>
 371                 if (k == null) return form;
 372                 LambdaForm result = k.get();
 373                 if (result != null) {
 374                     return result;
 375                 } else {
<span class="line-modified"> 376                     if (m.replace(transform, k, transform)) {</span>
 377                         return form;
 378                     } else {
 379                         continue;
 380                     }
 381                 }
 382             }
 383             assert(pass == 0);
 384             synchronized (lambdaForm) {
 385                 c = lambdaForm.transformCache;
 386                 if (c instanceof ConcurrentHashMap)
 387                     continue;
 388                 if (c == null) {
<span class="line-modified"> 389                     lambdaForm.transformCache = transform;</span>
 390                     return form;
 391                 }
 392                 Transform[] ta;
 393                 if (c instanceof Transform) {
 394                     Transform k = (Transform)c;
 395                     if (k.equals(key)) {
 396                         LambdaForm result = k.get();
 397                         if (result == null) {
<span class="line-modified"> 398                             lambdaForm.transformCache = transform;</span>
 399                             return form;
 400                         } else {
 401                             return result;
 402                         }
 403                     } else if (k.get() == null) { // overwrite stale entry
<span class="line-modified"> 404                         lambdaForm.transformCache = transform;</span>
 405                         return form;
 406                     }
 407                     // expand one-element cache to small array
 408                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 409                     ta[0] = k;
 410                     lambdaForm.transformCache = ta;
 411                 } else {
 412                     // it is already expanded
 413                     ta = (Transform[])c;
 414                 }
 415                 int len = ta.length;
 416                 int stale = -1;
 417                 int i;
 418                 for (i = 0; i &lt; len; i++) {
 419                     Transform k = ta[i];
 420                     if (k == null) {
 421                         break;
 422                     }
<span class="line-modified"> 423                     if (k.equals(transform)) {</span>
 424                         LambdaForm result = k.get();
 425                         if (result == null) {
<span class="line-modified"> 426                             ta[i] = transform;</span>
 427                             return form;
 428                         } else {
 429                             return result;
 430                         }
 431                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 432                         stale = i; // remember 1st stale entry index
 433                     }
 434                 }
 435                 if (i &lt; len || stale &gt;= 0) {
 436                     // just fall through to cache update
 437                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 438                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 439                     ta = Arrays.copyOf(ta, len);
 440                     lambdaForm.transformCache = ta;
 441                 } else {
 442                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 443                     for (Transform k : ta) {
 444                         m.put(k, k);
 445                     }
 446                     lambdaForm.transformCache = m;
 447                     // The second iteration will update for this query, concurrently.
 448                     continue;
 449                 }
 450                 int idx = (stale &gt;= 0) ? stale : i;
<span class="line-modified"> 451                 ta[idx] = transform;</span>
 452                 return form;
 453             }
 454         }
 455     }
 456 
 457     private LambdaFormBuffer buffer() {
 458         return new LambdaFormBuffer(lambdaForm);
 459     }
 460 
 461     /// Editing methods for method handles.  These need to have fast paths.
 462 
 463     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 464         return BoundMethodHandle.speciesDataFor(lambdaForm);
 465     }
 466 
 467     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 468         return oldSpeciesData().extendWith((byte) type.ordinal());
 469     }
 470 
 471     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
</pre>
<hr />
<pre>
 501 
 502     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 503         assert(mh.speciesData() == oldSpeciesData());
 504         BasicType bt = D_TYPE;
 505         MethodType type2 = bindArgumentType(mh, pos, bt);
 506         LambdaForm form2 = bindArgumentForm(1+pos);
 507         return mh.copyWithExtendD(type2, form2, value);
 508     }
 509 
 510     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 511         assert(mh.form.uncustomize() == lambdaForm);
 512         assert(mh.form.names[1+pos].type == bt);
 513         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 514         return mh.type().dropParameterTypes(pos, pos+1);
 515     }
 516 
 517     /// Editing methods for lambda forms.
 518     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 519 
 520     LambdaForm bindArgumentForm(int pos) {
<span class="line-modified"> 521         TransformKey key = TransformKey.of(BIND_ARG, pos);</span>
 522         LambdaForm form = getInCache(key);
 523         if (form != null) {
 524             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 525             return form;
 526         }
 527         LambdaFormBuffer buf = buffer();
 528         buf.startEdit();
 529 
 530         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 531         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 532         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 533         Name newBaseAddress;
 534         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 535 
 536         if (pos != 0) {
 537             // The newly created LF will run with a different BMH.
 538             // Switch over any pre-existing BMH field references to the new BMH class.
 539             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 540             newBaseAddress = oldBaseAddress.withConstraint(newData);
 541             buf.renameParameter(0, newBaseAddress);
 542             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 543         } else {
 544             // cannot bind the MH arg itself, unless oldData is empty
 545             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 546             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 547             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 548             buf.insertParameter(0, newBaseAddress);
 549         }
 550 
 551         form = buf.endEdit();
 552         return putInCache(key, form);
 553     }
 554 
 555     LambdaForm addArgumentForm(int pos, BasicType type) {
<span class="line-modified"> 556         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());</span>
 557         LambdaForm form = getInCache(key);
 558         if (form != null) {
 559             assert(form.arity == lambdaForm.arity+1);
 560             assert(form.parameterType(pos) == type);
 561             return form;
 562         }
 563         LambdaFormBuffer buf = buffer();
 564         buf.startEdit();
 565 
 566         buf.insertParameter(pos, new Name(type));
 567 
 568         form = buf.endEdit();
 569         return putInCache(key, form);
 570     }
 571 
 572     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
<span class="line-modified"> 573         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);</span>
 574         LambdaForm form = getInCache(key);
 575         if (form != null) {
 576             assert(form.arity == lambdaForm.arity-1);
 577             return form;
 578         }
 579         LambdaFormBuffer buf = buffer();
 580         buf.startEdit();
 581 
 582         assert(lambdaForm.parameter(srcPos).constraint == null);
 583         assert(lambdaForm.parameter(dstPos).constraint == null);
 584         buf.replaceParameterByCopy(dstPos, srcPos);
 585 
 586         form = buf.endEdit();
 587         return putInCache(key, form);
 588     }
 589 
 590     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 591         Class&lt;?&gt; elementType = arrayType.getComponentType();
 592         Class&lt;?&gt; erasedArrayType = arrayType;
 593         if (!elementType.isPrimitive())
 594             erasedArrayType = Object[].class;
 595         BasicType bt = basicType(elementType);
 596         int elementTypeKey = bt.ordinal();
 597         if (bt.basicTypeClass() != elementType) {
 598             if (elementType.isPrimitive()) {
 599                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 600             }
 601         }
<span class="line-modified"> 602         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);</span>
 603         LambdaForm form = getInCache(key);
 604         if (form != null) {
 605             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 606             return form;
 607         }
 608         LambdaFormBuffer buf = buffer();
 609         buf.startEdit();
 610 
 611         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 612         assert(pos + arrayLength &lt;= lambdaForm.arity);
 613         assert(pos &gt; 0);  // cannot spread the MH arg itself
 614 
 615         Name spreadParam = new Name(L_TYPE);
 616         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 617                 spreadParam, arrayLength);
 618 
 619         // insert the new expressions
 620         int exprPos = lambdaForm.arity();
 621         buf.insertExpression(exprPos++, checkSpread);
 622         // adjust the arguments
 623         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 624         for (int i = 0; i &lt; arrayLength; i++) {
 625             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 626             buf.insertExpression(exprPos + i, loadArgument);
 627             buf.replaceParameterByCopy(pos + i, exprPos + i);
 628         }
 629         buf.insertParameter(pos, spreadParam);
 630 
 631         form = buf.endEdit();
 632         return putInCache(key, form);
 633     }
 634 
 635     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 636         int collectorArity = collectorType.parameterCount();
 637         boolean dropResult = (collectorType.returnType() == void.class);
 638         if (collectorArity == 1 &amp;&amp; !dropResult) {
 639             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 640         }
<span class="line-modified"> 641         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());</span>
<span class="line-modified"> 642         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);</span>


 643         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
<span class="line-modified"> 644         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);</span>
 645         LambdaForm form = getInCache(key);
 646         if (form != null) {
 647             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 648             return form;
 649         }
 650         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 651         return putInCache(key, form);
 652     }
 653 
 654     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 655         MethodType collectorType = arrayCollector.type();
 656         int collectorArity = collectorType.parameterCount();
 657         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 658         Class&lt;?&gt; arrayType = collectorType.returnType();
 659         Class&lt;?&gt; elementType = arrayType.getComponentType();
 660         BasicType argType = basicType(elementType);
 661         int argTypeKey = argType.ordinal();
 662         if (argType.basicTypeClass() != elementType) {
 663             // return null if it requires more metadata (like String[].class)
 664             if (!elementType.isPrimitive())
 665                 return null;
 666             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 667         }
 668         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
<span class="line-modified"> 669         byte kind = COLLECT_ARGS_TO_ARRAY;</span>
<span class="line-modified"> 670         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);</span>
 671         LambdaForm form = getInCache(key);
 672         if (form != null) {
 673             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 674             return form;
 675         }
 676         LambdaFormBuffer buf = buffer();
 677         buf.startEdit();
 678 
 679         assert(pos + 1 &lt;= lambdaForm.arity);
 680         assert(pos &gt; 0);  // cannot filter the MH arg itself
 681 
 682         Name[] newParams = new Name[collectorArity];
 683         for (int i = 0; i &lt; collectorArity; i++) {
 684             newParams[i] = new Name(pos + i, argType);
 685         }
 686         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 687                                         (Object[]) /*...*/ newParams);
 688 
 689         // insert the new expression
 690         int exprPos = lambdaForm.arity();
 691         buf.insertExpression(exprPos, callCombiner);
 692 
 693         // insert new arguments
 694         int argPos = pos + 1;  // skip result parameter
 695         for (Name newParam : newParams) {
 696             buf.insertParameter(argPos++, newParam);
 697         }
 698         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 699         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 700 
 701         form = buf.endEdit();
 702         return putInCache(key, form);
 703     }
 704 
 705     LambdaForm filterArgumentForm(int pos, BasicType newType) {
<span class="line-modified"> 706         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());</span>
 707         LambdaForm form = getInCache(key);
 708         if (form != null) {
 709             assert(form.arity == lambdaForm.arity);
 710             assert(form.parameterType(pos) == newType);
 711             return form;
 712         }
 713 
 714         BasicType oldType = lambdaForm.parameterType(pos);
 715         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 716                 newType.basicTypeClass());
 717         form = makeArgumentCombinationForm(pos, filterType, false, false);
 718         return putInCache(key, form);
 719     }
 720 
 721     /**
 722      * This creates a LF that will repeatedly invoke some unary filter function
 723      * at each of the given positions. This allows fewer LFs and BMH species
 724      * classes to be generated in typical cases compared to building up the form
 725      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 726      * no worse in the worst case.
 727      */
 728     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 729         assert (argPositions.length &gt; 1);
<span class="line-modified"> 730         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);</span>






 731         LambdaForm form = getInCache(key);
 732         if (form != null) {
 733             assert(form.arity == lambdaForm.arity &amp;&amp;
 734                     formParametersMatch(form, newType, argPositions));
 735             return form;
 736         }
 737         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 738         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 739                 newType.basicTypeClass());
 740         form = makeRepeatedFilterForm(filterType, argPositions);
 741         assert (formParametersMatch(form, newType, argPositions));
 742         return putInCache(key, form);
 743     }
 744 
 745     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 746         for (int i : argPositions) {
 747             if (form.parameterType(i) != newType) {
 748                 return false;
 749             }
 750         }
</pre>
<hr />
<pre>
 923         // insert the two new expressions
 924         int exprPos = lambdaForm.arity();
 925         buf.insertExpression(exprPos+0, getCombiner);
 926         buf.insertExpression(exprPos+1, callCombiner);
 927 
 928         // insert new arguments, if needed
 929         int argPos = pos + resultArity;  // skip result parameter
 930         if (newParam != null) {
 931             buf.insertParameter(argPos++, newParam);
 932             exprPos++;
 933         }
 934         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 935         if (!dropResult) {
 936             buf.replaceParameterByCopy(pos, exprPos+1);
 937         }
 938 
 939         return buf.endEdit();
 940     }
 941 
 942     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
<span class="line-modified"> 943         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);</span>
<span class="line-modified"> 944         TransformKey key = TransformKey.of(kind, newType.ordinal());</span>
 945         LambdaForm form = getInCache(key);
 946         if (form != null) {
 947             assert(form.arity == lambdaForm.arity);
 948             assert(form.returnType() == newType);
 949             return form;
 950         }
 951         LambdaFormBuffer buf = buffer();
 952         buf.startEdit();
 953 
 954         int insPos = lambdaForm.names.length;
 955         Name callFilter;
 956         if (constantZero) {
 957             // Synthesize a constant zero value for the given type.
 958             if (newType == V_TYPE)
 959                 callFilter = null;
 960             else
 961                 callFilter = new Name(constantZero(newType));
 962         } else {
 963             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 964             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
</pre>
<hr />
<pre>
 973             Name getFilter = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 974             buf.insertExpression(insPos++, getFilter);
 975             BasicType oldType = lambdaForm.returnType();
 976             if (oldType == V_TYPE) {
 977                 MethodType filterType = MethodType.methodType(newType.basicTypeClass());
 978                 callFilter = new Name(filterType, getFilter);
 979             } else {
 980                 MethodType filterType = MethodType.methodType(newType.basicTypeClass(), oldType.basicTypeClass());
 981                 callFilter = new Name(filterType, getFilter, lambdaForm.names[lambdaForm.result]);
 982             }
 983         }
 984 
 985         if (callFilter != null)
 986             buf.insertExpression(insPos++, callFilter);
 987         buf.setResult(callFilter);
 988 
 989         form = buf.endEdit();
 990         return putInCache(key, form);
 991     }
 992 
<span class="line-added"> 993     LambdaForm collectReturnValueForm(MethodType combinerType) {</span>
<span class="line-added"> 994         LambdaFormBuffer buf = buffer();</span>
<span class="line-added"> 995         buf.startEdit();</span>
<span class="line-added"> 996         int combinerArity = combinerType.parameterCount();</span>
<span class="line-added"> 997         int argPos = lambdaForm.arity();</span>
<span class="line-added"> 998         int exprPos = lambdaForm.names.length;</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();</span>
<span class="line-added">1001         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);</span>
<span class="line-added">1002 </span>
<span class="line-added">1003         // The newly created LF will run with a different BMH.</span>
<span class="line-added">1004         // Switch over any pre-existing BMH field references to the new BMH class.</span>
<span class="line-added">1005         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values</span>
<span class="line-added">1006         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);</span>
<span class="line-added">1007         Name newBaseAddress = oldBaseAddress.withConstraint(newData);</span>
<span class="line-added">1008         buf.renameParameter(0, newBaseAddress);</span>
<span class="line-added">1009 </span>
<span class="line-added">1010         // Now we set up the call to the filter</span>
<span class="line-added">1011         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);</span>
<span class="line-added">1012 </span>
<span class="line-added">1013         Object[] combinerArgs = new Object[combinerArity + 1];</span>
<span class="line-added">1014         combinerArgs[0] = getCombiner; // first (synthetic) argument should be the MH that acts as a target of the invoke</span>
<span class="line-added">1015 </span>
<span class="line-added">1016         // set up additional adapter parameters (in case the combiner is not a unary function)</span>
<span class="line-added">1017         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter</span>
<span class="line-added">1018         for (int i = 0; i &lt; newParams.length; i++) {</span>
<span class="line-added">1019             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));</span>
<span class="line-added">1020         }</span>
<span class="line-added">1021 </span>
<span class="line-added">1022         // set up remaining filter parameters to point to the corresponding adapter parameters (see above)</span>
<span class="line-added">1023         System.arraycopy(newParams, 0,</span>
<span class="line-added">1024                 combinerArgs, 1, combinerArity - 1);</span>
<span class="line-added">1025 </span>
<span class="line-added">1026         // the last filter argument is set to point at the result of the target method handle</span>
<span class="line-added">1027         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);</span>
<span class="line-added">1028         Name callCombiner = new Name(combinerType, combinerArgs);</span>
<span class="line-added">1029 </span>
<span class="line-added">1030         // insert the two new expressions</span>
<span class="line-added">1031         buf.insertExpression(exprPos, getCombiner);</span>
<span class="line-added">1032         buf.insertExpression(exprPos + 1, callCombiner);</span>
<span class="line-added">1033 </span>
<span class="line-added">1034         // insert additional arguments</span>
<span class="line-added">1035         int insPos = argPos;</span>
<span class="line-added">1036         for (Name newParam : newParams) {</span>
<span class="line-added">1037             buf.insertParameter(insPos++, newParam);</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039 </span>
<span class="line-added">1040         buf.setResult(callCombiner);</span>
<span class="line-added">1041         return buf.endEdit();</span>
<span class="line-added">1042     }</span>
<span class="line-added">1043 </span>
1044     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
1045         int combinerArity = combinerType.parameterCount();
<span class="line-modified">1046         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);</span>
<span class="line-modified">1047         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);</span>
1048         LambdaForm form = getInCache(key);
1049         if (form != null) {
<span class="line-modified">1050             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));</span>
1051             return form;
1052         }
1053         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
1054         return putInCache(key, form);
1055     }
1056 
1057     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
<span class="line-modified">1058         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);</span>
<span class="line-modified">1059         TransformKey key = TransformKey.of(kind, foldPos, argPositions);</span>



1060         LambdaForm form = getInCache(key);
1061         if (form != null) {
<span class="line-modified">1062             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));</span>
1063             return form;
1064         }
1065         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
1066         return putInCache(key, form);
1067     }
1068 
1069     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
<span class="line-modified">1070         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);</span>



1071         LambdaForm form = getInCache(key);
1072         if (form != null) {
1073             assert(form.arity == lambdaForm.arity);
1074             return form;
1075         }
1076         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
1077         return putInCache(key, form);
1078     }
1079 
1080     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
1081         assert(skip == 1);  // skip only the leading MH argument, names[0]
1082         int length = lambdaForm.names.length;
1083         int outArgs = reorder.length;
1084         int inTypes = 0;
1085         boolean nullPerm = true;
1086         for (int i = 0; i &lt; reorder.length; i++) {
1087             int inArg = reorder[i];
1088             if (inArg != i)  nullPerm = false;
1089             inTypes = Math.max(inTypes, inArg+1);
1090         }
1091         assert(skip + reorder.length == lambdaForm.arity);
1092         if (nullPerm)  return lambdaForm;  // do not bother to cache
<span class="line-modified">1093         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);</span>
1094         LambdaForm form = getInCache(key);
1095         if (form != null) {
1096             assert(form.arity == skip+inTypes) : form;
1097             return form;
1098         }
1099 
1100         BasicType[] types = new BasicType[inTypes];
1101         for (int i = 0; i &lt; outArgs; i++) {
1102             int inArg = reorder[i];
1103             types[inArg] = lambdaForm.names[skip + i].type;
1104         }
1105         assert (skip + outArgs == lambdaForm.arity);
1106         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
1107         int pos = 0;
1108         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
1109             pos += 1;
1110         }
1111         Name[] names2 = new Name[length - outArgs + inTypes];
1112         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1113         int bodyLength = length - lambdaForm.arity;
</pre>
<hr />
<pre>
1142         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1143             int i = j - lambdaForm.arity + arity2;
1144             Name n = lambdaForm.names[j];
1145             Name n2 = names2[i];
1146             if (n != n2) {
1147                 for (int k = i + 1; k &lt; names2.length; k++) {
1148                     names2[k] = names2[k].replaceName(n, n2);
1149                 }
1150             }
1151         }
1152 
1153         form = new LambdaForm(arity2, names2, result2);
1154         return putInCache(key, form);
1155     }
1156 
1157     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1158         assert(lambdaForm.isLoop(pos));
1159         int[] desc = BasicType.basicTypeOrds(localTypes);
1160         desc = Arrays.copyOf(desc, desc.length + 1);
1161         desc[desc.length - 1] = pos;
<span class="line-modified">1162         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);</span>
1163         LambdaForm form = getInCache(key);
1164         if (form != null) {
1165             return form;
1166         }
1167 
1168         // replace the null entry in the MHImpl.loop invocation with localTypes
1169         Name invokeLoop = lambdaForm.names[pos + 1];
1170         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1171         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1172         assert(args[0] == null);
1173         args[0] = localTypes;
1174 
1175         LambdaFormBuffer buf = buffer();
1176         buf.startEdit();
1177         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1178         form = buf.endEdit();
1179 
1180         return putInCache(key, form);
1181     }
1182 
</pre>
</td>
</tr>
</table>
<center><a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
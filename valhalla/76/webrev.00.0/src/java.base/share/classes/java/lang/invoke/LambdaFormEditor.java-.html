<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import sun.invoke.util.Wrapper;
  29 
  30 import java.lang.invoke.MethodHandles.Lookup;
  31 import java.lang.ref.SoftReference;
  32 import java.util.Arrays;
  33 import java.util.Collections;
  34 import java.util.Comparator;
  35 import java.util.TreeMap;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 
  38 import static java.lang.invoke.LambdaForm.*;
  39 import static java.lang.invoke.LambdaForm.BasicType.*;
  40 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  41 import static java.lang.invoke.MethodHandleImpl.NF_loop;
  42 
  43 /** Transforms on LFs.
  44  *  A lambda-form editor can derive new LFs from its base LF.
  45  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  46  *  To support this caching, a LF has an optional pointer to its editor.
  47  */
  48 class LambdaFormEditor {
  49     final LambdaForm lambdaForm;
  50 
  51     private LambdaFormEditor(LambdaForm lambdaForm) {
  52         this.lambdaForm = lambdaForm;
  53     }
  54 
  55     // Factory method.
  56     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  57         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  58         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  59 
  60         // Always use uncustomized version for editing.
  61         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  62         return new LambdaFormEditor(lambdaForm.uncustomize());
  63     }
  64 
  65     /** A description of a cached transform, possibly associated with the result of the transform.
  66      *  The logical content is a sequence of byte values, starting with a kind value.
  67      *  The sequence is unterminated, ending with an indefinite number of zero bytes.
  68      *  Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.
  69      */
  70     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  71         final long packedBytes;
  72         final byte[] fullBytes;
  73 
  74         // maybe add more for guard with test, catch exception, pointwise type conversions
  75         private static final byte
  76                 BIND_ARG = 1,
  77                 ADD_ARG = 2,
  78                 DUP_ARG = 3,
  79                 SPREAD_ARGS = 4,
  80                 FILTER_ARG = 5,
  81                 FILTER_RETURN = 6,
  82                 FILTER_RETURN_TO_ZERO = 7,
  83                 COLLECT_ARGS = 8,
  84                 COLLECT_ARGS_TO_VOID = 9,
  85                 COLLECT_ARGS_TO_ARRAY = 10,
  86                 FOLD_ARGS = 11,
  87                 FOLD_ARGS_TO_VOID = 12,
  88                 PERMUTE_ARGS = 13,
  89                 LOCAL_TYPES = 14,
  90                 FOLD_SELECT_ARGS = 15,
  91                 FOLD_SELECT_ARGS_TO_VOID = 16,
  92                 FILTER_SELECT_ARGS = 17,
  93                 REPEAT_FILTER_ARGS = 18;
  94 
  95         private static final boolean STRESS_TEST = false; // turn on to disable most packing
  96         private static final int
  97                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
  98                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
  99                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 100 
 101         private static long packedBytes(byte[] bytes) {
 102             if (bytes.length &gt; PACKED_BYTE_MAX_LENGTH)  return 0;
 103             long pb = 0;
 104             int bitset = 0;
 105             for (int i = 0; i &lt; bytes.length; i++) {
 106                 int b = bytes[i] &amp; 0xFF;
 107                 bitset |= b;
 108                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 109             }
 110             if (!inRange(bitset))
 111                 return 0;
 112             return pb;
 113         }
 114         private static long packedBytes(int b0, int b1) {
 115             assert(inRange(b0 | b1));
 116             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 117                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 118         }
 119         private static long packedBytes(int b0, int b1, int b2) {
 120             assert(inRange(b0 | b1 | b2));
 121             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 122                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 123                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE));
 124         }
 125         private static long packedBytes(int b0, int b1, int b2, int b3) {
 126             assert(inRange(b0 | b1 | b2 | b3));
 127             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 128                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 129                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 130                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 131         }
 132         private static boolean inRange(int bitset) {
 133             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 134             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 135         }
 136         private static byte[] fullBytes(int... byteValues) {
 137             byte[] bytes = new byte[byteValues.length];
 138             int i = 0;
 139             for (int bv : byteValues) {
 140                 bytes[i++] = bval(bv);
 141             }
 142             assert(packedBytes(bytes) == 0);
 143             return bytes;
 144         }
 145 
 146         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {
 147             super(result);
 148             this.packedBytes = packedBytes;
 149             this.fullBytes = fullBytes;
 150         }
 151         private Transform(long packedBytes) {
 152             this(packedBytes, null, null);
 153             assert(packedBytes != 0);
 154         }
 155         private Transform(byte[] fullBytes) {
 156             this(0, fullBytes, null);
 157         }
 158 
 159         private static byte bval(int b) {
 160             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte
 161             return (byte)b;
 162         }
 163         static Transform of(byte k, int b1) {
 164             byte b0 = bval(k);
 165             if (inRange(b0 | b1))
 166                 return new Transform(packedBytes(b0, b1));
 167             else
 168                 return new Transform(fullBytes(b0, b1));
 169         }
 170         static Transform of(byte b0, int b1, int b2) {
 171             if (inRange(b0 | b1 | b2))
 172                 return new Transform(packedBytes(b0, b1, b2));
 173             else
 174                 return new Transform(fullBytes(b0, b1, b2));
 175         }
 176         static Transform of(byte b0, int b1, int b2, int b3) {
 177             if (inRange(b0 | b1 | b2 | b3))
 178                 return new Transform(packedBytes(b0, b1, b2, b3));
 179             else
 180                 return new Transform(fullBytes(b0, b1, b2, b3));
 181         }
 182         private static final byte[] NO_BYTES = {};
 183         static Transform of(byte kind, int... b123) {
 184             return ofBothArrays(kind, b123, NO_BYTES);
 185         }
 186         static Transform of(byte kind, int b1, byte[] b234) {
 187             return ofBothArrays(kind, new int[]{ b1 }, b234);
 188         }
 189         static Transform of(byte kind, int b1, int b2, byte[] b345) {
 190             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);
 191         }
 192         private static Transform ofBothArrays(byte kind, int[] b123, byte[] b456) {
 193             byte[] fullBytes = new byte[1 + b123.length + b456.length];
 194             int i = 0;
 195             fullBytes[i++] = bval(kind);
 196             for (int bv : b123) {
 197                 fullBytes[i++] = bval(bv);
 198             }
 199             for (byte bv : b456) {
 200                 fullBytes[i++] = bv;
 201             }
 202             long packedBytes = packedBytes(fullBytes);
 203             if (packedBytes != 0)
 204                 return new Transform(packedBytes);
 205             else
 206                 return new Transform(fullBytes);
 207         }
 208 
 209         Transform withResult(LambdaForm result) {
 210             return new Transform(this.packedBytes, this.fullBytes, result);
 211         }
 212 
 213         @Override
 214         public boolean equals(Object obj) {
 215             return obj instanceof Transform &amp;&amp; equals((Transform)obj);
 216         }
 217         public boolean equals(Transform that) {
 218             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 219         }
 220         @Override
 221         public int hashCode() {
 222             if (packedBytes != 0) {
 223                 assert(fullBytes == null);
 224                 return Long.hashCode(packedBytes);
 225             }
 226             return Arrays.hashCode(fullBytes);
 227         }
 228         @Override
 229         public String toString() {
 230             StringBuilder buf = new StringBuilder();
 231             long bits = packedBytes;
 232             if (bits != 0) {
 233                 buf.append(&quot;(&quot;);
 234                 while (bits != 0) {
 235                     buf.append(bits &amp; PACKED_BYTE_MASK);
 236                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 237                     if (bits != 0)  buf.append(&quot;,&quot;);
 238                 }
 239                 buf.append(&quot;)&quot;);
 240             }
 241             if (fullBytes != null) {
 242                 buf.append(&quot;unpacked&quot;);
 243                 buf.append(Arrays.toString(fullBytes));
 244             }
 245             LambdaForm result = get();
 246             if (result != null) {
 247                 buf.append(&quot; result=&quot;);
 248                 buf.append(result);
 249             }
 250             return buf.toString();
 251         }
 252     }
 253 
 254     /** Find a previously cached transform equivalent to the given one, and return its result. */
 255     private LambdaForm getInCache(Transform key) {
 256         assert(key.get() == null);
 257         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 258         Object c = lambdaForm.transformCache;
 259         Transform k = null;
 260         if (c instanceof ConcurrentHashMap) {
 261             @SuppressWarnings(&quot;unchecked&quot;)
 262             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 263             k = m.get(key);
 264         } else if (c == null) {
 265             return null;
 266         } else if (c instanceof Transform) {
 267             // one-element cache avoids overhead of an array
 268             Transform t = (Transform)c;
 269             if (t.equals(key))  k = t;
 270         } else {
 271             Transform[] ta = (Transform[])c;
 272             for (int i = 0; i &lt; ta.length; i++) {
 273                 Transform t = ta[i];
 274                 if (t == null)  break;
 275                 if (t.equals(key)) { k = t; break; }
 276             }
 277         }
 278         assert(k == null || key.equals(k));
 279         return (k != null) ? k.get() : null;
 280     }
 281 
 282     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 283     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 284 
 285     /** Cache a transform with its result, and return that result.
 286      *  But if an equivalent transform has already been cached, return its result instead.
 287      */
 288     private LambdaForm putInCache(Transform key, LambdaForm form) {
 289         key = key.withResult(form);
 290         for (int pass = 0; ; pass++) {
 291             Object c = lambdaForm.transformCache;
 292             if (c instanceof ConcurrentHashMap) {
 293                 @SuppressWarnings(&quot;unchecked&quot;)
 294                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 295                 Transform k = m.putIfAbsent(key, key);
 296                 if (k == null) return form;
 297                 LambdaForm result = k.get();
 298                 if (result != null) {
 299                     return result;
 300                 } else {
 301                     if (m.replace(key, k, key)) {
 302                         return form;
 303                     } else {
 304                         continue;
 305                     }
 306                 }
 307             }
 308             assert(pass == 0);
 309             synchronized (lambdaForm) {
 310                 c = lambdaForm.transformCache;
 311                 if (c instanceof ConcurrentHashMap)
 312                     continue;
 313                 if (c == null) {
 314                     lambdaForm.transformCache = key;
 315                     return form;
 316                 }
 317                 Transform[] ta;
 318                 if (c instanceof Transform) {
 319                     Transform k = (Transform)c;
 320                     if (k.equals(key)) {
 321                         LambdaForm result = k.get();
 322                         if (result == null) {
 323                             lambdaForm.transformCache = key;
 324                             return form;
 325                         } else {
 326                             return result;
 327                         }
 328                     } else if (k.get() == null) { // overwrite stale entry
 329                         lambdaForm.transformCache = key;
 330                         return form;
 331                     }
 332                     // expand one-element cache to small array
 333                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 334                     ta[0] = k;
 335                     lambdaForm.transformCache = ta;
 336                 } else {
 337                     // it is already expanded
 338                     ta = (Transform[])c;
 339                 }
 340                 int len = ta.length;
 341                 int stale = -1;
 342                 int i;
 343                 for (i = 0; i &lt; len; i++) {
 344                     Transform k = ta[i];
 345                     if (k == null) {
 346                         break;
 347                     }
 348                     if (k.equals(key)) {
 349                         LambdaForm result = k.get();
 350                         if (result == null) {
 351                             ta[i] = key;
 352                             return form;
 353                         } else {
 354                             return result;
 355                         }
 356                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 357                         stale = i; // remember 1st stale entry index
 358                     }
 359                 }
 360                 if (i &lt; len || stale &gt;= 0) {
 361                     // just fall through to cache update
 362                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 363                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 364                     ta = Arrays.copyOf(ta, len);
 365                     lambdaForm.transformCache = ta;
 366                 } else {
 367                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 368                     for (Transform k : ta) {
 369                         m.put(k, k);
 370                     }
 371                     lambdaForm.transformCache = m;
 372                     // The second iteration will update for this query, concurrently.
 373                     continue;
 374                 }
 375                 int idx = (stale &gt;= 0) ? stale : i;
 376                 ta[idx] = key;
 377                 return form;
 378             }
 379         }
 380     }
 381 
 382     private LambdaFormBuffer buffer() {
 383         return new LambdaFormBuffer(lambdaForm);
 384     }
 385 
 386     /// Editing methods for method handles.  These need to have fast paths.
 387 
 388     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 389         return BoundMethodHandle.speciesDataFor(lambdaForm);
 390     }
 391 
 392     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 393         return oldSpeciesData().extendWith((byte) type.ordinal());
 394     }
 395 
 396     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
 397         assert(mh.speciesData() == oldSpeciesData());
 398         BasicType bt = L_TYPE;
 399         MethodType type2 = bindArgumentType(mh, pos, bt);
 400         LambdaForm form2 = bindArgumentForm(1+pos);
 401         return mh.copyWithExtendL(type2, form2, value);
 402     }
 403     BoundMethodHandle bindArgumentI(BoundMethodHandle mh, int pos, int value) {
 404         assert(mh.speciesData() == oldSpeciesData());
 405         BasicType bt = I_TYPE;
 406         MethodType type2 = bindArgumentType(mh, pos, bt);
 407         LambdaForm form2 = bindArgumentForm(1+pos);
 408         return mh.copyWithExtendI(type2, form2, value);
 409     }
 410 
 411     BoundMethodHandle bindArgumentJ(BoundMethodHandle mh, int pos, long value) {
 412         assert(mh.speciesData() == oldSpeciesData());
 413         BasicType bt = J_TYPE;
 414         MethodType type2 = bindArgumentType(mh, pos, bt);
 415         LambdaForm form2 = bindArgumentForm(1+pos);
 416         return mh.copyWithExtendJ(type2, form2, value);
 417     }
 418 
 419     BoundMethodHandle bindArgumentF(BoundMethodHandle mh, int pos, float value) {
 420         assert(mh.speciesData() == oldSpeciesData());
 421         BasicType bt = F_TYPE;
 422         MethodType type2 = bindArgumentType(mh, pos, bt);
 423         LambdaForm form2 = bindArgumentForm(1+pos);
 424         return mh.copyWithExtendF(type2, form2, value);
 425     }
 426 
 427     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 428         assert(mh.speciesData() == oldSpeciesData());
 429         BasicType bt = D_TYPE;
 430         MethodType type2 = bindArgumentType(mh, pos, bt);
 431         LambdaForm form2 = bindArgumentForm(1+pos);
 432         return mh.copyWithExtendD(type2, form2, value);
 433     }
 434 
 435     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 436         assert(mh.form.uncustomize() == lambdaForm);
 437         assert(mh.form.names[1+pos].type == bt);
 438         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 439         return mh.type().dropParameterTypes(pos, pos+1);
 440     }
 441 
 442     /// Editing methods for lambda forms.
 443     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 444 
 445     LambdaForm bindArgumentForm(int pos) {
 446         Transform key = Transform.of(Transform.BIND_ARG, pos);
 447         LambdaForm form = getInCache(key);
 448         if (form != null) {
 449             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 450             return form;
 451         }
 452         LambdaFormBuffer buf = buffer();
 453         buf.startEdit();
 454 
 455         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 456         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 457         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 458         Name newBaseAddress;
 459         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 460 
 461         if (pos != 0) {
 462             // The newly created LF will run with a different BMH.
 463             // Switch over any pre-existing BMH field references to the new BMH class.
 464             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 465             newBaseAddress = oldBaseAddress.withConstraint(newData);
 466             buf.renameParameter(0, newBaseAddress);
 467             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 468         } else {
 469             // cannot bind the MH arg itself, unless oldData is empty
 470             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 471             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 472             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 473             buf.insertParameter(0, newBaseAddress);
 474         }
 475 
 476         form = buf.endEdit();
 477         return putInCache(key, form);
 478     }
 479 
 480     LambdaForm addArgumentForm(int pos, BasicType type) {
 481         Transform key = Transform.of(Transform.ADD_ARG, pos, type.ordinal());
 482         LambdaForm form = getInCache(key);
 483         if (form != null) {
 484             assert(form.arity == lambdaForm.arity+1);
 485             assert(form.parameterType(pos) == type);
 486             return form;
 487         }
 488         LambdaFormBuffer buf = buffer();
 489         buf.startEdit();
 490 
 491         buf.insertParameter(pos, new Name(type));
 492 
 493         form = buf.endEdit();
 494         return putInCache(key, form);
 495     }
 496 
 497     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
 498         Transform key = Transform.of(Transform.DUP_ARG, srcPos, dstPos);
 499         LambdaForm form = getInCache(key);
 500         if (form != null) {
 501             assert(form.arity == lambdaForm.arity-1);
 502             return form;
 503         }
 504         LambdaFormBuffer buf = buffer();
 505         buf.startEdit();
 506 
 507         assert(lambdaForm.parameter(srcPos).constraint == null);
 508         assert(lambdaForm.parameter(dstPos).constraint == null);
 509         buf.replaceParameterByCopy(dstPos, srcPos);
 510 
 511         form = buf.endEdit();
 512         return putInCache(key, form);
 513     }
 514 
 515     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 516         Class&lt;?&gt; elementType = arrayType.getComponentType();
 517         Class&lt;?&gt; erasedArrayType = arrayType;
 518         if (!elementType.isPrimitive())
 519             erasedArrayType = Object[].class;
 520         BasicType bt = basicType(elementType);
 521         int elementTypeKey = bt.ordinal();
 522         if (bt.basicTypeClass() != elementType) {
 523             if (elementType.isPrimitive()) {
 524                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 525             }
 526         }
 527         Transform key = Transform.of(Transform.SPREAD_ARGS, pos, elementTypeKey, arrayLength);
 528         LambdaForm form = getInCache(key);
 529         if (form != null) {
 530             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 531             return form;
 532         }
 533         LambdaFormBuffer buf = buffer();
 534         buf.startEdit();
 535 
 536         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 537         assert(pos + arrayLength &lt;= lambdaForm.arity);
 538         assert(pos &gt; 0);  // cannot spread the MH arg itself
 539 
 540         Name spreadParam = new Name(L_TYPE);
 541         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 542                 spreadParam, arrayLength);
 543 
 544         // insert the new expressions
 545         int exprPos = lambdaForm.arity();
 546         buf.insertExpression(exprPos++, checkSpread);
 547         // adjust the arguments
 548         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 549         for (int i = 0; i &lt; arrayLength; i++) {
 550             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 551             buf.insertExpression(exprPos + i, loadArgument);
 552             buf.replaceParameterByCopy(pos + i, exprPos + i);
 553         }
 554         buf.insertParameter(pos, spreadParam);
 555 
 556         form = buf.endEdit();
 557         return putInCache(key, form);
 558     }
 559 
 560     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 561         int collectorArity = collectorType.parameterCount();
 562         boolean dropResult = (collectorType.returnType() == void.class);
 563         if (collectorArity == 1 &amp;&amp; !dropResult) {
 564             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 565         }
 566         byte[] newTypes = BasicType.basicTypesOrd(collectorType.parameterArray());
 567         byte kind = (dropResult
 568                 ? Transform.COLLECT_ARGS_TO_VOID
 569                 : Transform.COLLECT_ARGS);
 570         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
 571         Transform key = Transform.of(kind, pos, collectorArity, newTypes);
 572         LambdaForm form = getInCache(key);
 573         if (form != null) {
 574             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 575             return form;
 576         }
 577         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 578         return putInCache(key, form);
 579     }
 580 
 581     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 582         MethodType collectorType = arrayCollector.type();
 583         int collectorArity = collectorType.parameterCount();
 584         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 585         Class&lt;?&gt; arrayType = collectorType.returnType();
 586         Class&lt;?&gt; elementType = arrayType.getComponentType();
 587         BasicType argType = basicType(elementType);
 588         int argTypeKey = argType.ordinal();
 589         if (argType.basicTypeClass() != elementType) {
 590             // return null if it requires more metadata (like String[].class)
 591             if (!elementType.isPrimitive())
 592                 return null;
 593             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 594         }
 595         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
 596         byte kind = Transform.COLLECT_ARGS_TO_ARRAY;
 597         Transform key = Transform.of(kind, pos, collectorArity, argTypeKey);
 598         LambdaForm form = getInCache(key);
 599         if (form != null) {
 600             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 601             return form;
 602         }
 603         LambdaFormBuffer buf = buffer();
 604         buf.startEdit();
 605 
 606         assert(pos + 1 &lt;= lambdaForm.arity);
 607         assert(pos &gt; 0);  // cannot filter the MH arg itself
 608 
 609         Name[] newParams = new Name[collectorArity];
 610         for (int i = 0; i &lt; collectorArity; i++) {
 611             newParams[i] = new Name(pos + i, argType);
 612         }
 613         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 614                                         (Object[]) /*...*/ newParams);
 615 
 616         // insert the new expression
 617         int exprPos = lambdaForm.arity();
 618         buf.insertExpression(exprPos, callCombiner);
 619 
 620         // insert new arguments
 621         int argPos = pos + 1;  // skip result parameter
 622         for (Name newParam : newParams) {
 623             buf.insertParameter(argPos++, newParam);
 624         }
 625         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 626         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 627 
 628         form = buf.endEdit();
 629         return putInCache(key, form);
 630     }
 631 
 632     LambdaForm filterArgumentForm(int pos, BasicType newType) {
 633         Transform key = Transform.of(Transform.FILTER_ARG, pos, newType.ordinal());
 634         LambdaForm form = getInCache(key);
 635         if (form != null) {
 636             assert(form.arity == lambdaForm.arity);
 637             assert(form.parameterType(pos) == newType);
 638             return form;
 639         }
 640 
 641         BasicType oldType = lambdaForm.parameterType(pos);
 642         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 643                 newType.basicTypeClass());
 644         form = makeArgumentCombinationForm(pos, filterType, false, false);
 645         return putInCache(key, form);
 646     }
 647 
 648     /**
 649      * This creates a LF that will repeatedly invoke some unary filter function
 650      * at each of the given positions. This allows fewer LFs and BMH species
 651      * classes to be generated in typical cases compared to building up the form
 652      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 653      * no worse in the worst case.
 654      */
 655     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 656         assert (argPositions.length &gt; 1);
 657         byte[] keyArgs = new byte[argPositions.length + 2];
 658         keyArgs[0] = Transform.REPEAT_FILTER_ARGS;
 659         keyArgs[argPositions.length + 1] = (byte)newType.ordinal();
 660         for (int i = 0; i &lt; argPositions.length; i++) {
 661             keyArgs[i + 1] = (byte)argPositions[i];
 662         }
 663         Transform key = new Transform(keyArgs);
 664         LambdaForm form = getInCache(key);
 665         if (form != null) {
 666             assert(form.arity == lambdaForm.arity &amp;&amp;
 667                     formParametersMatch(form, newType, argPositions));
 668             return form;
 669         }
 670         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 671         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 672                 newType.basicTypeClass());
 673         form = makeRepeatedFilterForm(filterType, argPositions);
 674         assert (formParametersMatch(form, newType, argPositions));
 675         return putInCache(key, form);
 676     }
 677 
 678     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 679         for (int i : argPositions) {
 680             if (form.parameterType(i) != newType) {
 681                 return false;
 682             }
 683         }
 684         return true;
 685     }
 686 
 687     private LambdaForm makeRepeatedFilterForm(MethodType combinerType, int... positions) {
 688         assert (combinerType.parameterCount() == 1 &amp;&amp;
 689                 combinerType == combinerType.basicType() &amp;&amp;
 690                 combinerType.returnType() != void.class);
 691         LambdaFormBuffer buf = buffer();
 692         buf.startEdit();
 693 
 694         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 695         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 696 
 697         // The newly created LF will run with a different BMH.
 698         // Switch over any pre-existing BMH field references to the new BMH class.
 699         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 700         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 701         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 702         buf.renameParameter(0, newBaseAddress);
 703 
 704         // Insert the new expressions at the end
 705         int exprPos = lambdaForm.arity();
 706         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 707         buf.insertExpression(exprPos++, getCombiner);
 708 
 709         // After inserting expressions, we insert parameters in order
 710         // from lowest to highest, simplifying the calculation of where parameters
 711         // and expressions are
 712         var newParameters = new TreeMap&lt;Name, Integer&gt;(new Comparator&lt;&gt;() {
 713             public int compare(Name n1, Name n2) {
 714                 return n1.index - n2.index;
 715             }
 716         });
 717 
 718         // Insert combiner expressions in reverse order so that the invocation of
 719         // the resulting form will invoke the combiners in left-to-right order
 720         for (int i = positions.length - 1; i &gt;= 0; --i) {
 721             int pos = positions[i];
 722             assert (pos &gt; 0 &amp;&amp; pos &lt;= MethodType.MAX_JVM_ARITY &amp;&amp; pos &lt; lambdaForm.arity);
 723 
 724             Name newParameter = new Name(pos, basicType(combinerType.parameterType(0)));
 725             Object[] combinerArgs = {getCombiner, newParameter};
 726 
 727             Name callCombiner = new Name(combinerType, combinerArgs);
 728             buf.insertExpression(exprPos++, callCombiner);
 729             newParameters.put(newParameter, exprPos);
 730         }
 731 
 732         // Mix in new parameters from left to right in the buffer (this doesn&#39;t change
 733         // execution order
 734         int offset = 0;
 735         for (var entry : newParameters.entrySet()) {
 736             Name newParameter = entry.getKey();
 737             int from = entry.getValue();
 738             buf.insertParameter(newParameter.index() + 1 + offset, newParameter);
 739             buf.replaceParameterByCopy(newParameter.index() + offset, from + offset);
 740             offset++;
 741         }
 742         return buf.endEdit();
 743     }
 744 
 745 
 746     private LambdaForm makeArgumentCombinationForm(int pos,
 747                                                    MethodType combinerType,
 748                                                    boolean keepArguments, boolean dropResult) {
 749         LambdaFormBuffer buf = buffer();
 750         buf.startEdit();
 751         int combinerArity = combinerType.parameterCount();
 752         int resultArity = (dropResult ? 0 : 1);
 753 
 754         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 755         assert(pos + resultArity + (keepArguments ? combinerArity : 0) &lt;= lambdaForm.arity);
 756         assert(pos &gt; 0);  // cannot filter the MH arg itself
 757         assert(combinerType == combinerType.basicType());
 758         assert(combinerType.returnType() != void.class || dropResult);
 759 
 760         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 761         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 762 
 763         // The newly created LF will run with a different BMH.
 764         // Switch over any pre-existing BMH field references to the new BMH class.
 765         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 766         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 767         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 768         buf.renameParameter(0, newBaseAddress);
 769 
 770         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 771         Object[] combinerArgs = new Object[1 + combinerArity];
 772         combinerArgs[0] = getCombiner;
 773         Name[] newParams;
 774         if (keepArguments) {
 775             newParams = new Name[0];
 776             System.arraycopy(lambdaForm.names, pos + resultArity,
 777                              combinerArgs, 1, combinerArity);
 778         } else {
 779             newParams = new Name[combinerArity];
 780             for (int i = 0; i &lt; newParams.length; i++) {
 781                 newParams[i] = new Name(pos + i, basicType(combinerType.parameterType(i)));
 782             }
 783             System.arraycopy(newParams, 0,
 784                              combinerArgs, 1, combinerArity);
 785         }
 786         Name callCombiner = new Name(combinerType, combinerArgs);
 787 
 788         // insert the two new expressions
 789         int exprPos = lambdaForm.arity();
 790         buf.insertExpression(exprPos+0, getCombiner);
 791         buf.insertExpression(exprPos+1, callCombiner);
 792 
 793         // insert new arguments, if needed
 794         int argPos = pos + resultArity;  // skip result parameter
 795         for (Name newParam : newParams) {
 796             buf.insertParameter(argPos++, newParam);
 797         }
 798         assert(buf.lastIndexOf(callCombiner) == exprPos+1+newParams.length);
 799         if (!dropResult) {
 800             buf.replaceParameterByCopy(pos, exprPos+1+newParams.length);
 801         }
 802 
 803         return buf.endEdit();
 804     }
 805 
 806     private LambdaForm makeArgumentCombinationForm(int pos,
 807                                                    MethodType combinerType,
 808                                                    int[] argPositions,
 809                                                    boolean keepArguments,
 810                                                    boolean dropResult) {
 811         LambdaFormBuffer buf = buffer();
 812         buf.startEdit();
 813         int combinerArity = combinerType.parameterCount();
 814         assert(combinerArity == argPositions.length);
 815 
 816         int resultArity = (dropResult ? 0 : 1);
 817 
 818         assert(pos &lt;= lambdaForm.arity);
 819         assert(pos &gt; 0);  // cannot filter the MH arg itself
 820         assert(combinerType == combinerType.basicType());
 821         assert(combinerType.returnType() != void.class || dropResult);
 822 
 823         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 824         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 825 
 826         // The newly created LF will run with a different BMH.
 827         // Switch over any pre-existing BMH field references to the new BMH class.
 828         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 829         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 830         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 831         buf.renameParameter(0, newBaseAddress);
 832 
 833         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 834         Object[] combinerArgs = new Object[1 + combinerArity];
 835         combinerArgs[0] = getCombiner;
 836         Name newParam = null;
 837         if (keepArguments) {
 838             for (int i = 0; i &lt; combinerArity; i++) {
 839                 combinerArgs[i + 1] = lambdaForm.parameter(1 + argPositions[i]);
 840                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 841             }
 842         } else {
 843             newParam = new Name(pos, BasicType.basicType(combinerType.returnType()));
 844             for (int i = 0; i &lt; combinerArity; i++) {
 845                 int argPos = 1 + argPositions[i];
 846                 if (argPos == pos) {
 847                     combinerArgs[i + 1] = newParam;
 848                 } else {
 849                     combinerArgs[i + 1] = lambdaForm.parameter(argPos);
 850                 }
 851                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 852             }
 853         }
 854         Name callCombiner = new Name(combinerType, combinerArgs);
 855 
 856         // insert the two new expressions
 857         int exprPos = lambdaForm.arity();
 858         buf.insertExpression(exprPos+0, getCombiner);
 859         buf.insertExpression(exprPos+1, callCombiner);
 860 
 861         // insert new arguments, if needed
 862         int argPos = pos + resultArity;  // skip result parameter
 863         if (newParam != null) {
 864             buf.insertParameter(argPos++, newParam);
 865             exprPos++;
 866         }
 867         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 868         if (!dropResult) {
 869             buf.replaceParameterByCopy(pos, exprPos+1);
 870         }
 871 
 872         return buf.endEdit();
 873     }
 874 
 875     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
 876         byte kind = (constantZero ? Transform.FILTER_RETURN_TO_ZERO : Transform.FILTER_RETURN);
 877         Transform key = Transform.of(kind, newType.ordinal());
 878         LambdaForm form = getInCache(key);
 879         if (form != null) {
 880             assert(form.arity == lambdaForm.arity);
 881             assert(form.returnType() == newType);
 882             return form;
 883         }
 884         LambdaFormBuffer buf = buffer();
 885         buf.startEdit();
 886 
 887         int insPos = lambdaForm.names.length;
 888         Name callFilter;
 889         if (constantZero) {
 890             // Synthesize a constant zero value for the given type.
 891             if (newType == V_TYPE)
 892                 callFilter = null;
 893             else
 894                 callFilter = new Name(constantZero(newType));
 895         } else {
 896             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 897             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 898 
 899             // The newly created LF will run with a different BMH.
 900             // Switch over any pre-existing BMH field references to the new BMH class.
 901             Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 902             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 903             Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 904             buf.renameParameter(0, newBaseAddress);
 905 
 906             Name getFilter = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 907             buf.insertExpression(insPos++, getFilter);
 908             BasicType oldType = lambdaForm.returnType();
 909             if (oldType == V_TYPE) {
 910                 MethodType filterType = MethodType.methodType(newType.basicTypeClass());
 911                 callFilter = new Name(filterType, getFilter);
 912             } else {
 913                 MethodType filterType = MethodType.methodType(newType.basicTypeClass(), oldType.basicTypeClass());
 914                 callFilter = new Name(filterType, getFilter, lambdaForm.names[lambdaForm.result]);
 915             }
 916         }
 917 
 918         if (callFilter != null)
 919             buf.insertExpression(insPos++, callFilter);
 920         buf.setResult(callFilter);
 921 
 922         form = buf.endEdit();
 923         return putInCache(key, form);
 924     }
 925 
 926     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
 927         int combinerArity = combinerType.parameterCount();
 928         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);
 929         Transform key = Transform.of(kind, foldPos, combinerArity);
 930         LambdaForm form = getInCache(key);
 931         if (form != null) {
 932             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));
 933             return form;
 934         }
 935         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
 936         return putInCache(key, form);
 937     }
 938 
 939     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
 940         byte kind = (dropResult ? Transform.FOLD_SELECT_ARGS_TO_VOID
 941                                 : Transform.FOLD_SELECT_ARGS);
 942         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);
 943         keyArgs[argPositions.length] = foldPos;
 944         Transform key = Transform.of(kind, keyArgs);
 945         LambdaForm form = getInCache(key);
 946         if (form != null) {
 947             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_SELECT_ARGS ? 1 : 0));
 948             return form;
 949         }
 950         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
 951         return putInCache(key, form);
 952     }
 953 
 954     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
 955         byte kind = Transform.FILTER_SELECT_ARGS;
 956         int[] keyArgs = Arrays.copyOf(argPositions, argPositions.length + 1);
 957         keyArgs[argPositions.length] = filterPos;
 958         Transform key = Transform.of(kind, keyArgs);
 959         LambdaForm form = getInCache(key);
 960         if (form != null) {
 961             assert(form.arity == lambdaForm.arity);
 962             return form;
 963         }
 964         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
 965         return putInCache(key, form);
 966     }
 967 
 968     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
 969         assert(skip == 1);  // skip only the leading MH argument, names[0]
 970         int length = lambdaForm.names.length;
 971         int outArgs = reorder.length;
 972         int inTypes = 0;
 973         boolean nullPerm = true;
 974         for (int i = 0; i &lt; reorder.length; i++) {
 975             int inArg = reorder[i];
 976             if (inArg != i)  nullPerm = false;
 977             inTypes = Math.max(inTypes, inArg+1);
 978         }
 979         assert(skip + reorder.length == lambdaForm.arity);
 980         if (nullPerm)  return lambdaForm;  // do not bother to cache
 981         Transform key = Transform.of(Transform.PERMUTE_ARGS, reorder);
 982         LambdaForm form = getInCache(key);
 983         if (form != null) {
 984             assert(form.arity == skip+inTypes) : form;
 985             return form;
 986         }
 987 
 988         BasicType[] types = new BasicType[inTypes];
 989         for (int i = 0; i &lt; outArgs; i++) {
 990             int inArg = reorder[i];
 991             types[inArg] = lambdaForm.names[skip + i].type;
 992         }
 993         assert (skip + outArgs == lambdaForm.arity);
 994         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
 995         int pos = 0;
 996         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
 997             pos += 1;
 998         }
 999         Name[] names2 = new Name[length - outArgs + inTypes];
1000         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1001         int bodyLength = length - lambdaForm.arity;
1002         System.arraycopy(lambdaForm.names, skip + outArgs, names2, skip + inTypes, bodyLength);
1003         int arity2 = names2.length - bodyLength;
1004         int result2 = lambdaForm.result;
1005         if (result2 &gt;= skip) {
1006             if (result2 &lt; skip + outArgs) {
1007                 result2 = reorder[result2 - skip] + skip;
1008             } else {
1009                 result2 = result2 - outArgs + inTypes;
1010             }
1011         }
1012         for (int j = pos; j &lt; outArgs; j++) {
1013             Name n = lambdaForm.names[skip + j];
1014             int i = reorder[j];
1015             Name n2 = names2[skip + i];
1016             if (n2 == null) {
1017                 names2[skip + i] = n2 = new Name(types[i]);
1018             } else {
1019                 assert (n2.type == types[i]);
1020             }
1021             for (int k = arity2; k &lt; names2.length; k++) {
1022                 names2[k] = names2[k].replaceName(n, n2);
1023             }
1024         }
1025         for (int i = skip + pos; i &lt; arity2; i++) {
1026             if (names2[i] == null) {
1027                 names2[i] = argument(i, types[i - skip]);
1028             }
1029         }
1030         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1031             int i = j - lambdaForm.arity + arity2;
1032             Name n = lambdaForm.names[j];
1033             Name n2 = names2[i];
1034             if (n != n2) {
1035                 for (int k = i + 1; k &lt; names2.length; k++) {
1036                     names2[k] = names2[k].replaceName(n, n2);
1037                 }
1038             }
1039         }
1040 
1041         form = new LambdaForm(arity2, names2, result2);
1042         return putInCache(key, form);
1043     }
1044 
1045     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1046         assert(lambdaForm.isLoop(pos));
1047         int[] desc = BasicType.basicTypeOrds(localTypes);
1048         desc = Arrays.copyOf(desc, desc.length + 1);
1049         desc[desc.length - 1] = pos;
1050         Transform key = Transform.of(Transform.LOCAL_TYPES, desc);
1051         LambdaForm form = getInCache(key);
1052         if (form != null) {
1053             return form;
1054         }
1055 
1056         // replace the null entry in the MHImpl.loop invocation with localTypes
1057         Name invokeLoop = lambdaForm.names[pos + 1];
1058         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1059         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1060         assert(args[0] == null);
1061         args[0] = localTypes;
1062 
1063         LambdaFormBuffer buf = buffer();
1064         buf.startEdit();
1065         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1066         form = buf.endEdit();
1067 
1068         return putInCache(key, form);
1069     }
1070 
1071     static boolean permutedTypesMatch(int[] reorder, BasicType[] types, Name[] names, int skip) {
1072         for (int i = 0; i &lt; reorder.length; i++) {
1073             assert (names[skip + i].isParam());
1074             assert (names[skip + i].type == types[reorder[i]]);
1075         }
1076         return true;
1077     }
1078 }
    </pre>
  </body>
</html>
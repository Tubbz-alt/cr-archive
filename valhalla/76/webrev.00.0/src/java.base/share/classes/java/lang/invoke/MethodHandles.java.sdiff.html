<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaFormEditor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.VM;
  31 import jdk.internal.module.IllegalAccessLogger;
  32 import jdk.internal.org.objectweb.asm.ClassReader;
  33 import jdk.internal.org.objectweb.asm.Opcodes;

  34 import jdk.internal.reflect.CallerSensitive;
  35 import jdk.internal.reflect.Reflection;
  36 import jdk.internal.vm.annotation.ForceInline;
  37 import sun.invoke.util.ValueConversions;
  38 import sun.invoke.util.VerifyAccess;
  39 import sun.invoke.util.Wrapper;
  40 import sun.reflect.misc.ReflectUtil;
  41 import sun.security.util.SecurityConstants;
  42 
  43 import java.lang.invoke.LambdaForm.BasicType;
  44 import java.lang.reflect.Constructor;
  45 import java.lang.reflect.Field;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.ReflectPermission;
  50 import java.nio.ByteOrder;
  51 import java.security.ProtectionDomain;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
</pre>
<hr />
<pre>
1644          * that the lookup object was created by a caller in the runtime package (or derived
1645          * from a lookup originally created by suitably privileged code to a target class in
1646          * the runtime package). &lt;/p&gt;
1647          *
1648          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1649          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1650          * same package as the lookup class. &lt;/p&gt;
1651          *
1652          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1653          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1654          * Specification&lt;/em&gt;. &lt;/p&gt;
1655          *
1656          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1657          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1658          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1659          *
1660          * @param bytes the class bytes
1661          * @return the {@code Class} object for the class
1662          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
1663          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
<span class="line-modified">1664          * @throws IllegalArgumentException the bytes are for a class in a different package</span>
<span class="line-modified">1665          * to the lookup class</span>

1666          * @throws VerifyError if the newly created class cannot be verified
1667          * @throws LinkageError if the newly created class cannot be linked for any other reason
1668          * @throws SecurityException if a security manager is present and it
1669          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1670          * @throws NullPointerException if {@code bytes} is {@code null}
1671          * @since 9
1672          * @spec JPMS
1673          * @see Lookup#privateLookupIn
1674          * @see Lookup#dropLookupMode
1675          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1676          */
1677         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
1678             ensureDefineClassPermission();
1679             if ((lookupModes() &amp; PACKAGE) == 0)
1680                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
1681             return makeClassDefiner(bytes.clone()).defineClass(false);
1682         }
1683 
1684         private void ensureDefineClassPermission() {
1685             if (allowedModes == TRUSTED)  return;
</pre>
<hr />
<pre>
1906          * &lt;/ul&gt;
1907          *
1908          * &lt;p&gt; A hidden class or interface may be serializable, but this requires a custom
1909          * serialization mechanism in order to ensure that instances are properly serialized
1910          * and deserialized. The default serialization mechanism supports only classes and
1911          * interfaces that are discoverable by their class name.
1912          *
1913          * @param bytes the bytes that make up the class data,
1914          * in the format of a valid {@code class} file as defined by
1915          * &lt;cite&gt;The Java Virtual Machine Specification&lt;/cite&gt;.
1916          * @param initialize if {@code true} the class will be initialized.
1917          * @param options {@linkplain ClassOption class options}
1918          * @return the {@code Lookup} object on the hidden class
1919          *
1920          * @throws IllegalAccessException if this {@code Lookup} does not have
1921          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1922          * @throws SecurityException if a security manager is present and it
1923          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1924          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1925          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
<span class="line-modified">1926          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-modified">1927          * {@bytes} denotes a class in a different package than the lookup class</span>

1928          * @throws IncompatibleClassChangeError if the class or interface named as
1929          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1930          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
1931          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
1932          * {@code C} is {@code C} itself
1933          * @throws VerifyError if the newly created class cannot be verified
1934          * @throws LinkageError if the newly created class cannot be linked for any other reason
1935          * @throws NullPointerException if any parameter is {@code null}
1936          *
1937          * @since 15
1938          * @see Class#isHidden()
1939          * @jvms 4.2.1 Binary Class and Interface Names
1940          * @jvms 4.2.2 Unqualified Names
1941          * @jvms 4.7.28 The {@code NestHost} Attribute
1942          * @jvms 4.7.29 The {@code NestMembers} Attribute
1943          * @jvms 5.4.3.1 Class and Interface Resolution
1944          * @jvms 5.4.4 Access Control
1945          * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation
1946          * @jvms 5.4 Linking
1947          * @jvms 5.5 Initialization
</pre>
<hr />
<pre>
1970          * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}
1971          * as if the hidden class has a private static final unnamed field whose value
1972          * is initialized to {@code classData} right before the class initializer is
1973          * executed.  The newly created class is linked and initialized by the Java
1974          * Virtual Machine.
1975          *
1976          * &lt;p&gt; The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}
1977          * method can be used to retrieve the {@code classData}.
1978          *
1979          * @param bytes     the class bytes
1980          * @param classData pre-initialized class data
1981          * @param options   {@linkplain ClassOption class options}
1982          * @return the {@code Lookup} object on the hidden class
1983          *
1984          * @throws IllegalAccessException if this {@code Lookup} does not have
1985          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1986          * @throws SecurityException if a security manager is present and it
1987          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1988          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1989          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
<span class="line-modified">1990          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-modified">1991          * {@bytes} denotes a class in a different package than the lookup class</span>

1992          * @throws IncompatibleClassChangeError if the class or interface named as
1993          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1994          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
1995          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
1996          * {@code C} is {@code C} itself
1997          * @throws VerifyError if the newly created class cannot be verified
1998          * @throws LinkageError if the newly created class cannot be linked for any other reason
1999          * @throws NullPointerException if any parameter is {@code null}
2000          *
2001          * @since 15
2002          * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
2003          * @see Class#isHidden()
2004          */
2005         /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)
2006                 throws IllegalAccessException
2007         {
2008             Objects.requireNonNull(bytes);
2009             Objects.requireNonNull(classData);
2010             Objects.requireNonNull(options);
2011 
2012             ensureDefineClassPermission();
2013             if (!hasFullPrivilegeAccess()) {
2014                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);
2015             }
2016 
2017             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)
2018                        .defineClassAsLookup(true, classData);
2019         }
2020 
<span class="line-modified">2021         /*</span>
<span class="line-modified">2022          * Validates the given bytes to be a class or interface and the class name</span>
<span class="line-modified">2023          * is in the same package as the lookup class.</span>
<span class="line-modified">2024          *</span>
<span class="line-modified">2025          * This method returns the class name.</span>
<span class="line-modified">2026          */</span>
<span class="line-modified">2027         private String validateAndGetClassName(byte[] bytes) {</span>
<span class="line-modified">2028             try {</span>
<span class="line-modified">2029                 ClassReader reader = new ClassReader(bytes);</span>
<span class="line-modified">2030                 if ((reader.getAccess() &amp; Opcodes.ACC_MODULE) != 0) {</span>

















































2031                     throw newIllegalArgumentException(&quot;Not a class or interface: ACC_MODULE flag is set&quot;);
2032                 }
<span class="line-modified">2033                 String name = reader.getClassName().replace(&#39;/&#39;, &#39;.&#39;);</span>

2034                 int index = name.lastIndexOf(&#39;.&#39;);
2035                 String pn = (index == -1) ? &quot;&quot; : name.substring(0, index);
<span class="line-modified">2036                 if (!pn.equals(lookupClass.getPackageName())) {</span>
<span class="line-modified">2037                     throw newIllegalArgumentException(name + &quot; not in same package as lookup class: &quot; +</span>
<span class="line-removed">2038                             lookupClass.getName());</span>
2039                 }
<span class="line-modified">2040                 return name;</span>
<span class="line-modified">2041             } catch (IllegalArgumentException e) {</span>
<span class="line-modified">2042                 throw e;</span>
<span class="line-modified">2043             } catch (RuntimeException e) {</span>
<span class="line-modified">2044                 // ASM exceptions are poorly specified</span>
<span class="line-modified">2045                 ClassFormatError cfe = new ClassFormatError();</span>
<span class="line-modified">2046                 cfe.initCause(e);</span>
<span class="line-modified">2047                 throw cfe;</span>




2048             }
<span class="line-modified">2049         }</span>






2050 
2051 
2052         /*
2053          * Returns a ClassDefiner that creates a {@code Class} object of a normal class
2054          * from the given bytes.
2055          *
2056          * Caller should make a defensive copy of the arguments if needed
2057          * before calling this factory method.
2058          *
2059          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2060          * {@bytes} denotes a class in a different package than the lookup class
2061          */
2062         private ClassDefiner makeClassDefiner(byte[] bytes) {
<span class="line-modified">2063             return new ClassDefiner(this, validateAndGetClassName(bytes), bytes, STRONG_LOADER_LINK);</span>

2064         }
2065 
2066         /**
2067          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2068          * from the given bytes.  The name must be in the same package as the lookup class.
2069          *
2070          * Caller should make a defensive copy of the arguments if needed
2071          * before calling this factory method.
2072          *
2073          * @param bytes   class bytes
2074          * @return ClassDefiner that defines a hidden class of the given bytes.
2075          *
2076          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2077          * {@bytes} denotes a class in a different package than the lookup class
2078          */
2079         ClassDefiner makeHiddenClassDefiner(byte[] bytes) {
<span class="line-modified">2080             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, Set.of(), false);</span>

2081         }
2082 
2083         /**
2084          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2085          * from the given bytes and options.
2086          * The name must be in the same package as the lookup class.
2087          *
2088          * Caller should make a defensive copy of the arguments if needed
2089          * before calling this factory method.
2090          *
2091          * @param bytes   class bytes
2092          * @param options class options
2093          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2094          * @return ClassDefiner that defines a hidden class of the given bytes and options
2095          *
2096          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2097          * {@bytes} denotes a class in a different package than the lookup class
2098          */
2099         ClassDefiner makeHiddenClassDefiner(byte[] bytes,
2100                                             Set&lt;ClassOption&gt; options,
2101                                             boolean accessVmAnnotations) {
<span class="line-modified">2102             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, options, accessVmAnnotations);</span>

2103         }
2104 
2105         /**
2106          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2107          * from the given bytes.  No package name check on the given name.
2108          *
2109          * @param name    fully-qualified name that specifies the prefix of the hidden class
2110          * @param bytes   class bytes
2111          * @return ClassDefiner that defines a hidden class of the given bytes.
2112          */
2113         ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {
<span class="line-modified">2114             return makeHiddenClassDefiner(name, bytes, Set.of(), false);</span>

2115         }
2116 
2117         /**
2118          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
<span class="line-modified">2119          * from the given bytes and options.  No package name check on the given name.</span>
2120          *
<span class="line-modified">2121          * @param name the name of the class and the name in the class bytes is ignored.</span>
<span class="line-removed">2122          * @param bytes class bytes</span>
2123          * @param options class options
2124          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2125          */
<span class="line-modified">2126         ClassDefiner makeHiddenClassDefiner(String name,</span>
<span class="line-modified">2127                                             byte[] bytes,</span>
<span class="line-modified">2128                                             Set&lt;ClassOption&gt; options,</span>
<span class="line-removed">2129                                             boolean accessVmAnnotations) {</span>
2130             int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);
2131             if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {
2132                 // jdk.internal.vm.annotations are permitted for classes
2133                 // defined to boot loader and platform loader
2134                 flags |= ACCESS_VM_ANNOTATIONS;
2135             }
2136 
<span class="line-modified">2137             return new ClassDefiner(this, name, bytes, flags);</span>
2138         }
2139 
2140         static class ClassDefiner {
2141             private final Lookup lookup;
2142             private final String name;
2143             private final byte[] bytes;
2144             private final int classFlags;
2145 
<span class="line-modified">2146             private ClassDefiner(Lookup lookup, String name, byte[] bytes, int flags) {</span>
2147                 assert ((flags &amp; HIDDEN_CLASS) != 0 || (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK);
2148                 this.lookup = lookup;
<span class="line-modified">2149                 this.bytes = bytes;</span>

2150                 this.classFlags = flags;
<span class="line-removed">2151                 this.name = name;</span>
2152             }
2153 
2154             String className() {
2155                 return name;
2156             }
2157 
2158             Class&lt;?&gt; defineClass(boolean initialize) {
2159                 return defineClass(initialize, null);
2160             }
2161 
2162             Lookup defineClassAsLookup(boolean initialize) {
2163                 Class&lt;?&gt; c = defineClass(initialize, null);
2164                 return new Lookup(c, null, FULL_POWER_MODES);
2165             }
2166 
2167             /**
2168              * Defines the class of the given bytes and the given classData.
2169              * If {@code initialize} parameter is true, then the class will be initialized.
2170              *
2171              * @param initialize true if the class to be initialized
</pre>
<hr />
<pre>
5492         MethodType targetType = target.type();
5493         MethodType filterType = filter.type();
5494         filterReturnValueChecks(targetType, filterType);
5495         BoundMethodHandle result = target.rebind();
5496         BasicType rtype = BasicType.basicType(filterType.returnType());
5497         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
5498         MethodType newType = targetType.changeReturnType(filterType.returnType());
5499         result = result.copyWithExtendL(newType, lform, filter);
5500         return result;
5501     }
5502 
5503     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
5504         Class&lt;?&gt; rtype = targetType.returnType();
5505         int filterValues = filterType.parameterCount();
5506         if (filterValues == 0
5507                 ? (rtype != void.class)
5508                 : (rtype != filterType.parameterType(0) || filterValues != 1))
5509             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
5510     }
5511 


































5512     /**
5513      * Adapts a target method handle by pre-processing
5514      * some of its arguments, and then calling the target with
5515      * the result of the pre-processing, inserted into the original
5516      * sequence of arguments.
5517      * &lt;p&gt;
5518      * The pre-processing is performed by {@code combiner}, a second method handle.
5519      * Of the arguments passed to the adapter, the first {@code N} arguments
5520      * are copied to the combiner, which is then called.
5521      * (Here, {@code N} is defined as the parameter count of the combiner.)
5522      * After this, control passes to the target, with any result
5523      * from the combiner inserted before the original {@code N} incoming
5524      * arguments.
5525      * &lt;p&gt;
5526      * If the combiner returns a value, the first parameter type of the target
5527      * must be identical with the return type of the combiner, and the next
5528      * {@code N} parameter types of the target must exactly match the parameters
5529      * of the combiner.
5530      * &lt;p&gt;
5531      * If the combiner has a void return, no result will be inserted,
</pre>
</td>
<td>
<hr />
<pre>
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.VM;
  31 import jdk.internal.module.IllegalAccessLogger;
  32 import jdk.internal.org.objectweb.asm.ClassReader;
  33 import jdk.internal.org.objectweb.asm.Opcodes;
<span class="line-added">  34 import jdk.internal.org.objectweb.asm.Type;</span>
  35 import jdk.internal.reflect.CallerSensitive;
  36 import jdk.internal.reflect.Reflection;
  37 import jdk.internal.vm.annotation.ForceInline;
  38 import sun.invoke.util.ValueConversions;
  39 import sun.invoke.util.VerifyAccess;
  40 import sun.invoke.util.Wrapper;
  41 import sun.reflect.misc.ReflectUtil;
  42 import sun.security.util.SecurityConstants;
  43 
  44 import java.lang.invoke.LambdaForm.BasicType;
  45 import java.lang.reflect.Constructor;
  46 import java.lang.reflect.Field;
  47 import java.lang.reflect.Member;
  48 import java.lang.reflect.Method;
  49 import java.lang.reflect.Modifier;
  50 import java.lang.reflect.ReflectPermission;
  51 import java.nio.ByteOrder;
  52 import java.security.ProtectionDomain;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
</pre>
<hr />
<pre>
1645          * that the lookup object was created by a caller in the runtime package (or derived
1646          * from a lookup originally created by suitably privileged code to a target class in
1647          * the runtime package). &lt;/p&gt;
1648          *
1649          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1650          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1651          * same package as the lookup class. &lt;/p&gt;
1652          *
1653          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1654          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1655          * Specification&lt;/em&gt;. &lt;/p&gt;
1656          *
1657          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1658          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1659          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1660          *
1661          * @param bytes the class bytes
1662          * @return the {@code Class} object for the class
1663          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
1664          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
<span class="line-modified">1665          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package</span>
<span class="line-modified">1666          * than the lookup class or {@code bytes} is not a class or interface</span>
<span class="line-added">1667          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)</span>
1668          * @throws VerifyError if the newly created class cannot be verified
1669          * @throws LinkageError if the newly created class cannot be linked for any other reason
1670          * @throws SecurityException if a security manager is present and it
1671          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1672          * @throws NullPointerException if {@code bytes} is {@code null}
1673          * @since 9
1674          * @spec JPMS
1675          * @see Lookup#privateLookupIn
1676          * @see Lookup#dropLookupMode
1677          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1678          */
1679         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
1680             ensureDefineClassPermission();
1681             if ((lookupModes() &amp; PACKAGE) == 0)
1682                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
1683             return makeClassDefiner(bytes.clone()).defineClass(false);
1684         }
1685 
1686         private void ensureDefineClassPermission() {
1687             if (allowedModes == TRUSTED)  return;
</pre>
<hr />
<pre>
1908          * &lt;/ul&gt;
1909          *
1910          * &lt;p&gt; A hidden class or interface may be serializable, but this requires a custom
1911          * serialization mechanism in order to ensure that instances are properly serialized
1912          * and deserialized. The default serialization mechanism supports only classes and
1913          * interfaces that are discoverable by their class name.
1914          *
1915          * @param bytes the bytes that make up the class data,
1916          * in the format of a valid {@code class} file as defined by
1917          * &lt;cite&gt;The Java Virtual Machine Specification&lt;/cite&gt;.
1918          * @param initialize if {@code true} the class will be initialized.
1919          * @param options {@linkplain ClassOption class options}
1920          * @return the {@code Lookup} object on the hidden class
1921          *
1922          * @throws IllegalAccessException if this {@code Lookup} does not have
1923          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1924          * @throws SecurityException if a security manager is present and it
1925          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1926          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1927          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
<span class="line-modified">1928          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package</span>
<span class="line-modified">1929          * than the lookup class or {@code bytes} is not a class or interface</span>
<span class="line-added">1930          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)</span>
1931          * @throws IncompatibleClassChangeError if the class or interface named as
1932          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1933          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
1934          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
1935          * {@code C} is {@code C} itself
1936          * @throws VerifyError if the newly created class cannot be verified
1937          * @throws LinkageError if the newly created class cannot be linked for any other reason
1938          * @throws NullPointerException if any parameter is {@code null}
1939          *
1940          * @since 15
1941          * @see Class#isHidden()
1942          * @jvms 4.2.1 Binary Class and Interface Names
1943          * @jvms 4.2.2 Unqualified Names
1944          * @jvms 4.7.28 The {@code NestHost} Attribute
1945          * @jvms 4.7.29 The {@code NestMembers} Attribute
1946          * @jvms 5.4.3.1 Class and Interface Resolution
1947          * @jvms 5.4.4 Access Control
1948          * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation
1949          * @jvms 5.4 Linking
1950          * @jvms 5.5 Initialization
</pre>
<hr />
<pre>
1973          * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}
1974          * as if the hidden class has a private static final unnamed field whose value
1975          * is initialized to {@code classData} right before the class initializer is
1976          * executed.  The newly created class is linked and initialized by the Java
1977          * Virtual Machine.
1978          *
1979          * &lt;p&gt; The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}
1980          * method can be used to retrieve the {@code classData}.
1981          *
1982          * @param bytes     the class bytes
1983          * @param classData pre-initialized class data
1984          * @param options   {@linkplain ClassOption class options}
1985          * @return the {@code Lookup} object on the hidden class
1986          *
1987          * @throws IllegalAccessException if this {@code Lookup} does not have
1988          * {@linkplain #hasFullPrivilegeAccess() full privilege} access
1989          * @throws SecurityException if a security manager is present and it
1990          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1991          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
1992          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
<span class="line-modified">1993          * @throws IllegalArgumentException if {@code bytes} denotes a class in a different package</span>
<span class="line-modified">1994          * than the lookup class or {@code bytes} is not a class or interface</span>
<span class="line-added">1995          * ({@code ACC_MODULE} flag is set in the value of the {@code access_flags} item)</span>
1996          * @throws IncompatibleClassChangeError if the class or interface named as
1997          * the direct superclass of {@code C} is in fact an interface, or if any of the classes
1998          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
1999          * @throws ClassCircularityError if any of the superclasses or superinterfaces of
2000          * {@code C} is {@code C} itself
2001          * @throws VerifyError if the newly created class cannot be verified
2002          * @throws LinkageError if the newly created class cannot be linked for any other reason
2003          * @throws NullPointerException if any parameter is {@code null}
2004          *
2005          * @since 15
2006          * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
2007          * @see Class#isHidden()
2008          */
2009         /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)
2010                 throws IllegalAccessException
2011         {
2012             Objects.requireNonNull(bytes);
2013             Objects.requireNonNull(classData);
2014             Objects.requireNonNull(options);
2015 
2016             ensureDefineClassPermission();
2017             if (!hasFullPrivilegeAccess()) {
2018                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);
2019             }
2020 
2021             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)
2022                        .defineClassAsLookup(true, classData);
2023         }
2024 
<span class="line-modified">2025         static class ClassFile {</span>
<span class="line-modified">2026             final String name;</span>
<span class="line-modified">2027             final int accessFlags;</span>
<span class="line-modified">2028             final byte[] bytes;</span>
<span class="line-modified">2029             ClassFile(String name, int accessFlags, byte[] bytes) {</span>
<span class="line-modified">2030                 this.name = name;</span>
<span class="line-modified">2031                 this.accessFlags = accessFlags;</span>
<span class="line-modified">2032                 this.bytes = bytes;</span>
<span class="line-modified">2033             }</span>
<span class="line-modified">2034 </span>
<span class="line-added">2035             static ClassFile newInstanceNoCheck(String name, byte[] bytes) {</span>
<span class="line-added">2036                 return new ClassFile(name, 0, bytes);</span>
<span class="line-added">2037             }</span>
<span class="line-added">2038 </span>
<span class="line-added">2039             /**</span>
<span class="line-added">2040              * This method checks the class file version and the structure of `this_class`.</span>
<span class="line-added">2041              * and checks if the bytes is a class or interface (ACC_MODULE flag not set)</span>
<span class="line-added">2042              * that is in the named package.</span>
<span class="line-added">2043              *</span>
<span class="line-added">2044              * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags</span>
<span class="line-added">2045              * or the class is not in the given package name.</span>
<span class="line-added">2046              */</span>
<span class="line-added">2047             static ClassFile newInstance(byte[] bytes, String pkgName) {</span>
<span class="line-added">2048                 int magic = readInt(bytes, 0);</span>
<span class="line-added">2049                 if (magic != 0xCAFEBABE) {</span>
<span class="line-added">2050                     throw new ClassFormatError(&quot;Incompatible magic value: &quot; + magic);</span>
<span class="line-added">2051                 }</span>
<span class="line-added">2052                 int minor = readUnsignedShort(bytes, 4);</span>
<span class="line-added">2053                 int major = readUnsignedShort(bytes, 6);</span>
<span class="line-added">2054                 if (!VM.isSupportedClassFileVersion(major, minor)) {</span>
<span class="line-added">2055                     throw new UnsupportedClassVersionError(&quot;Unsupported class file version &quot; + major + &quot;.&quot; + minor);</span>
<span class="line-added">2056                 }</span>
<span class="line-added">2057 </span>
<span class="line-added">2058                 String name;</span>
<span class="line-added">2059                 int accessFlags;</span>
<span class="line-added">2060                 try {</span>
<span class="line-added">2061                     ClassReader reader = new ClassReader(bytes);</span>
<span class="line-added">2062                     // ClassReader::getClassName does not check if `this_class` is CONSTANT_Class_info</span>
<span class="line-added">2063                     // workaround to read `this_class` using readConst and validate the value</span>
<span class="line-added">2064                     int thisClass = reader.readUnsignedShort(reader.header + 2);</span>
<span class="line-added">2065                     Object constant = reader.readConst(thisClass, new char[reader.getMaxStringLength()]);</span>
<span class="line-added">2066                     if (!(constant instanceof Type)) {</span>
<span class="line-added">2067                         throw new ClassFormatError(&quot;this_class item: #&quot; + thisClass + &quot; not a CONSTANT_Class_info&quot;);</span>
<span class="line-added">2068                     }</span>
<span class="line-added">2069                     Type type = ((Type) constant);</span>
<span class="line-added">2070                     if (!type.getDescriptor().startsWith(&quot;L&quot;)) {</span>
<span class="line-added">2071                         throw new ClassFormatError(&quot;this_class item: #&quot; + thisClass + &quot; not a CONSTANT_Class_info&quot;);</span>
<span class="line-added">2072                     }</span>
<span class="line-added">2073                     name = type.getClassName();</span>
<span class="line-added">2074                     accessFlags = reader.readUnsignedShort(reader.header);</span>
<span class="line-added">2075                 } catch (RuntimeException e) {</span>
<span class="line-added">2076                     // ASM exceptions are poorly specified</span>
<span class="line-added">2077                     ClassFormatError cfe = new ClassFormatError();</span>
<span class="line-added">2078                     cfe.initCause(e);</span>
<span class="line-added">2079                     throw cfe;</span>
<span class="line-added">2080                 }</span>
<span class="line-added">2081 </span>
<span class="line-added">2082                 // must be a class or interface</span>
<span class="line-added">2083                 if ((accessFlags &amp; Opcodes.ACC_MODULE) != 0) {</span>
2084                     throw newIllegalArgumentException(&quot;Not a class or interface: ACC_MODULE flag is set&quot;);
2085                 }
<span class="line-modified">2086 </span>
<span class="line-added">2087                 // check if it&#39;s in the named package</span>
2088                 int index = name.lastIndexOf(&#39;.&#39;);
2089                 String pn = (index == -1) ? &quot;&quot; : name.substring(0, index);
<span class="line-modified">2090                 if (!pn.equals(pkgName)) {</span>
<span class="line-modified">2091                     throw newIllegalArgumentException(name + &quot; not in same package as lookup class&quot;);</span>

2092                 }
<span class="line-modified">2093 </span>
<span class="line-modified">2094                 return new ClassFile(name, accessFlags, bytes);</span>
<span class="line-modified">2095             }</span>
<span class="line-modified">2096 </span>
<span class="line-modified">2097             private static int readInt(byte[] bytes, int offset) {</span>
<span class="line-modified">2098                 if ((offset+4) &gt; bytes.length) {</span>
<span class="line-modified">2099                     throw new ClassFormatError(&quot;Invalid ClassFile structure&quot;);</span>
<span class="line-modified">2100                 }</span>
<span class="line-added">2101                 return ((bytes[offset] &amp; 0xFF) &lt;&lt; 24)</span>
<span class="line-added">2102                         | ((bytes[offset + 1] &amp; 0xFF) &lt;&lt; 16)</span>
<span class="line-added">2103                         | ((bytes[offset + 2] &amp; 0xFF) &lt;&lt; 8)</span>
<span class="line-added">2104                         | (bytes[offset + 3] &amp; 0xFF);</span>
2105             }
<span class="line-modified">2106 </span>
<span class="line-added">2107             private static int readUnsignedShort(byte[] bytes, int offset) {</span>
<span class="line-added">2108                 if ((offset+2) &gt; bytes.length) {</span>
<span class="line-added">2109                     throw new ClassFormatError(&quot;Invalid ClassFile structure&quot;);</span>
<span class="line-added">2110                 }</span>
<span class="line-added">2111                 return ((bytes[offset] &amp; 0xFF) &lt;&lt; 8) | (bytes[offset + 1] &amp; 0xFF);</span>
<span class="line-added">2112             }</span>
2113         }
2114 
2115         /*
2116          * Returns a ClassDefiner that creates a {@code Class} object of a normal class
2117          * from the given bytes.
2118          *
2119          * Caller should make a defensive copy of the arguments if needed
2120          * before calling this factory method.
2121          *
2122          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2123          * {@bytes} denotes a class in a different package than the lookup class
2124          */
2125         private ClassDefiner makeClassDefiner(byte[] bytes) {
<span class="line-modified">2126             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());</span>
<span class="line-added">2127             return new ClassDefiner(this, cf, STRONG_LOADER_LINK);</span>
2128         }
2129 
2130         /**
2131          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2132          * from the given bytes.  The name must be in the same package as the lookup class.
2133          *
2134          * Caller should make a defensive copy of the arguments if needed
2135          * before calling this factory method.
2136          *
2137          * @param bytes   class bytes
2138          * @return ClassDefiner that defines a hidden class of the given bytes.
2139          *
2140          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2141          * {@bytes} denotes a class in a different package than the lookup class
2142          */
2143         ClassDefiner makeHiddenClassDefiner(byte[] bytes) {
<span class="line-modified">2144             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());</span>
<span class="line-added">2145             return makeHiddenClassDefiner(cf, Set.of(), false);</span>
2146         }
2147 
2148         /**
2149          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2150          * from the given bytes and options.
2151          * The name must be in the same package as the lookup class.
2152          *
2153          * Caller should make a defensive copy of the arguments if needed
2154          * before calling this factory method.
2155          *
2156          * @param bytes   class bytes
2157          * @param options class options
2158          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2159          * @return ClassDefiner that defines a hidden class of the given bytes and options
2160          *
2161          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
2162          * {@bytes} denotes a class in a different package than the lookup class
2163          */
2164         ClassDefiner makeHiddenClassDefiner(byte[] bytes,
2165                                             Set&lt;ClassOption&gt; options,
2166                                             boolean accessVmAnnotations) {
<span class="line-modified">2167             ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());</span>
<span class="line-added">2168             return makeHiddenClassDefiner(cf, options, accessVmAnnotations);</span>
2169         }
2170 
2171         /**
2172          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
2173          * from the given bytes.  No package name check on the given name.
2174          *
2175          * @param name    fully-qualified name that specifies the prefix of the hidden class
2176          * @param bytes   class bytes
2177          * @return ClassDefiner that defines a hidden class of the given bytes.
2178          */
2179         ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {
<span class="line-modified">2180             // skip name and access flags validation</span>
<span class="line-added">2181             return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), Set.of(), false);</span>
2182         }
2183 
2184         /**
2185          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
<span class="line-modified">2186          * from the given class file and options.</span>
2187          *
<span class="line-modified">2188          * @param cf ClassFile</span>

2189          * @param options class options
2190          * @param accessVmAnnotations true to give the hidden class access to VM annotations
2191          */
<span class="line-modified">2192         private ClassDefiner makeHiddenClassDefiner(ClassFile cf,</span>
<span class="line-modified">2193                                                     Set&lt;ClassOption&gt; options,</span>
<span class="line-modified">2194                                                     boolean accessVmAnnotations) {</span>

2195             int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);
2196             if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {
2197                 // jdk.internal.vm.annotations are permitted for classes
2198                 // defined to boot loader and platform loader
2199                 flags |= ACCESS_VM_ANNOTATIONS;
2200             }
2201 
<span class="line-modified">2202             return new ClassDefiner(this, cf, flags);</span>
2203         }
2204 
2205         static class ClassDefiner {
2206             private final Lookup lookup;
2207             private final String name;
2208             private final byte[] bytes;
2209             private final int classFlags;
2210 
<span class="line-modified">2211             private ClassDefiner(Lookup lookup, ClassFile cf, int flags) {</span>
2212                 assert ((flags &amp; HIDDEN_CLASS) != 0 || (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK);
2213                 this.lookup = lookup;
<span class="line-modified">2214                 this.bytes = cf.bytes;</span>
<span class="line-added">2215                 this.name = cf.name;</span>
2216                 this.classFlags = flags;

2217             }
2218 
2219             String className() {
2220                 return name;
2221             }
2222 
2223             Class&lt;?&gt; defineClass(boolean initialize) {
2224                 return defineClass(initialize, null);
2225             }
2226 
2227             Lookup defineClassAsLookup(boolean initialize) {
2228                 Class&lt;?&gt; c = defineClass(initialize, null);
2229                 return new Lookup(c, null, FULL_POWER_MODES);
2230             }
2231 
2232             /**
2233              * Defines the class of the given bytes and the given classData.
2234              * If {@code initialize} parameter is true, then the class will be initialized.
2235              *
2236              * @param initialize true if the class to be initialized
</pre>
<hr />
<pre>
5557         MethodType targetType = target.type();
5558         MethodType filterType = filter.type();
5559         filterReturnValueChecks(targetType, filterType);
5560         BoundMethodHandle result = target.rebind();
5561         BasicType rtype = BasicType.basicType(filterType.returnType());
5562         LambdaForm lform = result.editor().filterReturnForm(rtype, false);
5563         MethodType newType = targetType.changeReturnType(filterType.returnType());
5564         result = result.copyWithExtendL(newType, lform, filter);
5565         return result;
5566     }
5567 
5568     private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
5569         Class&lt;?&gt; rtype = targetType.returnType();
5570         int filterValues = filterType.parameterCount();
5571         if (filterValues == 0
5572                 ? (rtype != void.class)
5573                 : (rtype != filterType.parameterType(0) || filterValues != 1))
5574             throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
5575     }
5576 
<span class="line-added">5577     /**</span>
<span class="line-added">5578      * Filter the return value of a target method handle with a filter function. The filter function is</span>
<span class="line-added">5579      * applied to the return value of the original handle; if the filter specifies more than one parameters,</span>
<span class="line-added">5580      * then any remaining parameter is appended to the adapter handle. In other words, the adaptation works</span>
<span class="line-added">5581      * as follows:</span>
<span class="line-added">5582      * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-added">5583      * T target(A...)</span>
<span class="line-added">5584      * V filter(B... , T)</span>
<span class="line-added">5585      * V adapter(A... a, B... b) {</span>
<span class="line-added">5586      *     T t = target(a...);</span>
<span class="line-added">5587      *     return filter(b..., t);</span>
<span class="line-added">5588      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">5589      * &lt;p&gt;</span>
<span class="line-added">5590      * If the filter handle is a unary function, then this method behaves like {@link #filterReturnValue(MethodHandle, MethodHandle)}.</span>
<span class="line-added">5591      *</span>
<span class="line-added">5592      * @param target the target method handle</span>
<span class="line-added">5593      * @param filter the filter method handle</span>
<span class="line-added">5594      * @return the adapter method handle</span>
<span class="line-added">5595      */</span>
<span class="line-added">5596     /* package */ static MethodHandle collectReturnValue(MethodHandle target, MethodHandle filter) {</span>
<span class="line-added">5597         MethodType targetType = target.type();</span>
<span class="line-added">5598         MethodType filterType = filter.type();</span>
<span class="line-added">5599         BoundMethodHandle result = target.rebind();</span>
<span class="line-added">5600         LambdaForm lform = result.editor().collectReturnValueForm(filterType.basicType());</span>
<span class="line-added">5601         MethodType newType = targetType.changeReturnType(filterType.returnType());</span>
<span class="line-added">5602         if (filterType.parameterList().size() &gt; 1) {</span>
<span class="line-added">5603             for (int i = 0 ; i &lt; filterType.parameterList().size() - 1 ; i++) {</span>
<span class="line-added">5604                 newType = newType.appendParameterTypes(filterType.parameterType(i));</span>
<span class="line-added">5605             }</span>
<span class="line-added">5606         }</span>
<span class="line-added">5607         result = result.copyWithExtendL(newType, lform, filter);</span>
<span class="line-added">5608         return result;</span>
<span class="line-added">5609     }</span>
<span class="line-added">5610 </span>
5611     /**
5612      * Adapts a target method handle by pre-processing
5613      * some of its arguments, and then calling the target with
5614      * the result of the pre-processing, inserted into the original
5615      * sequence of arguments.
5616      * &lt;p&gt;
5617      * The pre-processing is performed by {@code combiner}, a second method handle.
5618      * Of the arguments passed to the adapter, the first {@code N} arguments
5619      * are copied to the combiner, which is then called.
5620      * (Here, {@code N} is defined as the parameter count of the combiner.)
5621      * After this, control passes to the target, with any result
5622      * from the combiner inserted before the original {@code N} incoming
5623      * arguments.
5624      * &lt;p&gt;
5625      * If the combiner returns a value, the first parameter type of the target
5626      * must be identical with the return type of the combiner, and the next
5627      * {@code N} parameter types of the target must exactly match the parameters
5628      * of the combiner.
5629      * &lt;p&gt;
5630      * If the combiner has a void return, no result will be inserted,
</pre>
</td>
</tr>
</table>
<center><a href="LambdaFormEditor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciField.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../c1/c1_LIRGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciField.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
276   _flags = ciFlags(fd-&gt;access_flags());
277   _offset = fd-&gt;offset();
278   Klass* field_holder = fd-&gt;field_holder();
279   assert(field_holder != NULL, &quot;null field_holder&quot;);
280   _holder = CURRENT_ENV-&gt;get_instance_klass(field_holder);
281   _is_flattened = fd-&gt;is_flattened();
282   _is_flattenable = fd-&gt;is_flattenable();
283 
284   // Check to see if the field is constant.
285   Klass* k = _holder-&gt;get_Klass();
286   bool is_stable_field = FoldStableValues &amp;&amp; is_stable();
287   if ((is_final() &amp;&amp; !has_initialized_final_update()) || is_stable_field) {
288     if (is_static()) {
289       // This field just may be constant.  The only case where it will
290       // not be constant is when the field is a *special* static &amp; final field
291       // whose value may change.  The three examples are java.lang.System.in,
292       // java.lang.System.out, and java.lang.System.err.
293       assert(SystemDictionary::System_klass() != NULL, &quot;Check once per vm&quot;);
294       if (k == SystemDictionary::System_klass()) {
295         // Check offsets for case 2: System.in, System.out, or System.err
<span class="line-modified">296         if( _offset == java_lang_System::in_offset_in_bytes()  ||</span>
<span class="line-modified">297             _offset == java_lang_System::out_offset_in_bytes() ||</span>
<span class="line-modified">298             _offset == java_lang_System::err_offset_in_bytes() ) {</span>
299           _is_constant = false;
300           return;
301         }
302       }
303       _is_constant = true;
304     } else {
305       // An instance field can be constant if it&#39;s a final static field or if
306       // it&#39;s a final non-static field of a trusted class (classes in
307       // java.lang.invoke and sun.invoke packages and subpackages).
308       _is_constant = is_stable_field || trust_final_non_static_fields(_holder);
309     }
310   } else {
311     // For CallSite objects treat the target field as a compile time constant.
312     assert(SystemDictionary::CallSite_klass() != NULL, &quot;should be already initialized&quot;);
313     if (k == SystemDictionary::CallSite_klass() &amp;&amp;
<span class="line-modified">314         _offset == java_lang_invoke_CallSite::target_offset_in_bytes()) {</span>
315       assert(!has_initialized_final_update(), &quot;CallSite is not supposed to have writes to final fields outside initializers&quot;);
316       _is_constant = true;
317     } else {
318       // Non-final &amp; non-stable fields are not constants.
319       _is_constant = false;
320     }
321   }
322 }
323 
324 // ------------------------------------------------------------------
325 // ciField::constant_value
326 // Get the constant value of a this static field.
327 ciConstant ciField::constant_value() {
328   assert(is_static() &amp;&amp; is_constant(), &quot;illegal call to constant_value()&quot;);
329   if (!_holder-&gt;is_initialized()) {
330     return ciConstant(); // Not initialized yet
331   }
332   if (_constant_value.basic_type() == T_ILLEGAL) {
333     // Static fields are placed in mirror objects.
334     VM_ENTRY_MARK;
</pre>
</td>
<td>
<hr />
<pre>
276   _flags = ciFlags(fd-&gt;access_flags());
277   _offset = fd-&gt;offset();
278   Klass* field_holder = fd-&gt;field_holder();
279   assert(field_holder != NULL, &quot;null field_holder&quot;);
280   _holder = CURRENT_ENV-&gt;get_instance_klass(field_holder);
281   _is_flattened = fd-&gt;is_flattened();
282   _is_flattenable = fd-&gt;is_flattenable();
283 
284   // Check to see if the field is constant.
285   Klass* k = _holder-&gt;get_Klass();
286   bool is_stable_field = FoldStableValues &amp;&amp; is_stable();
287   if ((is_final() &amp;&amp; !has_initialized_final_update()) || is_stable_field) {
288     if (is_static()) {
289       // This field just may be constant.  The only case where it will
290       // not be constant is when the field is a *special* static &amp; final field
291       // whose value may change.  The three examples are java.lang.System.in,
292       // java.lang.System.out, and java.lang.System.err.
293       assert(SystemDictionary::System_klass() != NULL, &quot;Check once per vm&quot;);
294       if (k == SystemDictionary::System_klass()) {
295         // Check offsets for case 2: System.in, System.out, or System.err
<span class="line-modified">296         if (_offset == java_lang_System::in_offset()  ||</span>
<span class="line-modified">297             _offset == java_lang_System::out_offset() ||</span>
<span class="line-modified">298             _offset == java_lang_System::err_offset()) {</span>
299           _is_constant = false;
300           return;
301         }
302       }
303       _is_constant = true;
304     } else {
305       // An instance field can be constant if it&#39;s a final static field or if
306       // it&#39;s a final non-static field of a trusted class (classes in
307       // java.lang.invoke and sun.invoke packages and subpackages).
308       _is_constant = is_stable_field || trust_final_non_static_fields(_holder);
309     }
310   } else {
311     // For CallSite objects treat the target field as a compile time constant.
312     assert(SystemDictionary::CallSite_klass() != NULL, &quot;should be already initialized&quot;);
313     if (k == SystemDictionary::CallSite_klass() &amp;&amp;
<span class="line-modified">314         _offset == java_lang_invoke_CallSite::target_offset()) {</span>
315       assert(!has_initialized_final_update(), &quot;CallSite is not supposed to have writes to final fields outside initializers&quot;);
316       _is_constant = true;
317     } else {
318       // Non-final &amp; non-stable fields are not constants.
319       _is_constant = false;
320     }
321   }
322 }
323 
324 // ------------------------------------------------------------------
325 // ciField::constant_value
326 // Get the constant value of a this static field.
327 ciConstant ciField::constant_value() {
328   assert(is_static() &amp;&amp; is_constant(), &quot;illegal call to constant_value()&quot;);
329   if (!_holder-&gt;is_initialized()) {
330     return ciConstant(); // Not initialized yet
331   }
332   if (_constant_value.basic_type() == T_ILLEGAL) {
333     // Static fields are placed in mirror objects.
334     VM_ENTRY_MARK;
</pre>
</td>
</tr>
</table>
<center><a href="../c1/c1_LIRGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
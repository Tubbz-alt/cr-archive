<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/templateInterpreterGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4315   return true;
4316 }
4317 
4318 
4319 bool GraphBuilder::try_method_handle_inline(ciMethod* callee, bool ignore_return) {
4320   ValueStack* state_before = copy_state_before();
4321   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
4322   switch (iid) {
4323   case vmIntrinsics::_invokeBasic:
4324     {
4325       // get MethodHandle receiver
4326       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4327       ValueType* type = state()-&gt;stack_at(args_base)-&gt;type();
4328       if (type-&gt;is_constant()) {
4329         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_method_handle()-&gt;get_vmtarget();
4330         // We don&#39;t do CHA here so only inline static and statically bindable methods.
4331         if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4332           if (ciMethod::is_consistent_info(callee, target)) {
4333             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4334             ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
<span class="line-modified">4335             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {</span>
4336               return true;
4337             }
4338           } else {
4339             print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4340           }
4341         } else {
4342           print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4343         }
4344       } else {
4345         print_inlining(callee, &quot;receiver not constant&quot;, /*success*/ false);
4346       }
4347     }
4348     break;
4349 
4350   case vmIntrinsics::_linkToVirtual:
4351   case vmIntrinsics::_linkToStatic:
4352   case vmIntrinsics::_linkToSpecial:
4353   case vmIntrinsics::_linkToInterface:
4354     {
4355       // pop MemberName argument
</pre>
<hr />
<pre>
4381             }
4382           }
4383           // Cast reference arguments to its type.
4384           for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
4385             ciType* t = signature-&gt;type_at(i);
4386             if (t-&gt;is_klass()) {
4387               ciKlass* tk = t-&gt;as_klass();
4388               Value obj = state()-&gt;stack_at(args_base + receiver_skip + j);
4389               if (obj-&gt;exact_type() == NULL &amp;&amp;
4390                   obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4391                 TypeCast* c = new TypeCast(t, obj, state_before);
4392                 append(c);
4393                 state()-&gt;stack_at_put(args_base + receiver_skip + j, c);
4394               }
4395             }
4396             j += t-&gt;size();  // long and double take two slots
4397           }
4398           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4399           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4400             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
<span class="line-modified">4401             if (try_inline(target, /*holder_known*/ true, ignore_return, bc)) {</span>
4402               return true;
4403             }
4404           } else {
4405             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4406           }
4407         }
4408       } else {
4409         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4410       }
4411     }
4412     break;
4413 
4414   default:
4415     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4416     break;
4417   }
4418   set_state(state_before-&gt;copy_for_parsing());
4419   return false;
4420 }
4421 
</pre>
</td>
<td>
<hr />
<pre>
4315   return true;
4316 }
4317 
4318 
4319 bool GraphBuilder::try_method_handle_inline(ciMethod* callee, bool ignore_return) {
4320   ValueStack* state_before = copy_state_before();
4321   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
4322   switch (iid) {
4323   case vmIntrinsics::_invokeBasic:
4324     {
4325       // get MethodHandle receiver
4326       const int args_base = state()-&gt;stack_size() - callee-&gt;arg_size();
4327       ValueType* type = state()-&gt;stack_at(args_base)-&gt;type();
4328       if (type-&gt;is_constant()) {
4329         ciMethod* target = type-&gt;as_ObjectType()-&gt;constant_value()-&gt;as_method_handle()-&gt;get_vmtarget();
4330         // We don&#39;t do CHA here so only inline static and statically bindable methods.
4331         if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4332           if (ciMethod::is_consistent_info(callee, target)) {
4333             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4334             ignore_return = ignore_return || (callee-&gt;return_type()-&gt;is_void() &amp;&amp; !target-&gt;return_type()-&gt;is_void());
<span class="line-modified">4335             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {</span>
4336               return true;
4337             }
4338           } else {
4339             print_inlining(target, &quot;signatures mismatch&quot;, /*success*/ false);
4340           }
4341         } else {
4342           print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4343         }
4344       } else {
4345         print_inlining(callee, &quot;receiver not constant&quot;, /*success*/ false);
4346       }
4347     }
4348     break;
4349 
4350   case vmIntrinsics::_linkToVirtual:
4351   case vmIntrinsics::_linkToStatic:
4352   case vmIntrinsics::_linkToSpecial:
4353   case vmIntrinsics::_linkToInterface:
4354     {
4355       // pop MemberName argument
</pre>
<hr />
<pre>
4381             }
4382           }
4383           // Cast reference arguments to its type.
4384           for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
4385             ciType* t = signature-&gt;type_at(i);
4386             if (t-&gt;is_klass()) {
4387               ciKlass* tk = t-&gt;as_klass();
4388               Value obj = state()-&gt;stack_at(args_base + receiver_skip + j);
4389               if (obj-&gt;exact_type() == NULL &amp;&amp;
4390                   obj-&gt;declared_type() != tk &amp;&amp; tk != compilation()-&gt;env()-&gt;Object_klass()) {
4391                 TypeCast* c = new TypeCast(t, obj, state_before);
4392                 append(c);
4393                 state()-&gt;stack_at_put(args_base + receiver_skip + j, c);
4394               }
4395             }
4396             j += t-&gt;size();  // long and double take two slots
4397           }
4398           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4399           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4400             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
<span class="line-modified">4401             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {</span>
4402               return true;
4403             }
4404           } else {
4405             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4406           }
4407         }
4408       } else {
4409         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4410       }
4411     }
4412     break;
4413 
4414   default:
4415     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4416     break;
4417   }
4418   set_state(state_before-&gt;copy_for_parsing());
4419   return false;
4420 }
4421 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/templateInterpreterGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
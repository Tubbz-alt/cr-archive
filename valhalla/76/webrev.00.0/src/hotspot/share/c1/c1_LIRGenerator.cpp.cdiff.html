<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_LIRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciField.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 480,28 ***</span>
                                      CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info) {
    CodeStub* stub = new RangeCheckStub(range_check_info, index, array);
    if (index-&gt;is_constant()) {
      cmp_mem_int(lir_cond_belowEqual, array, arrayOopDesc::length_offset_in_bytes(),
                  index-&gt;as_jint(), null_check_info);
<span class="line-modified">!     __ branch(lir_cond_belowEqual, T_INT, stub); // forward branch</span>
    } else {
      cmp_reg_mem(lir_cond_aboveEqual, index, array,
                  arrayOopDesc::length_offset_in_bytes(), T_INT, null_check_info);
<span class="line-modified">!     __ branch(lir_cond_aboveEqual, T_INT, stub); // forward branch</span>
    }
  }
  
  
  void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {
    CodeStub* stub = new RangeCheckStub(info, index);
    if (index-&gt;is_constant()) {
      cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index-&gt;as_jint(), info);
<span class="line-modified">!     __ branch(lir_cond_belowEqual, T_INT, stub); // forward branch</span>
    } else {
      cmp_reg_mem(lir_cond_aboveEqual, index, buffer,
                  java_nio_Buffer::limit_offset(), T_INT, info);
<span class="line-modified">!     __ branch(lir_cond_aboveEqual, T_INT, stub); // forward branch</span>
    }
    __ move(index, result);
  }
  
  
<span class="line-new-header">--- 480,28 ---</span>
                                      CodeEmitInfo* null_check_info, CodeEmitInfo* range_check_info) {
    CodeStub* stub = new RangeCheckStub(range_check_info, index, array);
    if (index-&gt;is_constant()) {
      cmp_mem_int(lir_cond_belowEqual, array, arrayOopDesc::length_offset_in_bytes(),
                  index-&gt;as_jint(), null_check_info);
<span class="line-modified">!     __ branch(lir_cond_belowEqual, stub); // forward branch</span>
    } else {
      cmp_reg_mem(lir_cond_aboveEqual, index, array,
                  arrayOopDesc::length_offset_in_bytes(), T_INT, null_check_info);
<span class="line-modified">!     __ branch(lir_cond_aboveEqual, stub); // forward branch</span>
    }
  }
  
  
  void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {
    CodeStub* stub = new RangeCheckStub(info, index);
    if (index-&gt;is_constant()) {
      cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index-&gt;as_jint(), info);
<span class="line-modified">!     __ branch(lir_cond_belowEqual, stub); // forward branch</span>
    } else {
      cmp_reg_mem(lir_cond_aboveEqual, index, buffer,
                  java_nio_Buffer::limit_offset(), T_INT, info);
<span class="line-modified">!     __ branch(lir_cond_aboveEqual, stub); // forward branch</span>
    }
    __ move(index, result);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 689,11 ***</span>
      const int instance_size = align_object_size(klass-&gt;size_helper());
      __ allocate_object(dst, scratch1, scratch2, scratch3, scratch4,
                         oopDesc::header_size(), instance_size, klass_reg, !klass-&gt;is_initialized(), slow_path);
    } else {
      CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);
<span class="line-modified">!     __ branch(lir_cond_always, T_ILLEGAL, slow_path);</span>
      __ branch_destination(slow_path-&gt;continuation());
    }
  }
  
  
<span class="line-new-header">--- 689,11 ---</span>
      const int instance_size = align_object_size(klass-&gt;size_helper());
      __ allocate_object(dst, scratch1, scratch2, scratch3, scratch4,
                         oopDesc::header_size(), instance_size, klass_reg, !klass-&gt;is_initialized(), slow_path);
    } else {
      CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);
<span class="line-modified">!     __ branch(lir_cond_always, slow_path);</span>
      __ branch_destination(slow_path-&gt;continuation());
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,12 ***</span>
  
  // Examble: ref.get()
  // Combination of LoadField and g1 pre-write barrier
  void LIRGenerator::do_Reference_get(Intrinsic* x) {
  
<span class="line-modified">!   const int referent_offset = java_lang_ref_Reference::referent_offset;</span>
<span class="line-removed">-   guarantee(referent_offset &gt; 0, &quot;referent offset not initialized&quot;);</span>
  
    assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
  
    LIRItem reference(x-&gt;argument_at(0), this);
    reference.load_item();
<span class="line-new-header">--- 1233,11 ---</span>
  
  // Examble: ref.get()
  // Combination of LoadField and g1 pre-write barrier
  void LIRGenerator::do_Reference_get(Intrinsic* x) {
  
<span class="line-modified">!   const int referent_offset = java_lang_ref_Reference::referent_offset();</span>
  
    assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
  
    LIRItem reference(x-&gt;argument_at(0), this);
    reference.load_item();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1320,11 ***</span>
    CodeEmitInfo* info = NULL;
    if (x-&gt;needs_null_check()) {
      info = state_for(x);
    }
  
<span class="line-modified">!   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);</span>
    __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));
    __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
  }
  
  
<span class="line-new-header">--- 1319,11 ---</span>
    CodeEmitInfo* info = NULL;
    if (x-&gt;needs_null_check()) {
      info = state_for(x);
    }
  
<span class="line-modified">!   __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset(), T_ADDRESS), temp, info);</span>
    __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));
    __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);
  }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1562,11 ***</span>
        assert(!x-&gt;field()-&gt;holder()-&gt;is_loaded(), &quot;must be&quot;);
        // We don&#39;t know the offset of this field. Let&#39;s deopt and recompile.
        CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                            Deoptimization::Reason_unloaded,
                                            Deoptimization::Action_make_not_entrant);
<span class="line-modified">!       __ branch(lir_cond_always, T_ILLEGAL, stub);</span>
      } else {
        // Emit an explicit null check because the offset is too large.
        // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
        // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
        __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
<span class="line-new-header">--- 1561,11 ---</span>
        assert(!x-&gt;field()-&gt;holder()-&gt;is_loaded(), &quot;must be&quot;);
        // We don&#39;t know the offset of this field. Let&#39;s deopt and recompile.
        CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                            Deoptimization::Reason_unloaded,
                                            Deoptimization::Action_make_not_entrant);
<span class="line-modified">!       __ branch(lir_cond_always, stub);</span>
      } else {
        // Emit an explicit null check because the offset is too large.
        // If the class is not loaded and the object is NULL, we need to deoptimize to throw a
        // NoClassDefFoundError in the interpreter instead of an implicit NPE from compiled code.
        __ null_check(object.result(), new CodeEmitInfo(info), /* deoptimize */ needs_patching);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1681,11 ***</span>
  
  void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {
    LabelObj* L_end = new LabelObj();
    LIR_Opr tmp = new_register(T_METADATA);
    __ check_null_free_array(array.result(), tmp);
<span class="line-modified">!   __ branch(lir_cond_equal, T_ILLEGAL, L_end-&gt;label());</span>
    __ null_check(value.result(), info);
    __ branch_destination(L_end-&gt;label());
  }
  
  bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
<span class="line-new-header">--- 1680,11 ---</span>
  
  void LIRGenerator::check_null_free_array(LIRItem&amp; array, LIRItem&amp; value, CodeEmitInfo* info) {
    LabelObj* L_end = new LabelObj();
    LIR_Opr tmp = new_register(T_METADATA);
    __ check_null_free_array(array.result(), tmp);
<span class="line-modified">!   __ branch(lir_cond_equal, L_end-&gt;label());</span>
    __ null_check(value.result(), info);
    __ branch_destination(L_end-&gt;label());
  }
  
  bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1752,11 ***</span>
    }
  
    if (GenerateRangeChecks &amp;&amp; needs_range_check) {
      if (use_length) {
        __ cmp(lir_cond_belowEqual, length.result(), index.result());
<span class="line-modified">!       __ branch(lir_cond_belowEqual, T_INT, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else {
        array_range_check(array.result(), index.result(), null_check_info, range_check_info);
        // range_check also does the null check
        null_check_info = NULL;
      }
<span class="line-new-header">--- 1751,11 ---</span>
    }
  
    if (GenerateRangeChecks &amp;&amp; needs_range_check) {
      if (use_length) {
        __ cmp(lir_cond_belowEqual, length.result(), index.result());
<span class="line-modified">!       __ branch(lir_cond_belowEqual, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else {
        array_range_check(array.result(), index.result(), null_check_info, range_check_info);
        // range_check also does the null check
        null_check_info = NULL;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1946,11 ***</span>
      assert(x-&gt;needs_patching(), &quot;must be&quot;);
      assert(info != NULL, &quot;must be&quot;);
      CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                          Deoptimization::Reason_unloaded,
                                          Deoptimization::Action_make_not_entrant);
<span class="line-modified">!     __ branch(lir_cond_always, T_ILLEGAL, stub);</span>
    } else if (need_default) {
      assert(!field_type_unloaded, &quot;must be&quot;);
      assert(field-&gt;type()-&gt;is_valuetype(), &quot;must be&quot;);
      ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();
      assert(value_klass-&gt;is_loaded(), &quot;must be&quot;);
<span class="line-new-header">--- 1945,11 ---</span>
      assert(x-&gt;needs_patching(), &quot;must be&quot;);
      assert(info != NULL, &quot;must be&quot;);
      CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                          Deoptimization::Reason_unloaded,
                                          Deoptimization::Action_make_not_entrant);
<span class="line-modified">!     __ branch(lir_cond_always, stub);</span>
    } else if (need_default) {
      assert(!field_type_unloaded, &quot;must be&quot;);
      assert(field-&gt;type()-&gt;is_valuetype(), &quot;must be&quot;);
      ciValueKlass* value_klass = field-&gt;type()-&gt;as_value_klass();
      assert(value_klass-&gt;is_loaded(), &quot;must be&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2039,11 ***</span>
                   info ? new CodeEmitInfo(info) : NULL, info);
  
    if (default_value != NULL) {
      LabelObj* L_end = new LabelObj();
      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));
<span class="line-modified">!     __ branch(lir_cond_notEqual, T_OBJECT, L_end-&gt;label());</span>
      set_in_conditional_code(true);
      __ move(load_constant(default_value), result);
      __ branch_destination(L_end-&gt;label());
      set_in_conditional_code(false);
    }
<span class="line-new-header">--- 2038,11 ---</span>
                   info ? new CodeEmitInfo(info) : NULL, info);
  
    if (default_value != NULL) {
      LabelObj* L_end = new LabelObj();
      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));
<span class="line-modified">!     __ branch(lir_cond_notEqual, L_end-&gt;label());</span>
      set_in_conditional_code(true);
      __ move(load_constant(default_value), result);
      __ branch_destination(L_end-&gt;label());
      set_in_conditional_code(false);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2068,15 ***</span>
      CodeEmitInfo* info = state_for(x);
      CodeStub* stub = new RangeCheckStub(info, index.result());
      LIR_Opr buf_obj = access_resolve(IS_NOT_NULL | ACCESS_READ, buf.result());
      if (index.result()-&gt;is_constant()) {
        cmp_mem_int(lir_cond_belowEqual, buf_obj, java_nio_Buffer::limit_offset(), index.result()-&gt;as_jint(), info);
<span class="line-modified">!       __ branch(lir_cond_belowEqual, T_INT, stub);</span>
      } else {
        cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf_obj,
                    java_nio_Buffer::limit_offset(), T_INT, info);
<span class="line-modified">!       __ branch(lir_cond_aboveEqual, T_INT, stub);</span>
      }
      __ move(index.result(), result);
    } else {
      // Just load the index into the result register
      __ move(index.result(), result);
<span class="line-new-header">--- 2067,15 ---</span>
      CodeEmitInfo* info = state_for(x);
      CodeStub* stub = new RangeCheckStub(info, index.result());
      LIR_Opr buf_obj = access_resolve(IS_NOT_NULL | ACCESS_READ, buf.result());
      if (index.result()-&gt;is_constant()) {
        cmp_mem_int(lir_cond_belowEqual, buf_obj, java_nio_Buffer::limit_offset(), index.result()-&gt;as_jint(), info);
<span class="line-modified">!       __ branch(lir_cond_belowEqual, stub);</span>
      } else {
        cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf_obj,
                    java_nio_Buffer::limit_offset(), T_INT, info);
<span class="line-modified">!       __ branch(lir_cond_aboveEqual, stub);</span>
      }
      __ move(index.result(), result);
    } else {
      // Just load the index into the result register
      __ move(index.result(), result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2146,16 ***</span>
      }
    }
  
    if (GenerateRangeChecks &amp;&amp; needs_range_check) {
      if (StressLoopInvariantCodeMotion &amp;&amp; range_check_info-&gt;deoptimize_on_exception()) {
<span class="line-modified">!       __ branch(lir_cond_always, T_ILLEGAL, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else if (use_length) {
        // TODO: use a (modified) version of array_range_check that does not require a
        //       constant length to be loaded to a register
        __ cmp(lir_cond_belowEqual, length.result(), index.result());
<span class="line-modified">!       __ branch(lir_cond_belowEqual, T_INT, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else {
        array_range_check(array.result(), index.result(), null_check_info, range_check_info);
        // The range check performs the null check, so clear it out for the load
        null_check_info = NULL;
      }
<span class="line-new-header">--- 2145,16 ---</span>
      }
    }
  
    if (GenerateRangeChecks &amp;&amp; needs_range_check) {
      if (StressLoopInvariantCodeMotion &amp;&amp; range_check_info-&gt;deoptimize_on_exception()) {
<span class="line-modified">!       __ branch(lir_cond_always, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else if (use_length) {
        // TODO: use a (modified) version of array_range_check that does not require a
        //       constant length to be loaded to a register
        __ cmp(lir_cond_belowEqual, length.result(), index.result());
<span class="line-modified">!       __ branch(lir_cond_belowEqual, new RangeCheckStub(range_check_info, index.result(), array.result()));</span>
      } else {
        array_range_check(array.result(), index.result(), null_check_info, range_check_info);
        // The range check performs the null check, so clear it out for the load
        null_check_info = NULL;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2221,22 ***</span>
    // case. Let&#39;s just deoptimize.
    CodeEmitInfo* info = state_for(x, x-&gt;state_before());
    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                        Deoptimization::Reason_unloaded,
                                        Deoptimization::Action_make_not_entrant);
<span class="line-modified">!   __ branch(lir_cond_always, T_ILLEGAL, stub);</span>
    LIR_Opr reg = rlock_result(x, T_OBJECT);
    __ move(LIR_OprFact::oopConst(NULL), reg);
  }
  
  void LIRGenerator::do_DefaultValue(DefaultValue* x) {
    // Same as withfield above. Let&#39;s deoptimize.
    CodeEmitInfo* info = state_for(x, x-&gt;state_before());
    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                        Deoptimization::Reason_unloaded,
                                        Deoptimization::Action_make_not_entrant);
<span class="line-modified">!   __ branch(lir_cond_always, T_ILLEGAL, stub);</span>
    LIR_Opr reg = rlock_result(x, T_OBJECT);
    __ move(LIR_OprFact::oopConst(NULL), reg);
  }
  
  void LIRGenerator::do_NullCheck(NullCheck* x) {
<span class="line-new-header">--- 2220,22 ---</span>
    // case. Let&#39;s just deoptimize.
    CodeEmitInfo* info = state_for(x, x-&gt;state_before());
    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                        Deoptimization::Reason_unloaded,
                                        Deoptimization::Action_make_not_entrant);
<span class="line-modified">!   __ branch(lir_cond_always, stub);</span>
    LIR_Opr reg = rlock_result(x, T_OBJECT);
    __ move(LIR_OprFact::oopConst(NULL), reg);
  }
  
  void LIRGenerator::do_DefaultValue(DefaultValue* x) {
    // Same as withfield above. Let&#39;s deoptimize.
    CodeEmitInfo* info = state_for(x, x-&gt;state_before());
    CodeStub* stub = new DeoptimizeStub(new CodeEmitInfo(info),
                                        Deoptimization::Reason_unloaded,
                                        Deoptimization::Action_make_not_entrant);
<span class="line-modified">!   __ branch(lir_cond_always, stub);</span>
    LIR_Opr reg = rlock_result(x, T_OBJECT);
    __ move(LIR_OprFact::oopConst(NULL), reg);
  }
  
  void LIRGenerator::do_NullCheck(NullCheck* x) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2596,22 ***</span>
      int low_key = one_range-&gt;low_key();
      int high_key = one_range-&gt;high_key();
      BlockBegin* dest = one_range-&gt;sux();
      if (low_key == high_key) {
        __ cmp(lir_cond_equal, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, dest);</span>
      } else if (high_key - low_key == 1) {
        __ cmp(lir_cond_equal, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, dest);</span>
        __ cmp(lir_cond_equal, value, high_key);
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, dest);</span>
      } else {
        LabelObj* L = new LabelObj();
        __ cmp(lir_cond_less, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_less, T_INT, L-&gt;label());</span>
        __ cmp(lir_cond_lessEqual, value, high_key);
<span class="line-modified">!       __ branch(lir_cond_lessEqual, T_INT, dest);</span>
        __ branch_destination(L-&gt;label());
      }
    }
    __ jump(default_sux);
  }
<span class="line-new-header">--- 2595,22 ---</span>
      int low_key = one_range-&gt;low_key();
      int high_key = one_range-&gt;high_key();
      BlockBegin* dest = one_range-&gt;sux();
      if (low_key == high_key) {
        __ cmp(lir_cond_equal, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_equal, dest);</span>
      } else if (high_key - low_key == 1) {
        __ cmp(lir_cond_equal, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_equal, dest);</span>
        __ cmp(lir_cond_equal, value, high_key);
<span class="line-modified">!       __ branch(lir_cond_equal, dest);</span>
      } else {
        LabelObj* L = new LabelObj();
        __ cmp(lir_cond_less, value, low_key);
<span class="line-modified">!       __ branch(lir_cond_less, L-&gt;label());</span>
        __ cmp(lir_cond_lessEqual, value, high_key);
<span class="line-modified">!       __ branch(lir_cond_lessEqual, dest);</span>
        __ branch_destination(L-&gt;label());
      }
    }
    __ jump(default_sux);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2727,11 ***</span>
    if (UseTableRanges) {
      do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
    } else {
      for (int i = 0; i &lt; len; i++) {
        __ cmp(lir_cond_equal, value, i + lo_key);
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, x-&gt;sux_at(i));</span>
      }
      __ jump(x-&gt;default_sux());
    }
  }
  
<span class="line-new-header">--- 2726,11 ---</span>
    if (UseTableRanges) {
      do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
    } else {
      for (int i = 0; i &lt; len; i++) {
        __ cmp(lir_cond_equal, value, i + lo_key);
<span class="line-modified">!       __ branch(lir_cond_equal, x-&gt;sux_at(i));</span>
      }
      __ jump(x-&gt;default_sux());
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2786,11 ***</span>
      do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
    } else {
      int len = x-&gt;length();
      for (int i = 0; i &lt; len; i++) {
        __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, x-&gt;sux_at(i));</span>
      }
      __ jump(x-&gt;default_sux());
    }
  }
  
<span class="line-new-header">--- 2785,11 ---</span>
      do_SwitchRanges(create_lookup_ranges(x), value, x-&gt;default_sux());
    } else {
      int len = x-&gt;length();
      for (int i = 0; i &lt; len; i++) {
        __ cmp(lir_cond_equal, value, x-&gt;key_at(i));
<span class="line-modified">!       __ branch(lir_cond_equal, x-&gt;sux_at(i));</span>
      }
      __ jump(x-&gt;default_sux());
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3004,11 ***</span>
    LIR_Opr tmp = new_register(T_METADATA);
    LIR_Opr mdp = new_register(T_METADATA);
    assert(md != NULL, &quot;should have been initialized&quot;);
    __ metadata2reg(md-&gt;constant_encoding(), mdp);
    __ check_null_free_array(array.result(), tmp);
<span class="line-modified">!   __ branch(lir_cond_equal, T_ILLEGAL, L_end-&gt;label());</span>
  
    profile_array_load_store_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), mdp);
  
    __ branch_destination(L_end-&gt;label());
  }
<span class="line-new-header">--- 3003,11 ---</span>
    LIR_Opr tmp = new_register(T_METADATA);
    LIR_Opr mdp = new_register(T_METADATA);
    assert(md != NULL, &quot;should have been initialized&quot;);
    __ metadata2reg(md-&gt;constant_encoding(), mdp);
    __ check_null_free_array(array.result(), tmp);
<span class="line-modified">!   __ branch(lir_cond_equal, L_end-&gt;label());</span>
  
    profile_array_load_store_flags(md, load_store, ArrayLoadStoreData::null_free_array_byte_constant(), mdp);
  
    __ branch_destination(L_end-&gt;label());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3121,11 ***</span>
      // Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized value type arguments
      // in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.
      CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);
      CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);
      __ append(new LIR_Op0(lir_check_orig_pc));
<span class="line-modified">!     __ branch(lir_cond_notEqual, T_ADDRESS, deopt_stub);</span>
    }
  
    // all blocks with a successor must end with an unconditional jump
    // to the successor even if they are consecutive
    __ jump(x-&gt;default_sux());
<span class="line-new-header">--- 3120,11 ---</span>
      // Check if deoptimization was triggered (i.e. orig_pc was set) while buffering scalarized value type arguments
      // in the entry point (see comments in frame::deoptimize). If so, deoptimize only now that we have the right state.
      CodeEmitInfo* info = new CodeEmitInfo(scope()-&gt;start()-&gt;state()-&gt;copy(ValueStack::StateBefore, 0), NULL, false);
      CodeStub* deopt_stub = new DeoptimizeStub(info, Deoptimization::Reason_none, Deoptimization::Action_none);
      __ append(new LIR_Op0(lir_check_orig_pc));
<span class="line-modified">!     __ branch(lir_cond_notEqual, deopt_stub);</span>
    }
  
    // all blocks with a successor must end with an unconditional jump
    // to the successor even if they are consecutive
    __ jump(x-&gt;default_sux());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3428,11 ***</span>
    assert(info != NULL, &quot;must have info&quot;);
    LIRItem arg(x-&gt;argument_at(0), this);
  
    arg.load_item();
    LIR_Opr klass = new_register(T_METADATA);
<span class="line-modified">!   __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), klass, info);</span>
    LIR_Opr id = new_register(T_LONG);
    ByteSize offset = KLASS_TRACE_ID_OFFSET;
    LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);
  
    __ move(trace_id_addr, id);
<span class="line-new-header">--- 3427,11 ---</span>
    assert(info != NULL, &quot;must have info&quot;);
    LIRItem arg(x-&gt;argument_at(0), this);
  
    arg.load_item();
    LIR_Opr klass = new_register(T_METADATA);
<span class="line-modified">!   __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);</span>
    LIR_Opr id = new_register(T_LONG);
    ByteSize offset = KLASS_TRACE_ID_OFFSET;
    LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);
  
    __ move(trace_id_addr, id);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3450,20 ***</span>
  }
  
  void LIRGenerator::do_getEventWriter(Intrinsic* x) {
    LabelObj* L_end = new LabelObj();
  
    LIR_Address* jobj_addr = new LIR_Address(getThreadPointer(),
                                             in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR),
<span class="line-modified">!                                            T_OBJECT);</span>
    LIR_Opr result = rlock_result(x);
<span class="line-modified">!   __ move_wide(jobj_addr, result);</span>
<span class="line-modified">!   __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(NULL));</span>
<span class="line-modified">!   __ branch(lir_cond_equal, T_OBJECT, L_end-&gt;label());</span>
  
<span class="line-removed">-   LIR_Opr jobj = new_register(T_OBJECT);</span>
<span class="line-removed">-   __ move(result, jobj);</span>
    access_load(IN_NATIVE, T_OBJECT, LIR_OprFact::address(new LIR_Address(jobj, T_OBJECT)), result);
  
    __ branch_destination(L_end-&gt;label());
  }
  
<span class="line-new-header">--- 3449,22 ---</span>
  }
  
  void LIRGenerator::do_getEventWriter(Intrinsic* x) {
    LabelObj* L_end = new LabelObj();
  
<span class="line-added">+   // FIXME T_ADDRESS should actually be T_METADATA but it can&#39;t because the</span>
<span class="line-added">+   // meaning of these two is mixed up (see JDK-8026837).</span>
    LIR_Address* jobj_addr = new LIR_Address(getThreadPointer(),
                                             in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR),
<span class="line-modified">!                                            T_ADDRESS);</span>
    LIR_Opr result = rlock_result(x);
<span class="line-modified">!   __ move(LIR_OprFact::oopConst(NULL), result);</span>
<span class="line-modified">!   LIR_Opr jobj = new_register(T_METADATA);</span>
<span class="line-modified">!   __ move_wide(jobj_addr, jobj);</span>
<span class="line-added">+   __ cmp(lir_cond_equal, jobj, LIR_OprFact::metadataConst(0));</span>
<span class="line-added">+   __ branch(lir_cond_equal, L_end-&gt;label());</span>
  
    access_load(IN_NATIVE, T_OBJECT, LIR_OprFact::address(new LIR_Address(jobj, T_OBJECT)), result);
  
    __ branch_destination(L_end-&gt;label());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3817,11 ***</span>
      __ store(result, counter);
      // DeoptimizeStub will reexecute from the current state in code info.
      CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_tenured,
                                           Deoptimization::Action_make_not_entrant);
      __ cmp(lir_cond_lessEqual, result, LIR_OprFact::intConst(0));
<span class="line-modified">!     __ branch(lir_cond_lessEqual, T_INT, deopt);</span>
    }
  }
  
  
  void LIRGenerator::increment_event_counter_impl(CodeEmitInfo* info,
<span class="line-new-header">--- 3818,11 ---</span>
      __ store(result, counter);
      // DeoptimizeStub will reexecute from the current state in code info.
      CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_tenured,
                                           Deoptimization::Action_make_not_entrant);
      __ cmp(lir_cond_lessEqual, result, LIR_OprFact::intConst(0));
<span class="line-modified">!     __ branch(lir_cond_lessEqual, deopt);</span>
    }
  }
  
  
  void LIRGenerator::increment_event_counter_impl(CodeEmitInfo* info,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3864,24 ***</span>
      CodeStub* overflow = new CounterOverflowStub(info, bci, meth);
      int freq = frequency &lt;&lt; InvocationCounter::count_shift;
      if (freq == 0) {
        if (!step-&gt;is_constant()) {
          __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
<span class="line-modified">!         __ branch(lir_cond_notEqual, T_ILLEGAL, overflow);</span>
        } else {
<span class="line-modified">!         __ branch(lir_cond_always, T_ILLEGAL, overflow);</span>
        }
      } else {
        LIR_Opr mask = load_immediate(freq, T_INT);
        if (!step-&gt;is_constant()) {
          // If step is 0, make sure the overflow check below always fails
          __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
          __ cmove(lir_cond_notEqual, result, LIR_OprFact::intConst(InvocationCounter::count_increment), result, T_INT);
        }
        __ logical_and(result, mask, result);
        __ cmp(lir_cond_equal, result, LIR_OprFact::intConst(0));
<span class="line-modified">!       __ branch(lir_cond_equal, T_INT, overflow);</span>
      }
      __ branch_destination(overflow-&gt;continuation());
    }
  }
  
<span class="line-new-header">--- 3865,24 ---</span>
      CodeStub* overflow = new CounterOverflowStub(info, bci, meth);
      int freq = frequency &lt;&lt; InvocationCounter::count_shift;
      if (freq == 0) {
        if (!step-&gt;is_constant()) {
          __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
<span class="line-modified">!         __ branch(lir_cond_notEqual, overflow);</span>
        } else {
<span class="line-modified">!         __ branch(lir_cond_always, overflow);</span>
        }
      } else {
        LIR_Opr mask = load_immediate(freq, T_INT);
        if (!step-&gt;is_constant()) {
          // If step is 0, make sure the overflow check below always fails
          __ cmp(lir_cond_notEqual, step, LIR_OprFact::intConst(0));
          __ cmove(lir_cond_notEqual, result, LIR_OprFact::intConst(InvocationCounter::count_increment), result, T_INT);
        }
        __ logical_and(result, mask, result);
        __ cmp(lir_cond_equal, result, LIR_OprFact::intConst(0));
<span class="line-modified">!       __ branch(lir_cond_equal, overflow);</span>
      }
      __ branch_destination(overflow-&gt;continuation());
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3991,11 ***</span>
  
      CodeEmitInfo *info = state_for(x, x-&gt;state());
      CodeStub* stub = new PredicateFailedStub(info);
  
      __ cmp(lir_cond(cond), left, right);
<span class="line-modified">!     __ branch(lir_cond(cond), right-&gt;type(), stub);</span>
    }
  }
  
  
  LIR_Opr LIRGenerator::call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info) {
<span class="line-new-header">--- 3992,11 ---</span>
  
      CodeEmitInfo *info = state_for(x, x-&gt;state());
      CodeStub* stub = new PredicateFailedStub(info);
  
      __ cmp(lir_cond(cond), left, right);
<span class="line-modified">!     __ branch(lir_cond(cond), stub);</span>
    }
  }
  
  
  LIR_Opr LIRGenerator::call_runtime(Value arg1, address entry, ValueType* result_type, CodeEmitInfo* info) {
</pre>
<center><a href="c1_LIR.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciField.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
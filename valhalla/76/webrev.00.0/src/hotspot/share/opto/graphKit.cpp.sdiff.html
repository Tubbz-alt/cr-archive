<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
4411 
4412 void GraphKit::sync_kit(IdealKit&amp; ideal) {
4413   set_all_memory(ideal.merged_memory());
4414   set_i_o(ideal.i_o());
4415   set_control(ideal.ctrl());
4416 }
4417 
4418 void GraphKit::final_sync(IdealKit&amp; ideal) {
4419   // Final sync IdealKit and graphKit.
4420   sync_kit(ideal);
4421 }
4422 
4423 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
4424   Node* len = load_array_length(load_String_value(str, set_ctrl));
4425   Node* coder = load_String_coder(str, set_ctrl);
4426   // Divide length by 2 if coder is UTF16
4427   return _gvn.transform(new RShiftINode(len, coder));
4428 }
4429 
4430 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
<span class="line-modified">4431   int value_offset = java_lang_String::value_offset_in_bytes();</span>
4432   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4433                                                      false, NULL, Type::Offset(0), false);
4434   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4435   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
4436                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),
4437                                                   ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));
4438   Node* p = basic_plus_adr(str, str, value_offset);
4439   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
4440                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4441   return load;
4442 }
4443 
4444 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4445   if (!CompactStrings) {
4446     return intcon(java_lang_String::CODER_UTF16);
4447   }
<span class="line-modified">4448   int coder_offset = java_lang_String::coder_offset_in_bytes();</span>
4449   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4450                                                      false, NULL, Type::Offset(0), false);
4451   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4452 
4453   Node* p = basic_plus_adr(str, str, coder_offset);
4454   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4455                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4456   return load;
4457 }
4458 
4459 void GraphKit::store_String_value(Node* str, Node* value) {
<span class="line-modified">4460   int value_offset = java_lang_String::value_offset_in_bytes();</span>
4461   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4462                                                      false, NULL, Type::Offset(0), false);
4463   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4464 
4465   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4466                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4467 }
4468 
4469 void GraphKit::store_String_coder(Node* str, Node* value) {
<span class="line-modified">4470   int coder_offset = java_lang_String::coder_offset_in_bytes();</span>
4471   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4472                                                      false, NULL, Type::Offset(0), false);
4473   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4474 
4475   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4476                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4477 }
4478 
4479 // Capture src and dst memory state with a MergeMemNode
4480 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4481   if (src_type == dst_type) {
4482     // Types are equal, we don&#39;t need a MergeMemNode
4483     return memory(src_type);
4484   }
4485   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4486   record_for_igvn(merge); // fold it up later, if possible
4487   int src_idx = C-&gt;get_alias_index(src_type);
4488   int dst_idx = C-&gt;get_alias_index(dst_type);
4489   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4490   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
4411 
4412 void GraphKit::sync_kit(IdealKit&amp; ideal) {
4413   set_all_memory(ideal.merged_memory());
4414   set_i_o(ideal.i_o());
4415   set_control(ideal.ctrl());
4416 }
4417 
4418 void GraphKit::final_sync(IdealKit&amp; ideal) {
4419   // Final sync IdealKit and graphKit.
4420   sync_kit(ideal);
4421 }
4422 
4423 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
4424   Node* len = load_array_length(load_String_value(str, set_ctrl));
4425   Node* coder = load_String_coder(str, set_ctrl);
4426   // Divide length by 2 if coder is UTF16
4427   return _gvn.transform(new RShiftINode(len, coder));
4428 }
4429 
4430 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
<span class="line-modified">4431   int value_offset = java_lang_String::value_offset();</span>
4432   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4433                                                      false, NULL, Type::Offset(0), false);
4434   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4435   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
4436                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),
4437                                                   ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));
4438   Node* p = basic_plus_adr(str, str, value_offset);
4439   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
4440                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4441   return load;
4442 }
4443 
4444 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4445   if (!CompactStrings) {
4446     return intcon(java_lang_String::CODER_UTF16);
4447   }
<span class="line-modified">4448   int coder_offset = java_lang_String::coder_offset();</span>
4449   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4450                                                      false, NULL, Type::Offset(0), false);
4451   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4452 
4453   Node* p = basic_plus_adr(str, str, coder_offset);
4454   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4455                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4456   return load;
4457 }
4458 
4459 void GraphKit::store_String_value(Node* str, Node* value) {
<span class="line-modified">4460   int value_offset = java_lang_String::value_offset();</span>
4461   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4462                                                      false, NULL, Type::Offset(0), false);
4463   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4464 
4465   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4466                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4467 }
4468 
4469 void GraphKit::store_String_coder(Node* str, Node* value) {
<span class="line-modified">4470   int coder_offset = java_lang_String::coder_offset();</span>
4471   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
4472                                                      false, NULL, Type::Offset(0), false);
4473   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4474 
4475   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4476                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4477 }
4478 
4479 // Capture src and dst memory state with a MergeMemNode
4480 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4481   if (src_type == dst_type) {
4482     // Types are equal, we don&#39;t need a MergeMemNode
4483     return memory(src_type);
4484   }
4485   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4486   record_for_igvn(merge); // fold it up later, if possible
4487   int src_idx = C-&gt;get_alias_index(src_type);
4488   int dst_idx = C-&gt;get_alias_index(dst_type);
4489   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4490   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
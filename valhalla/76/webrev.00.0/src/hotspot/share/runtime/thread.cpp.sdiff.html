<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="synchronizer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4680     thread-&gt;metadata_handles_do(_f);
4681   }
4682 };
4683 
4684 void Threads::metadata_handles_do(void f(Metadata*)) {
4685   // Only walk the Handles in Thread.
4686   ThreadHandlesClosure handles_closure(f);
4687   threads_do(&amp;handles_closure);
4688 }
4689 
4690 // Get count Java threads that are waiting to enter the specified monitor.
4691 GrowableArray&lt;JavaThread*&gt;* Threads::get_pending_threads(ThreadsList * t_list,
4692                                                          int count,
4693                                                          address monitor) {
4694   GrowableArray&lt;JavaThread*&gt;* result = new GrowableArray&lt;JavaThread*&gt;(count);
4695 
4696   int i = 0;
4697   DO_JAVA_THREADS(t_list, p) {
4698     if (!p-&gt;can_call_java()) continue;
4699 


4700     address pending = (address)p-&gt;current_pending_monitor();
4701     if (pending == monitor) {             // found a match
4702       if (i &lt; count) result-&gt;append(p);   // save the first count matches
4703       i++;
4704     }
4705   }
4706 
4707   return result;
4708 }
4709 
4710 
4711 JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,
4712                                                       address owner) {
4713   // NULL owner means not locked so we can skip the search
4714   if (owner == NULL) return NULL;
4715 
4716   DO_JAVA_THREADS(t_list, p) {
4717     // first, see if owner is the address of a Java thread
4718     if (owner == (address)p) return p;
4719   }
</pre>
<hr />
<pre>
4826 // Threads::print_on_error() is called by fatal error handler. It&#39;s possible
4827 // that VM is not at safepoint and/or current thread is inside signal handler.
4828 // Don&#39;t print stack trace, as the stack may not be walkable. Don&#39;t allocate
4829 // memory (even in resource area), it might deadlock the error handler.
4830 void Threads::print_on_error(outputStream* st, Thread* current, char* buf,
4831                              int buflen) {
4832   ThreadsSMRSupport::print_info_on(st);
4833   st-&gt;cr();
4834 
4835   bool found_current = false;
4836   st-&gt;print_cr(&quot;Java Threads: ( =&gt; current thread )&quot;);
4837   ALL_JAVA_THREADS(thread) {
4838     print_on_error(thread, st, current, buf, buflen, &amp;found_current);
4839   }
4840   st-&gt;cr();
4841 
4842   st-&gt;print_cr(&quot;Other Threads:&quot;);
4843   print_on_error(VMThread::vm_thread(), st, current, buf, buflen, &amp;found_current);
4844   print_on_error(WatcherThread::watcher_thread(), st, current, buf, buflen, &amp;found_current);
4845 
<span class="line-modified">4846   PrintOnErrorClosure print_closure(st, current, buf, buflen, &amp;found_current);</span>
<span class="line-modified">4847   Universe::heap()-&gt;gc_threads_do(&amp;print_closure);</span>


4848 
4849   if (!found_current) {
4850     st-&gt;cr();
4851     st-&gt;print(&quot;=&gt;&quot; PTR_FORMAT &quot; (exited) &quot;, p2i(current));
4852     current-&gt;print_on_error(st, buf, buflen);
4853     st-&gt;cr();
4854   }
4855   st-&gt;cr();
4856 
4857   st-&gt;print_cr(&quot;Threads with active compile tasks:&quot;);
4858   print_threads_compiling(st, buf, buflen);
4859 }
4860 
4861 void Threads::print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form) {
4862   ALL_JAVA_THREADS(thread) {
4863     if (thread-&gt;is_Compiler_thread()) {
4864       CompilerThread* ct = (CompilerThread*) thread;
4865 
4866       // Keep task in local variable for NULL check.
4867       // ct-&gt;_task might be set to NULL by concurring compiler thread
</pre>
</td>
<td>
<hr />
<pre>
4680     thread-&gt;metadata_handles_do(_f);
4681   }
4682 };
4683 
4684 void Threads::metadata_handles_do(void f(Metadata*)) {
4685   // Only walk the Handles in Thread.
4686   ThreadHandlesClosure handles_closure(f);
4687   threads_do(&amp;handles_closure);
4688 }
4689 
4690 // Get count Java threads that are waiting to enter the specified monitor.
4691 GrowableArray&lt;JavaThread*&gt;* Threads::get_pending_threads(ThreadsList * t_list,
4692                                                          int count,
4693                                                          address monitor) {
4694   GrowableArray&lt;JavaThread*&gt;* result = new GrowableArray&lt;JavaThread*&gt;(count);
4695 
4696   int i = 0;
4697   DO_JAVA_THREADS(t_list, p) {
4698     if (!p-&gt;can_call_java()) continue;
4699 
<span class="line-added">4700     // The first stage of async deflation does not affect any field</span>
<span class="line-added">4701     // used by this comparison so the ObjectMonitor* is usable here.</span>
4702     address pending = (address)p-&gt;current_pending_monitor();
4703     if (pending == monitor) {             // found a match
4704       if (i &lt; count) result-&gt;append(p);   // save the first count matches
4705       i++;
4706     }
4707   }
4708 
4709   return result;
4710 }
4711 
4712 
4713 JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,
4714                                                       address owner) {
4715   // NULL owner means not locked so we can skip the search
4716   if (owner == NULL) return NULL;
4717 
4718   DO_JAVA_THREADS(t_list, p) {
4719     // first, see if owner is the address of a Java thread
4720     if (owner == (address)p) return p;
4721   }
</pre>
<hr />
<pre>
4828 // Threads::print_on_error() is called by fatal error handler. It&#39;s possible
4829 // that VM is not at safepoint and/or current thread is inside signal handler.
4830 // Don&#39;t print stack trace, as the stack may not be walkable. Don&#39;t allocate
4831 // memory (even in resource area), it might deadlock the error handler.
4832 void Threads::print_on_error(outputStream* st, Thread* current, char* buf,
4833                              int buflen) {
4834   ThreadsSMRSupport::print_info_on(st);
4835   st-&gt;cr();
4836 
4837   bool found_current = false;
4838   st-&gt;print_cr(&quot;Java Threads: ( =&gt; current thread )&quot;);
4839   ALL_JAVA_THREADS(thread) {
4840     print_on_error(thread, st, current, buf, buflen, &amp;found_current);
4841   }
4842   st-&gt;cr();
4843 
4844   st-&gt;print_cr(&quot;Other Threads:&quot;);
4845   print_on_error(VMThread::vm_thread(), st, current, buf, buflen, &amp;found_current);
4846   print_on_error(WatcherThread::watcher_thread(), st, current, buf, buflen, &amp;found_current);
4847 
<span class="line-modified">4848   if (Universe::heap() != NULL) {</span>
<span class="line-modified">4849     PrintOnErrorClosure print_closure(st, current, buf, buflen, &amp;found_current);</span>
<span class="line-added">4850     Universe::heap()-&gt;gc_threads_do(&amp;print_closure);</span>
<span class="line-added">4851   }</span>
4852 
4853   if (!found_current) {
4854     st-&gt;cr();
4855     st-&gt;print(&quot;=&gt;&quot; PTR_FORMAT &quot; (exited) &quot;, p2i(current));
4856     current-&gt;print_on_error(st, buf, buflen);
4857     st-&gt;cr();
4858   }
4859   st-&gt;cr();
4860 
4861   st-&gt;print_cr(&quot;Threads with active compile tasks:&quot;);
4862   print_threads_compiling(st, buf, buflen);
4863 }
4864 
4865 void Threads::print_threads_compiling(outputStream* st, char* buf, int buflen, bool short_form) {
4866   ALL_JAVA_THREADS(thread) {
4867     if (thread-&gt;is_Compiler_thread()) {
4868       CompilerThread* ct = (CompilerThread*) thread;
4869 
4870       // Keep task in local variable for NULL check.
4871       // ct-&gt;_task might be set to NULL by concurring compiler thread
</pre>
</td>
</tr>
</table>
<center><a href="synchronizer.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
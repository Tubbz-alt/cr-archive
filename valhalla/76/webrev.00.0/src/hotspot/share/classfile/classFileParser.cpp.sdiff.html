<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3361   _nest_members = nest_members;
3362 
3363   int index = 0;
3364   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3365   for (int n = 0; n &lt; length; n++) {
3366     const u2 class_info_index = cfs-&gt;get_u2_fast();
3367     check_property(
3368       valid_klass_reference_at(class_info_index),
3369       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3370       class_info_index, CHECK_0);
3371     nest_members-&gt;at_put(index++, class_info_index);
3372   }
3373   assert(index == size, &quot;wrong size&quot;);
3374 
3375   // Restore buffer&#39;s current position.
3376   cfs-&gt;set_current(current_mark);
3377 
3378   return length;
3379 }
3380 



































3381 //  Record {
3382 //    u2 attribute_name_index;
3383 //    u4 attribute_length;
3384 //    u2 components_count;
3385 //    component_info components[components_count];
3386 //  }
3387 //  component_info {
3388 //    u2 name_index;
3389 //    u2 descriptor_index
3390 //    u2 attributes_count;
3391 //    attribute_info_attributes[attributes_count];
3392 //  }
3393 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3394                                                      const ConstantPool* cp,
3395                                                      const u1* const record_attribute_start,
3396                                                      TRAPS) {
3397   const u1* const current_mark = cfs-&gt;current();
3398   int components_count = 0;
3399   unsigned int calculate_attr_size = 0;
3400   if (record_attribute_start != NULL) {
</pre>
<hr />
<pre>
3625     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3626     operands-&gt;at_put(operand_fill_index++, argument_count);
3627 
3628     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3629     for (int j = 0; j &lt; argument_count; j++) {
3630       const u2 argument_index = cfs-&gt;get_u2_fast();
3631       check_property(
3632         valid_cp_range(argument_index, cp_size) &amp;&amp;
3633         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3634         &quot;argument_index %u has bad constant type in class file %s&quot;,
3635         argument_index,
3636         CHECK);
3637       operands-&gt;at_put(operand_fill_index++, argument_index);
3638     }
3639   }
3640   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3641                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3642                      CHECK);
3643 }
3644 






3645 bool ClassFileParser::supports_records() {
3646   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3647     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3648     Arguments::enable_preview();</span>
3649 }
3650 
3651 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3652                                                  ConstantPool* cp,
3653                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3654                                                  TRAPS) {
3655   assert(cfs != NULL, &quot;invariant&quot;);
3656   assert(cp != NULL, &quot;invariant&quot;);
3657   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3658 
3659   // Set inner classes attribute to default sentinel
3660   _inner_classes = Universe::the_empty_short_array();
3661   // Set nest members attribute to default sentinel
3662   _nest_members = Universe::the_empty_short_array();


3663   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3664   u2 attributes_count = cfs-&gt;get_u2_fast();
3665   bool parsed_sourcefile_attribute = false;
3666   bool parsed_innerclasses_attribute = false;
3667   bool parsed_nest_members_attribute = false;

3668   bool parsed_nest_host_attribute = false;
3669   bool parsed_record_attribute = false;
3670   bool parsed_enclosingmethod_attribute = false;
3671   bool parsed_bootstrap_methods_attribute = false;
3672   const u1* runtime_visible_annotations = NULL;
3673   int runtime_visible_annotations_length = 0;
3674   const u1* runtime_invisible_annotations = NULL;
3675   int runtime_invisible_annotations_length = 0;
3676   const u1* runtime_visible_type_annotations = NULL;
3677   int runtime_visible_type_annotations_length = 0;
3678   const u1* runtime_invisible_type_annotations = NULL;
3679   int runtime_invisible_type_annotations_length = 0;
3680   bool runtime_invisible_type_annotations_exists = false;
3681   bool runtime_invisible_annotations_exists = false;
3682   bool parsed_source_debug_ext_annotations_exist = false;
3683   const u1* inner_classes_attribute_start = NULL;
3684   u4  inner_classes_attribute_length = 0;
3685   u2  enclosing_method_class_index = 0;
3686   u2  enclosing_method_method_index = 0;
3687   const u1* nest_members_attribute_start = NULL;
3688   u4  nest_members_attribute_length = 0;
3689   const u1* record_attribute_start = NULL;
3690   u4  record_attribute_length = 0;


3691 
3692   // Iterate over attributes
3693   while (attributes_count--) {
3694     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3695     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3696     const u4 attribute_length = cfs-&gt;get_u4_fast();
3697     check_property(
3698       valid_symbol_at(attribute_name_index),
3699       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3700       attribute_name_index, CHECK);
3701     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3702     if (tag == vmSymbols::tag_source_file()) {
3703       // Check for SourceFile tag
3704       if (_need_verify) {
3705         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3706       }
3707       if (parsed_sourcefile_attribute) {
3708         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3709       } else {
3710         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3887               parsed_record_attribute = true;
3888               record_attribute_start = cfs-&gt;current();
3889               record_attribute_length = attribute_length;
3890             } else if (log_is_enabled(Info, class, record)) {
3891               // Log why the Record attribute was ignored.  Note that if the
3892               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3893               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3894               // exception would have been thrown.
3895               ResourceMark rm(THREAD);
3896               if (supports_records()) {
3897                 log_info(class, record)(
3898                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3899                   _class_name-&gt;as_C_string());
3900               } else {
3901                 log_info(class, record)(
3902                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3903                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3904               }
3905             }
3906             cfs-&gt;skip_u1(attribute_length, CHECK);




















3907           } else {
3908             // Unknown attribute
3909             cfs-&gt;skip_u1(attribute_length, CHECK);
3910           }
3911         } else {
3912           // Unknown attribute
3913           cfs-&gt;skip_u1(attribute_length, CHECK);
3914         }
3915       } else {
3916         // Unknown attribute
3917         cfs-&gt;skip_u1(attribute_length, CHECK);
3918       }
3919     } else {
3920       // Unknown attribute
3921       cfs-&gt;skip_u1(attribute_length, CHECK);
3922     }
3923   }
3924   _class_annotations = assemble_annotations(runtime_visible_annotations,
3925                                             runtime_visible_annotations_length,
3926                                             runtime_invisible_annotations,
</pre>
<hr />
<pre>
3955     if (_need_verify) {
3956       guarantee_property(
3957         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3958         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3959     }
3960   }
3961 
3962   if (parsed_record_attribute) {
3963     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3964                             cfs,
3965                             cp,
3966                             record_attribute_start,
3967                             CHECK);
3968     if (_need_verify) {
3969       guarantee_property(record_attribute_length == calculated_attr_length,
3970                          &quot;Record attribute has wrong length in class file %s&quot;,
3971                          CHECK);
3972     }
3973   }
3974 












3975   if (_max_bootstrap_specifier_index &gt;= 0) {
3976     guarantee_property(parsed_bootstrap_methods_attribute,
3977                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3978   }
3979 }
3980 
3981 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3982   assert(k != NULL, &quot;invariant&quot;);
3983 
3984   if (_synthetic_flag)
3985     k-&gt;set_is_synthetic();
3986   if (_sourcefile_index != 0) {
3987     k-&gt;set_source_file_name_index(_sourcefile_index);
3988   }
3989   if (_generic_signature_index != 0) {
3990     k-&gt;set_generic_signature_index(_generic_signature_index);
3991   }
3992   if (_sde_buffer != NULL) {
3993     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3994   }
</pre>
<hr />
<pre>
4022     _fields_annotations      = NULL;
4023     _fields_type_annotations = NULL;
4024 }
4025 
4026 // Transfer ownership of metadata allocated to the InstanceKlass.
4027 void ClassFileParser::apply_parsed_class_metadata(
4028                                             InstanceKlass* this_klass,
4029                                             int java_fields_count,
4030                                             TRAPS) {
4031   assert(this_klass != NULL, &quot;invariant&quot;);
4032 
4033   _cp-&gt;set_pool_holder(this_klass);
4034   this_klass-&gt;set_constants(_cp);
4035   this_klass-&gt;set_fields(_fields, java_fields_count);
4036   this_klass-&gt;set_methods(_methods);
4037   this_klass-&gt;set_inner_classes(_inner_classes);
4038   this_klass-&gt;set_nest_members(_nest_members);
4039   this_klass-&gt;set_nest_host_index(_nest_host);
4040   this_klass-&gt;set_local_interfaces(_local_interfaces);
4041   this_klass-&gt;set_annotations(_combined_annotations);

4042   this_klass-&gt;set_record_components(_record_components);
4043   // Delay the setting of _transitive_interfaces until after initialize_supers() in
4044   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
4045   // its _super. If an OOM occurs while loading the current klass, its _super field
4046   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4047   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4048   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4049 
4050   // Clear out these fields so they don&#39;t get deallocated by the destructor
4051   clear_class_metadata();
4052 }
4053 
4054 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4055                                                        int runtime_visible_annotations_length,
4056                                                        const u1* const runtime_invisible_annotations,
4057                                                        int runtime_invisible_annotations_length,
4058                                                        TRAPS) {
4059   AnnotationArray* annotations = NULL;
4060   if (runtime_visible_annotations != NULL ||
4061       runtime_invisible_annotations != NULL) {
</pre>
<hr />
<pre>
5051     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
5052       return Universe::the_single_IdentityObject_klass_array();
5053     }
5054 
5055     Array&lt;InstanceKlass*&gt;* const new_result =
5056       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5057     for (int i = 0; i &lt; length; i++) {
5058       InstanceKlass* const e = result-&gt;at(i);
5059       assert(e != NULL, &quot;just checking&quot;);
5060       new_result-&gt;at_put(i, e);
5061     }
5062     return new_result;
5063   }
5064 }
5065 
5066 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5067   assert(this_klass != NULL, &quot;invariant&quot;);
5068   const Klass* const super = this_klass-&gt;super();
5069 
5070   if (super != NULL) {























5071 
5072     // If the loader is not the boot loader then throw an exception if its
5073     // superclass is in package jdk.internal.reflect and its loader is not a
5074     // special reflection class loader
5075     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
<span class="line-removed">5076       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);</span>
5077       PackageEntry* super_package = super-&gt;package();
5078       if (super_package != NULL &amp;&amp;
5079           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
5080           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
5081         ResourceMark rm(THREAD);
5082         Exceptions::fthrow(
5083           THREAD_AND_LOCATION,
5084           vmSymbols::java_lang_IllegalAccessError(),
5085           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
5086           this_klass-&gt;external_name(),
5087           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
5088           super-&gt;external_name());
5089         return;
5090       }
5091     }
5092 
5093     Reflection::VerifyClassAccessResults vca_result =
5094       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
5095     if (vca_result != Reflection::ACCESS_OK) {
5096       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
5112       } else {
5113         // Add additional message content.
5114         Exceptions::fthrow(
5115           THREAD_AND_LOCATION,
5116           vmSymbols::java_lang_IllegalAccessError(),
5117           &quot;superclass access check failed: %s&quot;,
5118           msg);
5119       }
5120     }
5121   }
5122 }
5123 
5124 
5125 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
5126   assert(this_klass != NULL, &quot;invariant&quot;);
5127   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
5128   const int lng = local_interfaces-&gt;length();
5129   for (int i = lng - 1; i &gt;= 0; i--) {
5130     InstanceKlass* const k = local_interfaces-&gt;at(i);
5131     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);













5132     Reflection::VerifyClassAccessResults vca_result =
5133       Reflection::verify_class_access(this_klass, k, false);
5134     if (vca_result != Reflection::ACCESS_OK) {
5135       ResourceMark rm(THREAD);
5136       char* msg = Reflection::verify_class_access_msg(this_klass,
5137                                                       k,
5138                                                       vca_result);
5139       if (msg == NULL) {
5140         bool same_module = (this_klass-&gt;module() == k-&gt;module());
5141         Exceptions::fthrow(
5142           THREAD_AND_LOCATION,
5143           vmSymbols::java_lang_IllegalAccessError(),
5144           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
5145           this_klass-&gt;external_name(),
5146           k-&gt;external_name(),
5147           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
5148           (same_module) ? &quot;&quot; : &quot;; &quot;,
5149           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
5150       } else {
5151         // Add additional message content.
</pre>
<hr />
<pre>
6167   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6168 
6169   // this transfers ownership of a lot of arrays from
6170   // the parser onto the InstanceKlass*
6171   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6172 
6173   // can only set dynamic nest-host after static nest information is set
6174   if (cl_inst_info.dynamic_nest_host() != NULL) {
6175     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6176   }
6177 
6178   // note that is not safe to use the fields in the parser from this point on
6179   assert(NULL == _cp, &quot;invariant&quot;);
6180   assert(NULL == _fields, &quot;invariant&quot;);
6181   assert(NULL == _methods, &quot;invariant&quot;);
6182   assert(NULL == _inner_classes, &quot;invariant&quot;);
6183   assert(NULL == _nest_members, &quot;invariant&quot;);
6184   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6185   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6186   assert(NULL == _record_components, &quot;invariant&quot;);

6187 
6188   if (_has_final_method) {
6189     ik-&gt;set_has_final_method();
6190   }
6191 
6192   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6193   // The InstanceKlass::_methods_jmethod_ids cache
6194   // is managed on the assumption that the initial cache
6195   // size is equal to the number of methods in the class. If
6196   // that changes, then InstanceKlass::idnum_can_increment()
6197   // has to be changed accordingly.
6198   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6199 
6200   ik-&gt;set_this_class_index(_this_class_index);
6201 
6202   if (_is_hidden || is_unsafe_anonymous()) {
6203     // _this_class_index is a CONSTANT_Class entry that refers to this
6204     // hidden or anonymous class itself. If this class needs to refer to its own
6205     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6206     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
</pre>
<hr />
<pre>
6496                                  Publicity pub_level,
6497                                  TRAPS) :
6498   _stream(stream),
6499   _class_name(NULL),
6500   _loader_data(loader_data),
6501   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6502   _cp_patches(cl_info-&gt;cp_patches()),
6503   _is_hidden(cl_info-&gt;is_hidden()),
6504   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6505   _num_patched_klasses(0),
6506   _max_num_patched_klasses(0),
6507   _orig_cp_size(0),
6508   _first_patched_klass_resolved_index(0),
6509   _super_klass(),
6510   _cp(NULL),
6511   _fields(NULL),
6512   _methods(NULL),
6513   _inner_classes(NULL),
6514   _nest_members(NULL),
6515   _nest_host(0),

6516   _record_components(NULL),
6517   _temp_local_interfaces(NULL),
6518   _local_interfaces(NULL),
6519   _transitive_interfaces(NULL),
6520   _combined_annotations(NULL),
6521   _class_annotations(NULL),
6522   _class_type_annotations(NULL),
6523   _fields_annotations(NULL),
6524   _fields_type_annotations(NULL),
6525   _klass(NULL),
6526   _klass_to_deallocate(NULL),
6527   _parsed_annotations(NULL),
6528   _fac(NULL),
6529   _field_info(NULL),
6530   _method_ordering(NULL),
6531   _all_mirandas(NULL),
6532   _vtable_size(0),
6533   _itable_size(0),
6534   _num_miranda_methods(0),
6535   _rt(REF_NONE),
</pre>
<hr />
<pre>
6614   // synch back verification state to stream
6615   stream-&gt;set_verify(_need_verify);
6616 
6617   // Check if verification needs to be relaxed for this class file
6618   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6619   _relax_verify = relax_format_check_for(_loader_data);
6620 
6621   parse_stream(stream, CHECK);
6622 
6623   post_process_parsed_stream(stream, _cp, CHECK);
6624 }
6625 
6626 void ClassFileParser::clear_class_metadata() {
6627   // metadata created before the instance klass is created.  Must be
6628   // deallocated if classfile parsing returns an error.
6629   _cp = NULL;
6630   _fields = NULL;
6631   _methods = NULL;
6632   _inner_classes = NULL;
6633   _nest_members = NULL;

6634   _local_interfaces = NULL;
6635   _combined_annotations = NULL;
6636   _class_annotations = _class_type_annotations = NULL;
6637   _fields_annotations = _fields_type_annotations = NULL;
6638   _record_components = NULL;
6639 }
6640 
6641 // Destructor to clean up
6642 ClassFileParser::~ClassFileParser() {
6643   _class_name-&gt;decrement_refcount();
6644 
6645   if (_cp != NULL) {
6646     MetadataFactory::free_metadata(_loader_data, _cp);
6647   }
6648   if (_fields != NULL) {
6649     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6650   }
6651 
6652   if (_methods != NULL) {
6653     // Free methods
6654     InstanceKlass::deallocate_methods(_loader_data, _methods);
6655   }
6656 
6657   // beware of the Universe::empty_blah_array!!
6658   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6659     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6660   }
6661 
6662   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6663     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6664   }
6665 
6666   if (_record_components != NULL) {
6667     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6668   }
6669 




6670   // Free interfaces
6671   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6672                                        _local_interfaces, _transitive_interfaces);
6673 
6674   if (_combined_annotations != NULL) {
6675     // After all annotations arrays have been created, they are installed into the
6676     // Annotations object that will be assigned to the InstanceKlass being created.
6677 
6678     // Deallocate the Annotations object and the installed annotations arrays.
6679     _combined_annotations-&gt;deallocate_contents(_loader_data);
6680 
6681     // If the _combined_annotations pointer is non-NULL,
6682     // then the other annotations fields should have been cleared.
6683     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6684     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6685     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6686     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6687   } else {
6688     // If the annotations arrays were not installed into the Annotations object,
6689     // then they have to be deallocated explicitly.
</pre>
<hr />
<pre>
7060   if (_super_klass != NULL) {
7061     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7062       _has_nonstatic_concrete_methods = true;
7063     }
7064     if (_super_klass-&gt;is_declared_atomic()) {
7065       _is_declared_atomic = true;
7066     }
7067 
7068     if (_super_klass-&gt;is_interface()) {
7069       ResourceMark rm(THREAD);
7070       Exceptions::fthrow(
7071         THREAD_AND_LOCATION,
7072         vmSymbols::java_lang_IncompatibleClassChangeError(),
7073         &quot;class %s has interface %s as super class&quot;,
7074         _class_name-&gt;as_klass_external_name(),
7075         _super_klass-&gt;external_name()
7076       );
7077       return;
7078     }
7079 
<span class="line-removed">7080     // Make sure super class is not final</span>
<span class="line-removed">7081     if (_super_klass-&gt;is_final()) {</span>
<span class="line-removed">7082       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);</span>
<span class="line-removed">7083     }</span>
<span class="line-removed">7084 </span>
7085     // For an inline class, only java/lang/Object or special abstract classes
7086     // are acceptable super classes.
7087     if (is_inline_type()) {
7088       const InstanceKlass* super_ik = _super_klass;
7089       if (super_ik-&gt;invalid_inline_super()) {
7090         ResourceMark rm(THREAD);
7091         Exceptions::fthrow(
7092           THREAD_AND_LOCATION,
7093           vmSymbols::java_lang_IncompatibleClassChangeError(),
7094           &quot;inline class %s has an invalid super class %s&quot;,
7095           _class_name-&gt;as_klass_external_name(),
7096           _super_klass-&gt;external_name());
7097         return;
7098       }
7099     }
7100   }
7101 
7102   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7103     // This is the original source of this condition.
7104     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
</pre>
</td>
<td>
<hr />
<pre>
3361   _nest_members = nest_members;
3362 
3363   int index = 0;
3364   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3365   for (int n = 0; n &lt; length; n++) {
3366     const u2 class_info_index = cfs-&gt;get_u2_fast();
3367     check_property(
3368       valid_klass_reference_at(class_info_index),
3369       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3370       class_info_index, CHECK_0);
3371     nest_members-&gt;at_put(index++, class_info_index);
3372   }
3373   assert(index == size, &quot;wrong size&quot;);
3374 
3375   // Restore buffer&#39;s current position.
3376   cfs-&gt;set_current(current_mark);
3377 
3378   return length;
3379 }
3380 
<span class="line-added">3381 u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,</span>
<span class="line-added">3382                                                                    const u1* const permitted_subclasses_attribute_start,</span>
<span class="line-added">3383                                                                    TRAPS) {</span>
<span class="line-added">3384   const u1* const current_mark = cfs-&gt;current();</span>
<span class="line-added">3385   u2 length = 0;</span>
<span class="line-added">3386   if (permitted_subclasses_attribute_start != NULL) {</span>
<span class="line-added">3387     cfs-&gt;set_current(permitted_subclasses_attribute_start);</span>
<span class="line-added">3388     cfs-&gt;guarantee_more(2, CHECK_0);  // length</span>
<span class="line-added">3389     length = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3390   }</span>
<span class="line-added">3391   if (length &lt; 1) {</span>
<span class="line-added">3392     classfile_parse_error(&quot;PermittedSubclasses attribute is empty in class file %s&quot;, CHECK_0);</span>
<span class="line-added">3393   }</span>
<span class="line-added">3394   const int size = length;</span>
<span class="line-added">3395   Array&lt;u2&gt;* const permitted_subclasses = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);</span>
<span class="line-added">3396   _permitted_subclasses = permitted_subclasses;</span>
<span class="line-added">3397 </span>
<span class="line-added">3398   int index = 0;</span>
<span class="line-added">3399   cfs-&gt;guarantee_more(2 * length, CHECK_0);</span>
<span class="line-added">3400   for (int n = 0; n &lt; length; n++) {</span>
<span class="line-added">3401     const u2 class_info_index = cfs-&gt;get_u2_fast();</span>
<span class="line-added">3402     check_property(</span>
<span class="line-added">3403       valid_klass_reference_at(class_info_index),</span>
<span class="line-added">3404       &quot;Permitted subclass class_info_index %u has bad constant type in class file %s&quot;,</span>
<span class="line-added">3405       class_info_index, CHECK_0);</span>
<span class="line-added">3406     permitted_subclasses-&gt;at_put(index++, class_info_index);</span>
<span class="line-added">3407   }</span>
<span class="line-added">3408   assert(index == size, &quot;wrong size&quot;);</span>
<span class="line-added">3409 </span>
<span class="line-added">3410   // Restore buffer&#39;s current position.</span>
<span class="line-added">3411   cfs-&gt;set_current(current_mark);</span>
<span class="line-added">3412 </span>
<span class="line-added">3413   return length;</span>
<span class="line-added">3414 }</span>
<span class="line-added">3415 </span>
3416 //  Record {
3417 //    u2 attribute_name_index;
3418 //    u4 attribute_length;
3419 //    u2 components_count;
3420 //    component_info components[components_count];
3421 //  }
3422 //  component_info {
3423 //    u2 name_index;
3424 //    u2 descriptor_index
3425 //    u2 attributes_count;
3426 //    attribute_info_attributes[attributes_count];
3427 //  }
3428 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3429                                                      const ConstantPool* cp,
3430                                                      const u1* const record_attribute_start,
3431                                                      TRAPS) {
3432   const u1* const current_mark = cfs-&gt;current();
3433   int components_count = 0;
3434   unsigned int calculate_attr_size = 0;
3435   if (record_attribute_start != NULL) {
</pre>
<hr />
<pre>
3660     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3661     operands-&gt;at_put(operand_fill_index++, argument_count);
3662 
3663     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3664     for (int j = 0; j &lt; argument_count; j++) {
3665       const u2 argument_index = cfs-&gt;get_u2_fast();
3666       check_property(
3667         valid_cp_range(argument_index, cp_size) &amp;&amp;
3668         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3669         &quot;argument_index %u has bad constant type in class file %s&quot;,
3670         argument_index,
3671         CHECK);
3672       operands-&gt;at_put(operand_fill_index++, argument_index);
3673     }
3674   }
3675   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3676                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3677                      CHECK);
3678 }
3679 
<span class="line-added">3680 bool ClassFileParser::supports_sealed_types() {</span>
<span class="line-added">3681   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;</span>
<span class="line-added">3682          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-added">3683          Arguments::enable_preview();</span>
<span class="line-added">3684 }</span>
<span class="line-added">3685 </span>
3686 bool ClassFileParser::supports_records() {
3687   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
<span class="line-modified">3688          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;</span>
<span class="line-modified">3689          Arguments::enable_preview();</span>
3690 }
3691 
3692 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3693                                                  ConstantPool* cp,
3694                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3695                                                  TRAPS) {
3696   assert(cfs != NULL, &quot;invariant&quot;);
3697   assert(cp != NULL, &quot;invariant&quot;);
3698   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3699 
3700   // Set inner classes attribute to default sentinel
3701   _inner_classes = Universe::the_empty_short_array();
3702   // Set nest members attribute to default sentinel
3703   _nest_members = Universe::the_empty_short_array();
<span class="line-added">3704   // Set _permitted_subclasses attribute to default sentinel</span>
<span class="line-added">3705   _permitted_subclasses = Universe::the_empty_short_array();</span>
3706   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3707   u2 attributes_count = cfs-&gt;get_u2_fast();
3708   bool parsed_sourcefile_attribute = false;
3709   bool parsed_innerclasses_attribute = false;
3710   bool parsed_nest_members_attribute = false;
<span class="line-added">3711   bool parsed_permitted_subclasses_attribute = false;</span>
3712   bool parsed_nest_host_attribute = false;
3713   bool parsed_record_attribute = false;
3714   bool parsed_enclosingmethod_attribute = false;
3715   bool parsed_bootstrap_methods_attribute = false;
3716   const u1* runtime_visible_annotations = NULL;
3717   int runtime_visible_annotations_length = 0;
3718   const u1* runtime_invisible_annotations = NULL;
3719   int runtime_invisible_annotations_length = 0;
3720   const u1* runtime_visible_type_annotations = NULL;
3721   int runtime_visible_type_annotations_length = 0;
3722   const u1* runtime_invisible_type_annotations = NULL;
3723   int runtime_invisible_type_annotations_length = 0;
3724   bool runtime_invisible_type_annotations_exists = false;
3725   bool runtime_invisible_annotations_exists = false;
3726   bool parsed_source_debug_ext_annotations_exist = false;
3727   const u1* inner_classes_attribute_start = NULL;
3728   u4  inner_classes_attribute_length = 0;
3729   u2  enclosing_method_class_index = 0;
3730   u2  enclosing_method_method_index = 0;
3731   const u1* nest_members_attribute_start = NULL;
3732   u4  nest_members_attribute_length = 0;
3733   const u1* record_attribute_start = NULL;
3734   u4  record_attribute_length = 0;
<span class="line-added">3735   const u1* permitted_subclasses_attribute_start = NULL;</span>
<span class="line-added">3736   u4  permitted_subclasses_attribute_length = 0;</span>
3737 
3738   // Iterate over attributes
3739   while (attributes_count--) {
3740     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3741     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3742     const u4 attribute_length = cfs-&gt;get_u4_fast();
3743     check_property(
3744       valid_symbol_at(attribute_name_index),
3745       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3746       attribute_name_index, CHECK);
3747     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3748     if (tag == vmSymbols::tag_source_file()) {
3749       // Check for SourceFile tag
3750       if (_need_verify) {
3751         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3752       }
3753       if (parsed_sourcefile_attribute) {
3754         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3755       } else {
3756         parsed_sourcefile_attribute = true;
</pre>
<hr />
<pre>
3933               parsed_record_attribute = true;
3934               record_attribute_start = cfs-&gt;current();
3935               record_attribute_length = attribute_length;
3936             } else if (log_is_enabled(Info, class, record)) {
3937               // Log why the Record attribute was ignored.  Note that if the
3938               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3939               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3940               // exception would have been thrown.
3941               ResourceMark rm(THREAD);
3942               if (supports_records()) {
3943                 log_info(class, record)(
3944                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3945                   _class_name-&gt;as_C_string());
3946               } else {
3947                 log_info(class, record)(
3948                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3949                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3950               }
3951             }
3952             cfs-&gt;skip_u1(attribute_length, CHECK);
<span class="line-added">3953           } else if (_major_version &gt;= JAVA_15_VERSION) {</span>
<span class="line-added">3954             // Check for PermittedSubclasses tag</span>
<span class="line-added">3955             if (tag == vmSymbols::tag_permitted_subclasses()) {</span>
<span class="line-added">3956               if (supports_sealed_types()) {</span>
<span class="line-added">3957                 if (parsed_permitted_subclasses_attribute) {</span>
<span class="line-added">3958                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);</span>
<span class="line-added">3959                 }</span>
<span class="line-added">3960                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.</span>
<span class="line-added">3961                 if (_access_flags.is_final()) {</span>
<span class="line-added">3962                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);</span>
<span class="line-added">3963                 }</span>
<span class="line-added">3964                 parsed_permitted_subclasses_attribute = true;</span>
<span class="line-added">3965                 permitted_subclasses_attribute_start = cfs-&gt;current();</span>
<span class="line-added">3966                 permitted_subclasses_attribute_length = attribute_length;</span>
<span class="line-added">3967               }</span>
<span class="line-added">3968               cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3969             } else {</span>
<span class="line-added">3970               // Unknown attribute</span>
<span class="line-added">3971               cfs-&gt;skip_u1(attribute_length, CHECK);</span>
<span class="line-added">3972             }</span>
3973           } else {
3974             // Unknown attribute
3975             cfs-&gt;skip_u1(attribute_length, CHECK);
3976           }
3977         } else {
3978           // Unknown attribute
3979           cfs-&gt;skip_u1(attribute_length, CHECK);
3980         }
3981       } else {
3982         // Unknown attribute
3983         cfs-&gt;skip_u1(attribute_length, CHECK);
3984       }
3985     } else {
3986       // Unknown attribute
3987       cfs-&gt;skip_u1(attribute_length, CHECK);
3988     }
3989   }
3990   _class_annotations = assemble_annotations(runtime_visible_annotations,
3991                                             runtime_visible_annotations_length,
3992                                             runtime_invisible_annotations,
</pre>
<hr />
<pre>
4021     if (_need_verify) {
4022       guarantee_property(
4023         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
4024         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
4025     }
4026   }
4027 
4028   if (parsed_record_attribute) {
4029     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
4030                             cfs,
4031                             cp,
4032                             record_attribute_start,
4033                             CHECK);
4034     if (_need_verify) {
4035       guarantee_property(record_attribute_length == calculated_attr_length,
4036                          &quot;Record attribute has wrong length in class file %s&quot;,
4037                          CHECK);
4038     }
4039   }
4040 
<span class="line-added">4041   if (parsed_permitted_subclasses_attribute) {</span>
<span class="line-added">4042     const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(</span>
<span class="line-added">4043                             cfs,</span>
<span class="line-added">4044                             permitted_subclasses_attribute_start,</span>
<span class="line-added">4045                             CHECK);</span>
<span class="line-added">4046     if (_need_verify) {</span>
<span class="line-added">4047       guarantee_property(</span>
<span class="line-added">4048         permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,</span>
<span class="line-added">4049         &quot;Wrong PermittedSubclasses attribute length in class file %s&quot;, CHECK);</span>
<span class="line-added">4050     }</span>
<span class="line-added">4051   }</span>
<span class="line-added">4052 </span>
4053   if (_max_bootstrap_specifier_index &gt;= 0) {
4054     guarantee_property(parsed_bootstrap_methods_attribute,
4055                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
4056   }
4057 }
4058 
4059 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
4060   assert(k != NULL, &quot;invariant&quot;);
4061 
4062   if (_synthetic_flag)
4063     k-&gt;set_is_synthetic();
4064   if (_sourcefile_index != 0) {
4065     k-&gt;set_source_file_name_index(_sourcefile_index);
4066   }
4067   if (_generic_signature_index != 0) {
4068     k-&gt;set_generic_signature_index(_generic_signature_index);
4069   }
4070   if (_sde_buffer != NULL) {
4071     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
4072   }
</pre>
<hr />
<pre>
4100     _fields_annotations      = NULL;
4101     _fields_type_annotations = NULL;
4102 }
4103 
4104 // Transfer ownership of metadata allocated to the InstanceKlass.
4105 void ClassFileParser::apply_parsed_class_metadata(
4106                                             InstanceKlass* this_klass,
4107                                             int java_fields_count,
4108                                             TRAPS) {
4109   assert(this_klass != NULL, &quot;invariant&quot;);
4110 
4111   _cp-&gt;set_pool_holder(this_klass);
4112   this_klass-&gt;set_constants(_cp);
4113   this_klass-&gt;set_fields(_fields, java_fields_count);
4114   this_klass-&gt;set_methods(_methods);
4115   this_klass-&gt;set_inner_classes(_inner_classes);
4116   this_klass-&gt;set_nest_members(_nest_members);
4117   this_klass-&gt;set_nest_host_index(_nest_host);
4118   this_klass-&gt;set_local_interfaces(_local_interfaces);
4119   this_klass-&gt;set_annotations(_combined_annotations);
<span class="line-added">4120   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);</span>
4121   this_klass-&gt;set_record_components(_record_components);
4122   // Delay the setting of _transitive_interfaces until after initialize_supers() in
4123   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
4124   // its _super. If an OOM occurs while loading the current klass, its _super field
4125   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4126   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4127   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4128 
4129   // Clear out these fields so they don&#39;t get deallocated by the destructor
4130   clear_class_metadata();
4131 }
4132 
4133 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4134                                                        int runtime_visible_annotations_length,
4135                                                        const u1* const runtime_invisible_annotations,
4136                                                        int runtime_invisible_annotations_length,
4137                                                        TRAPS) {
4138   AnnotationArray* annotations = NULL;
4139   if (runtime_visible_annotations != NULL ||
4140       runtime_invisible_annotations != NULL) {
</pre>
<hr />
<pre>
5130     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
5131       return Universe::the_single_IdentityObject_klass_array();
5132     }
5133 
5134     Array&lt;InstanceKlass*&gt;* const new_result =
5135       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5136     for (int i = 0; i &lt; length; i++) {
5137       InstanceKlass* const e = result-&gt;at(i);
5138       assert(e != NULL, &quot;just checking&quot;);
5139       new_result-&gt;at_put(i, e);
5140     }
5141     return new_result;
5142   }
5143 }
5144 
5145 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5146   assert(this_klass != NULL, &quot;invariant&quot;);
5147   const Klass* const super = this_klass-&gt;super();
5148 
5149   if (super != NULL) {
<span class="line-added">5150     const InstanceKlass* super_ik = InstanceKlass::cast(super);</span>
<span class="line-added">5151 </span>
<span class="line-added">5152     if (super-&gt;is_final()) {</span>
<span class="line-added">5153       ResourceMark rm(THREAD);</span>
<span class="line-added">5154       Exceptions::fthrow(</span>
<span class="line-added">5155         THREAD_AND_LOCATION,</span>
<span class="line-added">5156         vmSymbols::java_lang_VerifyError(),</span>
<span class="line-added">5157         &quot;class %s cannot inherit from final class %s&quot;,</span>
<span class="line-added">5158         this_klass-&gt;external_name(),</span>
<span class="line-added">5159         super_ik-&gt;external_name());</span>
<span class="line-added">5160       return;</span>
<span class="line-added">5161     }</span>
<span class="line-added">5162 </span>
<span class="line-added">5163     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {</span>
<span class="line-added">5164       ResourceMark rm(THREAD);</span>
<span class="line-added">5165       Exceptions::fthrow(</span>
<span class="line-added">5166         THREAD_AND_LOCATION,</span>
<span class="line-added">5167         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">5168         &quot;class %s cannot inherit from sealed class %s&quot;,</span>
<span class="line-added">5169         this_klass-&gt;external_name(),</span>
<span class="line-added">5170         super_ik-&gt;external_name());</span>
<span class="line-added">5171       return;</span>
<span class="line-added">5172     }</span>
5173 
5174     // If the loader is not the boot loader then throw an exception if its
5175     // superclass is in package jdk.internal.reflect and its loader is not a
5176     // special reflection class loader
5177     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {

5178       PackageEntry* super_package = super-&gt;package();
5179       if (super_package != NULL &amp;&amp;
5180           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
5181           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
5182         ResourceMark rm(THREAD);
5183         Exceptions::fthrow(
5184           THREAD_AND_LOCATION,
5185           vmSymbols::java_lang_IllegalAccessError(),
5186           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
5187           this_klass-&gt;external_name(),
5188           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
5189           super-&gt;external_name());
5190         return;
5191       }
5192     }
5193 
5194     Reflection::VerifyClassAccessResults vca_result =
5195       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
5196     if (vca_result != Reflection::ACCESS_OK) {
5197       ResourceMark rm(THREAD);
</pre>
<hr />
<pre>
5213       } else {
5214         // Add additional message content.
5215         Exceptions::fthrow(
5216           THREAD_AND_LOCATION,
5217           vmSymbols::java_lang_IllegalAccessError(),
5218           &quot;superclass access check failed: %s&quot;,
5219           msg);
5220       }
5221     }
5222   }
5223 }
5224 
5225 
5226 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
5227   assert(this_klass != NULL, &quot;invariant&quot;);
5228   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
5229   const int lng = local_interfaces-&gt;length();
5230   for (int i = lng - 1; i &gt;= 0; i--) {
5231     InstanceKlass* const k = local_interfaces-&gt;at(i);
5232     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
<span class="line-added">5233 </span>
<span class="line-added">5234     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {</span>
<span class="line-added">5235       ResourceMark rm(THREAD);</span>
<span class="line-added">5236       Exceptions::fthrow(</span>
<span class="line-added">5237         THREAD_AND_LOCATION,</span>
<span class="line-added">5238         vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">5239         &quot;class %s cannot %s sealed interface %s&quot;,</span>
<span class="line-added">5240         this_klass-&gt;external_name(),</span>
<span class="line-added">5241         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,</span>
<span class="line-added">5242         k-&gt;external_name());</span>
<span class="line-added">5243       return;</span>
<span class="line-added">5244     }</span>
<span class="line-added">5245 </span>
5246     Reflection::VerifyClassAccessResults vca_result =
5247       Reflection::verify_class_access(this_klass, k, false);
5248     if (vca_result != Reflection::ACCESS_OK) {
5249       ResourceMark rm(THREAD);
5250       char* msg = Reflection::verify_class_access_msg(this_klass,
5251                                                       k,
5252                                                       vca_result);
5253       if (msg == NULL) {
5254         bool same_module = (this_klass-&gt;module() == k-&gt;module());
5255         Exceptions::fthrow(
5256           THREAD_AND_LOCATION,
5257           vmSymbols::java_lang_IllegalAccessError(),
5258           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
5259           this_klass-&gt;external_name(),
5260           k-&gt;external_name(),
5261           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
5262           (same_module) ? &quot;&quot; : &quot;; &quot;,
5263           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
5264       } else {
5265         // Add additional message content.
</pre>
<hr />
<pre>
6281   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6282 
6283   // this transfers ownership of a lot of arrays from
6284   // the parser onto the InstanceKlass*
6285   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6286 
6287   // can only set dynamic nest-host after static nest information is set
6288   if (cl_inst_info.dynamic_nest_host() != NULL) {
6289     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6290   }
6291 
6292   // note that is not safe to use the fields in the parser from this point on
6293   assert(NULL == _cp, &quot;invariant&quot;);
6294   assert(NULL == _fields, &quot;invariant&quot;);
6295   assert(NULL == _methods, &quot;invariant&quot;);
6296   assert(NULL == _inner_classes, &quot;invariant&quot;);
6297   assert(NULL == _nest_members, &quot;invariant&quot;);
6298   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6299   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6300   assert(NULL == _record_components, &quot;invariant&quot;);
<span class="line-added">6301   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);</span>
6302 
6303   if (_has_final_method) {
6304     ik-&gt;set_has_final_method();
6305   }
6306 
6307   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6308   // The InstanceKlass::_methods_jmethod_ids cache
6309   // is managed on the assumption that the initial cache
6310   // size is equal to the number of methods in the class. If
6311   // that changes, then InstanceKlass::idnum_can_increment()
6312   // has to be changed accordingly.
6313   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6314 
6315   ik-&gt;set_this_class_index(_this_class_index);
6316 
6317   if (_is_hidden || is_unsafe_anonymous()) {
6318     // _this_class_index is a CONSTANT_Class entry that refers to this
6319     // hidden or anonymous class itself. If this class needs to refer to its own
6320     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6321     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
</pre>
<hr />
<pre>
6611                                  Publicity pub_level,
6612                                  TRAPS) :
6613   _stream(stream),
6614   _class_name(NULL),
6615   _loader_data(loader_data),
6616   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6617   _cp_patches(cl_info-&gt;cp_patches()),
6618   _is_hidden(cl_info-&gt;is_hidden()),
6619   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6620   _num_patched_klasses(0),
6621   _max_num_patched_klasses(0),
6622   _orig_cp_size(0),
6623   _first_patched_klass_resolved_index(0),
6624   _super_klass(),
6625   _cp(NULL),
6626   _fields(NULL),
6627   _methods(NULL),
6628   _inner_classes(NULL),
6629   _nest_members(NULL),
6630   _nest_host(0),
<span class="line-added">6631   _permitted_subclasses(NULL),</span>
6632   _record_components(NULL),
6633   _temp_local_interfaces(NULL),
6634   _local_interfaces(NULL),
6635   _transitive_interfaces(NULL),
6636   _combined_annotations(NULL),
6637   _class_annotations(NULL),
6638   _class_type_annotations(NULL),
6639   _fields_annotations(NULL),
6640   _fields_type_annotations(NULL),
6641   _klass(NULL),
6642   _klass_to_deallocate(NULL),
6643   _parsed_annotations(NULL),
6644   _fac(NULL),
6645   _field_info(NULL),
6646   _method_ordering(NULL),
6647   _all_mirandas(NULL),
6648   _vtable_size(0),
6649   _itable_size(0),
6650   _num_miranda_methods(0),
6651   _rt(REF_NONE),
</pre>
<hr />
<pre>
6730   // synch back verification state to stream
6731   stream-&gt;set_verify(_need_verify);
6732 
6733   // Check if verification needs to be relaxed for this class file
6734   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6735   _relax_verify = relax_format_check_for(_loader_data);
6736 
6737   parse_stream(stream, CHECK);
6738 
6739   post_process_parsed_stream(stream, _cp, CHECK);
6740 }
6741 
6742 void ClassFileParser::clear_class_metadata() {
6743   // metadata created before the instance klass is created.  Must be
6744   // deallocated if classfile parsing returns an error.
6745   _cp = NULL;
6746   _fields = NULL;
6747   _methods = NULL;
6748   _inner_classes = NULL;
6749   _nest_members = NULL;
<span class="line-added">6750   _permitted_subclasses = NULL;</span>
6751   _local_interfaces = NULL;
6752   _combined_annotations = NULL;
6753   _class_annotations = _class_type_annotations = NULL;
6754   _fields_annotations = _fields_type_annotations = NULL;
6755   _record_components = NULL;
6756 }
6757 
6758 // Destructor to clean up
6759 ClassFileParser::~ClassFileParser() {
6760   _class_name-&gt;decrement_refcount();
6761 
6762   if (_cp != NULL) {
6763     MetadataFactory::free_metadata(_loader_data, _cp);
6764   }
6765   if (_fields != NULL) {
6766     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6767   }
6768 
6769   if (_methods != NULL) {
6770     // Free methods
6771     InstanceKlass::deallocate_methods(_loader_data, _methods);
6772   }
6773 
6774   // beware of the Universe::empty_blah_array!!
6775   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6776     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6777   }
6778 
6779   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6780     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6781   }
6782 
6783   if (_record_components != NULL) {
6784     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6785   }
6786 
<span class="line-added">6787   if (_permitted_subclasses != NULL &amp;&amp; _permitted_subclasses != Universe::the_empty_short_array()) {</span>
<span class="line-added">6788     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _permitted_subclasses);</span>
<span class="line-added">6789   }</span>
<span class="line-added">6790 </span>
6791   // Free interfaces
6792   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6793                                        _local_interfaces, _transitive_interfaces);
6794 
6795   if (_combined_annotations != NULL) {
6796     // After all annotations arrays have been created, they are installed into the
6797     // Annotations object that will be assigned to the InstanceKlass being created.
6798 
6799     // Deallocate the Annotations object and the installed annotations arrays.
6800     _combined_annotations-&gt;deallocate_contents(_loader_data);
6801 
6802     // If the _combined_annotations pointer is non-NULL,
6803     // then the other annotations fields should have been cleared.
6804     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6805     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6806     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6807     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6808   } else {
6809     // If the annotations arrays were not installed into the Annotations object,
6810     // then they have to be deallocated explicitly.
</pre>
<hr />
<pre>
7181   if (_super_klass != NULL) {
7182     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7183       _has_nonstatic_concrete_methods = true;
7184     }
7185     if (_super_klass-&gt;is_declared_atomic()) {
7186       _is_declared_atomic = true;
7187     }
7188 
7189     if (_super_klass-&gt;is_interface()) {
7190       ResourceMark rm(THREAD);
7191       Exceptions::fthrow(
7192         THREAD_AND_LOCATION,
7193         vmSymbols::java_lang_IncompatibleClassChangeError(),
7194         &quot;class %s has interface %s as super class&quot;,
7195         _class_name-&gt;as_klass_external_name(),
7196         _super_klass-&gt;external_name()
7197       );
7198       return;
7199     }
7200 





7201     // For an inline class, only java/lang/Object or special abstract classes
7202     // are acceptable super classes.
7203     if (is_inline_type()) {
7204       const InstanceKlass* super_ik = _super_klass;
7205       if (super_ik-&gt;invalid_inline_super()) {
7206         ResourceMark rm(THREAD);
7207         Exceptions::fthrow(
7208           THREAD_AND_LOCATION,
7209           vmSymbols::java_lang_IncompatibleClassChangeError(),
7210           &quot;inline class %s has an invalid super class %s&quot;,
7211           _class_name-&gt;as_klass_external_name(),
7212           _super_klass-&gt;external_name());
7213         return;
7214       }
7215     }
7216   }
7217 
7218   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7219     // This is the original source of this condition.
7220     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciInstanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
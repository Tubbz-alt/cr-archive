<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 162     ik-&gt;print_on(&amp;ls);
 163 #endif //PRODUCT
 164     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 165   }
 166   dest_offset = fd.offset();
 167 }
 168 
 169 // Overloading to pass name as a string.
 170 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 171                            const char* name_string, Symbol* signature_symbol,
 172                            bool is_static = false) {
 173   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 174   if (name == NULL) {
 175     ResourceMark rm;
 176     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 177     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 178   }
 179   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 180 }
 181 
<span class="line-removed"> 182 int java_lang_String::value_offset  = 0;</span>
<span class="line-removed"> 183 int java_lang_String::hash_offset   = 0;</span>
<span class="line-removed"> 184 int java_lang_String::hashIsZero_offset = 0;</span>
<span class="line-removed"> 185 int java_lang_String::coder_offset  = 0;</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187 bool java_lang_String::initialized  = false;</span>
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189 bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-removed"> 190   return is_instance_inlined(obj);</span>
<span class="line-removed"> 191 }</span>
 192 
 193 #if INCLUDE_CDS
 194 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 195   f-&gt;do_u4((u4*)&amp;offset)
 196 #endif
 197 
 198 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 199   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 200 














 201 #define STRING_FIELDS_DO(macro) \
<span class="line-modified"> 202   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified"> 203   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified"> 204   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified"> 205   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
 206 
 207 void java_lang_String::compute_offsets() {
<span class="line-modified"> 208   if (initialized) {</span>
 209     return;
 210   }
 211 
 212   InstanceKlass* k = SystemDictionary::String_klass();
 213   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 214 
<span class="line-modified"> 215   initialized = true;</span>
 216 }
 217 
 218 #if INCLUDE_CDS
 219 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 220   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 221   f-&gt;do_bool(&amp;initialized);</span>
 222 }
 223 #endif
 224 
 225 class CompactStringsFixup : public FieldClosure {
 226 private:
 227   bool _value;
 228 
 229 public:
 230   CompactStringsFixup(bool value) : _value(value) {}
 231 
 232   void do_field(fieldDescriptor* fd) {
 233     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 234       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 235       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 236       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 237       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 238     }
 239   }
 240 };
 241 
 242 void java_lang_String::set_compact_strings(bool value) {
 243   CompactStringsFixup fix(value);
 244   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 245 }
 246 
 247 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified"> 248   assert(initialized, &quot;Must be initialized&quot;);</span>
 249   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 250 
 251   // Create the String object first, so there&#39;s a chance that the String
 252   // and the char array it points to end up in the same cache line.
 253   oop obj;
 254   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 255 
 256   // Create the char array.  The String object must be handlized here
 257   // because GC can happen as a result of the allocation attempt.
 258   Handle h_obj(THREAD, obj);
 259   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 260   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 261 
 262   // Point the String at the char array
 263   obj = h_obj();
 264   set_value(obj, buffer);
 265   // No need to zero the offset, allocation zero&#39;ed the entire String object
 266   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 267   return h_obj;
 268 }
</pre>
<hr />
<pre>
 526     } else {
 527       for (int index = 0; index &lt; length; index++) {
 528         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 529       }
 530     }
 531   } else {
 532     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 533   }
 534   return result;
 535 }
 536 
 537 unsigned int java_lang_String::hash_code(oop java_string) {
 538   // The hash and hashIsZero fields are subject to a benign data race,
 539   // making it crucial to ensure that any observable result of the
 540   // calculation in this method stays correct under any possible read of
 541   // these fields. Necessary restrictions to allow this to be correct
 542   // without explicit memory fences or similar concurrency primitives is
 543   // that we can ever only write to one of these two fields for a given
 544   // String instance, and that the computation is idempotent and derived
 545   // from immutable state
<span class="line-modified"> 546   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
 547   if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified"> 548     return java_string-&gt;int_field(hash_offset);</span>
 549   }
 550 
 551   typeArrayOop value = java_lang_String::value(java_string);
 552   int         length = java_lang_String::length(java_string, value);
 553   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 554 
 555   unsigned int hash = 0;
 556   if (length &gt; 0) {
 557     if (is_latin1) {
 558       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 559     } else {
 560       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 561     }
 562   }
 563 
 564   if (hash != 0) {
<span class="line-modified"> 565     java_string-&gt;int_field_put(hash_offset, hash);</span>
 566   } else {
<span class="line-modified"> 567     java_string-&gt;bool_field_put(hashIsZero_offset, true);</span>
 568   }
 569   return hash;
 570 }
 571 
 572 char* java_lang_String::as_quoted_ascii(oop java_string) {
 573   typeArrayOop value  = java_lang_String::value(java_string);
 574   int          length = java_lang_String::length(java_string, value);
 575   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 576 
 577   if (length == 0) return NULL;
 578 
 579   char* result;
 580   int result_length;
 581   if (!is_latin1) {
 582     jchar* base = value-&gt;char_at_addr(0);
 583     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 584     result = NEW_RESOURCE_ARRAY(char, result_length);
 585     UNICODE::as_quoted_ascii(base, length, result, result_length);
 586   } else {
 587     jbyte* base = value-&gt;byte_at_addr(0);
</pre>
<hr />
<pre>
 779   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 780 
 781   if (value == NULL) {
 782     // This can happen if, e.g., printing a String
 783     // object before its initializer has been called
 784     st-&gt;print(&quot;NULL&quot;);
 785     return;
 786   }
 787 
 788   int length = java_lang_String::length(java_string, value);
 789   bool is_latin1 = java_lang_String::is_latin1(java_string);
 790 
 791   st-&gt;print(&quot;\&quot;&quot;);
 792   for (int index = 0; index &lt; length; index++) {
 793     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 794                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 795   }
 796   st-&gt;print(&quot;\&quot;&quot;);
 797 }
 798 






















 799 
 800 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 801   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 802   if (fd-&gt;has_initial_value()) {
 803     BasicType t = fd-&gt;field_type();
 804     switch (t) {
 805       case T_BYTE:
 806         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 807               break;
 808       case T_BOOLEAN:
 809         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 810               break;
 811       case T_CHAR:
 812         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 813               break;
 814       case T_SHORT:
 815         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 816               break;
 817       case T_INT:
 818         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
</pre>
<hr />
<pre>
1659   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1660   if (is_primitive(java_class)) {
1661     if (reference_klass != NULL)
1662       (*reference_klass) = NULL;
1663     return primitive_type(java_class);
1664   } else {
1665     if (reference_klass != NULL)
1666       (*reference_klass) = as_Klass(java_class);
1667     return T_OBJECT;
1668   }
1669 }
1670 
1671 
1672 oop java_lang_Class::primitive_mirror(BasicType t) {
1673   oop mirror = Universe::java_mirror(t);
1674   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1675   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1676   return mirror;
1677 }
1678 
<span class="line-modified">1679 bool java_lang_Class::offsets_computed = false;</span>
<span class="line-modified">1680 int  java_lang_Class::classRedefinedCount_offset = -1;</span>
<span class="line-modified">1681 </span>
<span class="line-modified">1682 #define CLASS_FIELDS_DO(macro) \</span>
<span class="line-modified">1683   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">1684   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">1685   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">1686   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-removed">1687   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-removed">1688   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-removed">1689   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1690   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1691 
1692 void java_lang_Class::compute_offsets() {
<span class="line-modified">1693   if (offsets_computed) {</span>
1694     return;
1695   }
1696 
<span class="line-modified">1697   offsets_computed = true;</span>
1698 
1699   InstanceKlass* k = SystemDictionary::Class_klass();
1700   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1701 
1702   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1703   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1704   // GC treats them the same.
1705   _init_lock_offset = _component_mirror_offset;
1706 
1707   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1708 }
1709 
1710 #if INCLUDE_CDS
1711 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1712   f-&gt;do_bool(&amp;offsets_computed);</span>
1713   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1714 
1715   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1716 
1717   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1718 }
1719 #endif
1720 
1721 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1722   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1723   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);</span>
1724 }
1725 
1726 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1727   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1728   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);</span>
1729 }
1730 
1731 
1732 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1733 //       platform thread structure, and a eetop offset which was used for thread
1734 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1735 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1736 //       instead of the privateInfo_offset.
1737 //
1738 // Note: The stackSize field is only present starting in 1.4.
1739 
<span class="line-modified">1740 int java_lang_Thread::_name_offset = 0;</span>
<span class="line-modified">1741 int java_lang_Thread::_group_offset = 0;</span>
<span class="line-modified">1742 int java_lang_Thread::_contextClassLoader_offset = 0;</span>
<span class="line-modified">1743 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;</span>
<span class="line-modified">1744 int java_lang_Thread::_priority_offset = 0;</span>
<span class="line-modified">1745 int java_lang_Thread::_eetop_offset = 0;</span>
<span class="line-modified">1746 int java_lang_Thread::_interrupted_offset = 0;</span>
<span class="line-modified">1747 int java_lang_Thread::_daemon_offset = 0;</span>
<span class="line-modified">1748 int java_lang_Thread::_stillborn_offset = 0;</span>
<span class="line-modified">1749 int java_lang_Thread::_stackSize_offset = 0;</span>
<span class="line-modified">1750 int java_lang_Thread::_tid_offset = 0;</span>
<span class="line-modified">1751 int java_lang_Thread::_thread_status_offset = 0;</span>
<span class="line-modified">1752 int java_lang_Thread::_park_blocker_offset = 0;</span>
1753 
1754 #define THREAD_FIELDS_DO(macro) \
1755   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1756   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1757   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1758   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1759   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1760   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1761   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1762   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1763   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1764   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1765   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1766   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1767   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1768 
1769 void java_lang_Thread::compute_offsets() {
1770   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1771 
1772   InstanceKlass* k = SystemDictionary::Thread_klass();
</pre>
<hr />
<pre>
1894 
1895 oop java_lang_Thread::park_blocker(oop java_thread) {
1896   return java_thread-&gt;obj_field(_park_blocker_offset);
1897 }
1898 
1899 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1900   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1901   switch (status) {
1902     case NEW                      : return &quot;NEW&quot;;
1903     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1904     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1905     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1906     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1907     case PARKED                   : return &quot;WAITING (parking)&quot;;
1908     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1909     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1910     case TERMINATED               : return &quot;TERMINATED&quot;;
1911     default                       : return &quot;UNKNOWN&quot;;
1912   };
1913 }
<span class="line-modified">1914 int java_lang_ThreadGroup::_parent_offset = 0;</span>
<span class="line-modified">1915 int java_lang_ThreadGroup::_name_offset = 0;</span>
<span class="line-modified">1916 int java_lang_ThreadGroup::_threads_offset = 0;</span>
<span class="line-modified">1917 int java_lang_ThreadGroup::_groups_offset = 0;</span>
<span class="line-modified">1918 int java_lang_ThreadGroup::_maxPriority_offset = 0;</span>
<span class="line-modified">1919 int java_lang_ThreadGroup::_destroyed_offset = 0;</span>
<span class="line-modified">1920 int java_lang_ThreadGroup::_daemon_offset = 0;</span>
<span class="line-modified">1921 int java_lang_ThreadGroup::_nthreads_offset = 0;</span>
<span class="line-modified">1922 int java_lang_ThreadGroup::_ngroups_offset = 0;</span>
1923 
1924 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1925   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1926   return java_thread_group-&gt;obj_field(_parent_offset);
1927 }
1928 
1929 // (&quot;name as oop&quot; accessor is not necessary)
1930 
1931 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1932   oop name = java_thread_group-&gt;obj_field(_name_offset);
1933   // ThreadGroup.name can be null
1934   if (name != NULL) {
1935     return java_lang_String::as_utf8_string(name);
1936   }
1937   return NULL;
1938 }
1939 
1940 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1941   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1942   return java_thread_group-&gt;int_field(_nthreads_offset);
</pre>
<hr />
<pre>
1982   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1983   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1984   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1985   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1986   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1987   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1988 
1989 void java_lang_ThreadGroup::compute_offsets() {
1990   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1991 
1992   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1993   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1994 }
1995 
1996 #if INCLUDE_CDS
1997 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1998   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1999 }
2000 #endif
2001 








2002 #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">2003   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">2004   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">2005   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">2006   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">2007   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
2008 
2009 void java_lang_Throwable::compute_offsets() {
2010   InstanceKlass* k = SystemDictionary::Throwable_klass();
2011   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2012 }
2013 
2014 #if INCLUDE_CDS
2015 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2016   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2017 }
2018 #endif
2019 
2020 oop java_lang_Throwable::unassigned_stacktrace() {
2021   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2022   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">2023   return base-&gt;obj_field(static_unassigned_stacktrace_offset);</span>
2024 }
2025 
2026 oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">2027   return throwable-&gt;obj_field_acquire(backtrace_offset);</span>
2028 }
2029 
2030 
2031 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">2032   throwable-&gt;release_obj_field_put(backtrace_offset, value);</span>
2033 }
2034 
2035 int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">2036   return throwable-&gt;int_field(depth_offset);</span>
2037 }
2038 
2039 void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">2040   throwable-&gt;int_field_put(depth_offset, value);</span>
2041 }
2042 
2043 oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">2044   return throwable-&gt;obj_field(detailMessage_offset);</span>
2045 }
2046 
2047 
2048 // Return Symbol for detailed_message or NULL
2049 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2050   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2051   oop detailed_message = java_lang_Throwable::message(throwable);
2052   if (detailed_message != NULL) {
2053     return java_lang_String::as_symbol(detailed_message);
2054   }
2055   return NULL;
2056 }
2057 
2058 void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">2059   throwable-&gt;obj_field_put(detailMessage_offset, value);</span>
2060 }
2061 
2062 
2063 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">2064   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);</span>
2065 }
2066 
2067 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2068   set_stacktrace(throwable, NULL);
2069 }
2070 
2071 
2072 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2073   ResourceMark rm;
2074   Klass* k = throwable-&gt;klass();
2075   assert(k != NULL, &quot;just checking&quot;);
2076   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2077   oop msg = message(throwable);
2078   if (msg != NULL) {
2079     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2080   }
2081 }
2082 
2083 // After this many redefines, the stack trace is unreliable.
2084 const int MAX_VERSION = USHRT_MAX;
</pre>
<hr />
<pre>
2823   line_number = Backtrace::get_line_number(method(), bci);
2824 }
2825 
2826 #if INCLUDE_JVMCI
2827 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2828                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2829   ResourceMark rm(THREAD);
2830   HandleMark hm(THREAD);
2831 
2832   filename = NULL;
2833   line_number = -1;
2834 
2835   oop source_file;
2836   int version = method-&gt;constants()-&gt;version();
2837   InstanceKlass* holder = method-&gt;method_holder();
2838   Handle java_class(THREAD, holder-&gt;java_mirror());
2839   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2840 }
2841 #endif // INCLUDE_JVMCI
2842 























2843 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2844   HandleMark hm(THREAD);
2845   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2846   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2847   // we should expand MemberName::name when Throwable uses StackTrace
2848   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2849   return method;
2850 }
2851 
2852 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2853   // set Method* or mid/cpref
2854   HandleMark hm(THREAD);
2855   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2856   InstanceKlass* ik = method-&gt;method_holder();
2857   CallInfo info(method(), ik, CHECK);
2858   MethodHandles::init_method_MemberName(mname, info);
2859   // set bci
2860   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2861   // method may be redefined; store the version
2862   int version = method-&gt;constants()-&gt;version();
2863   assert((jushort)version == version, &quot;version should be short&quot;);
2864   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2865 }
2866 
2867 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2868   ResourceMark rm(THREAD);
2869   HandleMark hm(THREAD);
2870   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2871   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2872   InstanceKlass* holder = InstanceKlass::cast(clazz);
2873   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2874 
2875   short version = stackFrame-&gt;short_field(_version_offset);
2876   int bci = stackFrame-&gt;int_field(_bci_offset);
2877   Symbol* name = method-&gt;name();
2878   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2879                                        version, bci, name, CHECK);
2880 }
2881 
<span class="line-modified">2882 #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-modified">2883   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-removed">2884   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-removed">2885 </span>
<span class="line-removed">2886 void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-removed">2887   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-removed">2888   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">2889   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
2890 }
2891 
<span class="line-modified">2892 #if INCLUDE_CDS</span>
<span class="line-modified">2893 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-modified">2894   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">2895   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
2896 }
<span class="line-modified">2897 #endif</span>




2898 
2899 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2900   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2901   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2902   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2903   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2904 
2905 void java_lang_LiveStackFrameInfo::compute_offsets() {
2906   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2907   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2908 }
2909 
2910 #if INCLUDE_CDS
2911 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2912   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2913 }
2914 #endif
2915 





















2916 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">2917   macro(override_offset, k, &quot;override&quot;, bool_signature, false)</span>
2918 
2919 void java_lang_reflect_AccessibleObject::compute_offsets() {
2920   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2921   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2922 }
2923 
2924 #if INCLUDE_CDS
2925 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2926   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2927 }
2928 #endif
2929 
2930 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">2931   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2932   return (jboolean) reflect-&gt;bool_field(override_offset);</span>
2933 }
2934 
2935 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">2936   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2937   reflect-&gt;bool_field_put(override_offset, (int) value);</span>
2938 }
2939 














2940 #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">2941   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">2942   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">2943   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">2944   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2945   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">2946   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">2947   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">2948   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">2949   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">2950   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">2951   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
2952 
2953 void java_lang_reflect_Method::compute_offsets() {
2954   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2955   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2956 }
2957 
2958 #if INCLUDE_CDS
2959 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2960   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2961 }
2962 #endif
2963 
2964 Handle java_lang_reflect_Method::create(TRAPS) {
2965   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2966   Klass* klass = SystemDictionary::reflect_Method_klass();
2967   // This class is eagerly initialized during VM initialization, since we keep a refence
2968   // to one of the methods
2969   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2970   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2971 }
2972 
2973 oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">2974   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2975   return reflect-&gt;obj_field(clazz_offset);</span>
2976 }
2977 
2978 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">2979   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2980    reflect-&gt;obj_field_put(clazz_offset, value);</span>
2981 }
2982 
2983 int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">2984   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2985   return reflect-&gt;int_field(slot_offset);</span>
2986 }
2987 
2988 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">2989   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2990   reflect-&gt;int_field_put(slot_offset, value);</span>
2991 }
2992 
2993 void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">2994   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">2995   method-&gt;obj_field_put(name_offset, value);</span>
2996 }
2997 
2998 oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">2999   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3000   return method-&gt;obj_field(returnType_offset);</span>
3001 }
3002 
3003 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">3004   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3005   method-&gt;obj_field_put(returnType_offset, value);</span>
3006 }
3007 
3008 oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">3009   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3010   return method-&gt;obj_field(parameterTypes_offset);</span>
3011 }
3012 
3013 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">3014   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3015   method-&gt;obj_field_put(parameterTypes_offset, value);</span>
3016 }
3017 
3018 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">3019   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3020   method-&gt;obj_field_put(exceptionTypes_offset, value);</span>
3021 }
3022 
3023 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">3024   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3025   method-&gt;int_field_put(modifiers_offset, value);</span>
3026 }
3027 
3028 void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">3029   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3030   method-&gt;obj_field_put(signature_offset, value);</span>
3031 }
3032 
3033 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">3034   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3035   method-&gt;obj_field_put(annotations_offset, value);</span>
3036 }
3037 
3038 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3039   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3040   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
3041 }
3042 
3043 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">3044   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3045   method-&gt;obj_field_put(annotation_default_offset, value);</span>
3046 }
3047 









3048 #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">3049   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">3050   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3051   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3052   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">3053   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">3054   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">3055   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">3056   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
3057 
3058 void java_lang_reflect_Constructor::compute_offsets() {
3059   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3060   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3061 }
3062 
3063 #if INCLUDE_CDS
3064 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3065   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3066 }
3067 #endif
3068 
3069 Handle java_lang_reflect_Constructor::create(TRAPS) {
3070   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3071   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3072   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3073   InstanceKlass* ik = InstanceKlass::cast(k);
3074   // Ensure it is initialized
3075   ik-&gt;initialize(CHECK_NH);
3076   return ik-&gt;allocate_instance_handle(THREAD);
3077 }
3078 
3079 oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">3080   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3081   return reflect-&gt;obj_field(clazz_offset);</span>
3082 }
3083 
3084 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">3085   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3086    reflect-&gt;obj_field_put(clazz_offset, value);</span>
3087 }
3088 
3089 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">3090   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3091   return constructor-&gt;obj_field(parameterTypes_offset);</span>
3092 }
3093 
3094 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">3095   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3096   constructor-&gt;obj_field_put(parameterTypes_offset, value);</span>
3097 }
3098 
3099 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">3100   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3101   constructor-&gt;obj_field_put(exceptionTypes_offset, value);</span>
3102 }
3103 
3104 int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">3105   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3106   return reflect-&gt;int_field(slot_offset);</span>
3107 }
3108 
3109 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">3110   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3111   reflect-&gt;int_field_put(slot_offset, value);</span>
3112 }
3113 
3114 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">3115   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3116   constructor-&gt;int_field_put(modifiers_offset, value);</span>
3117 }
3118 
3119 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">3120   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3121   constructor-&gt;obj_field_put(signature_offset, value);</span>
3122 }
3123 
3124 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">3125   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3126   constructor-&gt;obj_field_put(annotations_offset, value);</span>
3127 }
3128 
3129 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3130   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3131   method-&gt;obj_field_put(parameter_annotations_offset, value);</span>
3132 }
3133 








3134 #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">3135   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">3136   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">3137   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">3138   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">3139   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">3140   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">3141   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
3142 
3143 void java_lang_reflect_Field::compute_offsets() {
3144   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3145   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3146 }
3147 
3148 #if INCLUDE_CDS
3149 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3150   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3151 }
3152 #endif
3153 
3154 Handle java_lang_reflect_Field::create(TRAPS) {
3155   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3156   Symbol* name = vmSymbols::java_lang_reflect_Field();
3157   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3158   InstanceKlass* ik = InstanceKlass::cast(k);
3159   // Ensure it is initialized
3160   ik-&gt;initialize(CHECK_NH);
3161   return ik-&gt;allocate_instance_handle(THREAD);
3162 }
3163 
3164 oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">3165   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3166   return reflect-&gt;obj_field(clazz_offset);</span>
3167 }
3168 
3169 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">3170   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3171    reflect-&gt;obj_field_put(clazz_offset, value);</span>
3172 }
3173 
3174 oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">3175   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3176   return field-&gt;obj_field(name_offset);</span>
3177 }
3178 
3179 void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">3180   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3181   field-&gt;obj_field_put(name_offset, value);</span>
3182 }
3183 
3184 oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">3185   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3186   return field-&gt;obj_field(type_offset);</span>
3187 }
3188 
3189 void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">3190   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3191   field-&gt;obj_field_put(type_offset, value);</span>
3192 }
3193 
3194 int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">3195   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3196   return reflect-&gt;int_field(slot_offset);</span>
3197 }
3198 
3199 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">3200   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3201   reflect-&gt;int_field_put(slot_offset, value);</span>
3202 }
3203 
3204 int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">3205   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3206   return field-&gt;int_field(modifiers_offset);</span>
3207 }
3208 
3209 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">3210   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3211   field-&gt;int_field_put(modifiers_offset, value);</span>
3212 }
3213 
3214 void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">3215   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3216   field-&gt;obj_field_put(signature_offset, value);</span>
3217 }
3218 
3219 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">3220   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3221   field-&gt;obj_field_put(annotations_offset, value);</span>
3222 }
3223 
3224 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3225   // Allocate java.lang.reflect.RecordComponent instance
3226   HandleMark hm(THREAD);
3227   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3228   assert(ik != NULL, &quot;must be loaded&quot;);
3229   ik-&gt;initialize(CHECK_NULL);
3230 
3231   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3232 
3233   Handle decl_class(THREAD, holder-&gt;java_mirror());
3234   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3235 
3236   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3237   oop component_name = StringTable::intern(name, CHECK_NULL);
3238   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3239 
3240   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3241   Handle component_type_h =
</pre>
<hr />
<pre>
3262   }
3263 
3264   int sig_index = component-&gt;generic_signature_index();
3265   if (sig_index &gt; 0) {
3266     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3267     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3268     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3269   } else {
3270     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3271   }
3272 
3273   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3274   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3275 
3276   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3277   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3278 
3279   return element();
3280 }
3281 


3282 #define CONSTANTPOOL_FIELDS_DO(macro) \
3283   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3284 
3285 void reflect_ConstantPool::compute_offsets() {
3286   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3287   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3288   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3289 }
3290 
3291 #if INCLUDE_CDS
3292 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3293   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3294 }
3295 #endif
3296 





3297 #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">3298   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">3299   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">3300   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">3301   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
3302 
3303 void java_lang_reflect_Parameter::compute_offsets() {
3304   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3305   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3306 }
3307 
3308 #if INCLUDE_CDS
3309 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3310   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3311 }
3312 #endif
3313 
3314 Handle java_lang_reflect_Parameter::create(TRAPS) {
3315   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3316   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3317   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3318   InstanceKlass* ik = InstanceKlass::cast(k);
3319   // Ensure it is initialized
3320   ik-&gt;initialize(CHECK_NH);
3321   return ik-&gt;allocate_instance_handle(THREAD);
3322 }
3323 
3324 oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">3325   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3326   return param-&gt;obj_field(name_offset);</span>
3327 }
3328 
3329 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">3330   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3331   param-&gt;obj_field_put(name_offset, value);</span>
3332 }
3333 
3334 int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">3335   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3336   return param-&gt;int_field(modifiers_offset);</span>
3337 }
3338 
3339 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">3340   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3341   param-&gt;int_field_put(modifiers_offset, value);</span>
3342 }
3343 
3344 int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">3345   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3346   return param-&gt;int_field(index_offset);</span>
3347 }
3348 
3349 void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">3350   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3351   param-&gt;int_field_put(index_offset, value);</span>
3352 }
3353 
3354 oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">3355   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3356   return param-&gt;obj_field(executable_offset);</span>
3357 }
3358 
3359 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">3360   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3361   param-&gt;obj_field_put(executable_offset, value);</span>
3362 }
3363 

3364 
<span class="line-modified">3365 int java_lang_Module::loader_offset;</span>
<span class="line-modified">3366 int java_lang_Module::name_offset;</span>
<span class="line-modified">3367 int java_lang_Module::_module_entry_offset = -1;</span>
3368 
3369 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3370   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3371   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3372                           vmSymbols::java_lang_module_init_signature(),
3373                           loader, module_name, CHECK_NH);
3374 }
3375 
3376 #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">3377   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">3378   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
3379 
3380 void java_lang_Module::compute_offsets() {
3381   InstanceKlass* k = SystemDictionary::Module_klass();
3382   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3383   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3384 }
3385 
3386 #if INCLUDE_CDS
3387 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3388   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3389   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3390 }
3391 #endif
3392 
3393 oop java_lang_Module::loader(oop module) {
<span class="line-modified">3394   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3395   return module-&gt;obj_field(loader_offset);</span>
3396 }
3397 
3398 void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">3399   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3400   module-&gt;obj_field_put(loader_offset, value);</span>
3401 }
3402 
3403 oop java_lang_Module::name(oop module) {
<span class="line-modified">3404   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3405   return module-&gt;obj_field(name_offset);</span>
3406 }
3407 
3408 void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">3409   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
<span class="line-removed">3410   module-&gt;obj_field_put(name_offset, value);</span>
3411 }
3412 
3413 ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">3414   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
3415   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3416   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3417 
3418   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3419   if (module_entry == NULL) {
3420     // If the inject field containing the ModuleEntry* is null then return the
3421     // class loader&#39;s unnamed module.
3422     oop loader = java_lang_Module::loader(module);
3423     Handle h_loader = Handle(Thread::current(), loader);
3424     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3425     return loader_cld-&gt;unnamed_module();
3426   }
3427   return module_entry;
3428 }
3429 
3430 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">3431   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);</span>
3432   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3433   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3434   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3435 }
3436 
3437 Handle reflect_ConstantPool::create(TRAPS) {
3438   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3439   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3440   // Ensure it is initialized
3441   k-&gt;initialize(CHECK_NH);
3442   return k-&gt;allocate_instance_handle(THREAD);
3443 }
3444 
3445 
3446 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
<span class="line-removed">3447   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
3448   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3449   // Save the mirror to get back the constant pool.
3450   reflect-&gt;obj_field_put(_oop_offset, mirror);
3451 }
3452 
3453 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
<span class="line-removed">3454   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);</span>
3455 
3456   oop mirror = reflect-&gt;obj_field(_oop_offset);
3457   Klass* k = java_lang_Class::as_Klass(mirror);
3458   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3459 
3460   // Get the constant pool back from the klass.  Since class redefinition
3461   // merges the new constant pool into the old, this is essentially the
3462   // same constant pool as the original.  If constant pool merging is
3463   // no longer done in the future, this will have to change to save
3464   // the original.
3465   return InstanceKlass::cast(k)-&gt;constants();
3466 }
3467 


3468 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3469   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3470 
3471 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3472   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3473   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3474 }
3475 
3476 #if INCLUDE_CDS
3477 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3478   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3479 }
3480 #endif
3481 



































































3482 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3483   Klass* k = SystemDictionary::box_klass(type);
3484   if (k == NULL)  return NULL;
3485   InstanceKlass* ik = InstanceKlass::cast(k);
3486   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3487   return ik-&gt;allocate_instance(THREAD);
3488 }
3489 
3490 
3491 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3492   oop box = initialize_and_allocate(type, CHECK_NULL);
3493   if (box == NULL)  return NULL;
3494   switch (type) {
3495     case T_BOOLEAN:
<span class="line-modified">3496       box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
3497       break;
3498     case T_CHAR:
<span class="line-modified">3499       box-&gt;char_field_put(value_offset, value-&gt;c);</span>
3500       break;
3501     case T_FLOAT:
<span class="line-modified">3502       box-&gt;float_field_put(value_offset, value-&gt;f);</span>
3503       break;
3504     case T_DOUBLE:
<span class="line-modified">3505       box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
3506       break;
3507     case T_BYTE:
<span class="line-modified">3508       box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
3509       break;
3510     case T_SHORT:
<span class="line-modified">3511       box-&gt;short_field_put(value_offset, value-&gt;s);</span>
3512       break;
3513     case T_INT:
<span class="line-modified">3514       box-&gt;int_field_put(value_offset, value-&gt;i);</span>
3515       break;
3516     case T_LONG:
<span class="line-modified">3517       box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
3518       break;
3519     default:
3520       return NULL;
3521   }
3522   return box;
3523 }
3524 
3525 
3526 BasicType java_lang_boxing_object::basic_type(oop box) {
3527   if (box == NULL)  return T_ILLEGAL;
3528   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3529   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3530     return T_ILLEGAL;
3531   return type;
3532 }
3533 
3534 
3535 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3536   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3537   switch (type) {
3538   case T_BOOLEAN:
<span class="line-modified">3539     value-&gt;z = box-&gt;bool_field(value_offset);</span>
3540     break;
3541   case T_CHAR:
<span class="line-modified">3542     value-&gt;c = box-&gt;char_field(value_offset);</span>
3543     break;
3544   case T_FLOAT:
<span class="line-modified">3545     value-&gt;f = box-&gt;float_field(value_offset);</span>
3546     break;
3547   case T_DOUBLE:
<span class="line-modified">3548     value-&gt;d = box-&gt;double_field(long_value_offset);</span>
3549     break;
3550   case T_BYTE:
<span class="line-modified">3551     value-&gt;b = box-&gt;byte_field(value_offset);</span>
3552     break;
3553   case T_SHORT:
<span class="line-modified">3554     value-&gt;s = box-&gt;short_field(value_offset);</span>
3555     break;
3556   case T_INT:
<span class="line-modified">3557     value-&gt;i = box-&gt;int_field(value_offset);</span>
3558     break;
3559   case T_LONG:
<span class="line-modified">3560     value-&gt;j = box-&gt;long_field(long_value_offset);</span>
3561     break;
3562   default:
3563     return T_ILLEGAL;
3564   } // end switch
3565   return type;
3566 }
3567 
3568 
3569 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3570   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3571   switch (type) {
3572   case T_BOOLEAN:
<span class="line-modified">3573     box-&gt;bool_field_put(value_offset, value-&gt;z);</span>
3574     break;
3575   case T_CHAR:
<span class="line-modified">3576     box-&gt;char_field_put(value_offset, value-&gt;c);</span>
3577     break;
3578   case T_FLOAT:
<span class="line-modified">3579     box-&gt;float_field_put(value_offset, value-&gt;f);</span>
3580     break;
3581   case T_DOUBLE:
<span class="line-modified">3582     box-&gt;double_field_put(long_value_offset, value-&gt;d);</span>
3583     break;
3584   case T_BYTE:
<span class="line-modified">3585     box-&gt;byte_field_put(value_offset, value-&gt;b);</span>
3586     break;
3587   case T_SHORT:
<span class="line-modified">3588     box-&gt;short_field_put(value_offset, value-&gt;s);</span>
3589     break;
3590   case T_INT:
<span class="line-modified">3591     box-&gt;int_field_put(value_offset, value-&gt;i);</span>
3592     break;
3593   case T_LONG:
<span class="line-modified">3594     box-&gt;long_field_put(long_value_offset, value-&gt;j);</span>
3595     break;
3596   default:
3597     return T_ILLEGAL;
3598   } // end switch
3599   return type;
3600 }
3601 
3602 
3603 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3604   switch (type) {
3605   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3606   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3607   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3608   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3609   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3610   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3611   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3612   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3613   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3614   }
3615 }
3616 
<span class="line-removed">3617 // Support for java_lang_ref_Reference</span>
<span class="line-removed">3618 </span>
<span class="line-removed">3619 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-removed">3620   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">3621   if (offset != java_lang_ref_Reference::referent_offset) {</span>
<span class="line-removed">3622     return false;</span>
<span class="line-removed">3623   }</span>
<span class="line-removed">3624 </span>
<span class="line-removed">3625   Klass* k = obj-&gt;klass();</span>
<span class="line-removed">3626   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-removed">3627     return false;</span>
<span class="line-removed">3628   }</span>
<span class="line-removed">3629 </span>
<span class="line-removed">3630   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-removed">3631   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-removed">3632   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-removed">3633   return is_reference;</span>
<span class="line-removed">3634 }</span>
<span class="line-removed">3635 </span>
<span class="line-removed">3636 #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-removed">3637   macro(referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-removed">3638   macro(queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-removed">3639   macro(next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-removed">3640   macro(discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-removed">3641 </span>
<span class="line-removed">3642 void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-removed">3643   if (_offsets_initialized) {</span>
<span class="line-removed">3644     return;</span>
<span class="line-removed">3645   }</span>
<span class="line-removed">3646   _offsets_initialized = true;</span>
<span class="line-removed">3647   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-removed">3648   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">3649 }</span>
<span class="line-removed">3650 </span>
<span class="line-removed">3651 #if INCLUDE_CDS</span>
<span class="line-removed">3652 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">3653   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-removed">3654   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">3655 }</span>
<span class="line-removed">3656 #endif</span>
<span class="line-removed">3657 </span>
<span class="line-removed">3658 #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-removed">3659   macro(value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-removed">3660   macro(long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-removed">3661 </span>
<span class="line-removed">3662 void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-removed">3663   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-removed">3664   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-removed">3665   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-removed">3666 }</span>
<span class="line-removed">3667 </span>
<span class="line-removed">3668 #if INCLUDE_CDS</span>
<span class="line-removed">3669 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-removed">3670   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-removed">3671 }</span>
<span class="line-removed">3672 #endif</span>
3673 
3674 // Support for java_lang_ref_SoftReference
3675 //
3676 



3677 #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">3678   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">3679   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
3680 
3681 void java_lang_ref_SoftReference::compute_offsets() {
3682   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3683   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3684 }
3685 
3686 #if INCLUDE_CDS
3687 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3688   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3689 }
3690 #endif
3691 
3692 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">3693   return ref-&gt;long_field(timestamp_offset);</span>
3694 }
3695 
3696 jlong java_lang_ref_SoftReference::clock() {
3697   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3698   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3699   return base-&gt;long_field(static_clock_offset);</span>
3700 }
3701 
3702 void java_lang_ref_SoftReference::set_clock(jlong value) {
3703   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3704   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3705   base-&gt;long_field_put(static_clock_offset, value);</span>
3706 }
3707 
3708 // Support for java_lang_invoke_DirectMethodHandle
3709 
3710 int java_lang_invoke_DirectMethodHandle::_member_offset;
3711 
3712 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3713   oop member_name = NULL;
3714   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3715          &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">3716   return dmh-&gt;obj_field(member_offset_in_bytes());</span>
3717 }
3718 
3719 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3720   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3721 
3722 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3723   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3724   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3725 }
3726 
3727 #if INCLUDE_CDS
3728 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3729   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3730 }
3731 #endif
3732 
3733 // Support for java_lang_invoke_MethodHandle
3734 
3735 int java_lang_invoke_MethodHandle::_type_offset;
3736 int java_lang_invoke_MethodHandle::_form_offset;
</pre>
<hr />
<pre>
4114   InstanceKlass* k = SystemDictionary::Context_klass();
4115   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4116 }
4117 
4118 #if INCLUDE_CDS
4119 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4120   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4121 }
4122 #endif
4123 
4124 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4125   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4126   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4127   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4128   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4129   return dep_ctx;
4130 }
4131 
4132 // Support for java_security_AccessControlContext
4133 
<span class="line-modified">4134 int java_security_AccessControlContext::_context_offset = 0;</span>
<span class="line-modified">4135 int java_security_AccessControlContext::_privilegedContext_offset = 0;</span>
<span class="line-modified">4136 int java_security_AccessControlContext::_isPrivileged_offset = 0;</span>
<span class="line-modified">4137 int java_security_AccessControlContext::_isAuthorized_offset = -1;</span>
4138 
4139 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4140   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4141   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4142   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4143   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4144 
4145 void java_security_AccessControlContext::compute_offsets() {
4146   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4147   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4148   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4149 }
4150 
4151 #if INCLUDE_CDS
4152 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4153   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4154 }
4155 #endif
4156 
4157 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4158   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">4159   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);</span>
4160   // Ensure klass is initialized
4161   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4162   // Allocate result
4163   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4164   // Fill in values
4165   result-&gt;obj_field_put(_context_offset, context());
4166   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4167   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4168   // whitelist AccessControlContexts created by the JVM
4169   result-&gt;bool_field_put(_isAuthorized_offset, true);
4170   return result;
4171 }
4172 
4173 
4174 // Support for java_lang_ClassLoader
4175 
<span class="line-modified">4176 bool java_lang_ClassLoader::offsets_computed = false;</span>
<span class="line-modified">4177 int  java_lang_ClassLoader::_loader_data_offset = -1;</span>
<span class="line-modified">4178 int  java_lang_ClassLoader::parallelCapable_offset = -1;</span>
<span class="line-modified">4179 int  java_lang_ClassLoader::name_offset = -1;</span>
<span class="line-modified">4180 int  java_lang_ClassLoader::nameAndId_offset = -1;</span>
<span class="line-modified">4181 int  java_lang_ClassLoader::unnamedModule_offset = -1;</span>
4182 
4183 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4184   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4185   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4186   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4187 }
4188 
4189 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4190   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4191   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4192   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4193 }
4194 
4195 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4196   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4197   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4198   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4199 }
4200 
4201 #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">4202   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">4203   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">4204   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">4205   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">4206   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
4207 
4208 void java_lang_ClassLoader::compute_offsets() {
<span class="line-removed">4209   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);</span>
<span class="line-removed">4210   offsets_computed = true;</span>
<span class="line-removed">4211 </span>
4212   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4213   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4214 
4215   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4216 }
4217 
4218 #if INCLUDE_CDS
4219 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4220   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4221   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4222 }
4223 #endif
4224 
4225 oop java_lang_ClassLoader::parent(oop loader) {
4226   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4227   return loader-&gt;obj_field(parent_offset);</span>
4228 }
4229 
4230 // Returns the name field of this class loader.  If the name field has not
4231 // been set, null will be returned.
4232 oop java_lang_ClassLoader::name(oop loader) {
4233   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4234   return loader-&gt;obj_field(name_offset);</span>
4235 }
4236 
4237 // Returns the nameAndId field of this class loader. The format is
4238 // as follows:
4239 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4240 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4241 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4242 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4243 oop java_lang_ClassLoader::nameAndId(oop loader) {
4244   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4245   return loader-&gt;obj_field(nameAndId_offset);</span>
4246 }
4247 
4248 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4249   assert(is_instance(loader), &quot;loader must be oop&quot;);
4250   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4251   oop acl = loader;
4252   debug_only(jint loop_count = 0);
4253   // This loop taken verbatim from ClassLoader.java:
4254   do {
4255     acl = parent(acl);
4256     if (cl == acl) {
4257       return true;
4258     }
4259     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4260   } while (acl != NULL);
4261   return false;
4262 }
4263 
4264 bool java_lang_ClassLoader::is_instance(oop obj) {
4265   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4266 }
4267 
4268 
4269 // For class loader classes, parallelCapable defined
4270 // based on non-null field
4271 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4272 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">4273   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">4274   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);</span>
4275 }
4276 
4277 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4278   // Fix for 4474172; see evaluation for more details
4279   loader = non_reflection_class_loader(loader);
4280 
4281   oop cl = SystemDictionary::java_system_loader();
4282   while(cl != NULL) {
4283     if (cl == loader) return true;
4284     cl = parent(cl);
4285   }
4286   return false;
4287 }
4288 
4289 // Return true if this is one of the class loaders associated with
4290 // the generated bytecodes for reflection.
4291 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4292   if (loader != NULL) {
4293     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4294     // This might be null in non-1.4 JDKs
4295     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4296   }
4297   return false;
4298 }
4299 
4300 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4301   // See whether this is one of the class loaders associated with
4302   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4303   // delegate to its parent to prevent class loading from occurring
4304   // in places where applications using reflection didn&#39;t expect it.
4305   if (is_reflection_class_loader(loader)) {
4306     return parent(loader);
4307   }
4308   return loader;
4309 }
4310 
4311 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4312   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4313   return loader-&gt;obj_field(unnamedModule_offset);</span>
4314 }
4315 
4316 // Support for java_lang_System
4317 //






4318 #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">4319   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">4320   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4321   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4322   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
4323 
4324 void java_lang_System::compute_offsets() {
4325   InstanceKlass* k = SystemDictionary::System_klass();
4326   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4327 }
4328 
4329 #if INCLUDE_CDS
4330 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4331    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4332 }
4333 #endif
4334 
<span class="line-removed">4335 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }</span>
<span class="line-removed">4336 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }</span>
<span class="line-removed">4337 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }</span>
<span class="line-removed">4338 </span>
4339 // Support for jdk_internal_misc_UnsafeConstants
4340 //
4341 class UnsafeConstantsFixup : public FieldClosure {
4342 private:
4343   int _address_size;
4344   int _page_size;
4345   bool _big_endian;
4346   bool _use_unaligned_access;
4347   int _data_cache_line_flush_size;
4348 public:
4349   UnsafeConstantsFixup() {
4350     // round up values for all static final fields
4351     _address_size = sizeof(void*);
4352     _page_size = os::vm_page_size();
4353     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4354     _use_unaligned_access = UseUnalignedAccesses;
4355     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4356   }
4357 
4358   void do_field(fieldDescriptor* fd) {
</pre>
<hr />
<pre>
4365       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4366     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4367       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4368     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4369       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4370     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4371       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4372     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4373       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4374     } else {
4375       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4376     }
4377   }
4378 };
4379 
4380 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4381   UnsafeConstantsFixup fixup;
4382   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4383 }
4384 
<span class="line-modified">4385 int java_lang_Class::_klass_offset;</span>
<span class="line-removed">4386 int java_lang_Class::_array_klass_offset;</span>
<span class="line-removed">4387 int java_lang_Class::_oop_size_offset;</span>
<span class="line-removed">4388 int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-removed">4389 int java_lang_Class::_class_loader_offset;</span>
<span class="line-removed">4390 int java_lang_Class::_module_offset;</span>
<span class="line-removed">4391 int java_lang_Class::_protection_domain_offset;</span>
<span class="line-removed">4392 int java_lang_Class::_component_mirror_offset;</span>
<span class="line-removed">4393 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-removed">4394 int java_lang_Class::_ref_type_mirror_offset;</span>
<span class="line-removed">4395 int java_lang_Class::_init_lock_offset;</span>
<span class="line-removed">4396 int java_lang_Class::_signers_offset;</span>
<span class="line-removed">4397 int java_lang_Class::_name_offset;</span>
<span class="line-removed">4398 int java_lang_Class::_source_file_offset;</span>
<span class="line-removed">4399 int java_lang_Class::_classData_offset;</span>
<span class="line-removed">4400 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-removed">4401 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
<span class="line-removed">4402 int java_lang_Throwable::backtrace_offset;</span>
<span class="line-removed">4403 int java_lang_Throwable::detailMessage_offset;</span>
<span class="line-removed">4404 int java_lang_Throwable::stackTrace_offset;</span>
<span class="line-removed">4405 int java_lang_Throwable::depth_offset;</span>
<span class="line-removed">4406 int java_lang_Throwable::static_unassigned_stacktrace_offset;</span>
<span class="line-removed">4407 int java_lang_reflect_AccessibleObject::override_offset;</span>
<span class="line-removed">4408 int java_lang_reflect_Method::clazz_offset;</span>
<span class="line-removed">4409 int java_lang_reflect_Method::name_offset;</span>
<span class="line-removed">4410 int java_lang_reflect_Method::returnType_offset;</span>
<span class="line-removed">4411 int java_lang_reflect_Method::parameterTypes_offset;</span>
<span class="line-removed">4412 int java_lang_reflect_Method::exceptionTypes_offset;</span>
<span class="line-removed">4413 int java_lang_reflect_Method::slot_offset;</span>
<span class="line-removed">4414 int java_lang_reflect_Method::modifiers_offset;</span>
<span class="line-removed">4415 int java_lang_reflect_Method::signature_offset;</span>
<span class="line-removed">4416 int java_lang_reflect_Method::annotations_offset;</span>
<span class="line-removed">4417 int java_lang_reflect_Method::parameter_annotations_offset;</span>
<span class="line-removed">4418 int java_lang_reflect_Method::annotation_default_offset;</span>
<span class="line-removed">4419 int java_lang_reflect_Constructor::clazz_offset;</span>
<span class="line-removed">4420 int java_lang_reflect_Constructor::parameterTypes_offset;</span>
<span class="line-removed">4421 int java_lang_reflect_Constructor::exceptionTypes_offset;</span>
<span class="line-removed">4422 int java_lang_reflect_Constructor::slot_offset;</span>
<span class="line-removed">4423 int java_lang_reflect_Constructor::modifiers_offset;</span>
<span class="line-removed">4424 int java_lang_reflect_Constructor::signature_offset;</span>
<span class="line-removed">4425 int java_lang_reflect_Constructor::annotations_offset;</span>
<span class="line-removed">4426 int java_lang_reflect_Constructor::parameter_annotations_offset;</span>
<span class="line-removed">4427 int java_lang_reflect_Field::clazz_offset;</span>
<span class="line-removed">4428 int java_lang_reflect_Field::name_offset;</span>
<span class="line-removed">4429 int java_lang_reflect_Field::type_offset;</span>
<span class="line-removed">4430 int java_lang_reflect_Field::slot_offset;</span>
<span class="line-removed">4431 int java_lang_reflect_Field::modifiers_offset;</span>
<span class="line-removed">4432 int java_lang_reflect_Field::signature_offset;</span>
<span class="line-removed">4433 int java_lang_reflect_Field::annotations_offset;</span>
<span class="line-removed">4434 int java_lang_reflect_Parameter::name_offset;</span>
<span class="line-removed">4435 int java_lang_reflect_Parameter::modifiers_offset;</span>
<span class="line-removed">4436 int java_lang_reflect_Parameter::index_offset;</span>
<span class="line-removed">4437 int java_lang_reflect_Parameter::executable_offset;</span>
<span class="line-removed">4438 int java_lang_boxing_object::value_offset;</span>
<span class="line-removed">4439 int java_lang_boxing_object::long_value_offset;</span>
<span class="line-removed">4440 bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-removed">4441 int java_lang_ref_Reference::referent_offset;</span>
<span class="line-removed">4442 int java_lang_ref_Reference::queue_offset;</span>
<span class="line-removed">4443 int java_lang_ref_Reference::next_offset;</span>
<span class="line-removed">4444 int java_lang_ref_Reference::discovered_offset;</span>
<span class="line-removed">4445 int java_lang_ref_SoftReference::timestamp_offset;</span>
<span class="line-removed">4446 int java_lang_ref_SoftReference::static_clock_offset;</span>
<span class="line-removed">4447 int java_lang_ClassLoader::parent_offset;</span>
<span class="line-removed">4448 int java_lang_System::static_in_offset;</span>
<span class="line-removed">4449 int java_lang_System::static_out_offset;</span>
<span class="line-removed">4450 int java_lang_System::static_err_offset;</span>
<span class="line-removed">4451 int java_lang_System::static_security_offset;</span>
<span class="line-removed">4452 int java_lang_StackTraceElement::methodName_offset;</span>
<span class="line-removed">4453 int java_lang_StackTraceElement::fileName_offset;</span>
<span class="line-removed">4454 int java_lang_StackTraceElement::lineNumber_offset;</span>
<span class="line-removed">4455 int java_lang_StackTraceElement::moduleName_offset;</span>
<span class="line-removed">4456 int java_lang_StackTraceElement::moduleVersion_offset;</span>
<span class="line-removed">4457 int java_lang_StackTraceElement::classLoaderName_offset;</span>
<span class="line-removed">4458 int java_lang_StackTraceElement::declaringClass_offset;</span>
<span class="line-removed">4459 int java_lang_StackTraceElement::declaringClassObject_offset;</span>
<span class="line-removed">4460 int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-removed">4461 int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-removed">4462 int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-removed">4463 int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-removed">4464 int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-removed">4465 int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-removed">4466 int java_lang_LiveStackFrameInfo::_mode_offset;</span>
<span class="line-removed">4467 int java_lang_AssertionStatusDirectives::classes_offset;</span>
<span class="line-removed">4468 int java_lang_AssertionStatusDirectives::classEnabled_offset;</span>
<span class="line-removed">4469 int java_lang_AssertionStatusDirectives::packages_offset;</span>
<span class="line-removed">4470 int java_lang_AssertionStatusDirectives::packageEnabled_offset;</span>
<span class="line-removed">4471 int java_lang_AssertionStatusDirectives::deflt_offset;</span>
<span class="line-removed">4472 int java_nio_Buffer::_limit_offset;</span>
<span class="line-removed">4473 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-removed">4474 int reflect_ConstantPool::_oop_offset;</span>
<span class="line-removed">4475 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-removed">4476 int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-removed">4477 int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-removed">4478 int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-removed">4479 int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-removed">4480 int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-removed">4481 int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-removed">4482 int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-removed">4483 int java_lang_reflect_RecordComponent::clazz_offset;</span>
<span class="line-removed">4484 int java_lang_reflect_RecordComponent::name_offset;</span>
<span class="line-removed">4485 int java_lang_reflect_RecordComponent::type_offset;</span>
<span class="line-removed">4486 int java_lang_reflect_RecordComponent::accessor_offset;</span>
<span class="line-removed">4487 int java_lang_reflect_RecordComponent::signature_offset;</span>
<span class="line-removed">4488 int java_lang_reflect_RecordComponent::annotations_offset;</span>
<span class="line-removed">4489 int java_lang_reflect_RecordComponent::typeAnnotations_offset;</span>
<span class="line-removed">4490 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-removed">4491 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-removed">4492 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-removed">4493 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-removed">4494 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4495 
4496 








4497 
4498 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">4499   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">4500   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">4501   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">4502   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">4503   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">4504   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">4505   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">4506   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
4507 
4508 // Support for java_lang_StackTraceElement
4509 void java_lang_StackTraceElement::compute_offsets() {
4510   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4511   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4512 }
4513 
4514 #if INCLUDE_CDS
4515 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4516   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4517 }
4518 #endif
4519 
4520 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">4521   element-&gt;obj_field_put(fileName_offset, value);</span>
4522 }
4523 
4524 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">4525   element-&gt;obj_field_put(declaringClass_offset, value);</span>
4526 }
4527 
4528 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">4529   element-&gt;obj_field_put(methodName_offset, value);</span>
4530 }
4531 
4532 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">4533   element-&gt;int_field_put(lineNumber_offset, value);</span>
4534 }
4535 
4536 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">4537   element-&gt;obj_field_put(moduleName_offset, value);</span>
4538 }
4539 
4540 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">4541   element-&gt;obj_field_put(moduleVersion_offset, value);</span>
4542 }
4543 
4544 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">4545   element-&gt;obj_field_put(classLoaderName_offset, value);</span>
4546 }
4547 
4548 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">4549   element-&gt;obj_field_put(declaringClassObject_offset, value);</span>
4550 }
4551 
<span class="line-modified">4552 void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-removed">4553   element-&gt;short_field_put(_version_offset, value);</span>
<span class="line-removed">4554 }</span>
<span class="line-removed">4555 </span>
<span class="line-removed">4556 void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-removed">4557   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-removed">4558   element-&gt;int_field_put(_bci_offset, value);</span>
<span class="line-removed">4559 }</span>
<span class="line-removed">4560 </span>
<span class="line-removed">4561 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-removed">4562   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-removed">4563 }</span>
<span class="line-removed">4564 </span>
<span class="line-removed">4565 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-removed">4566   element-&gt;obj_field_put(_locals_offset, value);</span>
4567 }
4568 
<span class="line-modified">4569 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-modified">4570   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-modified">4571 }</span>
<span class="line-modified">4572 </span>
<span class="line-modified">4573 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-removed">4574   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-removed">4575 }</span>
4576 
4577 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4578 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">4579   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">4580   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">4581   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">4582   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">4583   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
4584 
4585 void java_lang_AssertionStatusDirectives::compute_offsets() {
4586   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4587   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4588 }
4589 
4590 #if INCLUDE_CDS
4591 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4592   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4593 }
4594 #endif
4595 
4596 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">4597   o-&gt;obj_field_put(classes_offset, val);</span>
4598 }
4599 
4600 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">4601   o-&gt;obj_field_put(classEnabled_offset, val);</span>
4602 }
4603 
4604 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">4605   o-&gt;obj_field_put(packages_offset, val);</span>
4606 }
4607 
4608 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">4609   o-&gt;obj_field_put(packageEnabled_offset, val);</span>
4610 }
4611 
4612 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">4613   o-&gt;bool_field_put(deflt_offset, val);</span>
4614 }
4615 
4616 
4617 // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">4618 int java_nio_Buffer::limit_offset() {</span>
<span class="line-modified">4619   return _limit_offset;</span>
<span class="line-removed">4620 }</span>
4621 
4622 #define BUFFER_FIELDS_DO(macro) \
4623   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4624 
4625 void java_nio_Buffer::compute_offsets() {
4626   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4627   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4628   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4629 }
4630 
4631 #if INCLUDE_CDS
4632 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4633   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4634 }
4635 #endif
4636 


4637 #define AOS_FIELDS_DO(macro) \
4638   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4639 
4640 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4641   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4642   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4643 }
4644 
4645 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4646   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4647   return obj-&gt;obj_field(_owner_offset);
4648 }
4649 
4650 #if INCLUDE_CDS
4651 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4652   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4653 }
4654 #endif
4655 






4656 #define INTEGER_CACHE_FIELDS_DO(macro) \
4657   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4658 
4659 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4660   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4661   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4662 }
4663 
4664 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4665   oop base = ik-&gt;static_field_base_raw();
4666   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4667 }
4668 
4669 Symbol* java_lang_Integer_IntegerCache::symbol() {
4670   return vmSymbols::java_lang_Integer_IntegerCache();
4671 }
4672 
4673 #if INCLUDE_CDS
4674 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4675   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4780   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4781   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4782 }
4783 
4784 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4785   oop base = ik-&gt;static_field_base_raw();
4786   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4787 }
4788 
4789 Symbol* java_lang_Byte_ByteCache::symbol() {
4790   return vmSymbols::java_lang_Byte_ByteCache();
4791 }
4792 
4793 #if INCLUDE_CDS
4794 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4795   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4796 }
4797 #endif
4798 #undef BYTE_CACHE_FIELDS_DO
4799 








4800 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \
4801   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \
4802   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \
4803   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \
4804   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \
4805   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);
4806 
4807 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {
4808   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();
4809   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4810 }
4811 
4812 #if INCLUDE_CDS
4813 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {
4814   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4815 }
4816 #endif
4817 #undef SUBELEMENT_SELECTOR_FIELDS_DO
4818 
4819 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {
</pre>
<hr />
<pre>
4848   return obj-&gt;bool_field(_isFlattened_offset);
4849 }
4850 
4851 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {
4852   obj-&gt;bool_field_put(_isFlattened_offset, b);
4853 }
4854 
4855 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {
4856   return obj-&gt;bool_field(_isFlattenable_offset);
4857 }
4858 
4859 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {
4860   obj-&gt;bool_field_put(_isFlattenable_offset, b);
4861 }
4862 
4863 jbyte java_lang_Byte::value(oop obj) {
4864    jvalue v;
4865    java_lang_boxing_object::get_value(obj, &amp;v);
4866    return v.b;
4867 }




4868 #define BOOLEAN_FIELDS_DO(macro) \
4869   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4870   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4871 
4872 
4873 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4874   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4875   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4876 }
4877 
4878 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4879   oop base = ik-&gt;static_field_base_raw();
4880   return base-&gt;obj_field(_static_TRUE_offset);
4881 }
4882 
4883 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4884   oop base = ik-&gt;static_field_base_raw();
4885   return base-&gt;obj_field(_static_FALSE_offset);
4886 }
4887 
4888 Symbol* java_lang_Boolean::symbol() {
4889   return vmSymbols::java_lang_Boolean();
4890 }
4891 
4892 #if INCLUDE_CDS
4893 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4894   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4895 }
4896 #endif
4897 #undef BOOLEAN_CACHE_FIELDS_DO
4898 
4899 jboolean java_lang_Boolean::value(oop obj) {
4900    jvalue v;
4901    java_lang_boxing_object::get_value(obj, &amp;v);
4902    return v.z;
4903 }
4904 










4905 #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">4906   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">4907   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">4908   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">4909   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">4910   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">4911   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">4912   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
4913 
4914 // Support for java_lang_reflect_RecordComponent
4915 void java_lang_reflect_RecordComponent::compute_offsets() {
4916   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4917   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4918 }
4919 
4920 #if INCLUDE_CDS
4921 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4922   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4923 }
4924 #endif
4925 
4926 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">4927   element-&gt;obj_field_put(clazz_offset, value);</span>
4928 }
4929 
4930 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">4931   element-&gt;obj_field_put(name_offset, value);</span>
4932 }
4933 
4934 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">4935   element-&gt;obj_field_put(type_offset, value);</span>
4936 }
4937 
4938 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">4939   element-&gt;obj_field_put(accessor_offset, value);</span>
4940 }
4941 
4942 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">4943   element-&gt;obj_field_put(signature_offset, value);</span>
4944 }
4945 
4946 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">4947   element-&gt;obj_field_put(annotations_offset, value);</span>
4948 }
4949 
4950 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">4951   element-&gt;obj_field_put(typeAnnotations_offset, value);</span>
4952 }
4953 
4954 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4955 
<span class="line-modified">4956 // Compute non-hard-coded field offsets of all the classes in this file</span>
4957 void JavaClasses::compute_offsets() {
4958   if (UseSharedSpaces) {
4959     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4960                                                          JvmtiExport::has_early_class_hook_env()),
4961                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4962     // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">4963     // JMVTI ClassFileLoadHook.</span>
4964     // We are safe to use the archived offsets, which have already been restored
4965     // by JavaClasses::serialize_offsets, without computing the offsets again.
4966     return;
4967   }
4968 
4969   // We have already called the compute_offsets() of the
4970   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4971   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4972   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4973 }
4974 
4975 #if INCLUDE_CDS
4976 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4977 
4978 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4979   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4980 }
4981 #endif
4982 
4983 #if INCLUDE_CDS_JAVA_HEAP
</pre>
<hr />
<pre>
4988       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4989       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4990       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4991       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4992       // So for now we cannot not support these classes for archiving.
4993       //
4994       // These objects typically are not referenced by static fields, but rather by resolved
4995       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4996       klass == SystemDictionary::ResolvedMethodName_klass() ||
4997       klass == SystemDictionary::MemberName_klass() ||
4998       klass == SystemDictionary::Context_klass()) {
4999     return false;
5000   }
5001 
5002   return true;
5003 }
5004 #endif
5005 
5006 #ifndef PRODUCT
5007 
<span class="line-modified">5008 // These functions exist to assert the validity of hard-coded field offsets to guard</span>
<span class="line-removed">5009 // against changes in the class files</span>
5010 
<span class="line-modified">5011 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {</span>

5012   EXCEPTION_MARK;
5013   fieldDescriptor fd;
5014   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
5015   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5016   InstanceKlass* ik = InstanceKlass::cast(k);
5017   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5018   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5019   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5020     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5021     return false;
5022   }
5023   if (fd.is_static()) {
5024     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5025     return false;
5026   }
<span class="line-modified">5027   if (fd.offset() == hardcoded_offset ) {</span>
5028     return true;
5029   } else {
<span class="line-modified">5030     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,</span>
<span class="line-modified">5031                   klass_name, field_name, hardcoded_offset, fd.offset());</span>
5032     return false;
5033   }
5034 }
5035 
<span class="line-removed">5036 // Check the hard-coded field offsets of all the classes in this file</span>
<span class="line-removed">5037 </span>
5038 void JavaClasses::check_offsets() {
5039   bool valid = true;
5040 
5041 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">5042   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)</span>
5043 
5044 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">5045   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)</span>
5046 
5047   // Boxed primitive objects (java_lang_boxing_object)
5048 
5049   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5050   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5051   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5052   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5053   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5054   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5055   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5056   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5057 
<span class="line-modified">5058   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);</span>
5059 }
5060 
5061 #endif // PRODUCT
5062 
5063 int InjectedField::compute_offset() {
5064   InstanceKlass* ik = InstanceKlass::cast(klass());
5065   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5066     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5067       // Only look at injected fields
5068       continue;
5069     }
5070     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5071       return fs.offset();
5072     }
5073   }
5074   ResourceMark rm;
5075   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5076 #ifndef PRODUCT
5077   ik-&gt;print();
5078   tty-&gt;print_cr(&quot;all fields:&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 162     ik-&gt;print_on(&amp;ls);
 163 #endif //PRODUCT
 164     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 165   }
 166   dest_offset = fd.offset();
 167 }
 168 
 169 // Overloading to pass name as a string.
 170 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 171                            const char* name_string, Symbol* signature_symbol,
 172                            bool is_static = false) {
 173   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 174   if (name == NULL) {
 175     ResourceMark rm;
 176     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 177     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 178   }
 179   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 180 }
 181 










 182 
 183 #if INCLUDE_CDS
 184 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 185   f-&gt;do_u4((u4*)&amp;offset)
 186 #endif
 187 
 188 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 189   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 190 
<span class="line-added"> 191 </span>
<span class="line-added"> 192 // java_lang_String</span>
<span class="line-added"> 193 </span>
<span class="line-added"> 194 int java_lang_String::_value_offset;</span>
<span class="line-added"> 195 int java_lang_String::_hash_offset;</span>
<span class="line-added"> 196 int java_lang_String::_hashIsZero_offset;</span>
<span class="line-added"> 197 int java_lang_String::_coder_offset;</span>
<span class="line-added"> 198 </span>
<span class="line-added"> 199 bool java_lang_String::_initialized;</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 bool java_lang_String::is_instance(oop obj) {</span>
<span class="line-added"> 202   return is_instance_inlined(obj);</span>
<span class="line-added"> 203 }</span>
<span class="line-added"> 204 </span>
 205 #define STRING_FIELDS_DO(macro) \
<span class="line-modified"> 206   macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \</span>
<span class="line-modified"> 207   macro(_hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \</span>
<span class="line-modified"> 208   macro(_hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \</span>
<span class="line-modified"> 209   macro(_coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);</span>
 210 
 211 void java_lang_String::compute_offsets() {
<span class="line-modified"> 212   if (_initialized) {</span>
 213     return;
 214   }
 215 
 216   InstanceKlass* k = SystemDictionary::String_klass();
 217   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 218 
<span class="line-modified"> 219   _initialized = true;</span>
 220 }
 221 
 222 #if INCLUDE_CDS
 223 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 224   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
<span class="line-modified"> 225   f-&gt;do_bool(&amp;_initialized);</span>
 226 }
 227 #endif
 228 
 229 class CompactStringsFixup : public FieldClosure {
 230 private:
 231   bool _value;
 232 
 233 public:
 234   CompactStringsFixup(bool value) : _value(value) {}
 235 
 236   void do_field(fieldDescriptor* fd) {
 237     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 238       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 239       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 240       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 241       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 242     }
 243   }
 244 };
 245 
 246 void java_lang_String::set_compact_strings(bool value) {
 247   CompactStringsFixup fix(value);
 248   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 249 }
 250 
 251 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
<span class="line-modified"> 252   assert(_initialized, &quot;Must be initialized&quot;);</span>
 253   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 254 
 255   // Create the String object first, so there&#39;s a chance that the String
 256   // and the char array it points to end up in the same cache line.
 257   oop obj;
 258   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 259 
 260   // Create the char array.  The String object must be handlized here
 261   // because GC can happen as a result of the allocation attempt.
 262   Handle h_obj(THREAD, obj);
 263   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 264   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 265 
 266   // Point the String at the char array
 267   obj = h_obj();
 268   set_value(obj, buffer);
 269   // No need to zero the offset, allocation zero&#39;ed the entire String object
 270   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 271   return h_obj;
 272 }
</pre>
<hr />
<pre>
 530     } else {
 531       for (int index = 0; index &lt; length; index++) {
 532         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 533       }
 534     }
 535   } else {
 536     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 537   }
 538   return result;
 539 }
 540 
 541 unsigned int java_lang_String::hash_code(oop java_string) {
 542   // The hash and hashIsZero fields are subject to a benign data race,
 543   // making it crucial to ensure that any observable result of the
 544   // calculation in this method stays correct under any possible read of
 545   // these fields. Necessary restrictions to allow this to be correct
 546   // without explicit memory fences or similar concurrency primitives is
 547   // that we can ever only write to one of these two fields for a given
 548   // String instance, and that the computation is idempotent and derived
 549   // from immutable state
<span class="line-modified"> 550   assert(_initialized &amp;&amp; (_hash_offset &gt; 0) &amp;&amp; (_hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);</span>
 551   if (java_lang_String::hash_is_set(java_string)) {
<span class="line-modified"> 552     return java_string-&gt;int_field(_hash_offset);</span>
 553   }
 554 
 555   typeArrayOop value = java_lang_String::value(java_string);
 556   int         length = java_lang_String::length(java_string, value);
 557   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 558 
 559   unsigned int hash = 0;
 560   if (length &gt; 0) {
 561     if (is_latin1) {
 562       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 563     } else {
 564       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 565     }
 566   }
 567 
 568   if (hash != 0) {
<span class="line-modified"> 569     java_string-&gt;int_field_put(_hash_offset, hash);</span>
 570   } else {
<span class="line-modified"> 571     java_string-&gt;bool_field_put(_hashIsZero_offset, true);</span>
 572   }
 573   return hash;
 574 }
 575 
 576 char* java_lang_String::as_quoted_ascii(oop java_string) {
 577   typeArrayOop value  = java_lang_String::value(java_string);
 578   int          length = java_lang_String::length(java_string, value);
 579   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 580 
 581   if (length == 0) return NULL;
 582 
 583   char* result;
 584   int result_length;
 585   if (!is_latin1) {
 586     jchar* base = value-&gt;char_at_addr(0);
 587     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 588     result = NEW_RESOURCE_ARRAY(char, result_length);
 589     UNICODE::as_quoted_ascii(base, length, result, result_length);
 590   } else {
 591     jbyte* base = value-&gt;byte_at_addr(0);
</pre>
<hr />
<pre>
 783   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 784 
 785   if (value == NULL) {
 786     // This can happen if, e.g., printing a String
 787     // object before its initializer has been called
 788     st-&gt;print(&quot;NULL&quot;);
 789     return;
 790   }
 791 
 792   int length = java_lang_String::length(java_string, value);
 793   bool is_latin1 = java_lang_String::is_latin1(java_string);
 794 
 795   st-&gt;print(&quot;\&quot;&quot;);
 796   for (int index = 0; index &lt; length; index++) {
 797     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 798                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 799   }
 800   st-&gt;print(&quot;\&quot;&quot;);
 801 }
 802 
<span class="line-added"> 803 // java_lang_Class</span>
<span class="line-added"> 804 </span>
<span class="line-added"> 805 int java_lang_Class::_klass_offset;</span>
<span class="line-added"> 806 int java_lang_Class::_array_klass_offset;</span>
<span class="line-added"> 807 int java_lang_Class::_oop_size_offset;</span>
<span class="line-added"> 808 int java_lang_Class::_static_oop_field_count_offset;</span>
<span class="line-added"> 809 int java_lang_Class::_class_loader_offset;</span>
<span class="line-added"> 810 int java_lang_Class::_module_offset;</span>
<span class="line-added"> 811 int java_lang_Class::_protection_domain_offset;</span>
<span class="line-added"> 812 int java_lang_Class::_component_mirror_offset;</span>
<span class="line-added"> 813 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added"> 814 int java_lang_Class::_ref_type_mirror_offset;</span>
<span class="line-added"> 815 int java_lang_Class::_init_lock_offset;</span>
<span class="line-added"> 816 int java_lang_Class::_signers_offset;</span>
<span class="line-added"> 817 int java_lang_Class::_name_offset;</span>
<span class="line-added"> 818 int java_lang_Class::_source_file_offset;</span>
<span class="line-added"> 819 int java_lang_Class::_classData_offset;</span>
<span class="line-added"> 820 int java_lang_Class::_classRedefinedCount_offset;</span>
<span class="line-added"> 821 </span>
<span class="line-added"> 822 bool java_lang_Class::_offsets_computed = false;</span>
<span class="line-added"> 823 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;</span>
<span class="line-added"> 824 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;</span>
 825 
 826 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 827   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 828   if (fd-&gt;has_initial_value()) {
 829     BasicType t = fd-&gt;field_type();
 830     switch (t) {
 831       case T_BYTE:
 832         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 833               break;
 834       case T_BOOLEAN:
 835         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 836               break;
 837       case T_CHAR:
 838         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 839               break;
 840       case T_SHORT:
 841         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 842               break;
 843       case T_INT:
 844         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
</pre>
<hr />
<pre>
1685   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1686   if (is_primitive(java_class)) {
1687     if (reference_klass != NULL)
1688       (*reference_klass) = NULL;
1689     return primitive_type(java_class);
1690   } else {
1691     if (reference_klass != NULL)
1692       (*reference_klass) = as_Klass(java_class);
1693     return T_OBJECT;
1694   }
1695 }
1696 
1697 
1698 oop java_lang_Class::primitive_mirror(BasicType t) {
1699   oop mirror = Universe::java_mirror(t);
1700   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1701   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1702   return mirror;
1703 }
1704 
<span class="line-modified">1705 #define CLASS_FIELDS_DO(macro) \</span>
<span class="line-modified">1706   macro(_classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \</span>
<span class="line-modified">1707   macro(_class_loader_offset,        k, &quot;classLoader&quot;,         classloader_signature, false); \</span>
<span class="line-modified">1708   macro(_component_mirror_offset,    k, &quot;componentType&quot;,       class_signature,       false); \</span>
<span class="line-modified">1709   macro(_module_offset,              k, &quot;module&quot;,              module_signature,      false); \</span>
<span class="line-modified">1710   macro(_name_offset,                k, &quot;name&quot;,                string_signature,      false); \</span>
<span class="line-modified">1711   macro(_val_type_mirror_offset,     k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-modified">1712   macro(_ref_type_mirror_offset,     k, &quot;refType&quot;,             class_signature,       false); \</span>



1713   macro(_classData_offset,           k, &quot;classData&quot;,           object_signature,      false);
1714 
1715 void java_lang_Class::compute_offsets() {
<span class="line-modified">1716   if (_offsets_computed) {</span>
1717     return;
1718   }
1719 
<span class="line-modified">1720   _offsets_computed = true;</span>
1721 
1722   InstanceKlass* k = SystemDictionary::Class_klass();
1723   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1724 
1725   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1726   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1727   // GC treats them the same.
1728   _init_lock_offset = _component_mirror_offset;
1729 
1730   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1731 }
1732 
1733 #if INCLUDE_CDS
1734 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
<span class="line-modified">1735   f-&gt;do_bool(&amp;_offsets_computed);</span>
1736   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1737 
1738   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1739 
1740   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1741 }
1742 #endif
1743 
1744 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
<span class="line-modified">1745   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1746   return the_class_mirror-&gt;int_field(_classRedefinedCount_offset);</span>
1747 }
1748 
1749 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
<span class="line-modified">1750   assert(_classRedefinedCount_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">1751   the_class_mirror-&gt;int_field_put(_classRedefinedCount_offset, value);</span>
1752 }
1753 
1754 
1755 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1756 //       platform thread structure, and a eetop offset which was used for thread
1757 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1758 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1759 //       instead of the privateInfo_offset.
1760 //
1761 // Note: The stackSize field is only present starting in 1.4.
1762 
<span class="line-modified">1763 int java_lang_Thread::_name_offset;</span>
<span class="line-modified">1764 int java_lang_Thread::_group_offset;</span>
<span class="line-modified">1765 int java_lang_Thread::_contextClassLoader_offset;</span>
<span class="line-modified">1766 int java_lang_Thread::_inheritedAccessControlContext_offset;</span>
<span class="line-modified">1767 int java_lang_Thread::_priority_offset;</span>
<span class="line-modified">1768 int java_lang_Thread::_eetop_offset;</span>
<span class="line-modified">1769 int java_lang_Thread::_interrupted_offset;</span>
<span class="line-modified">1770 int java_lang_Thread::_daemon_offset;</span>
<span class="line-modified">1771 int java_lang_Thread::_stillborn_offset;</span>
<span class="line-modified">1772 int java_lang_Thread::_stackSize_offset;</span>
<span class="line-modified">1773 int java_lang_Thread::_tid_offset;</span>
<span class="line-modified">1774 int java_lang_Thread::_thread_status_offset;</span>
<span class="line-modified">1775 int java_lang_Thread::_park_blocker_offset;</span>
1776 
1777 #define THREAD_FIELDS_DO(macro) \
1778   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1779   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1780   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1781   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1782   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1783   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1784   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1785   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1786   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1787   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1788   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1789   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1790   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1791 
1792 void java_lang_Thread::compute_offsets() {
1793   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1794 
1795   InstanceKlass* k = SystemDictionary::Thread_klass();
</pre>
<hr />
<pre>
1917 
1918 oop java_lang_Thread::park_blocker(oop java_thread) {
1919   return java_thread-&gt;obj_field(_park_blocker_offset);
1920 }
1921 
1922 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1923   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1924   switch (status) {
1925     case NEW                      : return &quot;NEW&quot;;
1926     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1927     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1928     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1929     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1930     case PARKED                   : return &quot;WAITING (parking)&quot;;
1931     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1932     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1933     case TERMINATED               : return &quot;TERMINATED&quot;;
1934     default                       : return &quot;UNKNOWN&quot;;
1935   };
1936 }
<span class="line-modified">1937 int java_lang_ThreadGroup::_parent_offset;</span>
<span class="line-modified">1938 int java_lang_ThreadGroup::_name_offset;</span>
<span class="line-modified">1939 int java_lang_ThreadGroup::_threads_offset;</span>
<span class="line-modified">1940 int java_lang_ThreadGroup::_groups_offset;</span>
<span class="line-modified">1941 int java_lang_ThreadGroup::_maxPriority_offset;</span>
<span class="line-modified">1942 int java_lang_ThreadGroup::_destroyed_offset;</span>
<span class="line-modified">1943 int java_lang_ThreadGroup::_daemon_offset;</span>
<span class="line-modified">1944 int java_lang_ThreadGroup::_nthreads_offset;</span>
<span class="line-modified">1945 int java_lang_ThreadGroup::_ngroups_offset;</span>
1946 
1947 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1948   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1949   return java_thread_group-&gt;obj_field(_parent_offset);
1950 }
1951 
1952 // (&quot;name as oop&quot; accessor is not necessary)
1953 
1954 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1955   oop name = java_thread_group-&gt;obj_field(_name_offset);
1956   // ThreadGroup.name can be null
1957   if (name != NULL) {
1958     return java_lang_String::as_utf8_string(name);
1959   }
1960   return NULL;
1961 }
1962 
1963 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1964   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1965   return java_thread_group-&gt;int_field(_nthreads_offset);
</pre>
<hr />
<pre>
2005   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
2006   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
2007   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
2008   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
2009   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
2010   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
2011 
2012 void java_lang_ThreadGroup::compute_offsets() {
2013   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
2014 
2015   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
2016   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2017 }
2018 
2019 #if INCLUDE_CDS
2020 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
2021   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2022 }
2023 #endif
2024 
<span class="line-added">2025 // java_lang_Throwable</span>
<span class="line-added">2026 </span>
<span class="line-added">2027 int java_lang_Throwable::_backtrace_offset;</span>
<span class="line-added">2028 int java_lang_Throwable::_detailMessage_offset;</span>
<span class="line-added">2029 int java_lang_Throwable::_stackTrace_offset;</span>
<span class="line-added">2030 int java_lang_Throwable::_depth_offset;</span>
<span class="line-added">2031 int java_lang_Throwable::_static_unassigned_stacktrace_offset;</span>
<span class="line-added">2032 </span>
2033 #define THROWABLE_FIELDS_DO(macro) \
<span class="line-modified">2034   macro(_backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \</span>
<span class="line-modified">2035   macro(_detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \</span>
<span class="line-modified">2036   macro(_stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \</span>
<span class="line-modified">2037   macro(_depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \</span>
<span class="line-modified">2038   macro(_static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)</span>
2039 
2040 void java_lang_Throwable::compute_offsets() {
2041   InstanceKlass* k = SystemDictionary::Throwable_klass();
2042   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2043 }
2044 
2045 #if INCLUDE_CDS
2046 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2047   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2048 }
2049 #endif
2050 
2051 oop java_lang_Throwable::unassigned_stacktrace() {
2052   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2053   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">2054   return base-&gt;obj_field(_static_unassigned_stacktrace_offset);</span>
2055 }
2056 
2057 oop java_lang_Throwable::backtrace(oop throwable) {
<span class="line-modified">2058   return throwable-&gt;obj_field_acquire(_backtrace_offset);</span>
2059 }
2060 
2061 
2062 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
<span class="line-modified">2063   throwable-&gt;release_obj_field_put(_backtrace_offset, value);</span>
2064 }
2065 
2066 int java_lang_Throwable::depth(oop throwable) {
<span class="line-modified">2067   return throwable-&gt;int_field(_depth_offset);</span>
2068 }
2069 
2070 void java_lang_Throwable::set_depth(oop throwable, int value) {
<span class="line-modified">2071   throwable-&gt;int_field_put(_depth_offset, value);</span>
2072 }
2073 
2074 oop java_lang_Throwable::message(oop throwable) {
<span class="line-modified">2075   return throwable-&gt;obj_field(_detailMessage_offset);</span>
2076 }
2077 
2078 
2079 // Return Symbol for detailed_message or NULL
2080 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2081   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2082   oop detailed_message = java_lang_Throwable::message(throwable);
2083   if (detailed_message != NULL) {
2084     return java_lang_String::as_symbol(detailed_message);
2085   }
2086   return NULL;
2087 }
2088 
2089 void java_lang_Throwable::set_message(oop throwable, oop value) {
<span class="line-modified">2090   throwable-&gt;obj_field_put(_detailMessage_offset, value);</span>
2091 }
2092 
2093 
2094 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
<span class="line-modified">2095   throwable-&gt;obj_field_put(_stackTrace_offset, st_element_array);</span>
2096 }
2097 
2098 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2099   set_stacktrace(throwable, NULL);
2100 }
2101 
2102 
2103 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2104   ResourceMark rm;
2105   Klass* k = throwable-&gt;klass();
2106   assert(k != NULL, &quot;just checking&quot;);
2107   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2108   oop msg = message(throwable);
2109   if (msg != NULL) {
2110     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2111   }
2112 }
2113 
2114 // After this many redefines, the stack trace is unreliable.
2115 const int MAX_VERSION = USHRT_MAX;
</pre>
<hr />
<pre>
2854   line_number = Backtrace::get_line_number(method(), bci);
2855 }
2856 
2857 #if INCLUDE_JVMCI
2858 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2859                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2860   ResourceMark rm(THREAD);
2861   HandleMark hm(THREAD);
2862 
2863   filename = NULL;
2864   line_number = -1;
2865 
2866   oop source_file;
2867   int version = method-&gt;constants()-&gt;version();
2868   InstanceKlass* holder = method-&gt;method_holder();
2869   Handle java_class(THREAD, holder-&gt;java_mirror());
2870   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2871 }
2872 #endif // INCLUDE_JVMCI
2873 
<span class="line-added">2874 // java_lang_StackFrameInfo</span>
<span class="line-added">2875 </span>
<span class="line-added">2876 int java_lang_StackFrameInfo::_memberName_offset;</span>
<span class="line-added">2877 int java_lang_StackFrameInfo::_bci_offset;</span>
<span class="line-added">2878 int java_lang_StackFrameInfo::_version_offset;</span>
<span class="line-added">2879 </span>
<span class="line-added">2880 #define STACKFRAMEINFO_FIELDS_DO(macro) \</span>
<span class="line-added">2881   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \</span>
<span class="line-added">2882   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)</span>
<span class="line-added">2883 </span>
<span class="line-added">2884 void java_lang_StackFrameInfo::compute_offsets() {</span>
<span class="line-added">2885   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();</span>
<span class="line-added">2886   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">2887   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">2888 }</span>
<span class="line-added">2889 </span>
<span class="line-added">2890 #if INCLUDE_CDS</span>
<span class="line-added">2891 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">2892   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">2893   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">2894 }</span>
<span class="line-added">2895 #endif</span>
<span class="line-added">2896 </span>
2897 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2898   HandleMark hm(THREAD);
2899   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2900   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2901   // we should expand MemberName::name when Throwable uses StackTrace
2902   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2903   return method;
2904 }
2905 
2906 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2907   // set Method* or mid/cpref
2908   HandleMark hm(THREAD);
2909   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2910   InstanceKlass* ik = method-&gt;method_holder();
2911   CallInfo info(method(), ik, CHECK);
2912   MethodHandles::init_method_MemberName(mname, info);
2913   // set bci
2914   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2915   // method may be redefined; store the version
2916   int version = method-&gt;constants()-&gt;version();
2917   assert((jushort)version == version, &quot;version should be short&quot;);
2918   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2919 }
2920 
2921 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2922   ResourceMark rm(THREAD);
2923   HandleMark hm(THREAD);
2924   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2925   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2926   InstanceKlass* holder = InstanceKlass::cast(clazz);
2927   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2928 
2929   short version = stackFrame-&gt;short_field(_version_offset);
2930   int bci = stackFrame-&gt;int_field(_bci_offset);
2931   Symbol* name = method-&gt;name();
2932   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2933                                        version, bci, name, CHECK);
2934 }
2935 
<span class="line-modified">2936 void java_lang_StackFrameInfo::set_version(oop element, short value) {</span>
<span class="line-modified">2937   element-&gt;short_field_put(_version_offset, value);</span>






2938 }
2939 
<span class="line-modified">2940 void java_lang_StackFrameInfo::set_bci(oop element, int value) {</span>
<span class="line-modified">2941   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);</span>
<span class="line-modified">2942   element-&gt;int_field_put(_bci_offset, value);</span>

2943 }
<span class="line-modified">2944 </span>
<span class="line-added">2945 int java_lang_LiveStackFrameInfo::_monitors_offset;</span>
<span class="line-added">2946 int java_lang_LiveStackFrameInfo::_locals_offset;</span>
<span class="line-added">2947 int java_lang_LiveStackFrameInfo::_operands_offset;</span>
<span class="line-added">2948 int java_lang_LiveStackFrameInfo::_mode_offset;</span>
2949 
2950 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2951   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2952   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2953   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2954   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2955 
2956 void java_lang_LiveStackFrameInfo::compute_offsets() {
2957   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2958   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2959 }
2960 
2961 #if INCLUDE_CDS
2962 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2963   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2964 }
2965 #endif
2966 
<span class="line-added">2967 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {</span>
<span class="line-added">2968   element-&gt;obj_field_put(_monitors_offset, value);</span>
<span class="line-added">2969 }</span>
<span class="line-added">2970 </span>
<span class="line-added">2971 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {</span>
<span class="line-added">2972   element-&gt;obj_field_put(_locals_offset, value);</span>
<span class="line-added">2973 }</span>
<span class="line-added">2974 </span>
<span class="line-added">2975 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {</span>
<span class="line-added">2976   element-&gt;obj_field_put(_operands_offset, value);</span>
<span class="line-added">2977 }</span>
<span class="line-added">2978 </span>
<span class="line-added">2979 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {</span>
<span class="line-added">2980   element-&gt;int_field_put(_mode_offset, value);</span>
<span class="line-added">2981 }</span>
<span class="line-added">2982 </span>
<span class="line-added">2983 </span>
<span class="line-added">2984 // java_lang_AccessibleObject</span>
<span class="line-added">2985 </span>
<span class="line-added">2986 int java_lang_reflect_AccessibleObject::_override_offset;</span>
<span class="line-added">2987 </span>
2988 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
<span class="line-modified">2989   macro(_override_offset, k, &quot;override&quot;, bool_signature, false)</span>
2990 
2991 void java_lang_reflect_AccessibleObject::compute_offsets() {
2992   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2993   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2994 }
2995 
2996 #if INCLUDE_CDS
2997 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2998   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2999 }
3000 #endif
3001 
3002 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
<span class="line-modified">3003   return (jboolean) reflect-&gt;bool_field(_override_offset);</span>

3004 }
3005 
3006 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
<span class="line-modified">3007   reflect-&gt;bool_field_put(_override_offset, (int) value);</span>

3008 }
3009 
<span class="line-added">3010 // java_lang_reflect_Method</span>
<span class="line-added">3011 </span>
<span class="line-added">3012 int java_lang_reflect_Method::_clazz_offset;</span>
<span class="line-added">3013 int java_lang_reflect_Method::_name_offset;</span>
<span class="line-added">3014 int java_lang_reflect_Method::_returnType_offset;</span>
<span class="line-added">3015 int java_lang_reflect_Method::_parameterTypes_offset;</span>
<span class="line-added">3016 int java_lang_reflect_Method::_exceptionTypes_offset;</span>
<span class="line-added">3017 int java_lang_reflect_Method::_slot_offset;</span>
<span class="line-added">3018 int java_lang_reflect_Method::_modifiers_offset;</span>
<span class="line-added">3019 int java_lang_reflect_Method::_signature_offset;</span>
<span class="line-added">3020 int java_lang_reflect_Method::_annotations_offset;</span>
<span class="line-added">3021 int java_lang_reflect_Method::_parameter_annotations_offset;</span>
<span class="line-added">3022 int java_lang_reflect_Method::_annotation_default_offset;</span>
<span class="line-added">3023 </span>
3024 #define METHOD_FIELDS_DO(macro) \
<span class="line-modified">3025   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">3026   macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \</span>
<span class="line-modified">3027   macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \</span>
<span class="line-modified">3028   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3029   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3030   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">3031   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">3032   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">3033   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">3034   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \</span>
<span class="line-modified">3035   macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);</span>
3036 
3037 void java_lang_reflect_Method::compute_offsets() {
3038   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
3039   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3040 }
3041 
3042 #if INCLUDE_CDS
3043 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
3044   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3045 }
3046 #endif
3047 
3048 Handle java_lang_reflect_Method::create(TRAPS) {
3049   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3050   Klass* klass = SystemDictionary::reflect_Method_klass();
3051   // This class is eagerly initialized during VM initialization, since we keep a refence
3052   // to one of the methods
3053   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
3054   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
3055 }
3056 
3057 oop java_lang_reflect_Method::clazz(oop reflect) {
<span class="line-modified">3058   return reflect-&gt;obj_field(_clazz_offset);</span>

3059 }
3060 
3061 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
<span class="line-modified">3062    reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3063 }
3064 
3065 int java_lang_reflect_Method::slot(oop reflect) {
<span class="line-modified">3066   return reflect-&gt;int_field(_slot_offset);</span>

3067 }
3068 
3069 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
<span class="line-modified">3070   reflect-&gt;int_field_put(_slot_offset, value);</span>

3071 }
3072 
3073 void java_lang_reflect_Method::set_name(oop method, oop value) {
<span class="line-modified">3074   method-&gt;obj_field_put(_name_offset, value);</span>

3075 }
3076 
3077 oop java_lang_reflect_Method::return_type(oop method) {
<span class="line-modified">3078   return method-&gt;obj_field(_returnType_offset);</span>

3079 }
3080 
3081 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
<span class="line-modified">3082   method-&gt;obj_field_put(_returnType_offset, value);</span>

3083 }
3084 
3085 oop java_lang_reflect_Method::parameter_types(oop method) {
<span class="line-modified">3086   return method-&gt;obj_field(_parameterTypes_offset);</span>

3087 }
3088 
3089 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
<span class="line-modified">3090   method-&gt;obj_field_put(_parameterTypes_offset, value);</span>

3091 }
3092 
3093 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
<span class="line-modified">3094   method-&gt;obj_field_put(_exceptionTypes_offset, value);</span>

3095 }
3096 
3097 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
<span class="line-modified">3098   method-&gt;int_field_put(_modifiers_offset, value);</span>

3099 }
3100 
3101 void java_lang_reflect_Method::set_signature(oop method, oop value) {
<span class="line-modified">3102   method-&gt;obj_field_put(_signature_offset, value);</span>

3103 }
3104 
3105 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
<span class="line-modified">3106   method-&gt;obj_field_put(_annotations_offset, value);</span>

3107 }
3108 
3109 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3110   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>

3111 }
3112 
3113 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
<span class="line-modified">3114   method-&gt;obj_field_put(_annotation_default_offset, value);</span>

3115 }
3116 
<span class="line-added">3117 int java_lang_reflect_Constructor::_clazz_offset;</span>
<span class="line-added">3118 int java_lang_reflect_Constructor::_parameterTypes_offset;</span>
<span class="line-added">3119 int java_lang_reflect_Constructor::_exceptionTypes_offset;</span>
<span class="line-added">3120 int java_lang_reflect_Constructor::_slot_offset;</span>
<span class="line-added">3121 int java_lang_reflect_Constructor::_modifiers_offset;</span>
<span class="line-added">3122 int java_lang_reflect_Constructor::_signature_offset;</span>
<span class="line-added">3123 int java_lang_reflect_Constructor::_annotations_offset;</span>
<span class="line-added">3124 int java_lang_reflect_Constructor::_parameter_annotations_offset;</span>
<span class="line-added">3125 </span>
3126 #define CONSTRUCTOR_FIELDS_DO(macro) \
<span class="line-modified">3127   macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \</span>
<span class="line-modified">3128   macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3129   macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \</span>
<span class="line-modified">3130   macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \</span>
<span class="line-modified">3131   macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \</span>
<span class="line-modified">3132   macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \</span>
<span class="line-modified">3133   macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \</span>
<span class="line-modified">3134   macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);</span>
3135 
3136 void java_lang_reflect_Constructor::compute_offsets() {
3137   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3138   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3139 }
3140 
3141 #if INCLUDE_CDS
3142 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3143   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3144 }
3145 #endif
3146 
3147 Handle java_lang_reflect_Constructor::create(TRAPS) {
3148   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3149   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3150   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3151   InstanceKlass* ik = InstanceKlass::cast(k);
3152   // Ensure it is initialized
3153   ik-&gt;initialize(CHECK_NH);
3154   return ik-&gt;allocate_instance_handle(THREAD);
3155 }
3156 
3157 oop java_lang_reflect_Constructor::clazz(oop reflect) {
<span class="line-modified">3158   return reflect-&gt;obj_field(_clazz_offset);</span>

3159 }
3160 
3161 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
<span class="line-modified">3162    reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3163 }
3164 
3165 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
<span class="line-modified">3166   return constructor-&gt;obj_field(_parameterTypes_offset);</span>

3167 }
3168 
3169 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
<span class="line-modified">3170   constructor-&gt;obj_field_put(_parameterTypes_offset, value);</span>

3171 }
3172 
3173 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
<span class="line-modified">3174   constructor-&gt;obj_field_put(_exceptionTypes_offset, value);</span>

3175 }
3176 
3177 int java_lang_reflect_Constructor::slot(oop reflect) {
<span class="line-modified">3178   return reflect-&gt;int_field(_slot_offset);</span>

3179 }
3180 
3181 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
<span class="line-modified">3182   reflect-&gt;int_field_put(_slot_offset, value);</span>

3183 }
3184 
3185 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
<span class="line-modified">3186   constructor-&gt;int_field_put(_modifiers_offset, value);</span>

3187 }
3188 
3189 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
<span class="line-modified">3190   constructor-&gt;obj_field_put(_signature_offset, value);</span>

3191 }
3192 
3193 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
<span class="line-modified">3194   constructor-&gt;obj_field_put(_annotations_offset, value);</span>

3195 }
3196 
3197 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
<span class="line-modified">3198   method-&gt;obj_field_put(_parameter_annotations_offset, value);</span>

3199 }
3200 
<span class="line-added">3201 int java_lang_reflect_Field::_clazz_offset;</span>
<span class="line-added">3202 int java_lang_reflect_Field::_name_offset;</span>
<span class="line-added">3203 int java_lang_reflect_Field::_type_offset;</span>
<span class="line-added">3204 int java_lang_reflect_Field::_slot_offset;</span>
<span class="line-added">3205 int java_lang_reflect_Field::_modifiers_offset;</span>
<span class="line-added">3206 int java_lang_reflect_Field::_signature_offset;</span>
<span class="line-added">3207 int java_lang_reflect_Field::_annotations_offset;</span>
<span class="line-added">3208 </span>
3209 #define FIELD_FIELDS_DO(macro) \
<span class="line-modified">3210   macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \</span>
<span class="line-modified">3211   macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \</span>
<span class="line-modified">3212   macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \</span>
<span class="line-modified">3213   macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \</span>
<span class="line-modified">3214   macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \</span>
<span class="line-modified">3215   macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \</span>
<span class="line-modified">3216   macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);</span>
3217 
3218 void java_lang_reflect_Field::compute_offsets() {
3219   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3220   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3221 }
3222 
3223 #if INCLUDE_CDS
3224 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3225   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3226 }
3227 #endif
3228 
3229 Handle java_lang_reflect_Field::create(TRAPS) {
3230   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3231   Symbol* name = vmSymbols::java_lang_reflect_Field();
3232   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3233   InstanceKlass* ik = InstanceKlass::cast(k);
3234   // Ensure it is initialized
3235   ik-&gt;initialize(CHECK_NH);
3236   return ik-&gt;allocate_instance_handle(THREAD);
3237 }
3238 
3239 oop java_lang_reflect_Field::clazz(oop reflect) {
<span class="line-modified">3240   return reflect-&gt;obj_field(_clazz_offset);</span>

3241 }
3242 
3243 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
<span class="line-modified">3244   reflect-&gt;obj_field_put(_clazz_offset, value);</span>

3245 }
3246 
3247 oop java_lang_reflect_Field::name(oop field) {
<span class="line-modified">3248   return field-&gt;obj_field(_name_offset);</span>

3249 }
3250 
3251 void java_lang_reflect_Field::set_name(oop field, oop value) {
<span class="line-modified">3252   field-&gt;obj_field_put(_name_offset, value);</span>

3253 }
3254 
3255 oop java_lang_reflect_Field::type(oop field) {
<span class="line-modified">3256   return field-&gt;obj_field(_type_offset);</span>

3257 }
3258 
3259 void java_lang_reflect_Field::set_type(oop field, oop value) {
<span class="line-modified">3260   field-&gt;obj_field_put(_type_offset, value);</span>

3261 }
3262 
3263 int java_lang_reflect_Field::slot(oop reflect) {
<span class="line-modified">3264   return reflect-&gt;int_field(_slot_offset);</span>

3265 }
3266 
3267 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
<span class="line-modified">3268   reflect-&gt;int_field_put(_slot_offset, value);</span>

3269 }
3270 
3271 int java_lang_reflect_Field::modifiers(oop field) {
<span class="line-modified">3272   return field-&gt;int_field(_modifiers_offset);</span>

3273 }
3274 
3275 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
<span class="line-modified">3276   field-&gt;int_field_put(_modifiers_offset, value);</span>

3277 }
3278 
3279 void java_lang_reflect_Field::set_signature(oop field, oop value) {
<span class="line-modified">3280   field-&gt;obj_field_put(_signature_offset, value);</span>

3281 }
3282 
3283 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
<span class="line-modified">3284   field-&gt;obj_field_put(_annotations_offset, value);</span>

3285 }
3286 
3287 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3288   // Allocate java.lang.reflect.RecordComponent instance
3289   HandleMark hm(THREAD);
3290   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3291   assert(ik != NULL, &quot;must be loaded&quot;);
3292   ik-&gt;initialize(CHECK_NULL);
3293 
3294   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3295 
3296   Handle decl_class(THREAD, holder-&gt;java_mirror());
3297   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3298 
3299   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3300   oop component_name = StringTable::intern(name, CHECK_NULL);
3301   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3302 
3303   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3304   Handle component_type_h =
</pre>
<hr />
<pre>
3325   }
3326 
3327   int sig_index = component-&gt;generic_signature_index();
3328   if (sig_index &gt; 0) {
3329     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3330     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3331     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3332   } else {
3333     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3334   }
3335 
3336   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3337   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3338 
3339   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3340   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3341 
3342   return element();
3343 }
3344 
<span class="line-added">3345 int reflect_ConstantPool::_oop_offset;</span>
<span class="line-added">3346 </span>
3347 #define CONSTANTPOOL_FIELDS_DO(macro) \
3348   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3349 
3350 void reflect_ConstantPool::compute_offsets() {
3351   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3352   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3353   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3354 }
3355 
3356 #if INCLUDE_CDS
3357 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3358   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3359 }
3360 #endif
3361 
<span class="line-added">3362 int java_lang_reflect_Parameter::_name_offset;</span>
<span class="line-added">3363 int java_lang_reflect_Parameter::_modifiers_offset;</span>
<span class="line-added">3364 int java_lang_reflect_Parameter::_index_offset;</span>
<span class="line-added">3365 int java_lang_reflect_Parameter::_executable_offset;</span>
<span class="line-added">3366 </span>
3367 #define PARAMETER_FIELDS_DO(macro) \
<span class="line-modified">3368   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \</span>
<span class="line-modified">3369   macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \</span>
<span class="line-modified">3370   macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \</span>
<span class="line-modified">3371   macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)</span>
3372 
3373 void java_lang_reflect_Parameter::compute_offsets() {
3374   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3375   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3376 }
3377 
3378 #if INCLUDE_CDS
3379 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3380   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3381 }
3382 #endif
3383 
3384 Handle java_lang_reflect_Parameter::create(TRAPS) {
3385   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3386   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3387   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3388   InstanceKlass* ik = InstanceKlass::cast(k);
3389   // Ensure it is initialized
3390   ik-&gt;initialize(CHECK_NH);
3391   return ik-&gt;allocate_instance_handle(THREAD);
3392 }
3393 
3394 oop java_lang_reflect_Parameter::name(oop param) {
<span class="line-modified">3395   return param-&gt;obj_field(_name_offset);</span>

3396 }
3397 
3398 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
<span class="line-modified">3399   param-&gt;obj_field_put(_name_offset, value);</span>

3400 }
3401 
3402 int java_lang_reflect_Parameter::modifiers(oop param) {
<span class="line-modified">3403   return param-&gt;int_field(_modifiers_offset);</span>

3404 }
3405 
3406 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
<span class="line-modified">3407   param-&gt;int_field_put(_modifiers_offset, value);</span>

3408 }
3409 
3410 int java_lang_reflect_Parameter::index(oop param) {
<span class="line-modified">3411   return param-&gt;int_field(_index_offset);</span>

3412 }
3413 
3414 void java_lang_reflect_Parameter::set_index(oop param, int value) {
<span class="line-modified">3415   param-&gt;int_field_put(_index_offset, value);</span>

3416 }
3417 
3418 oop java_lang_reflect_Parameter::executable(oop param) {
<span class="line-modified">3419   return param-&gt;obj_field(_executable_offset);</span>

3420 }
3421 
3422 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
<span class="line-modified">3423   param-&gt;obj_field_put(_executable_offset, value);</span>

3424 }
3425 
<span class="line-added">3426 // java_lang_Module</span>
3427 
<span class="line-modified">3428 int java_lang_Module::_loader_offset;</span>
<span class="line-modified">3429 int java_lang_Module::_name_offset;</span>
<span class="line-modified">3430 int java_lang_Module::_module_entry_offset;</span>
3431 
3432 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3433   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3434   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3435                           vmSymbols::java_lang_module_init_signature(),
3436                           loader, module_name, CHECK_NH);
3437 }
3438 
3439 #define MODULE_FIELDS_DO(macro) \
<span class="line-modified">3440   macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \</span>
<span class="line-modified">3441   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)</span>
3442 
3443 void java_lang_Module::compute_offsets() {
3444   InstanceKlass* k = SystemDictionary::Module_klass();
3445   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3446   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3447 }
3448 
3449 #if INCLUDE_CDS
3450 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3451   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3452   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3453 }
3454 #endif
3455 
3456 oop java_lang_Module::loader(oop module) {
<span class="line-modified">3457   return module-&gt;obj_field(_loader_offset);</span>

3458 }
3459 
3460 void java_lang_Module::set_loader(oop module, oop value) {
<span class="line-modified">3461   module-&gt;obj_field_put(_loader_offset, value);</span>

3462 }
3463 
3464 oop java_lang_Module::name(oop module) {
<span class="line-modified">3465   return module-&gt;obj_field(_name_offset);</span>

3466 }
3467 
3468 void java_lang_Module::set_name(oop module, oop value) {
<span class="line-modified">3469   module-&gt;obj_field_put(_name_offset, value);</span>

3470 }
3471 
3472 ModuleEntry* java_lang_Module::module_entry(oop module) {
<span class="line-modified">3473   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
3474   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3475   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3476 
3477   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3478   if (module_entry == NULL) {
3479     // If the inject field containing the ModuleEntry* is null then return the
3480     // class loader&#39;s unnamed module.
3481     oop loader = java_lang_Module::loader(module);
3482     Handle h_loader = Handle(Thread::current(), loader);
3483     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3484     return loader_cld-&gt;unnamed_module();
3485   }
3486   return module_entry;
3487 }
3488 
3489 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
<span class="line-modified">3490   assert(_module_entry_offset != 0, &quot;Uninitialized module_entry_offset&quot;);</span>
3491   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3492   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3493   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3494 }
3495 
3496 Handle reflect_ConstantPool::create(TRAPS) {
3497   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3498   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3499   // Ensure it is initialized
3500   k-&gt;initialize(CHECK_NH);
3501   return k-&gt;allocate_instance_handle(THREAD);
3502 }
3503 
3504 
3505 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {

3506   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3507   // Save the mirror to get back the constant pool.
3508   reflect-&gt;obj_field_put(_oop_offset, mirror);
3509 }
3510 
3511 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {

3512 
3513   oop mirror = reflect-&gt;obj_field(_oop_offset);
3514   Klass* k = java_lang_Class::as_Klass(mirror);
3515   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3516 
3517   // Get the constant pool back from the klass.  Since class redefinition
3518   // merges the new constant pool into the old, this is essentially the
3519   // same constant pool as the original.  If constant pool merging is
3520   // no longer done in the future, this will have to change to save
3521   // the original.
3522   return InstanceKlass::cast(k)-&gt;constants();
3523 }
3524 
<span class="line-added">3525 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;</span>
<span class="line-added">3526 </span>
3527 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3528   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3529 
3530 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3531   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3532   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3533 }
3534 
3535 #if INCLUDE_CDS
3536 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3537   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3538 }
3539 #endif
3540 
<span class="line-added">3541 // Support for java_lang_ref_Reference</span>
<span class="line-added">3542 </span>
<span class="line-added">3543 bool java_lang_ref_Reference::_offsets_initialized;</span>
<span class="line-added">3544 </span>
<span class="line-added">3545 int java_lang_ref_Reference::_referent_offset;</span>
<span class="line-added">3546 int java_lang_ref_Reference::_queue_offset;</span>
<span class="line-added">3547 int java_lang_ref_Reference::_next_offset;</span>
<span class="line-added">3548 int java_lang_ref_Reference::_discovered_offset;</span>
<span class="line-added">3549 </span>
<span class="line-added">3550 #define REFERENCE_FIELDS_DO(macro) \</span>
<span class="line-added">3551   macro(_referent_offset,   k, &quot;referent&quot;, object_signature, false); \</span>
<span class="line-added">3552   macro(_queue_offset,      k, &quot;queue&quot;, referencequeue_signature, false); \</span>
<span class="line-added">3553   macro(_next_offset,       k, &quot;next&quot;, reference_signature, false); \</span>
<span class="line-added">3554   macro(_discovered_offset, k, &quot;discovered&quot;, reference_signature, false);</span>
<span class="line-added">3555 </span>
<span class="line-added">3556 void java_lang_ref_Reference::compute_offsets() {</span>
<span class="line-added">3557   if (_offsets_initialized) {</span>
<span class="line-added">3558     return;</span>
<span class="line-added">3559   }</span>
<span class="line-added">3560   _offsets_initialized = true;</span>
<span class="line-added">3561   InstanceKlass* k = SystemDictionary::Reference_klass();</span>
<span class="line-added">3562   REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3563 }</span>
<span class="line-added">3564 </span>
<span class="line-added">3565 #if INCLUDE_CDS</span>
<span class="line-added">3566 void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3567   f-&gt;do_bool(&amp;_offsets_initialized);</span>
<span class="line-added">3568   REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3569 }</span>
<span class="line-added">3570 #endif</span>
<span class="line-added">3571 </span>
<span class="line-added">3572 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {</span>
<span class="line-added">3573   assert(obj != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3574   if (offset != _referent_offset) {</span>
<span class="line-added">3575     return false;</span>
<span class="line-added">3576   }</span>
<span class="line-added">3577 </span>
<span class="line-added">3578   Klass* k = obj-&gt;klass();</span>
<span class="line-added">3579   if (!k-&gt;is_instance_klass()) {</span>
<span class="line-added">3580     return false;</span>
<span class="line-added">3581   }</span>
<span class="line-added">3582 </span>
<span class="line-added">3583   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());</span>
<span class="line-added">3584   bool is_reference = ik-&gt;reference_type() != REF_NONE;</span>
<span class="line-added">3585   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);</span>
<span class="line-added">3586   return is_reference;</span>
<span class="line-added">3587 }</span>
<span class="line-added">3588 </span>
<span class="line-added">3589 int java_lang_boxing_object::_value_offset;</span>
<span class="line-added">3590 int java_lang_boxing_object::_long_value_offset;</span>
<span class="line-added">3591 </span>
<span class="line-added">3592 #define BOXING_FIELDS_DO(macro) \</span>
<span class="line-added">3593   macro(_value_offset,      integerKlass, &quot;value&quot;, int_signature, false); \</span>
<span class="line-added">3594   macro(_long_value_offset, longKlass, &quot;value&quot;, long_signature, false);</span>
<span class="line-added">3595 </span>
<span class="line-added">3596 void java_lang_boxing_object::compute_offsets() {</span>
<span class="line-added">3597   InstanceKlass* integerKlass = SystemDictionary::Integer_klass();</span>
<span class="line-added">3598   InstanceKlass* longKlass = SystemDictionary::Long_klass();</span>
<span class="line-added">3599   BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">3600 }</span>
<span class="line-added">3601 </span>
<span class="line-added">3602 #if INCLUDE_CDS</span>
<span class="line-added">3603 void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">3604   BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">3605 }</span>
<span class="line-added">3606 #endif</span>
<span class="line-added">3607 </span>
3608 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3609   Klass* k = SystemDictionary::box_klass(type);
3610   if (k == NULL)  return NULL;
3611   InstanceKlass* ik = InstanceKlass::cast(k);
3612   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3613   return ik-&gt;allocate_instance(THREAD);
3614 }
3615 
3616 
3617 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3618   oop box = initialize_and_allocate(type, CHECK_NULL);
3619   if (box == NULL)  return NULL;
3620   switch (type) {
3621     case T_BOOLEAN:
<span class="line-modified">3622       box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
3623       break;
3624     case T_CHAR:
<span class="line-modified">3625       box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
3626       break;
3627     case T_FLOAT:
<span class="line-modified">3628       box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
3629       break;
3630     case T_DOUBLE:
<span class="line-modified">3631       box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
3632       break;
3633     case T_BYTE:
<span class="line-modified">3634       box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
3635       break;
3636     case T_SHORT:
<span class="line-modified">3637       box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
3638       break;
3639     case T_INT:
<span class="line-modified">3640       box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
3641       break;
3642     case T_LONG:
<span class="line-modified">3643       box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
3644       break;
3645     default:
3646       return NULL;
3647   }
3648   return box;
3649 }
3650 
3651 
3652 BasicType java_lang_boxing_object::basic_type(oop box) {
3653   if (box == NULL)  return T_ILLEGAL;
3654   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3655   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3656     return T_ILLEGAL;
3657   return type;
3658 }
3659 
3660 
3661 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3662   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3663   switch (type) {
3664   case T_BOOLEAN:
<span class="line-modified">3665     value-&gt;z = box-&gt;bool_field(_value_offset);</span>
3666     break;
3667   case T_CHAR:
<span class="line-modified">3668     value-&gt;c = box-&gt;char_field(_value_offset);</span>
3669     break;
3670   case T_FLOAT:
<span class="line-modified">3671     value-&gt;f = box-&gt;float_field(_value_offset);</span>
3672     break;
3673   case T_DOUBLE:
<span class="line-modified">3674     value-&gt;d = box-&gt;double_field(_long_value_offset);</span>
3675     break;
3676   case T_BYTE:
<span class="line-modified">3677     value-&gt;b = box-&gt;byte_field(_value_offset);</span>
3678     break;
3679   case T_SHORT:
<span class="line-modified">3680     value-&gt;s = box-&gt;short_field(_value_offset);</span>
3681     break;
3682   case T_INT:
<span class="line-modified">3683     value-&gt;i = box-&gt;int_field(_value_offset);</span>
3684     break;
3685   case T_LONG:
<span class="line-modified">3686     value-&gt;j = box-&gt;long_field(_long_value_offset);</span>
3687     break;
3688   default:
3689     return T_ILLEGAL;
3690   } // end switch
3691   return type;
3692 }
3693 
3694 
3695 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3696   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3697   switch (type) {
3698   case T_BOOLEAN:
<span class="line-modified">3699     box-&gt;bool_field_put(_value_offset, value-&gt;z);</span>
3700     break;
3701   case T_CHAR:
<span class="line-modified">3702     box-&gt;char_field_put(_value_offset, value-&gt;c);</span>
3703     break;
3704   case T_FLOAT:
<span class="line-modified">3705     box-&gt;float_field_put(_value_offset, value-&gt;f);</span>
3706     break;
3707   case T_DOUBLE:
<span class="line-modified">3708     box-&gt;double_field_put(_long_value_offset, value-&gt;d);</span>
3709     break;
3710   case T_BYTE:
<span class="line-modified">3711     box-&gt;byte_field_put(_value_offset, value-&gt;b);</span>
3712     break;
3713   case T_SHORT:
<span class="line-modified">3714     box-&gt;short_field_put(_value_offset, value-&gt;s);</span>
3715     break;
3716   case T_INT:
<span class="line-modified">3717     box-&gt;int_field_put(_value_offset, value-&gt;i);</span>
3718     break;
3719   case T_LONG:
<span class="line-modified">3720     box-&gt;long_field_put(_long_value_offset, value-&gt;j);</span>
3721     break;
3722   default:
3723     return T_ILLEGAL;
3724   } // end switch
3725   return type;
3726 }
3727 
3728 
3729 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3730   switch (type) {
3731   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3732   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3733   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3734   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3735   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3736   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3737   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3738   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3739   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3740   }
3741 }
3742 
























































3743 
3744 // Support for java_lang_ref_SoftReference
3745 //
3746 
<span class="line-added">3747 int java_lang_ref_SoftReference::_timestamp_offset;</span>
<span class="line-added">3748 int java_lang_ref_SoftReference::_static_clock_offset;</span>
<span class="line-added">3749 </span>
3750 #define SOFTREFERENCE_FIELDS_DO(macro) \
<span class="line-modified">3751   macro(_timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \</span>
<span class="line-modified">3752   macro(_static_clock_offset, k, &quot;clock&quot;,     long_signature, true)</span>
3753 
3754 void java_lang_ref_SoftReference::compute_offsets() {
3755   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3756   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3757 }
3758 
3759 #if INCLUDE_CDS
3760 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3761   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3762 }
3763 #endif
3764 
3765 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
<span class="line-modified">3766   return ref-&gt;long_field(_timestamp_offset);</span>
3767 }
3768 
3769 jlong java_lang_ref_SoftReference::clock() {
3770   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3771   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3772   return base-&gt;long_field(_static_clock_offset);</span>
3773 }
3774 
3775 void java_lang_ref_SoftReference::set_clock(jlong value) {
3776   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3777   oop base = ik-&gt;static_field_base_raw();
<span class="line-modified">3778   base-&gt;long_field_put(_static_clock_offset, value);</span>
3779 }
3780 
3781 // Support for java_lang_invoke_DirectMethodHandle
3782 
3783 int java_lang_invoke_DirectMethodHandle::_member_offset;
3784 
3785 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3786   oop member_name = NULL;
3787   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3788          &quot;a DirectMethodHandle oop is expected&quot;);
<span class="line-modified">3789   return dmh-&gt;obj_field(_member_offset);</span>
3790 }
3791 
3792 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3793   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3794 
3795 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3796   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3797   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3798 }
3799 
3800 #if INCLUDE_CDS
3801 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3802   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3803 }
3804 #endif
3805 
3806 // Support for java_lang_invoke_MethodHandle
3807 
3808 int java_lang_invoke_MethodHandle::_type_offset;
3809 int java_lang_invoke_MethodHandle::_form_offset;
</pre>
<hr />
<pre>
4187   InstanceKlass* k = SystemDictionary::Context_klass();
4188   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4189 }
4190 
4191 #if INCLUDE_CDS
4192 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4193   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4194 }
4195 #endif
4196 
4197 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4198   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4199   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4200   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4201   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4202   return dep_ctx;
4203 }
4204 
4205 // Support for java_security_AccessControlContext
4206 
<span class="line-modified">4207 int java_security_AccessControlContext::_context_offset;</span>
<span class="line-modified">4208 int java_security_AccessControlContext::_privilegedContext_offset;</span>
<span class="line-modified">4209 int java_security_AccessControlContext::_isPrivileged_offset;</span>
<span class="line-modified">4210 int java_security_AccessControlContext::_isAuthorized_offset;</span>
4211 
4212 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4213   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4214   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4215   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4216   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4217 
4218 void java_security_AccessControlContext::compute_offsets() {
4219   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4220   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4221   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4222 }
4223 
4224 #if INCLUDE_CDS
4225 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4226   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4227 }
4228 #endif
4229 
4230 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4231   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
<span class="line-modified">4232   assert(_isAuthorized_offset != 0, &quot;offsets should have been initialized&quot;);</span>
4233   // Ensure klass is initialized
4234   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4235   // Allocate result
4236   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4237   // Fill in values
4238   result-&gt;obj_field_put(_context_offset, context());
4239   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4240   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4241   // whitelist AccessControlContexts created by the JVM
4242   result-&gt;bool_field_put(_isAuthorized_offset, true);
4243   return result;
4244 }
4245 
4246 
4247 // Support for java_lang_ClassLoader
4248 
<span class="line-modified">4249 int  java_lang_ClassLoader::_loader_data_offset;</span>
<span class="line-modified">4250 int  java_lang_ClassLoader::_parallelCapable_offset;</span>
<span class="line-modified">4251 int  java_lang_ClassLoader::_name_offset;</span>
<span class="line-modified">4252 int  java_lang_ClassLoader::_nameAndId_offset;</span>
<span class="line-modified">4253 int  java_lang_ClassLoader::_unnamedModule_offset;</span>
<span class="line-modified">4254 int  java_lang_ClassLoader::_parent_offset;</span>
4255 
4256 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4257   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4258   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4259   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4260 }
4261 
4262 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4263   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4264   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4265   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4266 }
4267 
4268 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4269   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4270   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4271   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4272 }
4273 
4274 #define CLASSLOADER_FIELDS_DO(macro) \
<span class="line-modified">4275   macro(_parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \</span>
<span class="line-modified">4276   macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \</span>
<span class="line-modified">4277   macro(_nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \</span>
<span class="line-modified">4278   macro(_unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \</span>
<span class="line-modified">4279   macro(_parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)</span>
4280 
4281 void java_lang_ClassLoader::compute_offsets() {



4282   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4283   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4284 
4285   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4286 }
4287 
4288 #if INCLUDE_CDS
4289 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4290   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4291   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4292 }
4293 #endif
4294 
4295 oop java_lang_ClassLoader::parent(oop loader) {
4296   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4297   return loader-&gt;obj_field(_parent_offset);</span>
4298 }
4299 
4300 // Returns the name field of this class loader.  If the name field has not
4301 // been set, null will be returned.
4302 oop java_lang_ClassLoader::name(oop loader) {
4303   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4304   return loader-&gt;obj_field(_name_offset);</span>
4305 }
4306 
4307 // Returns the nameAndId field of this class loader. The format is
4308 // as follows:
4309 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4310 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4311 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4312 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4313 oop java_lang_ClassLoader::nameAndId(oop loader) {
4314   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4315   return loader-&gt;obj_field(_nameAndId_offset);</span>
4316 }
4317 
4318 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4319   assert(is_instance(loader), &quot;loader must be oop&quot;);
4320   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4321   oop acl = loader;
4322   debug_only(jint loop_count = 0);
4323   // This loop taken verbatim from ClassLoader.java:
4324   do {
4325     acl = parent(acl);
4326     if (cl == acl) {
4327       return true;
4328     }
4329     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4330   } while (acl != NULL);
4331   return false;
4332 }
4333 
4334 bool java_lang_ClassLoader::is_instance(oop obj) {
4335   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4336 }
4337 
4338 
4339 // For class loader classes, parallelCapable defined
4340 // based on non-null field
4341 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4342 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
<span class="line-modified">4343   assert(_parallelCapable_offset != 0, &quot;offsets should have been initialized&quot;);</span>
<span class="line-modified">4344   return (class_loader-&gt;obj_field(_parallelCapable_offset) != NULL);</span>
4345 }
4346 
4347 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4348   // Fix for 4474172; see evaluation for more details
4349   loader = non_reflection_class_loader(loader);
4350 
4351   oop cl = SystemDictionary::java_system_loader();
4352   while(cl != NULL) {
4353     if (cl == loader) return true;
4354     cl = parent(cl);
4355   }
4356   return false;
4357 }
4358 
4359 // Return true if this is one of the class loaders associated with
4360 // the generated bytecodes for reflection.
4361 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4362   if (loader != NULL) {
4363     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4364     // This might be null in non-1.4 JDKs
4365     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4366   }
4367   return false;
4368 }
4369 
4370 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4371   // See whether this is one of the class loaders associated with
4372   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4373   // delegate to its parent to prevent class loading from occurring
4374   // in places where applications using reflection didn&#39;t expect it.
4375   if (is_reflection_class_loader(loader)) {
4376     return parent(loader);
4377   }
4378   return loader;
4379 }
4380 
4381 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4382   assert(is_instance(loader), &quot;loader must be oop&quot;);
<span class="line-modified">4383   return loader-&gt;obj_field(_unnamedModule_offset);</span>
4384 }
4385 
4386 // Support for java_lang_System
4387 //
<span class="line-added">4388 </span>
<span class="line-added">4389 int java_lang_System::_static_in_offset;</span>
<span class="line-added">4390 int java_lang_System::_static_out_offset;</span>
<span class="line-added">4391 int java_lang_System::_static_err_offset;</span>
<span class="line-added">4392 int java_lang_System::_static_security_offset;</span>
<span class="line-added">4393 </span>
4394 #define SYSTEM_FIELDS_DO(macro) \
<span class="line-modified">4395   macro(_static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \</span>
<span class="line-modified">4396   macro(_static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4397   macro(_static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \</span>
<span class="line-modified">4398   macro(_static_security_offset, k, &quot;security&quot;, security_manager_signature, true)</span>
4399 
4400 void java_lang_System::compute_offsets() {
4401   InstanceKlass* k = SystemDictionary::System_klass();
4402   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4403 }
4404 
4405 #if INCLUDE_CDS
4406 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4407    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4408 }
4409 #endif
4410 




4411 // Support for jdk_internal_misc_UnsafeConstants
4412 //
4413 class UnsafeConstantsFixup : public FieldClosure {
4414 private:
4415   int _address_size;
4416   int _page_size;
4417   bool _big_endian;
4418   bool _use_unaligned_access;
4419   int _data_cache_line_flush_size;
4420 public:
4421   UnsafeConstantsFixup() {
4422     // round up values for all static final fields
4423     _address_size = sizeof(void*);
4424     _page_size = os::vm_page_size();
4425     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4426     _use_unaligned_access = UseUnalignedAccesses;
4427     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4428   }
4429 
4430   void do_field(fieldDescriptor* fd) {
</pre>
<hr />
<pre>
4437       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4438     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4439       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4440     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4441       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4442     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4443       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4444     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4445       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4446     } else {
4447       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4448     }
4449   }
4450 };
4451 
4452 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4453   UnsafeConstantsFixup fixup;
4454   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4455 }
4456 
<span class="line-modified">4457 </span>













































































































4458 // java_lang_StackTraceElement
4459 
<span class="line-added">4460 int java_lang_StackTraceElement::_methodName_offset;</span>
<span class="line-added">4461 int java_lang_StackTraceElement::_fileName_offset;</span>
<span class="line-added">4462 int java_lang_StackTraceElement::_lineNumber_offset;</span>
<span class="line-added">4463 int java_lang_StackTraceElement::_moduleName_offset;</span>
<span class="line-added">4464 int java_lang_StackTraceElement::_moduleVersion_offset;</span>
<span class="line-added">4465 int java_lang_StackTraceElement::_classLoaderName_offset;</span>
<span class="line-added">4466 int java_lang_StackTraceElement::_declaringClass_offset;</span>
<span class="line-added">4467 int java_lang_StackTraceElement::_declaringClassObject_offset;</span>
4468 
4469 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
<span class="line-modified">4470   macro(_declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \</span>
<span class="line-modified">4471   macro(_classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \</span>
<span class="line-modified">4472   macro(_moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \</span>
<span class="line-modified">4473   macro(_moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \</span>
<span class="line-modified">4474   macro(_declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \</span>
<span class="line-modified">4475   macro(_methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \</span>
<span class="line-modified">4476   macro(_fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \</span>
<span class="line-modified">4477   macro(_lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)</span>
4478 
4479 // Support for java_lang_StackTraceElement
4480 void java_lang_StackTraceElement::compute_offsets() {
4481   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4482   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4483 }
4484 
4485 #if INCLUDE_CDS
4486 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4487   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4488 }
4489 #endif
4490 
4491 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
<span class="line-modified">4492   element-&gt;obj_field_put(_fileName_offset, value);</span>
4493 }
4494 
4495 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
<span class="line-modified">4496   element-&gt;obj_field_put(_declaringClass_offset, value);</span>
4497 }
4498 
4499 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
<span class="line-modified">4500   element-&gt;obj_field_put(_methodName_offset, value);</span>
4501 }
4502 
4503 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
<span class="line-modified">4504   element-&gt;int_field_put(_lineNumber_offset, value);</span>
4505 }
4506 
4507 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
<span class="line-modified">4508   element-&gt;obj_field_put(_moduleName_offset, value);</span>
4509 }
4510 
4511 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
<span class="line-modified">4512   element-&gt;obj_field_put(_moduleVersion_offset, value);</span>
4513 }
4514 
4515 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
<span class="line-modified">4516   element-&gt;obj_field_put(_classLoaderName_offset, value);</span>
4517 }
4518 
4519 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
<span class="line-modified">4520   element-&gt;obj_field_put(_declaringClassObject_offset, value);</span>
4521 }
4522 
<span class="line-modified">4523 </span>














4524 // java_lang_AssertionStatusDirectives
4525 
<span class="line-modified">4526 int java_lang_AssertionStatusDirectives::_classes_offset;</span>
<span class="line-modified">4527 int java_lang_AssertionStatusDirectives::_classEnabled_offset;</span>
<span class="line-modified">4528 int java_lang_AssertionStatusDirectives::_packages_offset;</span>
<span class="line-modified">4529 int java_lang_AssertionStatusDirectives::_packageEnabled_offset;</span>
<span class="line-modified">4530 int java_lang_AssertionStatusDirectives::_deflt_offset;</span>


4531 
4532 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4533 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
<span class="line-modified">4534   macro(_classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \</span>
<span class="line-modified">4535   macro(_classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \</span>
<span class="line-modified">4536   macro(_packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \</span>
<span class="line-modified">4537   macro(_packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \</span>
<span class="line-modified">4538   macro(_deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)</span>
4539 
4540 void java_lang_AssertionStatusDirectives::compute_offsets() {
4541   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4542   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4543 }
4544 
4545 #if INCLUDE_CDS
4546 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4547   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4548 }
4549 #endif
4550 
4551 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
<span class="line-modified">4552   o-&gt;obj_field_put(_classes_offset, val);</span>
4553 }
4554 
4555 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
<span class="line-modified">4556   o-&gt;obj_field_put(_classEnabled_offset, val);</span>
4557 }
4558 
4559 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
<span class="line-modified">4560   o-&gt;obj_field_put(_packages_offset, val);</span>
4561 }
4562 
4563 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
<span class="line-modified">4564   o-&gt;obj_field_put(_packageEnabled_offset, val);</span>
4565 }
4566 
4567 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
<span class="line-modified">4568   o-&gt;bool_field_put(_deflt_offset, val);</span>
4569 }
4570 
4571 
4572 // Support for intrinsification of java.nio.Buffer.checkIndex
<span class="line-modified">4573 </span>
<span class="line-modified">4574 int java_nio_Buffer::_limit_offset;</span>

4575 
4576 #define BUFFER_FIELDS_DO(macro) \
4577   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4578 
4579 void java_nio_Buffer::compute_offsets() {
4580   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4581   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4582   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4583 }
4584 
4585 #if INCLUDE_CDS
4586 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4587   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4588 }
4589 #endif
4590 
<span class="line-added">4591 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;</span>
<span class="line-added">4592 </span>
4593 #define AOS_FIELDS_DO(macro) \
4594   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4595 
4596 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4597   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4598   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4599 }
4600 
4601 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4602   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4603   return obj-&gt;obj_field(_owner_offset);
4604 }
4605 
4606 #if INCLUDE_CDS
4607 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4608   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4609 }
4610 #endif
4611 
<span class="line-added">4612 int java_lang_Integer_IntegerCache::_static_cache_offset;</span>
<span class="line-added">4613 int java_lang_Long_LongCache::_static_cache_offset;</span>
<span class="line-added">4614 int java_lang_Character_CharacterCache::_static_cache_offset;</span>
<span class="line-added">4615 int java_lang_Short_ShortCache::_static_cache_offset;</span>
<span class="line-added">4616 int java_lang_Byte_ByteCache::_static_cache_offset;</span>
<span class="line-added">4617 </span>
4618 #define INTEGER_CACHE_FIELDS_DO(macro) \
4619   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4620 
4621 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4622   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4623   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4624 }
4625 
4626 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4627   oop base = ik-&gt;static_field_base_raw();
4628   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4629 }
4630 
4631 Symbol* java_lang_Integer_IntegerCache::symbol() {
4632   return vmSymbols::java_lang_Integer_IntegerCache();
4633 }
4634 
4635 #if INCLUDE_CDS
4636 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4637   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
</pre>
<hr />
<pre>
4742   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4743   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4744 }
4745 
4746 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4747   oop base = ik-&gt;static_field_base_raw();
4748   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4749 }
4750 
4751 Symbol* java_lang_Byte_ByteCache::symbol() {
4752   return vmSymbols::java_lang_Byte_ByteCache();
4753 }
4754 
4755 #if INCLUDE_CDS
4756 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4757   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4758 }
4759 #endif
4760 #undef BYTE_CACHE_FIELDS_DO
4761 
<span class="line-added">4762 // jdk_internal_vm_jni_SubElementSelector</span>
<span class="line-added">4763 </span>
<span class="line-added">4764 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4765 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4766 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4767 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4768 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
<span class="line-added">4769 </span>
4770 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \
4771   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \
4772   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \
4773   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \
4774   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \
4775   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);
4776 
4777 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {
4778   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();
4779   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4780 }
4781 
4782 #if INCLUDE_CDS
4783 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {
4784   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4785 }
4786 #endif
4787 #undef SUBELEMENT_SELECTOR_FIELDS_DO
4788 
4789 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {
</pre>
<hr />
<pre>
4818   return obj-&gt;bool_field(_isFlattened_offset);
4819 }
4820 
4821 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {
4822   obj-&gt;bool_field_put(_isFlattened_offset, b);
4823 }
4824 
4825 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {
4826   return obj-&gt;bool_field(_isFlattenable_offset);
4827 }
4828 
4829 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {
4830   obj-&gt;bool_field_put(_isFlattenable_offset, b);
4831 }
4832 
4833 jbyte java_lang_Byte::value(oop obj) {
4834    jvalue v;
4835    java_lang_boxing_object::get_value(obj, &amp;v);
4836    return v.b;
4837 }
<span class="line-added">4838 </span>
<span class="line-added">4839 int java_lang_Boolean::_static_TRUE_offset;</span>
<span class="line-added">4840 int java_lang_Boolean::_static_FALSE_offset;</span>
<span class="line-added">4841 </span>
4842 #define BOOLEAN_FIELDS_DO(macro) \
4843   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4844   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4845 
4846 
4847 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4848   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4849   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4850 }
4851 
4852 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4853   oop base = ik-&gt;static_field_base_raw();
4854   return base-&gt;obj_field(_static_TRUE_offset);
4855 }
4856 
4857 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4858   oop base = ik-&gt;static_field_base_raw();
4859   return base-&gt;obj_field(_static_FALSE_offset);
4860 }
4861 
4862 Symbol* java_lang_Boolean::symbol() {
4863   return vmSymbols::java_lang_Boolean();
4864 }
4865 
4866 #if INCLUDE_CDS
4867 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4868   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4869 }
4870 #endif
4871 #undef BOOLEAN_CACHE_FIELDS_DO
4872 
4873 jboolean java_lang_Boolean::value(oop obj) {
4874    jvalue v;
4875    java_lang_boxing_object::get_value(obj, &amp;v);
4876    return v.z;
4877 }
4878 
<span class="line-added">4879 // java_lang_reflect_RecordComponent</span>
<span class="line-added">4880 </span>
<span class="line-added">4881 int java_lang_reflect_RecordComponent::_clazz_offset;</span>
<span class="line-added">4882 int java_lang_reflect_RecordComponent::_name_offset;</span>
<span class="line-added">4883 int java_lang_reflect_RecordComponent::_type_offset;</span>
<span class="line-added">4884 int java_lang_reflect_RecordComponent::_accessor_offset;</span>
<span class="line-added">4885 int java_lang_reflect_RecordComponent::_signature_offset;</span>
<span class="line-added">4886 int java_lang_reflect_RecordComponent::_annotations_offset;</span>
<span class="line-added">4887 int java_lang_reflect_RecordComponent::_typeAnnotations_offset;</span>
<span class="line-added">4888 </span>
4889 #define RECORDCOMPONENT_FIELDS_DO(macro) \
<span class="line-modified">4890   macro(_clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \</span>
<span class="line-modified">4891   macro(_name_offset,        k, &quot;name&quot;,        string_signature, false); \</span>
<span class="line-modified">4892   macro(_type_offset,        k, &quot;type&quot;,        class_signature,  false); \</span>
<span class="line-modified">4893   macro(_accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \</span>
<span class="line-modified">4894   macro(_signature_offset,   k, &quot;signature&quot;,   string_signature, false); \</span>
<span class="line-modified">4895   macro(_annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \</span>
<span class="line-modified">4896   macro(_typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);</span>
4897 
4898 // Support for java_lang_reflect_RecordComponent
4899 void java_lang_reflect_RecordComponent::compute_offsets() {
4900   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4901   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4902 }
4903 
4904 #if INCLUDE_CDS
4905 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4906   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4907 }
4908 #endif
4909 
4910 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
<span class="line-modified">4911   element-&gt;obj_field_put(_clazz_offset, value);</span>
4912 }
4913 
4914 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
<span class="line-modified">4915   element-&gt;obj_field_put(_name_offset, value);</span>
4916 }
4917 
4918 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
<span class="line-modified">4919   element-&gt;obj_field_put(_type_offset, value);</span>
4920 }
4921 
4922 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
<span class="line-modified">4923   element-&gt;obj_field_put(_accessor_offset, value);</span>
4924 }
4925 
4926 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
<span class="line-modified">4927   element-&gt;obj_field_put(_signature_offset, value);</span>
4928 }
4929 
4930 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
<span class="line-modified">4931   element-&gt;obj_field_put(_annotations_offset, value);</span>
4932 }
4933 
4934 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
<span class="line-modified">4935   element-&gt;obj_field_put(_typeAnnotations_offset, value);</span>
4936 }
4937 
4938 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4939 
<span class="line-modified">4940 // Compute field offsets of all the classes in this file</span>
4941 void JavaClasses::compute_offsets() {
4942   if (UseSharedSpaces) {
4943     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4944                                                          JvmtiExport::has_early_class_hook_env()),
4945                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4946     // None of the classes used by the rest of this function can be replaced by
<span class="line-modified">4947     // JVMTI ClassFileLoadHook.</span>
4948     // We are safe to use the archived offsets, which have already been restored
4949     // by JavaClasses::serialize_offsets, without computing the offsets again.
4950     return;
4951   }
4952 
4953   // We have already called the compute_offsets() of the
4954   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and
4955   // java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()
4956   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4957 }
4958 
4959 #if INCLUDE_CDS
4960 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4961 
4962 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4963   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4964 }
4965 #endif
4966 
4967 #if INCLUDE_CDS_JAVA_HEAP
</pre>
<hr />
<pre>
4972       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4973       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4974       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4975       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4976       // So for now we cannot not support these classes for archiving.
4977       //
4978       // These objects typically are not referenced by static fields, but rather by resolved
4979       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4980       klass == SystemDictionary::ResolvedMethodName_klass() ||
4981       klass == SystemDictionary::MemberName_klass() ||
4982       klass == SystemDictionary::Context_klass()) {
4983     return false;
4984   }
4985 
4986   return true;
4987 }
4988 #endif
4989 
4990 #ifndef PRODUCT
4991 
<span class="line-modified">4992 // These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.</span>

4993 
<span class="line-modified">4994 bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,</span>
<span class="line-added">4995                                const char* field_sig) {</span>
4996   EXCEPTION_MARK;
4997   fieldDescriptor fd;
4998   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4999   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5000   InstanceKlass* ik = InstanceKlass::cast(k);
5001   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5002   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5003   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5004     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5005     return false;
5006   }
5007   if (fd.is_static()) {
5008     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5009     return false;
5010   }
<span class="line-modified">5011   if (fd.offset() == deserialized_offset ) {</span>
5012     return true;
5013   } else {
<span class="line-modified">5014     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.&quot;,</span>
<span class="line-modified">5015                   klass_name, field_name, deserialized_offset, fd.offset());</span>
5016     return false;
5017   }
5018 }
5019 


5020 void JavaClasses::check_offsets() {
5021   bool valid = true;
5022 
5023 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">5024   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)</span>
5025 
5026 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
<span class="line-modified">5027   valid &amp;= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)</span>
5028 
5029   // Boxed primitive objects (java_lang_boxing_object)
5030 
5031   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5032   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5033   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5034   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5035   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5036   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5037   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5038   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5039 
<span class="line-modified">5040   if (!valid) vm_exit_during_initialization(&quot;Field offset verification failed&quot;);</span>
5041 }
5042 
5043 #endif // PRODUCT
5044 
5045 int InjectedField::compute_offset() {
5046   InstanceKlass* ik = InstanceKlass::cast(klass());
5047   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5048     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5049       // Only look at injected fields
5050       continue;
5051     }
5052     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5053       return fs.offset();
5054     }
5055   }
5056   ResourceMark rm;
5057   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5058 #ifndef PRODUCT
5059   ik-&gt;print();
5060   tty-&gt;print_cr(&quot;all fields:&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
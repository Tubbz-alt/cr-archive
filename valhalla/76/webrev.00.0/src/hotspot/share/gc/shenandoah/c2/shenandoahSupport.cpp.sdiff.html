<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../z/zBarrierSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 281   Node_Stack phis(0);
 282   VectorSet visited(Thread::current()-&gt;resource_area());
 283   const bool trace = false;
 284   const bool verify_no_useless_barrier = false;
 285 
 286   wq.push(root);
 287   for (uint next = 0; next &lt; wq.size(); next++) {
 288     Node *n = wq.at(next);
 289     if (n-&gt;is_Load()) {
 290       const bool trace = false;
 291       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 292       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 293         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 294       } else {
 295         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 296 
 297         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 298           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 299         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 300                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
<span class="line-modified"> 301                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset) {</span>
 302           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
 303         } else if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {
 304           report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);
 305         }
 306       }
 307     } else if (n-&gt;is_Store()) {
 308       const bool trace = false;
 309 
 310       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 311       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 312         Node* adr = n-&gt;in(MemNode::Address);
 313         bool verify = true;
 314 
 315         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 316           adr = adr-&gt;in(AddPNode::Address);
 317           if (adr-&gt;is_AddP()) {
 318             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 319             adr = adr-&gt;in(AddPNode::Address);
 320             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 321                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
</pre>
<hr />
<pre>
1078   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1079 
1080   Unique_Node_List uses;
1081   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1082     Node* barrier = state-&gt;enqueue_barrier(i);
1083     Node* ctrl = phase-&gt;get_ctrl(barrier);
1084     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1085     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1086       // Expanding a barrier here will break loop strip mining
1087       // verification. Transform the loop so the loop nest doesn&#39;t
1088       // appear as strip mined.
1089       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1090       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1091     }
1092   }
1093 
1094   Node_Stack stack(0);
1095   Node_List clones;
1096   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1097     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-removed">1098     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1099       continue;</span>
<span class="line-removed">1100     }</span>
1101 
1102     Node* ctrl = phase-&gt;get_ctrl(lrb);
1103     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1104 
1105     CallStaticJavaNode* unc = NULL;
1106     Node* unc_ctrl = NULL;
1107     Node* uncasted_val = val;
1108 
1109     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1110       Node* u = lrb-&gt;fast_out(i);
1111       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1112           u-&gt;in(0) != NULL &amp;&amp;
1113           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1114         const Type* u_t = phase-&gt;igvn().type(u);
1115 
1116         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1117             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1118             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1119             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
1120             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
</pre>
<hr />
<pre>
1270                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1271                 }
1272                 replaced = true;
1273               }
1274             }
1275             if (!replaced) {
1276               stack.set_index(idx+1);
1277             }
1278           }
1279         } else {
1280           stack.pop();
1281           clones.pop();
1282         }
1283       } while (stack.size() &gt; 0);
1284       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1285     }
1286   }
1287 
1288   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1289     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-removed">1290     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1291       continue;</span>
<span class="line-removed">1292     }</span>
1293     Node* ctrl = phase-&gt;get_ctrl(lrb);
1294     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1295     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1296       // Expanding a barrier here will break loop strip mining
1297       // verification. Transform the loop so the loop nest doesn&#39;t
1298       // appear as strip mined.
1299       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1300       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1301     }
1302   }
1303 
1304   // Expand load-reference-barriers
1305   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1306   Unique_Node_List uses_to_ignore;
1307   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1308     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
<span class="line-removed">1309     if (lrb-&gt;is_redundant()) {</span>
<span class="line-removed">1310       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));</span>
<span class="line-removed">1311       continue;</span>
<span class="line-removed">1312     }</span>
1313     uint last = phase-&gt;C-&gt;unique();
1314     Node* ctrl = phase-&gt;get_ctrl(lrb);
1315     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1316 
1317 
1318     Node* orig_ctrl = ctrl;
1319 
1320     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1321     Node* init_raw_mem = raw_mem;
1322     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1323 
1324     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1325 
1326     Node* heap_stable_ctrl = NULL;
1327     Node* null_ctrl = NULL;
1328 
1329     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1330     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1331 
1332     enum { _heap_stable = 1, _not_cset, _evac_path, PATH_LIMIT };
</pre>
<hr />
<pre>
3005     case Op_CMoveP:
3006       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
3007              needs_barrier_impl(phase, n-&gt;in(3), visited);
3008     case Op_ShenandoahEnqueueBarrier:
3009       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3010     case Op_CreateEx:
3011       return false;
3012     default:
3013       break;
3014   }
3015 #ifdef ASSERT
3016   tty-&gt;print(&quot;need barrier on?: &quot;);
3017   tty-&gt;print_cr(&quot;ins:&quot;);
3018   n-&gt;dump(2);
3019   tty-&gt;print_cr(&quot;outs:&quot;);
3020   n-&gt;dump(-2);
3021   ShouldNotReachHere();
3022 #endif
3023   return true;
3024 }
<span class="line-removed">3025 </span>
<span class="line-removed">3026 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {</span>
<span class="line-removed">3027   Unique_Node_List visited;</span>
<span class="line-removed">3028   Node_Stack stack(0);</span>
<span class="line-removed">3029   stack.push(this, 0);</span>
<span class="line-removed">3030 </span>
<span class="line-removed">3031   // Check if the barrier is actually useful: go over nodes looking for useful uses</span>
<span class="line-removed">3032   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk</span>
<span class="line-removed">3033   // until we ran out of nodes, and then declare the barrier redundant.</span>
<span class="line-removed">3034   while (stack.size() &gt; 0) {</span>
<span class="line-removed">3035     Node* n = stack.node();</span>
<span class="line-removed">3036     if (visited.member(n)) {</span>
<span class="line-removed">3037       stack.pop();</span>
<span class="line-removed">3038       continue;</span>
<span class="line-removed">3039     }</span>
<span class="line-removed">3040     visited.push(n);</span>
<span class="line-removed">3041     bool visit_users = false;</span>
<span class="line-removed">3042     switch (n-&gt;Opcode()) {</span>
<span class="line-removed">3043       case Op_CallStaticJava:</span>
<span class="line-removed">3044       case Op_CallDynamicJava:</span>
<span class="line-removed">3045       case Op_CallLeaf:</span>
<span class="line-removed">3046       case Op_CallLeafNoFP:</span>
<span class="line-removed">3047       case Op_CompareAndSwapL:</span>
<span class="line-removed">3048       case Op_CompareAndSwapI:</span>
<span class="line-removed">3049       case Op_CompareAndSwapB:</span>
<span class="line-removed">3050       case Op_CompareAndSwapS:</span>
<span class="line-removed">3051       case Op_CompareAndSwapN:</span>
<span class="line-removed">3052       case Op_CompareAndSwapP:</span>
<span class="line-removed">3053       case Op_CompareAndExchangeL:</span>
<span class="line-removed">3054       case Op_CompareAndExchangeI:</span>
<span class="line-removed">3055       case Op_CompareAndExchangeB:</span>
<span class="line-removed">3056       case Op_CompareAndExchangeS:</span>
<span class="line-removed">3057       case Op_CompareAndExchangeN:</span>
<span class="line-removed">3058       case Op_CompareAndExchangeP:</span>
<span class="line-removed">3059       case Op_WeakCompareAndSwapL:</span>
<span class="line-removed">3060       case Op_WeakCompareAndSwapI:</span>
<span class="line-removed">3061       case Op_WeakCompareAndSwapB:</span>
<span class="line-removed">3062       case Op_WeakCompareAndSwapS:</span>
<span class="line-removed">3063       case Op_WeakCompareAndSwapN:</span>
<span class="line-removed">3064       case Op_WeakCompareAndSwapP:</span>
<span class="line-removed">3065       case Op_ShenandoahCompareAndSwapN:</span>
<span class="line-removed">3066       case Op_ShenandoahCompareAndSwapP:</span>
<span class="line-removed">3067       case Op_ShenandoahWeakCompareAndSwapN:</span>
<span class="line-removed">3068       case Op_ShenandoahWeakCompareAndSwapP:</span>
<span class="line-removed">3069       case Op_ShenandoahCompareAndExchangeN:</span>
<span class="line-removed">3070       case Op_ShenandoahCompareAndExchangeP:</span>
<span class="line-removed">3071       case Op_GetAndSetL:</span>
<span class="line-removed">3072       case Op_GetAndSetI:</span>
<span class="line-removed">3073       case Op_GetAndSetB:</span>
<span class="line-removed">3074       case Op_GetAndSetS:</span>
<span class="line-removed">3075       case Op_GetAndSetP:</span>
<span class="line-removed">3076       case Op_GetAndSetN:</span>
<span class="line-removed">3077       case Op_GetAndAddL:</span>
<span class="line-removed">3078       case Op_GetAndAddI:</span>
<span class="line-removed">3079       case Op_GetAndAddB:</span>
<span class="line-removed">3080       case Op_GetAndAddS:</span>
<span class="line-removed">3081       case Op_ShenandoahEnqueueBarrier:</span>
<span class="line-removed">3082       case Op_FastLock:</span>
<span class="line-removed">3083       case Op_FastUnlock:</span>
<span class="line-removed">3084       case Op_Rethrow:</span>
<span class="line-removed">3085       case Op_Return:</span>
<span class="line-removed">3086       case Op_StoreB:</span>
<span class="line-removed">3087       case Op_StoreC:</span>
<span class="line-removed">3088       case Op_StoreD:</span>
<span class="line-removed">3089       case Op_StoreF:</span>
<span class="line-removed">3090       case Op_StoreL:</span>
<span class="line-removed">3091       case Op_StoreLConditional:</span>
<span class="line-removed">3092       case Op_StoreI:</span>
<span class="line-removed">3093       case Op_StoreIConditional:</span>
<span class="line-removed">3094       case Op_StoreN:</span>
<span class="line-removed">3095       case Op_StoreP:</span>
<span class="line-removed">3096       case Op_StoreVector:</span>
<span class="line-removed">3097       case Op_StrInflatedCopy:</span>
<span class="line-removed">3098       case Op_StrCompressedCopy:</span>
<span class="line-removed">3099       case Op_EncodeP:</span>
<span class="line-removed">3100       case Op_CastP2X:</span>
<span class="line-removed">3101       case Op_SafePoint:</span>
<span class="line-removed">3102       case Op_EncodeISOArray:</span>
<span class="line-removed">3103       case Op_AryEq:</span>
<span class="line-removed">3104       case Op_StrEquals:</span>
<span class="line-removed">3105       case Op_StrComp:</span>
<span class="line-removed">3106       case Op_StrIndexOf:</span>
<span class="line-removed">3107       case Op_StrIndexOfChar:</span>
<span class="line-removed">3108       case Op_HasNegatives:</span>
<span class="line-removed">3109         // Known to require barriers</span>
<span class="line-removed">3110         return false;</span>
<span class="line-removed">3111       case Op_CmpP: {</span>
<span class="line-removed">3112         if (n-&gt;in(1)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR) ||</span>
<span class="line-removed">3113             n-&gt;in(2)-&gt;bottom_type()-&gt;higher_equal(TypePtr::NULL_PTR)) {</span>
<span class="line-removed">3114           // One of the sides is known null, no need for barrier.</span>
<span class="line-removed">3115         } else {</span>
<span class="line-removed">3116           return false;</span>
<span class="line-removed">3117         }</span>
<span class="line-removed">3118         break;</span>
<span class="line-removed">3119       }</span>
<span class="line-removed">3120       case Op_LoadB:</span>
<span class="line-removed">3121       case Op_LoadUB:</span>
<span class="line-removed">3122       case Op_LoadUS:</span>
<span class="line-removed">3123       case Op_LoadD:</span>
<span class="line-removed">3124       case Op_LoadF:</span>
<span class="line-removed">3125       case Op_LoadL:</span>
<span class="line-removed">3126       case Op_LoadI:</span>
<span class="line-removed">3127       case Op_LoadS:</span>
<span class="line-removed">3128       case Op_LoadN:</span>
<span class="line-removed">3129       case Op_LoadP:</span>
<span class="line-removed">3130       case Op_LoadVector: {</span>
<span class="line-removed">3131         const TypePtr* adr_type = n-&gt;adr_type();</span>
<span class="line-removed">3132         int alias_idx = Compile::current()-&gt;get_alias_index(adr_type);</span>
<span class="line-removed">3133         Compile::AliasType* alias_type = Compile::current()-&gt;alias_type(alias_idx);</span>
<span class="line-removed">3134         ciField* field = alias_type-&gt;field();</span>
<span class="line-removed">3135         bool is_static = field != NULL &amp;&amp; field-&gt;is_static();</span>
<span class="line-removed">3136         bool is_final = field != NULL &amp;&amp; field-&gt;is_final();</span>
<span class="line-removed">3137 </span>
<span class="line-removed">3138         if (ShenandoahOptimizeStaticFinals &amp;&amp; is_static &amp;&amp; is_final) {</span>
<span class="line-removed">3139           // Loading the constant does not require barriers: it should be handled</span>
<span class="line-removed">3140           // as part of GC roots already.</span>
<span class="line-removed">3141         } else {</span>
<span class="line-removed">3142           return false;</span>
<span class="line-removed">3143         }</span>
<span class="line-removed">3144         break;</span>
<span class="line-removed">3145       }</span>
<span class="line-removed">3146       case Op_Conv2B:</span>
<span class="line-removed">3147       case Op_LoadRange:</span>
<span class="line-removed">3148       case Op_LoadKlass:</span>
<span class="line-removed">3149       case Op_LoadNKlass:</span>
<span class="line-removed">3150         // Do not require barriers</span>
<span class="line-removed">3151         break;</span>
<span class="line-removed">3152       case Op_AddP:</span>
<span class="line-removed">3153       case Op_CheckCastPP:</span>
<span class="line-removed">3154       case Op_CastPP:</span>
<span class="line-removed">3155       case Op_CMoveP:</span>
<span class="line-removed">3156       case Op_Phi:</span>
<span class="line-removed">3157       case Op_ShenandoahLoadReferenceBarrier:</span>
<span class="line-removed">3158         // Whether or not these need the barriers depends on their users</span>
<span class="line-removed">3159         visit_users = true;</span>
<span class="line-removed">3160         break;</span>
<span class="line-removed">3161       default: {</span>
<span class="line-removed">3162 #ifdef ASSERT</span>
<span class="line-removed">3163         fatal(&quot;Unknown node in is_redundant: %s&quot;, NodeClassNames[n-&gt;Opcode()]);</span>
<span class="line-removed">3164 #else</span>
<span class="line-removed">3165         // Default to have excess barriers, rather than miss some.</span>
<span class="line-removed">3166         return false;</span>
<span class="line-removed">3167 #endif</span>
<span class="line-removed">3168       }</span>
<span class="line-removed">3169     }</span>
<span class="line-removed">3170 </span>
<span class="line-removed">3171     stack.pop();</span>
<span class="line-removed">3172     if (visit_users) {</span>
<span class="line-removed">3173       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">3174         Node* user = n-&gt;fast_out(i);</span>
<span class="line-removed">3175         if (user != NULL) {</span>
<span class="line-removed">3176           stack.push(user, 0);</span>
<span class="line-removed">3177         }</span>
<span class="line-removed">3178       }</span>
<span class="line-removed">3179     }</span>
<span class="line-removed">3180   }</span>
<span class="line-removed">3181 </span>
<span class="line-removed">3182   // No need for barrier found.</span>
<span class="line-removed">3183   return true;</span>
<span class="line-removed">3184 }</span>
</pre>
</td>
<td>
<hr />
<pre>
 281   Node_Stack phis(0);
 282   VectorSet visited(Thread::current()-&gt;resource_area());
 283   const bool trace = false;
 284   const bool verify_no_useless_barrier = false;
 285 
 286   wq.push(root);
 287   for (uint next = 0; next &lt; wq.size(); next++) {
 288     Node *n = wq.at(next);
 289     if (n-&gt;is_Load()) {
 290       const bool trace = false;
 291       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 292       if (n-&gt;Opcode() == Op_LoadRange || n-&gt;Opcode() == Op_LoadKlass || n-&gt;Opcode() == Op_LoadNKlass) {
 293         if (trace) {tty-&gt;print_cr(&quot;Load range/klass&quot;);}
 294       } else {
 295         const TypePtr* adr_type = n-&gt;as_Load()-&gt;adr_type();
 296 
 297         if (adr_type-&gt;isa_oopptr() &amp;&amp; adr_type-&gt;is_oopptr()-&gt;offset() == oopDesc::mark_offset_in_bytes()) {
 298           if (trace) {tty-&gt;print_cr(&quot;Mark load&quot;);}
 299         } else if (adr_type-&gt;isa_instptr() &amp;&amp;
 300                    adr_type-&gt;is_instptr()-&gt;klass()-&gt;is_subtype_of(Compile::current()-&gt;env()-&gt;Reference_klass()) &amp;&amp;
<span class="line-modified"> 301                    adr_type-&gt;is_instptr()-&gt;offset() == java_lang_ref_Reference::referent_offset()) {</span>
 302           if (trace) {tty-&gt;print_cr(&quot;Reference.get()&quot;);}
 303         } else if (!verify_helper(n-&gt;in(MemNode::Address), phis, visited, ShenandoahLoad, trace, barriers_used)) {
 304           report_verify_failure(&quot;Shenandoah verification: Load should have barriers&quot;, n);
 305         }
 306       }
 307     } else if (n-&gt;is_Store()) {
 308       const bool trace = false;
 309 
 310       if (trace) {tty-&gt;print(&quot;Verifying&quot;); n-&gt;dump();}
 311       if (n-&gt;in(MemNode::ValueIn)-&gt;bottom_type()-&gt;make_oopptr()) {
 312         Node* adr = n-&gt;in(MemNode::Address);
 313         bool verify = true;
 314 
 315         if (adr-&gt;is_AddP() &amp;&amp; adr-&gt;in(AddPNode::Base)-&gt;is_top()) {
 316           adr = adr-&gt;in(AddPNode::Address);
 317           if (adr-&gt;is_AddP()) {
 318             assert(adr-&gt;in(AddPNode::Base)-&gt;is_top(), &quot;&quot;);
 319             adr = adr-&gt;in(AddPNode::Address);
 320             if (adr-&gt;Opcode() == Op_LoadP &amp;&amp;
 321                 adr-&gt;in(MemNode::Address)-&gt;in(AddPNode::Base)-&gt;is_top() &amp;&amp;
</pre>
<hr />
<pre>
1078   ShenandoahBarrierSetC2State* state = ShenandoahBarrierSetC2::bsc2()-&gt;state();
1079 
1080   Unique_Node_List uses;
1081   for (int i = 0; i &lt; state-&gt;enqueue_barriers_count(); i++) {
1082     Node* barrier = state-&gt;enqueue_barrier(i);
1083     Node* ctrl = phase-&gt;get_ctrl(barrier);
1084     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1085     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1086       // Expanding a barrier here will break loop strip mining
1087       // verification. Transform the loop so the loop nest doesn&#39;t
1088       // appear as strip mined.
1089       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1090       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1091     }
1092   }
1093 
1094   Node_Stack stack(0);
1095   Node_List clones;
1096   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1097     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);



1098 
1099     Node* ctrl = phase-&gt;get_ctrl(lrb);
1100     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1101 
1102     CallStaticJavaNode* unc = NULL;
1103     Node* unc_ctrl = NULL;
1104     Node* uncasted_val = val;
1105 
1106     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {
1107       Node* u = lrb-&gt;fast_out(i);
1108       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;
1109           u-&gt;in(0) != NULL &amp;&amp;
1110           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {
1111         const Type* u_t = phase-&gt;igvn().type(u);
1112 
1113         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;
1114             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;
1115             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1116             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;
1117             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;
</pre>
<hr />
<pre>
1267                   assert(nb &gt; 0, &quot;should have replaced some uses&quot;);
1268                 }
1269                 replaced = true;
1270               }
1271             }
1272             if (!replaced) {
1273               stack.set_index(idx+1);
1274             }
1275           }
1276         } else {
1277           stack.pop();
1278           clones.pop();
1279         }
1280       } while (stack.size() &gt; 0);
1281       assert(stack.size() == 0 &amp;&amp; clones.size() == 0, &quot;&quot;);
1282     }
1283   }
1284 
1285   for (int i = 0; i &lt; state-&gt;load_reference_barriers_count(); i++) {
1286     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);



1287     Node* ctrl = phase-&gt;get_ctrl(lrb);
1288     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1289     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1290       // Expanding a barrier here will break loop strip mining
1291       // verification. Transform the loop so the loop nest doesn&#39;t
1292       // appear as strip mined.
1293       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1294       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1295     }
1296   }
1297 
1298   // Expand load-reference-barriers
1299   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1300   Unique_Node_List uses_to_ignore;
1301   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1302     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);




1303     uint last = phase-&gt;C-&gt;unique();
1304     Node* ctrl = phase-&gt;get_ctrl(lrb);
1305     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1306 
1307 
1308     Node* orig_ctrl = ctrl;
1309 
1310     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1311     Node* init_raw_mem = raw_mem;
1312     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1313 
1314     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);
1315 
1316     Node* heap_stable_ctrl = NULL;
1317     Node* null_ctrl = NULL;
1318 
1319     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1320     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1321 
1322     enum { _heap_stable = 1, _not_cset, _evac_path, PATH_LIMIT };
</pre>
<hr />
<pre>
2995     case Op_CMoveP:
2996       return needs_barrier_impl(phase, n-&gt;in(2), visited) ||
2997              needs_barrier_impl(phase, n-&gt;in(3), visited);
2998     case Op_ShenandoahEnqueueBarrier:
2999       return needs_barrier_impl(phase, n-&gt;in(1), visited);
3000     case Op_CreateEx:
3001       return false;
3002     default:
3003       break;
3004   }
3005 #ifdef ASSERT
3006   tty-&gt;print(&quot;need barrier on?: &quot;);
3007   tty-&gt;print_cr(&quot;ins:&quot;);
3008   n-&gt;dump(2);
3009   tty-&gt;print_cr(&quot;outs:&quot;);
3010   n-&gt;dump(-2);
3011   ShouldNotReachHere();
3012 #endif
3013   return true;
3014 }
































































































































































</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../z/zBarrierSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
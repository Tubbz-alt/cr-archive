<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/objArrayOop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;prims/resolvedMethodTable.hpp&quot;
  63 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  64 #include &quot;prims/whitebox.inline.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/deoptimization.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  70 #include &quot;runtime/frame.inline.hpp&quot;
  71 #include &quot;runtime/handles.inline.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.hpp&quot;
  77 #include &quot;runtime/sweeper.hpp&quot;

  78 #include &quot;runtime/thread.hpp&quot;
  79 #include &quot;runtime/threadSMR.hpp&quot;
  80 #include &quot;runtime/vm_version.hpp&quot;
  81 #include &quot;services/memoryService.hpp&quot;
  82 #include &quot;utilities/align.hpp&quot;
  83 #include &quot;utilities/debug.hpp&quot;
  84 #include &quot;utilities/elfFile.hpp&quot;
  85 #include &quot;utilities/exceptions.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;prims/cdsoffsets.hpp&quot;
  89 #endif // INCLUDE_CDS
  90 #if INCLUDE_G1GC
  91 #include &quot;gc/g1/g1Arguments.hpp&quot;
  92 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  93 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  94 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  95 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  96 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  97 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
 462 
 463 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 464   if (UseG1GC) {
 465     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 466     size_t nr = g1h-&gt;num_free_regions();
 467     return (jlong)nr;
 468   }
 469   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 470 WB_END
 471 
 472 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 473   if (UseG1GC) {
 474     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 475     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 476   }
 477   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 478 WB_END
 479 
 480 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 481   if (UseG1GC) {






 482     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 483     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 484       g1h-&gt;collect(GCCause::_wb_conc_mark);
 485       return true;
 486     }
 487     return false;
 488   }
 489   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 490 WB_END
 491 
 492 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 493   if (UseG1GC) {
 494     return (jint)HeapRegion::GrainBytes;
 495   }
 496   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 497 WB_END
 498 
 499 #endif // INCLUDE_G1GC
 500 
 501 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
</pre>
<hr />
<pre>
1433 
1434 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1435   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1436   WhiteBox::compilation_locked = false;
1437   mo.notify_all();
1438 WB_END
1439 
1440 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1441   // Force a code cache sweep and block until it finished
1442   NMethodSweeper::force_sweep();
1443 WB_END
1444 
1445 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1446   ResourceMark rm(THREAD);
1447   int len;
1448   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1449   return (StringTable::lookup(name, len) != NULL);
1450 WB_END
1451 
1452 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))






1453   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1454   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1455 #if INCLUDE_G1GC
1456   if (UseG1GC) {
1457     // Needs to be cleared explicitly for G1
1458     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1459   }
1460 #endif // INCLUDE_G1GC
1461 WB_END
1462 
1463 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1464   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1465 WB_END
1466 
1467 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1468   // static+volatile in order to force the read to happen
1469   // (not be eliminated by the compiler)
1470   static char c;
1471   static volatile char* p;
1472 
</pre>
<hr />
<pre>
1782 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1783   // Create a special lock violating condition in value
1784   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1785                                            Mutex::_safepoint_check_always :
1786                                            Mutex::_safepoint_check_never;
1787   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1788                                            Monitor::_safepoint_check_flag :
1789                                            Monitor::_no_safepoint_check_flag;
1790 
1791   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1792   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1793   ThreadBlockInVM tbivm(JavaThread::current());
1794 WB_END
1795 
1796 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1797   oop obj_oop = JNIHandles::resolve(obj);
1798   return (jboolean) obj_oop-&gt;mark().has_monitor();
1799 WB_END
1800 
1801 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))







1802   VM_ForceSafepoint force_safepoint_op;
1803   VMThread::execute(&amp;force_safepoint_op);
1804 WB_END
1805 
1806 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1807   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1808   return (jlong) ik-&gt;constants();
1809 WB_END
1810 
1811 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1812   return ConstantPool::CPCACHE_INDEX_TAG;
1813 WB_END
1814 
1815 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1816   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1817   ConstantPool* cp = ik-&gt;constants();
1818   if (cp-&gt;cache() == NULL) {
1819       return -1;
1820   }
1821   return cp-&gt;cache()-&gt;length();
</pre>
</td>
<td>
<hr />
<pre>
  58 #include &quot;oops/objArrayOop.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/objArrayOop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;prims/resolvedMethodTable.hpp&quot;
  63 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  64 #include &quot;prims/whitebox.inline.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/atomic.hpp&quot;
  67 #include &quot;runtime/deoptimization.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  70 #include &quot;runtime/frame.inline.hpp&quot;
  71 #include &quot;runtime/handles.inline.hpp&quot;
  72 #include &quot;runtime/handshake.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/javaCalls.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/os.hpp&quot;
  77 #include &quot;runtime/sweeper.hpp&quot;
<span class="line-added">  78 #include &quot;runtime/synchronizer.hpp&quot;</span>
  79 #include &quot;runtime/thread.hpp&quot;
  80 #include &quot;runtime/threadSMR.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/memoryService.hpp&quot;
  83 #include &quot;utilities/align.hpp&quot;
  84 #include &quot;utilities/debug.hpp&quot;
  85 #include &quot;utilities/elfFile.hpp&quot;
  86 #include &quot;utilities/exceptions.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;prims/cdsoffsets.hpp&quot;
  90 #endif // INCLUDE_CDS
  91 #if INCLUDE_G1GC
  92 #include &quot;gc/g1/g1Arguments.hpp&quot;
  93 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  94 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  95 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  96 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  97 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  98 #endif // INCLUDE_G1GC
</pre>
<hr />
<pre>
 463 
 464 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 465   if (UseG1GC) {
 466     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 467     size_t nr = g1h-&gt;num_free_regions();
 468     return (jlong)nr;
 469   }
 470   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 471 WB_END
 472 
 473 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 474   if (UseG1GC) {
 475     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 476     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 477   }
 478   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 479 WB_END
 480 
 481 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 482   if (UseG1GC) {
<span class="line-added"> 483     if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added"> 484       // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added"> 485       // the equivalent is called so any special clean up can be done</span>
<span class="line-added"> 486       // at a safepoint, e.g., TestHumongousClassLoader.java.</span>
<span class="line-added"> 487       ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added"> 488     }</span>
 489     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 490     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 491       g1h-&gt;collect(GCCause::_wb_conc_mark);
 492       return true;
 493     }
 494     return false;
 495   }
 496   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 497 WB_END
 498 
 499 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 500   if (UseG1GC) {
 501     return (jint)HeapRegion::GrainBytes;
 502   }
 503   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 504 WB_END
 505 
 506 #endif // INCLUDE_G1GC
 507 
 508 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
</pre>
<hr />
<pre>
1440 
1441 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1442   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1443   WhiteBox::compilation_locked = false;
1444   mo.notify_all();
1445 WB_END
1446 
1447 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1448   // Force a code cache sweep and block until it finished
1449   NMethodSweeper::force_sweep();
1450 WB_END
1451 
1452 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1453   ResourceMark rm(THREAD);
1454   int len;
1455   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1456   return (StringTable::lookup(name, len) != NULL);
1457 WB_END
1458 
1459 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
<span class="line-added">1460   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added">1461     // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added">1462     // the equivalent is called so any special clean up can be done</span>
<span class="line-added">1463     // at a safepoint, e.g., TestHumongousClassLoader.java.</span>
<span class="line-added">1464     ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added">1465   }</span>
1466   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1467   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1468 #if INCLUDE_G1GC
1469   if (UseG1GC) {
1470     // Needs to be cleared explicitly for G1
1471     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1472   }
1473 #endif // INCLUDE_G1GC
1474 WB_END
1475 
1476 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1477   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1478 WB_END
1479 
1480 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1481   // static+volatile in order to force the read to happen
1482   // (not be eliminated by the compiler)
1483   static char c;
1484   static volatile char* p;
1485 
</pre>
<hr />
<pre>
1795 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1796   // Create a special lock violating condition in value
1797   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1798                                            Mutex::_safepoint_check_always :
1799                                            Mutex::_safepoint_check_never;
1800   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1801                                            Monitor::_safepoint_check_flag :
1802                                            Monitor::_no_safepoint_check_flag;
1803 
1804   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1805   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1806   ThreadBlockInVM tbivm(JavaThread::current());
1807 WB_END
1808 
1809 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1810   oop obj_oop = JNIHandles::resolve(obj);
1811   return (jboolean) obj_oop-&gt;mark().has_monitor();
1812 WB_END
1813 
1814 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
<span class="line-added">1815   if (AsyncDeflateIdleMonitors) {</span>
<span class="line-added">1816     // AsyncDeflateIdleMonitors needs to know when System.gc() or</span>
<span class="line-added">1817     // the equivalent is called so any special clean up can be done</span>
<span class="line-added">1818     // at a safepoint, e.g., TestRTMTotalCountIncrRate.java or</span>
<span class="line-added">1819     // TestUseRTMForStackLocks.java.</span>
<span class="line-added">1820     ObjectSynchronizer::set_is_special_deflation_requested(true);</span>
<span class="line-added">1821   }</span>
1822   VM_ForceSafepoint force_safepoint_op;
1823   VMThread::execute(&amp;force_safepoint_op);
1824 WB_END
1825 
1826 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1827   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1828   return (jlong) ik-&gt;constants();
1829 WB_END
1830 
1831 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1832   return ConstantPool::CPCACHE_INDEX_TAG;
1833 WB_END
1834 
1835 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1836   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1837   ConstantPool* cp = ik-&gt;constants();
1838   if (cp-&gt;cache() == NULL) {
1839       return -1;
1840   }
1841   return cp-&gt;cache()-&gt;length();
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
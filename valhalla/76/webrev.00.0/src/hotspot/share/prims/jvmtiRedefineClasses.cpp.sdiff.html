<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiClassFileReconstituter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 836           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 837            the_class-&gt;external_name());
 838         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 839       }
 840 
 841       // It&#39;s okay if a record component&#39;s annotations were changed.
 842     }
 843 
 844   } else if (the_record_exists ^ scr_record_exists) {
 845     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 846     log_trace(redefine, class, record)
 847       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 848        the_class-&gt;external_name(), action_str);
 849     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 850   }
 851 
 852   return JVMTI_ERROR_NONE;
 853 }
 854 
 855 



























































 856 static bool can_add_or_delete(Method* m) {
 857       // Compatibility mode
 858   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 859           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 860 }
 861 
 862 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 863              InstanceKlass* the_class,
 864              InstanceKlass* scratch_class) {
 865   int i;
 866 
 867   // Check superclasses, or rather their names, since superclasses themselves can be
 868   // requested to replace.
 869   // Check for NULL superclass first since this might be java.lang.Object
 870   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 871       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 872        the_class-&gt;super()-&gt;name() !=
 873        scratch_class-&gt;super()-&gt;name())) {
 874     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 875   }
</pre>
<hr />
<pre>
 895   }
 896 
 897   // Check whether class is in the error init state.
 898   if (the_class-&gt;is_in_error_state()) {
 899     // TBD #5057930: special error code is needed in 1.6
 900     return JVMTI_ERROR_INVALID_CLASS;
 901   }
 902 
 903   // Check whether the nest-related attributes have been changed.
 904   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 905   if (err != JVMTI_ERROR_NONE) {
 906     return err;
 907   }
 908 
 909   // Check whether the Record attribute has been changed.
 910   err = check_record_attribute(the_class, scratch_class);
 911   if (err != JVMTI_ERROR_NONE) {
 912     return err;
 913   }
 914 






 915   // Check whether class modifiers are the same.
 916   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 917   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 918   if (old_flags != new_flags) {
 919     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 920   }
 921 
 922   // Check if the number, names, types and order of fields declared in these classes
 923   // are the same.
 924   JavaFieldStream old_fs(the_class);
 925   JavaFieldStream new_fs(scratch_class);
 926   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 927     // access
 928     old_flags = old_fs.access_flags().as_short();
 929     new_flags = new_fs.access_flags().as_short();
 930     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 931       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 932     }
 933     // offset
 934     if (old_fs.offset() != new_fs.offset()) {
</pre>
<hr />
<pre>
1774   return JVMTI_ERROR_NONE;
1775 } // end merge_cp_and_rewrite()
1776 
1777 
1778 // Rewrite constant pool references in klass scratch_class.
1779 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1780        TRAPS) {
1781 
1782   // rewrite constant pool references in the nest attributes:
1783   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1784     // propagate failure back to caller
1785     return false;
1786   }
1787 
1788   // rewrite constant pool references in the Record attribute:
1789   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1790     // propagate failure back to caller
1791     return false;
1792   }
1793 






1794   // rewrite constant pool references in the methods:
1795   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1796     // propagate failure back to caller
1797     return false;
1798   }
1799 
1800   // rewrite constant pool references in the class_annotations:
1801   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1802     // propagate failure back to caller
1803     return false;
1804   }
1805 
1806   // rewrite constant pool references in the fields_annotations:
1807   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1808     // propagate failure back to caller
1809     return false;
1810   }
1811 
1812   // rewrite constant pool references in the methods_annotations:
1813   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
</pre>
<hr />
<pre>
1912           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1913           // propagate failure back to caller
1914           return false;
1915         }
1916       }
1917 
1918       AnnotationArray* type_annotations = component-&gt;type_annotations();
1919       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1920         int byte_i = 0;  // byte index into annotations
1921         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1922           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1923           // propagate failure back to caller
1924           return false;
1925         }
1926       }
1927     }
1928   }
1929   return true;
1930 }
1931 













1932 // Rewrite constant pool references in the methods.
1933 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1934        InstanceKlass* scratch_class, TRAPS) {
1935 
1936   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1937 
1938   if (methods == NULL || methods-&gt;length() == 0) {
1939     // no methods so nothing to do
1940     return true;
1941   }
1942 
1943   // rewrite constant pool references in the methods:
1944   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1945     methodHandle method(THREAD, methods-&gt;at(i));
1946     methodHandle new_method;
1947     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1948     if (!new_method.is_null()) {
1949       // the method has been replaced so save the new method version
1950       // even in the case of an exception.  original method is on the
1951       // deallocation list.
</pre>
</td>
<td>
<hr />
<pre>
 836           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 837            the_class-&gt;external_name());
 838         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 839       }
 840 
 841       // It&#39;s okay if a record component&#39;s annotations were changed.
 842     }
 843 
 844   } else if (the_record_exists ^ scr_record_exists) {
 845     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 846     log_trace(redefine, class, record)
 847       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 848        the_class-&gt;external_name(), action_str);
 849     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 850   }
 851 
 852   return JVMTI_ERROR_NONE;
 853 }
 854 
 855 
<span class="line-added"> 856 static jvmtiError check_permitted_subclasses_attribute(InstanceKlass* the_class,</span>
<span class="line-added"> 857                                                        InstanceKlass* scratch_class) {</span>
<span class="line-added"> 858   // Check whether the class PermittedSubclasses attribute has been changed.</span>
<span class="line-added"> 859   Thread* thread = Thread::current();</span>
<span class="line-added"> 860   ResourceMark rm(thread);</span>
<span class="line-added"> 861   Array&lt;u2&gt;* the_permitted_subclasses = the_class-&gt;permitted_subclasses();</span>
<span class="line-added"> 862   Array&lt;u2&gt;* scr_permitted_subclasses = scratch_class-&gt;permitted_subclasses();</span>
<span class="line-added"> 863   bool the_subclasses_exist = the_permitted_subclasses != Universe::the_empty_short_array();</span>
<span class="line-added"> 864   bool scr_subclasses_exist = scr_permitted_subclasses != Universe::the_empty_short_array();</span>
<span class="line-added"> 865   int subclasses_len = the_permitted_subclasses-&gt;length();</span>
<span class="line-added"> 866   if (the_subclasses_exist &amp;&amp; scr_subclasses_exist) {</span>
<span class="line-added"> 867     if (subclasses_len != scr_permitted_subclasses-&gt;length()) {</span>
<span class="line-added"> 868       log_trace(redefine, class, sealed)</span>
<span class="line-added"> 869         (&quot;redefined class %s attribute change error: PermittedSubclasses len=%d changed to len=%d&quot;,</span>
<span class="line-added"> 870          the_class-&gt;external_name(), subclasses_len, scr_permitted_subclasses-&gt;length());</span>
<span class="line-added"> 871       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 872     }</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874     // The order of entries in the PermittedSubclasses array is not specified so</span>
<span class="line-added"> 875     // we have to explicitly check for the same contents. We do this by copying</span>
<span class="line-added"> 876     // the referenced symbols into their own arrays, sorting them and then</span>
<span class="line-added"> 877     // comparing each element pair.</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, subclasses_len);</span>
<span class="line-added"> 880     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, subclasses_len);</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882     if (the_syms == NULL || scr_syms == NULL) {</span>
<span class="line-added"> 883       return JVMTI_ERROR_OUT_OF_MEMORY;</span>
<span class="line-added"> 884     }</span>
<span class="line-added"> 885 </span>
<span class="line-added"> 886     for (int i = 0; i &lt; subclasses_len; i++) {</span>
<span class="line-added"> 887       int the_cp_index = the_permitted_subclasses-&gt;at(i);</span>
<span class="line-added"> 888       int scr_cp_index = scr_permitted_subclasses-&gt;at(i);</span>
<span class="line-added"> 889       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);</span>
<span class="line-added"> 890       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);</span>
<span class="line-added"> 891     }</span>
<span class="line-added"> 892 </span>
<span class="line-added"> 893     qsort(the_syms, subclasses_len, sizeof(Symbol*), symcmp);</span>
<span class="line-added"> 894     qsort(scr_syms, subclasses_len, sizeof(Symbol*), symcmp);</span>
<span class="line-added"> 895 </span>
<span class="line-added"> 896     for (int i = 0; i &lt; subclasses_len; i++) {</span>
<span class="line-added"> 897       if (the_syms[i] != scr_syms[i]) {</span>
<span class="line-added"> 898         log_trace(redefine, class, sealed)</span>
<span class="line-added"> 899           (&quot;redefined class %s attribute change error: PermittedSubclasses[%d]: %s changed to %s&quot;,</span>
<span class="line-added"> 900            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());</span>
<span class="line-added"> 901         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 902       }</span>
<span class="line-added"> 903     }</span>
<span class="line-added"> 904   } else if (the_subclasses_exist ^ scr_subclasses_exist) {</span>
<span class="line-added"> 905     const char* action_str = (the_subclasses_exist) ? &quot;removed&quot; : &quot;added&quot;;</span>
<span class="line-added"> 906     log_trace(redefine, class, sealed)</span>
<span class="line-added"> 907       (&quot;redefined class %s attribute change error: PermittedSubclasses attribute %s&quot;,</span>
<span class="line-added"> 908        the_class-&gt;external_name(), action_str);</span>
<span class="line-added"> 909     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;</span>
<span class="line-added"> 910   }</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912   return JVMTI_ERROR_NONE;</span>
<span class="line-added"> 913 }</span>
<span class="line-added"> 914 </span>
 915 static bool can_add_or_delete(Method* m) {
 916       // Compatibility mode
 917   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 918           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 919 }
 920 
 921 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 922              InstanceKlass* the_class,
 923              InstanceKlass* scratch_class) {
 924   int i;
 925 
 926   // Check superclasses, or rather their names, since superclasses themselves can be
 927   // requested to replace.
 928   // Check for NULL superclass first since this might be java.lang.Object
 929   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 930       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 931        the_class-&gt;super()-&gt;name() !=
 932        scratch_class-&gt;super()-&gt;name())) {
 933     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 934   }
</pre>
<hr />
<pre>
 954   }
 955 
 956   // Check whether class is in the error init state.
 957   if (the_class-&gt;is_in_error_state()) {
 958     // TBD #5057930: special error code is needed in 1.6
 959     return JVMTI_ERROR_INVALID_CLASS;
 960   }
 961 
 962   // Check whether the nest-related attributes have been changed.
 963   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 964   if (err != JVMTI_ERROR_NONE) {
 965     return err;
 966   }
 967 
 968   // Check whether the Record attribute has been changed.
 969   err = check_record_attribute(the_class, scratch_class);
 970   if (err != JVMTI_ERROR_NONE) {
 971     return err;
 972   }
 973 
<span class="line-added"> 974   // Check whether the PermittedSubclasses attribute has been changed.</span>
<span class="line-added"> 975   err = check_permitted_subclasses_attribute(the_class, scratch_class);</span>
<span class="line-added"> 976   if (err != JVMTI_ERROR_NONE) {</span>
<span class="line-added"> 977     return err;</span>
<span class="line-added"> 978   }</span>
<span class="line-added"> 979 </span>
 980   // Check whether class modifiers are the same.
 981   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 982   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 983   if (old_flags != new_flags) {
 984     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 985   }
 986 
 987   // Check if the number, names, types and order of fields declared in these classes
 988   // are the same.
 989   JavaFieldStream old_fs(the_class);
 990   JavaFieldStream new_fs(scratch_class);
 991   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 992     // access
 993     old_flags = old_fs.access_flags().as_short();
 994     new_flags = new_fs.access_flags().as_short();
 995     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 996       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 997     }
 998     // offset
 999     if (old_fs.offset() != new_fs.offset()) {
</pre>
<hr />
<pre>
1839   return JVMTI_ERROR_NONE;
1840 } // end merge_cp_and_rewrite()
1841 
1842 
1843 // Rewrite constant pool references in klass scratch_class.
1844 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1845        TRAPS) {
1846 
1847   // rewrite constant pool references in the nest attributes:
1848   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1849     // propagate failure back to caller
1850     return false;
1851   }
1852 
1853   // rewrite constant pool references in the Record attribute:
1854   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1855     // propagate failure back to caller
1856     return false;
1857   }
1858 
<span class="line-added">1859   // rewrite constant pool references in the PermittedSubclasses attribute:</span>
<span class="line-added">1860   if (!rewrite_cp_refs_in_permitted_subclasses_attribute(scratch_class)) {</span>
<span class="line-added">1861     // propagate failure back to caller</span>
<span class="line-added">1862     return false;</span>
<span class="line-added">1863   }</span>
<span class="line-added">1864 </span>
1865   // rewrite constant pool references in the methods:
1866   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1867     // propagate failure back to caller
1868     return false;
1869   }
1870 
1871   // rewrite constant pool references in the class_annotations:
1872   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1873     // propagate failure back to caller
1874     return false;
1875   }
1876 
1877   // rewrite constant pool references in the fields_annotations:
1878   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1879     // propagate failure back to caller
1880     return false;
1881   }
1882 
1883   // rewrite constant pool references in the methods_annotations:
1884   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
</pre>
<hr />
<pre>
1983           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1984           // propagate failure back to caller
1985           return false;
1986         }
1987       }
1988 
1989       AnnotationArray* type_annotations = component-&gt;type_annotations();
1990       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1991         int byte_i = 0;  // byte index into annotations
1992         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1993           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1994           // propagate failure back to caller
1995           return false;
1996         }
1997       }
1998     }
1999   }
2000   return true;
2001 }
2002 
<span class="line-added">2003 // Rewrite constant pool references in the PermittedSubclasses attribute.</span>
<span class="line-added">2004 bool VM_RedefineClasses::rewrite_cp_refs_in_permitted_subclasses_attribute(</span>
<span class="line-added">2005        InstanceKlass* scratch_class) {</span>
<span class="line-added">2006 </span>
<span class="line-added">2007   Array&lt;u2&gt;* permitted_subclasses = scratch_class-&gt;permitted_subclasses();</span>
<span class="line-added">2008   assert(permitted_subclasses != NULL, &quot;unexpected null permitted_subclasses&quot;);</span>
<span class="line-added">2009   for (int i = 0; i &lt; permitted_subclasses-&gt;length(); i++) {</span>
<span class="line-added">2010     u2 cp_index = permitted_subclasses-&gt;at(i);</span>
<span class="line-added">2011     permitted_subclasses-&gt;at_put(i, find_new_index(cp_index));</span>
<span class="line-added">2012   }</span>
<span class="line-added">2013   return true;</span>
<span class="line-added">2014 }</span>
<span class="line-added">2015 </span>
2016 // Rewrite constant pool references in the methods.
2017 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
2018        InstanceKlass* scratch_class, TRAPS) {
2019 
2020   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
2021 
2022   if (methods == NULL || methods-&gt;length() == 0) {
2023     // no methods so nothing to do
2024     return true;
2025   }
2026 
2027   // rewrite constant pool references in the methods:
2028   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
2029     methodHandle method(THREAD, methods-&gt;at(i));
2030     methodHandle new_method;
2031     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
2032     if (!new_method.is_null()) {
2033       // the method has been replaced so save the new method version
2034       // even in the case of an exception.  original method is on the
2035       // deallocation list.
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiClassFileReconstituter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
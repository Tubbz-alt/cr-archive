<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 455   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 456 
 457     left.load_item();
 458     bool need_zero_check = true;
 459     if (right.is_constant()) {
 460       jlong c = right.get_jlong_constant();
 461       // no need to do div-by-zero check if the divisor is a non-zero constant
 462       if (c != 0) need_zero_check = false;
 463       // do not load right if the divisor is a power-of-2 constant
 464       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 465         right.dont_load_item();
 466       } else {
 467         right.load_item();
 468       }
 469     } else {
 470       right.load_item();
 471     }
 472     if (need_zero_check) {
 473       CodeEmitInfo* info = state_for(x);
 474       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 475       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));</span>
 476     }
 477 
 478     rlock_result(x);
 479     switch (x-&gt;op()) {
 480     case Bytecodes::_lrem:
 481       __ rem (left.result(), right.result(), x-&gt;operand());
 482       break;
 483     case Bytecodes::_ldiv:
 484       __ div (left.result(), right.result(), x-&gt;operand());
 485       break;
 486     default:
 487       ShouldNotReachHere();
 488       break;
 489     }
 490 
 491 
 492   } else {
 493     assert (x-&gt;op() == Bytecodes::_lmul || x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub,
 494             &quot;expect lmul, ladd or lsub&quot;);
 495     // add, sub, mul
</pre>
<hr />
<pre>
 530   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 531 
 532     rlock_result(x);
 533     bool need_zero_check = true;
 534     if (right.is_constant()) {
 535       jint c = right.get_jint_constant();
 536       // no need to do div-by-zero check if the divisor is a non-zero constant
 537       if (c != 0) need_zero_check = false;
 538       // do not load right if the divisor is a power-of-2 constant
 539       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 540         right_arg-&gt;dont_load_item();
 541       } else {
 542         right_arg-&gt;load_item();
 543       }
 544     } else {
 545       right_arg-&gt;load_item();
 546     }
 547     if (need_zero_check) {
 548       CodeEmitInfo* info = state_for(x);
 549       __ cmp(lir_cond_equal, right_arg-&gt;result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 550       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));</span>
 551     }
 552 
 553     LIR_Opr ill = LIR_OprFact::illegalOpr;
 554     if (x-&gt;op() == Bytecodes::_irem) {
 555       __ irem(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 556     } else if (x-&gt;op() == Bytecodes::_idiv) {
 557       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 558     }
 559 
 560   } else if (x-&gt;op() == Bytecodes::_iadd || x-&gt;op() == Bytecodes::_isub) {
 561     if (right.is_constant()
 562         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(right.get_jint_constant())) {
 563       right.load_nonconstant();
 564     } else {
 565       right.load_item();
 566     }
 567     rlock_result(x);
 568     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), LIR_OprFact::illegalOpr);
 569   } else {
 570     assert (x-&gt;op() == Bytecodes::_imul, &quot;expect imul&quot;);
</pre>
<hr />
<pre>
1407   }
1408 
1409   set_no_result(x);
1410 
1411   LIR_Opr left = xin-&gt;result();
1412   LIR_Opr right = yin-&gt;result();
1413 
1414   // add safepoint before generating condition code so it can be recomputed
1415   if (x-&gt;is_safepoint()) {
1416     // increment backedge counter if needed
1417     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1418         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1419     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1420   }
1421 
1422   __ cmp(lir_cond(cond), left, right);
1423   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1424   profile_branch(x, cond);
1425   move_to_phi(x-&gt;state());
1426   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1427     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());</span>
1428   } else {
<span class="line-modified">1429     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());</span>
1430   }
1431   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1432   __ jump(x-&gt;default_sux());
1433 }
1434 
1435 LIR_Opr LIRGenerator::getThreadPointer() {
1436    return FrameMap::as_pointer_opr(rthread);
1437 }
1438 
1439 void LIRGenerator::trace_block_entry(BlockBegin* block) { Unimplemented(); }
1440 
1441 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1442                                         CodeEmitInfo* info) {
1443   __ volatile_store_mem_reg(value, address, info);
1444 }
1445 
1446 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1447                                        CodeEmitInfo* info) {
1448   // 8179954: We need to make sure that the code generated for
1449   // volatile accesses forms a sequentially-consistent set of
</pre>
</td>
<td>
<hr />
<pre>
 455   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 456 
 457     left.load_item();
 458     bool need_zero_check = true;
 459     if (right.is_constant()) {
 460       jlong c = right.get_jlong_constant();
 461       // no need to do div-by-zero check if the divisor is a non-zero constant
 462       if (c != 0) need_zero_check = false;
 463       // do not load right if the divisor is a power-of-2 constant
 464       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 465         right.dont_load_item();
 466       } else {
 467         right.load_item();
 468       }
 469     } else {
 470       right.load_item();
 471     }
 472     if (need_zero_check) {
 473       CodeEmitInfo* info = state_for(x);
 474       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 475       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 476     }
 477 
 478     rlock_result(x);
 479     switch (x-&gt;op()) {
 480     case Bytecodes::_lrem:
 481       __ rem (left.result(), right.result(), x-&gt;operand());
 482       break;
 483     case Bytecodes::_ldiv:
 484       __ div (left.result(), right.result(), x-&gt;operand());
 485       break;
 486     default:
 487       ShouldNotReachHere();
 488       break;
 489     }
 490 
 491 
 492   } else {
 493     assert (x-&gt;op() == Bytecodes::_lmul || x-&gt;op() == Bytecodes::_ladd || x-&gt;op() == Bytecodes::_lsub,
 494             &quot;expect lmul, ladd or lsub&quot;);
 495     // add, sub, mul
</pre>
<hr />
<pre>
 530   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 531 
 532     rlock_result(x);
 533     bool need_zero_check = true;
 534     if (right.is_constant()) {
 535       jint c = right.get_jint_constant();
 536       // no need to do div-by-zero check if the divisor is a non-zero constant
 537       if (c != 0) need_zero_check = false;
 538       // do not load right if the divisor is a power-of-2 constant
 539       if (c &gt; 0 &amp;&amp; is_power_of_2(c)) {
 540         right_arg-&gt;dont_load_item();
 541       } else {
 542         right_arg-&gt;load_item();
 543       }
 544     } else {
 545       right_arg-&gt;load_item();
 546     }
 547     if (need_zero_check) {
 548       CodeEmitInfo* info = state_for(x);
 549       __ cmp(lir_cond_equal, right_arg-&gt;result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 550       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 551     }
 552 
 553     LIR_Opr ill = LIR_OprFact::illegalOpr;
 554     if (x-&gt;op() == Bytecodes::_irem) {
 555       __ irem(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 556     } else if (x-&gt;op() == Bytecodes::_idiv) {
 557       __ idiv(left_arg-&gt;result(), right_arg-&gt;result(), x-&gt;operand(), ill, NULL);
 558     }
 559 
 560   } else if (x-&gt;op() == Bytecodes::_iadd || x-&gt;op() == Bytecodes::_isub) {
 561     if (right.is_constant()
 562         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(right.get_jint_constant())) {
 563       right.load_nonconstant();
 564     } else {
 565       right.load_item();
 566     }
 567     rlock_result(x);
 568     arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), LIR_OprFact::illegalOpr);
 569   } else {
 570     assert (x-&gt;op() == Bytecodes::_imul, &quot;expect imul&quot;);
</pre>
<hr />
<pre>
1407   }
1408 
1409   set_no_result(x);
1410 
1411   LIR_Opr left = xin-&gt;result();
1412   LIR_Opr right = yin-&gt;result();
1413 
1414   // add safepoint before generating condition code so it can be recomputed
1415   if (x-&gt;is_safepoint()) {
1416     // increment backedge counter if needed
1417     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1418         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1419     __ safepoint(LIR_OprFact::illegalOpr, state_for(x, x-&gt;state_before()));
1420   }
1421 
1422   __ cmp(lir_cond(cond), left, right);
1423   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1424   profile_branch(x, cond);
1425   move_to_phi(x-&gt;state());
1426   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1427     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());</span>
1428   } else {
<span class="line-modified">1429     __ branch(lir_cond(cond), x-&gt;tsux());</span>
1430   }
1431   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1432   __ jump(x-&gt;default_sux());
1433 }
1434 
1435 LIR_Opr LIRGenerator::getThreadPointer() {
1436    return FrameMap::as_pointer_opr(rthread);
1437 }
1438 
1439 void LIRGenerator::trace_block_entry(BlockBegin* block) { Unimplemented(); }
1440 
1441 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1442                                         CodeEmitInfo* info) {
1443   __ volatile_store_mem_reg(value, address, info);
1444 }
1445 
1446 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1447                                        CodeEmitInfo* info) {
1448   // 8179954: We need to make sure that the code generated for
1449   // volatile accesses forms a sequentially-consistent set of
</pre>
</td>
</tr>
</table>
<center><a href="aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
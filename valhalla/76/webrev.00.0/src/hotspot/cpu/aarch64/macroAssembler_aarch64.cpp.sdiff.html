<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/signature_cc.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;
  58 #include &quot;opto/node.hpp&quot;
  59 #include &quot;opto/output.hpp&quot;
  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */
<span class="line-removed">  64 #define STOP(error) stop(error)</span>
  65 #else
  66 #define BLOCK_COMMENT(str) block_comment(str)
<span class="line-modified">  67 #define STOP(error) block_comment(error); stop(error)</span>
<span class="line-removed">  68 #endif</span>
  69 
  70 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  71 
  72 // Patch any kind of instruction; there may be several instructions.
  73 // Return the total length (in bytes) of the instructions.
  74 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  75   int instructions = 1;
  76   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  77   long offset = (target - branch) &gt;&gt; 2;
  78   unsigned insn = *(unsigned*)branch;
  79   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  80     // Load register (literal)
  81     Instruction_aarch64::spatch(branch, 23, 5, offset);
  82   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  83     // Unconditional branch (immediate)
  84     Instruction_aarch64::spatch(branch, 25, 0, offset);
  85   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  86     // Conditional branch (immediate)
  87     Instruction_aarch64::spatch(branch, 23, 5, offset);
  88   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
</pre>
<hr />
<pre>
2252   Label done, not_weak;
2253   cbz(value, done);           // Use NULL as-is.
2254 
2255   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2256   tbz(r0, 0, not_weak);    // Test for jweak tag.
2257 
2258   // Resolve jweak.
2259   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2260                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2261   verify_oop(value);
2262   b(done);
2263 
2264   bind(not_weak);
2265   // Resolve (untagged) jobject.
2266   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2267   verify_oop(value);
2268   bind(done);
2269 }
2270 
2271 void MacroAssembler::stop(const char* msg) {
<span class="line-modified">2272   address ip = pc();</span>
<span class="line-modified">2273   pusha();</span>
<span class="line-modified">2274   mov(c_rarg0, (address)msg);</span>
<span class="line-removed">2275   mov(c_rarg1, (address)ip);</span>
<span class="line-removed">2276   mov(c_rarg2, sp);</span>
<span class="line-removed">2277   mov(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));</span>
<span class="line-removed">2278   blr(c_rarg3);</span>
<span class="line-removed">2279   hlt(0);</span>
<span class="line-removed">2280 }</span>
<span class="line-removed">2281 </span>
<span class="line-removed">2282 void MacroAssembler::warn(const char* msg) {</span>
<span class="line-removed">2283   pusha();</span>
<span class="line-removed">2284   mov(c_rarg0, (address)msg);</span>
<span class="line-removed">2285   mov(lr, CAST_FROM_FN_PTR(address, warning));</span>
<span class="line-removed">2286   blr(lr);</span>
<span class="line-removed">2287   popa();</span>
2288 }
2289 
2290 void MacroAssembler::unimplemented(const char* what) {
2291   const char* buf = NULL;
2292   {
2293     ResourceMark rm;
2294     stringStream ss;
2295     ss.print(&quot;unimplemented: %s&quot;, what);
2296     buf = code_string(ss.as_string());
2297   }
2298   stop(buf);
2299 }
2300 
2301 // If a constant does not fit in an immediate field, generate some
2302 // number of MOV instructions and then perform the operation.
2303 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2304                                            add_sub_imm_insn insn1,
2305                                            add_sub_reg_insn insn2) {
2306   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2307   if (operand_valid_for_add_sub_immediate((int)imm)) {
</pre>
</td>
<td>
<hr />
<pre>
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/signature_cc.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;
  58 #include &quot;opto/node.hpp&quot;
  59 #include &quot;opto/output.hpp&quot;
  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */

  64 #else
  65 #define BLOCK_COMMENT(str) block_comment(str)
<span class="line-modified">  66 #endif</span>

  67 #define STOP(str) stop(str);
  68 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  69 
  70 // Patch any kind of instruction; there may be several instructions.
  71 // Return the total length (in bytes) of the instructions.
  72 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  73   int instructions = 1;
  74   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  75   long offset = (target - branch) &gt;&gt; 2;
  76   unsigned insn = *(unsigned*)branch;
  77   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  78     // Load register (literal)
  79     Instruction_aarch64::spatch(branch, 23, 5, offset);
  80   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  81     // Unconditional branch (immediate)
  82     Instruction_aarch64::spatch(branch, 25, 0, offset);
  83   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  84     // Conditional branch (immediate)
  85     Instruction_aarch64::spatch(branch, 23, 5, offset);
  86   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
</pre>
<hr />
<pre>
2250   Label done, not_weak;
2251   cbz(value, done);           // Use NULL as-is.
2252 
2253   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2254   tbz(r0, 0, not_weak);    // Test for jweak tag.
2255 
2256   // Resolve jweak.
2257   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2258                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2259   verify_oop(value);
2260   b(done);
2261 
2262   bind(not_weak);
2263   // Resolve (untagged) jobject.
2264   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2265   verify_oop(value);
2266   bind(done);
2267 }
2268 
2269 void MacroAssembler::stop(const char* msg) {
<span class="line-modified">2270   BLOCK_COMMENT(msg);</span>
<span class="line-modified">2271   dcps1(0xdeae);</span>
<span class="line-modified">2272   emit_int64((uintptr_t)msg);</span>













2273 }
2274 
2275 void MacroAssembler::unimplemented(const char* what) {
2276   const char* buf = NULL;
2277   {
2278     ResourceMark rm;
2279     stringStream ss;
2280     ss.print(&quot;unimplemented: %s&quot;, what);
2281     buf = code_string(ss.as_string());
2282   }
2283   stop(buf);
2284 }
2285 
2286 // If a constant does not fit in an immediate field, generate some
2287 // number of MOV instructions and then perform the operation.
2288 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2289                                            add_sub_imm_insn insn1,
2290                                            add_sub_reg_insn insn2) {
2291   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2292   if (operand_valid_for_add_sub_immediate((int)imm)) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRGenerator_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
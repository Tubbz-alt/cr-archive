<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 484     LIRItem right(x-&gt;y(), this);
 485 
 486     // the check for division by zero destroys the right operand
 487     right.set_destroys_register();
 488 
 489     BasicTypeList signature(2);
 490     signature.append(T_LONG);
 491     signature.append(T_LONG);
 492     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 493 
 494     // check for division by zero (destroys registers of right operand!)
 495     CodeEmitInfo* info = state_for(x);
 496 
 497     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 498     left.load_item_force(cc-&gt;at(1));
 499     right.load_item();
 500 
 501     __ move(right.result(), cc-&gt;at(0));
 502 
 503     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 504     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));</span>
 505 
 506     address entry = NULL;
 507     switch (x-&gt;op()) {
 508     case Bytecodes::_lrem:
 509       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 510       break; // check if dividend is 0 is done elsewhere
 511     case Bytecodes::_ldiv:
 512       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 513       break; // check if dividend is 0 is done elsewhere
 514     default:
 515       ShouldNotReachHere();
 516     }
 517 
 518     LIR_Opr result = rlock_result(x);
 519     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 520     __ move(result_reg, result);
 521   } else if (x-&gt;op() == Bytecodes::_lmul) {
 522     // missing test if instr is commutative and if we should swap
 523     LIRItem left(x-&gt;x(), this);
 524     LIRItem right(x-&gt;y(), this);
</pre>
<hr />
<pre>
 568     // call state_for before load_item_force because state_for may
 569     // force the evaluation of other instructions that are needed for
 570     // correct debug info.  Otherwise the live range of the fix
 571     // register might be too long.
 572     CodeEmitInfo* info = state_for(x);
 573 
 574     left.load_item_force(divInOpr());
 575 
 576     right.load_item();
 577 
 578     LIR_Opr result = rlock_result(x);
 579     LIR_Opr result_reg;
 580     if (x-&gt;op() == Bytecodes::_idiv) {
 581       result_reg = divOutOpr();
 582     } else {
 583       result_reg = remOutOpr();
 584     }
 585 
 586     if (!ImplicitDiv0Checks) {
 587       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
<span class="line-modified"> 588       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));</span>
 589       // Idiv/irem cannot trap (passing info would generate an assertion).
 590       info = NULL;
 591     }
 592     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 593     if (x-&gt;op() == Bytecodes::_irem) {
 594       __ irem(left.result(), right.result(), result_reg, tmp, info);
 595     } else if (x-&gt;op() == Bytecodes::_idiv) {
 596       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 597     } else {
 598       ShouldNotReachHere();
 599     }
 600 
 601     __ move(result_reg, result);
 602   } else {
 603     // missing test if instr is commutative and if we should swap
 604     LIRItem left(x-&gt;x(),  this);
 605     LIRItem right(x-&gt;y(), this);
 606     LIRItem* left_arg = &amp;left;
 607     LIRItem* right_arg = &amp;right;
 608     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
</pre>
<hr />
<pre>
1533 
1534   set_no_result(x);
1535 
1536   // add safepoint before generating condition code so it can be recomputed
1537   if (x-&gt;is_safepoint()) {
1538     // increment backedge counter if needed
1539     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1540         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1541     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1542   }
1543 
1544   if (x-&gt;substitutability_check()) {
1545     substitutability_check(x, *xin, *yin);
1546   } else {
1547     __ cmp(lir_cond(cond), left, right);
1548   }
1549   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1550   profile_branch(x, cond);
1551   move_to_phi(x-&gt;state());
1552   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1553     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());</span>
1554   } else {
<span class="line-modified">1555     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());</span>
1556   }
1557   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1558   __ jump(x-&gt;default_sux());
1559 }
1560 
1561 
1562 LIR_Opr LIRGenerator::getThreadPointer() {
1563 #ifdef _LP64
1564   return FrameMap::as_pointer_opr(r15_thread);
1565 #else
1566   LIR_Opr result = new_register(T_INT);
1567   __ get_thread(result);
1568   return result;
1569 #endif //
1570 }
1571 
1572 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1573   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1574   LIR_OprList* args = new LIR_OprList();
1575   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
</pre>
</td>
<td>
<hr />
<pre>
 484     LIRItem right(x-&gt;y(), this);
 485 
 486     // the check for division by zero destroys the right operand
 487     right.set_destroys_register();
 488 
 489     BasicTypeList signature(2);
 490     signature.append(T_LONG);
 491     signature.append(T_LONG);
 492     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 493 
 494     // check for division by zero (destroys registers of right operand!)
 495     CodeEmitInfo* info = state_for(x);
 496 
 497     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 498     left.load_item_force(cc-&gt;at(1));
 499     right.load_item();
 500 
 501     __ move(right.result(), cc-&gt;at(0));
 502 
 503     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
<span class="line-modified"> 504     __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 505 
 506     address entry = NULL;
 507     switch (x-&gt;op()) {
 508     case Bytecodes::_lrem:
 509       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 510       break; // check if dividend is 0 is done elsewhere
 511     case Bytecodes::_ldiv:
 512       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 513       break; // check if dividend is 0 is done elsewhere
 514     default:
 515       ShouldNotReachHere();
 516     }
 517 
 518     LIR_Opr result = rlock_result(x);
 519     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 520     __ move(result_reg, result);
 521   } else if (x-&gt;op() == Bytecodes::_lmul) {
 522     // missing test if instr is commutative and if we should swap
 523     LIRItem left(x-&gt;x(), this);
 524     LIRItem right(x-&gt;y(), this);
</pre>
<hr />
<pre>
 568     // call state_for before load_item_force because state_for may
 569     // force the evaluation of other instructions that are needed for
 570     // correct debug info.  Otherwise the live range of the fix
 571     // register might be too long.
 572     CodeEmitInfo* info = state_for(x);
 573 
 574     left.load_item_force(divInOpr());
 575 
 576     right.load_item();
 577 
 578     LIR_Opr result = rlock_result(x);
 579     LIR_Opr result_reg;
 580     if (x-&gt;op() == Bytecodes::_idiv) {
 581       result_reg = divOutOpr();
 582     } else {
 583       result_reg = remOutOpr();
 584     }
 585 
 586     if (!ImplicitDiv0Checks) {
 587       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
<span class="line-modified"> 588       __ branch(lir_cond_equal, new DivByZeroStub(info));</span>
 589       // Idiv/irem cannot trap (passing info would generate an assertion).
 590       info = NULL;
 591     }
 592     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 593     if (x-&gt;op() == Bytecodes::_irem) {
 594       __ irem(left.result(), right.result(), result_reg, tmp, info);
 595     } else if (x-&gt;op() == Bytecodes::_idiv) {
 596       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 597     } else {
 598       ShouldNotReachHere();
 599     }
 600 
 601     __ move(result_reg, result);
 602   } else {
 603     // missing test if instr is commutative and if we should swap
 604     LIRItem left(x-&gt;x(),  this);
 605     LIRItem right(x-&gt;y(), this);
 606     LIRItem* left_arg = &amp;left;
 607     LIRItem* right_arg = &amp;right;
 608     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
</pre>
<hr />
<pre>
1533 
1534   set_no_result(x);
1535 
1536   // add safepoint before generating condition code so it can be recomputed
1537   if (x-&gt;is_safepoint()) {
1538     // increment backedge counter if needed
1539     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1540         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1541     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1542   }
1543 
1544   if (x-&gt;substitutability_check()) {
1545     substitutability_check(x, *xin, *yin);
1546   } else {
1547     __ cmp(lir_cond(cond), left, right);
1548   }
1549   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1550   profile_branch(x, cond);
1551   move_to_phi(x-&gt;state());
1552   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
<span class="line-modified">1553     __ branch(lir_cond(cond), x-&gt;tsux(), x-&gt;usux());</span>
1554   } else {
<span class="line-modified">1555     __ branch(lir_cond(cond), x-&gt;tsux());</span>
1556   }
1557   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1558   __ jump(x-&gt;default_sux());
1559 }
1560 
1561 
1562 LIR_Opr LIRGenerator::getThreadPointer() {
1563 #ifdef _LP64
1564   return FrameMap::as_pointer_opr(r15_thread);
1565 #else
1566   LIR_Opr result = new_register(T_INT);
1567   __ get_thread(result);
1568   return result;
1569 #endif //
1570 }
1571 
1572 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1573   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1574   LIR_OprList* args = new LIR_OprList();
1575   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
</pre>
</td>
</tr>
</table>
<center><a href="c1_CodeStubs_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
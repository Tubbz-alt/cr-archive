diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Names.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,12 +23,10 @@
  * questions.
  */
 
 package com.sun.tools.javac.util;
 
-import java.util.Set;
-
 /**
  * Access to the compiler's name table.  Standard names are defined,
  * as well as methods to create new names.
  *
  *  <p><b>This is NOT part of any supported API.
@@ -165,10 +163,11 @@
     public final Name StackMap;
     public final Name StackMapTable;
     public final Name Synthetic;
     public final Name Value;
     public final Name Varargs;
+    public final Name PermittedSubclasses;
 
     // members of java.lang.annotation.ElementType
     public final Name ANNOTATION_TYPE;
     public final Name CONSTRUCTOR;
     public final Name FIELD;
@@ -213,17 +212,22 @@
     // record related
     // members of java.lang.runtime.ObjectMethods
     public final Name bootstrap;
 
     public final Name record;
+    public final Name non;
 
     // serialization members, used by records too
     public final Name serialPersistentFields;
     public final Name writeObject;
     public final Name writeReplace;
     public final Name readObjectNoData;
 
+    // sealed types
+    public final Name permits;
+    public final Name sealed;
+
     public final Name.Table table;
 
     public Names(Context context) {
         Options options = Options.instance(context);
         table = createTable(options);
@@ -345,10 +349,11 @@
         StackMap = fromString("StackMap");
         StackMapTable = fromString("StackMapTable");
         Synthetic = fromString("Synthetic");
         Value = fromString("Value");
         Varargs = fromString("Varargs");
+        PermittedSubclasses = fromString("PermittedSubclasses");
 
         // members of java.lang.annotation.ElementType
         ANNOTATION_TYPE = fromString("ANNOTATION_TYPE");
         CONSTRUCTOR = fromString("CONSTRUCTOR");
         FIELD = fromString("FIELD");
@@ -388,15 +393,20 @@
         ref = fromString("ref");
         val = fromString("val");
 
         bootstrap = fromString("bootstrap");
         record = fromString("record");
+        non = fromString("non");
 
         serialPersistentFields = fromString("serialPersistentFields");
         writeObject = fromString("writeObject");
         writeReplace = fromString("writeReplace");
         readObjectNoData = fromString("readObjectNoData");
+
+        // sealed types
+        permits = fromString("permits");
+        sealed = fromString("sealed");
     }
 
     protected Name.Table createTable(Options options) {
         boolean useUnsharedTable = options.isSet("useUnsharedTable");
         if (useUnsharedTable)

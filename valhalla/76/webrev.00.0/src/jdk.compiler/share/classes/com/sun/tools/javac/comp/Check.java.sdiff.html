<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
 160         deferredLintHandler = DeferredLintHandler.instance(context);
 161 
 162         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 163                 Feature.RECORDS.allowedInSource(source);


 164     }
 165 
 166     /** Character for synthetic names
 167      */
 168     char syntheticNameChar;
 169 
 170     /** A table mapping flat names of all compiled classes for each module in this run
 171      *  to their symbols; maintained from outside.
 172      */
 173     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 174 
 175     /** A handler for messages about deprecated usage.
 176      */
 177     private MandatoryWarningHandler deprecationHandler;
 178 
 179     /** A handler for messages about deprecated-for-removal usage.
 180      */
 181     private MandatoryWarningHandler removalHandler;
 182 
 183     /** A handler for messages about unchecked or unsafe usage.
 184      */
 185     private MandatoryWarningHandler uncheckedHandler;
 186 
 187     /** A handler for messages about using proprietary API.
 188      */
 189     private MandatoryWarningHandler sunApiHandler;
 190 
 191     /** A handler for deferred lint warnings.
 192      */
 193     private DeferredLintHandler deferredLintHandler;
 194 
 195     /** Are records allowed
 196      */
 197     private final boolean allowRecords;
 198 




 199 /* *************************************************************************
 200  * Errors and Warnings
 201  **************************************************************************/
 202 
 203     Lint setLint(Lint newLint) {
 204         Lint prev = lint;
 205         lint = newLint;
 206         return prev;
 207     }
 208 
 209     MethodSymbol setMethod(MethodSymbol newMethod) {
 210         MethodSymbol prev = method;
 211         method = newMethod;
 212         return prev;
 213     }
 214 
 215     /** Warn about deprecated symbol.
 216      *  @param pos        Position to be used for error reporting.
 217      *  @param sym        The deprecated symbol.
 218      */
</pre>
<hr />
<pre>
1365                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1366             }
1367             // Imply STRICTFP if owner has STRICTFP set.
1368             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1369                 ((flags) &amp; Flags.DEFAULT) != 0)
1370                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1371             break;
1372         case TYP:
1373             if (sym.isLocal()) {
1374                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1375                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1376                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1377                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1378                 implicit = implicitlyStatic ? STATIC : implicit;
1379                 if (staticOrImplicitlyStatic) {
1380                     if (sym.owner.kind == TYP) {
1381                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1382                     }
1383                 }
1384             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1385                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;</span>
1386                 if (sym.owner.owner.kind == PCK ||
1387                     (sym.owner.flags_field &amp; STATIC) != 0)
1388                     mask |= STATIC;
1389                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1390                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1391                 }
1392                 // Nested interfaces and enums are always STATIC (Spec ???)
1393                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1394             } else {
<span class="line-modified">1395                 mask = ClassFlags;</span>
1396             }
1397             // Interfaces are always ABSTRACT
1398             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1399 
1400             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1401                 // enums can&#39;t be declared abstract or final or value type</span>
<span class="line-modified">1402                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);</span>
1403                 implicit |= implicitEnumFinalFlag(tree);
1404             }
1405             if ((flags &amp; RECORD) != 0) {
1406                 // records can&#39;t be declared abstract
1407                 mask &amp;= ~ABSTRACT;
1408                 implicit |= FINAL;
1409             }
1410             // Imply STRICTFP if owner has STRICTFP set.
1411             implicit |= sym.owner.flags_field &amp; STRICTFP;
1412             break;
1413         default:
1414             throw new AssertionError();
1415         }
1416         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1417         if (illegal != 0) {
1418             if ((illegal &amp; INTERFACE) != 0) {
1419                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1420                 mask |= INTERFACE;
1421             }
1422             else {
</pre>
<hr />
<pre>
1437                  &amp;&amp;
1438                  checkDisjoint(pos, flags,
1439                                ABSTRACT | INTERFACE,
1440                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1441                  &amp;&amp;
1442                  checkDisjoint(pos, flags,
1443                                PUBLIC,
1444                                PRIVATE | PROTECTED)
1445                  &amp;&amp;
1446                  checkDisjoint(pos, flags,
1447                                PRIVATE,
1448                                PUBLIC | PROTECTED)
1449                  &amp;&amp;
1450                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.
1451                                FINAL,
1452                                VOLATILE)
1453                  &amp;&amp;
1454                  (sym.kind == TYP ||
1455                   checkDisjoint(pos, flags,
1456                                 ABSTRACT | NATIVE,
<span class="line-modified">1457                                 STRICTFP))) {</span>






1458             // skip
1459         }
1460         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1461     }
1462 
1463 
1464     /** Determine if this enum should be implicitly final.
1465      *
1466      *  If the enum has no specialized enum constants, it is final.
1467      *
1468      *  If the enum does have specialized enum constants, it is
1469      *  &lt;i&gt;not&lt;/i&gt; final.
1470      */
1471     private long implicitEnumFinalFlag(JCTree tree) {
1472         if (!tree.hasTag(CLASSDEF)) return 0;
1473         class SpecialTreeVisitor extends JCTree.Visitor {
1474             boolean specialized;
1475             SpecialTreeVisitor() {
1476                 this.specialized = false;
1477             }
1478 
1479             @Override
1480             public void visitTree(JCTree tree) { /* no-op */ }
1481 
1482             @Override
1483             public void visitVarDef(JCVariableDecl tree) {
1484                 if ((tree.mods.flags &amp; ENUM) != 0) {
1485                     if (tree.init instanceof JCNewClass &amp;&amp;
1486                         ((JCNewClass) tree.init).def != null) {
1487                         specialized = true;
1488                     }
1489                 }
1490             }
1491         }
1492 
1493         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1494         JCClassDecl cdef = (JCClassDecl) tree;
1495         for (JCTree defs: cdef.defs) {
1496             defs.accept(sts);
<span class="line-modified">1497             if (sts.specialized) return 0;</span>
1498         }
1499         return FINAL;
1500     }
1501 
1502 /* *************************************************************************
1503  * Type Validation
1504  **************************************************************************/
1505 
1506     /** Validate a type expression. That is,
1507      *  check that all type arguments of a parametric type are within
1508      *  their bounds. This must be done in a second phase after type attribution
1509      *  since a class might have a subclass as type parameter bound. E.g:
1510      *
1511      *  &lt;pre&gt;{@code
1512      *  class B&lt;A extends C&gt; { ... }
1513      *  class C extends B&lt;C&gt; { ... }
1514      *  }&lt;/pre&gt;
1515      *
1516      *  and we can&#39;t make sure that the bound is already attributed because
1517      *  of possible cycles.
</pre>
</td>
<td>
<hr />
<pre>
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
 160         deferredLintHandler = DeferredLintHandler.instance(context);
 161 
 162         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 163                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 164         allowSealed = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 165                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 166     }
 167 
 168     /** Character for synthetic names
 169      */
 170     char syntheticNameChar;
 171 
 172     /** A table mapping flat names of all compiled classes for each module in this run
 173      *  to their symbols; maintained from outside.
 174      */
 175     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 176 
 177     /** A handler for messages about deprecated usage.
 178      */
 179     private MandatoryWarningHandler deprecationHandler;
 180 
 181     /** A handler for messages about deprecated-for-removal usage.
 182      */
 183     private MandatoryWarningHandler removalHandler;
 184 
 185     /** A handler for messages about unchecked or unsafe usage.
 186      */
 187     private MandatoryWarningHandler uncheckedHandler;
 188 
 189     /** A handler for messages about using proprietary API.
 190      */
 191     private MandatoryWarningHandler sunApiHandler;
 192 
 193     /** A handler for deferred lint warnings.
 194      */
 195     private DeferredLintHandler deferredLintHandler;
 196 
 197     /** Are records allowed
 198      */
 199     private final boolean allowRecords;
 200 
<span class="line-added"> 201     /** Are sealed classes allowed</span>
<span class="line-added"> 202      */</span>
<span class="line-added"> 203     private final boolean allowSealed;</span>
<span class="line-added"> 204 </span>
 205 /* *************************************************************************
 206  * Errors and Warnings
 207  **************************************************************************/
 208 
 209     Lint setLint(Lint newLint) {
 210         Lint prev = lint;
 211         lint = newLint;
 212         return prev;
 213     }
 214 
 215     MethodSymbol setMethod(MethodSymbol newMethod) {
 216         MethodSymbol prev = method;
 217         method = newMethod;
 218         return prev;
 219     }
 220 
 221     /** Warn about deprecated symbol.
 222      *  @param pos        Position to be used for error reporting.
 223      *  @param sym        The deprecated symbol.
 224      */
</pre>
<hr />
<pre>
1371                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1372             }
1373             // Imply STRICTFP if owner has STRICTFP set.
1374             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1375                 ((flags) &amp; Flags.DEFAULT) != 0)
1376                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1377             break;
1378         case TYP:
1379             if (sym.isLocal()) {
1380                 boolean implicitlyStatic = !sym.isAnonymous() &amp;&amp;
1381                         ((flags &amp; RECORD) != 0 || (flags &amp; ENUM) != 0 || (flags &amp; INTERFACE) != 0);
1382                 boolean staticOrImplicitlyStatic = (flags &amp; STATIC) != 0 || implicitlyStatic;
1383                 mask = staticOrImplicitlyStatic &amp;&amp; allowRecords ? StaticLocalFlags : LocalClassFlags;
1384                 implicit = implicitlyStatic ? STATIC : implicit;
1385                 if (staticOrImplicitlyStatic) {
1386                     if (sym.owner.kind == TYP) {
1387                         log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1388                     }
1389                 }
1390             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1391                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : ExtendedMemberClassFlags;</span>
1392                 if (sym.owner.owner.kind == PCK ||
1393                     (sym.owner.flags_field &amp; STATIC) != 0)
1394                     mask |= STATIC;
1395                 else if ((flags &amp; ENUM) != 0 || (flags &amp; RECORD) != 0) {
1396                     log.error(pos, Errors.StaticDeclarationNotAllowedInInnerClasses);
1397                 }
1398                 // Nested interfaces and enums are always STATIC (Spec ???)
1399                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1400             } else {
<span class="line-modified">1401                 mask = ExtendedClassFlags;</span>
1402             }
1403             // Interfaces are always ABSTRACT
1404             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1405 
1406             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1407                 // enums can&#39;t be declared abstract, final, sealed or non-sealed or value type</span>
<span class="line-modified">1408                 mask &amp;= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE);</span>
1409                 implicit |= implicitEnumFinalFlag(tree);
1410             }
1411             if ((flags &amp; RECORD) != 0) {
1412                 // records can&#39;t be declared abstract
1413                 mask &amp;= ~ABSTRACT;
1414                 implicit |= FINAL;
1415             }
1416             // Imply STRICTFP if owner has STRICTFP set.
1417             implicit |= sym.owner.flags_field &amp; STRICTFP;
1418             break;
1419         default:
1420             throw new AssertionError();
1421         }
1422         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1423         if (illegal != 0) {
1424             if ((illegal &amp; INTERFACE) != 0) {
1425                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1426                 mask |= INTERFACE;
1427             }
1428             else {
</pre>
<hr />
<pre>
1443                  &amp;&amp;
1444                  checkDisjoint(pos, flags,
1445                                ABSTRACT | INTERFACE,
1446                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1447                  &amp;&amp;
1448                  checkDisjoint(pos, flags,
1449                                PUBLIC,
1450                                PRIVATE | PROTECTED)
1451                  &amp;&amp;
1452                  checkDisjoint(pos, flags,
1453                                PRIVATE,
1454                                PUBLIC | PROTECTED)
1455                  &amp;&amp;
1456                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.
1457                                FINAL,
1458                                VOLATILE)
1459                  &amp;&amp;
1460                  (sym.kind == TYP ||
1461                   checkDisjoint(pos, flags,
1462                                 ABSTRACT | NATIVE,
<span class="line-modified">1463                                 STRICTFP))</span>
<span class="line-added">1464                  &amp;&amp; checkDisjoint(pos, flags,</span>
<span class="line-added">1465                                 FINAL,</span>
<span class="line-added">1466                            SEALED | NON_SEALED)</span>
<span class="line-added">1467                  &amp;&amp; checkDisjoint(pos, flags,</span>
<span class="line-added">1468                                 SEALED,</span>
<span class="line-added">1469                            FINAL | NON_SEALED)) {</span>
1470             // skip
1471         }
1472         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1473     }
1474 
1475 
1476     /** Determine if this enum should be implicitly final.
1477      *
1478      *  If the enum has no specialized enum constants, it is final.
1479      *
1480      *  If the enum does have specialized enum constants, it is
1481      *  &lt;i&gt;not&lt;/i&gt; final.
1482      */
1483     private long implicitEnumFinalFlag(JCTree tree) {
1484         if (!tree.hasTag(CLASSDEF)) return 0;
1485         class SpecialTreeVisitor extends JCTree.Visitor {
1486             boolean specialized;
1487             SpecialTreeVisitor() {
1488                 this.specialized = false;
1489             }
1490 
1491             @Override
1492             public void visitTree(JCTree tree) { /* no-op */ }
1493 
1494             @Override
1495             public void visitVarDef(JCVariableDecl tree) {
1496                 if ((tree.mods.flags &amp; ENUM) != 0) {
1497                     if (tree.init instanceof JCNewClass &amp;&amp;
1498                         ((JCNewClass) tree.init).def != null) {
1499                         specialized = true;
1500                     }
1501                 }
1502             }
1503         }
1504 
1505         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1506         JCClassDecl cdef = (JCClassDecl) tree;
1507         for (JCTree defs: cdef.defs) {
1508             defs.accept(sts);
<span class="line-modified">1509             if (sts.specialized) return allowSealed ? SEALED : 0;</span>
1510         }
1511         return FINAL;
1512     }
1513 
1514 /* *************************************************************************
1515  * Type Validation
1516  **************************************************************************/
1517 
1518     /** Validate a type expression. That is,
1519      *  check that all type arguments of a parametric type are within
1520      *  their bounds. This must be done in a second phase after type attribution
1521      *  since a class might have a subclass as type parameter bound. E.g:
1522      *
1523      *  &lt;pre&gt;{@code
1524      *  class B&lt;A extends C&gt; { ... }
1525      *  class C extends B&lt;C&gt; { ... }
1526      *  }&lt;/pre&gt;
1527      *
1528      *  and we can&#39;t make sure that the bound is already attributed because
1529      *  of possible cycles.
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
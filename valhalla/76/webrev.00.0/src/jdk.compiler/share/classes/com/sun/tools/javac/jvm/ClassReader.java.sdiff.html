<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 




 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /** Switch: Should javac recongnize and handle value based classes specially ?
 125      */
 126     private boolean allowValueBasedClasses;
 127 
 128     /**
 129      * The currently selected profile.
 130      */
 131     public final Profile profile;
</pre>
<hr />
<pre>
 262         names = Names.instance(context);
 263         syms = Symtab.instance(context);
 264         types = Types.instance(context);
 265         fileManager = context.get(JavaFileManager.class);
 266         if (fileManager == null)
 267             throw new AssertionError(&quot;FileManager initialization error&quot;);
 268         diagFactory = JCDiagnostic.Factory.instance(context);
 269         dcfh = DeferredCompletionFailureHandler.instance(context);
 270 
 271         log = Log.instance(context);
 272 
 273         Options options = Options.instance(context);
 274         verbose         = options.isSet(Option.VERBOSE);
 275 
 276         Source source = Source.instance(context);
 277         preview = Preview.instance(context);
 278         allowModules     = Feature.MODULES.allowedInSource(source);
 279         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 280         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 281                 Feature.RECORDS.allowedInSource(source);


 282 
 283         saveParameterNames = options.isSet(PARAMETERS);
 284         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 285 
 286         profile = Profile.instance(context);
 287 
 288         typevars = WriteableScope.create(syms.noSymbol);
 289 
 290         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 291 
 292         initAttributeReaders();
 293     }
 294 
 295     /** Add member to class unless it is synthetic.
 296      */
 297     private void enterMember(ClassSymbol c, Symbol sym) {
 298         // Synthetic members are not entered -- reason lost to history (optimization?).
 299         // Lambda methods must be entered because they may have inner classes (which reference them)
 300         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 301             c.members_field.enter(sym);
</pre>
<hr />
<pre>
1207                 }
1208                 protected void read(Symbol sym, int attrLen) {
1209                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1210                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1211                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1212                     }
1213                 }
1214             },
1215 
1216             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1217                 @Override
1218                 protected boolean accepts(AttributeKind kind) {
1219                     return super.accepts(kind) &amp;&amp; allowRecords;
1220                 }
1221                 protected void read(Symbol sym, int attrLen) {
1222                     if (sym.kind == TYP) {
1223                         sym.flags_field |= RECORD;
1224                     }
1225                     bp = bp + attrLen;
1226                 }
<span class="line-modified">1227             }</span>
















1228         };
1229 
1230         for (AttributeReader r: readers)
1231             attributeReaders.put(r.name, r);
1232     }
1233 
1234     protected void readEnclosingMethodAttr(Symbol sym) {
1235         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1236         // remove sym from it&#39;s current owners scope and place it in
1237         // the scope specified by the attribute
1238         sym.owner.members().remove(sym);
1239         ClassSymbol self = (ClassSymbol)sym;
1240         ClassSymbol c = poolReader.getClass(nextChar());
1241         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1242 
1243         if (c.members_field == null || c.kind != TYP)
1244             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1245 
1246         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1247         if (nt != null &amp;&amp; m == null)
</pre>
<hr />
<pre>
2484                         Integer.toString(minorVersion));
2485             }
2486             c.flags_field = flags;
2487             currentModule = (ModuleSymbol) c.owner;
2488             int this_class = nextChar();
2489             // temp, no check on this_class
2490         }
2491 
2492         // class attributes must be read before class
2493         // skip ahead to read class attributes
2494         int startbp = bp;
2495         nextChar();
2496         char interfaceCount = nextChar();
2497         bp += interfaceCount * 2;
2498         char fieldCount = nextChar();
2499         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2500         char methodCount = nextChar();
2501         for (int i = 0; i &lt; methodCount; i++) skipMember();
2502         readClassAttrs(c);
2503 




2504         // reset and read rest of classinfo
2505         bp = startbp;
2506         int n = nextChar();
2507         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2508             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2509         }
2510         if (ct.supertype_field == null)
2511             ct.supertype_field =
2512                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2513         n = nextChar();
2514         List&lt;Type&gt; is = List.nil();
2515         for (int i = 0; i &lt; n; i++) {
2516             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2517             is = is.prepend(_inter);
2518         }
2519         if (ct.interfaces_field == null)
2520             ct.interfaces_field = is.reverse();
2521 
2522         Assert.check(fieldCount == nextChar());
2523         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow inline types.
 109      */
 110     boolean allowInlineTypes;
 111 
<span class="line-added"> 112     /** Switch: allow sealed</span>
<span class="line-added"> 113      */</span>
<span class="line-added"> 114     boolean allowSealedTypes;</span>
<span class="line-added"> 115 </span>
 116     /** Switch: allow records
 117      */
 118     boolean allowRecords;
 119 
 120    /** Lint option: warn about classfile issues
 121      */
 122     boolean lintClassfile;
 123 
 124     /** Switch: preserve parameter names from the variable table.
 125      */
 126     public boolean saveParameterNames;
 127 
 128     /** Switch: Should javac recongnize and handle value based classes specially ?
 129      */
 130     private boolean allowValueBasedClasses;
 131 
 132     /**
 133      * The currently selected profile.
 134      */
 135     public final Profile profile;
</pre>
<hr />
<pre>
 266         names = Names.instance(context);
 267         syms = Symtab.instance(context);
 268         types = Types.instance(context);
 269         fileManager = context.get(JavaFileManager.class);
 270         if (fileManager == null)
 271             throw new AssertionError(&quot;FileManager initialization error&quot;);
 272         diagFactory = JCDiagnostic.Factory.instance(context);
 273         dcfh = DeferredCompletionFailureHandler.instance(context);
 274 
 275         log = Log.instance(context);
 276 
 277         Options options = Options.instance(context);
 278         verbose         = options.isSet(Option.VERBOSE);
 279 
 280         Source source = Source.instance(context);
 281         preview = Preview.instance(context);
 282         allowModules     = Feature.MODULES.allowedInSource(source);
 283         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);
 284         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 285                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 286         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 287                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 288 
 289         saveParameterNames = options.isSet(PARAMETERS);
 290         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 291 
 292         profile = Profile.instance(context);
 293 
 294         typevars = WriteableScope.create(syms.noSymbol);
 295 
 296         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 297 
 298         initAttributeReaders();
 299     }
 300 
 301     /** Add member to class unless it is synthetic.
 302      */
 303     private void enterMember(ClassSymbol c, Symbol sym) {
 304         // Synthetic members are not entered -- reason lost to history (optimization?).
 305         // Lambda methods must be entered because they may have inner classes (which reference them)
 306         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 307             c.members_field.enter(sym);
</pre>
<hr />
<pre>
1213                 }
1214                 protected void read(Symbol sym, int attrLen) {
1215                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1216                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1217                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1218                     }
1219                 }
1220             },
1221 
1222             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1223                 @Override
1224                 protected boolean accepts(AttributeKind kind) {
1225                     return super.accepts(kind) &amp;&amp; allowRecords;
1226                 }
1227                 protected void read(Symbol sym, int attrLen) {
1228                     if (sym.kind == TYP) {
1229                         sym.flags_field |= RECORD;
1230                     }
1231                     bp = bp + attrLen;
1232                 }
<span class="line-modified">1233             },</span>
<span class="line-added">1234             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {</span>
<span class="line-added">1235                 @Override</span>
<span class="line-added">1236                 protected boolean accepts(AttributeKind kind) {</span>
<span class="line-added">1237                     return super.accepts(kind) &amp;&amp; allowSealedTypes;</span>
<span class="line-added">1238                 }</span>
<span class="line-added">1239                 protected void read(Symbol sym, int attrLen) {</span>
<span class="line-added">1240                     if (sym.kind == TYP) {</span>
<span class="line-added">1241                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();</span>
<span class="line-added">1242                         int numberOfPermittedSubtypes = nextChar();</span>
<span class="line-added">1243                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {</span>
<span class="line-added">1244                             subtypes.add(poolReader.getClass(nextChar()));</span>
<span class="line-added">1245                         }</span>
<span class="line-added">1246                         ((ClassSymbol)sym).permitted = subtypes.toList();</span>
<span class="line-added">1247                     }</span>
<span class="line-added">1248                 }</span>
<span class="line-added">1249             },</span>
1250         };
1251 
1252         for (AttributeReader r: readers)
1253             attributeReaders.put(r.name, r);
1254     }
1255 
1256     protected void readEnclosingMethodAttr(Symbol sym) {
1257         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1258         // remove sym from it&#39;s current owners scope and place it in
1259         // the scope specified by the attribute
1260         sym.owner.members().remove(sym);
1261         ClassSymbol self = (ClassSymbol)sym;
1262         ClassSymbol c = poolReader.getClass(nextChar());
1263         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1264 
1265         if (c.members_field == null || c.kind != TYP)
1266             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1267 
1268         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1269         if (nt != null &amp;&amp; m == null)
</pre>
<hr />
<pre>
2506                         Integer.toString(minorVersion));
2507             }
2508             c.flags_field = flags;
2509             currentModule = (ModuleSymbol) c.owner;
2510             int this_class = nextChar();
2511             // temp, no check on this_class
2512         }
2513 
2514         // class attributes must be read before class
2515         // skip ahead to read class attributes
2516         int startbp = bp;
2517         nextChar();
2518         char interfaceCount = nextChar();
2519         bp += interfaceCount * 2;
2520         char fieldCount = nextChar();
2521         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2522         char methodCount = nextChar();
2523         for (int i = 0; i &lt; methodCount; i++) skipMember();
2524         readClassAttrs(c);
2525 
<span class="line-added">2526         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {</span>
<span class="line-added">2527             c.flags_field |= SEALED;</span>
<span class="line-added">2528         }</span>
<span class="line-added">2529 </span>
2530         // reset and read rest of classinfo
2531         bp = startbp;
2532         int n = nextChar();
2533         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2534             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2535         }
2536         if (ct.supertype_field == null)
2537             ct.supertype_field =
2538                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2539         n = nextChar();
2540         List&lt;Type&gt; is = List.nil();
2541         for (int i = 0; i &lt; n; i++) {
2542             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2543             is = is.prepend(_inter);
2544         }
2545         if (ct.interfaces_field == null)
2546             ct.interfaces_field = is.reverse();
2547 
2548         Assert.check(fieldCount == nextChar());
2549         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
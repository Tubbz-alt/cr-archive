<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
5164         Type st = types.supertype(c.type);
5165         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5166             // First, attribute superclass.
5167             if (st.hasTag(CLASS))
5168                 attribClass((ClassSymbol)st.tsym);
5169 
5170             // Next attribute owner, if it is a class.
5171             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5172                 attribClass((ClassSymbol)c.owner);
5173         }
5174 
5175         // The previous operations might have attributed the current class
5176         // if there was a cycle. So we test first whether the class is still
5177         // UNATTRIBUTED.
5178         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5179             c.flags_field &amp;= ~UNATTRIBUTED;
5180 
5181             // Get environment current at the point of class definition.
5182             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5183 




















































































5184             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5185             // because the annotations were not available at the time the env was created. Therefore,
5186             // we look up the environment chain for the first enclosing environment for which the
5187             // lint value is set. Typically, this is the parent env, but might be further if there
5188             // are any envs created as a result of TypeParameter nodes.
5189             Env&lt;AttrContext&gt; lintEnv = env;
5190             while (lintEnv.info.lint == null)
5191                 lintEnv = lintEnv.next;
5192 
5193             // Having found the enclosing lint value, we can initialize the lint value for this class
5194             env.info.lint = lintEnv.info.lint.augment(c);
5195 
5196             Lint prevLint = chk.setLint(env.info.lint);
5197             JavaFileObject prev = log.useSource(c.sourcefile);
5198             ResultInfo prevReturnRes = env.info.returnResult;
5199 
5200             try {
5201                 deferredLintHandler.flush(env.tree);
5202                 env.info.returnResult = null;
5203                 // java.lang.Enum may not be subclassed by a non-enum
</pre>
</td>
<td>
<hr />
<pre>
5164         Type st = types.supertype(c.type);
5165         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5166             // First, attribute superclass.
5167             if (st.hasTag(CLASS))
5168                 attribClass((ClassSymbol)st.tsym);
5169 
5170             // Next attribute owner, if it is a class.
5171             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5172                 attribClass((ClassSymbol)c.owner);
5173         }
5174 
5175         // The previous operations might have attributed the current class
5176         // if there was a cycle. So we test first whether the class is still
5177         // UNATTRIBUTED.
5178         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5179             c.flags_field &amp;= ~UNATTRIBUTED;
5180 
5181             // Get environment current at the point of class definition.
5182             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5183 
<span class="line-added">5184             if (c.isSealed() &amp;&amp;</span>
<span class="line-added">5185                     !c.isEnum() &amp;&amp;</span>
<span class="line-added">5186                     !c.isPermittedExplicit &amp;&amp;</span>
<span class="line-added">5187                     c.permitted.isEmpty()) {</span>
<span class="line-added">5188                 log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);</span>
<span class="line-added">5189             }</span>
<span class="line-added">5190 </span>
<span class="line-added">5191             if (c.isSealed()) {</span>
<span class="line-added">5192                 Set&lt;Symbol&gt; permittedTypes = new HashSet&lt;&gt;();</span>
<span class="line-added">5193                 boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;</span>
<span class="line-added">5194                 for (Symbol subTypeSym : c.permitted) {</span>
<span class="line-added">5195                     boolean isTypeVar = false;</span>
<span class="line-added">5196                     if (subTypeSym.type.getTag() == TYPEVAR) {</span>
<span class="line-added">5197                         isTypeVar = true; //error recovery</span>
<span class="line-added">5198                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),</span>
<span class="line-added">5199                                 Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));</span>
<span class="line-added">5200                     }</span>
<span class="line-added">5201                     if (subTypeSym.isAnonymous() &amp;&amp; !c.isEnum()) {</span>
<span class="line-added">5202                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5203                     }</span>
<span class="line-added">5204                     if (permittedTypes.contains(subTypeSym)) {</span>
<span class="line-added">5205                         DiagnosticPosition pos =</span>
<span class="line-added">5206                                 env.enclClass.permitting.stream()</span>
<span class="line-added">5207                                         .filter(permittedExpr -&gt; TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)</span>
<span class="line-added">5208                                         .limit(2).collect(List.collector()).get(1);</span>
<span class="line-added">5209                         log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));</span>
<span class="line-added">5210                     } else {</span>
<span class="line-added">5211                         permittedTypes.add(subTypeSym);</span>
<span class="line-added">5212                     }</span>
<span class="line-added">5213                     if (sealedInUnnamed) {</span>
<span class="line-added">5214                         if (subTypeSym.packge() != c.packge()) {</span>
<span class="line-added">5215                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5216                         }</span>
<span class="line-added">5217                     } else if (subTypeSym.packge().modle != c.packge().modle) {</span>
<span class="line-added">5218                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));</span>
<span class="line-added">5219                     }</span>
<span class="line-added">5220                     if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {</span>
<span class="line-added">5221                         log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),</span>
<span class="line-added">5222                                 Errors.InvalidPermitsClause(</span>
<span class="line-added">5223                                         subTypeSym == c.type.tsym ?</span>
<span class="line-added">5224                                                 Fragments.MustNotBeSameClass :</span>
<span class="line-added">5225                                                 Fragments.MustNotBeSupertype(subTypeSym.type)</span>
<span class="line-added">5226                                 )</span>
<span class="line-added">5227                         );</span>
<span class="line-added">5228                     } else if (!isTypeVar) {</span>
<span class="line-added">5229                         boolean thisIsASuper = types.directSupertypes(subTypeSym.type)</span>
<span class="line-added">5230                                                     .stream()</span>
<span class="line-added">5231                                                     .anyMatch(d -&gt; d.tsym == c);</span>
<span class="line-added">5232                         if (!thisIsASuper) {</span>
<span class="line-added">5233                             log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),</span>
<span class="line-added">5234                                     Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));</span>
<span class="line-added">5235                         }</span>
<span class="line-added">5236                     }</span>
<span class="line-added">5237                 }</span>
<span class="line-added">5238             }</span>
<span class="line-added">5239 </span>
<span class="line-added">5240             List&lt;ClassSymbol&gt; sealedSupers = types.directSupertypes(c.type)</span>
<span class="line-added">5241                                                   .stream()</span>
<span class="line-added">5242                                                   .filter(s -&gt; s.tsym.isSealed())</span>
<span class="line-added">5243                                                   .map(s -&gt; (ClassSymbol) s.tsym)</span>
<span class="line-added">5244                                                   .collect(List.collector());</span>
<span class="line-added">5245 </span>
<span class="line-added">5246             if (sealedSupers.isEmpty()) {</span>
<span class="line-added">5247                 if ((c.flags_field &amp; Flags.NON_SEALED) != 0) {</span>
<span class="line-added">5248                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));</span>
<span class="line-added">5249                 }</span>
<span class="line-added">5250             } else {</span>
<span class="line-added">5251                 if (c.isLocal() &amp;&amp; !c.isEnum()) {</span>
<span class="line-added">5252                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);</span>
<span class="line-added">5253                 }</span>
<span class="line-added">5254 </span>
<span class="line-added">5255                 for (ClassSymbol supertypeSym : sealedSupers) {</span>
<span class="line-added">5256                     if (!supertypeSym.permitted.contains(c.type.tsym)) {</span>
<span class="line-added">5257                         log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));</span>
<span class="line-added">5258                     }</span>
<span class="line-added">5259                 }</span>
<span class="line-added">5260                 if (!c.isNonSealed() &amp;&amp; !c.isFinal() &amp;&amp; !c.isSealed()) {</span>
<span class="line-added">5261                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree),</span>
<span class="line-added">5262                             c.isInterface() ?</span>
<span class="line-added">5263                                     Errors.NonSealedOrSealedExpected :</span>
<span class="line-added">5264                                     Errors.NonSealedSealedOrFinalExpected);</span>
<span class="line-added">5265                 }</span>
<span class="line-added">5266             }</span>
<span class="line-added">5267 </span>
5268             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5269             // because the annotations were not available at the time the env was created. Therefore,
5270             // we look up the environment chain for the first enclosing environment for which the
5271             // lint value is set. Typically, this is the parent env, but might be further if there
5272             // are any envs created as a result of TypeParameter nodes.
5273             Env&lt;AttrContext&gt; lintEnv = env;
5274             while (lintEnv.info.lint == null)
5275                 lintEnv = lintEnv.next;
5276 
5277             // Having found the enclosing lint value, we can initialize the lint value for this class
5278             env.info.lint = lintEnv.info.lint.augment(c);
5279 
5280             Lint prevLint = chk.setLint(env.info.lint);
5281             JavaFileObject prev = log.useSource(c.sourcefile);
5282             ResultInfo prevReturnRes = env.info.returnResult;
5283 
5284             try {
5285                 deferredLintHandler.flush(env.tree);
5286                 env.info.returnResult = null;
5287                 // java.lang.Enum may not be subclassed by a non-enum
</pre>
</td>
</tr>
</table>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jvm/ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);


 193     }
 194 
 195     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 196         return  keepEndPositions
 197                 ? new SimpleEndPosTable(this)
 198                 : new EmptyEndPosTable(this);
 199     }
 200 
 201     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 202         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 203     }
 204 
 205     /** Switch: should we fold strings?
 206      */
 207     boolean allowStringFolding;
 208 
 209     /** Switch: should we allow withField operator at source level ?
 210     */
 211     boolean allowWithFieldOperator;
 212 
</pre>
<hr />
<pre>
 214      */
 215     boolean keepDocComments;
 216 
 217     /** Switch: should we keep line table?
 218      */
 219     boolean keepLineMap;
 220 
 221     /** Switch: is &quot;this&quot; allowed as an identifier?
 222      * This is needed to parse receiver types.
 223      */
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 




 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed
 244      */
 245     protected static final int EXPR = 0x1;
 246     protected static final int TYPE = 0x2;
 247     protected static final int NOPARAMS = 0x4;
 248     protected static final int TYPEARG = 0x8;
 249     protected static final int DIAMOND = 0x10;
 250     protected static final int NOLAMBDA = 0x20;
 251 
 252     protected void selectExprMode() {
 253         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
2687                             lookahead++;
2688                         }
2689                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2690                         break;
2691                     case SEMI: //error recovery - this is not a valid statement:
2692                         isYieldStatement = true;
2693                         break;
2694                     default:
2695                         isYieldStatement = false;
2696                         break;
2697                 }
2698 
2699                 if (isYieldStatement) {
2700                     nextToken();
2701                     JCExpression t = term(EXPR);
2702                     accept(SEMI);
2703                     return List.of(toP(F.at(pos).Yield(t)));
2704                 }
2705 
2706                 //else intentional fall-through













2707             }
2708         }
2709         if (isRecordStart() &amp;&amp; allowRecords) {
2710             dc = token.comment(CommentStyle.JAVADOC);
2711             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2712         } else {
2713             Token prevToken = token;
2714             JCExpression t = term(EXPR | TYPE);
2715             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2716                 nextToken();
2717                 JCStatement stat = parseStatementAsBlock();
2718                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2719             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2720                 pos = token.pos;
2721                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2722                 F.at(pos);
2723                 return localVariableDeclarations(mods, t);
2724             } else {
2725                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2726                 t = checkExprStat(t);
</pre>
<hr />
<pre>
3141     loop:
3142         while (true) {
3143             long flag;
3144             token = recastToken(token);
3145             switch (token.kind) {
3146             case PRIVATE     : flag = Flags.PRIVATE; break;
3147             case PROTECTED   : flag = Flags.PROTECTED; break;
3148             case PUBLIC      : flag = Flags.PUBLIC; break;
3149             case STATIC      : flag = Flags.STATIC; break;
3150             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3151             case FINAL       : flag = Flags.FINAL; break;
3152             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3153             case NATIVE      : flag = Flags.NATIVE; break;
3154             case VALUE       : flag = Flags.VALUE; break;
3155             case VOLATILE    : flag = Flags.VOLATILE; break;
3156             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3157             case STRICTFP    : flag = Flags.STRICTFP; break;
3158             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3159             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3160             case ERROR       : flag = 0; nextToken(); break;














3161             default: break loop;
3162             }
3163             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3164             lastPos = token.pos;
3165             nextToken();
3166             if (flag == Flags.ANNOTATION) {
3167                 if (token.kind != INTERFACE) {
3168                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3169                     // if first modifier is an annotation, set pos to annotation&#39;s.
3170                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3171                         pos = ann.pos;
3172                     final Name name = TreeInfo.name(ann.annotationType);
3173                     if (name == names.__inline__ || name == names.java_lang___inline__) {
3174                         flag = Flags.VALUE;
3175                     } else {
3176                         annotations.append(ann);
3177                         flag = 0;
3178                     }
3179                 }
3180             }
</pre>
<hr />
<pre>
3435             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3436                 return Source.JDK10;
3437             } else if (shouldWarn) {
3438                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3439             }
3440         }
3441         if (name == names.yield) {
3442             if (allowYieldStatement) {
3443                 return Source.JDK14;
3444             } else if (shouldWarn) {
3445                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3446             }
3447         }
3448         if (name == names.record) {
3449             if (allowRecords) {
3450                 return Source.JDK14;
3451             } else if (shouldWarn) {
3452                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3453             }
3454         }







3455         return null;
3456     }
3457 
3458     /** VariableDeclaratorId = Ident BracketsOpt
3459      */
3460     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3461         return variableDeclaratorId(mods, type, false);
3462     }
3463     //where
3464     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3465         int pos = token.pos;
3466         Name name;
3467         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3468             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3469             name = token.name();
3470             nextToken();
3471         } else {
3472             if (allowThisIdent ||
3473                 !lambdaParameter ||
3474                 LAX_IDENTIFIER.accepts(token.kind) ||
</pre>
<hr />
<pre>
3829      *  @param mods    The modifiers starting the class declaration
3830      *  @param dc       The documentation comment for the class, or null.
3831      */
3832     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3833         int pos = token.pos;
3834         accept(CLASS);
3835         Name name = typeName();
3836 
3837         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3838 
3839         JCExpression extending = null;
3840         if (token.kind == EXTENDS) {
3841             nextToken();
3842             extending = parseType();
3843         }
3844         List&lt;JCExpression&gt; implementing = List.nil();
3845         if (token.kind == IMPLEMENTS) {
3846             nextToken();
3847             implementing = typeList();
3848         }









3849         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3850         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3851             mods, name, typarams, extending, implementing, defs));</span>
3852         attach(result, dc);
3853         return result;
3854     }
3855 
3856     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3857         int pos = token.pos;
3858         nextToken();
3859         mods.flags |= Flags.RECORD;
3860         Name name = typeName();
3861 
3862         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3863 
3864         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3865 
3866         List&lt;JCExpression&gt; implementing = List.nil();
3867         if (token.kind == IMPLEMENTS) {
3868             nextToken();
3869             implementing = typeList();
3870         }
3871         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
</pre>
<hr />
<pre>
3908     }
3909 
3910     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3911      *                         [EXTENDS TypeList] InterfaceBody
3912      *  @param mods    The modifiers starting the interface declaration
3913      *  @param dc       The documentation comment for the interface, or null.
3914      */
3915     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3916         int pos = token.pos;
3917         accept(INTERFACE);
3918 
3919         Name name = typeName();
3920 
3921         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3922 
3923         List&lt;JCExpression&gt; extending = List.nil();
3924         if (token.kind == EXTENDS) {
3925             nextToken();
3926             extending = typeList();
3927         }
<span class="line-modified">3928         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);</span>










3929         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3930             mods, name, typarams, null, extending, defs));</span>
3931         attach(result, dc);
3932         return result;
3933     }
3934 
3935     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3936      *  @param mods    The modifiers starting the enum declaration
3937      *  @param dc       The documentation comment for the enum, or null.
3938      */
3939     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3940         int pos = token.pos;
3941         accept(ENUM);
3942 
3943         Name name = typeName();
3944 
3945         List&lt;JCExpression&gt; implementing = List.nil();
3946         if (token.kind == IMPLEMENTS) {
3947             nextToken();
3948             implementing = typeList();
3949         }
3950 
</pre>
<hr />
<pre>
4256                     } else {
4257                         pos = token.pos;
4258                         List&lt;JCTree&gt; err;
4259                         if (isVoid || typarams.nonEmpty()) {
4260                             JCMethodDecl m =
4261                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4262                                                             List.nil(), List.nil(), null, null));
4263                             attach(m, dc);
4264                             err = List.of(m);
4265                         } else {
4266                             err = List.nil();
4267                         }
4268                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4269                     }
4270                 }
4271             }
4272         }
4273     }
4274 
4275     protected boolean isRecordStart() {
<span class="line-modified">4276      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4277             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4278              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4279              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<span class="line-modified">4280           checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4281           return true;</span>
<span class="line-modified">4282     } else {</span>
<span class="line-modified">4283        return false;</span>
<span class="line-modified">4284    }</span>
<span class="line-modified">4285 }</span>














































4286 
4287     /** MethodDeclaratorRest =
4288      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4289      *  VoidMethodDeclaratorRest =
4290      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4291      *  ConstructorDeclaratorRest =
4292      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4293      */
4294     protected JCTree methodDeclaratorRest(int pos,
4295                               JCModifiers mods,
4296                               JCExpression type,
4297                               Name name,
4298                               List&lt;JCTypeParameter&gt; typarams,
4299                               boolean isInterface, boolean isVoid,
4300                               boolean isRecord,
4301                               Comment dc) {
4302         if (isInterface) {
4303             if ((mods.flags &amp; Flags.STATIC) != 0) {
4304                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4305             }
</pre>
</td>
<td>
<hr />
<pre>
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
<span class="line-added"> 193         this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 194                 Feature.SEALED_CLASSES.allowedInSource(source);</span>
 195     }
 196 
 197     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 198         return  keepEndPositions
 199                 ? new SimpleEndPosTable(this)
 200                 : new EmptyEndPosTable(this);
 201     }
 202 
 203     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 204         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 205     }
 206 
 207     /** Switch: should we fold strings?
 208      */
 209     boolean allowStringFolding;
 210 
 211     /** Switch: should we allow withField operator at source level ?
 212     */
 213     boolean allowWithFieldOperator;
 214 
</pre>
<hr />
<pre>
 216      */
 217     boolean keepDocComments;
 218 
 219     /** Switch: should we keep line table?
 220      */
 221     boolean keepLineMap;
 222 
 223     /** Switch: is &quot;this&quot; allowed as an identifier?
 224      * This is needed to parse receiver types.
 225      */
 226     boolean allowThisIdent;
 227 
 228     /** Switch: is yield statement allowed in this source level?
 229      */
 230     boolean allowYieldStatement;
 231 
 232     /** Switch: are records allowed in this source level?
 233      */
 234     boolean allowRecords;
 235 
<span class="line-added"> 236     /** Switch: are sealed types allowed in this source level?</span>
<span class="line-added"> 237      */</span>
<span class="line-added"> 238     boolean allowSealedTypes;</span>
<span class="line-added"> 239 </span>
 240     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 241      */
 242     JCVariableDecl receiverParam;
 243 
 244     /** When terms are parsed, the mode determines which is expected:
 245      *     mode = EXPR        : an expression
 246      *     mode = TYPE        : a type
 247      *     mode = NOPARAMS    : no parameters allowed for type
 248      *     mode = TYPEARG     : type argument
 249      *     mode |= NOLAMBDA   : lambdas are not allowed
 250      */
 251     protected static final int EXPR = 0x1;
 252     protected static final int TYPE = 0x2;
 253     protected static final int NOPARAMS = 0x4;
 254     protected static final int TYPEARG = 0x8;
 255     protected static final int DIAMOND = 0x10;
 256     protected static final int NOLAMBDA = 0x20;
 257 
 258     protected void selectExprMode() {
 259         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
2693                             lookahead++;
2694                         }
2695                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2696                         break;
2697                     case SEMI: //error recovery - this is not a valid statement:
2698                         isYieldStatement = true;
2699                         break;
2700                     default:
2701                         isYieldStatement = false;
2702                         break;
2703                 }
2704 
2705                 if (isYieldStatement) {
2706                     nextToken();
2707                     JCExpression t = term(EXPR);
2708                     accept(SEMI);
2709                     return List.of(toP(F.at(pos).Yield(t)));
2710                 }
2711 
2712                 //else intentional fall-through
<span class="line-added">2713             } else {</span>
<span class="line-added">2714                 if (isNonSealedClassStart(true)) {</span>
<span class="line-added">2715                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2716                     nextToken();</span>
<span class="line-added">2717                     nextToken();</span>
<span class="line-added">2718                     nextToken();</span>
<span class="line-added">2719                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2720                 } else if (isSealedClassStart(true)) {</span>
<span class="line-added">2721                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">2722                     log.error(token.pos, Errors.SealedOrNonSealedLocalClassesNotAllowed);</span>
<span class="line-added">2723                     nextToken();</span>
<span class="line-added">2724                     return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));</span>
<span class="line-added">2725                 }</span>
2726             }
2727         }
2728         if (isRecordStart() &amp;&amp; allowRecords) {
2729             dc = token.comment(CommentStyle.JAVADOC);
2730             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2731         } else {
2732             Token prevToken = token;
2733             JCExpression t = term(EXPR | TYPE);
2734             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2735                 nextToken();
2736                 JCStatement stat = parseStatementAsBlock();
2737                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2738             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2739                 pos = token.pos;
2740                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2741                 F.at(pos);
2742                 return localVariableDeclarations(mods, t);
2743             } else {
2744                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2745                 t = checkExprStat(t);
</pre>
<hr />
<pre>
3160     loop:
3161         while (true) {
3162             long flag;
3163             token = recastToken(token);
3164             switch (token.kind) {
3165             case PRIVATE     : flag = Flags.PRIVATE; break;
3166             case PROTECTED   : flag = Flags.PROTECTED; break;
3167             case PUBLIC      : flag = Flags.PUBLIC; break;
3168             case STATIC      : flag = Flags.STATIC; break;
3169             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3170             case FINAL       : flag = Flags.FINAL; break;
3171             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3172             case NATIVE      : flag = Flags.NATIVE; break;
3173             case VALUE       : flag = Flags.VALUE; break;
3174             case VOLATILE    : flag = Flags.VOLATILE; break;
3175             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3176             case STRICTFP    : flag = Flags.STRICTFP; break;
3177             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3178             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3179             case ERROR       : flag = 0; nextToken(); break;
<span class="line-added">3180             case IDENTIFIER  : {</span>
<span class="line-added">3181                 if (isNonSealedClassStart(false)) {</span>
<span class="line-added">3182                     flag = Flags.NON_SEALED;</span>
<span class="line-added">3183                     nextToken();</span>
<span class="line-added">3184                     nextToken();</span>
<span class="line-added">3185                     break;</span>
<span class="line-added">3186                 }</span>
<span class="line-added">3187                 if (isSealedClassStart(false)) {</span>
<span class="line-added">3188                     checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3189                     flag = Flags.SEALED;</span>
<span class="line-added">3190                     break;</span>
<span class="line-added">3191                 }</span>
<span class="line-added">3192                 break loop;</span>
<span class="line-added">3193             }</span>
3194             default: break loop;
3195             }
3196             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3197             lastPos = token.pos;
3198             nextToken();
3199             if (flag == Flags.ANNOTATION) {
3200                 if (token.kind != INTERFACE) {
3201                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3202                     // if first modifier is an annotation, set pos to annotation&#39;s.
3203                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3204                         pos = ann.pos;
3205                     final Name name = TreeInfo.name(ann.annotationType);
3206                     if (name == names.__inline__ || name == names.java_lang___inline__) {
3207                         flag = Flags.VALUE;
3208                     } else {
3209                         annotations.append(ann);
3210                         flag = 0;
3211                     }
3212                 }
3213             }
</pre>
<hr />
<pre>
3468             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3469                 return Source.JDK10;
3470             } else if (shouldWarn) {
3471                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3472             }
3473         }
3474         if (name == names.yield) {
3475             if (allowYieldStatement) {
3476                 return Source.JDK14;
3477             } else if (shouldWarn) {
3478                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3479             }
3480         }
3481         if (name == names.record) {
3482             if (allowRecords) {
3483                 return Source.JDK14;
3484             } else if (shouldWarn) {
3485                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3486             }
3487         }
<span class="line-added">3488         if (name == names.sealed) {</span>
<span class="line-added">3489             if (allowSealedTypes) {</span>
<span class="line-added">3490                 return Source.JDK15;</span>
<span class="line-added">3491             } else if (shouldWarn) {</span>
<span class="line-added">3492                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK15));</span>
<span class="line-added">3493             }</span>
<span class="line-added">3494         }</span>
3495         return null;
3496     }
3497 
3498     /** VariableDeclaratorId = Ident BracketsOpt
3499      */
3500     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3501         return variableDeclaratorId(mods, type, false);
3502     }
3503     //where
3504     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3505         int pos = token.pos;
3506         Name name;
3507         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3508             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3509             name = token.name();
3510             nextToken();
3511         } else {
3512             if (allowThisIdent ||
3513                 !lambdaParameter ||
3514                 LAX_IDENTIFIER.accepts(token.kind) ||
</pre>
<hr />
<pre>
3869      *  @param mods    The modifiers starting the class declaration
3870      *  @param dc       The documentation comment for the class, or null.
3871      */
3872     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3873         int pos = token.pos;
3874         accept(CLASS);
3875         Name name = typeName();
3876 
3877         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3878 
3879         JCExpression extending = null;
3880         if (token.kind == EXTENDS) {
3881             nextToken();
3882             extending = parseType();
3883         }
3884         List&lt;JCExpression&gt; implementing = List.nil();
3885         if (token.kind == IMPLEMENTS) {
3886             nextToken();
3887             implementing = typeList();
3888         }
<span class="line-added">3889         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3890         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3891             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3892             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3893                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;class&quot;)));</span>
<span class="line-added">3894             }</span>
<span class="line-added">3895             nextToken();</span>
<span class="line-added">3896             permitting = qualidentList(false);</span>
<span class="line-added">3897         }</span>
3898         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3899         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3900             mods, name, typarams, extending, implementing, permitting, defs));</span>
3901         attach(result, dc);
3902         return result;
3903     }
3904 
3905     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3906         int pos = token.pos;
3907         nextToken();
3908         mods.flags |= Flags.RECORD;
3909         Name name = typeName();
3910 
3911         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3912 
3913         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3914 
3915         List&lt;JCExpression&gt; implementing = List.nil();
3916         if (token.kind == IMPLEMENTS) {
3917             nextToken();
3918             implementing = typeList();
3919         }
3920         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
</pre>
<hr />
<pre>
3957     }
3958 
3959     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3960      *                         [EXTENDS TypeList] InterfaceBody
3961      *  @param mods    The modifiers starting the interface declaration
3962      *  @param dc       The documentation comment for the interface, or null.
3963      */
3964     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3965         int pos = token.pos;
3966         accept(INTERFACE);
3967 
3968         Name name = typeName();
3969 
3970         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3971 
3972         List&lt;JCExpression&gt; extending = List.nil();
3973         if (token.kind == EXTENDS) {
3974             nextToken();
3975             extending = typeList();
3976         }
<span class="line-modified">3977         List&lt;JCExpression&gt; permitting = List.nil();</span>
<span class="line-added">3978         if (allowSealedTypes &amp;&amp; token.kind == IDENTIFIER &amp;&amp; token.name() == names.permits) {</span>
<span class="line-added">3979             checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">3980             if ((mods.flags &amp; Flags.SEALED) == 0) {</span>
<span class="line-added">3981                 log.error(token.pos, Errors.InvalidPermitsClause(Fragments.ClassIsNotSealed(&quot;interface&quot;)));</span>
<span class="line-added">3982             }</span>
<span class="line-added">3983             nextToken();</span>
<span class="line-added">3984             permitting = typeList();</span>
<span class="line-added">3985         }</span>
<span class="line-added">3986         List&lt;JCTree&gt; defs;</span>
<span class="line-added">3987         defs = classInterfaceOrRecordBody(name, true, false);</span>
3988         JCClassDecl result = toP(F.at(pos).ClassDef(
<span class="line-modified">3989             mods, name, typarams, null, extending, permitting, defs));</span>
3990         attach(result, dc);
3991         return result;
3992     }
3993 
3994     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3995      *  @param mods    The modifiers starting the enum declaration
3996      *  @param dc       The documentation comment for the enum, or null.
3997      */
3998     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3999         int pos = token.pos;
4000         accept(ENUM);
4001 
4002         Name name = typeName();
4003 
4004         List&lt;JCExpression&gt; implementing = List.nil();
4005         if (token.kind == IMPLEMENTS) {
4006             nextToken();
4007             implementing = typeList();
4008         }
4009 
</pre>
<hr />
<pre>
4315                     } else {
4316                         pos = token.pos;
4317                         List&lt;JCTree&gt; err;
4318                         if (isVoid || typarams.nonEmpty()) {
4319                             JCMethodDecl m =
4320                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4321                                                             List.nil(), List.nil(), null, null));
4322                             attach(m, dc);
4323                             err = List.of(m);
4324                         } else {
4325                             err = List.nil();
4326                         }
4327                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4328                     }
4329                 }
4330             }
4331         }
4332     }
4333 
4334     protected boolean isRecordStart() {
<span class="line-modified">4335         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4336             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4337              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4338              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<span class="line-modified">4339              checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4340             return true;</span>
<span class="line-modified">4341         } else {</span>
<span class="line-modified">4342             return false;</span>
<span class="line-modified">4343         }</span>
<span class="line-modified">4344     }</span>
<span class="line-added">4345 </span>
<span class="line-added">4346     protected boolean isNonSealedClassStart(boolean local) {</span>
<span class="line-added">4347         if (isNonSealedIdentifier(token, 0)) {</span>
<span class="line-added">4348             Token next = S.token(3);</span>
<span class="line-added">4349             return allowedAfterSealedOrNonSealed(next, local, true);</span>
<span class="line-added">4350         }</span>
<span class="line-added">4351         return false;</span>
<span class="line-added">4352     }</span>
<span class="line-added">4353 </span>
<span class="line-added">4354     protected boolean isNonSealedIdentifier(Token someToken, int lookAheadOffset) {</span>
<span class="line-added">4355         if (someToken.name() == names.non &amp;&amp; peekToken(lookAheadOffset, TokenKind.SUB, TokenKind.IDENTIFIER)) {</span>
<span class="line-added">4356             Token tokenSub = S.token(lookAheadOffset + 1);</span>
<span class="line-added">4357             Token tokenSealed = S.token(lookAheadOffset + 2);</span>
<span class="line-added">4358             if (someToken.endPos == tokenSub.pos &amp;&amp;</span>
<span class="line-added">4359                     tokenSub.endPos == tokenSealed.pos &amp;&amp;</span>
<span class="line-added">4360                     tokenSealed.name() == names.sealed) {</span>
<span class="line-added">4361                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4362                 return true;</span>
<span class="line-added">4363             }</span>
<span class="line-added">4364         }</span>
<span class="line-added">4365         return false;</span>
<span class="line-added">4366     }</span>
<span class="line-added">4367 </span>
<span class="line-added">4368     protected boolean isSealedClassStart(boolean local) {</span>
<span class="line-added">4369         if (token.name() == names.sealed) {</span>
<span class="line-added">4370             Token next = S.token(1);</span>
<span class="line-added">4371             if (allowedAfterSealedOrNonSealed(next, local, false)) {</span>
<span class="line-added">4372                 checkSourceLevel(Feature.SEALED_CLASSES);</span>
<span class="line-added">4373                 return true;</span>
<span class="line-added">4374             }</span>
<span class="line-added">4375         }</span>
<span class="line-added">4376         return false;</span>
<span class="line-added">4377     }</span>
<span class="line-added">4378 </span>
<span class="line-added">4379     private boolean allowedAfterSealedOrNonSealed(Token next, boolean local, boolean currentIsNonSealed) {</span>
<span class="line-added">4380         return local ?</span>
<span class="line-added">4381             switch (next.kind) {</span>
<span class="line-added">4382                 case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4383                 default -&gt; false;</span>
<span class="line-added">4384             } :</span>
<span class="line-added">4385             switch (next.kind) {</span>
<span class="line-added">4386                 case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -&gt; true;</span>
<span class="line-added">4387                 case IDENTIFIER -&gt; isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;</span>
<span class="line-added">4388                 default -&gt; false;</span>
<span class="line-added">4389             };</span>
<span class="line-added">4390     }</span>
4391 
4392     /** MethodDeclaratorRest =
4393      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4394      *  VoidMethodDeclaratorRest =
4395      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4396      *  ConstructorDeclaratorRest =
4397      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4398      */
4399     protected JCTree methodDeclaratorRest(int pos,
4400                               JCModifiers mods,
4401                               JCExpression type,
4402                               Name name,
4403                               List&lt;JCTypeParameter&gt; typarams,
4404                               boolean isInterface, boolean isVoid,
4405                               boolean isRecord,
4406                               Comment dc) {
4407         if (isInterface) {
4408             if ((mods.flags &amp; Flags.STATIC) != 0) {
4409                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4410             }
</pre>
</td>
</tr>
</table>
<center><a href="../jvm/ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
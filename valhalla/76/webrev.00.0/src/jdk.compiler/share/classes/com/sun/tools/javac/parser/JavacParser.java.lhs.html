<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Flags.Flag;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.parser.Tokens.*;
  40 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 import com.sun.tools.javac.util.*;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.List;
  51 
  52 import static com.sun.tools.javac.code.Flags.asFlagSet;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  59 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  60 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  61 import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  64 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  65 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  66 
  67 /** The parser maps a token sequence into an abstract syntax
  68  *  tree. It operates by recursive descent, with code derived
  69  *  systematically from an LL(1) grammar. For efficiency reasons, an
  70  *  operator precedence scheme is used for parsing binary operation
  71  *  expressions.
  72  *
  73  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  74  *  If you write code that depends on this, you do so at your own risk.
  75  *  This code and its internal interfaces are subject to change or
  76  *  deletion without notice.&lt;/b&gt;
  77  */
  78 public class JavacParser implements Parser {
  79 
  80     /** The number of precedence levels of infix operators.
  81      */
  82     private static final int infixPrecedenceLevels = 10;
  83 
  84     /** Is the parser instantiated to parse a module-info file ?
  85      */
  86     private final boolean parseModuleInfo;
  87 
  88     /** The scanner used for lexical analysis.
  89      */
  90     protected Lexer S;
  91 
  92     /** The factory to be used for abstract syntax tree construction.
  93      */
  94     protected TreeMaker F;
  95 
  96     /** The log to be used for error diagnostics.
  97      */
  98     private Log log;
  99 
 100     /** The Source language setting. */
 101     private Source source;
 102 
 103     /** The Preview language setting. */
 104     private Preview preview;
 105 
 106     /** The name table. */
 107     private Names names;
 108 
 109     /** End position mappings container */
 110     protected final AbstractEndPosTable endPosTable;
 111 
 112     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 113     // the presence of type annotations even though they are not ambiguous
 114     // in the absence of type annotations.  Consider this code:
 115     //   void m(String [] m) { }
 116     //   void m(String ... m) { }
 117     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 118     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 119     // if the next token is ... and in that case parse an ellipsis.  But in
 120     // the presence of type annotations:
 121     //   void m(String @A [] m) { }
 122     //   void m(String @A ... m) { }
 123     // no finite lookahead is enough to determine whether to read array
 124     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 125     // bracketsOpt first reads all the leading annotations and only then
 126     // discovers that it needs to fail.  bracketsOpt needs a way to push
 127     // back the extra annotations that it read.  (But, bracketsOpt should
 128     // not *always* be allowed to push back extra annotations that it finds
 129     // -- in most contexts, any such extra annotation is an error.
 130     //
 131     // The following two variables permit type annotations that have
 132     // already been read to be stored for later use.  Alternate
 133     // implementations are possible but would cause much larger changes to
 134     // the parser.
 135 
 136     /** Type annotations that have already been read but have not yet been used. **/
 137     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 138 
 139     /**
 140      * If the parser notices extra annotations, then it either immediately
 141      * issues an error (if this variable is false) or places the extra
 142      * annotations in variable typeAnnotationsPushedBack (if this variable
 143      * is true).
 144      */
 145     private boolean permitTypeAnnotationsPushBack = false;
 146 
 147     interface ErrorRecoveryAction {
 148         JCTree doRecover(JavacParser parser);
 149     }
 150 
 151     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 152         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 153         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 154     }
 155 
 156     /** Construct a parser from a given scanner, tree factory and log.
 157      */
 158     protected JavacParser(ParserFactory fac,
 159                           Lexer S,
 160                           boolean keepDocComments,
 161                           boolean keepLineMap,
 162                           boolean keepEndPositions) {
 163         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 164 
 165     }
 166     /** Construct a parser from a given scanner, tree factory and log.
 167      */
 168     protected JavacParser(ParserFactory fac,
 169                      Lexer S,
 170                      boolean keepDocComments,
 171                      boolean keepLineMap,
 172                      boolean keepEndPositions,
 173                      boolean parseModuleInfo) {
 174         this.S = S;
 175         nextToken(); // prime the pump
 176         this.F = fac.F;
 177         this.log = fac.log;
 178         this.names = fac.names;
 179         this.source = fac.source;
 180         this.preview = fac.preview;
 181         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 182         this.keepDocComments = keepDocComments;
 183         this.parseModuleInfo = parseModuleInfo;
 184         docComments = newDocCommentTable(keepDocComments, fac);
 185         this.keepLineMap = keepLineMap;
 186         this.errorTree = F.Erroneous();
 187         endPosTable = newEndPosTable(keepEndPositions);
 188         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 189                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 190         this.allowWithFieldOperator = fac.options.isSet(&quot;allowWithFieldOperator&quot;);
 191         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 192                 Feature.RECORDS.allowedInSource(source);
<a name="1" id="anc1"></a>

 193     }
 194 
 195     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 196         return  keepEndPositions
 197                 ? new SimpleEndPosTable(this)
 198                 : new EmptyEndPosTable(this);
 199     }
 200 
 201     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 202         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 203     }
 204 
 205     /** Switch: should we fold strings?
 206      */
 207     boolean allowStringFolding;
 208 
 209     /** Switch: should we allow withField operator at source level ?
 210     */
 211     boolean allowWithFieldOperator;
 212 
 213     /** Switch: should we keep docComments?
 214      */
 215     boolean keepDocComments;
 216 
 217     /** Switch: should we keep line table?
 218      */
 219     boolean keepLineMap;
 220 
 221     /** Switch: is &quot;this&quot; allowed as an identifier?
 222      * This is needed to parse receiver types.
 223      */
 224     boolean allowThisIdent;
 225 
 226     /** Switch: is yield statement allowed in this source level?
 227      */
 228     boolean allowYieldStatement;
 229 
 230     /** Switch: are records allowed in this source level?
 231      */
 232     boolean allowRecords;
 233 
<a name="2" id="anc2"></a>



 234     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 235      */
 236     JCVariableDecl receiverParam;
 237 
 238     /** When terms are parsed, the mode determines which is expected:
 239      *     mode = EXPR        : an expression
 240      *     mode = TYPE        : a type
 241      *     mode = NOPARAMS    : no parameters allowed for type
 242      *     mode = TYPEARG     : type argument
 243      *     mode |= NOLAMBDA   : lambdas are not allowed
 244      */
 245     protected static final int EXPR = 0x1;
 246     protected static final int TYPE = 0x2;
 247     protected static final int NOPARAMS = 0x4;
 248     protected static final int TYPEARG = 0x8;
 249     protected static final int DIAMOND = 0x10;
 250     protected static final int NOLAMBDA = 0x20;
 251 
 252     protected void selectExprMode() {
 253         mode = (mode &amp; NOLAMBDA) | EXPR;
 254     }
 255 
 256     protected void selectTypeMode() {
 257         mode = (mode &amp; NOLAMBDA) | TYPE;
 258     }
 259 
 260     /** The current mode.
 261      */
 262     protected int mode = 0;
 263 
 264     /** The mode of the term that was parsed last.
 265      */
 266     protected int lastmode = 0;
 267 
 268     /* ---------- token management -------------- */
 269 
 270     protected Token token;
 271 
 272     public Token token() {
 273         return token;
 274     }
 275 
 276     public void nextToken() {
 277         S.nextToken();
 278         token = S.token();
 279     }
 280 
 281     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 282         return peekToken(0, tk);
 283     }
 284 
 285     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 286         return tk.accepts(S.token(lookahead + 1).kind);
 287     }
 288 
 289     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 290         return peekToken(0, tk1, tk2);
 291     }
 292 
 293     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 294         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 295                 tk2.accepts(S.token(lookahead + 2).kind);
 296     }
 297 
 298     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 299         return peekToken(0, tk1, tk2, tk3);
 300     }
 301 
 302     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 303         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 304                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 305                 tk3.accepts(S.token(lookahead + 3).kind);
 306     }
 307 
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3, Filter&lt;TokenKind&gt; tk4) {
 309         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 310                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 311                 tk3.accepts(S.token(lookahead + 3).kind) &amp;&amp;
 312                 tk4.accepts(S.token(lookahead + 4).kind);
 313     }
 314 
 315     @SuppressWarnings(&quot;unchecked&quot;)
 316     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 317         return peekToken(0, kinds);
 318     }
 319 
 320     @SuppressWarnings(&quot;unchecked&quot;)
 321     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 322         for (; lookahead &lt; kinds.length ; lookahead++) {
 323             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
 329 
 330     /* ---------- error recovery -------------- */
 331 
 332     private JCErroneous errorTree;
 333 
 334     /** Skip forward until a suitable stop token is found.
 335      */
 336     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 337          while (true) {
 338              switch (token.kind) {
 339                 case SEMI:
 340                     nextToken();
 341                     return;
 342                 case PUBLIC:
 343                 case FINAL:
 344                 case ABSTRACT:
 345                 case MONKEYS_AT:
 346                 case EOF:
 347                 case CLASS:
 348                 case INTERFACE:
 349                 case ENUM:
 350                     return;
 351                 case IMPORT:
 352                     if (stopAtImport)
 353                         return;
 354                     break;
 355                 case LBRACE:
 356                 case RBRACE:
 357                 case PRIVATE:
 358                 case PROTECTED:
 359                 case STATIC:
 360                 case TRANSIENT:
 361                 case NATIVE:
 362                 case VOLATILE:
 363                 case SYNCHRONIZED:
 364                 case STRICTFP:
 365                 case LT:
 366                 case BYTE:
 367                 case SHORT:
 368                 case CHAR:
 369                 case INT:
 370                 case LONG:
 371                 case FLOAT:
 372                 case DOUBLE:
 373                 case BOOLEAN:
 374                 case VOID:
 375                     if (stopAtMemberDecl)
 376                         return;
 377                     break;
 378                 case UNDERSCORE:
 379                 case IDENTIFIER:
 380                    if (stopAtIdentifier)
 381                         return;
 382                     break;
 383                 case CASE:
 384                 case DEFAULT:
 385                 case IF:
 386                 case FOR:
 387                 case WHILE:
 388                 case DO:
 389                 case TRY:
 390                 case SWITCH:
 391                 case RETURN:
 392                 case THROW:
 393                 case BREAK:
 394                 case CONTINUE:
 395                 case ELSE:
 396                 case FINALLY:
 397                 case CATCH:
 398                 case THIS:
 399                 case SUPER:
 400                 case NEW:
 401                     if (stopAtStatement)
 402                         return;
 403                     break;
 404                 case ASSERT:
 405                     if (stopAtStatement)
 406                         return;
 407                     break;
 408             }
 409             nextToken();
 410         }
 411     }
 412 
 413     protected JCErroneous syntaxError(int pos, Error errorKey) {
 414         return syntaxError(pos, List.nil(), errorKey);
 415     }
 416 
 417     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 418         setErrorEndPos(pos);
 419         JCErroneous err = F.at(pos).Erroneous(errs);
 420         reportSyntaxError(err, errorKey);
 421         if (errs != null) {
 422             JCTree last = errs.last();
 423             if (last != null)
 424                 storeEnd(last, pos);
 425         }
 426         return toP(err);
 427     }
 428 
 429     private static final int RECOVERY_THRESHOLD = 50;
 430     private int errorPos = Position.NOPOS;
 431     private int count = 0;
 432 
 433     /**
 434      * Report a syntax using the given the position parameter and arguments,
 435      * unless one was already reported at the same position.
 436      */
 437     protected void reportSyntaxError(int pos, Error errorKey) {
 438         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 439         reportSyntaxError(diag, errorKey);
 440     }
 441 
 442     /**
 443      * Report a syntax error using the given DiagnosticPosition object and
 444      * arguments, unless one was already reported at the same position.
 445      */
 446     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 447         int pos = diagPos.getPreferredPosition();
 448         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 449             if (token.kind == EOF) {
 450                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 451             } else {
 452                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 453             }
 454         }
 455         S.errPos(pos);
 456         if (token.pos == errorPos) {
 457             //check for a possible infinite loop in parsing:
 458             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 459         } else {
 460             count = 0;
 461             errorPos = token.pos;
 462         }
 463     }
 464 
 465     /** If next input token matches given token, skip it, otherwise report
 466      *  an error.
 467      */
 468     public void accept(TokenKind tk) {
 469         accept(tk, Errors::Expected);
 470     }
 471 
 472     /** If next input token matches given token, skip it, otherwise report
 473      *  an error.
 474      */
 475     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 476         if (token.kind == tk) {
 477             nextToken();
 478         } else {
 479             setErrorEndPos(token.pos);
 480             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 481         }
 482     }
 483 
 484     /** If next input token matches one of the two given tokens, skip it, otherwise report
 485      *  an error.
 486      *
 487      * @return The actual token kind.
 488      */
 489     public TokenKind accept2(TokenKind tk1, TokenKind tk2) {
 490         TokenKind returnValue = token.kind;
 491         if (token.kind == tk1 || token.kind == tk2) {
 492             nextToken();
 493         } else {
 494             setErrorEndPos(token.pos);
 495             reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));
 496         }
 497         return returnValue;
 498     }
 499 
 500     /** Report an illegal start of expression/type error at given position.
 501      */
 502     JCExpression illegal(int pos) {
 503         setErrorEndPos(pos);
 504         if ((mode &amp; EXPR) != 0)
 505             return syntaxError(pos, Errors.IllegalStartOfExpr);
 506         else
 507             return syntaxError(pos, Errors.IllegalStartOfType);
 508 
 509     }
 510 
 511     /** Report an illegal start of expression/type error at current position.
 512      */
 513     JCExpression illegal() {
 514         return illegal(token.pos);
 515     }
 516 
 517     /** Diagnose a modifier flag from the set, if any. */
 518     protected void checkNoMods(long mods) {
 519         if (mods != 0) {
 520             long lowestMod = mods &amp; -mods;
 521             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 522         }
 523     }
 524 
 525 /* ---------- doc comments --------- */
 526 
 527     /** A table to store all documentation comments
 528      *  indexed by the tree nodes they refer to.
 529      *  defined only if option flag keepDocComment is set.
 530      */
 531     private final DocCommentTable docComments;
 532 
 533     /** Make an entry into docComments hashtable,
 534      *  provided flag keepDocComments is set and given doc comment is non-null.
 535      *  @param tree   The tree to be used as index in the hashtable
 536      *  @param dc     The doc comment to associate with the tree, or null.
 537      */
 538     protected void attach(JCTree tree, Comment dc) {
 539         if (keepDocComments &amp;&amp; dc != null) {
 540 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 541             docComments.putComment(tree, dc);
 542         }
 543     }
 544 
 545 /* -------- source positions ------- */
 546 
 547     protected void setErrorEndPos(int errPos) {
 548         endPosTable.setErrorEndPos(errPos);
 549     }
 550 
 551     protected void storeEnd(JCTree tree, int endpos) {
 552         endPosTable.storeEnd(tree, endpos);
 553     }
 554 
 555     protected &lt;T extends JCTree&gt; T to(T t) {
 556         return endPosTable.to(t);
 557     }
 558 
 559     protected &lt;T extends JCTree&gt; T toP(T t) {
 560         return endPosTable.toP(t);
 561     }
 562 
 563     /** Get the start position for a tree node.  The start position is
 564      * defined to be the position of the first character of the first
 565      * token of the node&#39;s source text.
 566      * @param tree  The tree node
 567      */
 568     public int getStartPos(JCTree tree) {
 569         return TreeInfo.getStartPos(tree);
 570     }
 571 
 572     /**
 573      * Get the end position for a tree node.  The end position is
 574      * defined to be the position of the last character of the last
 575      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 576      * positions are not generated or the position is otherwise not
 577      * found.
 578      * @param tree  The tree node
 579      */
 580     public int getEndPos(JCTree tree) {
 581         return endPosTable.getEndPos(tree);
 582     }
 583 
 584 
 585 
 586 /* ---------- parsing -------------- */
 587 
 588     /**
 589      * Ident = IDENTIFIER
 590      */
 591     public Name ident() {
 592         return ident(false);
 593     }
 594 
 595     protected Name ident(boolean advanceOnErrors) {
 596         if (token.kind == IDENTIFIER) {
 597             Name name = token.name();
 598             nextToken();
 599             return name;
 600         } else if (token.kind == ASSERT) {
 601             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 602             nextToken();
 603             return names.error;
 604         } else if (token.kind == ENUM) {
 605             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 606             nextToken();
 607             return names.error;
 608         } else if (token.kind == THIS) {
 609             if (allowThisIdent) {
 610                 // Make sure we&#39;re using a supported source version.
 611                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 612                 Name name = token.name();
 613                 nextToken();
 614                 return name;
 615             } else {
 616                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 617                 nextToken();
 618                 return names.error;
 619             }
 620         } else if (token.kind == UNDERSCORE) {
 621             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 622                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 623             } else {
 624                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 625             }
 626             Name name = token.name();
 627             nextToken();
 628             return name;
 629         } else {
 630             accept(IDENTIFIER);
 631             if (advanceOnErrors) {
 632                 nextToken();
 633             }
 634             return names.error;
 635         }
 636     }
 637 
 638     /**
 639      * Qualident = Ident { DOT [Annotations] Ident }
 640      */
 641     public JCExpression qualident(boolean allowAnnos) {
 642         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 643         while (token.kind == DOT) {
 644             int pos = token.pos;
 645             nextToken();
 646             List&lt;JCAnnotation&gt; tyannos = null;
 647             if (allowAnnos) {
 648                 tyannos = typeAnnotationsOpt();
 649             }
 650             t = toP(F.at(pos).Select(t, ident()));
 651             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 652                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 653             }
 654         }
 655         return t;
 656     }
 657 
 658     JCExpression literal(Name prefix) {
 659         return literal(prefix, token.pos);
 660     }
 661 
 662     /**
 663      * Literal =
 664      *     INTLITERAL
 665      *   | LONGLITERAL
 666      *   | FLOATLITERAL
 667      *   | DOUBLELITERAL
 668      *   | CHARLITERAL
 669      *   | STRINGLITERAL
 670      *   | TRUE
 671      *   | FALSE
 672      *   | NULL
 673      */
 674     JCExpression literal(Name prefix, int pos) {
 675         JCExpression t = errorTree;
 676         switch (token.kind) {
 677         case INTLITERAL:
 678             try {
 679                 t = F.at(pos).Literal(
 680                     TypeTag.INT,
 681                     Convert.string2int(strval(prefix), token.radix()));
 682             } catch (NumberFormatException ex) {
 683                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 684             }
 685             break;
 686         case LONGLITERAL:
 687             try {
 688                 t = F.at(pos).Literal(
 689                     TypeTag.LONG,
 690                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 691             } catch (NumberFormatException ex) {
 692                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 693             }
 694             break;
 695         case FLOATLITERAL: {
 696             String proper = token.radix() == 16 ?
 697                     (&quot;0x&quot;+ token.stringVal()) :
 698                     token.stringVal();
 699             Float n;
 700             try {
 701                 n = Float.valueOf(proper);
 702             } catch (NumberFormatException ex) {
 703                 // error already reported in scanner
 704                 n = Float.NaN;
 705             }
 706             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 707                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 708             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 709                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 710             else
 711                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 712             break;
 713         }
 714         case DOUBLELITERAL: {
 715             String proper = token.radix() == 16 ?
 716                     (&quot;0x&quot;+ token.stringVal()) :
 717                     token.stringVal();
 718             Double n;
 719             try {
 720                 n = Double.valueOf(proper);
 721             } catch (NumberFormatException ex) {
 722                 // error already reported in scanner
 723                 n = Double.NaN;
 724             }
 725             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 726                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 727             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 728                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 729             else
 730                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 731             break;
 732         }
 733         case CHARLITERAL:
 734             t = F.at(pos).Literal(
 735                 TypeTag.CHAR,
 736                 token.stringVal().charAt(0) + 0);
 737             break;
 738         case STRINGLITERAL:
 739             t = F.at(pos).Literal(
 740                 TypeTag.CLASS,
 741                 token.stringVal());
 742             break;
 743         case TRUE: case FALSE:
 744             t = F.at(pos).Literal(
 745                 TypeTag.BOOLEAN,
 746                 (token.kind == TRUE ? 1 : 0));
 747             break;
 748         case NULL:
 749             t = F.at(pos).Literal(
 750                 TypeTag.BOT,
 751                 null);
 752             break;
 753         default:
 754             Assert.error();
 755         }
 756         if (t == errorTree)
 757             t = F.at(pos).Erroneous();
 758         storeEnd(t, token.endPos);
 759         nextToken();
 760         return t;
 761     }
 762     //where
 763         boolean isZero(String s) {
 764             char[] cs = s.toCharArray();
 765             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 766             int i = ((base==16) ? 2 : 0);
 767             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 768             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 769         }
 770 
 771         String strval(Name prefix) {
 772             String s = token.stringVal();
 773             return prefix.isEmpty() ? s : prefix + s;
 774         }
 775 
 776     /** terms can be either expressions or types.
 777      */
 778     public JCExpression parseExpression() {
 779         return term(EXPR);
 780     }
 781 
 782     /**
 783      * parses (optional) type annotations followed by a type. If the
 784      * annotations are present before the type and are not consumed during array
 785      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 786      * these annotations and the underlying type. Otherwise, it returns the
 787      * underlying type.
 788      *
 789      * &lt;p&gt;
 790      *
 791      * Note that this method sets {@code mode} to {@code TYPE} first, before
 792      * parsing annotations.
 793      */
 794     public JCExpression parseType() {
 795         return parseType(false);
 796     }
 797 
 798     public JCExpression parseType(boolean allowVar) {
 799         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 800         return parseType(allowVar, annotations);
 801     }
 802 
 803     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 804         JCExpression result = unannotatedType(allowVar);
 805 
 806         if (annotations.nonEmpty()) {
 807             result = insertAnnotationsToMostInner(result, annotations, false);
 808         }
 809 
 810         return result;
 811     }
 812 
 813     public JCExpression unannotatedType(boolean allowVar) {
 814         JCExpression result = term(TYPE);
 815         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 816 
 817         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 818             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 819         }
 820 
 821         return result;
 822     }
 823 
 824 
 825 
 826     protected JCExpression term(int newmode) {
 827         int prevmode = mode;
 828         mode = newmode;
 829         JCExpression t = term();
 830         lastmode = mode;
 831         mode = prevmode;
 832         return t;
 833     }
 834 
 835     /**
 836      *  {@literal
 837      *  Expression = Expression1 [ExpressionRest]
 838      *  ExpressionRest = [AssignmentOperator Expression1]
 839      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 840      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 841      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 842      *  Type = Type1
 843      *  TypeNoParams = TypeNoParams1
 844      *  StatementExpression = Expression
 845      *  ConstantExpression = Expression
 846      *  }
 847      */
 848     JCExpression term() {
 849         JCExpression t = term1();
 850         if ((mode &amp; EXPR) != 0 &amp;&amp;
 851             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 852             return termRest(t);
 853         else
 854             return t;
 855     }
 856 
 857     JCExpression termRest(JCExpression t) {
 858         switch (token.kind) {
 859         case EQ: {
 860             int pos = token.pos;
 861             nextToken();
 862             selectExprMode();
 863             JCExpression t1 = term();
 864             return toP(F.at(pos).Assign(t, t1));
 865         }
 866         case PLUSEQ:
 867         case SUBEQ:
 868         case STAREQ:
 869         case SLASHEQ:
 870         case PERCENTEQ:
 871         case AMPEQ:
 872         case BAREQ:
 873         case CARETEQ:
 874         case LTLTEQ:
 875         case GTGTEQ:
 876         case GTGTGTEQ:
 877             int pos = token.pos;
 878             TokenKind tk = token.kind;
 879             nextToken();
 880             selectExprMode();
 881             JCExpression t1 = term();
 882             return F.at(pos).Assignop(optag(tk), t, t1);
 883         default:
 884             return t;
 885         }
 886     }
 887 
 888     /** Expression1   = Expression2 [Expression1Rest]
 889      *  Type1         = Type2
 890      *  TypeNoParams1 = TypeNoParams2
 891      */
 892     JCExpression term1() {
 893         JCExpression t = term2();
 894         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 895             selectExprMode();
 896             return term1Rest(t);
 897         } else {
 898             return t;
 899         }
 900     }
 901 
 902     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 903      */
 904     JCExpression term1Rest(JCExpression t) {
 905         if (token.kind == QUES) {
 906             int pos = token.pos;
 907             nextToken();
 908             JCExpression t1 = term();
 909             accept(COLON);
 910             JCExpression t2 = term1();
 911             return F.at(pos).Conditional(t, t1, t2);
 912         } else {
 913             return t;
 914         }
 915     }
 916 
 917     /** Expression2   = Expression3 [Expression2Rest]
 918      *  Type2         = Type3
 919      *  TypeNoParams2 = TypeNoParams3
 920      */
 921     JCExpression term2() {
 922         JCExpression t = term3();
 923         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 924             selectExprMode();
 925             return term2Rest(t, TreeInfo.orPrec);
 926         } else {
 927             return t;
 928         }
 929     }
 930 
 931     /*  Expression2Rest = {infixop Expression3}
 932      *                  | Expression3 instanceof Type
 933      *                  | Expression3 instanceof Pattern
 934      *  infixop         = &quot;||&quot;
 935      *                  | &quot;&amp;&amp;&quot;
 936      *                  | &quot;|&quot;
 937      *                  | &quot;^&quot;
 938      *                  | &quot;&amp;&quot;
 939      *                  | &quot;==&quot; | &quot;!=&quot;
 940      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 941      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 942      *                  | &quot;+&quot; | &quot;-&quot;
 943      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 944      */
 945     JCExpression term2Rest(JCExpression t, int minprec) {
 946         JCExpression[] odStack = newOdStack();
 947         Token[] opStack = newOpStack();
 948 
 949         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 950         int top = 0;
 951         odStack[0] = t;
 952         int startPos = token.pos;
 953         Token topOp = Tokens.DUMMY;
 954         while (prec(token.kind) &gt;= minprec) {
 955             opStack[top] = topOp;
 956 
 957             if (token.kind == INSTANCEOF) {
 958                 int pos = token.pos;
 959                 nextToken();
 960                 JCTree pattern = parseType();
 961                 if (token.kind == IDENTIFIER) {
 962                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 963                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 964                 }
 965                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 966             } else {
 967                 topOp = token;
 968                 nextToken();
 969                 top++;
 970                 odStack[top] = term3();
 971             }
 972             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 973                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 974                 top--;
 975                 topOp = opStack[top];
 976             }
 977         }
 978         Assert.check(top == 0);
 979         t = odStack[0];
 980 
 981         if (t.hasTag(JCTree.Tag.PLUS)) {
 982             t = foldStrings(t);
 983         }
 984 
 985         odStackSupply.add(odStack);
 986         opStackSupply.add(opStack);
 987         return t;
 988     }
 989     //where
 990         /** If tree is a concatenation of string literals, replace it
 991          *  by a single literal representing the concatenated string.
 992          */
 993         protected JCExpression foldStrings(JCExpression tree) {
 994             if (!allowStringFolding)
 995                 return tree;
 996             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 997             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 998             boolean needsFolding = false;
 999             JCExpression curr = tree;
1000             while (true) {
1001                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1002                     JCBinary op = (JCBinary)curr;
1003                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1004                     curr = op.lhs;
1005                 } else {
1006                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1007                     break; //last one!
1008                 }
1009             }
1010             if (needsFolding) {
1011                 List&lt;JCExpression&gt; ops = opStack.toList();
1012                 JCExpression res = ops.head;
1013                 for (JCExpression op : ops.tail) {
1014                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1015                     storeEnd(res, getEndPos(op));
1016                 }
1017                 return res;
1018             } else {
1019                 return tree;
1020             }
1021         }
1022 
1023         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1024                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1025             JCLiteral str = stringLiteral(tree);
1026             if (str != null) {
1027                 litBuf.prepend(str);
1028                 return last &amp;&amp; merge(litBuf, opStack);
1029             } else {
1030                 boolean res = merge(litBuf, opStack);
1031                 litBuf.clear();
1032                 opStack.prepend(tree);
1033                 return res;
1034             }
1035         }
1036 
1037         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1038             if (litBuf.isEmpty()) {
1039                 return false;
1040             } else if (litBuf.size() == 1) {
1041                 opStack.prepend(litBuf.first());
1042                 return false;
1043             } else {
1044                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1045                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1046                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1047                 opStack.prepend(t);
1048                 return true;
1049             }
1050         }
1051 
1052         private JCLiteral stringLiteral(JCTree tree) {
1053             if (tree.hasTag(LITERAL)) {
1054                 JCLiteral lit = (JCLiteral)tree;
1055                 if (lit.typetag == TypeTag.CLASS) {
1056                     return lit;
1057                 }
1058             }
1059             return null;
1060         }
1061 
1062 
1063         /** optimization: To save allocating a new operand/operator stack
1064          *  for every binary operation, we use supplys.
1065          */
1066         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1067         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1068 
1069         private JCExpression[] newOdStack() {
1070             if (odStackSupply.isEmpty())
1071                 return new JCExpression[infixPrecedenceLevels + 1];
1072             return odStackSupply.remove(odStackSupply.size() - 1);
1073         }
1074 
1075         private Token[] newOpStack() {
1076             if (opStackSupply.isEmpty())
1077                 return new Token[infixPrecedenceLevels + 1];
1078             return opStackSupply.remove(opStackSupply.size() - 1);
1079         }
1080 
1081     /**
1082      *  Expression3    = PrefixOp Expression3
1083      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1084      *                 | Primary {Selector} {PostfixOp}
1085      *
1086      *  {@literal
1087      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1088      *                 | Literal
1089      *                 | [TypeArguments] THIS [Arguments]
1090      *                 | [TypeArguments] SUPER SuperSuffix
1091      *                 | NEW [TypeArguments] Creator
1092      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1093      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1094      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1095      *                 | Expression3 MemberReferenceSuffix
1096      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1097      *                   | Arguments
1098      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1099      *                   ]
1100      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1101      *  }
1102      *
1103      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1104      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1105      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1106      *                 | BasicType
1107      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1108      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1109      *                 | &quot;.&quot; THIS
1110      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1111      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1112      *                 | &quot;[&quot; Expression &quot;]&quot;
1113      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1114      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1115      */
1116     protected JCExpression term3() {
1117         int pos = token.pos;
1118         JCExpression t;
1119         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1120         switch (token.kind) {
1121         case QUES:
1122             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1123                 selectTypeMode();
1124                 return typeArgument();
1125             } else
1126                 return illegal();
1127         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1128             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1129                 TokenKind tk = token.kind;
1130                 nextToken();
1131                 selectExprMode();
1132                 if (tk == SUB &amp;&amp;
1133                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1134                     token.radix() == 10) {
1135                     selectExprMode();
1136                     t = literal(names.hyphen, pos);
1137                 } else {
1138                     t = term3();
1139                     return F.at(pos).Unary(unoptag(tk), t);
1140                 }
1141             } else return illegal();
1142             break;
1143         case WITHFIELD:
1144             if (!allowWithFieldOperator) {
1145                 log.error(pos, Errors.WithFieldOperatorDisallowed);
1146             }
1147             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1148                 nextToken();
1149                 accept(LPAREN);
1150                 mode = EXPR;
1151                 t = term();
1152                 accept(COMMA);
1153                 mode = EXPR;
1154                 JCExpression v = term();
1155                 accept(RPAREN);
1156                 return F.at(pos).WithField(t, v);
1157             } else return illegal();
1158         case LPAREN:
1159             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1160                 ParensResult pres = analyzeParens();
1161                 switch (pres) {
1162                     case CAST:
1163                        accept(LPAREN);
1164                        selectTypeMode();
1165                        int pos1 = pos;
1166                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1167                        while (token.kind == AMP) {
1168                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1169                            accept(AMP);
1170                            targets = targets.prepend(parseType());
1171                        }
1172                        if (targets.length() &gt; 1) {
1173                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1174                        }
1175                        accept(RPAREN);
1176                        selectExprMode();
1177                        JCExpression t1 = term3();
1178                        return F.at(pos).TypeCast(t, t1);
1179                     case IMPLICIT_LAMBDA:
1180                     case EXPLICIT_LAMBDA:
1181                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1182                         break;
1183                     default: //PARENS
1184                         accept(LPAREN);
1185                         selectExprMode();
1186                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1187                         accept(RPAREN);
1188                         t = toP(F.at(pos).Parens(t));
1189                         break;
1190                 }
1191             } else {
1192                 return illegal();
1193             }
1194             break;
1195         case THIS:
1196             if ((mode &amp; EXPR) != 0) {
1197                 selectExprMode();
1198                 t = to(F.at(pos).Ident(names._this));
1199                 nextToken();
1200                 if (typeArgs == null)
1201                     t = argumentsOpt(null, t);
1202                 else
1203                     t = arguments(typeArgs, t);
1204                 typeArgs = null;
1205             } else return illegal();
1206             break;
1207         case SUPER:
1208             if ((mode &amp; EXPR) != 0) {
1209                 selectExprMode();
1210                 t = to(F.at(pos).Ident(names._super));
1211                 t = superSuffix(typeArgs, t);
1212                 typeArgs = null;
1213             } else return illegal();
1214             break;
1215         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1216         case CHARLITERAL: case STRINGLITERAL:
1217         case TRUE: case FALSE: case NULL:
1218             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1219                 selectExprMode();
1220                 t = literal(names.empty);
1221             } else return illegal();
1222             break;
1223         case NEW:
1224             if (typeArgs != null) return illegal();
1225             if ((mode &amp; EXPR) != 0) {
1226                 selectExprMode();
1227                 nextToken();
1228                 if (token.kind == LT) typeArgs = typeArguments(false);
1229                 t = creator(pos, typeArgs);
1230                 typeArgs = null;
1231             } else return illegal();
1232             break;
1233         case MONKEYS_AT:
1234             // Only annotated cast types and method references are valid
1235             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1236             if (typeAnnos.isEmpty()) {
1237                 // else there would be no &#39;@&#39;
1238                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1239             }
1240 
1241             JCExpression expr = term3();
1242 
1243             if ((mode &amp; TYPE) == 0) {
1244                 // Type annotations on class literals no longer legal
1245                 switch (expr.getTag()) {
1246                 case REFERENCE: {
1247                     JCMemberReference mref = (JCMemberReference) expr;
1248                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1249                     t = mref;
1250                     break;
1251                 }
1252                 case SELECT: {
1253                     JCFieldAccess sel = (JCFieldAccess) expr;
1254 
1255                     if (sel.name != names._class) {
1256                         return illegal();
1257                     } else {
1258                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1259                         return expr;
1260                     }
1261                 }
1262                 default:
1263                     return illegal(typeAnnos.head.pos);
1264                 }
1265 
1266             } else {
1267                 // Type annotations targeting a cast
1268                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1269             }
1270             break;
1271         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1272             if (typeArgs != null) return illegal();
1273             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1274                 t = lambdaExpressionOrStatement(false, false, pos);
1275             } else {
1276                 t = toP(F.at(token.pos).Ident(ident()));
1277                 loop: while (true) {
1278                     pos = token.pos;
1279                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1280 
1281                     // need to report an error later if LBRACKET is for array
1282                     // index access rather than array creation level
1283                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1284                         return illegal(annos.head.pos);
1285 
1286                     switch (token.kind) {
1287                     case LBRACKET:
1288                         nextToken();
1289                         if (token.kind == RBRACKET) {
1290                             nextToken();
1291                             t = bracketsOpt(t);
1292                             t = toP(F.at(pos).TypeArray(t));
1293                             if (annos.nonEmpty()) {
1294                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1295                             }
1296                             t = bracketsSuffix(t);
1297                         } else {
1298                             if ((mode &amp; EXPR) != 0) {
1299                                 selectExprMode();
1300                                 JCExpression t1 = term();
1301                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1302                                 t = to(F.at(pos).Indexed(t, t1));
1303                             }
1304                             accept(RBRACKET);
1305                         }
1306                         break loop;
1307                     case LPAREN:
1308                         if ((mode &amp; EXPR) != 0) {
1309                             selectExprMode();
1310                             t = arguments(typeArgs, t);
1311                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1312                             typeArgs = null;
1313                         }
1314                         break loop;
1315                     case DOT:
1316                         nextToken();
1317                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1318                             return illegal();
1319                         }
1320                         int oldmode = mode;
1321                         mode &amp;= ~NOPARAMS;
1322                         typeArgs = typeArgumentsOpt(EXPR);
1323                         mode = oldmode;
1324                         if ((mode &amp; EXPR) != 0) {
1325                             switch (token.kind) {
1326                             case DEFAULT:
1327                                 if (typeArgs != null) return illegal();
1328                                 selectExprMode();
1329                                 t = to(F.at(pos).Select(t, names._default));
1330                                 nextToken();
1331                                 break loop;
1332                             case CLASS:
1333                                 if (typeArgs != null) return illegal();
1334                                 selectExprMode();
1335                                 t = to(F.at(pos).Select(t, names._class));
1336                                 nextToken();
1337                                 break loop;
1338                             case THIS:
1339                                 if (typeArgs != null) return illegal();
1340                                 selectExprMode();
1341                                 t = to(F.at(pos).Select(t, names._this));
1342                                 nextToken();
1343                                 break loop;
1344                             case SUPER:
1345                                 selectExprMode();
1346                                 t = to(F.at(pos).Select(t, names._super));
1347                                 t = superSuffix(typeArgs, t);
1348                                 typeArgs = null;
1349                                 break loop;
1350                             case NEW:
1351                                 if (typeArgs != null) return illegal();
1352                                 selectExprMode();
1353                                 int pos1 = token.pos;
1354                                 nextToken();
1355                                 if (token.kind == LT) typeArgs = typeArguments(false);
1356                                 t = innerCreator(pos1, typeArgs, t);
1357                                 typeArgs = null;
1358                                 break loop;
1359                             }
1360                         }
1361 
1362                         List&lt;JCAnnotation&gt; tyannos = null;
1363                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1364                             tyannos = typeAnnotationsOpt();
1365                         }
1366                         // typeArgs saved for next loop iteration.
1367                         t = toP(F.at(pos).Select(t, ident()));
1368                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1369                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1370                         }
1371                         break;
1372                     case ELLIPSIS:
1373                         if (this.permitTypeAnnotationsPushBack) {
1374                             this.typeAnnotationsPushedBack = annos;
1375                         } else if (annos.nonEmpty()) {
1376                             // Don&#39;t return here -- error recovery attempt
1377                             illegal(annos.head.pos);
1378                         }
1379                         break loop;
1380                     case LT:
1381                         if ((mode &amp; TYPE) == 0 &amp;&amp; isParameterizedTypePrefix()) {
1382                             //this is either an unbound method reference whose qualifier
1383                             //is a generic type i.e. A&lt;S&gt;::m or a default value creation of
1384                             //the form ValueType&lt;S&gt;.default
1385                             int pos1 = token.pos;
1386                             accept(LT);
1387                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1388                             args.append(typeArgument());
1389                             while (token.kind == COMMA) {
1390                                 nextToken();
1391                                 args.append(typeArgument());
1392                             }
1393                             accept(GT);
1394                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1395                             while (token.kind == DOT) {
1396                                 nextToken();
1397                                 if (token.kind == DEFAULT) {
1398                                     t =  toP(F.at(token.pos).Select(t, names._default));
1399                                     nextToken();
1400                                     selectExprMode();
1401                                     return term3Rest(t, typeArgs);
1402                                 }
1403                                 selectTypeMode();
1404                                 t = toP(F.at(token.pos).Select(t, ident()));
1405                                 t = typeArgumentsOpt(t);
1406                             }
1407                             t = bracketsOpt(t);
1408                             if (token.kind != COLCOL) {
1409                                 //method reference expected here
1410                                 t = illegal();
1411                             }
1412                             selectExprMode();
1413                             return term3Rest(t, typeArgs);
1414                         }
1415                         break loop;
1416                     default:
1417                         break loop;
1418                     }
1419                 }
1420             }
1421             if (typeArgs != null) illegal();
1422             t = typeArgumentsOpt(t);
1423             break;
1424         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1425         case DOUBLE: case BOOLEAN:
1426             if (typeArgs != null) illegal();
1427             t = bracketsSuffix(bracketsOpt(basicType()));
1428             break;
1429         case VOID:
1430             if (typeArgs != null) illegal();
1431             if ((mode &amp; EXPR) != 0) {
1432                 nextToken();
1433                 if (token.kind == DOT) {
1434                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1435                     t = bracketsSuffix(ti);
1436                 } else {
1437                     return illegal(pos);
1438                 }
1439             } else {
1440                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1441                 // a void type (like other primitive types) to the next phase.
1442                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1443                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1444                 nextToken();
1445                 return ti;
1446                 //return illegal();
1447             }
1448             break;
1449         case SWITCH:
1450             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1451             allowYieldStatement = true;
1452             int switchPos = token.pos;
1453             nextToken();
1454             JCExpression selector = parExpression();
1455             accept(LBRACE);
1456             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1457             while (true) {
1458                 pos = token.pos;
1459                 switch (token.kind) {
1460                 case CASE:
1461                 case DEFAULT:
1462                     cases.appendList(switchExpressionStatementGroup());
1463                     break;
1464                 case RBRACE: case EOF:
1465                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1466                                                                                cases.toList()));
1467                     e.endpos = token.pos;
1468                     accept(RBRACE);
1469                     return e;
1470                 default:
1471                     nextToken(); // to ensure progress
1472                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1473                 }
1474             }
1475         default:
1476             return illegal();
1477         }
1478         return term3Rest(t, typeArgs);
1479     }
1480 
1481     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1482         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1483         int casePos = token.pos;
1484         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1485 
1486         if (token.kind == DEFAULT) {
1487             nextToken();
1488         } else {
1489             accept(CASE);
1490             while (true) {
1491                 pats.append(term(EXPR | NOLAMBDA));
1492                 if (token.kind != COMMA) break;
1493                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1494                 nextToken();
1495             };
1496         }
1497         List&lt;JCStatement&gt; stats = null;
1498         JCTree body = null;
1499         CaseTree.CaseKind kind;
1500         switch (token.kind) {
1501             case ARROW:
1502                 checkSourceLevel(Feature.SWITCH_RULE);
1503                 nextToken();
1504                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1505                     stats = List.of(parseStatement());
1506                     body = stats.head;
1507                     kind = JCCase.RULE;
1508                 } else {
1509                     JCExpression value = parseExpression();
1510                     stats = List.of(to(F.at(value).Yield(value)));
1511                     body = value;
1512                     kind = JCCase.RULE;
1513                     accept(SEMI);
1514                 }
1515                 break;
1516             default:
1517                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1518                 stats = blockStatements();
1519                 kind = JCCase.STATEMENT;
1520                 break;
1521         }
1522         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1523         return caseExprs.toList();
1524     }
1525 
1526     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1527         if (typeArgs != null) illegal();
1528         while (true) {
1529             int pos1 = token.pos;
1530             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1531 
1532             if (token.kind == LBRACKET) {
1533                 nextToken();
1534                 if ((mode &amp; TYPE) != 0) {
1535                     int oldmode = mode;
1536                     selectTypeMode();
1537                     if (token.kind == RBRACKET) {
1538                         nextToken();
1539                         t = bracketsOpt(t);
1540                         t = toP(F.at(pos1).TypeArray(t));
1541                         if (token.kind == COLCOL) {
1542                             selectExprMode();
1543                             continue;
1544                         }
1545                         if (annos.nonEmpty()) {
1546                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1547                         }
1548                         return t;
1549                     }
1550                     mode = oldmode;
1551                 }
1552                 if ((mode &amp; EXPR) != 0) {
1553                     selectExprMode();
1554                     JCExpression t1 = term();
1555                     t = to(F.at(pos1).Indexed(t, t1));
1556                 }
1557                 accept(RBRACKET);
1558             } else if (token.kind == DOT) {
1559                 nextToken();
1560                 typeArgs = typeArgumentsOpt(EXPR);
1561                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1562                     selectExprMode();
1563                     t = to(F.at(pos1).Select(t, names._super));
1564                     nextToken();
1565                     t = arguments(typeArgs, t);
1566                     typeArgs = null;
1567                 } else if ((token.kind == NEW) &amp;&amp; (mode &amp; EXPR) != 0) {
1568                     if (typeArgs != null) return illegal();
1569                     selectExprMode();
1570                     int pos2 = token.pos;
1571                     nextToken();
1572                     if (token.kind == LT) typeArgs = typeArguments(false);
1573                     t = innerCreator(pos2, typeArgs, t);
1574                     typeArgs = null;
1575                 } else {
1576                     List&lt;JCAnnotation&gt; tyannos = null;
1577                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1578                         // is the mode check needed?
1579                         tyannos = typeAnnotationsOpt();
1580                     }
1581                     t = toP(F.at(pos1).Select(t, ident(true)));
1582                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1583                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1584                     }
1585                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1586                     typeArgs = null;
1587                 }
1588             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1589                 selectExprMode();
1590                 if (typeArgs != null) return illegal();
1591                 accept(COLCOL);
1592                 t = memberReferenceSuffix(pos1, t);
1593             } else {
1594                 if (!annos.isEmpty()) {
1595                     if (permitTypeAnnotationsPushBack)
1596                         typeAnnotationsPushedBack = annos;
1597                     else
1598                         return illegal(annos.head.pos);
1599                 }
1600                 break;
1601             }
1602         }
1603         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1604             selectExprMode();
1605             t = to(F.at(token.pos).Unary(
1606                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1607             nextToken();
1608         }
1609         return toP(t);
1610     }
1611 
1612     /**
1613      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1614      * method reference or a default value creation that uses a parameterized type
1615      * or a binary expression. To disambiguate, look for a
1616      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1617      */
1618     @SuppressWarnings(&quot;fallthrough&quot;)
1619     boolean isParameterizedTypePrefix() {
1620         int pos = 0, depth = 0;
1621         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1622             switch (t.kind) {
1623                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1624                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1625                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1626                 case DOUBLE: case BOOLEAN: case CHAR:
1627                 case MONKEYS_AT:
1628                     break;
1629 
1630                 case LPAREN:
1631                     // skip annotation values
1632                     int nesting = 0;
1633                     for (; ; pos++) {
1634                         TokenKind tk2 = S.token(pos).kind;
1635                         switch (tk2) {
1636                             case EOF:
1637                                 return false;
1638                             case LPAREN:
1639                                 nesting++;
1640                                 break;
1641                             case RPAREN:
1642                                 nesting--;
1643                                 if (nesting == 0) {
1644                                     continue outer;
1645                                 }
1646                                 break;
1647                         }
1648                     }
1649 
1650                 case LT:
1651                     depth++; break;
1652                 case GTGTGT:
1653                     depth--;
1654                 case GTGT:
1655                     depth--;
1656                 case GT:
1657                     depth--;
1658                     if (depth == 0) {
1659                         TokenKind nextKind = S.token(pos + 1).kind;
1660                         return
1661                             nextKind == TokenKind.DOT ||
1662                             nextKind == TokenKind.LBRACKET ||
1663                             nextKind == TokenKind.COLCOL;
1664                     }
1665                     break;
1666                 default:
1667                     return false;
1668             }
1669         }
1670     }
1671 
1672     /**
1673      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1674      * method reference or a binary expression. To disambiguate, look for a
1675      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1676      */
1677     @SuppressWarnings(&quot;fallthrough&quot;)
1678     ParensResult analyzeParens() {
1679         int depth = 0;
1680         boolean type = false;
1681         ParensResult defaultResult = ParensResult.PARENS;
1682         outer: for (int lookahead = 0; ; lookahead++) {
1683             TokenKind tk = S.token(lookahead).kind;
1684             switch (tk) {
1685                 case COMMA:
1686                     type = true;
1687                 case EXTENDS: case SUPER: case DOT: case AMP:
1688                     //skip
1689                     break;
1690                 case QUES:
1691                     if (peekToken(lookahead, EXTENDS) ||
1692                             peekToken(lookahead, SUPER)) {
1693                         //wildcards
1694                         type = true;
1695                     }
1696                     break;
1697                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1698                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1699                     if (peekToken(lookahead, RPAREN)) {
1700                         //Type, &#39;)&#39; -&gt; cast
1701                         return ParensResult.CAST;
1702                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1703                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1704                         return ParensResult.EXPLICIT_LAMBDA;
1705                     }
1706                     break;
1707                 case LPAREN:
1708                     if (lookahead != 0) {
1709                         // &#39;(&#39; in a non-starting position -&gt; parens
1710                         return ParensResult.PARENS;
1711                     } else if (peekToken(lookahead, RPAREN)) {
1712                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1713                         return ParensResult.EXPLICIT_LAMBDA;
1714                     }
1715                     break;
1716                 case RPAREN:
1717                     // if we have seen something that looks like a type,
1718                     // then it&#39;s a cast expression
1719                     if (type) return ParensResult.CAST;
1720                     // otherwise, disambiguate cast vs. parenthesized expression
1721                     // based on subsequent token.
1722                     switch (S.token(lookahead + 1).kind) {
1723                         /*case PLUSPLUS: case SUBSUB: */
1724                         case BANG: case TILDE:
1725                         case LPAREN: case THIS: case SUPER:
1726                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1727                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1728                         case TRUE: case FALSE: case NULL:
1729                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1730                         case SWITCH:
1731                         case BYTE: case SHORT: case CHAR: case INT:
1732                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1733                             return ParensResult.CAST;
1734                         default:
1735                             return defaultResult;
1736                     }
1737                 case UNDERSCORE:
1738                 case ASSERT:
1739                 case ENUM:
1740                 case IDENTIFIER:
1741                     if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) &amp;&amp; (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {
1742                         // Identifier[?], Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1743                         return ParensResult.EXPLICIT_LAMBDA;
1744                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1745                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1746                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1747                                                       : ParensResult.PARENS;
1748                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1749                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1750                     }
1751                     type = false;
1752                     break;
1753                 case FINAL:
1754                 case ELLIPSIS:
1755                     //those can only appear in explicit lambdas
1756                     return ParensResult.EXPLICIT_LAMBDA;
1757                 case MONKEYS_AT:
1758                     type = true;
1759                     lookahead += 1; //skip &#39;@&#39;
1760                     while (peekToken(lookahead, DOT)) {
1761                         lookahead += 2;
1762                     }
1763                     if (peekToken(lookahead, LPAREN)) {
1764                         lookahead++;
1765                         //skip annotation values
1766                         int nesting = 0;
1767                         for (; ; lookahead++) {
1768                             TokenKind tk2 = S.token(lookahead).kind;
1769                             switch (tk2) {
1770                                 case EOF:
1771                                     return ParensResult.PARENS;
1772                                 case LPAREN:
1773                                     nesting++;
1774                                     break;
1775                                 case RPAREN:
1776                                     nesting--;
1777                                     if (nesting == 0) {
1778                                         continue outer;
1779                                     }
1780                                 break;
1781                             }
1782                         }
1783                     }
1784                     break;
1785                 case LBRACKET:
1786                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1787                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1788                         return ParensResult.EXPLICIT_LAMBDA;
1789                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1790                             peekToken(lookahead, RBRACKET, AMP)) {
1791                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1792                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1793                         return ParensResult.CAST;
1794                     } else if (peekToken(lookahead, RBRACKET)) {
1795                         //consume the &#39;]&#39; and skip
1796                         type = true;
1797                         lookahead++;
1798                         break;
1799                     } else {
1800                         return ParensResult.PARENS;
1801                     }
1802                 case LT:
1803                     depth++; break;
1804                 case GTGTGT:
1805                     depth--;
1806                 case GTGT:
1807                     depth--;
1808                 case GT:
1809                     depth--;
1810                     if (depth == 0) {
1811                         if (peekToken(lookahead, RPAREN) ||
1812                                 peekToken(lookahead, AMP)) {
1813                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1814                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1815                             return ParensResult.CAST;
1816                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1817                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1818                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||
1819                                 peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||
1820                                 peekToken(lookahead, ELLIPSIS)) {
1821                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1822                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1823                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1824                             return ParensResult.EXPLICIT_LAMBDA;
1825                         }
1826                         //it looks a type, but could still be (i) a cast to generic type,
1827                         //(ii) an unbound method reference or (iii) an explicit lambda
1828                         type = true;
1829                         break;
1830                     } else if (depth &lt; 0) {
1831                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1832                         return ParensResult.PARENS;
1833                     }
1834                     break;
1835                 default:
1836                     //this includes EOF
1837                     return defaultResult;
1838             }
1839         }
1840     }
1841 
1842     /** Accepts all identifier-like tokens */
1843     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1844 
1845     enum ParensResult {
1846         CAST,
1847         EXPLICIT_LAMBDA,
1848         IMPLICIT_LAMBDA,
1849         PARENS
1850     }
1851 
1852     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1853         List&lt;JCVariableDecl&gt; params = explicitParams ?
1854                 formalParameters(true, false) :
1855                 implicitParameters(hasParens);
1856         if (explicitParams) {
1857             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1858             for (JCVariableDecl param: params) {
1859                 Name restrictedTypeName;
1860                 if (param.vartype != null &amp;&amp;
1861                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1862                         param.vartype.hasTag(TYPEARRAY)) {
1863                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1864                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1865                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1866                 }
1867                 lambdaClassifier.addParameter(param);
1868                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1869                     break;
1870                 }
1871             }
1872             if (lambdaClassifier.diagFragment != null) {
1873                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1874             }
1875             for (JCVariableDecl param: params) {
1876                 if (param.vartype != null
1877                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1878                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1879                     param.startPos = TreeInfo.getStartPos(param.vartype);
1880                     param.vartype = null;
1881                 }
1882             }
1883         }
1884         return lambdaExpressionOrStatementRest(params, pos);
1885     }
1886 
1887     enum LambdaParameterKind {
1888         VAR(0),
1889         EXPLICIT(1),
1890         IMPLICIT(2),
1891         ERROR(-1);
1892 
1893         private final int index;
1894 
1895         LambdaParameterKind(int index) {
1896             this.index = index;
1897         }
1898     }
1899 
1900     private final static Fragment[][] decisionTable = new Fragment[][] {
1901         /*              VAR                              EXPLICIT                         IMPLICIT  */
1902         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1903         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1904         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1905     };
1906 
1907     class LambdaClassifier {
1908 
1909         LambdaParameterKind kind;
1910         Fragment diagFragment;
1911         List&lt;JCVariableDecl&gt; params;
1912 
1913         void addParameter(JCVariableDecl param) {
1914             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1915                 if (restrictedTypeName(param.vartype, false) != null) {
1916                     reduce(LambdaParameterKind.VAR);
1917                 } else {
1918                     reduce(LambdaParameterKind.EXPLICIT);
1919                 }
1920             }
1921             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1922                 param.vartype != null &amp;&amp; param.name == names.empty) {
1923                 reduce(LambdaParameterKind.IMPLICIT);
1924             }
1925         }
1926 
1927         private void reduce(LambdaParameterKind newKind) {
1928             if (kind == null) {
1929                 kind = newKind;
1930             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1931                 LambdaParameterKind currentKind = kind;
1932                 kind = LambdaParameterKind.ERROR;
1933                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1934                         newKind.index == LambdaParameterKind.VAR.index;
1935                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1936                         decisionTable[currentKind.index][newKind.index] : null;
1937             }
1938         }
1939 
1940         LambdaParameterKind result() {
1941             return kind;
1942         }
1943     }
1944 
1945     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1946         checkSourceLevel(Feature.LAMBDA);
1947         accept(ARROW);
1948 
1949         return token.kind == LBRACE ?
1950             lambdaStatement(args, pos, token.pos) :
1951             lambdaExpression(args, pos);
1952     }
1953 
1954     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1955         JCBlock block = block(pos2, 0);
1956         return toP(F.at(pos).Lambda(args, block));
1957     }
1958 
1959     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1960         JCTree expr = parseExpression();
1961         return toP(F.at(pos).Lambda(args, expr));
1962     }
1963 
1964     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1965      */
1966     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1967         nextToken();
1968         if (token.kind == LPAREN || typeArgs != null) {
1969             t = arguments(typeArgs, t);
1970         } else if (token.kind == COLCOL) {
1971             if (typeArgs != null) return illegal();
1972             t = memberReferenceSuffix(t);
1973         } else {
1974             int pos = token.pos;
1975             accept(DOT);
1976             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1977             t = toP(F.at(pos).Select(t, ident()));
1978             t = argumentsOpt(typeArgs, t);
1979         }
1980         return t;
1981     }
1982 
1983     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1984      */
1985     JCPrimitiveTypeTree basicType() {
1986         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1987         nextToken();
1988         return t;
1989     }
1990 
1991     /** ArgumentsOpt = [ Arguments ]
1992      */
1993     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1994         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1995             selectExprMode();
1996             return arguments(typeArgs, t);
1997         } else {
1998             return t;
1999         }
2000     }
2001 
2002     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
2003      */
2004     List&lt;JCExpression&gt; arguments() {
2005         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2006         if (token.kind == LPAREN) {
2007             nextToken();
2008             if (token.kind != RPAREN) {
2009                 args.append(parseExpression());
2010                 while (token.kind == COMMA) {
2011                     nextToken();
2012                     args.append(parseExpression());
2013                 }
2014             }
2015             accept(RPAREN);
2016         } else {
2017             syntaxError(token.pos, Errors.Expected(LPAREN));
2018         }
2019         return args.toList();
2020     }
2021 
2022     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2023         int pos = token.pos;
2024         List&lt;JCExpression&gt; args = arguments();
2025         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2026         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2027                                                                     ((JCIdent) t).name)) {
2028             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2029             mi = F.Erroneous(List.of(mi));
2030         }
2031         return toP(mi);
2032     }
2033 
2034     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2035         if (name == names.yield) {
2036             if (allowYieldStatement) {
2037                 return true;
2038             } else {
2039                 log.warning(pos, Warnings.InvalidYield);
2040             }
2041         }
2042         return false;
2043     }
2044 
2045     /**  TypeArgumentsOpt = [ TypeArguments ]
2046      */
2047     JCExpression typeArgumentsOpt(JCExpression t) {
2048         if (token.kind == LT &amp;&amp;
2049             (mode &amp; TYPE) != 0 &amp;&amp;
2050             (mode &amp; NOPARAMS) == 0) {
2051             selectTypeMode();
2052             return typeArguments(t, false);
2053         } else {
2054             return t;
2055         }
2056     }
2057     List&lt;JCExpression&gt; typeArgumentsOpt() {
2058         return typeArgumentsOpt(TYPE);
2059     }
2060 
2061     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2062         if (token.kind == LT) {
2063             if ((mode &amp; useMode) == 0 ||
2064                 (mode &amp; NOPARAMS) != 0) {
2065                 illegal();
2066             }
2067             mode = useMode;
2068             return typeArguments(false);
2069         }
2070         return null;
2071     }
2072 
2073     /**
2074      *  {@literal
2075      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2076      *  }
2077      */
2078     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2079         if (token.kind == LT) {
2080             nextToken();
2081             if (token.kind == GT &amp;&amp; diamondAllowed) {
2082                 checkSourceLevel(Feature.DIAMOND);
2083                 mode |= DIAMOND;
2084                 nextToken();
2085                 return List.nil();
2086             } else {
2087                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2088                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2089                 while (token.kind == COMMA) {
2090                     nextToken();
2091                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2092                 }
2093                 switch (token.kind) {
2094 
2095                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2096                 case GTGTGT: case GTGT:
2097                     token = S.split();
2098                     break;
2099                 case GT:
2100                     nextToken();
2101                     break;
2102                 default:
2103                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2104                     break;
2105                 }
2106                 return args.toList();
2107             }
2108         } else {
2109             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2110         }
2111     }
2112 
2113     /**
2114      *  {@literal
2115      *  TypeArgument = Type
2116      *               | [Annotations] &quot;?&quot;
2117      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2118      *               | [Annotations] &quot;?&quot; SUPER Type
2119      *  }
2120      */
2121     JCExpression typeArgument() {
2122         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2123         if (token.kind != QUES) return parseType(false, annotations);
2124         int pos = token.pos;
2125         nextToken();
2126         JCExpression result;
2127         if (token.kind == EXTENDS) {
2128             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2129             nextToken();
2130             JCExpression bound = parseType();
2131             result = F.at(pos).Wildcard(t, bound);
2132         } else if (token.kind == SUPER) {
2133             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2134             nextToken();
2135             JCExpression bound = parseType();
2136             result = F.at(pos).Wildcard(t, bound);
2137         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2138             //error recovery
2139             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2140             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2141             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2142             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2143             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2144             result = err;
2145         } else {
2146             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2147             result = toP(F.at(pos).Wildcard(t, null));
2148         }
2149         if (!annotations.isEmpty()) {
2150             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2151         }
2152         return result;
2153     }
2154 
2155     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2156         int pos = token.pos;
2157         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2158         return toP(F.at(pos).TypeApply(t, args));
2159     }
2160 
2161     /**
2162      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2163      *
2164      * &lt;p&gt;
2165      *
2166      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2167      * the expression &lt;code&gt;t&lt;/code&gt;.
2168      */
2169     private JCExpression bracketsOpt(JCExpression t,
2170             List&lt;JCAnnotation&gt; annotations) {
2171         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2172 
2173         if (token.kind == LBRACKET) {
2174             int pos = token.pos;
2175             nextToken();
2176             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2177         } else if (!nextLevelAnnotations.isEmpty()) {
2178             if (permitTypeAnnotationsPushBack) {
2179                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2180             } else {
2181                 return illegal(nextLevelAnnotations.head.pos);
2182             }
2183         }
2184 
2185         if (!annotations.isEmpty()) {
2186             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2187         }
2188         return t;
2189     }
2190 
2191     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2192      */
2193     private JCExpression bracketsOpt(JCExpression t) {
2194         return bracketsOpt(t, List.nil());
2195     }
2196 
2197     private JCExpression bracketsOptCont(JCExpression t, int pos,
2198             List&lt;JCAnnotation&gt; annotations) {
2199         accept(RBRACKET);
2200         t = bracketsOpt(t);
2201         t = toP(F.at(pos).TypeArray(t));
2202         if (annotations.nonEmpty()) {
2203             t = toP(F.at(pos).AnnotatedType(annotations, t));
2204         }
2205         return t;
2206     }
2207 
2208     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2209      *  BracketsSuffixType =
2210      */
2211     JCExpression bracketsSuffix(JCExpression t) {
2212         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2213             selectExprMode();
2214             int pos = token.pos;
2215             nextToken();
2216             TokenKind selector = accept2(CLASS, DEFAULT);
2217             if (token.pos == endPosTable.errorEndPos) {
2218                 // error recovery
2219                 Name name;
2220                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2221                     name = token.name();
2222                     nextToken();
2223                 } else {
2224                     name = names.error;
2225                 }
2226                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2227             } else {
2228                 Tag tag = t.getTag();
2229                 // Type annotations are illegal on class literals. Annotated non array class literals
2230                 // are complained about directly in term3(), Here check for type annotations on dimensions
2231                 // taking care to handle some interior dimension(s) being annotated.
2232                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2233                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2234                 t = toP(F.at(pos).Select(t, selector == CLASS ? names._class : names._default));
2235             }
2236         } else if ((mode &amp; TYPE) != 0) {
2237             if (token.kind != COLCOL) {
2238                 selectTypeMode();
2239             }
2240         } else if (token.kind != COLCOL) {
2241             syntaxError(token.pos, Errors.DotClassExpected);
2242         }
2243         return t;
2244     }
2245 
2246     /**
2247      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2248      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2249      */
2250     JCExpression memberReferenceSuffix(JCExpression t) {
2251         int pos1 = token.pos;
2252         accept(COLCOL);
2253         return memberReferenceSuffix(pos1, t);
2254     }
2255 
2256     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2257         checkSourceLevel(Feature.METHOD_REFERENCES);
2258         selectExprMode();
2259         List&lt;JCExpression&gt; typeArgs = null;
2260         if (token.kind == LT) {
2261             typeArgs = typeArguments(false);
2262         }
2263         Name refName;
2264         ReferenceMode refMode;
2265         if (token.kind == NEW) {
2266             refMode = ReferenceMode.NEW;
2267             refName = names.init;
2268             nextToken();
2269         } else {
2270             refMode = ReferenceMode.INVOKE;
2271             refName = ident();
2272         }
2273         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2274     }
2275 
2276     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2277      */
2278     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2279         final JCModifiers mods = modifiersOpt();
2280         List&lt;JCAnnotation&gt; newAnnotations = mods.annotations;
2281         if (!newAnnotations.isEmpty()) {
2282             checkSourceLevel(newAnnotations.head.pos, Feature.TYPE_ANNOTATIONS);
2283         }
2284         switch (token.kind) {
2285         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2286         case DOUBLE: case BOOLEAN:
2287             if (mods.flags != 0) {
2288                 long badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2289                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2290             }
2291             if (typeArgs == null) {
2292                 if (newAnnotations.isEmpty()) {
2293                     return arrayCreatorRest(newpos, basicType());
2294                 } else {
2295                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2296                 }
2297             }
2298             break;
2299         default:
2300         }
2301         JCExpression t = qualident(true);
2302 
2303         int oldmode = mode;
2304         selectTypeMode();
2305         boolean diamondFound = false;
2306         int lastTypeargsPos = -1;
2307         if (token.kind == LT) {
2308             lastTypeargsPos = token.pos;
2309             t = typeArguments(t, true);
2310             diamondFound = (mode &amp; DIAMOND) != 0;
2311         }
2312         while (token.kind == DOT) {
2313             if (diamondFound) {
2314                 //cannot select after a diamond
2315                 illegal();
2316             }
2317             int pos = token.pos;
2318             nextToken();
2319             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2320             t = toP(F.at(pos).Select(t, ident()));
2321 
2322             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2323                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2324             }
2325 
2326             if (token.kind == LT) {
2327                 lastTypeargsPos = token.pos;
2328                 t = typeArguments(t, true);
2329                 diamondFound = (mode &amp; DIAMOND) != 0;
2330             }
2331         }
2332         mode = oldmode;
2333         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2334             // handle type annotations for non primitive arrays
2335             if (newAnnotations.nonEmpty()) {
2336                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2337             }
2338 
2339             JCExpression e = arrayCreatorRest(newpos, t);
2340             if (diamondFound) {
2341                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2342                 return toP(F.at(newpos).Erroneous(List.of(e)));
2343             }
2344             else if (typeArgs != null) {
2345                 int pos = newpos;
2346                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2347                     // note: this should always happen but we should
2348                     // not rely on this as the parser is continuously
2349                     // modified to improve error recovery.
2350                     pos = typeArgs.head.pos;
2351                 }
2352                 setErrorEndPos(S.prevToken().endPos);
2353                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2354                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2355                 return toP(err);
2356             }
2357             return e;
2358         } else if (token.kind == LPAREN) {
2359             long badModifiers = mods.flags &amp; ~(Flags.VALUE | Flags.FINAL);
2360             if (badModifiers != 0)
2361                 log.error(token.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2362             // handle type annotations for instantiations and anonymous classes
2363             if (newAnnotations.nonEmpty()) {
2364                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2365             }
2366             JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t, mods.flags);
2367             if ((newClass.def == null) &amp;&amp; (mods.flags != 0)) {
2368                 badModifiers = (mods.flags &amp; Flags.VALUE) != 0 ? mods.flags &amp; ~Flags.FINAL : mods.flags;
2369                 log.error(newClass.pos, Errors.ModNotAllowedHere(asFlagSet(badModifiers)));
2370             }
2371             return newClass;
2372         } else {
2373             setErrorEndPos(token.pos);
2374             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2375             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2376             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2377         }
2378     }
2379 
2380     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2381      */
2382     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2383         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2384 
2385         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2386 
2387         if (newAnnotations.nonEmpty()) {
2388             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2389         }
2390 
2391         if (token.kind == LT) {
2392             int oldmode = mode;
2393             t = typeArguments(t, true);
2394             mode = oldmode;
2395         }
2396         return classCreatorRest(newpos, encl, typeArgs, t, 0);
2397     }
2398 
2399     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2400      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2401      */
2402     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2403         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2404 
2405         accept(LBRACKET);
2406         if (token.kind == RBRACKET) {
2407             accept(RBRACKET);
2408             elemtype = bracketsOpt(elemtype, annos);
2409             if (token.kind == LBRACE) {
2410                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2411                 if (annos.nonEmpty()) {
2412                     // when an array initializer is present then
2413                     // the parsed annotations should target the
2414                     // new array tree
2415                     // bracketsOpt inserts the annotation in
2416                     // elemtype, and it needs to be corrected
2417                     //
2418                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2419                     assert annotated.annotations == annos;
2420                     na.annotations = annotated.annotations;
2421                     na.elemtype = annotated.underlyingType;
2422                 }
2423                 return na;
2424             } else {
2425                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2426                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2427             }
2428         } else {
2429             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2430 
2431             // maintain array dimension type annotations
2432             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2433             dimAnnotations.append(annos);
2434 
2435             dims.append(parseExpression());
2436             accept(RBRACKET);
2437             while (token.kind == LBRACKET
2438                     || token.kind == MONKEYS_AT) {
2439                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2440                 int pos = token.pos;
2441                 nextToken();
2442                 if (token.kind == RBRACKET) {
2443                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2444                 } else {
2445                     if (token.kind == RBRACKET) { // no dimension
2446                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2447                     } else {
2448                         dimAnnotations.append(maybeDimAnnos);
2449                         dims.append(parseExpression());
2450                         accept(RBRACKET);
2451                     }
2452                 }
2453             }
2454 
2455             List&lt;JCExpression&gt; elems = null;
2456             int errpos = token.pos;
2457 
2458             if (token.kind == LBRACE) {
2459                 elems = arrayInitializerElements(newpos, elemtype);
2460             }
2461 
2462             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2463             na.dimAnnotations = dimAnnotations.toList();
2464 
2465             if (elems != null) {
2466                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2467             }
2468 
2469             return na;
2470         }
2471     }
2472 
2473     /** ClassCreatorRest = Arguments [ClassBody]
2474      */
2475     JCNewClass classCreatorRest(int newpos,
2476                                   JCExpression encl,
2477                                   List&lt;JCExpression&gt; typeArgs,
2478                                   JCExpression t,
2479                                   long flags)
2480     {
2481         List&lt;JCExpression&gt; args = arguments();
2482         JCClassDecl body = null;
2483         if (token.kind == LBRACE) {
2484             int pos = token.pos;
2485             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2486             JCModifiers mods = F.at(Position.NOPOS).Modifiers(flags);
2487             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2488         }
2489         JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2490         return newClass;
2491     }
2492 
2493     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2494      */
2495     JCExpression arrayInitializer(int newpos, JCExpression t) {
2496         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2497         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2498     }
2499 
2500     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2501         accept(LBRACE);
2502         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2503         if (token.kind == COMMA) {
2504             nextToken();
2505         } else if (token.kind != RBRACE) {
2506             elems.append(variableInitializer());
2507             while (token.kind == COMMA) {
2508                 nextToken();
2509                 if (token.kind == RBRACE) break;
2510                 elems.append(variableInitializer());
2511             }
2512         }
2513         accept(RBRACE);
2514         return elems.toList();
2515     }
2516 
2517     /** VariableInitializer = ArrayInitializer | Expression
2518      */
2519     public JCExpression variableInitializer() {
2520         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2521     }
2522 
2523     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2524      */
2525     JCExpression parExpression() {
2526         int pos = token.pos;
2527         accept(LPAREN);
2528         JCExpression t = parseExpression();
2529         accept(RPAREN);
2530         return toP(F.at(pos).Parens(t));
2531     }
2532 
2533     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2534      */
2535     JCBlock block(int pos, long flags) {
2536         accept(LBRACE);
2537         List&lt;JCStatement&gt; stats = blockStatements();
2538         JCBlock t = F.at(pos).Block(flags, stats);
2539         while (token.kind == CASE || token.kind == DEFAULT) {
2540             syntaxError(token.pos, Errors.Orphaned(token.kind));
2541             switchBlockStatementGroups();
2542         }
2543         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2544         // usually but not necessarily the last char of the last token.
2545         t.endpos = token.pos;
2546         accept(RBRACE);
2547         return toP(t);
2548     }
2549 
2550     public JCBlock block() {
2551         return block(token.pos, 0);
2552     }
2553 
2554     /** BlockStatements = { BlockStatement }
2555      *  BlockStatement  = LocalVariableDeclarationStatement
2556      *                  | ClassOrInterfaceOrEnumDeclaration
2557      *                  | [Ident &quot;:&quot;] Statement
2558      *  LocalVariableDeclarationStatement
2559      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2560      */
2561     @SuppressWarnings(&quot;fallthrough&quot;)
2562     List&lt;JCStatement&gt; blockStatements() {
2563         //todo: skip to anchor on error(?)
2564         int lastErrPos = -1;
2565         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2566         while (true) {
2567             List&lt;JCStatement&gt; stat = blockStatement();
2568             if (stat.isEmpty()) {
2569                 return stats.toList();
2570             } else {
2571                 // error recovery
2572                 if (token.pos == lastErrPos)
2573                     return stats.toList();
2574                 if (token.pos &lt;= endPosTable.errorEndPos) {
2575                     skip(false, true, true, true);
2576                     lastErrPos = token.pos;
2577                 }
2578                 stats.addAll(stat);
2579             }
2580         }
2581     }
2582 
2583     /*
2584      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2585      * this method will also recognize variable and class declarations (which are
2586      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2587      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2588      * and an error will be produced by this method.
2589      */
2590     JCStatement parseStatementAsBlock() {
2591         int pos = token.pos;
2592         List&lt;JCStatement&gt; stats = blockStatement();
2593         if (stats.isEmpty()) {
2594             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2595             return toP(F.at(pos).Exec(e));
2596         } else {
2597             JCStatement first = stats.head;
2598             Error error = null;
2599             switch (first.getTag()) {
2600             case CLASSDEF:
2601                 error = Errors.ClassNotAllowed;
2602                 break;
2603             case VARDEF:
2604                 error = Errors.VariableNotAllowed;
2605                 break;
2606             }
2607             if (error != null) {
2608                 log.error(DiagnosticFlag.SYNTAX, first, error);
2609                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2610                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2611             }
2612             return first;
2613         }
2614     }
2615 
2616     /**This method parses a statement appearing inside a block.
2617      */
2618     @SuppressWarnings(&quot;fallthrough&quot;)
2619     List&lt;JCStatement&gt; blockStatement() {
2620         //todo: skip to anchor on error(?)
2621         token = recastToken(token);
2622         Comment dc;
2623         int pos = token.pos;
2624         switch (token.kind) {
2625         case RBRACE: case CASE: case DEFAULT: case EOF:
2626             return List.nil();
2627         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2628         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2629         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2630         case ASSERT:
2631             return List.of(parseSimpleStatement());
2632         case VALUE:
2633         case MONKEYS_AT:
2634         case FINAL: {
2635             dc = token.comment(CommentStyle.JAVADOC);
2636             JCModifiers mods = modifiersOpt();
2637             if (token.kind == INTERFACE ||
2638                 token.kind == CLASS ||
2639                 token.kind == ENUM ||
2640                 isRecordStart()) {
2641                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2642             } else {
2643                 JCExpression t = parseType(true);
2644                 return localVariableDeclarations(mods, t);
2645             }
2646         }
2647         case ABSTRACT: case STRICTFP: {
2648             dc = token.comment(CommentStyle.JAVADOC);
2649             JCModifiers mods = modifiersOpt();
2650             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2651         }
2652         case INTERFACE:
2653         case CLASS:
2654             dc = token.comment(CommentStyle.JAVADOC);
2655             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2656         case ENUM:
2657             if (!allowRecords) {
2658                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2659             }
2660             dc = token.comment(CommentStyle.JAVADOC);
2661             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2662         case IDENTIFIER:
2663             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2664                 Token next = S.token(1);
2665                 boolean isYieldStatement;
2666                 switch (next.kind) {
2667                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2668                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2669                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2670                     case NEW: case SWITCH: case THIS: case SUPER:
2671                         isYieldStatement = true;
2672                         break;
2673                     case PLUSPLUS: case SUBSUB:
2674                         isYieldStatement = S.token(2).kind != SEMI;
2675                         break;
2676                     case LPAREN:
2677                         int lookahead = 2;
2678                         int balance = 1;
2679                         boolean hasComma = false;
2680                         Token l;
2681                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2682                             switch (l.kind) {
2683                                 case LPAREN: balance++; break;
2684                                 case RPAREN: balance--; break;
2685                                 case COMMA: if (balance == 1) hasComma = true; break;
2686                             }
2687                             lookahead++;
2688                         }
2689                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2690                         break;
2691                     case SEMI: //error recovery - this is not a valid statement:
2692                         isYieldStatement = true;
2693                         break;
2694                     default:
2695                         isYieldStatement = false;
2696                         break;
2697                 }
2698 
2699                 if (isYieldStatement) {
2700                     nextToken();
2701                     JCExpression t = term(EXPR);
2702                     accept(SEMI);
2703                     return List.of(toP(F.at(pos).Yield(t)));
2704                 }
2705 
2706                 //else intentional fall-through
<a name="3" id="anc3"></a>












2707             }
2708         }
2709         if (isRecordStart() &amp;&amp; allowRecords) {
2710             dc = token.comment(CommentStyle.JAVADOC);
2711             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2712         } else {
2713             Token prevToken = token;
2714             JCExpression t = term(EXPR | TYPE);
2715             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2716                 nextToken();
2717                 JCStatement stat = parseStatementAsBlock();
2718                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2719             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2720                 pos = token.pos;
2721                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2722                 F.at(pos);
2723                 return localVariableDeclarations(mods, t);
2724             } else {
2725                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2726                 t = checkExprStat(t);
2727                 accept(SEMI);
2728                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2729                 return List.of(expr);
2730             }
2731         }
2732     }
2733     //where
2734         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2735             ListBuffer&lt;JCStatement&gt; stats =
2736                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2737             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2738             accept(SEMI);
2739             storeEnd(stats.last(), S.prevToken().endPos);
2740             return stats.toList();
2741         }
2742 
2743     /** Statement =
2744      *       Block
2745      *     | IF ParExpression Statement [ELSE Statement]
2746      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2747      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2748      *     | WHILE ParExpression Statement
2749      *     | DO Statement WHILE ParExpression &quot;;&quot;
2750      *     | TRY Block ( Catches | [Catches] FinallyPart )
2751      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2752      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2753      *     | SYNCHRONIZED ParExpression Block
2754      *     | RETURN [Expression] &quot;;&quot;
2755      *     | THROW Expression &quot;;&quot;
2756      *     | BREAK [Ident] &quot;;&quot;
2757      *     | CONTINUE [Ident] &quot;;&quot;
2758      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2759      *     | &quot;;&quot;
2760      */
2761     public JCStatement parseSimpleStatement() {
2762         int pos = token.pos;
2763         switch (token.kind) {
2764         case LBRACE:
2765             return block();
2766         case IF: {
2767             nextToken();
2768             JCExpression cond = parExpression();
2769             JCStatement thenpart = parseStatementAsBlock();
2770             JCStatement elsepart = null;
2771             if (token.kind == ELSE) {
2772                 nextToken();
2773                 elsepart = parseStatementAsBlock();
2774             }
2775             return F.at(pos).If(cond, thenpart, elsepart);
2776         }
2777         case FOR: {
2778             nextToken();
2779             accept(LPAREN);
2780             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2781             if (inits.length() == 1 &amp;&amp;
2782                 inits.head.hasTag(VARDEF) &amp;&amp;
2783                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2784                 token.kind == COLON) {
2785                 JCVariableDecl var = (JCVariableDecl)inits.head;
2786                 accept(COLON);
2787                 JCExpression expr = parseExpression();
2788                 accept(RPAREN);
2789                 JCStatement body = parseStatementAsBlock();
2790                 return F.at(pos).ForeachLoop(var, expr, body);
2791             } else {
2792                 accept(SEMI);
2793                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2794                 accept(SEMI);
2795                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2796                 accept(RPAREN);
2797                 JCStatement body = parseStatementAsBlock();
2798                 return F.at(pos).ForLoop(inits, cond, steps, body);
2799             }
2800         }
2801         case WHILE: {
2802             nextToken();
2803             JCExpression cond = parExpression();
2804             JCStatement body = parseStatementAsBlock();
2805             return F.at(pos).WhileLoop(cond, body);
2806         }
2807         case DO: {
2808             nextToken();
2809             JCStatement body = parseStatementAsBlock();
2810             accept(WHILE);
2811             JCExpression cond = parExpression();
2812             accept(SEMI);
2813             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2814             return t;
2815         }
2816         case TRY: {
2817             nextToken();
2818             List&lt;JCTree&gt; resources = List.nil();
2819             if (token.kind == LPAREN) {
2820                 nextToken();
2821                 resources = resources();
2822                 accept(RPAREN);
2823             }
2824             JCBlock body = block();
2825             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2826             JCBlock finalizer = null;
2827             if (token.kind == CATCH || token.kind == FINALLY) {
2828                 while (token.kind == CATCH) catchers.append(catchClause());
2829                 if (token.kind == FINALLY) {
2830                     nextToken();
2831                     finalizer = block();
2832                 }
2833             } else {
2834                 if (resources.isEmpty()) {
2835                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2836                 }
2837             }
2838             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2839         }
2840         case SWITCH: {
2841             nextToken();
2842             JCExpression selector = parExpression();
2843             accept(LBRACE);
2844             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2845             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2846             accept(RBRACE);
2847             return t;
2848         }
2849         case SYNCHRONIZED: {
2850             nextToken();
2851             JCExpression lock = parExpression();
2852             JCBlock body = block();
2853             return F.at(pos).Synchronized(lock, body);
2854         }
2855         case RETURN: {
2856             nextToken();
2857             JCExpression result = token.kind == SEMI ? null : parseExpression();
2858             accept(SEMI);
2859             JCReturn t = toP(F.at(pos).Return(result));
2860             return t;
2861         }
2862         case THROW: {
2863             nextToken();
2864             JCExpression exc = parseExpression();
2865             accept(SEMI);
2866             JCThrow t = toP(F.at(pos).Throw(exc));
2867             return t;
2868         }
2869         case BREAK: {
2870             nextToken();
2871             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2872             accept(SEMI);
2873             JCBreak t = toP(F.at(pos).Break(label));
2874             return t;
2875         }
2876         case CONTINUE: {
2877             nextToken();
2878             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2879             accept(SEMI);
2880             JCContinue t =  toP(F.at(pos).Continue(label));
2881             return t;
2882         }
2883         case SEMI:
2884             nextToken();
2885             return toP(F.at(pos).Skip());
2886         case ELSE:
2887             int elsePos = token.pos;
2888             nextToken();
2889             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2890         case FINALLY:
2891             int finallyPos = token.pos;
2892             nextToken();
2893             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2894         case CATCH:
2895             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2896         case ASSERT: {
2897             nextToken();
2898             JCExpression assertion = parseExpression();
2899             JCExpression message = null;
2900             if (token.kind == COLON) {
2901                 nextToken();
2902                 message = parseExpression();
2903             }
2904             accept(SEMI);
2905             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2906             return t;
2907         }
2908         default:
2909             Assert.error();
2910             return null;
2911         }
2912     }
2913 
2914     @Override
2915     public JCStatement parseStatement() {
2916         return parseStatementAsBlock();
2917     }
2918 
2919     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2920         int errPos = S.errPos();
2921         JCTree stm = action.doRecover(this);
2922         S.errPos(errPos);
2923         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2924     }
2925 
2926     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2927      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2928      */
2929     protected JCCatch catchClause() {
2930         int pos = token.pos;
2931         accept(CATCH);
2932         accept(LPAREN);
2933         JCModifiers mods = optFinal(Flags.PARAMETER);
2934         List&lt;JCExpression&gt; catchTypes = catchTypes();
2935         JCExpression paramType = catchTypes.size() &gt; 1 ?
2936                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2937                 catchTypes.head;
2938         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2939         accept(RPAREN);
2940         JCBlock body = block();
2941         return F.at(pos).Catch(formal, body);
2942     }
2943 
2944     List&lt;JCExpression&gt; catchTypes() {
2945         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2946         catchTypes.add(parseType());
2947         while (token.kind == BAR) {
2948             nextToken();
2949             // Instead of qualident this is now parseType.
2950             // But would that allow too much, e.g. arrays or generics?
2951             catchTypes.add(parseType());
2952         }
2953         return catchTypes.toList();
2954     }
2955 
2956     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2957      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2958      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2959      */
2960     List&lt;JCCase&gt; switchBlockStatementGroups() {
2961         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2962         while (true) {
2963             int pos = token.pos;
2964             switch (token.kind) {
2965             case CASE:
2966             case DEFAULT:
2967                 cases.appendList(switchBlockStatementGroup());
2968                 break;
2969             case RBRACE: case EOF:
2970                 return cases.toList();
2971             default:
2972                 nextToken(); // to ensure progress
2973                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2974             }
2975         }
2976     }
2977 
2978     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2979         int pos = token.pos;
2980         List&lt;JCStatement&gt; stats;
2981         JCCase c;
2982         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2983         switch (token.kind) {
2984         case CASE: {
2985             nextToken();
2986             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2987             while (true) {
2988                 pats.append(term(EXPR | NOLAMBDA));
2989                 if (token.kind != COMMA) break;
2990                 nextToken();
2991                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2992             };
2993             CaseTree.CaseKind caseKind;
2994             JCTree body = null;
2995             if (token.kind == ARROW) {
2996                 checkSourceLevel(Feature.SWITCH_RULE);
2997                 accept(ARROW);
2998                 caseKind = JCCase.RULE;
2999                 JCStatement statement = parseStatementAsBlock();
3000                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3001                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3002                 }
3003                 stats = List.of(statement);
3004                 body = stats.head;
3005             } else {
3006                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3007                 caseKind = JCCase.STATEMENT;
3008                 stats = blockStatements();
3009             }
3010             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
3011             if (stats.isEmpty())
3012                 storeEnd(c, S.prevToken().endPos);
3013             return cases.append(c).toList();
3014         }
3015         case DEFAULT: {
3016             nextToken();
3017             CaseTree.CaseKind caseKind;
3018             JCTree body = null;
3019             if (token.kind == ARROW) {
3020                 checkSourceLevel(Feature.SWITCH_RULE);
3021                 accept(ARROW);
3022                 caseKind = JCCase.RULE;
3023                 JCStatement statement = parseStatementAsBlock();
3024                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
3025                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
3026                 }
3027                 stats = List.of(statement);
3028                 body = stats.head;
3029             } else {
3030                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3031                 caseKind = JCCase.STATEMENT;
3032                 stats = blockStatements();
3033             }
3034             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3035             if (stats.isEmpty())
3036                 storeEnd(c, S.prevToken().endPos);
3037             return cases.append(c).toList();
3038         }
3039         }
3040         throw new AssertionError(&quot;should not reach here&quot;);
3041     }
3042 
3043     /** MoreStatementExpressions = { COMMA StatementExpression }
3044      */
3045     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3046                                                                     JCExpression first,
3047                                                                     T stats) {
3048         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3049         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3050         while (token.kind == COMMA) {
3051             nextToken();
3052             pos = token.pos;
3053             JCExpression t = parseExpression();
3054             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3055             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3056         }
3057         return stats;
3058     }
3059 
3060     /** ForInit = StatementExpression MoreStatementExpressions
3061      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3062      */
3063     List&lt;JCStatement&gt; forInit() {
3064         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3065         int pos = token.pos;
3066         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3067             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3068         } else {
3069             JCExpression t = term(EXPR | TYPE);
3070             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3071                 pos = token.pos;
3072                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
3073                 F.at(pos);
3074                 return variableDeclarators(mods, t, stats, true).toList();
3075             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3076                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3077                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3078             } else {
3079                 return moreStatementExpressions(pos, t, stats).toList();
3080             }
3081         }
3082     }
3083 
3084     /** ForUpdate = StatementExpression MoreStatementExpressions
3085      */
3086     List&lt;JCExpressionStatement&gt; forUpdate() {
3087         return moreStatementExpressions(token.pos,
3088                                         parseExpression(),
3089                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3090     }
3091 
3092     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3093      *
3094      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3095      */
3096     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3097         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3098         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3099         int prevmode = mode;
3100         while (token.kind == MONKEYS_AT) {
3101             int pos = token.pos;
3102             nextToken();
3103             buf.append(annotation(pos, kind));
3104         }
3105         lastmode = mode;
3106         mode = prevmode;
3107         List&lt;JCAnnotation&gt; annotations = buf.toList();
3108 
3109         return annotations;
3110     }
3111 
3112     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3113         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3114         return annotations;
3115     }
3116 
3117     /** ModifiersOpt = { Modifier }
3118      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3119      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3120      *           | &quot;@&quot; Annotation
3121      */
3122     protected JCModifiers modifiersOpt() {
3123         return modifiersOpt(null);
3124     }
3125     protected JCModifiers modifiersOpt(JCModifiers partial) {
3126         long flags;
3127         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3128         int pos;
3129         if (partial == null) {
3130             flags = 0;
3131             pos = token.pos;
3132         } else {
3133             flags = partial.flags;
3134             annotations.appendList(partial.annotations);
3135             pos = partial.pos;
3136         }
3137         if (token.deprecatedFlag()) {
3138             flags |= Flags.DEPRECATED;
3139         }
3140         int lastPos;
3141     loop:
3142         while (true) {
3143             long flag;
3144             token = recastToken(token);
3145             switch (token.kind) {
3146             case PRIVATE     : flag = Flags.PRIVATE; break;
3147             case PROTECTED   : flag = Flags.PROTECTED; break;
3148             case PUBLIC      : flag = Flags.PUBLIC; break;
3149             case STATIC      : flag = Flags.STATIC; break;
3150             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3151             case FINAL       : flag = Flags.FINAL; break;
3152             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3153             case NATIVE      : flag = Flags.NATIVE; break;
3154             case VALUE       : flag = Flags.VALUE; break;
3155             case VOLATILE    : flag = Flags.VOLATILE; break;
3156             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3157             case STRICTFP    : flag = Flags.STRICTFP; break;
3158             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3159             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3160             case ERROR       : flag = 0; nextToken(); break;
<a name="4" id="anc4"></a>













3161             default: break loop;
3162             }
3163             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3164             lastPos = token.pos;
3165             nextToken();
3166             if (flag == Flags.ANNOTATION) {
3167                 if (token.kind != INTERFACE) {
3168                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3169                     // if first modifier is an annotation, set pos to annotation&#39;s.
3170                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3171                         pos = ann.pos;
3172                     final Name name = TreeInfo.name(ann.annotationType);
3173                     if (name == names.__inline__ || name == names.java_lang___inline__) {
3174                         flag = Flags.VALUE;
3175                     } else {
3176                         annotations.append(ann);
3177                         flag = 0;
3178                     }
3179                 }
3180             }
3181             flags |= flag;
3182         }
3183         switch (token.kind) {
3184         case ENUM: flags |= Flags.ENUM; break;
3185         case INTERFACE: flags |= Flags.INTERFACE; break;
3186         default: break;
3187         }
3188 
3189         /* A modifiers tree with no modifier tokens or annotations
3190          * has no text position. */
3191         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3192             pos = Position.NOPOS;
3193 
3194         // Force value classes to be automatically final.
3195         if ((flags &amp; (Flags.VALUE | Flags.ABSTRACT | Flags.INTERFACE | Flags.ENUM)) == Flags.VALUE) {
3196             flags |= Flags.FINAL;
3197         }
3198 
3199         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3200         if (pos != Position.NOPOS)
3201             storeEnd(mods, S.prevToken().endPos);
3202         return mods;
3203     }
3204 
3205     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3206      *
3207      * @param pos position of &quot;@&quot; token
3208      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3209      */
3210     JCAnnotation annotation(int pos, Tag kind) {
3211         // accept(AT); // AT consumed by caller
3212         if (kind == Tag.TYPE_ANNOTATION) {
3213             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3214         }
3215         JCTree ident = qualident(false);
3216         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3217         JCAnnotation ann;
3218         if (kind == Tag.ANNOTATION) {
3219             ann = F.at(pos).Annotation(ident, fieldValues);
3220         } else if (kind == Tag.TYPE_ANNOTATION) {
3221             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3222         } else {
3223             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3224         }
3225 
3226         storeEnd(ann, S.prevToken().endPos);
3227         return ann;
3228     }
3229 
3230     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3231         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3232     }
3233 
3234     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3235     List&lt;JCExpression&gt; annotationFieldValues() {
3236         accept(LPAREN);
3237         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3238         if (token.kind != RPAREN) {
3239             buf.append(annotationFieldValue());
3240             while (token.kind == COMMA) {
3241                 nextToken();
3242                 buf.append(annotationFieldValue());
3243             }
3244         }
3245         accept(RPAREN);
3246         return buf.toList();
3247     }
3248 
3249     /** AnnotationFieldValue    = AnnotationValue
3250      *                          | Identifier &quot;=&quot; AnnotationValue
3251      */
3252     JCExpression annotationFieldValue() {
3253         if (LAX_IDENTIFIER.accepts(token.kind)) {
3254             selectExprMode();
3255             JCExpression t1 = term1();
3256             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3257                 int pos = token.pos;
3258                 accept(EQ);
3259                 JCExpression v = annotationValue();
3260                 return toP(F.at(pos).Assign(t1, v));
3261             } else {
3262                 return t1;
3263             }
3264         }
3265         return annotationValue();
3266     }
3267 
3268     /* AnnotationValue          = ConditionalExpression
3269      *                          | Annotation
3270      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3271      */
3272     JCExpression annotationValue() {
3273         int pos;
3274         switch (token.kind) {
3275         case MONKEYS_AT:
3276             pos = token.pos;
3277             nextToken();
3278             return annotation(pos, Tag.ANNOTATION);
3279         case LBRACE:
3280             pos = token.pos;
3281             accept(LBRACE);
3282             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3283             if (token.kind == COMMA) {
3284                 nextToken();
3285             } else if (token.kind != RBRACE) {
3286                 buf.append(annotationValue());
3287                 while (token.kind == COMMA) {
3288                     nextToken();
3289                     if (token.kind == RBRACE) break;
3290                     buf.append(annotationValue());
3291                 }
3292             }
3293             accept(RBRACE);
3294             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3295         default:
3296             selectExprMode();
3297             return term1();
3298         }
3299     }
3300 
3301     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3302      */
3303     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3304                                                                          JCExpression type,
3305                                                                          T vdefs,
3306                                                                          boolean localDecl)
3307     {
3308         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3309     }
3310 
3311     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3312      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3313      *
3314      *  @param reqInit  Is an initializer always required?
3315      *  @param dc       The documentation comment for the variable declarations, or null.
3316      */
3317     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3318                                                                      JCModifiers mods,
3319                                                                      JCExpression type,
3320                                                                      Name name,
3321                                                                      boolean reqInit,
3322                                                                      Comment dc,
3323                                                                      T vdefs,
3324                                                                      boolean localDecl)
3325     {
3326         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3327         vdefs.append(head);
3328         while (token.kind == COMMA) {
3329             // All but last of multiple declarators subsume a comma
3330             storeEnd((JCTree)vdefs.last(), token.endPos);
3331             nextToken();
3332             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3333         }
3334         return vdefs;
3335     }
3336 
3337     /** VariableDeclarator = Ident VariableDeclaratorRest
3338      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3339      */
3340     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3341         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3342     }
3343 
3344     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3345      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3346      *
3347      *  @param reqInit  Is an initializer always required?
3348      *  @param dc       The documentation comment for the variable declarations, or null.
3349      */
3350     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3351                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3352         type = bracketsOpt(type);
3353         JCExpression init = null;
3354         if (token.kind == EQ) {
3355             nextToken();
3356             init = variableInitializer();
3357         }
3358         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3359         JCTree elemType = TreeInfo.innermostType(type, true);
3360         int startPos = Position.NOPOS;
3361         if (elemType.hasTag(IDENT)) {
3362             Name typeName = ((JCIdent)elemType).name;
3363             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3364                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3365                     //error - &#39;var&#39; and arrays
3366                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3367                 } else {
3368                     if(compound)
3369                         //error - &#39;var&#39; in compound local var decl
3370                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3371                     startPos = TreeInfo.getStartPos(mods);
3372                     if (startPos == Position.NOPOS)
3373                         startPos = TreeInfo.getStartPos(type);
3374                     //implicit type
3375                     type = null;
3376                 }
3377             }
3378         }
3379         JCVariableDecl result =
3380             toP(F.at(pos).VarDef(mods, name, type, init));
3381         attach(result, dc);
3382         result.startPos = startPos;
3383         return result;
3384     }
3385 
3386     // Does the given token signal an inline modifier ? If yes, suitably reclassify token.
3387     Token recastToken(Token token) {
3388         if (token.kind != IDENTIFIER || token.name() != names.inline) {
3389             return token;
3390         }
3391         if (peekToken(t-&gt;t == PRIVATE ||
3392                          t == PROTECTED ||
3393                          t == PUBLIC ||
3394                          t == STATIC ||
3395                          t == TRANSIENT ||
3396                          t == FINAL ||
3397                          t == ABSTRACT ||
3398                          t == NATIVE ||
3399                          t == VOLATILE ||
3400                          t == SYNCHRONIZED ||
3401                          t == STRICTFP ||
3402                          t == MONKEYS_AT ||
3403                          t == DEFAULT ||
3404                          t == BYTE ||
3405                          t == SHORT ||
3406                          t == CHAR ||
3407                          t == INT ||
3408                          t == LONG ||
3409                          t == FLOAT ||
3410                          t == DOUBLE ||
3411                          t == BOOLEAN ||
3412                          t == CLASS ||
3413                          t == INTERFACE ||
3414                          t == ENUM ||
3415                          t == IDENTIFIER)) { // new value Comparable() {}
3416             checkSourceLevel(Feature.INLINE_TYPES);
3417             return new Token(VALUE, token.pos, token.endPos, token.comments);
3418         }
3419         return token;
3420     }
3421 
3422     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3423         switch (e.getTag()) {
3424             case IDENT:
3425                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3426             case TYPEARRAY:
3427                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3428             default:
3429                 return null;
3430         }
3431     }
3432 
3433     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3434         if (name == names.var) {
3435             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3436                 return Source.JDK10;
3437             } else if (shouldWarn) {
3438                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3439             }
3440         }
3441         if (name == names.yield) {
3442             if (allowYieldStatement) {
3443                 return Source.JDK14;
3444             } else if (shouldWarn) {
3445                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3446             }
3447         }
3448         if (name == names.record) {
3449             if (allowRecords) {
3450                 return Source.JDK14;
3451             } else if (shouldWarn) {
3452                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3453             }
3454         }
<a name="5" id="anc5"></a>






3455         return null;
3456     }
3457 
3458     /** VariableDeclaratorId = Ident BracketsOpt
3459      */
3460     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3461         return variableDeclaratorId(mods, type, false);
3462     }
3463     //where
3464     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3465         int pos = token.pos;
3466         Name name;
3467         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3468             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3469             name = token.name();
3470             nextToken();
3471         } else {
3472             if (allowThisIdent ||
3473                 !lambdaParameter ||
3474                 LAX_IDENTIFIER.accepts(token.kind) ||
3475                 mods.flags != Flags.PARAMETER ||
3476                 mods.annotations.nonEmpty()) {
3477                 JCExpression pn = qualident(false);
3478                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3479                     name = ((JCIdent)pn).name;
3480                 } else {
3481                     if (allowThisIdent) {
3482                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3483                             log.error(token.pos, Errors.VarargsAndReceiver);
3484                         }
3485                         if (token.kind == LBRACKET) {
3486                             log.error(token.pos, Errors.ArrayAndReceiver);
3487                         }
3488                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3489                             log.error(token.pos, Errors.WrongReceiver);
3490                         }
3491                     }
3492                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3493                 }
3494             } else {
3495                 /** if it is a lambda parameter and the token kind is not an identifier,
3496                  *  and there are no modifiers or annotations, then this means that the compiler
3497                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3498                  *  var or explicit parameters. So we assign the error name to the parameter name
3499                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3500                  *  a higher level.
3501                  */
3502                 name = names.empty;
3503             }
3504         }
3505         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3506                 token.kind == LBRACKET) {
3507             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3508         }
3509         type = bracketsOpt(type);
3510 
3511         return toP(F.at(pos).VarDef(mods, name, type, null));
3512     }
3513 
3514     /** Resources = Resource { &quot;;&quot; Resources }
3515      */
3516     List&lt;JCTree&gt; resources() {
3517         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3518         defs.append(resource());
3519         while (token.kind == SEMI) {
3520             // All but last of multiple declarators must subsume a semicolon
3521             storeEnd(defs.last(), token.endPos);
3522             int semiColonPos = token.pos;
3523             nextToken();
3524             if (token.kind == RPAREN) { // Optional trailing semicolon
3525                                        // after last resource
3526                 break;
3527             }
3528             defs.append(resource());
3529         }
3530         return defs.toList();
3531     }
3532 
3533     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3534      *           | Expression
3535      */
3536     protected JCTree resource() {
3537         int startPos = token.pos;
3538         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3539             JCModifiers mods = optFinal(Flags.FINAL);
3540             JCExpression t = parseType(true);
3541             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3542         }
3543         JCExpression t = term(EXPR | TYPE);
3544         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3545             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3546             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3547         } else {
3548             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3549             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3550                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3551             }
3552 
3553             return t;
3554         }
3555     }
3556 
3557     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3558      */
3559     public JCTree.JCCompilationUnit parseCompilationUnit() {
3560         Token firstToken = token;
3561         JCModifiers mods = null;
3562         boolean consumedToplevelDoc = false;
3563         boolean seenImport = false;
3564         boolean seenPackage = false;
3565         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3566         if (token.kind == MONKEYS_AT)
3567             mods = modifiersOpt();
3568 
3569         if (token.kind == PACKAGE) {
3570             int packagePos = token.pos;
3571             List&lt;JCAnnotation&gt; annotations = List.nil();
3572             seenPackage = true;
3573             if (mods != null) {
3574                 checkNoMods(mods.flags);
3575                 annotations = mods.annotations;
3576                 mods = null;
3577             }
3578             nextToken();
3579             JCExpression pid = qualident(false);
3580             accept(SEMI);
3581             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3582             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3583             consumedToplevelDoc = true;
3584             defs.append(pd);
3585         }
3586 
3587         boolean checkForImports = true;
3588         boolean firstTypeDecl = true;
3589         while (token.kind != EOF) {
3590             if (token.pos &lt;= endPosTable.errorEndPos) {
3591                 // error recovery
3592                 skip(checkForImports, false, false, false);
3593                 if (token.kind == EOF)
3594                     break;
3595             }
3596             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3597                 seenImport = true;
3598                 defs.append(importDeclaration());
3599             } else {
3600                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3601                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3602                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3603                     consumedToplevelDoc = true;
3604                 }
3605                 if (mods != null || token.kind != SEMI)
3606                     mods = modifiersOpt(mods);
3607                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3608                     ModuleKind kind = ModuleKind.STRONG;
3609                     if (token.name() == names.open) {
3610                         kind = ModuleKind.OPEN;
3611                         nextToken();
3612                     }
3613                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3614                         if (mods != null) {
3615                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3616                         }
3617                         defs.append(moduleDecl(mods, kind, docComment));
3618                         consumedToplevelDoc = true;
3619                         break;
3620                     } else if (kind != ModuleKind.STRONG) {
3621                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3622                     }
3623                 }
3624                 JCTree def = typeDeclaration(mods, docComment);
3625                 if (def instanceof JCExpressionStatement)
3626                     def = ((JCExpressionStatement)def).expr;
3627                 defs.append(def);
3628                 if (def instanceof JCClassDecl)
3629                     checkForImports = false;
3630                 mods = null;
3631                 firstTypeDecl = false;
3632             }
3633         }
3634         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3635         if (!consumedToplevelDoc)
3636             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3637         if (defs.isEmpty())
3638             storeEnd(toplevel, S.prevToken().endPos);
3639         if (keepDocComments)
3640             toplevel.docComments = docComments;
3641         if (keepLineMap)
3642             toplevel.lineMap = S.getLineMap();
3643         this.endPosTable.setParser(null); // remove reference to parser
3644         toplevel.endPositions = this.endPosTable;
3645         return toplevel;
3646     }
3647 
3648     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3649         int pos = token.pos;
3650         checkSourceLevel(Feature.MODULES);
3651 
3652         nextToken();
3653         JCExpression name = qualident(false);
3654         List&lt;JCDirective&gt; directives = null;
3655 
3656         accept(LBRACE);
3657         directives = moduleDirectiveList();
3658         accept(RBRACE);
3659         accept(EOF);
3660 
3661         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3662         attach(result, dc);
3663         return result;
3664     }
3665 
3666     List&lt;JCDirective&gt; moduleDirectiveList() {
3667         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3668         while (token.kind == IDENTIFIER) {
3669             int pos = token.pos;
3670             if (token.name() == names.requires) {
3671                 nextToken();
3672                 boolean isTransitive = false;
3673                 boolean isStaticPhase = false;
3674             loop:
3675                 while (true) {
3676                     switch (token.kind) {
3677                         case IDENTIFIER:
3678                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3679                                 Token t1 = S.token(1);
3680                                 if (t1.kind == SEMI || t1.kind == DOT) {
3681                                     break loop;
3682                                 }
3683                                 isTransitive = true;
3684                                 break;
3685                             } else {
3686                                 break loop;
3687                             }
3688                         case STATIC:
3689                             if (isStaticPhase) {
3690                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3691                             }
3692                             isStaticPhase = true;
3693                             break;
3694                         default:
3695                             break loop;
3696                     }
3697                     nextToken();
3698                 }
3699                 JCExpression moduleName = qualident(false);
3700                 accept(SEMI);
3701                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3702             } else if (token.name() == names.exports || token.name() == names.opens) {
3703                 boolean exports = token.name() == names.exports;
3704                 nextToken();
3705                 JCExpression pkgName = qualident(false);
3706                 List&lt;JCExpression&gt; moduleNames = null;
3707                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3708                     nextToken();
3709                     moduleNames = qualidentList(false);
3710                 }
3711                 accept(SEMI);
3712                 JCDirective d;
3713                 if (exports) {
3714                     d = F.at(pos).Exports(pkgName, moduleNames);
3715                 } else {
3716                     d = F.at(pos).Opens(pkgName, moduleNames);
3717                 }
3718                 defs.append(toP(d));
3719             } else if (token.name() == names.provides) {
3720                 nextToken();
3721                 JCExpression serviceName = qualident(false);
3722                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3723                     nextToken();
3724                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3725                     accept(SEMI);
3726                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3727                 } else {
3728                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3729                     skip(false, false, false, false);
3730                 }
3731             } else if (token.name() == names.uses) {
3732                 nextToken();
3733                 JCExpression service = qualident(false);
3734                 accept(SEMI);
3735                 defs.append(toP(F.at(pos).Uses(service)));
3736             } else {
3737                 setErrorEndPos(pos);
3738                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3739                 break;
3740             }
3741         }
3742         return defs.toList();
3743     }
3744 
3745     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3746      */
3747     protected JCTree importDeclaration() {
3748         int pos = token.pos;
3749         nextToken();
3750         boolean importStatic = false;
3751         if (token.kind == STATIC) {
3752             importStatic = true;
3753             nextToken();
3754         }
3755         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3756         do {
3757             int pos1 = token.pos;
3758             accept(DOT);
3759             if (token.kind == STAR) {
3760                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3761                 nextToken();
3762                 break;
3763             } else {
3764                 pid = toP(F.at(pos1).Select(pid, ident()));
3765             }
3766         } while (token.kind == DOT);
3767         accept(SEMI);
3768         return toP(F.at(pos).Import(pid, importStatic));
3769     }
3770 
3771     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3772      *                  | &quot;;&quot;
3773      */
3774     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3775         int pos = token.pos;
3776         if (mods == null &amp;&amp; token.kind == SEMI) {
3777             nextToken();
3778             return toP(F.at(pos).Skip());
3779         } else {
3780             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3781         }
3782     }
3783 
3784     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3785      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3786      *  @param mods     Any modifiers starting the class or interface declaration
3787      *  @param dc       The documentation comment for the class, or null.
3788      */
3789     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3790         if (token.kind == CLASS) {
3791             return classDeclaration(mods, dc);
3792         } if (isRecordStart()) {
3793             return recordDeclaration(mods, dc);
3794         } else if (token.kind == INTERFACE) {
3795             return interfaceDeclaration(mods, dc);
3796         } else if (token.kind == ENUM) {
3797             return enumDeclaration(mods, dc);
3798         } else {
3799             int pos = token.pos;
3800             List&lt;JCTree&gt; errs;
3801             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3802                 checkSourceLevel(Feature.RECORDS);
3803                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3804                 return toP(F.Exec(erroneousTree));
3805             } else {
3806                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3807                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3808                     setErrorEndPos(token.pos);
3809                 } else {
3810                     errs = List.of(mods);
3811                 }
3812                 final JCErroneous erroneousTree;
3813                 if (parseModuleInfo) {
3814                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3815                 } else {
3816                     if (allowRecords) {
3817                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3818                     } else {
3819                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3820                     }
3821                 }
3822                 return toP(F.Exec(erroneousTree));
3823             }
3824         }
3825     }
3826 
3827     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3828      *                     [IMPLEMENTS TypeList] ClassBody
3829      *  @param mods    The modifiers starting the class declaration
3830      *  @param dc       The documentation comment for the class, or null.
3831      */
3832     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3833         int pos = token.pos;
3834         accept(CLASS);
3835         Name name = typeName();
3836 
3837         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3838 
3839         JCExpression extending = null;
3840         if (token.kind == EXTENDS) {
3841             nextToken();
3842             extending = parseType();
3843         }
3844         List&lt;JCExpression&gt; implementing = List.nil();
3845         if (token.kind == IMPLEMENTS) {
3846             nextToken();
3847             implementing = typeList();
3848         }
<a name="6" id="anc6"></a>








3849         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3850         JCClassDecl result = toP(F.at(pos).ClassDef(
<a name="7" id="anc7"></a><span class="line-modified">3851             mods, name, typarams, extending, implementing, defs));</span>
3852         attach(result, dc);
3853         return result;
3854     }
3855 
3856     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3857         int pos = token.pos;
3858         nextToken();
3859         mods.flags |= Flags.RECORD;
3860         Name name = typeName();
3861 
3862         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3863 
3864         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3865 
3866         List&lt;JCExpression&gt; implementing = List.nil();
3867         if (token.kind == IMPLEMENTS) {
3868             nextToken();
3869             implementing = typeList();
3870         }
3871         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3872         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3873         for (JCVariableDecl field : headerFields) {
3874             fields.add(field);
3875         }
3876         for (JCTree def : defs) {
3877             if (def.hasTag(METHODDEF)) {
3878                 JCMethodDecl methDef = (JCMethodDecl) def;
3879                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3880                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3881                     for (JCVariableDecl param : headerFields) {
3882                         tmpParams.add(F.at(param)
3883                                 // we will get flags plus annotations from the record component
3884                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3885                                 param.name, param.vartype, null));
3886                     }
3887                     methDef.params = tmpParams.toList();
3888                 }
3889             }
3890         }
3891         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3892             JCVariableDecl field = fields.get(i);
3893             defs = defs.prepend(field);
3894         }
3895         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3896         attach(result, dc);
3897         return result;
3898     }
3899 
3900     Name typeName() {
3901         int pos = token.pos;
3902         Name name = ident();
3903         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3904         if (source != null) {
3905             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3906         }
3907         return name;
3908     }
3909 
3910     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3911      *                         [EXTENDS TypeList] InterfaceBody
3912      *  @param mods    The modifiers starting the interface declaration
3913      *  @param dc       The documentation comment for the interface, or null.
3914      */
3915     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3916         int pos = token.pos;
3917         accept(INTERFACE);
3918 
3919         Name name = typeName();
3920 
3921         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3922 
3923         List&lt;JCExpression&gt; extending = List.nil();
3924         if (token.kind == EXTENDS) {
3925             nextToken();
3926             extending = typeList();
3927         }
<a name="8" id="anc8"></a><span class="line-modified">3928         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);</span>










3929         JCClassDecl result = toP(F.at(pos).ClassDef(
<a name="9" id="anc9"></a><span class="line-modified">3930             mods, name, typarams, null, extending, defs));</span>
3931         attach(result, dc);
3932         return result;
3933     }
3934 
3935     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3936      *  @param mods    The modifiers starting the enum declaration
3937      *  @param dc       The documentation comment for the enum, or null.
3938      */
3939     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3940         int pos = token.pos;
3941         accept(ENUM);
3942 
3943         Name name = typeName();
3944 
3945         List&lt;JCExpression&gt; implementing = List.nil();
3946         if (token.kind == IMPLEMENTS) {
3947             nextToken();
3948             implementing = typeList();
3949         }
3950 
3951         List&lt;JCTree&gt; defs = enumBody(name);
3952         mods.flags |= Flags.ENUM;
3953         JCClassDecl result = toP(F.at(pos).
3954             ClassDef(mods, name, List.nil(),
3955                      null, implementing, defs));
3956         attach(result, dc);
3957         return result;
3958     }
3959 
3960     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3961      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3962      */
3963     List&lt;JCTree&gt; enumBody(Name enumName) {
3964         accept(LBRACE);
3965         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3966         boolean wasSemi = false;
3967         boolean hasStructuralErrors = false;
3968         boolean wasError = false;
3969         if (token.kind == COMMA) {
3970             nextToken();
3971             if (token.kind == SEMI) {
3972                 wasSemi = true;
3973                 nextToken();
3974             } else if (token.kind != RBRACE) {
3975                 reportSyntaxError(S.prevToken().endPos,
3976                                   Errors.Expected2(RBRACE, SEMI));
3977                 wasError = true;
3978             }
3979         }
3980         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3981             if (token.kind == SEMI) {
3982                 accept(SEMI);
3983                 wasSemi = true;
3984                 if (token.kind == RBRACE || token.kind == EOF) break;
3985             }
3986             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3987             if (memberType == EnumeratorEstimate.UNKNOWN) {
3988                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3989                                      : EnumeratorEstimate.ENUMERATOR;
3990             }
3991             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3992                 wasError = false;
3993                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3994                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3995                     hasStructuralErrors = true;
3996                 }
3997                 defs.append(enumeratorDeclaration(enumName));
3998                 if (token.pos &lt;= endPosTable.errorEndPos) {
3999                     // error recovery
4000                    skip(false, true, true, false);
4001                 } else {
4002                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
4003                         if (token.kind == COMMA) {
4004                             nextToken();
4005                         } else {
4006                             setErrorEndPos(token.pos);
4007                             reportSyntaxError(S.prevToken().endPos,
4008                                               Errors.Expected3(COMMA, RBRACE, SEMI));
4009                             wasError = true;
4010                         }
4011                     }
4012                 }
4013             } else {
4014                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
4015                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
4016                     hasStructuralErrors = true;
4017                 }
4018                 wasError = false;
4019                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
4020                                                                 false, false));
4021                 if (token.pos &lt;= endPosTable.errorEndPos) {
4022                     // error recovery
4023                    skip(false, true, true, false);
4024                 }
4025             }
4026         }
4027         accept(RBRACE);
4028         return defs.toList();
4029     }
4030 
4031     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
4032         // if we are seeing a record declaration inside of an enum we want the same error message as expected for a
4033         // let&#39;s say an interface declaration inside an enum
4034         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName &amp;&amp;
4035                 (!allowRecords || !isRecordStart())) {
4036             Token next = S.token(1);
4037             switch (next.kind) {
4038                 case LPAREN: case LBRACE: case COMMA: case SEMI:
4039                     return EnumeratorEstimate.ENUMERATOR;
4040             }
4041         }
4042         switch (token.kind) {
4043             case IDENTIFIER: case MONKEYS_AT: case LT:
4044                 if (token.kind == IDENTIFIER) {
4045                     if (allowRecords &amp;&amp; isRecordStart()) {
4046                         return EnumeratorEstimate.MEMBER;
4047                     }
4048                 }
4049                 return EnumeratorEstimate.UNKNOWN;
4050             default:
4051                 return EnumeratorEstimate.MEMBER;
4052         }
4053     }
4054 
4055     private enum EnumeratorEstimate {
4056         ENUMERATOR,
4057         MEMBER,
4058         UNKNOWN;
4059     }
4060 
4061     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
4062      */
4063     JCTree enumeratorDeclaration(Name enumName) {
4064         Comment dc = token.comment(CommentStyle.JAVADOC);
4065         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
4066         if (token.deprecatedFlag()) {
4067             flags |= Flags.DEPRECATED;
4068         }
4069         int pos = token.pos;
4070         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
4071         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
4072         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
4073         int identPos = token.pos;
4074         Name name = ident();
4075         int createPos = token.pos;
4076         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
4077             ? arguments() : List.nil();
4078         JCClassDecl body = null;
4079         if (token.kind == LBRACE) {
4080             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
4081             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
4082             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
4083         }
4084         if (args.isEmpty() &amp;&amp; body == null)
4085             createPos = identPos;
4086         JCIdent ident = F.at(identPos).Ident(enumName);
4087         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4088         if (createPos != identPos)
4089             storeEnd(create, S.prevToken().endPos);
4090         ident = F.at(identPos).Ident(enumName);
4091         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4092         attach(result, dc);
4093         return result;
4094     }
4095 
4096     /** TypeList = Type {&quot;,&quot; Type}
4097      */
4098     List&lt;JCExpression&gt; typeList() {
4099         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4100         ts.append(parseType());
4101         while (token.kind == COMMA) {
4102             nextToken();
4103             ts.append(parseType());
4104         }
4105         return ts.toList();
4106     }
4107 
4108     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4109      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4110      */
4111     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4112         accept(LBRACE);
4113         if (token.pos &lt;= endPosTable.errorEndPos) {
4114             // error recovery
4115             skip(false, true, false, false);
4116             if (token.kind == LBRACE)
4117                 nextToken();
4118         }
4119         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4120         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4121             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4122             if (token.pos &lt;= endPosTable.errorEndPos) {
4123                // error recovery
4124                skip(false, true, true, false);
4125            }
4126         }
4127         accept(RBRACE);
4128         return defs.toList();
4129     }
4130 
4131     /** ClassBodyDeclaration =
4132      *      &quot;;&quot;
4133      *    | [STATIC] Block
4134      *    | ModifiersOpt
4135      *      ( Type Ident
4136      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4137      *      | VOID Ident VoidMethodDeclaratorRest
4138      *      | TypeParameters [Annotations]
4139      *        ( Type Ident MethodDeclaratorRest
4140      *        | VOID Ident VoidMethodDeclaratorRest
4141      *        )
4142      *      | Ident ConstructorDeclaratorRest
4143      *      | TypeParameters Ident ConstructorDeclaratorRest
4144      *      | ClassOrInterfaceOrEnumDeclaration
4145      *      )
4146      *  InterfaceBodyDeclaration =
4147      *      &quot;;&quot;
4148      *    | ModifiersOpt
4149      *      ( Type Ident
4150      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4151      *      | VOID Ident MethodDeclaratorRest
4152      *      | TypeParameters [Annotations]
4153      *        ( Type Ident MethodDeclaratorRest
4154      *        | VOID Ident VoidMethodDeclaratorRest
4155      *        )
4156      *      | ClassOrInterfaceOrEnumDeclaration
4157      *      )
4158      *
4159      */
4160     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4161         if (token.kind == SEMI) {
4162             nextToken();
4163             return List.nil();
4164         } else {
4165             Comment dc = token.comment(CommentStyle.JAVADOC);
4166             int pos = token.pos;
4167             JCModifiers mods = modifiersOpt();
4168             if (token.kind == CLASS ||
4169                 allowRecords &amp;&amp; isRecordStart() ||
4170                 token.kind == INTERFACE ||
4171                 token.kind == ENUM) {
4172                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4173             } else if (token.kind == LBRACE &amp;&amp;
4174                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4175                        mods.annotations.isEmpty()) {
4176                 if (isInterface) {
4177                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4178                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4179                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4180                 }
4181                 return List.of(block(pos, mods.flags));
4182             } else {
4183                 pos = token.pos;
4184                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4185                 // if there are type parameters but no modifiers, save the start
4186                 // position of the method in the modifiers.
4187                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4188                     mods.pos = pos;
4189                     storeEnd(mods, pos);
4190                 }
4191                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4192 
4193                 if (annosAfterParams.nonEmpty()) {
4194                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4195                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4196                     if (mods.pos == Position.NOPOS)
4197                         mods.pos = mods.annotations.head.pos;
4198                 }
4199 
4200                 Token tk = token;
4201                 pos = token.pos;
4202                 JCExpression type;
4203                 boolean isVoid = token.kind == VOID;
4204                 if (isVoid) {
4205                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4206                     nextToken();
4207                 } else {
4208                     // method returns types are un-annotated types
4209                     type = unannotatedType(false);
4210                 }
4211                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4212                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4213                     if (isInterface || tk.name() != className)
4214                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4215                     else if (annosAfterParams.nonEmpty())
4216                         illegal(annosAfterParams.head.pos);
4217                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4218                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4219                     }
4220                     return List.of(methodDeclaratorRest(
4221                         pos, mods, null, names.init, typarams,
4222                         isInterface, true, isRecord, dc));
4223                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4224                     // trying to define a compact constructor with a throws clause
4225                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4226                             Errors.InvalidCanonicalConstructorInRecord(
4227                                     Fragments.Compact,
4228                                     className,
4229                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4230                     skip(false, true, false, false);
4231                     return List.of(methodDeclaratorRest(
4232                             pos, mods, null, names.init, typarams,
4233                             isInterface, true, isRecord, dc));
4234                 } else {
4235                     pos = token.pos;
4236                     Name name = ident();
4237                     if (token.kind == LPAREN) {
4238                         return List.of(methodDeclaratorRest(
4239                             pos, mods, type, name, typarams,
4240                             isInterface, isVoid, false, dc));
4241                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4242                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4243                         List&lt;JCTree&gt; defs =
4244                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4245                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4246                         accept(SEMI);
4247                         storeEnd(defs.last(), S.prevToken().endPos);
4248                         return defs;
4249                     } else {
4250                             int errPos = pos;
4251                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4252                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4253                             accept(SEMI);
4254                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4255                         }
4256                     } else {
4257                         pos = token.pos;
4258                         List&lt;JCTree&gt; err;
4259                         if (isVoid || typarams.nonEmpty()) {
4260                             JCMethodDecl m =
4261                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4262                                                             List.nil(), List.nil(), null, null));
4263                             attach(m, dc);
4264                             err = List.of(m);
4265                         } else {
4266                             err = List.nil();
4267                         }
4268                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4269                     }
4270                 }
4271             }
4272         }
4273     }
4274 
4275     protected boolean isRecordStart() {
<a name="10" id="anc10"></a><span class="line-modified">4276      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
4277             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4278              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4279              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
<a name="11" id="anc11"></a><span class="line-modified">4280           checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">4281           return true;</span>
<span class="line-modified">4282     } else {</span>
<span class="line-modified">4283        return false;</span>
<span class="line-modified">4284    }</span>
<span class="line-modified">4285 }</span>














































4286 
4287     /** MethodDeclaratorRest =
4288      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4289      *  VoidMethodDeclaratorRest =
4290      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4291      *  ConstructorDeclaratorRest =
4292      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4293      */
4294     protected JCTree methodDeclaratorRest(int pos,
4295                               JCModifiers mods,
4296                               JCExpression type,
4297                               Name name,
4298                               List&lt;JCTypeParameter&gt; typarams,
4299                               boolean isInterface, boolean isVoid,
4300                               boolean isRecord,
4301                               Comment dc) {
4302         if (isInterface) {
4303             if ((mods.flags &amp; Flags.STATIC) != 0) {
4304                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4305             }
4306             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4307                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4308             }
4309         }
4310         JCVariableDecl prevReceiverParam = this.receiverParam;
4311         try {
4312             this.receiverParam = null;
4313             // Parsing formalParameters sets the receiverParam, if present
4314             List&lt;JCVariableDecl&gt; params = List.nil();
4315             List&lt;JCExpression&gt; thrown = List.nil();
4316             if (!isRecord || name != names.init || token.kind == LPAREN) {
4317                 params = formalParameters();
4318                 if (!isVoid) type = bracketsOpt(type);
4319                 if (token.kind == THROWS) {
4320                     nextToken();
4321                     thrown = qualidentList(true);
4322                 }
4323             }
4324             JCBlock body = null;
4325             JCExpression defaultValue;
4326             if (token.kind == LBRACE) {
4327                 body = block();
4328                 defaultValue = null;
4329             } else {
4330                 if (token.kind == DEFAULT) {
4331                     accept(DEFAULT);
4332                     defaultValue = annotationValue();
4333                 } else {
4334                     defaultValue = null;
4335                 }
4336                 accept(SEMI);
4337                 if (token.pos &lt;= endPosTable.errorEndPos) {
4338                     // error recovery
4339                     skip(false, true, false, false);
4340                     if (token.kind == LBRACE) {
4341                         body = block();
4342                     }
4343                 }
4344             }
4345 
4346             JCMethodDecl result =
4347                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4348                                             receiverParam, params, thrown,
4349                                             body, defaultValue));
4350             attach(result, dc);
4351             return result;
4352         } finally {
4353             this.receiverParam = prevReceiverParam;
4354         }
4355     }
4356 
4357     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4358      */
4359     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4360         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4361 
4362         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4363         JCExpression qi = qualident(allowAnnos);
4364         if (!typeAnnos.isEmpty()) {
4365             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4366             ts.append(at);
4367         } else {
4368             ts.append(qi);
4369         }
4370         while (token.kind == COMMA) {
4371             nextToken();
4372 
4373             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4374             qi = qualident(allowAnnos);
4375             if (!typeAnnos.isEmpty()) {
4376                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4377                 ts.append(at);
4378             } else {
4379                 ts.append(qi);
4380             }
4381         }
4382         return ts.toList();
4383     }
4384 
4385     /**
4386      *  {@literal
4387      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4388      *  }
4389      */
4390     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4391         if (token.kind == LT) {
4392             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4393             nextToken();
4394             typarams.append(typeParameter());
4395             while (token.kind == COMMA) {
4396                 nextToken();
4397                 typarams.append(typeParameter());
4398             }
4399             accept(GT);
4400             return typarams.toList();
4401         } else {
4402             return List.nil();
4403         }
4404     }
4405 
4406     /**
4407      *  {@literal
4408      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4409      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4410      *  TypeVariable = Ident
4411      *  }
4412      */
4413     JCTypeParameter typeParameter() {
4414         int pos = token.pos;
4415         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4416         Name name = typeName();
4417         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4418         if (token.kind == EXTENDS) {
4419             nextToken();
4420             bounds.append(parseType());
4421             while (token.kind == AMP) {
4422                 nextToken();
4423                 bounds.append(parseType());
4424             }
4425         }
4426         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4427     }
4428 
4429     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4430      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4431      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4432      */
4433     List&lt;JCVariableDecl&gt; formalParameters() {
4434         return formalParameters(false, false);
4435     }
4436     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4437         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4438         JCVariableDecl lastParam;
4439         accept(LPAREN);
4440         if (token.kind != RPAREN) {
4441             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4442             lastParam = formalParameter(lambdaParameters, recordComponents);
4443             if (lastParam.nameexpr != null) {
4444                 this.receiverParam = lastParam;
4445             } else {
4446                 params.append(lastParam);
4447             }
4448             this.allowThisIdent = false;
4449             while (token.kind == COMMA) {
4450                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4451                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4452                 }
4453                 nextToken();
4454                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4455             }
4456         }
4457         if (token.kind == RPAREN) {
4458             nextToken();
4459         } else {
4460             setErrorEndPos(token.pos);
4461             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4462         }
4463         return params.toList();
4464     }
4465 
4466     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4467         if (hasParens) {
4468             accept(LPAREN);
4469         }
4470         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4471         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4472             params.append(implicitParameter());
4473             while (token.kind == COMMA) {
4474                 nextToken();
4475                 params.append(implicitParameter());
4476             }
4477         }
4478         if (hasParens) {
4479             accept(RPAREN);
4480         }
4481         return params.toList();
4482     }
4483 
4484     JCModifiers optFinal(long flags) {
4485         JCModifiers mods = modifiersOpt();
4486         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4487         mods.flags |= flags;
4488         return mods;
4489     }
4490 
4491     /**
4492      * Inserts the annotations (and possibly a new array level)
4493      * to the left-most type in an array or nested type.
4494      *
4495      * When parsing a type like {@code @B Outer.Inner @A []}, the
4496      * {@code @A} annotation should target the array itself, while
4497      * {@code @B} targets the nested type {@code Outer}.
4498      *
4499      * Currently the parser parses the annotation first, then
4500      * the array, and then inserts the annotation to the left-most
4501      * nested type.
4502      *
4503      * When {@code createNewLevel} is true, then a new array
4504      * level is inserted as the most inner type, and have the
4505      * annotations target it.  This is useful in the case of
4506      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4507      * first parses the type {@code String @A []} then inserts
4508      * a new array level with {@code @B} annotation.
4509      */
4510     private JCExpression insertAnnotationsToMostInner(
4511             JCExpression type, List&lt;JCAnnotation&gt; annos,
4512             boolean createNewLevel) {
4513         int origEndPos = getEndPos(type);
4514         JCExpression mostInnerType = type;
4515         JCArrayTypeTree mostInnerArrayType = null;
4516         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4517             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4518             mostInnerType = mostInnerArrayType.elemtype;
4519         }
4520 
4521         if (createNewLevel) {
4522             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4523         }
4524 
4525         JCExpression mostInnerTypeToReturn = mostInnerType;
4526         if (annos.nonEmpty()) {
4527             JCExpression lastToModify = mostInnerType;
4528 
4529             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4530                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4531                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4532                     lastToModify = mostInnerType;
4533                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4534                 }
4535                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4536                     lastToModify = mostInnerType;
4537                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4538                 }
4539             }
4540 
4541             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4542 
4543             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4544                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4545             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4546                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4547             } else {
4548                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4549                 mostInnerTypeToReturn = mostInnerType;
4550             }
4551         }
4552 
4553         if (mostInnerArrayType == null) {
4554             return mostInnerTypeToReturn;
4555         } else {
4556             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4557             storeEnd(type, origEndPos);
4558             return type;
4559         }
4560     }
4561 
4562     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4563      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4564      */
4565     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4566         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4567         if (recordComponent &amp;&amp; mods.flags != 0) {
4568             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4569         }
4570         if (recordComponent) {
4571             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4572         }
4573         // need to distinguish between vararg annos and array annos
4574         // look at typeAnnotationsPushedBack comment
4575         this.permitTypeAnnotationsPushBack = true;
4576         JCExpression type = parseType(lambdaParameter);
4577         this.permitTypeAnnotationsPushBack = false;
4578 
4579         if (token.kind == ELLIPSIS) {
4580             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4581             typeAnnotationsPushedBack = List.nil();
4582             mods.flags |= Flags.VARARGS;
4583             // insert var arg type annotations
4584             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4585             nextToken();
4586         } else {
4587             // if not a var arg, then typeAnnotationsPushedBack should be null
4588             if (typeAnnotationsPushedBack.nonEmpty()) {
4589                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4590             }
4591             typeAnnotationsPushedBack = List.nil();
4592         }
4593         return variableDeclaratorId(mods, type, lambdaParameter);
4594     }
4595 
4596     protected JCVariableDecl implicitParameter() {
4597         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4598         return variableDeclaratorId(mods, null, true);
4599     }
4600 
4601 /* ---------- auxiliary methods -------------- */
4602     /** Check that given tree is a legal expression statement.
4603      */
4604     protected JCExpression checkExprStat(JCExpression t) {
4605         if (!TreeInfo.isExpressionStatement(t)) {
4606             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4607             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4608             return ret;
4609         } else {
4610             return t;
4611         }
4612     }
4613 
4614     /** Return precedence of operator represented by token,
4615      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4616      */
4617     static int prec(TokenKind token) {
4618         JCTree.Tag oc = optag(token);
4619         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4620     }
4621 
4622     /**
4623      * Return the lesser of two positions, making allowance for either one
4624      * being unset.
4625      */
4626     static int earlier(int pos1, int pos2) {
4627         if (pos1 == Position.NOPOS)
4628             return pos2;
4629         if (pos2 == Position.NOPOS)
4630             return pos1;
4631         return (pos1 &lt; pos2 ? pos1 : pos2);
4632     }
4633 
4634     /** Return operation tag of binary operator represented by token,
4635      *  No_TAG if token is not a binary operator.
4636      */
4637     static JCTree.Tag optag(TokenKind token) {
4638         switch (token) {
4639         case BARBAR:
4640             return OR;
4641         case AMPAMP:
4642             return AND;
4643         case BAR:
4644             return BITOR;
4645         case BAREQ:
4646             return BITOR_ASG;
4647         case CARET:
4648             return BITXOR;
4649         case CARETEQ:
4650             return BITXOR_ASG;
4651         case AMP:
4652             return BITAND;
4653         case AMPEQ:
4654             return BITAND_ASG;
4655         case EQEQ:
4656             return JCTree.Tag.EQ;
4657         case BANGEQ:
4658             return NE;
4659         case LT:
4660             return JCTree.Tag.LT;
4661         case GT:
4662             return JCTree.Tag.GT;
4663         case LTEQ:
4664             return LE;
4665         case GTEQ:
4666             return GE;
4667         case LTLT:
4668             return SL;
4669         case LTLTEQ:
4670             return SL_ASG;
4671         case GTGT:
4672             return SR;
4673         case GTGTEQ:
4674             return SR_ASG;
4675         case GTGTGT:
4676             return USR;
4677         case GTGTGTEQ:
4678             return USR_ASG;
4679         case PLUS:
4680             return JCTree.Tag.PLUS;
4681         case PLUSEQ:
4682             return PLUS_ASG;
4683         case SUB:
4684             return MINUS;
4685         case SUBEQ:
4686             return MINUS_ASG;
4687         case STAR:
4688             return MUL;
4689         case STAREQ:
4690             return MUL_ASG;
4691         case SLASH:
4692             return DIV;
4693         case SLASHEQ:
4694             return DIV_ASG;
4695         case PERCENT:
4696             return MOD;
4697         case PERCENTEQ:
4698             return MOD_ASG;
4699         case INSTANCEOF:
4700             return TYPETEST;
4701         default:
4702             return NO_TAG;
4703         }
4704     }
4705 
4706     /** Return operation tag of unary operator represented by token,
4707      *  No_TAG if token is not a binary operator.
4708      */
4709     static JCTree.Tag unoptag(TokenKind token) {
4710         switch (token) {
4711         case PLUS:
4712             return POS;
4713         case SUB:
4714             return NEG;
4715         case BANG:
4716             return NOT;
4717         case TILDE:
4718             return COMPL;
4719         case PLUSPLUS:
4720             return PREINC;
4721         case SUBSUB:
4722             return PREDEC;
4723         default:
4724             return NO_TAG;
4725         }
4726     }
4727 
4728     /** Return type tag of basic type represented by token,
4729      *  NONE if token is not a basic type identifier.
4730      */
4731     static TypeTag typetag(TokenKind token) {
4732         switch (token) {
4733         case BYTE:
4734             return TypeTag.BYTE;
4735         case CHAR:
4736             return TypeTag.CHAR;
4737         case SHORT:
4738             return TypeTag.SHORT;
4739         case INT:
4740             return TypeTag.INT;
4741         case LONG:
4742             return TypeTag.LONG;
4743         case FLOAT:
4744             return TypeTag.FLOAT;
4745         case DOUBLE:
4746             return TypeTag.DOUBLE;
4747         case BOOLEAN:
4748             return TypeTag.BOOLEAN;
4749         default:
4750             return TypeTag.NONE;
4751         }
4752     }
4753 
4754     void checkSourceLevel(Feature feature) {
4755         checkSourceLevel(token.pos, feature);
4756     }
4757 
4758     protected void checkSourceLevel(int pos, Feature feature) {
4759         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4760             //preview feature without --preview flag, error
4761             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4762         } else if (!feature.allowedInSource(source)) {
4763             //incompatible source level, error
4764             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4765         } else if (preview.isPreview(feature)) {
4766             //use of preview feature, warn
4767             preview.warnPreview(pos, feature);
4768         }
4769     }
4770 
4771     /*
4772      * a functional source tree and end position mappings
4773      */
4774     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4775 
4776         private final IntHashTable endPosMap;
4777 
4778         SimpleEndPosTable(JavacParser parser) {
4779             super(parser);
4780             endPosMap = new IntHashTable();
4781         }
4782 
4783         public void storeEnd(JCTree tree, int endpos) {
4784             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4785                                  endPosMap.lookup(tree));
4786         }
4787 
4788         protected &lt;T extends JCTree&gt; T to(T t) {
4789             storeEnd(t, parser.token.endPos);
4790             return t;
4791         }
4792 
4793         protected &lt;T extends JCTree&gt; T toP(T t) {
4794             storeEnd(t, parser.S.prevToken().endPos);
4795             return t;
4796         }
4797 
4798         public int getEndPos(JCTree tree) {
4799             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4800             // As long as Position.NOPOS==-1, this just returns value.
4801             return (value == -1) ? Position.NOPOS : value;
4802         }
4803 
4804         public int replaceTree(JCTree oldTree, JCTree newTree) {
4805             int pos = endPosMap.remove(oldTree);
4806             if (pos != -1) {
4807                 storeEnd(newTree, pos);
4808                 return pos;
4809             }
4810             return Position.NOPOS;
4811         }
4812     }
4813 
4814     /*
4815      * a default skeletal implementation without any mapping overhead.
4816      */
4817     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4818 
4819         EmptyEndPosTable(JavacParser parser) {
4820             super(parser);
4821         }
4822 
4823         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4824 
4825         protected &lt;T extends JCTree&gt; T to(T t) {
4826             return t;
4827         }
4828 
4829         protected &lt;T extends JCTree&gt; T toP(T t) {
4830             return t;
4831         }
4832 
4833         public int getEndPos(JCTree tree) {
4834             return Position.NOPOS;
4835         }
4836 
4837         public int replaceTree(JCTree oldTree, JCTree newTree) {
4838             return Position.NOPOS;
4839         }
4840 
4841     }
4842 
4843     protected static abstract class AbstractEndPosTable implements EndPosTable {
4844         /**
4845          * The current parser.
4846          */
4847         protected JavacParser parser;
4848 
4849         /**
4850          * Store the last error position.
4851          */
4852         public int errorEndPos = Position.NOPOS;
4853 
4854         public AbstractEndPosTable(JavacParser parser) {
4855             this.parser = parser;
4856         }
4857 
4858         /**
4859          * Store current token&#39;s ending position for a tree, the value of which
4860          * will be the greater of last error position and the ending position of
4861          * the current token.
4862          * @param t The tree.
4863          */
4864         protected abstract &lt;T extends JCTree&gt; T to(T t);
4865 
4866         /**
4867          * Store current token&#39;s ending position for a tree, the value of which
4868          * will be the greater of last error position and the ending position of
4869          * the previous token.
4870          * @param t The tree.
4871          */
4872         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4873 
4874         /**
4875          * Set the error position during the parsing phases, the value of which
4876          * will be set only if it is greater than the last stored error position.
4877          * @param errPos The error position
4878          */
4879         public void setErrorEndPos(int errPos) {
4880             if (errPos &gt; errorEndPos) {
4881                 errorEndPos = errPos;
4882             }
4883         }
4884 
4885         public void setParser(JavacParser parser) {
4886             this.parser = parser;
4887         }
4888     }
4889 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
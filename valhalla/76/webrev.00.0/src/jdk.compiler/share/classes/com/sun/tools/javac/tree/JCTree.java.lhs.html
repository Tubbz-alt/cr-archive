<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;
  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
  74  *
  75  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  76  * classes should, by convention, start with JC (javac).
  77  *
  78  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  79  * If you write code that depends on this, you do so at your own risk.
  80  * This code and its internal interfaces are subject to change or
  81  * deletion without notice.&lt;/b&gt;
  82  *
  83  * @see TreeMaker
  84  * @see TreeInfo
  85  * @see TreeTranslator
  86  * @see Pretty
  87  */
  88 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  89 
  90     /* Tree tag values, identifying kinds of trees */
  91     public enum Tag {
  92         /** For methods that return an invalid tag if a given condition is not met
  93          */
  94         NO_TAG,
  95 
  96         /** Toplevel nodes, of type TopLevel, representing entire source files.
  97         */
  98         TOPLEVEL,
  99 
 100         /** Package level definitions.
 101          */
 102         PACKAGEDEF,
 103 
 104         /** Import clauses, of type Import.
 105          */
 106         IMPORT,
 107 
 108         /** Class definitions, of type ClassDef.
 109          */
 110         CLASSDEF,
 111 
 112         /** Method definitions, of type MethodDef.
 113          */
 114         METHODDEF,
 115 
 116         /** Variable definitions, of type VarDef.
 117          */
 118         VARDEF,
 119 
 120         /** The no-op statement &quot;;&quot;, of type Skip
 121          */
 122         SKIP,
 123 
 124         /** Blocks, of type Block.
 125          */
 126         BLOCK,
 127 
 128         /** Do-while loops, of type DoLoop.
 129          */
 130         DOLOOP,
 131 
 132         /** While-loops, of type WhileLoop.
 133          */
 134         WHILELOOP,
 135 
 136         /** Withfields, of type WithField.
 137          */
 138         WITHFIELD,
 139 
 140         /** For-loops, of type ForLoop.
 141          */
 142         FORLOOP,
 143 
 144         /** Foreach-loops, of type ForeachLoop.
 145          */
 146         FOREACHLOOP,
 147 
 148         /** Labelled statements, of type Labelled.
 149          */
 150         LABELLED,
 151 
 152         /** Switch statements, of type Switch.
 153          */
 154         SWITCH,
 155 
 156         /** Case parts in switch statements/expressions, of type Case.
 157          */
 158         CASE,
 159 
 160         /** Switch expression statements, of type Switch.
 161          */
 162         SWITCH_EXPRESSION,
 163 
 164         /** Synchronized statements, of type Synchronized.
 165          */
 166         SYNCHRONIZED,
 167 
 168         /** Try statements, of type Try.
 169          */
 170         TRY,
 171 
 172         /** Catch clauses in try statements, of type Catch.
 173          */
 174         CATCH,
 175 
 176         /** Conditional expressions, of type Conditional.
 177          */
 178         CONDEXPR,
 179 
 180         /** Conditional statements, of type If.
 181          */
 182         IF,
 183 
 184         /** Expression statements, of type Exec.
 185          */
 186         EXEC,
 187 
 188         /** Break statements, of type Break.
 189          */
 190         BREAK,
 191 
 192         /** Yield statements, of type Yield.
 193          */
 194         YIELD,
 195 
 196         /** Continue statements, of type Continue.
 197          */
 198         CONTINUE,
 199 
 200         /** Return statements, of type Return.
 201          */
 202         RETURN,
 203 
 204         /** Throw statements, of type Throw.
 205          */
 206         THROW,
 207 
 208         /** Assert statements, of type Assert.
 209          */
 210         ASSERT,
 211 
 212         /** Method invocation expressions, of type Apply.
 213          */
 214         APPLY,
 215 
 216         /** Class instance creation expressions, of type NewClass.
 217          */
 218         NEWCLASS,
 219 
 220         /** Array creation expressions, of type NewArray.
 221          */
 222         NEWARRAY,
 223 
 224         /** Lambda expression, of type Lambda.
 225          */
 226         LAMBDA,
 227 
 228         /** Parenthesized subexpressions, of type Parens.
 229          */
 230         PARENS,
 231 
 232         /** Assignment expressions, of type Assign.
 233          */
 234         ASSIGN,
 235 
 236         /** Type cast expressions, of type TypeCast.
 237          */
 238         TYPECAST,
 239 
 240         /** Type test expressions, of type TypeTest.
 241          */
 242         TYPETEST,
 243 
 244         /** Patterns.
 245          */
 246         BINDINGPATTERN,
 247 
 248         /** Indexed array expressions, of type Indexed.
 249          */
 250         INDEXED,
 251 
 252         /** Selections, of type Select.
 253          */
 254         SELECT,
 255 
 256         /** Member references, of type Reference.
 257          */
 258         REFERENCE,
 259 
 260         /** Simple identifiers, of type Ident.
 261          */
 262         IDENT,
 263 
 264         /** Literals, of type Literal.
 265          */
 266         LITERAL,
 267 
 268         /** Basic type identifiers, of type TypeIdent.
 269          */
 270         TYPEIDENT,
 271 
 272         /** Array types, of type TypeArray.
 273          */
 274         TYPEARRAY,
 275 
 276         /** Parameterized types, of type TypeApply.
 277          */
 278         TYPEAPPLY,
 279 
 280         /** Union types, of type TypeUnion.
 281          */
 282         TYPEUNION,
 283 
 284         /** Intersection types, of type TypeIntersection.
 285          */
 286         TYPEINTERSECTION,
 287 
 288         /** Formal type parameters, of type TypeParameter.
 289          */
 290         TYPEPARAMETER,
 291 
 292         /** Type argument.
 293          */
 294         WILDCARD,
 295 
 296         /** Bound kind: extends, super, exact, or unbound
 297          */
 298         TYPEBOUNDKIND,
 299 
 300         /** metadata: Annotation.
 301          */
 302         ANNOTATION,
 303 
 304         /** metadata: Type annotation.
 305          */
 306         TYPE_ANNOTATION,
 307 
 308         /** metadata: Modifiers
 309          */
 310         MODIFIERS,
 311 
 312         /** An annotated type tree.
 313          */
 314         ANNOTATED_TYPE,
 315 
 316         /** Error trees, of type Erroneous.
 317          */
 318         ERRONEOUS,
 319 
 320         /** Unary operators, of type Unary.
 321          */
 322         POS,                             // +
 323         NEG,                             // -
 324         NOT,                             // !
 325         COMPL,                           // ~
 326         PREINC,                          // ++ _
 327         PREDEC,                          // -- _
 328         POSTINC,                         // _ ++
 329         POSTDEC,                         // _ --
 330 
 331         /** unary operator for null reference checks, only used internally.
 332          */
 333         NULLCHK,
 334 
 335         /** Binary operators, of type Binary.
 336          */
 337         OR,                              // ||
 338         AND,                             // &amp;&amp;
 339         BITOR,                           // |
 340         BITXOR,                          // ^
 341         BITAND,                          // &amp;
 342         EQ,                              // ==
 343         NE,                              // !=
 344         LT,                              // &lt;
 345         GT,                              // &gt;
 346         LE,                              // &lt;=
 347         GE,                              // &gt;=
 348         SL,                              // &lt;&lt;
 349         SR,                              // &gt;&gt;
 350         USR,                             // &gt;&gt;&gt;
 351         PLUS,                            // +
 352         MINUS,                           // -
 353         MUL,                             // *
 354         DIV,                             // /
 355         MOD,                             // %
 356 
 357         /** Assignment operators, of type Assignop.
 358          */
 359         BITOR_ASG(BITOR),                // |=
 360         BITXOR_ASG(BITXOR),              // ^=
 361         BITAND_ASG(BITAND),              // &amp;=
 362 
 363         SL_ASG(SL),                      // &lt;&lt;=
 364         SR_ASG(SR),                      // &gt;&gt;=
 365         USR_ASG(USR),                    // &gt;&gt;&gt;=
 366         PLUS_ASG(PLUS),                  // +=
 367         MINUS_ASG(MINUS),                // -=
 368         MUL_ASG(MUL),                    // *=
 369         DIV_ASG(DIV),                    // /=
 370         MOD_ASG(MOD),                    // %=
 371 
 372         MODULEDEF,
 373         EXPORTS,
 374         OPENS,
 375         PROVIDES,
 376         REQUIRES,
 377         USES,
 378 
 379         /** A synthetic let expression, of type LetExpr.
 380          */
 381         LETEXPR;                         // ala scheme
 382 
 383         private final Tag noAssignTag;
 384 
 385         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 386 
 387         private Tag(Tag noAssignTag) {
 388             this.noAssignTag = noAssignTag;
 389         }
 390 
 391         private Tag() {
 392             this(null);
 393         }
 394 
 395         public static int getNumberOfOperators() {
 396             return numberOfOperators;
 397         }
 398 
 399         public Tag noAssignOp() {
 400             if (noAssignTag != null)
 401                 return noAssignTag;
 402             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 403         }
 404 
 405         public boolean isPostUnaryOp() {
 406             return (this == POSTINC || this == POSTDEC);
 407         }
 408 
 409         public boolean isIncOrDecUnaryOp() {
 410             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 411         }
 412 
 413         public boolean isAssignop() {
 414             return noAssignTag != null;
 415         }
 416 
 417         public int operatorIndex() {
 418             return (this.ordinal() - POS.ordinal());
 419         }
 420     }
 421 
 422     /* The (encoded) position in the source file. @see util.Position.
 423      */
 424     public int pos;
 425 
 426     /* The type of this node.
 427      */
 428     public Type type;
 429 
 430     /* The tag of this node -- one of the constants declared above.
 431      */
 432     public abstract Tag getTag();
 433 
 434     /* Returns true if the tag of this node is equals to tag.
 435      */
 436     public boolean hasTag(Tag tag) {
 437         return tag == getTag();
 438     }
 439 
 440     /** Convert a tree to a pretty-printed string. */
 441     @Override
 442     public String toString() {
 443         StringWriter s = new StringWriter();
 444         try {
 445             new Pretty(s, false).printExpr(this);
 446         }
 447         catch (IOException e) {
 448             // should never happen, because StringWriter is defined
 449             // never to throw any IOExceptions
 450             throw new AssertionError(e);
 451         }
 452         return s.toString();
 453     }
 454 
 455     /** Set position field and return this tree.
 456      */
 457     public JCTree setPos(int pos) {
 458         this.pos = pos;
 459         return this;
 460     }
 461 
 462     /** Set type field and return this tree.
 463      */
 464     public JCTree setType(Type type) {
 465         this.type = type;
 466         return this;
 467     }
 468 
 469     /** Visit this tree with a given visitor.
 470      */
 471     public abstract void accept(Visitor v);
 472 
 473     @DefinedBy(Api.COMPILER_TREE)
 474     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 475 
 476     /** Return a shallow copy of this tree.
 477      */
 478     @Override
 479     public Object clone() {
 480         try {
 481             return super.clone();
 482         } catch(CloneNotSupportedException e) {
 483             throw new RuntimeException(e);
 484         }
 485     }
 486 
 487     /** Get a default position for this tree node.
 488      */
 489     public DiagnosticPosition pos() {
 490         return this;
 491     }
 492 
 493     // for default DiagnosticPosition
 494     public JCTree getTree() {
 495         return this;
 496     }
 497 
 498     // for default DiagnosticPosition
 499     public int getStartPosition() {
 500         return TreeInfo.getStartPos(this);
 501     }
 502 
 503     // for default DiagnosticPosition
 504     public int getPreferredPosition() {
 505         return pos;
 506     }
 507 
 508     // for default DiagnosticPosition
 509     public int getEndPosition(EndPosTable endPosTable) {
 510         return TreeInfo.getEndPos(this, endPosTable);
 511     }
 512 
 513     /**
 514      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 515      */
 516     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 517         /** All definitions in this file (ClassDef, Import, and Skip) */
 518         public List&lt;JCTree&gt; defs;
 519         /** The source file name. */
 520         public JavaFileObject sourcefile;
 521         /** The module to which this compilation unit belongs. */
 522         public ModuleSymbol modle;
 523         /** The location in which this compilation unit was found. */
 524         public Location locn;
 525         /** The package to which this compilation unit belongs. */
 526         public PackageSymbol packge;
 527         /** A scope containing top level classes. */
 528         public WriteableScope toplevelScope;
 529         /** A scope for all named imports. */
 530         public NamedImportScope namedImportScope;
 531         /** A scope for all import-on-demands. */
 532         public StarImportScope starImportScope;
 533         /** Line starting positions, defined only if option -g is set. */
 534         public Position.LineMap lineMap = null;
 535         /** A table that stores all documentation comments indexed by the tree
 536          * nodes they refer to. defined only if option -s is set. */
 537         public DocCommentTable docComments = null;
 538         /* An object encapsulating ending positions of source ranges indexed by
 539          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 540         public EndPosTable endPositions = null;
 541         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 542             this.defs = defs;
 543         }
 544         @Override
 545         public void accept(Visitor v) { v.visitTopLevel(this); }
 546 
 547         @DefinedBy(Api.COMPILER_TREE)
 548         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 549 
 550         public JCModuleDecl getModuleDecl() {
 551             for (JCTree tree : defs) {
 552                 if (tree.hasTag(MODULEDEF)) {
 553                     return (JCModuleDecl) tree;
 554                 }
 555             }
 556 
 557             return null;
 558         }
 559 
 560         @DefinedBy(Api.COMPILER_TREE)
 561         public JCPackageDecl getPackage() {
 562             // PackageDecl must be the first entry if it exists
 563             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 564                 return (JCPackageDecl)defs.head;
 565             return null;
 566         }
 567         @DefinedBy(Api.COMPILER_TREE)
 568         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 569             JCPackageDecl pd = getPackage();
 570             return pd != null ? pd.getAnnotations() : List.nil();
 571         }
 572         @DefinedBy(Api.COMPILER_TREE)
 573         public ExpressionTree getPackageName() {
 574             JCPackageDecl pd = getPackage();
 575             return pd != null ? pd.getPackageName() : null;
 576         }
 577 
 578         @DefinedBy(Api.COMPILER_TREE)
 579         public List&lt;JCImport&gt; getImports() {
 580             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 581             for (JCTree tree : defs) {
 582                 if (tree.hasTag(IMPORT))
 583                     imports.append((JCImport)tree);
 584                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 585                     break;
 586             }
 587             return imports.toList();
 588         }
 589         @DefinedBy(Api.COMPILER_TREE)
 590         public JavaFileObject getSourceFile() {
 591             return sourcefile;
 592         }
 593         @DefinedBy(Api.COMPILER_TREE)
 594         public Position.LineMap getLineMap() {
 595             return lineMap;
 596         }
 597         @DefinedBy(Api.COMPILER_TREE)
 598         public List&lt;JCTree&gt; getTypeDecls() {
 599             List&lt;JCTree&gt; typeDefs;
 600             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 601                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 602                     break;
 603             return typeDefs;
 604         }
 605         @Override @DefinedBy(Api.COMPILER_TREE)
 606         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 607             return v.visitCompilationUnit(this, d);
 608         }
 609 
 610         @Override
 611         public Tag getTag() {
 612             return TOPLEVEL;
 613         }
 614     }
 615 
 616     /**
 617      * Package definition.
 618      */
 619     public static class JCPackageDecl extends JCTree implements PackageTree {
 620         public List&lt;JCAnnotation&gt; annotations;
 621         /** The tree representing the package clause. */
 622         public JCExpression pid;
 623         public PackageSymbol packge;
 624         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 625             this.annotations = annotations;
 626             this.pid = pid;
 627         }
 628         @Override
 629         public void accept(Visitor v) { v.visitPackageDef(this); }
 630         @DefinedBy(Api.COMPILER_TREE)
 631         public Kind getKind() {
 632             return Kind.PACKAGE;
 633         }
 634         @DefinedBy(Api.COMPILER_TREE)
 635         public List&lt;JCAnnotation&gt; getAnnotations() {
 636             return annotations;
 637         }
 638         @DefinedBy(Api.COMPILER_TREE)
 639         public JCExpression getPackageName() {
 640             return pid;
 641         }
 642         @Override @DefinedBy(Api.COMPILER_TREE)
 643         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 644             return v.visitPackage(this, d);
 645         }
 646         @Override
 647         public Tag getTag() {
 648             return PACKAGEDEF;
 649         }
 650     }
 651 
 652     /**
 653      * An import clause.
 654      */
 655     public static class JCImport extends JCTree implements ImportTree {
 656         public boolean staticImport;
 657         /** The imported class(es). */
 658         public JCTree qualid;
 659         public com.sun.tools.javac.code.Scope importScope;
 660         protected JCImport(JCTree qualid, boolean importStatic) {
 661             this.qualid = qualid;
 662             this.staticImport = importStatic;
 663         }
 664         @Override
 665         public void accept(Visitor v) { v.visitImport(this); }
 666 
 667         @DefinedBy(Api.COMPILER_TREE)
 668         public boolean isStatic() { return staticImport; }
 669         @DefinedBy(Api.COMPILER_TREE)
 670         public JCTree getQualifiedIdentifier() { return qualid; }
 671 
 672         @DefinedBy(Api.COMPILER_TREE)
 673         public Kind getKind() { return Kind.IMPORT; }
 674         @Override @DefinedBy(Api.COMPILER_TREE)
 675         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 676             return v.visitImport(this, d);
 677         }
 678 
 679         @Override
 680         public Tag getTag() {
 681             return IMPORT;
 682         }
 683     }
 684 
 685     public static abstract class JCStatement extends JCTree implements StatementTree {
 686         @Override
 687         public JCStatement setType(Type type) {
 688             super.setType(type);
 689             return this;
 690         }
 691         @Override
 692         public JCStatement setPos(int pos) {
 693             super.setPos(pos);
 694             return this;
 695         }
 696     }
 697 
 698     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 699         @Override
 700         public JCExpression setType(Type type) {
 701             super.setType(type);
 702             return this;
 703         }
 704         @Override
 705         public JCExpression setPos(int pos) {
 706             super.setPos(pos);
 707             return this;
 708         }
 709         public boolean isPoly() { return false; }
 710         public boolean isStandalone() { return true; }
 711     }
 712 
 713     /**
 714      * Common supertype for all poly expression trees (lambda, method references,
 715      * conditionals, method and constructor calls)
 716      */
 717     public static abstract class JCPolyExpression extends JCExpression {
 718 
 719         /**
 720          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 721          */
 722         public enum PolyKind {
 723             /** poly expression to be treated as a standalone expression */
 724             STANDALONE,
 725             /** true poly expression */
 726             POLY
 727         }
 728 
 729         /** is this poly expression a &#39;true&#39; poly expression? */
 730         public PolyKind polyKind;
 731 
 732         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 733         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 734     }
 735 
 736     /**
 737      * Common supertype for all functional expression trees (lambda and method references)
 738      */
 739     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 740 
 741         public JCFunctionalExpression() {
 742             //a functional expression is always a &#39;true&#39; poly
 743             polyKind = PolyKind.POLY;
 744         }
 745 
 746         /** list of target types inferred for this functional expression. */
 747         public Type target;
 748 
 749         public Type getDescriptorType(Types types) {
 750             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 751         }
 752     }
 753 
 754     /**
 755      * A class definition.
 756      */
 757     public static class JCClassDecl extends JCStatement implements ClassTree {
 758         /** the modifiers */
 759         public JCModifiers mods;
 760         /** the name of the class */
 761         public Name name;
 762         /** formal class parameters */
 763         public List&lt;JCTypeParameter&gt; typarams;
 764         /** the classes this class extends */
 765         public JCExpression extending;
 766         /** the interfaces implemented by this class */
 767         public List&lt;JCExpression&gt; implementing;
<a name="1" id="anc1"></a>

 768         /** all variables and methods defined in this class */
 769         public List&lt;JCTree&gt; defs;
 770         /** the symbol */
 771         public ClassSymbol sym;
 772         protected JCClassDecl(JCModifiers mods,
 773                            Name name,
 774                            List&lt;JCTypeParameter&gt; typarams,
 775                            JCExpression extending,
 776                            List&lt;JCExpression&gt; implementing,
<a name="2" id="anc2"></a>
 777                            List&lt;JCTree&gt; defs,
 778                            ClassSymbol sym)
 779         {
 780             this.mods = mods;
 781             this.name = name;
 782             this.typarams = typarams;
 783             this.extending = extending;
 784             this.implementing = implementing;
<a name="3" id="anc3"></a>
 785             this.defs = defs;
 786             this.sym = sym;
 787         }
 788         @Override
 789         public void accept(Visitor v) { v.visitClassDef(this); }
 790 
 791         @SuppressWarnings(&quot;preview&quot;)
 792         @DefinedBy(Api.COMPILER_TREE)
 793         public Kind getKind() {
 794             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 795                 return Kind.ANNOTATION_TYPE;
 796             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 797                 return Kind.INTERFACE;
 798             else if ((mods.flags &amp; Flags.ENUM) != 0)
 799                 return Kind.ENUM;
 800             else if ((mods.flags &amp; Flags.RECORD) != 0)
 801                 return Kind.RECORD;
 802             else
 803                 return Kind.CLASS;
 804         }
 805 
 806         @DefinedBy(Api.COMPILER_TREE)
 807         public JCModifiers getModifiers() { return mods; }
 808         @DefinedBy(Api.COMPILER_TREE)
 809         public Name getSimpleName() { return name; }
 810         @DefinedBy(Api.COMPILER_TREE)
 811         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 812             return typarams;
 813         }
 814         @DefinedBy(Api.COMPILER_TREE)
 815         public JCExpression getExtendsClause() { return extending; }
 816         @DefinedBy(Api.COMPILER_TREE)
 817         public List&lt;JCExpression&gt; getImplementsClause() {
 818             return implementing;
 819         }
<a name="4" id="anc4"></a>




 820         @DefinedBy(Api.COMPILER_TREE)
 821         public List&lt;JCTree&gt; getMembers() {
 822             return defs;
 823         }
 824         @Override @DefinedBy(Api.COMPILER_TREE)
 825         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 826             return v.visitClass(this, d);
 827         }
 828 
 829         @Override
 830         public Tag getTag() {
 831             return CLASSDEF;
 832         }
 833     }
 834 
 835     /**
 836      * A method definition.
 837      */
 838     public static class JCMethodDecl extends JCTree implements MethodTree {
 839         /** method modifiers */
 840         public JCModifiers mods;
 841         /** method name */
 842         public Name name;
 843         /** type of method return value */
 844         public JCExpression restype;
 845         /** type parameters */
 846         public List&lt;JCTypeParameter&gt; typarams;
 847         /** receiver parameter */
 848         public JCVariableDecl recvparam;
 849         /** value parameters */
 850         public List&lt;JCVariableDecl&gt; params;
 851         /** exceptions thrown by this method */
 852         public List&lt;JCExpression&gt; thrown;
 853         /** statements in the method */
 854         public JCBlock body;
 855         /** default value, for annotation types */
 856         public JCExpression defaultValue;
 857         /** method symbol */
 858         public MethodSymbol sym;
 859         /** nascent value that evolves into the return value for a value factory */
 860         public VarSymbol factoryProduct;
 861 
 862         /** does this method completes normally */
 863         public boolean completesNormally;
 864 
 865         protected JCMethodDecl(JCModifiers mods,
 866                             Name name,
 867                             JCExpression restype,
 868                             List&lt;JCTypeParameter&gt; typarams,
 869                             JCVariableDecl recvparam,
 870                             List&lt;JCVariableDecl&gt; params,
 871                             List&lt;JCExpression&gt; thrown,
 872                             JCBlock body,
 873                             JCExpression defaultValue,
 874                             MethodSymbol sym)
 875         {
 876             this.mods = mods;
 877             this.name = name;
 878             this.restype = restype;
 879             this.typarams = typarams;
 880             this.params = params;
 881             this.recvparam = recvparam;
 882             // TODO: do something special if the given type is null?
 883             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 884             this.thrown = thrown;
 885             this.body = body;
 886             this.defaultValue = defaultValue;
 887             this.sym = sym;
 888         }
 889         @Override
 890         public void accept(Visitor v) { v.visitMethodDef(this); }
 891 
 892         @DefinedBy(Api.COMPILER_TREE)
 893         public Kind getKind() { return Kind.METHOD; }
 894         @DefinedBy(Api.COMPILER_TREE)
 895         public JCModifiers getModifiers() { return mods; }
 896         @DefinedBy(Api.COMPILER_TREE)
 897         public Name getName() { return name; }
 898         @DefinedBy(Api.COMPILER_TREE)
 899         public JCTree getReturnType() { return restype; }
 900         @DefinedBy(Api.COMPILER_TREE)
 901         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 902             return typarams;
 903         }
 904         @DefinedBy(Api.COMPILER_TREE)
 905         public List&lt;JCVariableDecl&gt; getParameters() {
 906             return params;
 907         }
 908         @DefinedBy(Api.COMPILER_TREE)
 909         public JCVariableDecl getReceiverParameter() { return recvparam; }
 910         @DefinedBy(Api.COMPILER_TREE)
 911         public List&lt;JCExpression&gt; getThrows() {
 912             return thrown;
 913         }
 914         @DefinedBy(Api.COMPILER_TREE)
 915         public JCBlock getBody() { return body; }
 916         @DefinedBy(Api.COMPILER_TREE)
 917         public JCTree getDefaultValue() { // for annotation types
 918             return defaultValue;
 919         }
 920         @Override @DefinedBy(Api.COMPILER_TREE)
 921         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 922             return v.visitMethod(this, d);
 923         }
 924 
 925         @Override
 926         public Tag getTag() {
 927             return METHODDEF;
 928         }
 929   }
 930 
 931     /**
 932      * A variable definition.
 933      */
 934     public static class JCVariableDecl extends JCStatement implements VariableTree {
 935         /** variable modifiers */
 936         public JCModifiers mods;
 937         /** variable name */
 938         public Name name;
 939         /** variable name expression */
 940         public JCExpression nameexpr;
 941         /** type of the variable */
 942         public JCExpression vartype;
 943         /** variable&#39;s initial value */
 944         public JCExpression init;
 945         /** symbol */
 946         public VarSymbol sym;
 947         /** explicit start pos */
 948         public int startPos = Position.NOPOS;
 949 
 950         protected JCVariableDecl(JCModifiers mods,
 951                          Name name,
 952                          JCExpression vartype,
 953                          JCExpression init,
 954                          VarSymbol sym) {
 955             this.mods = mods;
 956             this.name = name;
 957             this.vartype = vartype;
 958             this.init = init;
 959             this.sym = sym;
 960         }
 961 
 962         protected JCVariableDecl(JCModifiers mods,
 963                          JCExpression nameexpr,
 964                          JCExpression vartype) {
 965             this(mods, null, vartype, null, null);
 966             this.nameexpr = nameexpr;
 967             if (nameexpr.hasTag(Tag.IDENT)) {
 968                 this.name = ((JCIdent)nameexpr).name;
 969             } else {
 970                 // Only other option is qualified name x.y.this;
 971                 this.name = ((JCFieldAccess)nameexpr).name;
 972             }
 973         }
 974 
 975         public boolean isImplicitlyTyped() {
 976             return vartype == null;
 977         }
 978 
 979         @Override
 980         public void accept(Visitor v) { v.visitVarDef(this); }
 981 
 982         @DefinedBy(Api.COMPILER_TREE)
 983         public Kind getKind() { return Kind.VARIABLE; }
 984         @DefinedBy(Api.COMPILER_TREE)
 985         public JCModifiers getModifiers() { return mods; }
 986         @DefinedBy(Api.COMPILER_TREE)
 987         public Name getName() { return name; }
 988         @DefinedBy(Api.COMPILER_TREE)
 989         public JCExpression getNameExpression() { return nameexpr; }
 990         @DefinedBy(Api.COMPILER_TREE)
 991         public JCTree getType() { return vartype; }
 992         @DefinedBy(Api.COMPILER_TREE)
 993         public JCExpression getInitializer() {
 994             return init;
 995         }
 996         @Override @DefinedBy(Api.COMPILER_TREE)
 997         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 998             return v.visitVariable(this, d);
 999         }
1000 
1001         @Override
1002         public Tag getTag() {
1003             return VARDEF;
1004         }
1005     }
1006 
1007     /**
1008      * A no-op statement &quot;;&quot;.
1009      */
1010     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1011         protected JCSkip() {
1012         }
1013         @Override
1014         public void accept(Visitor v) { v.visitSkip(this); }
1015 
1016         @DefinedBy(Api.COMPILER_TREE)
1017         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1018         @Override @DefinedBy(Api.COMPILER_TREE)
1019         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1020             return v.visitEmptyStatement(this, d);
1021         }
1022 
1023         @Override
1024         public Tag getTag() {
1025             return SKIP;
1026         }
1027     }
1028 
1029     /**
1030      * A statement block.
1031      */
1032     public static class JCBlock extends JCStatement implements BlockTree {
1033         /** flags */
1034         public long flags;
1035         /** statements */
1036         public List&lt;JCStatement&gt; stats;
1037         /** Position of closing brace, optional. */
1038         public int endpos = Position.NOPOS;
1039         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1040             this.stats = stats;
1041             this.flags = flags;
1042         }
1043         @Override
1044         public void accept(Visitor v) { v.visitBlock(this); }
1045 
1046         @DefinedBy(Api.COMPILER_TREE)
1047         public Kind getKind() { return Kind.BLOCK; }
1048         @DefinedBy(Api.COMPILER_TREE)
1049         public List&lt;JCStatement&gt; getStatements() {
1050             return stats;
1051         }
1052         @DefinedBy(Api.COMPILER_TREE)
1053         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1054         @Override @DefinedBy(Api.COMPILER_TREE)
1055         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1056             return v.visitBlock(this, d);
1057         }
1058 
1059         @Override
1060         public Tag getTag() {
1061             return BLOCK;
1062         }
1063     }
1064 
1065     /**
1066      * A do loop
1067      */
1068     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1069         public JCStatement body;
1070         public JCExpression cond;
1071         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1072             this.body = body;
1073             this.cond = cond;
1074         }
1075         @Override
1076         public void accept(Visitor v) { v.visitDoLoop(this); }
1077 
1078         @DefinedBy(Api.COMPILER_TREE)
1079         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1080         @DefinedBy(Api.COMPILER_TREE)
1081         public JCExpression getCondition() { return cond; }
1082         @DefinedBy(Api.COMPILER_TREE)
1083         public JCStatement getStatement() { return body; }
1084         @Override @DefinedBy(Api.COMPILER_TREE)
1085         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1086             return v.visitDoWhileLoop(this, d);
1087         }
1088 
1089         @Override
1090         public Tag getTag() {
1091             return DOLOOP;
1092         }
1093     }
1094 
1095     /**
1096      * A while loop
1097      */
1098     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1099         public JCExpression cond;
1100         public JCStatement body;
1101         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1102             this.cond = cond;
1103             this.body = body;
1104         }
1105         @Override
1106         public void accept(Visitor v) { v.visitWhileLoop(this); }
1107 
1108         @DefinedBy(Api.COMPILER_TREE)
1109         public Kind getKind() { return Kind.WHILE_LOOP; }
1110         @DefinedBy(Api.COMPILER_TREE)
1111         public JCExpression getCondition() { return cond; }
1112         @DefinedBy(Api.COMPILER_TREE)
1113         public JCStatement getStatement() { return body; }
1114         @Override @DefinedBy(Api.COMPILER_TREE)
1115         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1116             return v.visitWhileLoop(this, d);
1117         }
1118 
1119         @Override
1120         public Tag getTag() {
1121             return WHILELOOP;
1122         }
1123     }
1124 
1125     /**
1126      * A withfield expression
1127      */
1128     public static class JCWithField extends JCExpression implements WithFieldTree {
1129         public JCExpression field;
1130         public JCExpression value;
1131         protected JCWithField(JCExpression field, JCExpression value) {
1132             this.field = field;
1133             this.value = value;
1134         }
1135         @Override
1136         public void accept(Visitor v) { v.visitWithField(this); }
1137 
1138         @DefinedBy(Api.COMPILER_TREE)
1139         public Kind getKind() { return Kind.WITH_FIELD; }
1140         @DefinedBy(Api.COMPILER_TREE)
1141         public JCExpression getField() { return field; }
1142         @DefinedBy(Api.COMPILER_TREE)
1143         public JCExpression getValue() { return value; }
1144         @Override @DefinedBy(Api.COMPILER_TREE)
1145         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1146             return v.visitWithField(this, d);
1147         }
1148 
1149         @Override
1150         public Tag getTag() {
1151             return WITHFIELD;
1152         }
1153     }
1154 
1155     /**
1156      * A for loop.
1157      */
1158     public static class JCForLoop extends JCStatement implements ForLoopTree {
1159         public List&lt;JCStatement&gt; init;
1160         public JCExpression cond;
1161         public List&lt;JCExpressionStatement&gt; step;
1162         public JCStatement body;
1163         protected JCForLoop(List&lt;JCStatement&gt; init,
1164                           JCExpression cond,
1165                           List&lt;JCExpressionStatement&gt; update,
1166                           JCStatement body)
1167         {
1168             this.init = init;
1169             this.cond = cond;
1170             this.step = update;
1171             this.body = body;
1172         }
1173         @Override
1174         public void accept(Visitor v) { v.visitForLoop(this); }
1175 
1176         @DefinedBy(Api.COMPILER_TREE)
1177         public Kind getKind() { return Kind.FOR_LOOP; }
1178         @DefinedBy(Api.COMPILER_TREE)
1179         public JCExpression getCondition() { return cond; }
1180         @DefinedBy(Api.COMPILER_TREE)
1181         public JCStatement getStatement() { return body; }
1182         @DefinedBy(Api.COMPILER_TREE)
1183         public List&lt;JCStatement&gt; getInitializer() {
1184             return init;
1185         }
1186         @DefinedBy(Api.COMPILER_TREE)
1187         public List&lt;JCExpressionStatement&gt; getUpdate() {
1188             return step;
1189         }
1190         @Override @DefinedBy(Api.COMPILER_TREE)
1191         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1192             return v.visitForLoop(this, d);
1193         }
1194 
1195         @Override
1196         public Tag getTag() {
1197             return FORLOOP;
1198         }
1199     }
1200 
1201     /**
1202      * The enhanced for loop.
1203      */
1204     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1205         public JCVariableDecl var;
1206         public JCExpression expr;
1207         public JCStatement body;
1208         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1209             this.var = var;
1210             this.expr = expr;
1211             this.body = body;
1212         }
1213         @Override
1214         public void accept(Visitor v) { v.visitForeachLoop(this); }
1215 
1216         @DefinedBy(Api.COMPILER_TREE)
1217         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1218         @DefinedBy(Api.COMPILER_TREE)
1219         public JCVariableDecl getVariable() { return var; }
1220         @DefinedBy(Api.COMPILER_TREE)
1221         public JCExpression getExpression() { return expr; }
1222         @DefinedBy(Api.COMPILER_TREE)
1223         public JCStatement getStatement() { return body; }
1224         @Override @DefinedBy(Api.COMPILER_TREE)
1225         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1226             return v.visitEnhancedForLoop(this, d);
1227         }
1228         @Override
1229         public Tag getTag() {
1230             return FOREACHLOOP;
1231         }
1232     }
1233 
1234     /**
1235      * A labelled expression or statement.
1236      */
1237     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1238         public Name label;
1239         public JCStatement body;
1240         protected JCLabeledStatement(Name label, JCStatement body) {
1241             this.label = label;
1242             this.body = body;
1243         }
1244         @Override
1245         public void accept(Visitor v) { v.visitLabelled(this); }
1246         @DefinedBy(Api.COMPILER_TREE)
1247         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1248         @DefinedBy(Api.COMPILER_TREE)
1249         public Name getLabel() { return label; }
1250         @DefinedBy(Api.COMPILER_TREE)
1251         public JCStatement getStatement() { return body; }
1252         @Override @DefinedBy(Api.COMPILER_TREE)
1253         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1254             return v.visitLabeledStatement(this, d);
1255         }
1256         @Override
1257         public Tag getTag() {
1258             return LABELLED;
1259         }
1260     }
1261 
1262     /**
1263      * A &quot;switch ( ) { }&quot; construction.
1264      */
1265     public static class JCSwitch extends JCStatement implements SwitchTree {
1266         public JCExpression selector;
1267         public List&lt;JCCase&gt; cases;
1268         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1269             this.selector = selector;
1270             this.cases = cases;
1271         }
1272         @Override
1273         public void accept(Visitor v) { v.visitSwitch(this); }
1274 
1275         @DefinedBy(Api.COMPILER_TREE)
1276         public Kind getKind() { return Kind.SWITCH; }
1277         @DefinedBy(Api.COMPILER_TREE)
1278         public JCExpression getExpression() { return selector; }
1279         @DefinedBy(Api.COMPILER_TREE)
1280         public List&lt;JCCase&gt; getCases() { return cases; }
1281         @Override @DefinedBy(Api.COMPILER_TREE)
1282         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1283             return v.visitSwitch(this, d);
1284         }
1285         @Override
1286         public Tag getTag() {
1287             return SWITCH;
1288         }
1289     }
1290 
1291     /**
1292      * A &quot;case  :&quot; of a switch.
1293      */
1294     public static class JCCase extends JCStatement implements CaseTree {
1295         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1296         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1297         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1298         public static final CaseKind RULE = CaseKind.RULE;
1299         public final CaseKind caseKind;
1300         public List&lt;JCExpression&gt; pats;
1301         public List&lt;JCStatement&gt; stats;
1302         public JCTree body;
1303         public boolean completesNormally;
1304         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,
1305                          List&lt;JCStatement&gt; stats, JCTree body) {
1306             Assert.checkNonNull(pats);
1307             Assert.check(pats.isEmpty() || pats.head != null);
1308             this.caseKind = caseKind;
1309             this.pats = pats;
1310             this.stats = stats;
1311             this.body = body;
1312         }
1313         @Override
1314         public void accept(Visitor v) { v.visitCase(this); }
1315 
1316         @Override @DefinedBy(Api.COMPILER_TREE)
1317         public Kind getKind() { return Kind.CASE; }
1318         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)
1319         public JCExpression getExpression() { return pats.head; }
1320         @Override @DefinedBy(Api.COMPILER_TREE)
1321         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1322         @Override @DefinedBy(Api.COMPILER_TREE)
1323         public List&lt;JCStatement&gt; getStatements() {
1324             return caseKind == CaseKind.STATEMENT ? stats : null;
1325         }
1326         @Override @DefinedBy(Api.COMPILER_TREE)
1327         public JCTree getBody() { return body; }
1328         @Override @DefinedBy(Api.COMPILER_TREE)
1329         public CaseKind getCaseKind() {
1330             return caseKind;
1331         }
1332         @Override @DefinedBy(Api.COMPILER_TREE)
1333         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1334             return v.visitCase(this, d);
1335         }
1336         @Override
1337         public Tag getTag() {
1338             return CASE;
1339         }
1340     }
1341 
1342     /**
1343      * A &quot;switch ( ) { }&quot; construction.
1344      */
1345     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1346         public JCExpression selector;
1347         public List&lt;JCCase&gt; cases;
1348         /** Position of closing brace, optional. */
1349         public int endpos = Position.NOPOS;
1350         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1351             this.selector = selector;
1352             this.cases = cases;
1353         }
1354         @Override
1355         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1356 
1357         @DefinedBy(Api.COMPILER_TREE)
1358         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1359         @DefinedBy(Api.COMPILER_TREE)
1360         public JCExpression getExpression() { return selector; }
1361         @DefinedBy(Api.COMPILER_TREE)
1362         public List&lt;JCCase&gt; getCases() { return cases; }
1363         @Override @DefinedBy(Api.COMPILER_TREE)
1364         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1365             return v.visitSwitchExpression(this, d);
1366         }
1367         @Override
1368         public Tag getTag() {
1369             return SWITCH_EXPRESSION;
1370         }
1371     }
1372 
1373     /**
1374      * A synchronized block.
1375      */
1376     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1377         public JCExpression lock;
1378         public JCBlock body;
1379         protected JCSynchronized(JCExpression lock, JCBlock body) {
1380             this.lock = lock;
1381             this.body = body;
1382         }
1383         @Override
1384         public void accept(Visitor v) { v.visitSynchronized(this); }
1385 
1386         @DefinedBy(Api.COMPILER_TREE)
1387         public Kind getKind() { return Kind.SYNCHRONIZED; }
1388         @DefinedBy(Api.COMPILER_TREE)
1389         public JCExpression getExpression() { return lock; }
1390         @DefinedBy(Api.COMPILER_TREE)
1391         public JCBlock getBlock() { return body; }
1392         @Override @DefinedBy(Api.COMPILER_TREE)
1393         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1394             return v.visitSynchronized(this, d);
1395         }
1396         @Override
1397         public Tag getTag() {
1398             return SYNCHRONIZED;
1399         }
1400     }
1401 
1402     /**
1403      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1404      */
1405     public static class JCTry extends JCStatement implements TryTree {
1406         public JCBlock body;
1407         public List&lt;JCCatch&gt; catchers;
1408         public JCBlock finalizer;
1409         public List&lt;JCTree&gt; resources;
1410         public boolean finallyCanCompleteNormally;
1411         protected JCTry(List&lt;JCTree&gt; resources,
1412                         JCBlock body,
1413                         List&lt;JCCatch&gt; catchers,
1414                         JCBlock finalizer) {
1415             this.body = body;
1416             this.catchers = catchers;
1417             this.finalizer = finalizer;
1418             this.resources = resources;
1419         }
1420         @Override
1421         public void accept(Visitor v) { v.visitTry(this); }
1422 
1423         @DefinedBy(Api.COMPILER_TREE)
1424         public Kind getKind() { return Kind.TRY; }
1425         @DefinedBy(Api.COMPILER_TREE)
1426         public JCBlock getBlock() { return body; }
1427         @DefinedBy(Api.COMPILER_TREE)
1428         public List&lt;JCCatch&gt; getCatches() {
1429             return catchers;
1430         }
1431         @DefinedBy(Api.COMPILER_TREE)
1432         public JCBlock getFinallyBlock() { return finalizer; }
1433         @Override @DefinedBy(Api.COMPILER_TREE)
1434         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1435             return v.visitTry(this, d);
1436         }
1437         @Override @DefinedBy(Api.COMPILER_TREE)
1438         public List&lt;JCTree&gt; getResources() {
1439             return resources;
1440         }
1441         @Override
1442         public Tag getTag() {
1443             return TRY;
1444         }
1445     }
1446 
1447     /**
1448      * A catch block.
1449      */
1450     public static class JCCatch extends JCTree implements CatchTree {
1451         public JCVariableDecl param;
1452         public JCBlock body;
1453         protected JCCatch(JCVariableDecl param, JCBlock body) {
1454             this.param = param;
1455             this.body = body;
1456         }
1457         @Override
1458         public void accept(Visitor v) { v.visitCatch(this); }
1459 
1460         @DefinedBy(Api.COMPILER_TREE)
1461         public Kind getKind() { return Kind.CATCH; }
1462         @DefinedBy(Api.COMPILER_TREE)
1463         public JCVariableDecl getParameter() { return param; }
1464         @DefinedBy(Api.COMPILER_TREE)
1465         public JCBlock getBlock() { return body; }
1466         @Override @DefinedBy(Api.COMPILER_TREE)
1467         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1468             return v.visitCatch(this, d);
1469         }
1470         @Override
1471         public Tag getTag() {
1472             return CATCH;
1473         }
1474     }
1475 
1476     /**
1477      * A ( ) ? ( ) : ( ) conditional expression
1478      */
1479     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1480         public JCExpression cond;
1481         public JCExpression truepart;
1482         public JCExpression falsepart;
1483         protected JCConditional(JCExpression cond,
1484                               JCExpression truepart,
1485                               JCExpression falsepart)
1486         {
1487             this.cond = cond;
1488             this.truepart = truepart;
1489             this.falsepart = falsepart;
1490         }
1491         @Override
1492         public void accept(Visitor v) { v.visitConditional(this); }
1493 
1494         @DefinedBy(Api.COMPILER_TREE)
1495         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1496         @DefinedBy(Api.COMPILER_TREE)
1497         public JCExpression getCondition() { return cond; }
1498         @DefinedBy(Api.COMPILER_TREE)
1499         public JCExpression getTrueExpression() { return truepart; }
1500         @DefinedBy(Api.COMPILER_TREE)
1501         public JCExpression getFalseExpression() { return falsepart; }
1502         @Override @DefinedBy(Api.COMPILER_TREE)
1503         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1504             return v.visitConditionalExpression(this, d);
1505         }
1506         @Override
1507         public Tag getTag() {
1508             return CONDEXPR;
1509         }
1510     }
1511 
1512     /**
1513      * An &quot;if ( ) { } else { }&quot; block
1514      */
1515     public static class JCIf extends JCStatement implements IfTree {
1516         public JCExpression cond;
1517         public JCStatement thenpart;
1518         public JCStatement elsepart;
1519         protected JCIf(JCExpression cond,
1520                      JCStatement thenpart,
1521                      JCStatement elsepart)
1522         {
1523             this.cond = cond;
1524             this.thenpart = thenpart;
1525             this.elsepart = elsepart;
1526         }
1527         @Override
1528         public void accept(Visitor v) { v.visitIf(this); }
1529 
1530         @DefinedBy(Api.COMPILER_TREE)
1531         public Kind getKind() { return Kind.IF; }
1532         @DefinedBy(Api.COMPILER_TREE)
1533         public JCExpression getCondition() { return cond; }
1534         @DefinedBy(Api.COMPILER_TREE)
1535         public JCStatement getThenStatement() { return thenpart; }
1536         @DefinedBy(Api.COMPILER_TREE)
1537         public JCStatement getElseStatement() { return elsepart; }
1538         @Override @DefinedBy(Api.COMPILER_TREE)
1539         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1540             return v.visitIf(this, d);
1541         }
1542         @Override
1543         public Tag getTag() {
1544             return IF;
1545         }
1546     }
1547 
1548     /**
1549      * an expression statement
1550      */
1551     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1552         /** expression structure */
1553         public JCExpression expr;
1554         protected JCExpressionStatement(JCExpression expr)
1555         {
1556             this.expr = expr;
1557         }
1558         @Override
1559         public void accept(Visitor v) { v.visitExec(this); }
1560 
1561         @DefinedBy(Api.COMPILER_TREE)
1562         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1563         @DefinedBy(Api.COMPILER_TREE)
1564         public JCExpression getExpression() { return expr; }
1565         @Override @DefinedBy(Api.COMPILER_TREE)
1566         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1567             return v.visitExpressionStatement(this, d);
1568         }
1569         @Override
1570         public Tag getTag() {
1571             return EXEC;
1572         }
1573 
1574         /** Convert a expression-statement tree to a pretty-printed string. */
1575         @Override
1576         public String toString() {
1577             StringWriter s = new StringWriter();
1578             try {
1579                 new Pretty(s, false).printStat(this);
1580             }
1581             catch (IOException e) {
1582                 // should never happen, because StringWriter is defined
1583                 // never to throw any IOExceptions
1584                 throw new AssertionError(e);
1585             }
1586             return s.toString();
1587         }
1588     }
1589 
1590     /**
1591      * A break from a loop or switch.
1592      */
1593     public static class JCBreak extends JCStatement implements BreakTree {
1594         public Name label;
1595         public JCTree target;
1596         protected JCBreak(Name label, JCTree target) {
1597             this.label = label;
1598             this.target = target;
1599         }
1600         @Override
1601         public void accept(Visitor v) { v.visitBreak(this); }
1602         public boolean isValueBreak() {
1603             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1604         }
1605 
1606         @DefinedBy(Api.COMPILER_TREE)
1607         public Kind getKind() { return Kind.BREAK; }
1608         @DefinedBy(Api.COMPILER_TREE)
1609         public Name getLabel() {
1610             return label;
1611         }
1612         @Override @DefinedBy(Api.COMPILER_TREE)
1613         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1614             return v.visitBreak(this, d);
1615         }
1616         @Override
1617         public Tag getTag() {
1618             return BREAK;
1619         }
1620     }
1621 
1622     /**
1623      * A break-with from a switch expression.
1624      */
1625     public static class JCYield extends JCStatement implements YieldTree {
1626         public JCExpression value;
1627         public JCTree target;
1628         protected JCYield(JCExpression value, JCTree target) {
1629             this.value = value;
1630             this.target = target;
1631         }
1632         @Override
1633         public void accept(Visitor v) { v.visitYield(this); }
1634         @DefinedBy(Api.COMPILER_TREE)
1635         public Kind getKind() { return Kind.YIELD; }
1636         @DefinedBy(Api.COMPILER_TREE)
1637         public JCExpression getValue() { return value; }
1638         @Override @DefinedBy(Api.COMPILER_TREE)
1639         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1640             return v.visitYield(this, d);
1641         }
1642         @Override
1643         public Tag getTag() {
1644             return YIELD;
1645         }
1646     }
1647 
1648     /**
1649      * A continue of a loop.
1650      */
1651     public static class JCContinue extends JCStatement implements ContinueTree {
1652         public Name label;
1653         public JCTree target;
1654         protected JCContinue(Name label, JCTree target) {
1655             this.label = label;
1656             this.target = target;
1657         }
1658         @Override
1659         public void accept(Visitor v) { v.visitContinue(this); }
1660 
1661         @DefinedBy(Api.COMPILER_TREE)
1662         public Kind getKind() { return Kind.CONTINUE; }
1663         @DefinedBy(Api.COMPILER_TREE)
1664         public Name getLabel() { return label; }
1665         @Override @DefinedBy(Api.COMPILER_TREE)
1666         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1667             return v.visitContinue(this, d);
1668         }
1669         @Override
1670         public Tag getTag() {
1671             return CONTINUE;
1672         }
1673     }
1674 
1675     /**
1676      * A return statement.
1677      */
1678     public static class JCReturn extends JCStatement implements ReturnTree {
1679         public JCExpression expr;
1680         protected JCReturn(JCExpression expr) {
1681             this.expr = expr;
1682         }
1683         @Override
1684         public void accept(Visitor v) { v.visitReturn(this); }
1685 
1686         @DefinedBy(Api.COMPILER_TREE)
1687         public Kind getKind() { return Kind.RETURN; }
1688         @DefinedBy(Api.COMPILER_TREE)
1689         public JCExpression getExpression() { return expr; }
1690         @Override @DefinedBy(Api.COMPILER_TREE)
1691         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1692             return v.visitReturn(this, d);
1693         }
1694         @Override
1695         public Tag getTag() {
1696             return RETURN;
1697         }
1698     }
1699 
1700     /**
1701      * A throw statement.
1702      */
1703     public static class JCThrow extends JCStatement implements ThrowTree {
1704         public JCExpression expr;
1705         protected JCThrow(JCExpression expr) {
1706             this.expr = expr;
1707         }
1708         @Override
1709         public void accept(Visitor v) { v.visitThrow(this); }
1710 
1711         @DefinedBy(Api.COMPILER_TREE)
1712         public Kind getKind() { return Kind.THROW; }
1713         @DefinedBy(Api.COMPILER_TREE)
1714         public JCExpression getExpression() { return expr; }
1715         @Override @DefinedBy(Api.COMPILER_TREE)
1716         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1717             return v.visitThrow(this, d);
1718         }
1719         @Override
1720         public Tag getTag() {
1721             return THROW;
1722         }
1723     }
1724 
1725     /**
1726      * An assert statement.
1727      */
1728     public static class JCAssert extends JCStatement implements AssertTree {
1729         public JCExpression cond;
1730         public JCExpression detail;
1731         protected JCAssert(JCExpression cond, JCExpression detail) {
1732             this.cond = cond;
1733             this.detail = detail;
1734         }
1735         @Override
1736         public void accept(Visitor v) { v.visitAssert(this); }
1737 
1738         @DefinedBy(Api.COMPILER_TREE)
1739         public Kind getKind() { return Kind.ASSERT; }
1740         @DefinedBy(Api.COMPILER_TREE)
1741         public JCExpression getCondition() { return cond; }
1742         @DefinedBy(Api.COMPILER_TREE)
1743         public JCExpression getDetail() { return detail; }
1744         @Override @DefinedBy(Api.COMPILER_TREE)
1745         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1746             return v.visitAssert(this, d);
1747         }
1748         @Override
1749         public Tag getTag() {
1750             return ASSERT;
1751         }
1752     }
1753 
1754     /**
1755      * A method invocation
1756      */
1757     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1758         public List&lt;JCExpression&gt; typeargs;
1759         public JCExpression meth;
1760         public List&lt;JCExpression&gt; args;
1761         public Type varargsElement;
1762         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1763                         JCExpression meth,
1764                         List&lt;JCExpression&gt; args)
1765         {
1766             this.typeargs = (typeargs == null) ? List.nil()
1767                                                : typeargs;
1768             this.meth = meth;
1769             this.args = args;
1770         }
1771         @Override
1772         public void accept(Visitor v) { v.visitApply(this); }
1773 
1774         @DefinedBy(Api.COMPILER_TREE)
1775         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1776         @DefinedBy(Api.COMPILER_TREE)
1777         public List&lt;JCExpression&gt; getTypeArguments() {
1778             return typeargs;
1779         }
1780         @DefinedBy(Api.COMPILER_TREE)
1781         public JCExpression getMethodSelect() { return meth; }
1782         @DefinedBy(Api.COMPILER_TREE)
1783         public List&lt;JCExpression&gt; getArguments() {
1784             return args;
1785         }
1786         @Override @DefinedBy(Api.COMPILER_TREE)
1787         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1788             return v.visitMethodInvocation(this, d);
1789         }
1790         @Override
1791         public JCMethodInvocation setType(Type type) {
1792             super.setType(type);
1793             return this;
1794         }
1795         @Override
1796         public Tag getTag() {
1797             return(APPLY);
1798         }
1799     }
1800 
1801     /**
1802      * A new(...) operation.
1803      */
1804     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1805         public JCExpression encl;
1806         public List&lt;JCExpression&gt; typeargs;
1807         public JCExpression clazz;
1808         public List&lt;JCExpression&gt; args;
1809         public JCClassDecl def;
1810         public Symbol constructor;
1811         public Type varargsElement;
1812         public Type constructorType;
1813         protected JCNewClass(JCExpression encl,
1814                            List&lt;JCExpression&gt; typeargs,
1815                            JCExpression clazz,
1816                            List&lt;JCExpression&gt; args,
1817                            JCClassDecl def)
1818         {
1819             this.encl = encl;
1820             this.typeargs = (typeargs == null) ? List.nil()
1821                                                : typeargs;
1822             this.clazz = clazz;
1823             this.args = args;
1824             this.def = def;
1825         }
1826         @Override
1827         public void accept(Visitor v) { v.visitNewClass(this); }
1828 
1829         @DefinedBy(Api.COMPILER_TREE)
1830         public Kind getKind() { return Kind.NEW_CLASS; }
1831         @DefinedBy(Api.COMPILER_TREE)
1832         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1833             return encl;
1834         }
1835         @DefinedBy(Api.COMPILER_TREE)
1836         public List&lt;JCExpression&gt; getTypeArguments() {
1837             return typeargs;
1838         }
1839         @DefinedBy(Api.COMPILER_TREE)
1840         public JCExpression getIdentifier() { return clazz; }
1841         @DefinedBy(Api.COMPILER_TREE)
1842         public List&lt;JCExpression&gt; getArguments() {
1843             return args;
1844         }
1845         @DefinedBy(Api.COMPILER_TREE)
1846         public JCClassDecl getClassBody() { return def; }
1847         @Override @DefinedBy(Api.COMPILER_TREE)
1848         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1849             return v.visitNewClass(this, d);
1850         }
1851         @Override
1852         public Tag getTag() {
1853             return NEWCLASS;
1854         }
1855 
1856         public boolean classDeclRemoved() {
1857             return false;
1858         }
1859     }
1860 
1861     /**
1862      * A new[...] operation.
1863      */
1864     public static class JCNewArray extends JCExpression implements NewArrayTree {
1865         public JCExpression elemtype;
1866         public List&lt;JCExpression&gt; dims;
1867         // type annotations on inner-most component
1868         public List&lt;JCAnnotation&gt; annotations;
1869         // type annotations on dimensions
1870         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1871         public List&lt;JCExpression&gt; elems;
1872         protected JCNewArray(JCExpression elemtype,
1873                            List&lt;JCExpression&gt; dims,
1874                            List&lt;JCExpression&gt; elems)
1875         {
1876             this.elemtype = elemtype;
1877             this.dims = dims;
1878             this.annotations = List.nil();
1879             this.dimAnnotations = List.nil();
1880             this.elems = elems;
1881         }
1882         @Override
1883         public void accept(Visitor v) { v.visitNewArray(this); }
1884 
1885         @DefinedBy(Api.COMPILER_TREE)
1886         public Kind getKind() { return Kind.NEW_ARRAY; }
1887         @DefinedBy(Api.COMPILER_TREE)
1888         public JCExpression getType() { return elemtype; }
1889         @DefinedBy(Api.COMPILER_TREE)
1890         public List&lt;JCExpression&gt; getDimensions() {
1891             return dims;
1892         }
1893         @DefinedBy(Api.COMPILER_TREE)
1894         public List&lt;JCExpression&gt; getInitializers() {
1895             return elems;
1896         }
1897         @Override @DefinedBy(Api.COMPILER_TREE)
1898         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1899             return v.visitNewArray(this, d);
1900         }
1901         @Override
1902         public Tag getTag() {
1903             return NEWARRAY;
1904         }
1905 
1906         @Override @DefinedBy(Api.COMPILER_TREE)
1907         public List&lt;JCAnnotation&gt; getAnnotations() {
1908             return annotations;
1909         }
1910 
1911         @Override @DefinedBy(Api.COMPILER_TREE)
1912         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1913             return dimAnnotations;
1914         }
1915     }
1916 
1917     /**
1918      * A lambda expression.
1919      */
1920     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1921 
1922         public enum ParameterKind {
1923             IMPLICIT,
1924             EXPLICIT
1925         }
1926 
1927         public List&lt;JCVariableDecl&gt; params;
1928         public JCTree body;
1929         public boolean canCompleteNormally = true;
1930         public ParameterKind paramKind;
1931 
1932         public JCLambda(List&lt;JCVariableDecl&gt; params,
1933                         JCTree body) {
1934             this.params = params;
1935             this.body = body;
1936             if (params.isEmpty() ||
1937                 params.head.vartype != null) {
1938                 paramKind = ParameterKind.EXPLICIT;
1939             } else {
1940                 paramKind = ParameterKind.IMPLICIT;
1941             }
1942         }
1943         @Override
1944         public Tag getTag() {
1945             return LAMBDA;
1946         }
1947         @Override
1948         public void accept(Visitor v) {
1949             v.visitLambda(this);
1950         }
1951         @Override @DefinedBy(Api.COMPILER_TREE)
1952         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1953             return v.visitLambdaExpression(this, d);
1954         }
1955         @DefinedBy(Api.COMPILER_TREE)
1956         public Kind getKind() {
1957             return Kind.LAMBDA_EXPRESSION;
1958         }
1959         @DefinedBy(Api.COMPILER_TREE)
1960         public JCTree getBody() {
1961             return body;
1962         }
1963         @DefinedBy(Api.COMPILER_TREE)
1964         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1965             return params;
1966         }
1967         @Override
1968         public JCLambda setType(Type type) {
1969             super.setType(type);
1970             return this;
1971         }
1972         @Override @DefinedBy(Api.COMPILER_TREE)
1973         public BodyKind getBodyKind() {
1974             return body.hasTag(BLOCK) ?
1975                     BodyKind.STATEMENT :
1976                     BodyKind.EXPRESSION;
1977         }
1978     }
1979 
1980     /**
1981      * A parenthesized subexpression ( ... )
1982      */
1983     public static class JCParens extends JCExpression implements ParenthesizedTree {
1984         public JCExpression expr;
1985         protected JCParens(JCExpression expr) {
1986             this.expr = expr;
1987         }
1988         @Override
1989         public void accept(Visitor v) { v.visitParens(this); }
1990 
1991         @DefinedBy(Api.COMPILER_TREE)
1992         public Kind getKind() { return Kind.PARENTHESIZED; }
1993         @DefinedBy(Api.COMPILER_TREE)
1994         public JCExpression getExpression() { return expr; }
1995         @Override @DefinedBy(Api.COMPILER_TREE)
1996         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1997             return v.visitParenthesized(this, d);
1998         }
1999         @Override
2000         public Tag getTag() {
2001             return PARENS;
2002         }
2003     }
2004 
2005     /**
2006      * A assignment with &quot;=&quot;.
2007      */
2008     public static class JCAssign extends JCExpression implements AssignmentTree {
2009         public JCExpression lhs;
2010         public JCExpression rhs;
2011         protected JCAssign(JCExpression lhs, JCExpression rhs) {
2012             this.lhs = lhs;
2013             this.rhs = rhs;
2014         }
2015         @Override
2016         public void accept(Visitor v) { v.visitAssign(this); }
2017 
2018         @DefinedBy(Api.COMPILER_TREE)
2019         public Kind getKind() { return Kind.ASSIGNMENT; }
2020         @DefinedBy(Api.COMPILER_TREE)
2021         public JCExpression getVariable() { return lhs; }
2022         @DefinedBy(Api.COMPILER_TREE)
2023         public JCExpression getExpression() { return rhs; }
2024         @Override @DefinedBy(Api.COMPILER_TREE)
2025         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2026             return v.visitAssignment(this, d);
2027         }
2028         @Override
2029         public Tag getTag() {
2030             return ASSIGN;
2031         }
2032     }
2033 
2034     public static abstract class JCOperatorExpression extends JCExpression {
2035         public enum OperandPos {
2036             LEFT,
2037             RIGHT
2038         }
2039 
2040         protected Tag opcode;
2041         public OperatorSymbol operator;
2042 
2043         public OperatorSymbol getOperator() {
2044             return operator;
2045         }
2046 
2047         @Override
2048         public Tag getTag() {
2049             return opcode;
2050         }
2051 
2052         public abstract JCExpression getOperand(OperandPos pos);
2053     }
2054 
2055     /**
2056      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2057      */
2058     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2059         public JCExpression lhs;
2060         public JCExpression rhs;
2061         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2062             this.opcode = opcode;
2063             this.lhs = (JCExpression)lhs;
2064             this.rhs = (JCExpression)rhs;
2065             this.operator = operator;
2066         }
2067         @Override
2068         public void accept(Visitor v) { v.visitAssignop(this); }
2069 
2070         @DefinedBy(Api.COMPILER_TREE)
2071         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2072         @DefinedBy(Api.COMPILER_TREE)
2073         public JCExpression getVariable() { return lhs; }
2074         @DefinedBy(Api.COMPILER_TREE)
2075         public JCExpression getExpression() { return rhs; }
2076         @Override @DefinedBy(Api.COMPILER_TREE)
2077         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2078             return v.visitCompoundAssignment(this, d);
2079         }
2080         @Override
2081         public JCExpression getOperand(OperandPos pos) {
2082             return pos == OperandPos.LEFT ? lhs : rhs;
2083         }
2084     }
2085 
2086     /**
2087      * A unary operation.
2088      */
2089     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2090         public JCExpression arg;
2091         protected JCUnary(Tag opcode, JCExpression arg) {
2092             this.opcode = opcode;
2093             this.arg = arg;
2094         }
2095         @Override
2096         public void accept(Visitor v) { v.visitUnary(this); }
2097 
2098         @DefinedBy(Api.COMPILER_TREE)
2099         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2100         @DefinedBy(Api.COMPILER_TREE)
2101         public JCExpression getExpression() { return arg; }
2102         @Override @DefinedBy(Api.COMPILER_TREE)
2103         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2104             return v.visitUnary(this, d);
2105         }
2106         public void setTag(Tag tag) {
2107             opcode = tag;
2108         }
2109         @Override
2110         public JCExpression getOperand(OperandPos pos) {
2111             return arg;
2112         }
2113     }
2114 
2115     /**
2116      * A binary operation.
2117      */
2118     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2119         public JCExpression lhs;
2120         public JCExpression rhs;
2121         protected JCBinary(Tag opcode,
2122                          JCExpression lhs,
2123                          JCExpression rhs,
2124                          OperatorSymbol operator) {
2125             this.opcode = opcode;
2126             this.lhs = lhs;
2127             this.rhs = rhs;
2128             this.operator = operator;
2129         }
2130         @Override
2131         public void accept(Visitor v) { v.visitBinary(this); }
2132 
2133         @DefinedBy(Api.COMPILER_TREE)
2134         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2135         @DefinedBy(Api.COMPILER_TREE)
2136         public JCExpression getLeftOperand() { return lhs; }
2137         @DefinedBy(Api.COMPILER_TREE)
2138         public JCExpression getRightOperand() { return rhs; }
2139         @Override @DefinedBy(Api.COMPILER_TREE)
2140         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2141             return v.visitBinary(this, d);
2142         }
2143         @Override
2144         public JCExpression getOperand(OperandPos pos) {
2145             return pos == OperandPos.LEFT ? lhs : rhs;
2146         }
2147     }
2148 
2149     /**
2150      * A type cast.
2151      */
2152     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2153         public JCTree clazz;
2154         public JCExpression expr;
2155         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2156             this.clazz = clazz;
2157             this.expr = expr;
2158         }
2159         @Override
2160         public void accept(Visitor v) { v.visitTypeCast(this); }
2161 
2162         @DefinedBy(Api.COMPILER_TREE)
2163         public Kind getKind() { return Kind.TYPE_CAST; }
2164         @DefinedBy(Api.COMPILER_TREE)
2165         public JCTree getType() { return clazz; }
2166         @DefinedBy(Api.COMPILER_TREE)
2167         public JCExpression getExpression() { return expr; }
2168         @Override @DefinedBy(Api.COMPILER_TREE)
2169         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2170             return v.visitTypeCast(this, d);
2171         }
2172         @Override
2173         public Tag getTag() {
2174             return TYPECAST;
2175         }
2176     }
2177 
2178     /**
2179      * A type test.
2180      */
2181     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2182         public JCExpression expr;
2183         public JCTree pattern;
2184         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2185             this.expr = expr;
2186             this.pattern = pattern;
2187         }
2188         @Override
2189         public void accept(Visitor v) { v.visitTypeTest(this); }
2190 
2191         @DefinedBy(Api.COMPILER_TREE)
2192         public Kind getKind() { return Kind.INSTANCE_OF; }
2193         @DefinedBy(Api.COMPILER_TREE)
2194         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2195 
2196         @Override @DefinedBy(Api.COMPILER_TREE)
2197         public JCPattern getPattern() {
2198             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2199         }
2200 
2201         @DefinedBy(Api.COMPILER_TREE)
2202         public JCExpression getExpression() { return expr; }
2203         @Override @DefinedBy(Api.COMPILER_TREE)
2204         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2205             return v.visitInstanceOf(this, d);
2206         }
2207         @Override
2208         public Tag getTag() {
2209             return TYPETEST;
2210         }
2211     }
2212 
2213     /**
2214      * Pattern matching forms.
2215      */
2216     public static abstract class JCPattern extends JCTree
2217             implements PatternTree {
2218         public JCExpression constExpression() {
2219             return null;
2220         }
2221     }
2222 
2223     public static class JCBindingPattern extends JCPattern
2224             implements BindingPatternTree {
2225         public Name name;
2226         public BindingSymbol symbol;
2227         public JCTree vartype;
2228 
2229         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2230             this.name = name;
2231             this.symbol = symbol;
2232             this.vartype = vartype;
2233         }
2234 
2235         @DefinedBy(Api.COMPILER_TREE)
2236         public Name getBinding() {
2237             return name;
2238         }
2239 
2240         @Override @DefinedBy(Api.COMPILER_TREE)
2241         public Tree getType() {
2242             return vartype;
2243         }
2244 
2245         @Override
2246         public void accept(Visitor v) {
2247             v.visitBindingPattern(this);
2248         }
2249 
2250         @DefinedBy(Api.COMPILER_TREE)
2251         public Kind getKind() {
2252             return Kind.BINDING_PATTERN;
2253         }
2254 
2255         @Override
2256         @DefinedBy(Api.COMPILER_TREE)
2257         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2258             return v.visitBindingPattern(this, d);
2259         }
2260 
2261         @Override
2262         public Tag getTag() {
2263             return BINDINGPATTERN;
2264         }
2265     }
2266 
2267     /**
2268      * An array selection
2269      */
2270     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2271         public JCExpression indexed;
2272         public JCExpression index;
2273         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2274             this.indexed = indexed;
2275             this.index = index;
2276         }
2277         @Override
2278         public void accept(Visitor v) { v.visitIndexed(this); }
2279 
2280         @DefinedBy(Api.COMPILER_TREE)
2281         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2282         @DefinedBy(Api.COMPILER_TREE)
2283         public JCExpression getExpression() { return indexed; }
2284         @DefinedBy(Api.COMPILER_TREE)
2285         public JCExpression getIndex() { return index; }
2286         @Override @DefinedBy(Api.COMPILER_TREE)
2287         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2288             return v.visitArrayAccess(this, d);
2289         }
2290         @Override
2291         public Tag getTag() {
2292             return INDEXED;
2293         }
2294     }
2295 
2296     /**
2297      * Selects through packages and classes
2298      */
2299     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2300         /** selected Tree hierarchy */
2301         public JCExpression selected;
2302         /** name of field to select thru */
2303         public Name name;
2304         /** symbol of the selected class */
2305         public Symbol sym;
2306         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2307             this.selected = selected;
2308             this.name = name;
2309             this.sym = sym;
2310         }
2311         @Override
2312         public void accept(Visitor v) { v.visitSelect(this); }
2313 
2314         @DefinedBy(Api.COMPILER_TREE)
2315         public Kind getKind() { return Kind.MEMBER_SELECT; }
2316         @DefinedBy(Api.COMPILER_TREE)
2317         public JCExpression getExpression() { return selected; }
2318         @Override @DefinedBy(Api.COMPILER_TREE)
2319         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2320             return v.visitMemberSelect(this, d);
2321         }
2322         @DefinedBy(Api.COMPILER_TREE)
2323         public Name getIdentifier() { return name; }
2324         @Override
2325         public Tag getTag() {
2326             return SELECT;
2327         }
2328     }
2329 
2330     /**
2331      * Selects a member expression.
2332      */
2333     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2334 
2335         public ReferenceMode mode;
2336         public ReferenceKind kind;
2337         public Name name;
2338         public JCExpression expr;
2339         public List&lt;JCExpression&gt; typeargs;
2340         public Symbol sym;
2341         public Type varargsElement;
2342         public PolyKind refPolyKind;
2343         public boolean ownerAccessible;
2344         private OverloadKind overloadKind;
2345         public Type referentType;
2346 
2347         public enum OverloadKind {
2348             OVERLOADED,
2349             UNOVERLOADED,
2350             ERROR
2351         }
2352 
2353         /**
2354          * Javac-dependent classification for member references, based
2355          * on relevant properties w.r.t. code-generation
2356          */
2357         public enum ReferenceKind {
2358             /** super # instMethod */
2359             SUPER(ReferenceMode.INVOKE, false),
2360             /** Type # instMethod */
2361             UNBOUND(ReferenceMode.INVOKE, true),
2362             /** Type # staticMethod */
2363             STATIC(ReferenceMode.INVOKE, false),
2364             /** Expr # instMethod */
2365             BOUND(ReferenceMode.INVOKE, false),
2366             /** Inner # new */
2367             IMPLICIT_INNER(ReferenceMode.NEW, false),
2368             /** Toplevel # new */
2369             TOPLEVEL(ReferenceMode.NEW, false),
2370             /** ArrayType # new */
2371             ARRAY_CTOR(ReferenceMode.NEW, false);
2372 
2373             final ReferenceMode mode;
2374             final boolean unbound;
2375 
2376             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2377                 this.mode = mode;
2378                 this.unbound = unbound;
2379             }
2380 
2381             public boolean isUnbound() {
2382                 return unbound;
2383             }
2384         }
2385 
2386         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2387             this.mode = mode;
2388             this.name = name;
2389             this.expr = expr;
2390             this.typeargs = typeargs;
2391         }
2392         @Override
2393         public void accept(Visitor v) { v.visitReference(this); }
2394 
2395         @DefinedBy(Api.COMPILER_TREE)
2396         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2397         @Override @DefinedBy(Api.COMPILER_TREE)
2398         public ReferenceMode getMode() { return mode; }
2399         @Override @DefinedBy(Api.COMPILER_TREE)
2400         public JCExpression getQualifierExpression() { return expr; }
2401         @Override @DefinedBy(Api.COMPILER_TREE)
2402         public Name getName() { return name; }
2403         @Override @DefinedBy(Api.COMPILER_TREE)
2404         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2405 
2406         @Override @DefinedBy(Api.COMPILER_TREE)
2407         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2408             return v.visitMemberReference(this, d);
2409         }
2410         @Override
2411         public Tag getTag() {
2412             return REFERENCE;
2413         }
2414         public boolean hasKind(ReferenceKind kind) {
2415             return this.kind == kind;
2416         }
2417 
2418         /**
2419          * @return the overloadKind
2420          */
2421         public OverloadKind getOverloadKind() {
2422             return overloadKind;
2423         }
2424 
2425         /**
2426          * @param overloadKind the overloadKind to set
2427          */
2428         public void setOverloadKind(OverloadKind overloadKind) {
2429             this.overloadKind = overloadKind;
2430         }
2431     }
2432 
2433     /**
2434      * An identifier
2435      */
2436     public static class JCIdent extends JCExpression implements IdentifierTree {
2437         /** the name */
2438         public Name name;
2439         /** the symbol */
2440         public Symbol sym;
2441         protected JCIdent(Name name, Symbol sym) {
2442             this.name = name;
2443             this.sym = sym;
2444         }
2445         @Override
2446         public void accept(Visitor v) { v.visitIdent(this); }
2447 
2448         @DefinedBy(Api.COMPILER_TREE)
2449         public Kind getKind() { return Kind.IDENTIFIER; }
2450         @DefinedBy(Api.COMPILER_TREE)
2451         public Name getName() { return name; }
2452         @Override @DefinedBy(Api.COMPILER_TREE)
2453         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2454             return v.visitIdentifier(this, d);
2455         }
2456         @Override
2457         public Tag getTag() {
2458             return IDENT;
2459         }
2460     }
2461 
2462     /**
2463      * A constant value given literally.
2464      */
2465     public static class JCLiteral extends JCExpression implements LiteralTree {
2466         public TypeTag typetag;
2467         /** value representation */
2468         public Object value;
2469         protected JCLiteral(TypeTag typetag, Object value) {
2470             this.typetag = typetag;
2471             this.value = value;
2472         }
2473         @Override
2474         public void accept(Visitor v) { v.visitLiteral(this); }
2475 
2476         @DefinedBy(Api.COMPILER_TREE)
2477         public Kind getKind() {
2478             return typetag.getKindLiteral();
2479         }
2480 
2481         @DefinedBy(Api.COMPILER_TREE)
2482         public Object getValue() {
2483             switch (typetag) {
2484                 case BOOLEAN:
2485                     int bi = (Integer) value;
2486                     return (bi != 0);
2487                 case CHAR:
2488                     int ci = (Integer) value;
2489                     char c = (char) ci;
2490                     if (c != ci)
2491                         throw new AssertionError(&quot;bad value for char literal&quot;);
2492                     return c;
2493                 default:
2494                     return value;
2495             }
2496         }
2497         @Override @DefinedBy(Api.COMPILER_TREE)
2498         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2499             return v.visitLiteral(this, d);
2500         }
2501         @Override
2502         public JCLiteral setType(Type type) {
2503             super.setType(type);
2504             return this;
2505         }
2506         @Override
2507         public Tag getTag() {
2508             return LITERAL;
2509         }
2510     }
2511 
2512     /**
2513      * Identifies a basic type.
2514      * @see TypeTag
2515      */
2516     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2517         /** the basic type id */
2518         public TypeTag typetag;
2519         protected JCPrimitiveTypeTree(TypeTag typetag) {
2520             this.typetag = typetag;
2521         }
2522         @Override
2523         public void accept(Visitor v) { v.visitTypeIdent(this); }
2524 
2525         @DefinedBy(Api.COMPILER_TREE)
2526         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2527         @DefinedBy(Api.COMPILER_TREE)
2528         public TypeKind getPrimitiveTypeKind() {
2529             return typetag.getPrimitiveTypeKind();
2530         }
2531 
2532         @Override @DefinedBy(Api.COMPILER_TREE)
2533         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2534             return v.visitPrimitiveType(this, d);
2535         }
2536         @Override
2537         public Tag getTag() {
2538             return TYPEIDENT;
2539         }
2540     }
2541 
2542     /**
2543      * An array type, A[]
2544      */
2545     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2546         public JCExpression elemtype;
2547         protected JCArrayTypeTree(JCExpression elemtype) {
2548             this.elemtype = elemtype;
2549         }
2550         @Override
2551         public void accept(Visitor v) { v.visitTypeArray(this); }
2552 
2553         @DefinedBy(Api.COMPILER_TREE)
2554         public Kind getKind() { return Kind.ARRAY_TYPE; }
2555         @DefinedBy(Api.COMPILER_TREE)
2556         public JCTree getType() { return elemtype; }
2557         @Override @DefinedBy(Api.COMPILER_TREE)
2558         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2559             return v.visitArrayType(this, d);
2560         }
2561         @Override
2562         public Tag getTag() {
2563             return TYPEARRAY;
2564         }
2565     }
2566 
2567     /**
2568      * A parameterized type, {@literal T&lt;...&gt;}
2569      */
2570     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2571         public JCExpression clazz;
2572         public List&lt;JCExpression&gt; arguments;
2573         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2574             this.clazz = clazz;
2575             this.arguments = arguments;
2576         }
2577         @Override
2578         public void accept(Visitor v) { v.visitTypeApply(this); }
2579 
2580         @DefinedBy(Api.COMPILER_TREE)
2581         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2582         @DefinedBy(Api.COMPILER_TREE)
2583         public JCTree getType() { return clazz; }
2584         @DefinedBy(Api.COMPILER_TREE)
2585         public List&lt;JCExpression&gt; getTypeArguments() {
2586             return arguments;
2587         }
2588         @Override @DefinedBy(Api.COMPILER_TREE)
2589         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2590             return v.visitParameterizedType(this, d);
2591         }
2592         @Override
2593         public Tag getTag() {
2594             return TYPEAPPLY;
2595         }
2596     }
2597 
2598     /**
2599      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2600      */
2601     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2602 
2603         public List&lt;JCExpression&gt; alternatives;
2604 
2605         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2606             this.alternatives = components;
2607         }
2608         @Override
2609         public void accept(Visitor v) { v.visitTypeUnion(this); }
2610 
2611         @DefinedBy(Api.COMPILER_TREE)
2612         public Kind getKind() { return Kind.UNION_TYPE; }
2613 
2614         @DefinedBy(Api.COMPILER_TREE)
2615         public List&lt;JCExpression&gt; getTypeAlternatives() {
2616             return alternatives;
2617         }
2618         @Override @DefinedBy(Api.COMPILER_TREE)
2619         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2620             return v.visitUnionType(this, d);
2621         }
2622         @Override
2623         public Tag getTag() {
2624             return TYPEUNION;
2625         }
2626     }
2627 
2628     /**
2629      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2630      */
2631     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2632 
2633         public List&lt;JCExpression&gt; bounds;
2634 
2635         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2636             this.bounds = bounds;
2637         }
2638         @Override
2639         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2640 
2641         @DefinedBy(Api.COMPILER_TREE)
2642         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2643 
2644         @DefinedBy(Api.COMPILER_TREE)
2645         public List&lt;JCExpression&gt; getBounds() {
2646             return bounds;
2647         }
2648         @Override @DefinedBy(Api.COMPILER_TREE)
2649         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2650             return v.visitIntersectionType(this, d);
2651         }
2652         @Override
2653         public Tag getTag() {
2654             return TYPEINTERSECTION;
2655         }
2656     }
2657 
2658     /**
2659      * A formal class parameter.
2660      */
2661     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2662         /** name */
2663         public Name name;
2664         /** bounds */
2665         public List&lt;JCExpression&gt; bounds;
2666         /** type annotations on type parameter */
2667         public List&lt;JCAnnotation&gt; annotations;
2668         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2669             this.name = name;
2670             this.bounds = bounds;
2671             this.annotations = annotations;
2672         }
2673         @Override
2674         public void accept(Visitor v) { v.visitTypeParameter(this); }
2675 
2676         @DefinedBy(Api.COMPILER_TREE)
2677         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2678         @DefinedBy(Api.COMPILER_TREE)
2679         public Name getName() { return name; }
2680         @DefinedBy(Api.COMPILER_TREE)
2681         public List&lt;JCExpression&gt; getBounds() {
2682             return bounds;
2683         }
2684         @DefinedBy(Api.COMPILER_TREE)
2685         public List&lt;JCAnnotation&gt; getAnnotations() {
2686             return annotations;
2687         }
2688         @Override @DefinedBy(Api.COMPILER_TREE)
2689         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2690             return v.visitTypeParameter(this, d);
2691         }
2692         @Override
2693         public Tag getTag() {
2694             return TYPEPARAMETER;
2695         }
2696     }
2697 
2698     public static class JCWildcard extends JCExpression implements WildcardTree {
2699         public TypeBoundKind kind;
2700         public JCTree inner;
2701         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2702             this.kind = Assert.checkNonNull(kind);
2703             this.inner = inner;
2704         }
2705         @Override
2706         public void accept(Visitor v) { v.visitWildcard(this); }
2707 
2708         @DefinedBy(Api.COMPILER_TREE)
2709         public Kind getKind() {
2710             switch (kind.kind) {
2711             case UNBOUND:
2712                 return Kind.UNBOUNDED_WILDCARD;
2713             case EXTENDS:
2714                 return Kind.EXTENDS_WILDCARD;
2715             case SUPER:
2716                 return Kind.SUPER_WILDCARD;
2717             default:
2718                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2719             }
2720         }
2721         @DefinedBy(Api.COMPILER_TREE)
2722         public JCTree getBound() { return inner; }
2723         @Override @DefinedBy(Api.COMPILER_TREE)
2724         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2725             return v.visitWildcard(this, d);
2726         }
2727         @Override
2728         public Tag getTag() {
2729             return Tag.WILDCARD;
2730         }
2731     }
2732 
2733     public static class TypeBoundKind extends JCTree {
2734         public BoundKind kind;
2735         protected TypeBoundKind(BoundKind kind) {
2736             this.kind = kind;
2737         }
2738         @Override
2739         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2740 
2741         @DefinedBy(Api.COMPILER_TREE)
2742         public Kind getKind() {
2743             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2744         }
2745         @Override @DefinedBy(Api.COMPILER_TREE)
2746         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2747             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2748         }
2749         @Override
2750         public Tag getTag() {
2751             return TYPEBOUNDKIND;
2752         }
2753     }
2754 
2755     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2756         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2757         private Tag tag;
2758 
2759         public JCTree annotationType;
2760         public List&lt;JCExpression&gt; args;
2761         public Attribute.Compound attribute;
2762 
2763         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2764             this.tag = tag;
2765             this.annotationType = annotationType;
2766             this.args = args;
2767         }
2768 
2769         @Override
2770         public void accept(Visitor v) { v.visitAnnotation(this); }
2771 
2772         @DefinedBy(Api.COMPILER_TREE)
2773         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2774 
2775         @DefinedBy(Api.COMPILER_TREE)
2776         public JCTree getAnnotationType() { return annotationType; }
2777         @DefinedBy(Api.COMPILER_TREE)
2778         public List&lt;JCExpression&gt; getArguments() {
2779             return args;
2780         }
2781         @Override @DefinedBy(Api.COMPILER_TREE)
2782         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2783             return v.visitAnnotation(this, d);
2784         }
2785         @Override
2786         public Tag getTag() {
2787             return tag;
2788         }
2789     }
2790 
2791     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2792         public long flags;
2793         public List&lt;JCAnnotation&gt; annotations;
2794         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2795             this.flags = flags;
2796             this.annotations = annotations;
2797         }
2798         @Override
2799         public void accept(Visitor v) { v.visitModifiers(this); }
2800 
2801         @DefinedBy(Api.COMPILER_TREE)
2802         public Kind getKind() { return Kind.MODIFIERS; }
2803         @DefinedBy(Api.COMPILER_TREE)
2804         public Set&lt;Modifier&gt; getFlags() {
2805             return Flags.asModifierSet(flags);
2806         }
2807         @DefinedBy(Api.COMPILER_TREE)
2808         public List&lt;JCAnnotation&gt; getAnnotations() {
2809             return annotations;
2810         }
2811         @Override @DefinedBy(Api.COMPILER_TREE)
2812         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2813             return v.visitModifiers(this, d);
2814         }
2815         @Override
2816         public Tag getTag() {
2817             return MODIFIERS;
2818         }
2819     }
2820 
2821     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2822         // type annotations
2823         public List&lt;JCAnnotation&gt; annotations;
2824         public JCExpression underlyingType;
2825 
2826         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2827             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2828             this.annotations = annotations;
2829             this.underlyingType = underlyingType;
2830         }
2831         @Override
2832         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2833 
2834         @DefinedBy(Api.COMPILER_TREE)
2835         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2836         @DefinedBy(Api.COMPILER_TREE)
2837         public List&lt;JCAnnotation&gt; getAnnotations() {
2838             return annotations;
2839         }
2840         @DefinedBy(Api.COMPILER_TREE)
2841         public JCExpression getUnderlyingType() {
2842             return underlyingType;
2843         }
2844         @Override @DefinedBy(Api.COMPILER_TREE)
2845         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2846             return v.visitAnnotatedType(this, d);
2847         }
2848         @Override
2849         public Tag getTag() {
2850             return ANNOTATED_TYPE;
2851         }
2852     }
2853 
2854     public static abstract class JCDirective extends JCTree
2855         implements DirectiveTree {
2856     }
2857 
2858     public static class JCModuleDecl extends JCTree implements ModuleTree {
2859         public JCModifiers mods;
2860         public ModuleType type;
2861         private final ModuleKind kind;
2862         public JCExpression qualId;
2863         public List&lt;JCDirective&gt; directives;
2864         public ModuleSymbol sym;
2865 
2866         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2867                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2868             this.mods = mods;
2869             this.kind = kind;
2870             this.qualId = qualId;
2871             this.directives = directives;
2872         }
2873 
2874         @Override
2875         public void accept(Visitor v) { v.visitModuleDef(this); }
2876 
2877         @Override @DefinedBy(Api.COMPILER_TREE)
2878         public Kind getKind() {
2879             return Kind.MODULE;
2880         }
2881 
2882         @Override @DefinedBy(Api.COMPILER_TREE)
2883         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2884             return mods.annotations;
2885         }
2886 
2887         @Override @DefinedBy(Api.COMPILER_TREE)
2888         public ModuleKind getModuleType() {
2889             return kind;
2890         }
2891 
2892         @Override @DefinedBy(Api.COMPILER_TREE)
2893         public JCExpression getName() {
2894             return qualId;
2895         }
2896 
2897         @Override @DefinedBy(Api.COMPILER_TREE)
2898         public List&lt;JCDirective&gt; getDirectives() {
2899             return directives;
2900         }
2901 
2902         @Override @DefinedBy(Api.COMPILER_TREE)
2903         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2904             return v.visitModule(this, d);
2905         }
2906 
2907         @Override
2908         public Tag getTag() {
2909             return MODULEDEF;
2910         }
2911     }
2912 
2913     public static class JCExports extends JCDirective
2914             implements ExportsTree {
2915         public JCExpression qualid;
2916         public List&lt;JCExpression&gt; moduleNames;
2917         public ExportsDirective directive;
2918 
2919         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2920             this.qualid = qualId;
2921             this.moduleNames = moduleNames;
2922         }
2923 
2924         @Override
2925         public void accept(Visitor v) { v.visitExports(this); }
2926 
2927         @Override @DefinedBy(Api.COMPILER_TREE)
2928         public Kind getKind() {
2929             return Kind.EXPORTS;
2930         }
2931 
2932         @Override @DefinedBy(Api.COMPILER_TREE)
2933         public JCExpression getPackageName() {
2934             return qualid;
2935         }
2936 
2937         @Override @DefinedBy(Api.COMPILER_TREE)
2938         public List&lt;JCExpression&gt; getModuleNames() {
2939             return moduleNames;
2940         }
2941 
2942         @Override @DefinedBy(Api.COMPILER_TREE)
2943         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2944             return v.visitExports(this, d);
2945         }
2946 
2947         @Override
2948         public Tag getTag() {
2949             return Tag.EXPORTS;
2950         }
2951     }
2952 
2953     public static class JCOpens extends JCDirective
2954             implements OpensTree {
2955         public JCExpression qualid;
2956         public List&lt;JCExpression&gt; moduleNames;
2957         public OpensDirective directive;
2958 
2959         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2960             this.qualid = qualId;
2961             this.moduleNames = moduleNames;
2962         }
2963 
2964         @Override
2965         public void accept(Visitor v) { v.visitOpens(this); }
2966 
2967         @Override @DefinedBy(Api.COMPILER_TREE)
2968         public Kind getKind() {
2969             return Kind.OPENS;
2970         }
2971 
2972         @Override @DefinedBy(Api.COMPILER_TREE)
2973         public JCExpression getPackageName() {
2974             return qualid;
2975         }
2976 
2977         @Override @DefinedBy(Api.COMPILER_TREE)
2978         public List&lt;JCExpression&gt; getModuleNames() {
2979             return moduleNames;
2980         }
2981 
2982         @Override @DefinedBy(Api.COMPILER_TREE)
2983         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2984             return v.visitOpens(this, d);
2985         }
2986 
2987         @Override
2988         public Tag getTag() {
2989             return Tag.OPENS;
2990         }
2991     }
2992 
2993     public static class JCProvides extends JCDirective
2994             implements ProvidesTree {
2995         public JCExpression serviceName;
2996         public List&lt;JCExpression&gt; implNames;
2997 
2998         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
2999             this.serviceName = serviceName;
3000             this.implNames = implNames;
3001         }
3002 
3003         @Override
3004         public void accept(Visitor v) { v.visitProvides(this); }
3005 
3006         @Override @DefinedBy(Api.COMPILER_TREE)
3007         public Kind getKind() {
3008             return Kind.PROVIDES;
3009         }
3010 
3011         @Override @DefinedBy(Api.COMPILER_TREE)
3012         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3013             return v.visitProvides(this, d);
3014         }
3015 
3016         @Override @DefinedBy(Api.COMPILER_TREE)
3017         public JCExpression getServiceName() {
3018             return serviceName;
3019         }
3020 
3021         @Override @DefinedBy(Api.COMPILER_TREE)
3022         public List&lt;JCExpression&gt; getImplementationNames() {
3023             return implNames;
3024         }
3025 
3026         @Override
3027         public Tag getTag() {
3028             return PROVIDES;
3029         }
3030     }
3031 
3032     public static class JCRequires extends JCDirective
3033             implements RequiresTree {
3034         public boolean isTransitive;
3035         public boolean isStaticPhase;
3036         public JCExpression moduleName;
3037         public RequiresDirective directive;
3038 
3039         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3040             this.isTransitive = isTransitive;
3041             this.isStaticPhase = isStaticPhase;
3042             this.moduleName = moduleName;
3043         }
3044 
3045         @Override
3046         public void accept(Visitor v) { v.visitRequires(this); }
3047 
3048         @Override @DefinedBy(Api.COMPILER_TREE)
3049         public Kind getKind() {
3050             return Kind.REQUIRES;
3051         }
3052 
3053         @Override @DefinedBy(Api.COMPILER_TREE)
3054         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3055             return v.visitRequires(this, d);
3056         }
3057 
3058         @Override @DefinedBy(Api.COMPILER_TREE)
3059         public boolean isTransitive() {
3060             return isTransitive;
3061         }
3062 
3063         @Override @DefinedBy(Api.COMPILER_TREE)
3064         public boolean isStatic() {
3065             return isStaticPhase;
3066         }
3067 
3068         @Override @DefinedBy(Api.COMPILER_TREE)
3069         public JCExpression getModuleName() {
3070             return moduleName;
3071         }
3072 
3073         @Override
3074         public Tag getTag() {
3075             return REQUIRES;
3076         }
3077     }
3078 
3079     public static class JCUses extends JCDirective
3080             implements UsesTree {
3081         public JCExpression qualid;
3082 
3083         protected JCUses(JCExpression qualId) {
3084             this.qualid = qualId;
3085         }
3086 
3087         @Override
3088         public void accept(Visitor v) { v.visitUses(this); }
3089 
3090         @Override @DefinedBy(Api.COMPILER_TREE)
3091         public Kind getKind() {
3092             return Kind.USES;
3093         }
3094 
3095         @Override @DefinedBy(Api.COMPILER_TREE)
3096         public JCExpression getServiceName() {
3097             return qualid;
3098         }
3099 
3100         @Override @DefinedBy(Api.COMPILER_TREE)
3101         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3102             return v.visitUses(this, d);
3103         }
3104 
3105         @Override
3106         public Tag getTag() {
3107             return USES;
3108         }
3109     }
3110 
3111     public static class JCErroneous extends JCExpression
3112             implements ErroneousTree {
3113         public List&lt;? extends JCTree&gt; errs;
3114         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3115             this.errs = errs;
3116         }
3117         @Override
3118         public void accept(Visitor v) { v.visitErroneous(this); }
3119 
3120         @DefinedBy(Api.COMPILER_TREE)
3121         public Kind getKind() { return Kind.ERRONEOUS; }
3122 
3123         @DefinedBy(Api.COMPILER_TREE)
3124         public List&lt;? extends JCTree&gt; getErrorTrees() {
3125             return errs;
3126         }
3127 
3128         @Override @DefinedBy(Api.COMPILER_TREE)
3129         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3130             return v.visitErroneous(this, d);
3131         }
3132         @Override
3133         public Tag getTag() {
3134             return ERRONEOUS;
3135         }
3136     }
3137 
3138     /** (let int x = 3; in x+2) */
3139     public static class LetExpr extends JCExpression {
3140         public List&lt;JCStatement&gt; defs;
3141         public JCExpression expr;
3142         /**true if a expr should be run through Gen.genCond:*/
3143         public boolean needsCond;
3144         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
3145             this.defs = defs;
3146             this.expr = expr;
3147         }
3148         @Override
3149         public void accept(Visitor v) { v.visitLetExpr(this); }
3150 
3151         @DefinedBy(Api.COMPILER_TREE)
3152         public Kind getKind() {
3153             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3154         }
3155         @Override @DefinedBy(Api.COMPILER_TREE)
3156         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3157             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3158         }
3159         @Override
3160         public Tag getTag() {
3161             return LETEXPR;
3162         }
3163     }
3164 
3165     /** An interface for tree factories
3166      */
3167     public interface Factory {
3168         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3169         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3170                                   JCExpression pid);
3171         JCImport Import(JCTree qualid, boolean staticImport);
3172         JCClassDecl ClassDef(JCModifiers mods,
3173                           Name name,
3174                           List&lt;JCTypeParameter&gt; typarams,
3175                           JCExpression extending,
3176                           List&lt;JCExpression&gt; implementing,
3177                           List&lt;JCTree&gt; defs);
3178         JCMethodDecl MethodDef(JCModifiers mods,
3179                             Name name,
3180                             JCExpression restype,
3181                             List&lt;JCTypeParameter&gt; typarams,
3182                             JCVariableDecl recvparam,
3183                             List&lt;JCVariableDecl&gt; params,
3184                             List&lt;JCExpression&gt; thrown,
3185                             JCBlock body,
3186                             JCExpression defaultValue);
3187         JCVariableDecl VarDef(JCModifiers mods,
3188                       Name name,
3189                       JCExpression vartype,
3190                       JCExpression init);
3191         JCSkip Skip();
3192         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3193         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3194         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3195         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3196                         JCExpression cond,
3197                         List&lt;JCExpressionStatement&gt; step,
3198                         JCStatement body);
3199         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3200         JCLabeledStatement Labelled(Name label, JCStatement body);
3201         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3202         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3203         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,
3204                     List&lt;JCStatement&gt; stats, JCTree body);
3205         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3206         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3207         JCTry Try(List&lt;JCTree&gt; resources,
3208                   JCBlock body,
3209                   List&lt;JCCatch&gt; catchers,
3210                   JCBlock finalizer);
3211         JCCatch Catch(JCVariableDecl param, JCBlock body);
3212         JCConditional Conditional(JCExpression cond,
3213                                 JCExpression thenpart,
3214                                 JCExpression elsepart);
3215         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3216         JCExpressionStatement Exec(JCExpression expr);
3217         JCBreak Break(Name label);
3218         JCYield Yield(JCExpression value);
3219         JCContinue Continue(Name label);
3220         JCReturn Return(JCExpression expr);
3221         JCThrow Throw(JCExpression expr);
3222         JCAssert Assert(JCExpression cond, JCExpression detail);
3223         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3224                     JCExpression fn,
3225                     List&lt;JCExpression&gt; args);
3226         JCNewClass NewClass(JCExpression encl,
3227                           List&lt;JCExpression&gt; typeargs,
3228                           JCExpression clazz,
3229                           List&lt;JCExpression&gt; args,
3230                           JCClassDecl def);
3231         JCNewArray NewArray(JCExpression elemtype,
3232                           List&lt;JCExpression&gt; dims,
3233                           List&lt;JCExpression&gt; elems);
3234         JCParens Parens(JCExpression expr);
3235         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3236         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3237         JCUnary Unary(Tag opcode, JCExpression arg);
3238         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3239         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3240         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3241         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3242         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3243         JCFieldAccess Select(JCExpression selected, Name selector);
3244         JCIdent Ident(Name idname);
3245         JCLiteral Literal(TypeTag tag, Object value);
3246         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3247         JCArrayTypeTree TypeArray(JCExpression elemtype);
3248         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3249         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3250         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3251         TypeBoundKind TypeBoundKind(BoundKind kind);
3252         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3253         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3254         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3255         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3256         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3257         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3258         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3259         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3260         JCUses Uses(JCExpression qualId);
3261         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
3262     }
3263 
3264     /** A generic visitor class for trees.
3265      */
3266     public static abstract class Visitor {
3267         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3268         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3269         public void visitImport(JCImport that)               { visitTree(that); }
3270         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3271         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3272         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3273         public void visitSkip(JCSkip that)                   { visitTree(that); }
3274         public void visitBlock(JCBlock that)                 { visitTree(that); }
3275         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3276         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3277         public void visitWithField(JCWithField that)         { visitTree(that); }
3278         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3279         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3280         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3281         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3282         public void visitCase(JCCase that)                   { visitTree(that); }
3283         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3284         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3285         public void visitTry(JCTry that)                     { visitTree(that); }
3286         public void visitCatch(JCCatch that)                 { visitTree(that); }
3287         public void visitConditional(JCConditional that)     { visitTree(that); }
3288         public void visitIf(JCIf that)                       { visitTree(that); }
3289         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3290         public void visitBreak(JCBreak that)                 { visitTree(that); }
3291         public void visitYield(JCYield that)                 { visitTree(that); }
3292         public void visitContinue(JCContinue that)           { visitTree(that); }
3293         public void visitReturn(JCReturn that)               { visitTree(that); }
3294         public void visitThrow(JCThrow that)                 { visitTree(that); }
3295         public void visitAssert(JCAssert that)               { visitTree(that); }
3296         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3297         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3298         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3299         public void visitLambda(JCLambda that)               { visitTree(that); }
3300         public void visitParens(JCParens that)               { visitTree(that); }
3301         public void visitAssign(JCAssign that)               { visitTree(that); }
3302         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3303         public void visitUnary(JCUnary that)                 { visitTree(that); }
3304         public void visitBinary(JCBinary that)               { visitTree(that); }
3305         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3306         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3307         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3308         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3309         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3310         public void visitReference(JCMemberReference that)   { visitTree(that); }
3311         public void visitIdent(JCIdent that)                 { visitTree(that); }
3312         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3313         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3314         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3315         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3316         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3317         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3318         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3319         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3320         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3321         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3322         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3323         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3324         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3325         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3326         public void visitExports(JCExports that)             { visitTree(that); }
3327         public void visitOpens(JCOpens that)                 { visitTree(that); }
3328         public void visitProvides(JCProvides that)           { visitTree(that); }
3329         public void visitRequires(JCRequires that)           { visitTree(that); }
3330         public void visitUses(JCUses that)                   { visitTree(that); }
3331         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3332 
3333         public void visitTree(JCTree that)                   { Assert.error(); }
3334     }
3335 
3336 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
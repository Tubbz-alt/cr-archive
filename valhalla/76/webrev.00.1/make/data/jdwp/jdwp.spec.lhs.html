<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/data/jdwp/jdwp.spec</title>
    <link rel="stylesheet" href="../../../style.css" />
    <script type="text/javascript" src="../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 JDWP &quot;Java(tm) Debug Wire Protocol&quot;
  27 (CommandSet VirtualMachine=1
  28     (Command Version=1
  29         &quot;Returns the JDWP version implemented by the target VM. &quot;
  30         &quot;The version string format is implementation dependent. &quot;
  31         (Out
  32         )
  33         (Reply
  34             (string description &quot;Text information on the VM version&quot;)
  35             (int    jdwpMajor   &quot;Major JDWP Version number&quot;)
  36             (int    jdwpMinor   &quot;Minor JDWP Version number&quot;)
  37             (string vmVersion   &quot;Target VM JRE version, as in the java.version property&quot;)
  38             (string vmName      &quot;Target VM name, as in the java.vm.name property&quot;)
  39         )
  40         (ErrorSet
  41             (Error VM_DEAD)
  42         )
  43     )
  44     (Command ClassesBySignature=2
  45         &quot;Returns reference types for all the classes loaded by the target VM &quot;
  46         &quot;which match the given signature. &quot;
  47         &quot;Multple reference types will be returned if two or more class &quot;
  48         &quot;loaders have loaded a class of the same name. &quot;
  49         &quot;The search is confined to loaded classes only; no attempt is made &quot;
  50         &quot;to load a class of the given signature. &quot;
  51         (Out
  52             (string signature &quot;JNI signature of the class to find &quot;
  53                               &quot;(for example, \&quot;Ljava/lang/String;\&quot;). &quot;
  54             )
  55         )
  56         (Reply
  57             (Repeat classes &quot;Number of reference types that follow.&quot;
  58                 (Group ClassInfo
  59                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  60                                       &quot;of following reference type. &quot;)
  61                     (referenceTypeID typeID &quot;Matching loaded reference type&quot;)
  62                     (int status &quot;The current class &quot;
  63                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  64                 )
  65             )
  66         )
  67         (ErrorSet
  68             (Error VM_DEAD)
  69         )
  70     )
  71     (Command AllClasses=3
  72         &quot;Returns reference types for all classes currently loaded by the &quot;
  73         &quot;target VM. &quot;
  74         &quot;See &lt;a href=\&quot;../jvmti.html#GetLoadedClasses\&quot;&gt;JVM TI GetLoadedClasses&lt;/a&gt;.&quot;
  75         (Out
  76         )
  77         (Reply
  78             (Repeat classes &quot;Number of reference types that follow.&quot;
  79                 (Group ClassInfo
  80                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
  81                                       &quot;of following reference type. &quot;)
  82                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
  83                     (string signature
  84                                 &quot;The JNI signature of the loaded reference type&quot;)
  85                     (int status &quot;The current class &quot;
  86                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
  87                 )
  88             )
  89         )
  90         (ErrorSet
  91             (Error VM_DEAD)
  92         )
  93     )
  94     (Command AllThreads=4
  95         &quot;Returns all threads currently running in the target VM . &quot;
  96         &quot;The returned list contains threads created through &quot;
  97         &quot;java.lang.Thread, all native threads attached to &quot;
  98         &quot;the target VM through JNI, and system threads created &quot;
  99         &quot;by the target VM. Threads that have not yet been started &quot;
 100         &quot;and threads that have completed their execution are not &quot;
 101         &quot;included in the returned list. &quot;
 102         (Out
 103         )
 104         (Reply
 105             (Repeat threads &quot;Number of threads that follow.&quot;
 106                 (threadObject thread &quot;A running thread&quot;)
 107             )
 108         )
 109         (ErrorSet
 110             (Error VM_DEAD)
 111         )
 112     )
 113     (Command TopLevelThreadGroups=5
 114         &quot;Returns all thread groups that do not have a parent. This command &quot;
 115         &quot;may be used as the first step in building a tree (or trees) of the &quot;
 116         &quot;existing thread groups.&quot;
 117         (Out
 118         )
 119         (Reply
 120             (Repeat groups &quot;Number of thread groups that follow.&quot;
 121                 (threadGroupObject group &quot;A top level thread group&quot;)
 122             )
 123         )
 124         (ErrorSet
 125             (Error VM_DEAD)
 126         )
 127     )
 128     (Command Dispose=6
 129         &quot;Invalidates this virtual machine mirror. &quot;
 130         &quot;The communication channel to the target VM is closed, and &quot;
 131         &quot;the target VM prepares to accept another subsequent connection &quot;
 132         &quot;from this debugger or another debugger, including the &quot;
 133         &quot;following tasks: &quot;
 134         &quot;&lt;ul&gt;&quot;
 135         &quot;&lt;li&gt;All event requests are cancelled. &quot;
 136         &quot;&lt;li&gt;All threads suspended by the thread-level &quot;
 137         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 138         &quot;or the VM-level &quot;
 139         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;resume&lt;/a&gt; command &quot;
 140         &quot;are resumed as many times as necessary for them to run. &quot;
 141         &quot;&lt;li&gt;Garbage collection is re-enabled in all cases where it was &quot;
 142         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;disabled&lt;/a&gt; &quot;
 143         &quot;&lt;/ul&gt;&quot;
 144         &quot;Any current method invocations executing in the target VM &quot;
 145         &quot;are continued after the disconnection. Upon completion of any such &quot;
 146         &quot;method invocation, the invoking thread continues from the &quot;
 147         &quot;location where it was originally stopped. &quot;
 148         &quot;&lt;p&gt;&quot;
 149         &quot;Resources originating in  &quot;
 150         &quot;this VirtualMachine (ObjectReferences, ReferenceTypes, etc.) &quot;
 151         &quot;will become invalid. &quot;
 152         (Out
 153         )
 154         (Reply
 155         )
 156         (ErrorSet
 157         )
 158     )
 159     (Command IDSizes=7
 160         &quot;Returns the sizes of variably-sized data types in the target VM.&quot;
 161         &quot;The returned values indicate the number of bytes used by the &quot;
 162         &quot;identifiers in command and reply packets.&quot;
 163         (Out
 164         )
 165         (Reply
 166             (int fieldIDSize &quot;fieldID size in bytes &quot;)
 167             (int methodIDSize &quot;methodID size in bytes &quot;)
 168             (int objectIDSize &quot;objectID size in bytes &quot;)
 169             (int referenceTypeIDSize &quot;referenceTypeID size in bytes &quot;)
 170             (int frameIDSize &quot;frameID size in bytes &quot;)
 171         )
 172         (ErrorSet
 173             (Error VM_DEAD)
 174         )
 175     )
 176     (Command Suspend=8
 177         &quot;Suspends the execution of the application running in the target &quot;
 178         &quot;VM. All Java threads currently running will be suspended. &quot;
 179         &quot;&lt;p&gt;&quot;
 180         &quot;Unlike java.lang.Thread.suspend, &quot;
 181         &quot;suspends of both the virtual machine and individual threads are &quot;
 182         &quot;counted. Before a thread will run again, it must be resumed through &quot;
 183         &quot;the &lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-level resume&lt;/a&gt; command &quot;
 184         &quot;or the &lt;a href=\&quot;#JDWP_ThreadReference_Resume\&quot;&gt;thread-level resume&lt;/a&gt; command &quot;
 185         &quot;the same number of times it has been suspended. &quot;
 186         (Out
 187         )
 188         (Reply
 189         )
 190         (ErrorSet
 191             (Error VM_DEAD)
 192         )
 193     )
 194     (Command Resume=9
 195         &quot;Resumes execution of the application after the suspend &quot;
 196         &quot;command or an event has stopped it. &quot;
 197         &quot;Suspensions of the Virtual Machine and individual threads are &quot;
 198         &quot;counted. If a particular thread is suspended n times, it must &quot;
 199         &quot;resumed n times before it will continue. &quot;
 200         (Out
 201         )
 202         (Reply
 203         )
 204         (ErrorSet
 205         )
 206     )
 207     (Command Exit=10
 208         &quot;Terminates the target VM with the given exit code. &quot;
 209         &quot;On some platforms, the exit code might be truncated, for &quot;
 210         &quot;example, to the low order 8 bits. &quot;
 211         &quot;All ids previously returned from the target VM become invalid. &quot;
 212         &quot;Threads running in the VM are abruptly terminated. &quot;
 213         &quot;A thread death exception is not thrown and &quot;
 214         &quot;finally blocks are not run.&quot;
 215         (Out
 216             (int exitCode &quot;the exit code&quot;)
 217         )
 218         (Reply
 219         )
 220         (ErrorSet
 221         )
 222     )
 223     (Command CreateString=11
 224         &quot;Creates a new string object in the target VM and returns &quot;
 225         &quot;its id. &quot;
 226         (Out
 227             (string utf &quot;UTF-8 characters to use in the created string. &quot;)
 228         )
 229         (Reply
 230             (stringObject stringObject
 231                 &quot;Created string (instance of java.lang.String) &quot;)
 232         )
 233         (ErrorSet
 234             (Error VM_DEAD)
 235         )
 236     )
 237     (Command Capabilities=12
 238         &quot;Retrieve this VM&#39;s capabilities. The capabilities are returned &quot;
 239         &quot;as booleans, each indicating the presence or absence of a &quot;
 240         &quot;capability. The commands associated with each capability will &quot;
 241         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 242         &quot;available.&quot;
 243         (Out
 244         )
 245         (Reply
 246             (boolean canWatchFieldModification
 247                      &quot;Can the VM watch field modification, and therefore &quot;
 248                      &quot;can it send the Modification Watchpoint Event?&quot;)
 249             (boolean canWatchFieldAccess
 250                      &quot;Can the VM watch field access, and therefore &quot;
 251                      &quot;can it send the Access Watchpoint Event?&quot;)
 252             (boolean canGetBytecodes
 253                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 254             (boolean canGetSyntheticAttribute
 255                      &quot;Can the VM determine whether a field or method is &quot;
 256                      &quot;synthetic? (that is, can the VM determine if the &quot;
 257                      &quot;method or the field was invented by the compiler?) &quot;)
 258             (boolean canGetOwnedMonitorInfo
 259                      &quot;Can the VM get the owned monitors infornation for &quot;
 260                      &quot;a thread?&quot;)
 261             (boolean canGetCurrentContendedMonitor
 262                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 263             (boolean canGetMonitorInfo
 264                      &quot;Can the VM get the monitor information for a given object? &quot;)
 265         )
 266         (ErrorSet
 267             (Error VM_DEAD)
 268         )
 269     )
 270     (Command ClassPaths=13
 271         &quot;Retrieve the classpath and bootclasspath of the target VM. &quot;
 272         &quot;If the classpath is not defined, returns an empty list. If the &quot;
 273         &quot;bootclasspath is not defined returns an empty list.&quot;
 274         (Out
 275         )
 276         (Reply
 277             (string baseDir &quot;Base directory used to resolve relative &quot;
 278                             &quot;paths in either of the following lists.&quot;)
 279             (Repeat classpaths &quot;Number of paths in classpath.&quot;
 280                 (string path &quot;One component of classpath&quot;) )
 281             (Repeat bootclasspaths &quot;Number of paths in bootclasspath.&quot;
 282                 (string path &quot;One component of bootclasspath&quot;) )
 283         )
 284         (ErrorSet
 285             (Error VM_DEAD)
 286         )
 287     )
 288     (Command DisposeObjects=14
 289         &quot;Releases a list of object IDs. For each object in the list, the &quot;
 290         &quot;following applies. &quot;
 291         &quot;The count of references held by the back-end (the reference &quot;
 292         &quot;count) will be decremented by refCnt. &quot;
 293         &quot;If thereafter the reference count is less than &quot;
 294         &quot;or equal to zero, the ID is freed. &quot;
 295         &quot;Any back-end resources associated with the freed ID may &quot;
 296         &quot;be freed, and if garbage collection was &quot;
 297         &quot;disabled for the object, it will be re-enabled. &quot;
 298         &quot;The sender of this command &quot;
 299         &quot;promises that no further commands will be sent &quot;
 300         &quot;referencing a freed ID.
 301         &quot;&lt;p&gt;&quot;
 302         &quot;Use of this command is not required. If it is not sent, &quot;
 303         &quot;resources associated with each ID will be freed by the back-end &quot;
 304         &quot;at some time after the corresponding object is garbage collected. &quot;
 305         &quot;It is most useful to use this command to reduce the load on the &quot;
 306         &quot;back-end if a very large number of &quot;
 307         &quot;objects has been retrieved from the back-end (a large array, &quot;
 308         &quot;for example) but may not be garbage collected any time soon. &quot;
 309         &quot;&lt;p&gt;&quot;
 310         &quot;IDs may be re-used by the back-end after they &quot;
 311         &quot;have been freed with this command.&quot;
 312         &quot;This description assumes reference counting, &quot;
 313         &quot;a back-end may use any implementation which operates &quot;
 314         &quot;equivalently. &quot;
 315         (Out
 316             (Repeat requests &quot;Number of object dispose requests that follow&quot;
 317                 (Group Request
 318                     (object object &quot;The object ID&quot;)
 319                     (int refCnt &quot;The number of times this object ID has been &quot;
 320                                 &quot;part of a packet received from the back-end. &quot;
 321                                 &quot;An accurate count prevents the object ID &quot;
 322                                 &quot;from being freed on the back-end if &quot;
 323                                 &quot;it is part of an incoming packet, not yet &quot;
 324                                 &quot;handled by the front-end.&quot;)
 325                 )
 326             )
 327         )
 328         (Reply
 329         )
 330         (ErrorSet
 331         )
 332     )
 333     (Command HoldEvents=15
 334         &quot;Tells the target VM to stop sending events. Events are not discarded; &quot;
 335         &quot;they are held until a subsequent ReleaseEvents command is sent. &quot;
 336         &quot;This command is useful to control the number of events sent &quot;
 337         &quot;to the debugger VM in situations where very large numbers of events &quot;
 338         &quot;are generated. &quot;
 339         &quot;While events are held by the debugger back-end, application &quot;
 340         &quot;execution may be frozen by the debugger back-end to prevent &quot;
 341         &quot;buffer overflows on the back end.
 342         &quot;Responses to commands are never held and are not affected by this
 343         &quot;command. If events are already being held, this command is &quot;
 344         &quot;ignored.&quot;
 345         (Out
 346         )
 347         (Reply
 348         )
 349         (ErrorSet
 350         )
 351     )
 352     (Command ReleaseEvents=16
 353         &quot;Tells the target VM to continue sending events. This command is &quot;
 354         &quot;used to restore normal activity after a HoldEvents command. If &quot;
 355         &quot;there is no current HoldEvents command in effect, this command is &quot;
 356         &quot;ignored.&quot;
 357         (Out
 358         )
 359         (Reply
 360         )
 361         (ErrorSet
 362         )
 363     )
 364     (Command CapabilitiesNew=17
 365         &quot;Retrieve all of this VM&#39;s capabilities. The capabilities are returned &quot;
 366         &quot;as booleans, each indicating the presence or absence of a &quot;
 367         &quot;capability. The commands associated with each capability will &quot;
 368         &quot;return the NOT_IMPLEMENTED error if the cabability is not &quot;
 369         &quot;available.&quot;
 370         &quot;Since JDWP version 1.4.&quot;
 371         (Out
 372         )
 373         (Reply
 374             (boolean canWatchFieldModification
 375                      &quot;Can the VM watch field modification, and therefore &quot;
 376                      &quot;can it send the Modification Watchpoint Event?&quot;)
 377             (boolean canWatchFieldAccess
 378                      &quot;Can the VM watch field access, and therefore &quot;
 379                      &quot;can it send the Access Watchpoint Event?&quot;)
 380             (boolean canGetBytecodes
 381                      &quot;Can the VM get the bytecodes of a given method? &quot;)
 382             (boolean canGetSyntheticAttribute
 383                      &quot;Can the VM determine whether a field or method is &quot;
 384                      &quot;synthetic? (that is, can the VM determine if the &quot;
 385                      &quot;method or the field was invented by the compiler?) &quot;)
 386             (boolean canGetOwnedMonitorInfo
 387                      &quot;Can the VM get the owned monitors infornation for &quot;
 388                      &quot;a thread?&quot;)
 389             (boolean canGetCurrentContendedMonitor
 390                      &quot;Can the VM get the current contended monitor of a thread?&quot;)
 391             (boolean canGetMonitorInfo
 392                      &quot;Can the VM get the monitor information for a given object? &quot;)
 393             (boolean canRedefineClasses
 394                      &quot;Can the VM redefine classes?&quot;)
 395             (boolean canAddMethod
 396                      &quot;Can the VM add methods when redefining &quot;
 397                      &quot;classes?&quot;)
 398             (boolean canUnrestrictedlyRedefineClasses
 399                      &quot;Can the VM redefine classes &quot;
 400                      &quot;in ways that are normally restricted?&quot;)
 401             (boolean canPopFrames
 402                      &quot;Can the VM pop stack frames?&quot;)
 403             (boolean canUseInstanceFilters
 404                      &quot;Can the VM filter events by specific object?&quot;)
 405             (boolean canGetSourceDebugExtension
 406                      &quot;Can the VM get the source debug extension?&quot;)
 407             (boolean canRequestVMDeathEvent
 408                      &quot;Can the VM request VM death events?&quot;)
 409             (boolean canSetDefaultStratum
 410                      &quot;Can the VM set a default stratum?&quot;)
 411             (boolean canGetInstanceInfo
 412                      &quot;Can the VM return instances, counts of instances of classes &quot;
 413                      &quot;and referring objects?&quot;)
 414             (boolean canRequestMonitorEvents
 415                      &quot;Can the VM request monitor events?&quot;)
 416             (boolean canGetMonitorFrameInfo
 417                      &quot;Can the VM get monitors with frame depth info?&quot;)
 418             (boolean canUseSourceNameFilters
 419                      &quot;Can the VM filter class prepare events by source name?&quot;)
 420             (boolean canGetConstantPool
 421                      &quot;Can the VM return the constant pool information?&quot;)
 422             (boolean canForceEarlyReturn
 423                      &quot;Can the VM force early return from a method?&quot;)
 424             (boolean reserved22
 425                      &quot;Reserved for future capability&quot;)
 426             (boolean reserved23
 427                      &quot;Reserved for future capability&quot;)
 428             (boolean reserved24
 429                      &quot;Reserved for future capability&quot;)
 430             (boolean reserved25
 431                      &quot;Reserved for future capability&quot;)
 432             (boolean reserved26
 433                      &quot;Reserved for future capability&quot;)
 434             (boolean reserved27
 435                      &quot;Reserved for future capability&quot;)
 436             (boolean reserved28
 437                      &quot;Reserved for future capability&quot;)
 438             (boolean reserved29
 439                      &quot;Reserved for future capability&quot;)
 440             (boolean reserved30
 441                      &quot;Reserved for future capability&quot;)
 442             (boolean reserved31
 443                      &quot;Reserved for future capability&quot;)
 444             (boolean reserved32
 445                      &quot;Reserved for future capability&quot;)
 446         )
 447         (ErrorSet
 448             (Error VM_DEAD)
 449         )
 450     )
 451     (Command RedefineClasses=18
 452         &quot;Installs new class definitions. &quot;
 453         &quot;If there are active stack frames in methods of the redefined classes in the &quot;
 454         &quot;target VM then those active frames continue to run the bytecodes of the &quot;
 455         &quot;original method. These methods are considered obsolete - see &quot;
 456         &quot;&lt;a href=\&quot;#JDWP_Method_IsObsolete\&quot;&gt;IsObsolete&lt;/a&gt;. The methods in the &quot;
 457         &quot;redefined classes will be used for new invokes in the target VM. &quot;
 458         &quot;The original method ID refers to the redefined method. &quot;
 459         &quot;All breakpoints in the redefined classes are cleared.&quot;
 460         &quot;If resetting of stack frames is desired, the &quot;
 461         &quot;&lt;a href=\&quot;#JDWP_StackFrame_PopFrames\&quot;&gt;PopFrames&lt;/a&gt; command can be used &quot;
 462         &quot;to pop frames with obsolete methods.&quot;
 463         &quot;&lt;p&gt;&quot;
 464         &quot;Unless the canUnrestrictedlyRedefineClasses capability is present &quot;
 465         &quot;the redefinition must follow the restrictions described in &quot;
 466         &quot;&lt;a href=\&quot;../jvmti.html#RedefineClasses\&quot;&gt;JVM TI RedefineClasses&lt;/a&gt;.&quot;
 467         &quot;&lt;p&gt;&quot;
 468         &quot;Requires canRedefineClasses capability - see &quot;
 469         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
 470         &quot;In addition to the canRedefineClasses capability, the target VM must &quot;
 471         &quot;have the canAddMethod capability to add methods when redefining classes, &quot;
 472         &quot;or the canUnrestrictedlyRedefineClasses capability to redefine classes in ways &quot;
 473         &quot;that are normally restricted.&quot;
 474         (Out
 475             (Repeat classes &quot;Number of reference types that follow.&quot;
 476                 (Group ClassDef
 477                     (referenceType refType &quot;The reference type.&quot;)
 478                     (Repeat classfile &quot;Number of bytes defining class (below)&quot;
 479                          (byte classbyte &quot;byte in JVM class file &quot;
 480                                          &quot;format.&quot;)
 481                     )
 482                 )
 483             )
 484         )
 485         (Reply
 486         )
 487         (ErrorSet
 488             (Error INVALID_CLASS    &quot;One of the refTypes is not the ID of a reference &quot;
 489                                     &quot;type.&quot;)
 490             (Error INVALID_OBJECT   &quot;One of the refTypes is not a known ID.&quot;)
 491             (Error UNSUPPORTED_VERSION)
 492             (Error INVALID_CLASS_FORMAT)
 493             (Error CIRCULAR_CLASS_DEFINITION)
 494             (Error FAILS_VERIFICATION)
 495             (Error NAMES_DONT_MATCH)
 496             (Error NOT_IMPLEMENTED  &quot;No aspect of this functionality is implemented &quot;
 497                                     &quot;(CapabilitiesNew.canRedefineClasses is false)&quot;)
 498             (Error ADD_METHOD_NOT_IMPLEMENTED)
 499             (Error SCHEMA_CHANGE_NOT_IMPLEMENTED)
 500             (Error HIERARCHY_CHANGE_NOT_IMPLEMENTED)
 501             (Error DELETE_METHOD_NOT_IMPLEMENTED)
 502             (Error CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 503             (Error METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED)
 504             (Error CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED)
 505             (Error VM_DEAD)
 506         )
 507     )
 508     (Command SetDefaultStratum=19
 509         &quot;Set the default stratum. Requires canSetDefaultStratum capability - see &quot;
 510         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 511         (Out
 512             (string stratumID &quot;default stratum, or empty string to use &quot;
 513                               &quot;reference type default.&quot;)
 514         )
 515         (Reply
 516         )
 517         (ErrorSet
 518             (Error NOT_IMPLEMENTED)
 519             (Error VM_DEAD)
 520         )
 521     )
 522     (Command AllClassesWithGeneric=20
 523         &quot;Returns reference types for all classes currently loaded by the &quot;
 524         &quot;target VM.  &quot;
 525         &quot;Both the JNI signature and the generic signature are &quot;
 526         &quot;returned for each class.  &quot;
 527         &quot;Generic signatures are described in the signature attribute &quot;
 528         &quot;section in &quot;
 529         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 530         &quot;Since JDWP version 1.5.&quot;
 531         (Out
 532         )
 533         (Reply
 534             (Repeat classes &quot;Number of reference types that follow.&quot;
 535                 (Group ClassInfo
 536                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 537                                       &quot;of following reference type. &quot;)
 538                     (referenceTypeID typeID &quot;Loaded reference type&quot;)
 539                     (string signature
 540                                 &quot;The JNI signature of the loaded reference type.&quot;)
 541                     (string genericSignature
 542                                 &quot;The generic signature of the loaded reference type &quot;
 543                                 &quot;or an empty string if there is none.&quot;)
 544                     (int status &quot;The current class &quot;
 545                                 &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;status.&lt;/a&gt; &quot;)
 546                 )
 547             )
 548         )
 549         (ErrorSet
 550             (Error VM_DEAD)
 551         )
 552     )
 553 
 554     (Command InstanceCounts=21
 555         &quot;Returns the number of instances of each reference type in the input list. &quot;
 556         &quot;Only instances that are reachable for the purposes of &quot;
 557         &quot;garbage collection are counted.  If a reference type is invalid, &quot;
 558         &quot;eg. it has been unloaded, zero is returned for its instance count.&quot;
 559         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 560         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 561         (Out
 562             (Repeat refTypesCount &quot;Number of reference types that follow.    Must be non-negative.&quot;
 563                 (referenceType refType &quot;A reference type ID.&quot;)
 564             )
 565           )
 566         (Reply
 567             (Repeat counts &quot;The number of counts that follow.&quot;
 568               (long instanceCount &quot;The number of instances for the corresponding reference type &quot;
 569                                   &quot;in &#39;Out Data&#39;.&quot;)
 570             )
 571         )
 572         (ErrorSet
 573             (Error ILLEGAL_ARGUMENT   &quot;refTypesCount is less than zero.&quot;)
 574             (Error NOT_IMPLEMENTED)
 575             (Error VM_DEAD)
 576         )
 577     )
 578     (Command AllModules=22
 579         &quot;Returns all modules in the target VM.&quot;
 580         &quot;&lt;p&gt;Since JDWP version 9.&quot;
 581         (Out
 582         )
 583         (Reply
 584             (Repeat modules &quot;The number of the modules that follow.&quot;
 585                 (moduleID module &quot;One of the modules.&quot;)
 586             )
 587         )
 588         (ErrorSet
 589             (Error NOT_IMPLEMENTED)
 590             (Error VM_DEAD)
 591         )
 592     )
 593 )
 594 
 595 (CommandSet ReferenceType=2
 596     (Command Signature=1
 597         &quot;Returns the type signature of a reference type. &quot;
 598         &quot;Type signature formats are the same as specified in &quot;
 599         &quot;&lt;a href=\&quot;../jvmti.html#GetClassSignature\&quot;&gt;JVM TI GetClassSignature&lt;/a&gt;.&quot;
 600         (Out
 601             (referenceType refType &quot;The reference type ID.&quot;)
 602         )
 603         (Reply
 604             (string signature
 605                 &quot;The JNI signature for the reference type.&quot;)
 606         )
 607         (ErrorSet
 608             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 609                                      &quot;type.&quot;)
 610             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 611             (Error VM_DEAD)
 612         )
 613     )
 614     (Command ClassLoader=2
 615         &quot;Returns the instance of java.lang.ClassLoader which loaded &quot;
 616         &quot;a given reference type. If the reference type was loaded by the &quot;
 617         &quot;system class loader, the returned object ID is null.&quot;
 618         (Out
 619             (referenceType refType &quot;The reference type ID.&quot;)
 620         )
 621         (Reply
 622             (classLoaderObject classLoader &quot;The class loader for the reference type. &quot;)
 623         )
 624         (ErrorSet
 625             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 626                                      &quot;type.&quot;)
 627             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 628             (Error VM_DEAD)
 629         )
 630     )
 631     (Command Modifiers=3
 632         &quot;Returns the modifiers (also known as access flags) for a reference type. &quot;
 633         &quot;The returned bit mask contains information on the declaration &quot;
 634         &quot;of the reference type. If the reference type is an array or &quot;
 635         &quot;a primitive class (for example, java.lang.Integer.TYPE), the &quot;
 636         &quot;value of the returned bit mask is undefined.&quot;
 637         (Out
 638             (referenceType refType &quot;The reference type ID.&quot;)
 639         )
 640         (Reply
 641             (int modBits &quot;Modifier bits as defined in Chapter 4 of &quot;
 642                          &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;&quot;)
 643         )
 644         (ErrorSet
 645             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 646                                      &quot;type.&quot;)
 647             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 648             (Error VM_DEAD)
 649         )
 650     )
 651     (Command Fields=4
 652         &quot;Returns information for each field in a reference type. &quot;
 653         &quot;Inherited fields are not included. &quot;
 654         &quot;The field list will include any synthetic fields created &quot;
 655         &quot;by the compiler. &quot;
 656         &quot;Fields are returned in the order they occur in the class file.&quot;
 657         (Out
 658             (referenceType refType &quot;The reference type ID.&quot;)
 659         )
 660         (Reply
 661             (Repeat declared &quot;Number of declared fields.&quot;
 662                 (Group FieldInfo
 663                     (field fieldID &quot;Field ID.&quot;)
 664                     (string name &quot;Name of field.&quot;)
 665                     (string signature &quot;JNI Signature of field.&quot;)
 666                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 667                                  &quot;which provide additional information on the  &quot;
 668                                  &quot;field declaration. Individual flag values are &quot;
 669                                  &quot;defined in Chapter 4 of &quot;
 670                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 671                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 672                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 673                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 674                 )
 675             )
 676         )
 677         (ErrorSet
 678             (Error CLASS_NOT_PREPARED)
 679             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 680                                      &quot;type.&quot;)
 681             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 682             (Error VM_DEAD)
 683         )
 684     )
 685     (Command Methods=5
 686         &quot;Returns information for each method in a reference type. &quot;
 687         &quot;Inherited methods are not included. The list of methods will &quot;
 688         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 689         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 690         &quot;if present, and any synthetic methods created by the compiler. &quot;
 691         &quot;Methods are returned in the order they occur in the class file.&quot;
 692         (Out
 693             (referenceType refType &quot;The reference type ID.&quot;)
 694         )
 695         (Reply
 696             (Repeat declared &quot;Number of declared methods.&quot;
 697                 (Group MethodInfo
 698                     (method methodID &quot;Method ID.&quot;)
 699                     (string name &quot;Name of method.&quot;)
 700                     (string signature &quot;JNI signature of method.&quot;)
 701                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 702                                  &quot;which provide additional information on the  &quot;
 703                                  &quot;method declaration. Individual flag values are &quot;
 704                                  &quot;defined in Chapter 4 of &quot;
 705                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 706                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 707                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 708                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 709                 )
 710             )
 711         )
 712         (ErrorSet
 713             (Error CLASS_NOT_PREPARED)
 714             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 715                                      &quot;type.&quot;)
 716             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 717             (Error VM_DEAD)
 718         )
 719     )
 720     (Command GetValues=6
 721         &quot;Returns the value of one or more static fields of the &quot;
 722         &quot;reference type. Each field must be member of the reference type &quot;
 723         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
 724         &quot;Access control is not enforced; for example, the values of private &quot;
 725         &quot;fields can be obtained.&quot;
 726         (Out
 727             (referenceType refType &quot;The reference type ID.&quot;)
 728             (Repeat fields &quot;The number of values to get&quot;
 729                 (Group Field
 730                     (field fieldID &quot;A field to get&quot;)
 731                 )
 732             )
 733         )
 734         (Reply
 735             (Repeat values &quot;The number of values returned, always equal to fields, &quot;
 736                            &quot;the number of values to get.&quot;
 737                 (value value &quot;The field value&quot;)
 738             )
 739         )
 740         (ErrorSet
 741             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 742                                      &quot;type.&quot;)
 743             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 744             (Error INVALID_FIELDID)
 745             (Error VM_DEAD)
 746         )
 747     )
 748     (Command SourceFile=7
 749         &quot;Returns the name of source file in which a reference type was &quot;
 750         &quot;declared. &quot;
 751         (Out
 752             (referenceType refType &quot;The reference type ID.&quot;)
 753         )
 754         (Reply
 755             (string sourceFile &quot;The source file name. No path information &quot;
 756                                &quot;for the file is included&quot;)
 757         )
 758         (ErrorSet
 759             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 760                                      &quot;type.&quot;)
 761             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 762             (Error ABSENT_INFORMATION &quot;The source file attribute is absent.&quot;)
 763             (Error VM_DEAD)
 764         )
 765     )
 766     (Command NestedTypes=8
 767         &quot;Returns the classes and interfaces directly nested within this type.&quot;
 768         &quot;Types further nested within those types are not included. &quot;
 769         (Out
 770             (referenceType refType &quot;The reference type ID.&quot;)
 771         )
 772         (Reply
 773             (Repeat classes &quot;The number of nested classes and interfaces&quot;
 774                 (Group TypeInfo
 775                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
 776                                       &quot;of following reference type. &quot;)
 777                     (referenceTypeID typeID &quot;The nested class or interface ID.&quot;)
 778                 )
 779             )
 780         )
 781         (ErrorSet
 782             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 783                                      &quot;type.&quot;)
 784             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 785             (Error VM_DEAD)
 786         )
 787     )
 788     (Command Status=9
 789         &quot;Returns the current status of the reference type. The status &quot;
 790         &quot;indicates the extent to which the reference type has been &quot;
 791         &quot;initialized, as described in section 2.1.6 of &quot;
 792         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 793         &quot;If the class is linked the PREPARED and VERIFIED bits in the returned status bits &quot;
 794         &quot;will be set. If the class is initialized the INITIALIZED bit in the returned &quot;
 795         &quot;status bits will be set. If an error occured during initialization then the &quot;
 796         &quot;ERROR bit in the returned status bits will be set. &quot;
 797         &quot;The returned status bits are undefined for array types and for &quot;
 798         &quot;primitive classes (such as java.lang.Integer.TYPE). &quot;
 799         (Out
 800             (referenceType refType &quot;The reference type ID.&quot;)
 801         )
 802         (Reply
 803             (int status &quot;&lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;Status&lt;/a&gt; bits:&quot;
 804                         &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
 805         )
 806         (ErrorSet
 807             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 808                                      &quot;type.&quot;)
 809             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 810             (Error VM_DEAD)
 811         )
 812     )
 813     (Command Interfaces=10
 814         &quot;Returns the interfaces declared as implemented by this class. &quot;
 815         &quot;Interfaces indirectly implemented (extended by the implemented &quot;
 816         &quot;interface or implemented by a superclass) are not included.&quot;
 817         (Out
 818             (referenceType refType &quot;The reference type ID.&quot;)
 819         )
 820         (Reply
 821             (Repeat interfaces &quot;The number of implemented interfaces&quot;
 822                 (interfaceType interfaceType &quot;implemented interface.&quot;)
 823             )
 824         )
 825         (ErrorSet
 826             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 827                                      &quot;type.&quot;)
 828             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 829             (Error VM_DEAD)
 830         )
 831     )
 832     (Command ClassObject=11
 833         &quot;Returns the class object corresponding to this type. &quot;
 834         (Out
 835             (referenceType refType &quot;The reference type ID.&quot;)
 836         )
 837         (Reply
 838             (classObject classObject &quot;class object.&quot;)
 839         )
 840         (ErrorSet
 841             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 842                                      &quot;type.&quot;)
 843             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 844             (Error VM_DEAD)
 845         )
 846     )
 847     (Command SourceDebugExtension=12
 848         &quot;Returns the value of the SourceDebugExtension attribute. &quot;
 849         &quot;Since JDWP version 1.4. Requires canGetSourceDebugExtension capability - see &quot;
 850         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 851         (Out
 852             (referenceType refType &quot;The reference type ID.&quot;)
 853         )
 854         (Reply
 855             (string extension &quot;extension attribute&quot;)
 856         )
 857         (ErrorSet
 858             (Error INVALID_CLASS      &quot;refType is not the ID of a reference &quot;
 859                                       &quot;type.&quot;)
 860             (Error INVALID_OBJECT     &quot;refType is not a known ID.&quot;)
 861             (Error ABSENT_INFORMATION &quot;If the extension is not specified.&quot;)
 862             (Error NOT_IMPLEMENTED)
 863             (Error VM_DEAD)
 864         )
 865     )
 866     (Command SignatureWithGeneric=13
 867         &quot;Returns the JNI signature of a reference type along with the &quot;
 868         &quot;generic signature if there is one.  &quot;
 869         &quot;Generic signatures are described in the signature attribute &quot;
 870         &quot;section in &quot;
 871         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 872         &quot;Since JDWP version 1.5.&quot;
 873         (Out
 874             (referenceType refType &quot;The reference type ID.&quot;)
 875         )
 876         (Reply
 877             (string signature
 878                 &quot;The JNI signature for the reference type.&quot;)
 879             (string genericSignature
 880                 &quot;The generic signature for the reference type or an empty &quot;
 881                 &quot;string if there is none.&quot;)
 882         )
 883         (ErrorSet
 884             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 885                                      &quot;type.&quot;)
 886             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 887             (Error VM_DEAD)
 888         )
 889     )
 890     (Command FieldsWithGeneric=14
 891         &quot;Returns information, including the generic signature if any, &quot;
 892         &quot;for each field in a reference type. &quot;
 893         &quot;Inherited fields are not included. &quot;
 894         &quot;The field list will include any synthetic fields created &quot;
 895         &quot;by the compiler. &quot;
 896         &quot;Fields are returned in the order they occur in the class file.  &quot;
 897         &quot;Generic signatures are described in the signature attribute &quot;
 898         &quot;section in &quot;
 899         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 900         &quot;Since JDWP version 1.5.&quot;
 901         (Out
 902             (referenceType refType &quot;The reference type ID.&quot;)
 903         )
 904         (Reply
 905             (Repeat declared &quot;Number of declared fields.&quot;
 906                 (Group FieldInfo
 907                     (field fieldID &quot;Field ID.&quot;)
 908                     (string name &quot;The name of the field.&quot;)
 909                     (string signature &quot;The JNI signature of the field.&quot;)
 910                     (string genericSignature &quot;The generic signature of the &quot;
 911                                              &quot;field, or an empty string if there is none.&quot;)
 912                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 913                                  &quot;which provide additional information on the  &quot;
 914                                  &quot;field declaration. Individual flag values are &quot;
 915                                  &quot;defined in Chapter 4 of &quot;
 916                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 917                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 918                                  &quot;the field as synthetic, if the synthetic attribute &quot;
 919                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 920                 )
 921             )
 922         )
 923         (ErrorSet
 924             (Error CLASS_NOT_PREPARED)
 925             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 926                                      &quot;type.&quot;)
 927             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 928             (Error VM_DEAD)
 929         )
 930     )
 931     (Command MethodsWithGeneric=15
 932         &quot;Returns information, including the generic signature if any, &quot;
 933         &quot;for each method in a reference type. &quot;
 934         &quot;Inherited methodss are not included. The list of methods will &quot;
 935         &quot;include constructors (identified with the name \&quot;&amp;lt;init&amp;gt;\&quot;), &quot;
 936         &quot;the initialization method (identified with the name \&quot;&amp;lt;clinit&amp;gt;\&quot;) &quot;
 937         &quot;if present, and any synthetic methods created by the compiler. &quot;
 938         &quot;Methods are returned in the order they occur in the class file.  &quot;
 939         &quot;Generic signatures are described in the signature attribute &quot;
 940         &quot;section in &quot;
 941         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 942         &quot;Since JDWP version 1.5.&quot;
 943         (Out
 944             (referenceType refType &quot;The reference type ID.&quot;)
 945         )
 946         (Reply
 947             (Repeat declared &quot;Number of declared methods.&quot;
 948                 (Group MethodInfo
 949                     (method methodID &quot;Method ID.&quot;)
 950                     (string name &quot;The name of the method.&quot;)
 951                     (string signature &quot;The JNI signature of the method.&quot;)
 952                     (string genericSignature &quot;The generic signature of the method, or &quot;
 953                                              &quot;an empty string if there is none.&quot;)
 954                     (int modBits &quot;The modifier bit flags (also known as access flags) &quot;
 955                                  &quot;which provide additional information on the  &quot;
 956                                  &quot;method declaration. Individual flag values are &quot;
 957                                  &quot;defined in Chapter 4 of &quot;
 958                                  &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
 959                                  &quot;In addition, The &lt;code&gt;0xf0000000&lt;/code&gt; bit identifies &quot;
 960                                  &quot;the method as synthetic, if the synthetic attribute &quot;
 961                                  &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Capabilities\&quot;&gt;capability&lt;/a&gt; is available.&quot;)
 962                 )
 963             )
 964         )
 965         (ErrorSet
 966             (Error CLASS_NOT_PREPARED)
 967             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 968                                      &quot;type.&quot;)
 969             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 970             (Error VM_DEAD)
 971         )
 972     )
 973     (Command Instances=16
 974         &quot;Returns instances of this reference type. &quot;
 975         &quot;Only instances that are reachable for the purposes of &quot;
 976         &quot;garbage collection are returned. &quot;
 977         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
 978         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
 979         (Out
 980             (referenceType refType &quot;The reference type ID.&quot;)
 981             (int maxInstances &quot;Maximum number of instances to return.  Must be non-negative. &quot;
 982                               &quot;If zero, all instances are returned.&quot;)
 983         )
 984         (Reply
 985             (Repeat instances &quot;The number of instances that follow.&quot;
 986                  (tagged-object instance &quot;An instance of this reference type.&quot;)
 987              )
 988         )
 989         (ErrorSet
 990             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
 991                                      &quot;type.&quot;)
 992             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
 993             (Error ILLEGAL_ARGUMENT  &quot;maxInstances is less than zero.&quot;)
 994             (Error NOT_IMPLEMENTED)
 995             (Error VM_DEAD)
 996         )
 997     )
 998     (Command ClassFileVersion=17
 999         &quot;Returns the class file major and minor version numbers, as defined in the class &quot;
1000         &quot;file format of the Java Virtual Machine specification. &quot;
1001          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
1002         (Out
1003             (referenceType refType &quot;The class.&quot;)
1004         )
1005         (Reply
1006             (int majorVersion &quot;Major version number&quot;)
1007             (int minorVersion &quot;Minor version number&quot;)
1008         )
1009         (ErrorSet
1010             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1011                                      &quot;type.&quot;)
1012             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1013             (Error ABSENT_INFORMATION &quot;The class file version information is &quot;
1014                                       &quot;absent for primitive and array types.&quot;)
1015             (Error VM_DEAD)
1016         )
1017     )
1018     (Command ConstantPool=18
1019         &quot;Return the raw bytes of the constant pool in the format of the &quot;
1020         &quot;constant_pool item of the Class File Format in &quot;
1021         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1022         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetConstantPool capability - see &quot;
1023         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;&quot;
1024         (Out
1025             (referenceType refType &quot;The class.&quot;)
1026         )
1027         (Reply
1028             (int count &quot;Total number of constant pool entries plus one. This &quot;
1029                        &quot;corresponds to the constant_pool_count item of the &quot;
1030                        &quot;Class File Format in &quot;
1031                        &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;)
1032             (Repeat bytes
1033                 (byte cpbytes &quot;Raw bytes of constant pool&quot;)
1034             )
1035         )
1036         (ErrorSet
1037             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1038                                      &quot;type.&quot;)
1039             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1040             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1041                                      &quot;support the retrieval of constant pool information.&quot;)
1042             (Error ABSENT_INFORMATION &quot;The Constant Pool information is &quot;
1043                                       &quot;absent for primitive and array types.&quot;)
1044             (Error VM_DEAD)
1045         )
1046     )
1047     (Command Module=19
1048         &quot;Returns the module that this reference type belongs to.&quot;
1049         &quot;&lt;p&gt;Since JDWP version 9.&quot;
1050         (Out
1051             (referenceType refType &quot;The reference type.&quot;)
1052         )
1053         (Reply
1054             (moduleID module &quot;The module this reference type belongs to.&quot;)
1055         )
1056         (ErrorSet
1057             (Error INVALID_CLASS   &quot;refType is not the ID of a reference type.&quot;)
1058             (Error INVALID_OBJECT  &quot;refType is not a known ID.&quot;)
1059             (Error NOT_IMPLEMENTED)
1060             (Error VM_DEAD)
1061         )
1062     )
1063 )
1064 (CommandSet ClassType=3
1065     (Command Superclass=1
1066         &quot;Returns the immediate superclass of a class.&quot;
1067         (Out
1068             (classType clazz &quot;The class type ID.&quot;)
1069         )
1070         (Reply
1071             (classType superclass
1072                 &quot;The superclass (null if the class ID for java.lang.Object is specified).&quot;)
1073         )
1074         (ErrorSet
1075             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1076             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1077             (Error VM_DEAD)
1078         )
1079     )
1080     (Command SetValues=2
1081         &quot;Sets the value of one or more static fields. &quot;
1082         &quot;Each field must be member of the class type &quot;
1083         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1084         &quot;Access control is not enforced; for example, the values of private &quot;
1085         &quot;fields can be set. Final fields cannot be set.&quot;
1086         &quot;For primitive values, the value&#39;s type must match the &quot;
1087         &quot;field&#39;s type exactly. For object values, there must exist a &quot;
1088         &quot;widening reference conversion from the value&#39;s type to the
1089         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1090         (Out
1091             (classType clazz &quot;The class type ID.&quot;)
1092             (Repeat values &quot;The number of fields to set.&quot;
1093                 (Group FieldValue &quot;A Field/Value pair.&quot;
1094                     (field fieldID &quot;Field to set.&quot;)
1095                     (untagged-value value &quot;Value to put in the field.&quot;)
1096                 )
1097             )
1098         )
1099         (Reply &quot;none&quot;
1100         )
1101         (ErrorSet
1102             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1103             (Error CLASS_NOT_PREPARED)
1104             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1105                                      &quot;object field is not a known ID.&quot;)
1106             (Error INVALID_FIELDID)
1107             (Error VM_DEAD)
1108         )
1109     )
1110     (Command InvokeMethod=3
1111         &quot;Invokes a static method. &quot;
1112         &quot;The method must be member of the class type &quot;
1113         &quot;or one of its superclasses. &quot;
1114         &quot;Access control is not enforced; for example, private &quot;
1115         &quot;methods can be invoked.&quot;
1116         &quot;&lt;p&gt;&quot;
1117         &quot;The method invocation will occur in the specified thread. &quot;
1118         &quot;Method invocation can occur only if the specified thread &quot;
1119         &quot;has been suspended by an event. &quot;
1120         &quot;Method invocation is not supported &quot;
1121         &quot;when the target VM has been suspended by the front-end. &quot;
1122         &quot;&lt;p&gt;&quot;
1123         &quot;The specified method is invoked with the arguments in the specified &quot;
1124         &quot;argument list. &quot;
1125         &quot;The method invocation is synchronous; the reply packet is not &quot;
1126         &quot;sent until the invoked method returns in the target VM. &quot;
1127         &quot;The return value (possibly the void value) is &quot;
1128         &quot;included in the reply packet. &quot;
1129         &quot;If the invoked method throws an exception, the &quot;
1130         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1131         &quot;exception object ID is null. &quot;
1132         &quot;&lt;p&gt;&quot;
1133         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1134         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1135         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1136         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1137         &quot;&lt;p&gt;&quot;
1138         &quot;By default, all threads in the target VM are resumed while &quot;
1139         &quot;the method is being invoked if they were previously &quot;
1140         &quot;suspended by an event or by command. &quot;
1141         &quot;This is done to prevent the deadlocks &quot;
1142         &quot;that will occur if any of the threads own monitors &quot;
1143         &quot;that will be needed by the invoked method. It is possible that &quot;
1144         &quot;breakpoints or other events might occur during the invocation. &quot;
1145         &quot;Note, however, that this implicit resume acts exactly like &quot;
1146         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1147         &quot;count is greater than 1, it will remain in a suspended state &quot;
1148         &quot;during the invocation. By default, when the invocation completes, &quot;
1149         &quot;all threads in the target VM are suspended, regardless their state &quot;
1150         &quot;before the invocation. &quot;
1151         &quot;&lt;p&gt;&quot;
1152         &quot;The resumption of other threads during the invoke can be prevented &quot;
1153         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1154         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1155         &quot;there is no protection against or recovery from the deadlocks &quot;
1156         &quot;described above, so this option should be used with great caution. &quot;
1157         &quot;Only the specified thread will be resumed (as described for all &quot;
1158         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1159         &quot;will be suspended once again. Note that any threads started during &quot;
1160         &quot;the single threaded invocation will not be suspended when the &quot;
1161         &quot;invocation completes. &quot;
1162         &quot;&lt;p&gt;&quot;
1163         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1164         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1165         (Out
1166             (classType clazz &quot;The class type ID.&quot;)
1167             (threadObject thread &quot;The thread in which to invoke.&quot;)
1168             (method methodID &quot;The method to invoke.&quot;)
1169             (Repeat arguments
1170                 (value arg &quot;The argument value.&quot;)
1171             )
1172             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1173         )
1174         (Reply
1175             (value returnValue &quot;The returned value.&quot;)
1176             (tagged-object exception &quot;The thrown exception.&quot;)
1177         )
1178         (ErrorSet
1179             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1180             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1181             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in &quot;
1182                                      &quot;this class type or one of its superclasses.&quot;)
1183             (Error INVALID_THREAD)
1184             (Error THREAD_NOT_SUSPENDED)
1185             (Error VM_DEAD)
1186         )
1187     )
1188     (Command NewInstance=4
1189         &quot;Creates a new object of this type, invoking the specified &quot;
1190         &quot;constructor. The constructor method ID must be a member of &quot;
1191         &quot;the class type.&quot;
1192         &quot;&lt;p&gt;&quot;
1193         &quot;Instance creation will occur in the specified thread. &quot;
1194         &quot;Instance creation can occur only if the specified thread &quot;
1195         &quot;has been suspended by an event. &quot;
1196         &quot;Method invocation is not supported &quot;
1197         &quot;when the target VM has been suspended by the front-end. &quot;
1198         &quot;&lt;p&gt;&quot;
1199         &quot;The specified constructor is invoked with the arguments in the specified &quot;
1200         &quot;argument list. &quot;
1201         &quot;The constructor invocation is synchronous; the reply packet is not &quot;
1202         &quot;sent until the invoked method returns in the target VM. &quot;
1203         &quot;The return value (possibly the void value) is &quot;
1204         &quot;included in the reply packet. &quot;
1205         &quot;If the constructor throws an exception, the &quot;
1206         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1207         &quot;exception object ID is null. &quot;
1208         &quot;&lt;p&gt;&quot;
1209         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1210         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1211         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1212         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1213         &quot;&lt;p&gt;&quot;
1214         &quot;By default, all threads in the target VM are resumed while &quot;
1215         &quot;the method is being invoked if they were previously &quot;
1216         &quot;suspended by an event or by command. &quot;
1217         &quot;This is done to prevent the deadlocks &quot;
1218         &quot;that will occur if any of the threads own monitors &quot;
1219         &quot;that will be needed by the invoked method. It is possible that &quot;
1220         &quot;breakpoints or other events might occur during the invocation. &quot;
1221         &quot;Note, however, that this implicit resume acts exactly like &quot;
1222         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1223         &quot;count is greater than 1, it will remain in a suspended state &quot;
1224         &quot;during the invocation. By default, when the invocation completes, &quot;
1225         &quot;all threads in the target VM are suspended, regardless their state &quot;
1226         &quot;before the invocation. &quot;
1227         &quot;&lt;p&gt;&quot;
1228         &quot;The resumption of other threads during the invoke can be prevented &quot;
1229         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1230         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1231         &quot;there is no protection against or recovery from the deadlocks &quot;
1232         &quot;described above, so this option should be used with great caution. &quot;
1233         &quot;Only the specified thread will be resumed (as described for all &quot;
1234         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1235         &quot;will be suspended once again. Note that any threads started during &quot;
1236         &quot;the single threaded invocation will not be suspended when the &quot;
1237         &quot;invocation completes. &quot;
1238         &quot;&lt;p&gt;&quot;
1239         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1240         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1241         (Out
1242             (classType clazz &quot;The class type ID.&quot;)
1243             (threadObject thread &quot;The thread in which to invoke the constructor.&quot;)
1244             (method methodID &quot;The constructor to invoke.&quot;)
1245             (Repeat arguments
1246                 (value arg &quot;The argument value.&quot;)
1247             )
1248             (int options &quot;Constructor invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1249         )
1250         (Reply
1251             (tagged-object newObject &quot;The newly created object, or null &quot;
1252                                      &quot;if the constructor threw an exception.&quot;)
1253             (tagged-object exception &quot;The thrown exception, if any; otherwise, null.&quot;)
1254         )
1255         (ErrorSet
1256             (Error INVALID_CLASS     &quot;clazz is not the ID of a class.&quot;)
1257             (Error INVALID_OBJECT    &quot;clazz is not a known ID or a value of an &quot;
1258                                      &quot;object parameter is not a known ID..&quot;)
1259             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1260             (Error INVALID_OBJECT)
1261             (Error INVALID_THREAD)
1262             (Error THREAD_NOT_SUSPENDED)
1263             (Error VM_DEAD)
1264         )
1265     )
1266 )
1267 (CommandSet ArrayType=4
1268     (Command NewInstance=1
1269         &quot;Creates a new array object of this type with a given length.&quot;
1270         (Out
1271             (arrayType arrType &quot;The array type of the new instance.&quot;)
1272             (int length &quot;The length of the array.&quot;)
1273         )
1274         (Reply
1275             (tagged-object newArray &quot;The newly created array object. &quot;)
1276         )
1277         (ErrorSet
1278             (Error INVALID_ARRAY)
1279             (Error INVALID_OBJECT)
1280             (Error VM_DEAD)
1281         )
1282     )
1283 )
1284 (CommandSet InterfaceType=5
1285     (Command InvokeMethod=1
1286         &quot;Invokes a static method. &quot;
1287         &quot;The method must not be a static initializer. &quot;
1288         &quot;The method must be a member of the interface type. &quot;
1289         &quot;&lt;p&gt;Since JDWP version 1.8 &quot;
1290         &quot;&lt;p&gt;&quot;
1291         &quot;The method invocation will occur in the specified thread. &quot;
1292         &quot;Method invocation can occur only if the specified thread &quot;
1293         &quot;has been suspended by an event. &quot;
1294         &quot;Method invocation is not supported &quot;
1295         &quot;when the target VM has been suspended by the front-end. &quot;
1296         &quot;&lt;p&gt;&quot;
1297         &quot;The specified method is invoked with the arguments in the specified &quot;
1298         &quot;argument list. &quot;
1299         &quot;The method invocation is synchronous; the reply packet is not &quot;
1300         &quot;sent until the invoked method returns in the target VM. &quot;
1301         &quot;The return value (possibly the void value) is &quot;
1302         &quot;included in the reply packet. &quot;
1303         &quot;If the invoked method throws an exception, the &quot;
1304         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1305         &quot;exception object ID is null. &quot;
1306         &quot;&lt;p&gt;&quot;
1307         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1308         &quot;argument&#39;s type exactly. For object arguments, there must exist a &quot;
1309         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1310         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1311         &quot;&lt;p&gt;&quot;
1312         &quot;By default, all threads in the target VM are resumed while &quot;
1313         &quot;the method is being invoked if they were previously &quot;
1314         &quot;suspended by an event or by a command. &quot;
1315         &quot;This is done to prevent the deadlocks &quot;
1316         &quot;that will occur if any of the threads own monitors &quot;
1317         &quot;that will be needed by the invoked method. It is possible that &quot;
1318         &quot;breakpoints or other events might occur during the invocation. &quot;
1319         &quot;Note, however, that this implicit resume acts exactly like &quot;
1320         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1321         &quot;count is greater than 1, it will remain in a suspended state &quot;
1322         &quot;during the invocation. By default, when the invocation completes, &quot;
1323         &quot;all threads in the target VM are suspended, regardless their state &quot;
1324         &quot;before the invocation. &quot;
1325         &quot;&lt;p&gt;&quot;
1326         &quot;The resumption of other threads during the invoke can be prevented &quot;
1327         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1328         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1329         &quot;there is no protection against or recovery from the deadlocks &quot;
1330         &quot;described above, so this option should be used with great caution. &quot;
1331         &quot;Only the specified thread will be resumed (as described for all &quot;
1332         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1333         &quot;will be suspended once again. Note that any threads started during &quot;
1334         &quot;the single threaded invocation will not be suspended when the &quot;
1335         &quot;invocation completes. &quot;
1336         &quot;&lt;p&gt;&quot;
1337         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1338         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1339         (Out
1340             (interfaceType clazz &quot;The interface type ID.&quot;)
1341             (threadObject thread &quot;The thread in which to invoke.&quot;)
1342             (method methodID &quot;The method to invoke.&quot;)
1343             (Repeat arguments
1344                 (value arg &quot;The argument value.&quot;)
1345             )
1346             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1347         )
1348         (Reply
1349             (value returnValue &quot;The returned value.&quot;)
1350             (tagged-object exception &quot;The thrown exception.&quot;)
1351         )
1352         (ErrorSet
1353             (Error INVALID_CLASS     &quot;clazz is not the ID of an interface.&quot;)
1354             (Error INVALID_OBJECT    &quot;clazz is not a known ID.&quot;)
1355             (Error INVALID_METHODID  &quot;methodID is not the ID of a static method in this &quot;
1356                                      &quot;interface type or is the ID of a static initializer.&quot;)
1357             (Error INVALID_THREAD)
1358             (Error THREAD_NOT_SUSPENDED)
1359             (Error VM_DEAD)
1360         )
1361     )
1362 )
1363 (CommandSet Method=6
1364     (Command LineTable=1
1365         &quot;Returns line number information for the method, if present. &quot;
1366         &quot;The line table maps source line numbers to the initial code index &quot;
1367         &quot;of the line. The line table &quot;
1368         &quot;is ordered by code index (from lowest to highest). The line number &quot;
1369         &quot;information is constant unless a new class definition is installed &quot;
1370         &quot;using &lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt;.&quot;
1371         (Out
1372             (referenceType refType &quot;The class.&quot;)
1373             (method methodID &quot;The method.&quot;)
1374         )
1375         (Reply
1376             (long start &quot;Lowest valid code index for the method, &gt;=0, or -1 if the method is native &quot;)
1377             (long end &quot;Highest valid code index for the method, &gt;=0, or -1 if the method is native&quot;)
1378             (Repeat lines &quot;The number of entries in the line table for this method.&quot;
1379                 (Group LineInfo
1380                     (long lineCodeIndex &quot;Initial code index of the line, &quot;
1381                                         &quot;start &amp;lt;= lineCodeIndex &amp;lt; end&quot;)
1382                     (int lineNumber &quot;Line number.&quot;)
1383                 )
1384             )
1385         )
1386         (ErrorSet
1387             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1388                                      &quot;type.&quot;)
1389             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1390             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1391             (Error VM_DEAD)
1392         )
1393     )
1394     (Command VariableTable=2
1395         &quot;Returns variable information for the method. The variable table &quot;
1396         &quot;includes arguments and locals declared within the method. For &quot;
1397         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1398         &quot;table. Also, synthetic variables may be present. &quot;
1399         (Out
1400             (referenceType refType &quot;The class.&quot;)
1401             (method methodID &quot;The method.&quot;)
1402         )
1403         (Reply
1404             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1405                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1406             (Repeat slots &quot;The number of variables.&quot;
1407                 (Group SlotInfo &quot;Information about the variable.&quot;
1408                     (long codeIndex
1409                         &quot;First code index at which the variable is visible (unsigned). &quot;
1410                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1411                         &quot;The variable can be get or set only when the current &quot;
1412                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1413                     (string name &quot;The variable&#39;s name.&quot;)
1414                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1415                     (int length
1416                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1417                         &quot;The variable can be get or set only when the current &quot;
1418                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1419                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1420                 )
1421             )
1422         )
1423         (ErrorSet
1424             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1425                                      &quot;type.&quot;)
1426             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1427             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1428             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1429             (Error VM_DEAD)
1430         )
1431     )
1432     (Command Bytecodes=3
1433         &quot;Retrieve the method&#39;s bytecodes as defined in &quot;
1434         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1435         &quot;Requires canGetBytecodes capability - see &quot;
1436         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1437         (Out
1438             (referenceType refType &quot;The class.&quot;)
1439             (method methodID &quot;The method.&quot;)
1440         )
1441         (Reply
1442             (Repeat bytes
1443                 (byte bytecode &quot;A Java bytecode.&quot;)
1444             )
1445         )
1446         (ErrorSet
1447             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1448                                      &quot;type.&quot;)
1449             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1450             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1451             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does not &quot;
1452                                      &quot;support the retrieval of bytecodes.&quot;)
1453             (Error VM_DEAD)
1454         )
1455     )
1456     (Command IsObsolete=4
1457         &quot;Determine if this method is obsolete. A method is obsolete if it has been replaced &quot;
1458         &quot;by a non-equivalent method using the &quot;
1459         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_RedefineClasses\&quot;&gt;RedefineClasses&lt;/a&gt; command. &quot;
1460         &quot;The original and redefined methods are considered equivalent if their bytecodes are &quot;
1461         &quot;the same except for indices into the constant pool and the referenced constants are &quot;
1462         &quot;equal.&quot;
1463         (Out
1464             (referenceType refType &quot;The class.&quot;)
1465             (method methodID &quot;The method.&quot;)
1466         )
1467         (Reply
1468             (boolean isObsolete    &quot;true if this method has been replaced&quot;
1469                                    &quot;by a non-equivalent method using&quot;
1470                                    &quot;the RedefineClasses command.&quot;)
1471         )
1472         (ErrorSet
1473             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1474                                      &quot;type.&quot;)
1475             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1476             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1477             (Error NOT_IMPLEMENTED   &quot;If the target virtual machine does &quot;
1478                                      &quot;not support this query.&quot;)
1479             (Error VM_DEAD)
1480         )
1481     )
1482     (Command VariableTableWithGeneric=5
1483         &quot;Returns variable information for the method, including &quot;
1484         &quot;generic signatures for the variables. The variable table &quot;
1485         &quot;includes arguments and locals declared within the method. For &quot;
1486         &quot;instance methods, the \&quot;this\&quot; reference is included in the &quot;
1487         &quot;table. Also, synthetic variables may be present. &quot;
1488         &quot;Generic signatures are described in the signature attribute &quot;
1489         &quot;section in &quot;
1490         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. &quot;
1491         &quot;Since JDWP version 1.5.&quot;
1492         (Out
1493             (referenceType refType &quot;The class.&quot;)
1494             (method methodID &quot;The method.&quot;)
1495         )
1496         (Reply
1497             (int argCnt &quot;The number of words in the frame used by arguments. &quot;
1498                         &quot;Eight-byte arguments use two words; all others use one. &quot;)
1499             (Repeat slots &quot;The number of variables.&quot;
1500                 (Group SlotInfo &quot;Information about the variable.&quot;
1501                     (long codeIndex
1502                         &quot;First code index at which the variable is visible (unsigned). &quot;
1503                         &quot;Used in conjunction with &lt;code&gt;length&lt;/code&gt;. &quot;
1504                         &quot;The variable can be get or set only when the current &quot;
1505                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;codeIndex + length&lt;/code&gt; &quot;)
1506                     (string name &quot;The variable&#39;s name.&quot;)
1507                     (string signature &quot;The variable type&#39;s JNI signature.&quot;)
1508                     (string genericSignature &quot;The variable type&#39;s generic &quot;
1509                          &quot;signature or an empty string if there is none.&quot;)
1510                     (int length
1511                         &quot;Unsigned value used in conjunction with &lt;code&gt;codeIndex&lt;/code&gt;. &quot;
1512                         &quot;The variable can be get or set only when the current &quot;
1513                         &quot;&lt;code&gt;codeIndex&lt;/code&gt; &amp;lt;= current frame code index &amp;lt; &lt;code&gt;code index + length&lt;/code&gt; &quot;)
1514                     (int slot &quot;The local variable&#39;s index in its frame&quot;)
1515                 )
1516             )
1517         )
1518         (ErrorSet
1519             (Error INVALID_CLASS     &quot;refType is not the ID of a reference &quot;
1520                                      &quot;type.&quot;)
1521             (Error INVALID_OBJECT    &quot;refType is not a known ID.&quot;)
1522             (Error INVALID_METHODID  &quot;methodID is not the ID of a method.&quot;)
1523             (Error ABSENT_INFORMATION &quot;there is no variable information for the method.&quot;)
1524             (Error VM_DEAD)
1525         )
1526     )
1527 
1528 )
1529 (CommandSet Field=8
1530 )
1531 (CommandSet ObjectReference=9
1532     (Command ReferenceType=1
1533         &quot;Returns the runtime type of the object. &quot;
1534         &quot;The runtime type will be a class or an array. &quot;
1535         (Out
1536             (object object &quot;The object ID&quot;)
1537         )
1538         (Reply
1539             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
1540                               &quot;of following reference type. &quot;)
1541             (referenceTypeID typeID &quot;The runtime reference type.&quot;)
1542         )
1543         (ErrorSet
1544             (Error INVALID_OBJECT)
1545             (Error VM_DEAD)
1546         )
1547     )
1548     (Command GetValues=2
1549         &quot;Returns the value of one or more instance fields. &quot;
1550         &quot;Each field must be member of the object&#39;s type &quot;
1551         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1552         &quot;Access control is not enforced; for example, the values of private &quot;
1553         &quot;fields can be obtained.&quot;
1554         (Out
1555             (object object &quot;The object ID&quot;)
1556             (Repeat fields &quot;The number of values to get&quot;
1557                 (Group Field
1558                     (field fieldID &quot;Field to get.&quot;)
1559                 )
1560             )
1561         )
1562         (Reply
1563             (Repeat values &quot;The number of values returned, always equal to &#39;fields&#39;, &quot;
1564                            &quot;the number of values to get. Field values are ordered &quot;
1565                            &quot;in the reply in the same order as corresponding fieldIDs &quot;
1566                            &quot;in the command.&quot;
1567                 (value value &quot;The field value&quot;)
1568             )
1569         )
1570         (ErrorSet
1571             (Error INVALID_OBJECT)
1572             (Error INVALID_FIELDID)
1573             (Error VM_DEAD)
1574         )
1575     )
1576     (Command SetValues=3
1577         &quot;Sets the value of one or more instance fields. &quot;
1578         &quot;Each field must be member of the object&#39;s type &quot;
1579         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1580         &quot;Access control is not enforced; for example, the values of private &quot;
1581         &quot;fields can be set. &quot;
1582         &quot;For primitive values, the value&#39;s type must match the &quot;
1583         &quot;field&#39;s type exactly. For object values, there must be a &quot;
1584         &quot;widening reference conversion from the value&#39;s type to the
1585         &quot;field&#39;s type and the field&#39;s type must be loaded. &quot;
1586         (Out
1587             (object object &quot;The object ID&quot;)
1588             (Repeat values &quot;The number of fields to set.&quot;
1589                 (Group FieldValue &quot;A Field/Value pair.&quot;
1590                     (field fieldID &quot;Field to set.&quot;)
1591                     (untagged-value value &quot;Value to put in the field.&quot;)
1592                 )
1593             )
1594         )
1595         (Reply &quot;none&quot;
1596         )
1597         (ErrorSet
1598             (Error INVALID_OBJECT)
1599             (Error INVALID_FIELDID)
1600             (Error VM_DEAD)
1601         )
1602     )
1603     (Command MonitorInfo=5
1604         &quot;Returns monitor information for an object. All threads int the VM must &quot;
1605         &quot;be suspended.&quot;
1606         &quot;Requires canGetMonitorInfo capability - see &quot;
1607         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1608         (Out
1609             (object object &quot;The object ID&quot;)
1610         )
1611         (Reply
1612             (threadObject owner &quot;The monitor owner, or null if it is not currently owned.&quot;)
1613             (int entryCount &quot;The number of times the monitor has been entered.&quot;)
1614             (Repeat waiters &quot;The number of threads that are waiting for the monitor &quot;
1615                             &quot;0 if there is no current owner&quot;
1616                 (threadObject thread &quot;A thread waiting for this monitor.&quot;)
1617             )
1618         )
1619         (ErrorSet
1620             (Error INVALID_OBJECT)
1621             (Error NOT_IMPLEMENTED)
1622             (Error VM_DEAD)
1623         )
1624     )
1625     (Command InvokeMethod=6
1626         &quot;Invokes a instance method. &quot;
1627         &quot;The method must be member of the object&#39;s type &quot;
1628         &quot;or one of its superclasses, superinterfaces, or implemented interfaces. &quot;
1629         &quot;Access control is not enforced; for example, private &quot;
1630         &quot;methods can be invoked.&quot;
1631         &quot;&lt;p&gt;&quot;
1632         &quot;The method invocation will occur in the specified thread. &quot;
1633         &quot;Method invocation can occur only if the specified thread &quot;
1634         &quot;has been suspended by an event. &quot;
1635         &quot;Method invocation is not supported &quot;
1636         &quot;when the target VM has been suspended by the front-end. &quot;
1637         &quot;&lt;p&gt;&quot;
1638         &quot;The specified method is invoked with the arguments in the specified &quot;
1639         &quot;argument list. &quot;
1640         &quot;The method invocation is synchronous; the reply packet is not &quot;
1641         &quot;sent until the invoked method returns in the target VM. &quot;
1642         &quot;The return value (possibly the void value) is &quot;
1643         &quot;included in the reply packet. &quot;
1644         &quot;If the invoked method throws an exception, the &quot;
1645         &quot;exception object ID is set in the reply packet; otherwise, the &quot;
1646         &quot;exception object ID is null. &quot;
1647         &quot;&lt;p&gt;&quot;
1648         &quot;For primitive arguments, the argument value&#39;s type must match the &quot;
1649         &quot;argument&#39;s type exactly. For object arguments, there must be a &quot;
1650         &quot;widening reference conversion from the argument value&#39;s type to the &quot;
1651         &quot;argument&#39;s type and the argument&#39;s type must be loaded. &quot;
1652         &quot;&lt;p&gt;&quot;
1653         &quot;By default, all threads in the target VM are resumed while &quot;
1654         &quot;the method is being invoked if they were previously &quot;
1655         &quot;suspended by an event or by a command. &quot;
1656         &quot;This is done to prevent the deadlocks &quot;
1657         &quot;that will occur if any of the threads own monitors &quot;
1658         &quot;that will be needed by the invoked method. It is possible that &quot;
1659         &quot;breakpoints or other events might occur during the invocation. &quot;
1660         &quot;Note, however, that this implicit resume acts exactly like &quot;
1661         &quot;the ThreadReference resume command, so if the thread&#39;s suspend &quot;
1662         &quot;count is greater than 1, it will remain in a suspended state &quot;
1663         &quot;during the invocation. By default, when the invocation completes, &quot;
1664         &quot;all threads in the target VM are suspended, regardless their state &quot;
1665         &quot;before the invocation. &quot;
1666         &quot;&lt;p&gt;&quot;
1667         &quot;The resumption of other threads during the invoke can be prevented &quot;
1668         &quot;by specifying the INVOKE_SINGLE_THREADED &quot;
1669         &quot;bit flag in the &lt;code&gt;options&lt;/code&gt; field; however, &quot;
1670         &quot;there is no protection against or recovery from the deadlocks &quot;
1671         &quot;described above, so this option should be used with great caution. &quot;
1672         &quot;Only the specified thread will be resumed (as described for all &quot;
1673         &quot;threads above). Upon completion of a single threaded invoke, the invoking thread &quot;
1674         &quot;will be suspended once again. Note that any threads started during &quot;
1675         &quot;the single threaded invocation will not be suspended when the &quot;
1676         &quot;invocation completes. &quot;
1677         &quot;&lt;p&gt;&quot;
1678         &quot;If the target VM is disconnected during the invoke (for example, through &quot;
1679         &quot;the VirtualMachine dispose command) the method invocation continues. &quot;
1680         (Out
1681             (object object &quot;The object ID&quot;)
1682             (threadObject thread &quot;The thread in which to invoke.&quot;)
1683             (classType clazz &quot;The class type.&quot;)
1684             (method methodID &quot;The method to invoke.&quot;)
1685             (Repeat arguments &quot;The number of arguments.&quot;
1686                 (value arg &quot;The argument value.&quot;)
1687             )
1688             (int options &quot;Invocation &lt;a href=\&quot;#JDWP_InvokeOptions\&quot;&gt;options&lt;/a&gt;&quot;)
1689         )
1690         (Reply
1691             (value returnValue &quot;The returned value, or null if an exception is thrown.&quot;)
1692             (tagged-object exception &quot;The thrown exception, if any.&quot;)
1693         )
1694         (ErrorSet
1695             (Error INVALID_OBJECT)
1696             (Error INVALID_CLASS     &quot;clazz is not the ID of a reference &quot;
1697                                      &quot;type.&quot;)
1698             (Error INVALID_METHODID  &quot;methodID is not the ID of an instance method &quot;
1699                                      &quot;in this object&#39;s type or one of its superclasses, &quot;
1700                                      &quot;superinterfaces, or implemented interfaces.&quot;)
1701             (Error INVALID_THREAD)
1702             (Error THREAD_NOT_SUSPENDED)
1703             (Error VM_DEAD)
1704         )
1705     )
1706     (Command DisableCollection=7
1707         &quot;Prevents garbage collection for the given object. By &quot;
1708         &quot;default all objects in back-end replies may be &quot;
1709         &quot;collected at any time the target VM is running. A call to &quot;
1710         &quot;this command guarantees that the object will not be &quot;
1711         &quot;collected. The &quot;
1712         &quot;&lt;a href=\&quot;#JDWP_ObjectReference_EnableCollection\&quot;&gt;EnableCollection&lt;/a&gt; &quot;
1713         &quot;command can be used to &quot;
1714         &quot;allow collection once again. &quot;
1715         &quot;&lt;p&gt;&quot;
1716         &quot;Note that while the target VM is suspended, no garbage &quot;
1717         &quot;collection will occur because all threads are suspended. &quot;
1718         &quot;The typical examination of variables, fields, and arrays &quot;
1719         &quot;during the suspension is safe without explicitly disabling &quot;
1720         &quot;garbage collection. &quot;
1721         &quot;&lt;p&gt;&quot;
1722         &quot;This method should be used sparingly, as it alters the &quot;
1723         &quot;pattern of garbage collection in the target VM and, &quot;
1724         &quot;consequently, may result in application behavior under the &quot;
1725         &quot;debugger that differs from its non-debugged behavior. &quot;
1726         (Out
1727             (object object &quot;The object ID&quot;)
1728         )
1729         (Reply &quot;none&quot;
1730         )
1731         (ErrorSet
1732             (Error INVALID_OBJECT)
1733             (Error VM_DEAD)
1734         )
1735     )
1736     (Command EnableCollection=8
1737         &quot;Permits garbage collection for this object. By default all &quot;
1738         &quot;objects returned by JDWP may become unreachable in the target VM, &quot;
1739         &quot;and hence may be garbage collected. A call to this command is &quot;
1740         &quot;necessary only if garbage collection was previously disabled with &quot;
1741         &quot;the &lt;a href=\&quot;#JDWP_ObjectReference_DisableCollection\&quot;&gt;DisableCollection&lt;/a&gt; &quot;
1742         &quot;command.&quot;
1743         (Out
1744             (object object &quot;The object ID&quot;)
1745         )
1746         (Reply &quot;none&quot;
1747         )
1748         (ErrorSet
1749             (Error VM_DEAD)
1750         )
1751     )
1752     (Command IsCollected=9
1753         &quot;Determines whether an object has been garbage collected in the &quot;
1754         &quot;target VM. &quot;
1755         (Out
1756             (object object &quot;The object ID&quot;)
1757         )
1758         (Reply
1759             (boolean isCollected &quot;true if the object has been collected; false otherwise&quot;)
1760         )
1761         (ErrorSet
1762             (Error INVALID_OBJECT)
1763             (Error VM_DEAD)
1764         )
1765     )
1766     (Command ReferringObjects=10
1767         &quot;Returns objects that directly reference this object.  &quot;
1768         &quot;Only objects that are reachable for the purposes &quot;
1769         &quot;of garbage collection are returned. &quot;
1770         &quot;Note that an object can also be referenced in other ways, &quot;
1771         &quot;such as from a local variable in a stack frame, or from a JNI global &quot;
1772         &quot;reference.  Such non-object referrers are not returned by this command. &quot;
1773         &quot;&lt;p&gt;Since JDWP version 1.6. Requires canGetInstanceInfo capability - see &quot;
1774         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1775         (Out
1776             (object object &quot;The object ID&quot;)
1777             (int maxReferrers &quot;Maximum number of referring objects to return. &quot;
1778                               &quot;Must be non-negative. If zero, all referring &quot;
1779                               &quot;objects are returned.&quot;)
1780         )
1781         (Reply
1782             (Repeat referringObjects &quot;The number of objects that follow.&quot;
1783                 (tagged-object instance &quot;An object that references this object.&quot;)
1784              )
1785         )
1786         (ErrorSet
1787             (Error INVALID_OBJECT    &quot;object is not a known ID.&quot;)
1788             (Error ILLEGAL_ARGUMENT  &quot;maxReferrers is less than zero.&quot;)
1789             (Error NOT_IMPLEMENTED)
1790             (Error VM_DEAD)
1791         )
1792     )
1793 )
1794 
1795 (CommandSet StringReference=10
1796     (Command Value=1
1797         &quot;Returns the characters contained in the string. &quot;
1798         (Out
1799             (object stringObject &quot;The String object ID. &quot;)
1800         )
1801         (Reply
1802             (string stringValue &quot;UTF-8 representation of the string value.&quot;)
1803        )
1804         (ErrorSet
1805             (Error INVALID_STRING)
1806             (Error INVALID_OBJECT)
1807             (Error VM_DEAD)
1808         )
1809     )
1810 )
1811 (CommandSet ThreadReference=11
1812     (Command Name=1
1813         &quot;Returns the thread name. &quot;
1814         (Out
1815             (threadObject thread &quot;The thread object ID. &quot;)
1816         )
1817         (Reply
1818             (string threadName &quot;The thread name.&quot;)
1819         )
1820         (ErrorSet
1821             (Error INVALID_THREAD)
1822             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1823             (Error VM_DEAD)
1824         )
1825     )
1826     (Command Suspend=2
1827         &quot;Suspends the thread. &quot;
1828         &quot;&lt;p&gt;&quot;
1829         &quot;Unlike java.lang.Thread.suspend(), suspends of both &quot;
1830         &quot;the virtual machine and individual threads are counted. Before &quot;
1831         &quot;a thread will run again, it must be resumed the same number &quot;
1832         &quot;of times it has been suspended. &quot;
1833         &quot;&lt;p&gt;&quot;
1834         &quot;Suspending single threads with command has the same &quot;
1835         &quot;dangers java.lang.Thread.suspend(). If the suspended &quot;
1836         &quot;thread holds a monitor needed by another running thread, &quot;
1837         &quot;deadlock is possible in the target VM (at least until the &quot;
1838         &quot;suspended thread is resumed again). &quot;
1839         &quot;&lt;p&gt;&quot;
1840         &quot;The suspended thread is guaranteed to remain suspended until &quot;
1841         &quot;resumed through one of the JDI resume methods mentioned above; &quot;
1842         &quot;the application in the target VM cannot resume the suspended thread &quot;
1843         &quot;through {@link java.lang.Thread#resume}. &quot;
1844         &quot;&lt;p&gt;&quot;
1845         &quot;Note that this doesn&#39;t change the status of the thread (see the &quot;
1846         &quot;&lt;a href=\&quot;#JDWP_ThreadReference_Status\&quot;&gt;ThreadStatus&lt;/a&gt; command.) &quot;
1847         &quot;For example, if it was &quot;
1848         &quot;Running, it will still appear running to other threads. &quot;
1849         (Out
1850             (threadObject thread &quot;The thread object ID. &quot;)
1851         )
1852         (Reply &quot;none&quot;
1853         )
1854         (ErrorSet
1855             (Error INVALID_THREAD)
1856             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1857             (Error VM_DEAD)
1858         )
1859     )
1860     (Command Resume=3
1861         &quot;Resumes the execution of a given thread. If this thread was &quot;
1862         &quot;not previously suspended by the front-end, &quot;
1863         &quot;calling this command has no effect. &quot;
1864         &quot;Otherwise, the count of pending suspends on this thread is &quot;
1865         &quot;decremented. If it is decremented to 0, the thread will &quot;
1866         &quot;continue to execute. &quot;
1867         (Out
1868             (threadObject thread &quot;The thread object ID. &quot;)
1869         )
1870         (Reply &quot;none&quot;
1871         )
1872         (ErrorSet
1873             (Error INVALID_THREAD)
1874             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1875             (Error VM_DEAD)
1876         )
1877     )
1878     (Command Status=4
1879         &quot;Returns the current status of a thread. The thread status &quot;
1880         &quot;reply indicates the thread status the last time it was running. &quot;
1881         &quot;the suspend status provides information on the thread&#39;s &quot;
1882         &quot;suspension, if any.&quot;
1883         (Out
1884             (threadObject thread &quot;The thread object ID. &quot;)
1885         )
1886         (Reply
1887             (int threadStatus &quot;One of the thread status codes &quot;
1888                     &quot;See &lt;a href=\&quot;#JDWP_ThreadStatus\&quot;&gt;JDWP.ThreadStatus&lt;/a&gt;&quot;)
1889             (int suspendStatus &quot;One of the suspend status codes &quot;
1890                     &quot;See &lt;a href=\&quot;#JDWP_SuspendStatus\&quot;&gt;JDWP.SuspendStatus&lt;/a&gt;&quot;)
1891         )
1892         (ErrorSet
1893             (Error INVALID_THREAD)
1894             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1895             (Error VM_DEAD)
1896         )
1897     )
1898     (Command ThreadGroup=5
1899         &quot;Returns the thread group that contains a given thread. &quot;
1900         (Out
1901             (threadObject thread &quot;The thread object ID. &quot;)
1902         )
1903         (Reply
1904             (threadGroupObject group &quot;The thread group of this thread. &quot;)
1905         )
1906         (ErrorSet
1907             (Error INVALID_THREAD)
1908             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1909             (Error VM_DEAD)
1910         )
1911     )
1912     (Command Frames=6
1913         &quot;Returns the current call stack of a suspended thread. &quot;
1914         &quot;The sequence of frames starts with &quot;
1915         &quot;the currently executing frame, followed by its caller, &quot;
1916         &quot;and so on. The thread must be suspended, and the returned &quot;
1917         &quot;frameID is valid only while the thread is suspended. &quot;
1918         (Out
1919             (threadObject thread &quot;The thread object ID. &quot;)
1920             (int startFrame &quot;The index of the first frame to retrieve.&quot;)
1921             (int length
1922                         &quot;The count of frames to retrieve &quot;
1923                         &quot;(-1 means all remaining). &quot;)
1924         )
1925         (Reply
1926             (Repeat frames &quot;The number of frames retreived&quot;
1927                 (Group Frame
1928                     (frame frameID &quot;The ID of this frame. &quot;)
1929                     (location location &quot;The current location of this frame&quot;)
1930                 )
1931             )
1932         )
1933         (ErrorSet
1934             (Error INVALID_THREAD)
1935             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1936             (Error VM_DEAD)
1937         )
1938     )
1939     (Command FrameCount=7
1940         &quot;Returns the count of frames on this thread&#39;s stack. &quot;
1941         &quot;The thread must be suspended, and the returned &quot;
1942         &quot;count is valid only while the thread is suspended. &quot;
1943         &quot;Returns JDWP.Error.errorThreadNotSuspended if not suspended. &quot;
1944         (Out
1945             (threadObject thread &quot;The thread object ID. &quot;)
1946         )
1947         (Reply
1948             (int frameCount &quot;The count of frames on this thread&#39;s stack. &quot;)
1949         )
1950         (ErrorSet
1951             (Error INVALID_THREAD)
1952             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1953             (Error VM_DEAD)
1954         )
1955     )
1956     (Command OwnedMonitors=8
1957         &quot;Returns the objects whose monitors have been entered by this thread. &quot;
1958         &quot;The thread must be suspended, and the returned information is &quot;
1959         &quot;relevant only while the thread is suspended. &quot;
1960         &quot;Requires canGetOwnedMonitorInfo capability - see &quot;
1961         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1962         (Out
1963             (threadObject thread &quot;The thread object ID. &quot;)
1964         )
1965         (Reply
1966             (Repeat owned &quot;The number of owned monitors&quot;
1967                 (tagged-object monitor &quot;An owned monitor&quot;)
1968             )
1969         )
1970         (ErrorSet
1971             (Error INVALID_THREAD)
1972             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1973             (Error NOT_IMPLEMENTED)
1974             (Error VM_DEAD)
1975         )
1976     )
1977     (Command CurrentContendedMonitor=9
1978         &quot;Returns the object, if any, for which this thread is waiting. The &quot;
1979         &quot;thread may be waiting to enter a monitor, or it may be waiting, via &quot;
1980         &quot;the java.lang.Object.wait method, for another thread to invoke the &quot;
1981         &quot;notify method. &quot;
1982         &quot;The thread must be suspended, and the returned information is &quot;
1983         &quot;relevant only while the thread is suspended. &quot;
1984         &quot;Requires canGetCurrentContendedMonitor capability - see &quot;
1985         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
1986         (Out
1987             (threadObject thread &quot;The thread object ID. &quot;)
1988         )
1989         (Reply
1990             (tagged-object monitor &quot;The contended monitor, or null if &quot;
1991                                    &quot;there is no current contended monitor. &quot;)
1992         )
1993         (ErrorSet
1994             (Error INVALID_THREAD)
1995             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
1996             (Error NOT_IMPLEMENTED)
1997             (Error VM_DEAD)
1998         )
1999     )
2000     (Command Stop=10
2001         &quot;Stops the thread with an asynchronous exception. &quot;
2002         (Out
2003             (threadObject thread &quot;The thread object ID. &quot;)
2004             (object throwable &quot;Asynchronous exception. This object must &quot;
2005                               &quot;be an instance of java.lang.Throwable or a subclass&quot;)
2006         )
2007         (Reply &quot;none&quot;
2008         )
2009         (ErrorSet
2010             (Error INVALID_THREAD)
2011             (Error INVALID_OBJECT &quot;If thread is not a known ID or the asynchronous &quot;
2012                                   &quot;exception has been garbage collected.&quot;)
2013             (Error VM_DEAD)
2014         )
2015     )
2016     (Command Interrupt=11
2017         &quot;Interrupt the thread, as if done by java.lang.Thread.interrupt &quot;
2018         (Out
2019             (threadObject thread &quot;The thread object ID. &quot;)
2020         )
2021         (Reply &quot;none&quot;
2022         )
2023         (ErrorSet
2024             (Error INVALID_THREAD)
2025             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2026             (Error VM_DEAD)
2027         )
2028     )
2029     (Command SuspendCount=12
2030         &quot;Get the suspend count for this thread. The suspend count is the  &quot;
2031         &quot;number of times the thread has been suspended through the &quot;
2032         &quot;thread-level or VM-level suspend commands without a corresponding resume &quot;
2033         (Out
2034             (threadObject thread &quot;The thread object ID. &quot;)
2035         )
2036         (Reply
2037             (int suspendCount &quot;The number of outstanding suspends of this thread. &quot;)
2038         )
2039         (ErrorSet
2040             (Error INVALID_THREAD)
2041             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2042             (Error VM_DEAD)
2043         )
2044     )
2045     (Command OwnedMonitorsStackDepthInfo=13
2046         &quot;Returns monitor objects owned by the thread, along with stack depth at which &quot;
2047         &quot;the monitor was acquired. Returns stack depth of -1  if &quot;
2048         &quot;the implementation cannot determine the stack depth &quot;
2049         &quot;(e.g., for monitors acquired by JNI MonitorEnter).&quot;
2050         &quot;The thread must be suspended, and the returned information is &quot;
2051         &quot;relevant only while the thread is suspended. &quot;
2052         &quot;Requires canGetMonitorFrameInfo capability - see &quot;
2053         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2054         &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2055 
2056         (Out
2057             (threadObject thread &quot;The thread object ID. &quot;)
2058         )
2059         (Reply
2060             (Repeat owned &quot;The number of owned monitors&quot;
2061                (Group monitor
2062                   (tagged-object monitor &quot;An owned monitor&quot;)
2063                   (int stack_depth &quot;Stack depth location where monitor was acquired&quot;)
2064                )
2065             )
2066         )
2067         (ErrorSet
2068             (Error INVALID_THREAD)
2069             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2070             (Error NOT_IMPLEMENTED)
2071             (Error VM_DEAD)
2072         )
2073     )
2074     (Command ForceEarlyReturn=14
2075         &quot;Force a method to return before it reaches a return &quot;
2076         &quot;statement.  &quot;
2077         &quot;&lt;p&gt;&quot;
2078         &quot;The method which will return early is referred to as the &quot;
2079         &quot;called method. The called method is the current method (as &quot;
2080         &quot;defined by the Frames section in &quot;
2081         &quot;&lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;) &quot;
2082         &quot;for the specified thread at the time this command &quot;
2083         &quot;is received. &quot;
2084         &quot;&lt;p&gt;&quot;
2085         &quot;The specified thread must be suspended. &quot;
2086         &quot;The return occurs when execution of Java programming &quot;
2087         &quot;language code is resumed on this thread. Between sending this &quot;
2088         &quot;command and resumption of thread execution, the &quot;
2089         &quot;state of the stack is undefined. &quot;
2090         &quot;&lt;p&gt;&quot;
2091         &quot;No further instructions are executed in the called &quot;
2092         &quot;method. Specifically, finally blocks are not executed. Note: &quot;
2093         &quot;this can cause inconsistent states in the application. &quot;
2094         &quot;&lt;p&gt;&quot;
2095         &quot;A lock acquired by calling the called method (if it is a &quot;
2096         &quot;synchronized method) and locks acquired by entering &quot;
2097         &quot;synchronized blocks within the called method are &quot;
2098         &quot;released. Note: this does not apply to JNI locks or &quot;
2099         &quot;java.util.concurrent.locks locks. &quot;
2100         &quot;&lt;p&gt;&quot;
2101         &quot;Events, such as MethodExit, are generated as they would be in &quot;
2102         &quot;a normal return. &quot;
2103         &quot;&lt;p&gt;&quot;
2104         &quot;The called method must be a non-native Java programming &quot;
2105         &quot;language method. Forcing return on a thread with only one &quot;
2106         &quot;frame on the stack causes the thread to exit when resumed. &quot;
2107         &quot;&lt;p&gt;&quot;
2108         &quot;For void methods, the value must be a void value. &quot;
2109         &quot;For methods that return primitive values, the value&#39;s type must &quot;
2110         &quot;match the return type exactly.  For object values, there must be a &quot;
2111         &quot;widening reference conversion from the value&#39;s type to the &quot;
2112         &quot;return type type and the return type must be loaded. &quot;
2113         &quot;&lt;p&gt;&quot;
2114         &quot;Since JDWP version 1.6. Requires canForceEarlyReturn capability - see &quot;
2115         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2116         (Out
2117             (threadObject thread &quot;The thread object ID. &quot;)
2118             (value value &quot;The value to return. &quot;)
2119         )
2120         (Reply &quot;none&quot;
2121         )
2122         (ErrorSet
2123             (Error INVALID_THREAD)
2124             (Error INVALID_OBJECT    &quot;Thread or value is not a known ID.&quot;)
2125             (Error THREAD_NOT_SUSPENDED)
2126             (Error THREAD_NOT_ALIVE)
2127             (Error OPAQUE_FRAME      &quot;Attempted to return early from &quot;
2128                                      &quot;a frame corresponding to a native &quot;
2129                                      &quot;method. Or the implementation is &quot;
2130                                      &quot;unable to provide this functionality &quot;
2131                                      &quot;on this frame.&quot;)
2132             (Error NO_MORE_FRAMES)
2133             (Error NOT_IMPLEMENTED)
2134             (Error TYPE_MISMATCH   &quot;Value is not an appropriate type for the &quot;
2135                                    &quot;return value of the method.&quot;)
2136             (Error VM_DEAD)
2137         )
2138     )
2139 
2140 )
2141 (CommandSet ThreadGroupReference=12
2142     (Command Name=1
2143         &quot;Returns the thread group name. &quot;
2144         (Out
2145             (threadGroupObject group &quot;The thread group object ID. &quot;)
2146         )
2147         (Reply
2148             (string groupName &quot;The thread group&#39;s name.&quot;)
2149         )
2150         (ErrorSet
2151             (Error INVALID_THREAD_GROUP)
2152             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2153             (Error VM_DEAD)
2154         )
2155     )
2156     (Command Parent=2
2157         &quot;Returns the thread group, if any, which contains a given thread group. &quot;
2158         (Out
2159             (threadGroupObject group &quot;The thread group object ID. &quot;)
2160         )
2161         (Reply
2162             (threadGroupObject parentGroup &quot;The parent thread group object, or &quot;
2163                                            &quot;null if the given thread group &quot;
2164                                            &quot;is a top-level thread group&quot;)
2165         )
2166         (ErrorSet
2167             (Error INVALID_THREAD_GROUP)
2168             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2169             (Error VM_DEAD)
2170         )
2171     )
2172     (Command Children=3
2173         &quot;Returns the live threads and active thread groups directly contained &quot;
2174         &quot;in this thread group. Threads and thread groups in child &quot;
2175         &quot;thread groups are not included. &quot;
2176         &quot;A thread is alive if it has been started and has not yet been stopped. &quot;
2177         &quot;See &lt;a href=../../api/java.base/java/lang/ThreadGroup.html&gt;java.lang.ThreadGroup &lt;/a&gt;
2178         &quot;for information about active ThreadGroups.
2179         (Out
2180             (threadGroupObject group &quot;The thread group object ID. &quot;)
2181         )
2182         (Reply
2183             (Repeat childThreads &quot;The number of live child threads. &quot;
2184                 (threadObject childThread &quot;A direct child thread ID. &quot;)
2185             )
2186             (Repeat childGroups &quot;The number of active child thread groups. &quot;
2187                 (threadGroupObject childGroup &quot;A direct child thread group ID. &quot;)
2188             )
2189         )
2190         (ErrorSet
2191             (Error INVALID_THREAD_GROUP)
2192             (Error INVALID_OBJECT    &quot;group is not a known ID.&quot;)
2193             (Error VM_DEAD)
2194         )
2195     )
2196 )
2197 (CommandSet ArrayReference=13
2198     (Command Length=1
2199         &quot;Returns the number of components in a given array. &quot;
2200         (Out
2201             (arrayObject arrayObject &quot;The array object ID. &quot;)
2202         )
2203         (Reply
2204             (int arrayLength &quot;The length of the array.&quot;)
2205         )
2206         (ErrorSet
2207             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2208             (Error INVALID_ARRAY)
2209             (Error VM_DEAD)
2210         )
2211     )
2212     (Command GetValues=2
2213         &quot;Returns a range of array components. The specified range must &quot;
2214         &quot;be within the bounds of the array. &quot;
2215         (Out
2216             (arrayObject arrayObject &quot;The array object ID. &quot;)
2217             (int firstIndex &quot;The first index to retrieve.&quot;)
2218             (int length &quot;The number of components to retrieve.&quot;)
2219         )
2220         (Reply
2221             (typed-sequence values &quot;The retrieved values. If the values &quot;
2222                                    &quot;are objects, they are tagged-values; &quot;
2223                                    &quot;otherwise, they are untagged-values&quot;)
2224         )
2225         (ErrorSet
2226             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2227             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2228             (Error INVALID_ARRAY)
2229             (Error VM_DEAD)
2230         )
2231     )
2232     (Command SetValues=3
2233         &quot;Sets a range of array components. The specified range must &quot;
2234         &quot;be within the bounds of the array. &quot;
2235         &quot;For primitive values, each value&#39;s type must match the &quot;
2236         &quot;array component type exactly. For object values, there must be a &quot;
2237         &quot;widening reference conversion from the value&#39;s type to the
2238         &quot;array component type and the array component type must be loaded. &quot;
2239         (Out
2240             (arrayObject arrayObject &quot;The array object ID. &quot;)
2241             (int firstIndex &quot;The first index to set.&quot;)
2242             (Repeat values &quot;The number of values to set. &quot;
2243                 (untagged-value value &quot;A value to set. &quot;)
2244             )
2245         )
2246         (Reply &quot;none&quot;
2247         )
2248         (ErrorSet
2249             (Error INVALID_LENGTH &quot;If index is beyond the end of this array.&quot;)
2250             (Error INVALID_OBJECT    &quot;arrayObject is not a known ID.&quot;)
2251             (Error INVALID_ARRAY)
2252             (Error VM_DEAD)
2253         )
2254     )
2255 )
2256 (CommandSet ClassLoaderReference=14
2257     (Command VisibleClasses=1
2258         &quot;Returns a list of all classes which this class loader can find &quot;
2259         &quot;by name via &lt;code&gt;ClassLoader::loadClass&lt;/code&gt;, &quot;
2260         &quot;&lt;code&gt;Class::forName&lt;/code&gt; and bytecode linkage. That is, &quot;
2261         &quot;all classes for which this class loader has been recorded as an &quot;
2262         &quot;&lt;i&gt;initiating&lt;/i&gt; loader. The list contains each &quot;
2263         &quot;reference type created by this loader and any types for which &quot;
2264         &quot;loading was delegated by this class loader to another class loader. &quot;
2265         &quot;&lt;p&gt;&quot;
2266         &quot;The visible class list has useful properties with respect to &quot;
2267         &quot;the type namespace. A particular type name will occur at most &quot;
2268         &quot;once in the list. Each field or variable declared with that &quot;
2269         &quot;type name in a class defined by &quot;
2270         &quot;this class loader must be resolved to that single type. &quot;
2271         &quot;&lt;p&gt;&quot;
2272         &quot;No ordering of the returned list is guaranteed. &quot;
2273         &quot;&lt;p&gt;&quot;
2274         &quot;See &lt;a href=\&quot;../jvmti.html#GetClassLoaderClasses\&quot;&gt;JVM TI GetClassLoaderClasses&lt;/a&gt;. &quot;
2275         (Out
2276             (classLoaderObject classLoaderObject &quot;The class loader object ID. &quot;)
2277         )
2278         (Reply
2279             (Repeat classes &quot;The number of visible classes. &quot;
2280                 (Group ClassInfo
2281                     (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2282                                       &quot;of following reference type. &quot;)
2283                     (referenceTypeID typeID
2284                         &quot;A class visible to this class loader.&quot;)
2285                 )
2286             )
2287         )
2288         (ErrorSet
2289             (Error INVALID_OBJECT)
2290             (Error INVALID_CLASS_LOADER)
2291             (Error VM_DEAD)
2292         )
2293     )
2294 )
2295 (CommandSet EventRequest=15
2296     (Command Set=1
2297         &quot;Set an event request. When the event described by this request &quot;
2298         &quot;occurs, an &lt;a href=\&quot;#JDWP_Event\&quot;&gt;event&lt;/a&gt; is sent from the &quot;
2299         &quot;target VM. If an event occurs that has not been requested then it is not sent &quot;
2300         &quot;from the target VM. The two exceptions to this are the VM Start Event and &quot;
2301         &quot;the VM Death Event which are automatically generated events - see &quot;
2302         &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;Composite Command&lt;/a&gt; for further details.&quot;
2303         (Out
2304             (byte eventKind &quot;Event kind to request. &quot;
2305                       &quot;See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2306                       &quot;for a complete list of events that can be requested; &quot;
2307                       &quot;some events may require a capability in order to be requested. &quot;
2308                       )
2309             (byte suspendPolicy
2310                       &quot;What threads are suspended when this event occurs? &quot;
2311                       &quot;Note that the order of events and command replies &quot;
2312                       &quot;accurately reflects the order in which threads are &quot;
2313                       &quot;suspended and resumed. For example, if a &quot;
2314                       &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_Resume\&quot;&gt;VM-wide resume&lt;/a&gt; &quot;
2315                       &quot;is processed before an event occurs which suspends the &quot;
2316                       &quot;VM, the reply to the resume command will be written to &quot;
2317                       &quot;the transport before the suspending event.&quot;)
2318             (Repeat modifiers &quot;Constraints used to control the number &quot;
2319                               &quot;of generated events.&quot;
2320                               &quot;Modifiers specify additional tests that &quot;
2321                               &quot;an event must satisfy before it is placed &quot;
2322                               &quot;in the event queue. Events are filtered by &quot;
2323                               &quot;applying each modifier to an event in the &quot;
2324                               &quot;order they are specified in this collection &quot;
2325                               &quot;Only events that satisfy all modifiers &quot;
2326                               &quot;are reported. A value of 0 means there are no &quot;
2327                               &quot;modifiers in the request.&quot;
2328                               &quot;&lt;p&gt;&quot;
2329                               &quot;Filtering can improve &quot;
2330                               &quot;debugger performance dramatically by
2331                               &quot;reducing the &quot;
2332                               &quot;amount of event traffic sent from the &quot;
2333                               &quot;target VM to the debugger VM. &quot;
2334                 (Select Modifier
2335                     (byte modKind &quot;Modifier kind&quot;)
2336                     (Alt Count=1
2337                         &quot;Limit the requested event to be reported at most once after a &quot;
2338                         &quot;given number of occurrences.  The event is not reported &quot;
2339                         &quot;the first &lt;code&gt;count - 1&lt;/code&gt; times this filter is reached. &quot;
2340                         &quot;To request a one-off event, call this method with a count of 1. &quot;
2341                         &quot;&lt;p&gt;&quot;
2342                         &quot;Once the count reaches 0, any subsequent filters in this request &quot;
2343                         &quot;are applied. If none of those filters cause the event to be &quot;
2344                         &quot;suppressed, the event is reported. Otherwise, the event is not &quot;
2345                         &quot;reported. In either case subsequent events are never reported for &quot;
2346                         &quot;this request. &quot;
2347                         &quot;This modifier can be used with any event kind.&quot;
2348 
2349                         (int count &quot;Count before event. One for one-off.&quot;)
2350                     )
2351                     (Alt Conditional=2 &quot;Conditional on expression&quot;
2352                         (int exprID &quot;For the future&quot;)
2353                     )
2354                     (Alt ThreadOnly=3
2355                         &quot;Restricts reported events to &quot;
2356                         &quot;those in the given thread. &quot;
2357                         &quot;This modifier can be used with any event kind &quot;
2358                         &quot;except for class unload. &quot;
2359 
2360                         (threadObject thread &quot;Required thread&quot;)
2361                     )
2362                     (Alt ClassOnly=4
2363                         &quot;For class prepare events, restricts the events &quot;
2364                         &quot;generated by this request to be the &quot;
2365                         &quot;preparation of the given reference type and any subtypes. &quot;
2366                         &quot;For monitor wait and waited events, restricts the events &quot;
2367                         &quot;generated by this request to those whose monitor object &quot;
2368                         &quot;is of the given reference type or any of its subtypes. &quot;
2369                         &quot;For other events, restricts the events generated &quot;
2370                         &quot;by this request to those &quot;
2371                         &quot;whose location is in the given reference type or any of its subtypes. &quot;
2372                         &quot;An event will be generated for any location in a reference type that can &quot;
2373                         &quot;be safely cast to the given reference type. &quot;
2374                         &quot;This modifier can be used with any event kind except &quot;
2375                         &quot;class unload, thread start, and thread end. &quot;
2376 
2377                         (referenceType clazz &quot;Required class&quot;)
2378                     )
2379                     (Alt ClassMatch=5
2380                         &quot;Restricts reported events to those for classes whose name &quot;
2381                         &quot;matches the given restricted regular expression. &quot;
2382                         &quot;For class prepare events, the prepared class name &quot;
2383                         &quot;is matched. For class unload events, the &quot;
2384                         &quot;unloaded class name is matched. For monitor wait &quot;
2385                         &quot;and waited events, the name of the class of the &quot;
2386                         &quot;monitor object is matched. For other events, &quot;
2387                         &quot;the class name of the event&#39;s location is matched. &quot;
2388                         &quot;This modifier can be used with any event kind except &quot;
2389                         &quot;thread start and thread end. &quot;
2390 
2391                         (string classPattern &quot;Required class pattern. &quot;
2392                                 &quot;Matches are limited to exact matches of the &quot;
2393                                 &quot;given class pattern and matches of patterns that &quot;
2394                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2395                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2396                         )
2397 
2398                     )
2399                     (Alt ClassExclude=6
2400                         &quot;Restricts reported events to those for classes whose name &quot;
2401                         &quot;does not match the given restricted regular expression. &quot;
2402                         &quot;For class prepare events, the prepared class name &quot;
2403                         &quot;is matched. For class unload events, the &quot;
2404                         &quot;unloaded class name is matched. For monitor wait and &quot;
2405                         &quot;waited events, the name of the class of the monitor &quot;
2406                         &quot;object is matched. For other events, &quot;
2407                         &quot;the class name of the event&#39;s location is matched. &quot;
2408                         &quot;This modifier can be used with any event kind except &quot;
2409                         &quot;thread start and thread end. &quot;
2410 
2411                         (string classPattern &quot;Disallowed class pattern. &quot;
2412                                 &quot;Matches are limited to exact matches of the &quot;
2413                                 &quot;given class pattern and matches of patterns that &quot;
2414                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2415                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2416                         )
2417                     )
2418                     (Alt LocationOnly=7
2419                         &quot;Restricts reported events to those that occur at &quot;
2420                         &quot;the given location. &quot;
2421                         &quot;This modifier can be used with &quot;
2422                         &quot;breakpoint, field access, field modification, &quot;
2423                         &quot;step, and exception event kinds. &quot;
2424 
2425                         (location loc &quot;Required location&quot;)
2426                     )
2427                     (Alt ExceptionOnly=8
2428                         &quot;Restricts reported exceptions by their class and &quot;
2429                         &quot;whether they are caught or uncaught. &quot;
2430                         &quot;This modifier can be used with &quot;
2431                         &quot;exception event kinds only. &quot;
2432 
2433                         (referenceType exceptionOrNull
2434                                 &quot;Exception to report. Null (0) means report &quot;
2435                                 &quot;exceptions of all types. &quot;
2436                                 &quot;A non-null type restricts the reported exception &quot;
2437                                 &quot;events to exceptions of the given type or &quot;
2438                                 &quot;any of its subtypes. &quot;
2439                         )
2440                         (boolean caught &quot;Report caught exceptions&quot;)
2441                         (boolean uncaught &quot;Report uncaught exceptions. &quot;
2442                                 &quot;Note that it &quot;
2443                                 &quot;is not always possible to determine whether an &quot;
2444                                 &quot;exception is caught or uncaught at the time it is &quot;
2445                                 &quot;thrown. See the exception event catch location under &quot;
2446                                 &quot;&lt;a href=\&quot;#JDWP_Event_Composite\&quot;&gt;composite events&lt;/a&gt; &quot;
2447                                 &quot;for more information. &quot;
2448                         )
2449 
2450                     )
2451                     (Alt FieldOnly=9
2452                         &quot;Restricts reported events to those that occur for &quot;
2453                         &quot;a given field. &quot;
2454                         &quot;This modifier can be used with &quot;
2455                         &quot;field access and field modification event kinds only. &quot;
2456 
2457                         (referenceType declaring &quot;Type in which field is declared.&quot;)
2458                         (field fieldID &quot;Required field&quot;)
2459                     )
2460                     (Alt Step=10
2461                         &quot;Restricts reported step events &quot;
2462                         &quot;to those which satisfy &quot;
2463                         &quot;depth and size constraints. &quot;
2464                         &quot;This modifier can be used with &quot;
2465                         &quot;step event kinds only. &quot;
2466 
2467                         (threadObject thread &quot;Thread in which to step&quot;)
2468                         (int size &quot;size of each step. &quot;
2469                            &quot;See &lt;a href=\&quot;#JDWP_StepSize\&quot;&gt;JDWP.StepSize&lt;/a&gt;&quot;)
2470                         (int depth &quot;relative call stack limit. &quot;
2471                            &quot;See &lt;a href=\&quot;#JDWP_StepDepth\&quot;&gt;JDWP.StepDepth&lt;/a&gt;&quot;)
2472                     )
2473                     (Alt InstanceOnly=11
2474                         &quot;Restricts reported events to those whose &quot;
2475                         &quot;active &#39;this&#39; object is the given object. &quot;
2476                         &quot;Match value is the null object for static methods. &quot;
2477                         &quot;This modifier can be used with any event kind &quot;
2478                         &quot;except class prepare, class unload, thread start, &quot;
2479                         &quot;and thread end. Introduced in JDWP version 1.4.&quot;
2480 
2481                         (object instance &quot;Required &#39;this&#39; object&quot;)
2482                     )
2483                     (Alt SourceNameMatch=12
2484                         &quot;Restricts reported class prepare events to those &quot;
2485                         &quot;for reference types which have a source name &quot;
2486                         &quot;which matches the given restricted regular expression. &quot;
2487                         &quot;The source names are determined by the reference type&#39;s &quot;
2488                         &quot;&lt;a href=\&quot;#JDWP_ReferenceType_SourceDebugExtension\&quot;&gt; &quot;
2489                         &quot;SourceDebugExtension&lt;/a&gt;. &quot;
2490                         &quot;This modifier can only be used with class prepare &quot;
2491                         &quot;events. &quot;
2492                         &quot;Since JDWP version 1.6. Requires the canUseSourceNameFilters &quot;
2493                         &quot;capability - see &quot;
2494                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2495 
2496                         (string sourceNamePattern &quot;Required source name pattern. &quot;
2497                                 &quot;Matches are limited to exact matches of the &quot;
2498                                 &quot;given pattern and matches of patterns that &quot;
2499                                 &quot;begin or end with &#39;*&#39;; for example, &quot;
2500                                 &quot;\&quot;*.Foo\&quot; or \&quot;java.*\&quot;. &quot;
2501                         )
2502                     )
2503 
2504                 )
2505             )
2506         )
2507         (Reply
2508             (int requestID &quot;ID of created request&quot;)
2509         )
2510         (ErrorSet
2511             (Error INVALID_THREAD)
2512             (Error INVALID_CLASS)
2513             (Error INVALID_STRING)
2514             (Error INVALID_OBJECT)
2515             (Error INVALID_COUNT)
2516             (Error INVALID_FIELDID)
2517             (Error INVALID_METHODID)
2518             (Error INVALID_LOCATION)
2519             (Error INVALID_EVENT_TYPE)
2520             (Error NOT_IMPLEMENTED)
2521             (Error VM_DEAD)
2522         )
2523     )
2524     (Command Clear=2
2525         &quot;Clear an event request. See &lt;a href=\&quot;#JDWP_EventKind\&quot;&gt;JDWP.EventKind&lt;/a&gt; &quot;
2526         &quot;for a complete list of events that can be cleared. Only the event request matching &quot;
2527         &quot;the specified event kind and requestID is cleared. If there isn&#39;t a matching event &quot;
2528         &quot;request the command is a no-op and does not result in an error. Automatically &quot;
2529         &quot;generated events do not have a corresponding event request and may not be cleared &quot;
2530         &quot;using this command.&quot;
2531         (Out
2532             (byte eventKind &quot;Event kind to clear&quot;)
2533             (int requestID &quot;ID of request to clear&quot;)
2534         )
2535         (Reply &quot;none&quot;
2536         )
2537         (ErrorSet
2538             (Error VM_DEAD)
2539             (Error INVALID_EVENT_TYPE)
2540         )
2541     )
2542     (Command ClearAllBreakpoints=3
2543         &quot;Removes all set breakpoints, a no-op if there are no breakpoints set.&quot;
2544         (Out &quot;none&quot;
2545         )
2546         (Reply &quot;none&quot;
2547         )
2548         (ErrorSet
2549             (Error VM_DEAD)
2550         )
2551     )
2552 )
2553 (CommandSet StackFrame=16
2554     (Command GetValues=1
2555         &quot;Returns the value of one or more local variables in a &quot;
2556         &quot;given frame. Each variable must be visible at the frame&#39;s code index. &quot;
2557         &quot;Even if local variable information is not available, values can &quot;
2558         &quot;be retrieved if the front-end is able to &quot;
2559         &quot;determine the correct local variable index. (Typically, this &quot;
2560         &quot;index can be determined for method arguments from the method &quot;
2561         &quot;signature without access to the local variable table information.) &quot;
2562         (Out
2563             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2564             (frame frame &quot;The frame ID. &quot;)
2565             (Repeat slots &quot;The number of values to get. &quot;
2566                 (Group SlotInfo
2567                     (int slot &quot;The local variable&#39;s index in the frame. &quot;)
2568                     (byte sigbyte &quot;A &lt;a href=\&quot;#JDWP_Tag\&quot;&gt;tag&lt;/a&gt; &quot;
2569                                   &quot;identifying the type of the variable &quot;)
2570                 )
2571             )
2572         )
2573         (Reply
2574             (Repeat values &quot;The number of values retrieved, always equal to slots, &quot;
2575                            &quot;the number of values to get.&quot;
2576                 (value slotValue &quot;The value of the local variable. &quot;)
2577             )
2578         )
2579         (ErrorSet
2580             (Error INVALID_THREAD)
2581             (Error INVALID_OBJECT)
2582             (Error INVALID_FRAMEID)
2583             (Error INVALID_SLOT)
2584             (Error VM_DEAD)
2585         )
2586     )
2587     (Command SetValues=2
2588         &quot;Sets the value of one or more local variables. &quot;
2589         &quot;Each variable must be visible at the current frame code index. &quot;
2590         &quot;For primitive values, the value&#39;s type must match the &quot;
2591         &quot;variable&#39;s type exactly. For object values, there must be a &quot;
2592         &quot;widening reference conversion from the value&#39;s type to the
2593         &quot;variable&#39;s type and the variable&#39;s type must be loaded. &quot;
2594         &quot;&lt;p&gt;&quot;
2595         &quot;Even if local variable information is not available, values can &quot;
2596         &quot;be set, if the front-end is able to &quot;
2597         &quot;determine the correct local variable index. (Typically, this
2598         &quot;index can be determined for method arguments from the method &quot;
2599         &quot;signature without access to the local variable table information.) &quot;
2600         (Out
2601             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2602             (frame frame &quot;The frame ID. &quot;)
2603             (Repeat slotValues &quot;The number of values to set. &quot;
2604                 (Group SlotInfo
2605                     (int slot &quot;The slot ID. &quot;)
2606                     (value slotValue &quot;The value to set. &quot;)
2607                 )
2608             )
2609         )
2610         (Reply &quot;none&quot;
2611         )
2612         (ErrorSet
2613             (Error INVALID_THREAD)
2614             (Error INVALID_OBJECT)
2615             (Error INVALID_FRAMEID)
2616             (Error VM_DEAD)
2617         )
2618     )
2619     (Command ThisObject=3
2620         &quot;Returns the value of the &#39;this&#39; reference for this frame. &quot;
2621         &quot;If the frame&#39;s method is static or native, the reply &quot;
2622         &quot;will contain the null object reference. &quot;
2623         (Out
2624             (threadObject thread &quot;The frame&#39;s thread. &quot;)
2625             (frame frame &quot;The frame ID. &quot;)
2626         )
2627         (Reply
2628             (tagged-object objectThis &quot;The &#39;this&#39; object for this frame. &quot;)
2629         )
2630         (ErrorSet
2631             (Error INVALID_THREAD)
2632             (Error INVALID_OBJECT)
2633             (Error INVALID_FRAMEID)
2634             (Error VM_DEAD)
2635         )
2636     )
2637     (Command PopFrames=4
2638         &quot;Pop the top-most stack frames of the thread stack, up to, and including &#39;frame&#39;. &quot;
2639         &quot;The thread must be suspended to perform this command. &quot;
2640         &quot;The top-most stack frames are discarded and the stack frame previous to &#39;frame&#39; &quot;
2641         &quot;becomes the current frame. The operand stack is restored -- the argument values &quot;
2642         &quot;are added back and if the invoke was not &lt;code&gt;invokestatic&lt;/code&gt;, &quot;
2643         &quot;&lt;code&gt;objectref&lt;/code&gt; is added back as well. The Java virtual machine &quot;
2644         &quot;program counter is restored to the opcode of the invoke instruction.&quot;
2645         &quot;&lt;p&gt;&quot;
2646         &quot;Since JDWP version 1.4. Requires canPopFrames capability - see &quot;
2647         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
2648         (Out
2649             (threadObject thread &quot;The thread object ID. &quot;)
2650             (frame frame &quot;The frame ID. &quot;)
2651         )
2652         (Reply &quot;none&quot;
2653         )
2654         (ErrorSet
2655             (Error INVALID_THREAD)
2656             (Error INVALID_OBJECT    &quot;thread is not a known ID.&quot;)
2657             (Error INVALID_FRAMEID)
2658             (Error THREAD_NOT_SUSPENDED)
2659             (Error NO_MORE_FRAMES)
2660             (Error INVALID_FRAMEID)
2661             (Error NOT_IMPLEMENTED)
2662             (Error VM_DEAD)
2663         )
2664     )
2665 )
2666 (CommandSet ClassObjectReference=17
2667     (Command ReflectedType = 1
2668         &quot;Returns the reference type reflected by this class object.&quot;
2669         (Out
2670             (classObject classObject &quot;The class object. &quot;)
2671         )
2672         (Reply
2673             (byte refTypeTag  &quot;&lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;Kind&lt;/a&gt; &quot;
2674                               &quot;of following reference type. &quot;)
2675             (referenceTypeID typeID &quot;reflected reference type&quot;)
2676         )
2677         (ErrorSet
2678             (Error INVALID_OBJECT)
2679             (Error VM_DEAD)
2680         )
2681     )
2682 )
2683 (CommandSet ModuleReference=18
2684     (Command Name=1
2685         &quot;Returns the name of this module.&quot;
2686         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2687         (Out
2688             (moduleID module &quot;This module.&quot;)
2689         )
2690         (Reply
2691             (string name  &quot;The module&#39;s name.&quot;)
2692         )
2693         (ErrorSet
2694             (Error INVALID_MODULE)
2695             (Error NOT_IMPLEMENTED)
2696             (Error VM_DEAD)
2697         )
2698     )
2699     (Command ClassLoader=2
2700         &quot;Returns the class loader of this module.&quot;
2701         &quot;&lt;p&gt;Since JDWP version 9.&quot;
2702         (Out
2703             (moduleID module &quot;This module.&quot;)
2704         )
2705         (Reply
2706             (classLoaderObject classLoader  &quot;The module&#39;s class loader.&quot;)
2707         )
2708         (ErrorSet
2709             (Error INVALID_MODULE)
2710             (Error NOT_IMPLEMENTED)
2711             (Error VM_DEAD)
2712         )
2713     )
2714 )
2715 (CommandSet Event=64
2716     (Command Composite=100
2717         &quot;Several events may occur at a given time in the target VM. &quot;
2718         &quot;For example, there may be more than one breakpoint request &quot;
2719         &quot;for a given location &quot;
2720         &quot;or you might single step to the same location as a &quot;
2721         &quot;breakpoint request.  These events are delivered &quot;
2722         &quot;together as a composite event.  For uniformity, a &quot;
2723         &quot;composite event is always used &quot;
2724         &quot;to deliver events, even if there is only one event to report. &quot;
2725         &quot;&lt;P&gt;&quot;
2726         &quot;The events that are grouped in a composite event are restricted in the &quot;
2727         &quot;following ways: &quot;
2728         &quot;&lt;UL&gt;&quot;
2729         &quot;&lt;LI&gt;Only with other thread start events for the same thread:&quot;
2730         &quot;    &lt;UL&gt;&quot;
2731         &quot;    &lt;LI&gt;Thread Start Event&quot;
2732         &quot;    &lt;/UL&gt;&quot;
2733         &quot;&lt;LI&gt;Only with other thread death events for the same thread:&quot;
2734         &quot;    &lt;UL&gt;&quot;
2735         &quot;    &lt;LI&gt;Thread Death Event&quot;
2736         &quot;    &lt;/UL&gt;&quot;
2737         &quot;&lt;LI&gt;Only with other class prepare events for the same class:&quot;
2738         &quot;    &lt;UL&gt;&quot;
2739         &quot;    &lt;LI&gt;Class Prepare Event&quot;
2740         &quot;    &lt;/UL&gt;&quot;
2741         &quot;&lt;LI&gt;Only with other class unload events for the same class:&quot;
2742         &quot;    &lt;UL&gt;&quot;
2743         &quot;    &lt;LI&gt;Class Unload Event&quot;
2744         &quot;    &lt;/UL&gt;&quot;
2745         &quot;&lt;LI&gt;Only with other access watchpoint events for the same field access:&quot;
2746         &quot;    &lt;UL&gt;&quot;
2747         &quot;    &lt;LI&gt;Access Watchpoint Event&quot;
2748         &quot;    &lt;/UL&gt;&quot;
2749         &quot;&lt;LI&gt;Only with other modification watchpoint events for the same field &quot;
2750         &quot;modification:&quot;
2751         &quot;    &lt;UL&gt;&quot;
2752         &quot;    &lt;LI&gt;Modification Watchpoint Event&quot;
2753         &quot;    &lt;/UL&gt;&quot;
2754         &quot;&lt;LI&gt;Only with other Monitor contended enter events for the same monitor object: &quot;
2755         &quot;    &lt;UL&gt;&quot;
2756         &quot;    &lt;LI&gt;Monitor Contended Enter Event&quot;
2757         &quot;    &lt;/UL&gt;&quot;
2758         &quot;&lt;LI&gt;Only with other Monitor contended entered events for the same monitor object: &quot;
2759         &quot;    &lt;UL&gt;&quot;
2760         &quot;    &lt;LI&gt;Monitor Contended Entered Event&quot;
2761         &quot;    &lt;/UL&gt;&quot;
2762         &quot;&lt;LI&gt;Only with other Monitor wait events for the same monitor object: &quot;
2763         &quot;    &lt;UL&gt;&quot;
2764         &quot;    &lt;LI&gt;Monitor Wait Event&quot;
2765         &quot;    &lt;/UL&gt;&quot;
2766         &quot;&lt;LI&gt;Only with other Monitor waited events for the same monitor object: &quot;
2767         &quot;    &lt;UL&gt;&quot;
2768         &quot;    &lt;LI&gt;Monitor Waited Event&quot;
2769         &quot;    &lt;/UL&gt;&quot;
2770         &quot;&lt;LI&gt;Only with other ExceptionEvents for the same exception occurrance:&quot;
2771         &quot;    &lt;UL&gt;&quot;
2772         &quot;    &lt;LI&gt;ExceptionEvent&quot;
2773         &quot;    &lt;/UL&gt;&quot;
2774         &quot;&lt;LI&gt;Only with other members of this group, at the same location &quot;
2775         &quot;and in the same thread: &quot;
2776         &quot;    &lt;UL&gt;&quot;
2777         &quot;    &lt;LI&gt;Breakpoint Event&quot;
2778         &quot;    &lt;LI&gt;Step Event&quot;
2779         &quot;    &lt;LI&gt;Method Entry Event&quot;
2780         &quot;    &lt;LI&gt;Method Exit Event&quot;
2781         &quot;    &lt;/UL&gt;&quot;
2782         &quot;&lt;/UL&gt;&quot;
2783         &quot;&lt;P&gt;&quot;
2784         &quot;The VM Start Event and VM Death Event are automatically generated events. &quot;
2785         &quot;This means they do not need to be requested using the &quot;
2786         &quot;&lt;a href=\&quot;#JDWP_EventRequest_Set\&quot;&gt;EventRequest.Set&lt;/a&gt; command. &quot;
2787         &quot;The VM Start event signals the completion of VM initialization. The VM Death &quot;
2788         &quot;event signals the termination of the VM.&quot;
2789         &quot;If there is a debugger connected at the time when an automatically generated &quot;
2790         &quot;event occurs it is sent from the target VM. Automatically generated events may &quot;
2791         &quot;also be requested using the EventRequest.Set command and thus multiple events &quot;
2792         &quot;of the same event kind will be sent from the target VM when an event occurs.&quot;
2793         &quot;Automatically generated events are sent with the requestID field &quot;
2794         &quot;in the Event Data set to 0. The value of the suspendPolicy field in the &quot;
2795         &quot;Event Data depends on the event. For the automatically generated VM Start &quot;
2796         &quot;Event the value of suspendPolicy is not defined and is therefore implementation &quot;
2797         &quot;or configuration specific. In the Sun implementation, for example, the &quot;
2798         &quot;suspendPolicy is specified as an option to the JDWP agent at launch-time.&quot;
2799         &quot;The automatically generated VM Death Event will have the suspendPolicy set to &quot;
2800         &quot;NONE.&quot;
2801 
2802        (Event &quot;Generated event&quot;
2803             (byte suspendPolicy
2804                 &quot;Which threads where suspended by this composite event?&quot;)
2805             (Repeat events &quot;Events in set.&quot;
2806                 (Select Events
2807                     (byte eventKind &quot;Event kind selector&quot;)
2808                     (Alt VMStart=JDWP.EventKind.VM_START
2809                         &quot;Notification of initialization of a target VM.  This event is &quot;
2810                         &quot;received before the main thread is started and before any &quot;
2811                         &quot;application code has been executed. Before this event occurs &quot;
2812                         &quot;a significant amount of system code has executed and a number &quot;
2813                         &quot;of system classes have been loaded. &quot;
2814                         &quot;This event is always generated by the target VM, even &quot;
2815                         &quot;if not explicitly requested.&quot;
2816 
2817                      (int requestID
2818                              &quot;Request that generated event (or 0 if this &quot;
2819                              &quot;event is automatically generated.&quot;)
2820                         (threadObject thread &quot;Initial thread&quot;)
2821                     )
2822                     (Alt SingleStep=JDWP.EventKind.SINGLE_STEP
2823                         &quot;Notification of step completion in the target VM. The step event &quot;
2824                         &quot;is generated before the code at its location is executed. &quot;
2825 
2826                         (int requestID &quot;Request that generated event&quot;)
2827                         (threadObject thread &quot;Stepped thread&quot;)
2828                         (location location &quot;Location stepped to&quot;)
2829                     )
2830                     (Alt Breakpoint=JDWP.EventKind.BREAKPOINT
2831                         &quot;Notification of a breakpoint in the target VM. The breakpoint event &quot;
2832                         &quot;is generated before the code at its location is executed. &quot;
2833 
2834                         (int requestID &quot;Request that generated event&quot;)
2835                         (threadObject thread &quot;Thread which hit breakpoint&quot;)
2836                         (location location &quot;Location hit&quot;)
2837                     )
2838                     (Alt MethodEntry=JDWP.EventKind.METHOD_ENTRY
2839                          &quot;Notification of a method invocation in the target VM. This event &quot;
2840                          &quot;is generated before any code in the invoked method has executed. &quot;
2841                          &quot;Method entry events are generated for both native and non-native &quot;
2842                          &quot;methods. &quot;
2843                          &quot;&lt;P&gt;&quot;
2844                          &quot;In some VMs method entry events can occur for a particular thread &quot;
2845                          &quot;before its thread start event occurs if methods are called &quot;
2846                          &quot;as part of the thread&#39;s initialization. &quot;
2847 
2848                         (int requestID &quot;Request that generated event&quot;)
2849                         (threadObject thread &quot;Thread which entered method&quot;)
2850                         (location location &quot;The initial executable location in the method.&quot;)
2851                     )
2852                     (Alt MethodExit=JDWP.EventKind.METHOD_EXIT
2853                          &quot;Notification of a method return in the target VM. This event &quot;
2854                          &quot;is generated after all code in the method has executed, but the &quot;
2855                          &quot;location of this event is the last executed location in the method. &quot;
2856                          &quot;Method exit events are generated for both native and non-native &quot;
2857                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2858                          &quot;with a thrown exception. &quot;
2859 
2860                         (int requestID &quot;Request that generated event&quot;)
2861                         (threadObject thread &quot;Thread which exited method&quot;)
2862                         (location location &quot;Location of exit&quot;)
2863                     )
2864                     (Alt MethodExitWithReturnValue=JDWP.EventKind.METHOD_EXIT_WITH_RETURN_VALUE
2865                          &quot;Notification of a method return in the target VM. This event &quot;
2866                          &quot;is generated after all code in the method has executed, but the &quot;
2867                          &quot;location of this event is the last executed location in the method. &quot;
2868                          &quot;Method exit events are generated for both native and non-native &quot;
2869                          &quot;methods. Method exit events are not generated if the method terminates &quot;
2870                          &quot;with a thrown exception. &lt;p&gt;Since JDWP version 1.6. &quot;
2871 
2872                         (int requestID &quot;Request that generated event&quot;)
2873                         (threadObject thread &quot;Thread which exited method&quot;)
2874                         (location location &quot;Location of exit&quot;)
2875                         (value value &quot;Value that will be returned by the method&quot;)
2876                     )
2877                     (Alt MonitorContendedEnter=JDWP.EventKind.MONITOR_CONTENDED_ENTER
2878                          &quot;Notification that a thread in the target VM is attempting &quot;
2879                          &quot;to enter a monitor that is already acquired by another thread. &quot;
2880                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2881                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2882                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2883 
2884                         (int requestID
2885                                 &quot;Request that generated event&quot;)
2886                         (threadObject thread &quot;Thread which is trying to enter the monitor&quot;)
2887                         (tagged-object object &quot;Monitor object reference&quot;)
2888                         (location location &quot;Location of contended monitor enter&quot;)
2889                     )
2890                     (Alt MonitorContendedEntered=JDWP.EventKind.MONITOR_CONTENDED_ENTERED
2891                          &quot;Notification of a thread in the target VM is entering a monitor &quot;
2892                          &quot;after waiting for it to be released by another thread. &quot;
2893                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2894                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2895                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2896 
2897                         (int requestID
2898                                 &quot;Request that generated event&quot;)
2899                         (threadObject thread &quot;Thread which entered monitor&quot;)
2900                         (tagged-object object &quot;Monitor object reference&quot;)
2901                         (location location &quot;Location of contended monitor enter&quot;)
2902                     )
2903                     (Alt MonitorWait=JDWP.EventKind.MONITOR_WAIT
2904                          &quot;Notification of a thread about to wait on a monitor object. &quot;
2905                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2906                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2907                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2908 
2909                         (int requestID
2910                                 &quot;Request that generated event&quot;)
2911                         (threadObject thread &quot;Thread which is about to wait&quot;)
2912                         (tagged-object object &quot;Monitor object reference&quot;)
2913                         (location location &quot;Location at which the wait will occur&quot;)
2914                         (long     timeout  &quot;Thread wait time in milliseconds&quot;)
2915                     )
2916                     (Alt MonitorWaited=JDWP.EventKind.MONITOR_WAITED
2917                          &quot;Notification that a thread in the target VM has finished waiting on &quot;
2918                          &quot;Requires canRequestMonitorEvents capability - see &quot;
2919                          &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;. &quot;
2920                          &quot;a monitor object. &quot;
2921                          &quot;&lt;p&gt;Since JDWP version 1.6. &quot;
2922 
2923                         (int requestID
2924                                 &quot;Request that generated event&quot;)
2925                         (threadObject thread &quot;Thread which waited&quot;)
2926                         (tagged-object object &quot;Monitor object reference&quot;)
2927                         (location location &quot;Location at which the wait occured&quot;)
2928                         (boolean  timed_out &quot;True if timed out&quot;)
2929                     )
2930                     (Alt Exception=JDWP.EventKind.EXCEPTION
2931                          &quot;Notification of an exception in the target VM. &quot;
2932                          &quot;If the exception is thrown from a non-native method, &quot;
2933                          &quot;the exception event is generated at the location where the &quot;
2934                          &quot;exception is thrown. &quot;
2935                          &quot;If the exception is thrown from a native method, the exception event &quot;
2936                          &quot;is generated at the first non-native location reached after the exception &quot;
2937                          &quot;is thrown. &quot;
2938 
2939                         (int requestID &quot;Request that generated event&quot;)
2940                         (threadObject thread &quot;Thread with exception&quot;)
2941                         (location location &quot;Location of exception throw &quot;
2942                         &quot;(or first non-native location after throw if thrown from a native method)&quot;)
2943                         (tagged-object exception &quot;Thrown exception&quot;)
2944                         (location catchLocation
2945                             &quot;Location of catch, or 0 if not caught. An exception &quot;
2946                             &quot;is considered to be caught if, at the point of the throw, the &quot;
2947                             &quot;current location is dynamically enclosed in a try statement that &quot;
2948                             &quot;handles the exception. (See the JVM specification for details). &quot;
2949                             &quot;If there is such a try statement, the catch location is the &quot;
2950                             &quot;first location in the appropriate catch clause. &quot;
2951                             &quot;&lt;p&gt;&quot;
2952                             &quot;If there are native methods in the call stack at the time of the &quot;
2953                             &quot;exception, there are important restrictions to note about the &quot;
2954                             &quot;returned catch location. In such cases, &quot;
2955                             &quot;it is not possible to predict whether an exception will be handled &quot;
2956                             &quot;by some native method on the call stack. &quot;
2957                             &quot;Thus, it is possible that exceptions considered uncaught &quot;
2958                             &quot;here will, in fact, be handled by a native method and not cause &quot;
2959                             &quot;termination of the target VM. Furthermore, it cannot be assumed that the &quot;
2960                             &quot;catch location returned here will ever be reached by the throwing &quot;
2961                             &quot;thread. If there is &quot;
2962                             &quot;a native frame between the current location and the catch location, &quot;
2963                             &quot;the exception might be handled and cleared in that native method &quot;
2964                             &quot;instead. &quot;
2965                             &quot;&lt;p&gt;&quot;
2966                             &quot;Note that compilers can generate try-catch blocks in some cases &quot;
2967                             &quot;where they are not explicit in the source code; for example, &quot;
2968                             &quot;the code generated for &lt;code&gt;synchronized&lt;/code&gt; and &quot;
2969                             &quot;&lt;code&gt;finally&lt;/code&gt; blocks can contain implicit try-catch blocks. &quot;
2970                             &quot;If such an implicitly generated try-catch is &quot;
2971                             &quot;present on the call stack at the time of the throw, the exception &quot;
2972                             &quot;will be considered caught even though it appears to be uncaught from &quot;
2973                             &quot;examination of the source code. &quot;
2974                         )
2975                     )
2976                     (Alt ThreadStart=JDWP.EventKind.THREAD_START
2977                         &quot;Notification of a new running thread in the target VM. &quot;
2978                         &quot;The new thread can be the result of a call to &quot;
2979                         &quot;&lt;code&gt;java.lang.Thread.start&lt;/code&gt; or the result of &quot;
2980                         &quot;attaching a new thread to the VM though JNI. The &quot;
2981                         &quot;notification is generated by the new thread some time before &quot;
2982                         &quot;its execution starts. &quot;
2983                         &quot;Because of this timing, it is possible to receive other events &quot;
2984                         &quot;for the thread before this event is received. (Notably, &quot;
2985                         &quot;Method Entry Events and Method Exit Events might occur &quot;
2986                         &quot;during thread initialization. &quot;
2987                         &quot;It is also possible for the &quot;
2988                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_AllThreads\&quot;&gt;VirtualMachine AllThreads&lt;/a&gt; &quot;
2989                         &quot;command to return &quot;
2990                         &quot;a thread before its thread start event is received. &quot;
2991                         &quot;&lt;p&gt;&quot;
2992                         &quot;Note that this event gives no information &quot;
2993                         &quot;about the creation of the thread object which may have happened &quot;
2994                         &quot;much earlier, depending on the VM being debugged. &quot;
2995 
2996                         (int requestID &quot;Request that generated event&quot;)
2997                         (threadObject thread &quot;Started thread&quot;)
2998                     )
2999                     (Alt ThreadDeath=JDWP.EventKind.THREAD_DEATH
3000                         &quot;Notification of a completed thread in the target VM. The &quot;
3001                         &quot;notification is generated by the dying thread before it terminates. &quot;
3002                         &quot;Because of this timing, it is possible &quot;
3003                         &quot;for {@link VirtualMachine#allThreads} to return this thread &quot;
3004                         &quot;after this event is received. &quot;
3005                         &quot;&lt;p&gt;&quot;
3006                         &quot;Note that this event gives no information &quot;
3007                         &quot;about the lifetime of the thread object. It may or may not be collected &quot;
3008                         &quot;soon depending on what references exist in the target VM. &quot;
3009 
3010                         (int requestID &quot;Request that generated event&quot;)
3011                         (threadObject thread &quot;Ending thread&quot;)
3012                     )
3013                     (Alt ClassPrepare=JDWP.EventKind.CLASS_PREPARE
3014                         &quot;Notification of a class prepare in the target VM. See the JVM &quot;
3015                         &quot;specification for a definition of class preparation. Class prepare &quot;
3016                         &quot;events are not generated for primtiive classes (for example, &quot;
3017                         &quot;java.lang.Integer.TYPE). &quot;
3018 
3019                         (int requestID &quot;Request that generated event&quot;)
3020                         (threadObject thread &quot;Preparing thread. &quot;
3021                              &quot;In rare cases, this event may occur in a debugger system &quot;
3022                              &quot;thread within the target VM. Debugger threads take precautions &quot;
3023                              &quot;to prevent these events, but they cannot be avoided under some &quot;
3024                              &quot;conditions, especially for some subclasses of &quot;
3025                              &quot;java.lang.Error. &quot;
3026                              &quot;If the event was generated by a debugger system thread, the &quot;
3027                              &quot;value returned by this method is null, and if the requested  &quot;
3028                              &quot;&lt;a href=\&quot;#JDWP_SuspendPolicy\&quot;&gt;suspend policy&lt;/a&gt; &quot;
3029                              &quot;for the event was EVENT_THREAD &quot;
3030                              &quot;all threads will be suspended instead, and the &quot;
3031                              &quot;composite event&#39;s suspend policy will reflect this change. &quot;
3032                              &quot;&lt;p&gt;&quot;
3033                              &quot;Note that the discussion above does not apply to system threads &quot;
3034                              &quot;created by the target VM during its normal (non-debug) operation. &quot;
3035                         )
3036                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3037                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3038                         (referenceTypeID typeID &quot;Type being prepared&quot;)
3039                         (string signature &quot;Type signature&quot;)
3040                         (int status &quot;Status of type. &quot;
3041                          &quot;See &lt;a href=\&quot;#JDWP_ClassStatus\&quot;&gt;JDWP.ClassStatus&lt;/a&gt;&quot;)
3042                     )
3043                     (Alt ClassUnload=JDWP.EventKind.CLASS_UNLOAD
3044                          &quot;Notification of a class unload in the target VM. &quot;
3045                          &quot;&lt;p&gt;&quot;
3046                          &quot;There are severe constraints on the debugger back-end during &quot;
3047                          &quot;garbage collection, so unload information is greatly limited. &quot;
3048 
3049                         (int requestID &quot;Request that generated event&quot;)
3050                         (string signature &quot;Type signature&quot;)
3051                     )
3052                     (Alt FieldAccess=JDWP.EventKind.FIELD_ACCESS
3053                         &quot;Notification of a field access in the target VM. &quot;
3054                         &quot;Field modifications &quot;
3055                         &quot;are not considered field accesses. &quot;
3056                         &quot;Requires canWatchFieldAccess capability - see &quot;
3057                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3058 
3059                       (int requestID &quot;Request that generated event&quot;)
3060                         (threadObject thread &quot;Accessing thread&quot;)
3061                         (location location &quot;Location of access&quot;)
3062                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3063                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3064                         (referenceTypeID typeID &quot;Type of field&quot;)
3065                         (field fieldID &quot;Field being accessed&quot;)
3066                         (tagged-object object
3067                                 &quot;Object being accessed (null=0 for statics&quot;)
3068                     )
3069                     (Alt FieldModification=JDWP.EventKind.FIELD_MODIFICATION
3070                         &quot;Notification of a field modification in the target VM. &quot;
3071                         &quot;Requires canWatchFieldModification capability - see &quot;
3072                         &quot;&lt;a href=\&quot;#JDWP_VirtualMachine_CapabilitiesNew\&quot;&gt;CapabilitiesNew&lt;/a&gt;.&quot;
3073 
3074                         (int requestID &quot;Request that generated event&quot;)
3075                         (threadObject thread &quot;Modifying thread&quot;)
3076                         (location location &quot;Location of modify&quot;)
3077                         (byte refTypeTag  &quot;Kind of reference type. &quot;
3078                            &quot;See &lt;a href=\&quot;#JDWP_TypeTag\&quot;&gt;JDWP.TypeTag&lt;/a&gt;&quot;)
3079                         (referenceTypeID typeID &quot;Type of field&quot;)
3080                         (field fieldID &quot;Field being modified&quot;)
3081                         (tagged-object object
3082                                 &quot;Object being modified (null=0 for statics&quot;)
3083                         (value valueToBe &quot;Value to be assigned&quot;)
3084                     )
3085                     (Alt VMDeath=JDWP.EventKind.VM_DEATH
3086                         (int requestID
3087                                 &quot;Request that generated event&quot;)
3088                     )
3089                 )
3090             )
3091         )
3092     )
3093 )
3094 (ConstantSet Error
3095     (Constant NONE                   =0   &quot;No error has occurred.&quot;)
3096     (Constant INVALID_THREAD         =10  &quot;Passed thread is null, is not a valid thread or has exited.&quot;)
3097     (Constant INVALID_THREAD_GROUP   =11  &quot;Thread group invalid.&quot;)
3098     (Constant INVALID_PRIORITY       =12  &quot;Invalid priority.&quot;)
3099     (Constant THREAD_NOT_SUSPENDED   =13  &quot;If the specified thread has not been &quot;
3100                                           &quot;suspended by an event.&quot;)
3101     (Constant THREAD_SUSPENDED       =14  &quot;Thread already suspended.&quot;)
3102     (Constant THREAD_NOT_ALIVE       =15  &quot;Thread has not been started or is now dead.&quot;)
3103 
3104     (Constant INVALID_OBJECT         =20  &quot;If this reference type has been unloaded &quot;
3105                                           &quot;and garbage collected.&quot;)
3106     (Constant INVALID_CLASS          =21  &quot;Invalid class.&quot;)
3107     (Constant CLASS_NOT_PREPARED     =22  &quot;Class has been loaded but not yet prepared.&quot;)
3108     (Constant INVALID_METHODID       =23  &quot;Invalid method.&quot;)
3109     (Constant INVALID_LOCATION       =24  &quot;Invalid location.&quot;)
3110     (Constant INVALID_FIELDID        =25  &quot;Invalid field.&quot;)
3111     (Constant INVALID_FRAMEID        =30  &quot;Invalid jframeID.&quot;)
3112     (Constant NO_MORE_FRAMES         =31  &quot;There are no more Java or JNI frames on the &quot;
3113                                           &quot;call stack.&quot;)
3114     (Constant OPAQUE_FRAME           =32  &quot;Information about the frame is not available.&quot;)
3115     (Constant NOT_CURRENT_FRAME      =33  &quot;Operation can only be performed on current frame.&quot;)
3116     (Constant TYPE_MISMATCH          =34  &quot;The variable is not an appropriate type for &quot;
3117                                           &quot;the function used.&quot;)
3118     (Constant INVALID_SLOT           =35  &quot;Invalid slot.&quot;)
3119     (Constant DUPLICATE              =40  &quot;Item already set.&quot;)
3120     (Constant NOT_FOUND              =41  &quot;Desired element not found.&quot;)
3121     (Constant INVALID_MODULE         =42  &quot;Invalid module.&quot;)
3122     (Constant INVALID_MONITOR        =50  &quot;Invalid monitor.&quot;)
3123     (Constant NOT_MONITOR_OWNER      =51  &quot;This thread doesn&#39;t own the monitor.&quot;)
3124     (Constant INTERRUPT              =52  &quot;The call has been interrupted before completion.&quot;)
3125     (Constant INVALID_CLASS_FORMAT   =60  &quot;The virtual machine attempted to read a class &quot;
3126                                           &quot;file and determined that the file is malformed &quot;
3127                                           &quot;or otherwise cannot be interpreted as a class file.&quot;)
3128     (Constant CIRCULAR_CLASS_DEFINITION
3129                                      =61  &quot;A circularity has been detected while &quot;
3130                                           &quot;initializing a class.&quot;)
3131     (Constant FAILS_VERIFICATION     =62  &quot;The verifier detected that a class file, &quot;
3132                                           &quot;though well formed, contained some sort of &quot;
3133                                           &quot;internal inconsistency or security problem.&quot;)
3134     (Constant ADD_METHOD_NOT_IMPLEMENTED
3135                                      =63  &quot;Adding methods has not been implemented.&quot;)
3136     (Constant SCHEMA_CHANGE_NOT_IMPLEMENTED
3137                                      =64  &quot;Schema change has not been implemented.&quot;)
3138     (Constant INVALID_TYPESTATE      =65  &quot;The state of the thread has been modified, &quot;
3139                                           &quot;and is now inconsistent.&quot;)
3140     (Constant HIERARCHY_CHANGE_NOT_IMPLEMENTED
3141                                      =66  &quot;A direct superclass is different for the new class &quot;
3142                                           &quot;version, or the set of directly implemented &quot;
3143                                           &quot;interfaces is different &quot;
3144                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3145     (Constant DELETE_METHOD_NOT_IMPLEMENTED
3146                                      =67  &quot;The new class version does not declare a method &quot;
3147                                           &quot;declared in the old class version &quot;
3148                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3149     (Constant UNSUPPORTED_VERSION    =68  &quot;A class file has a version number not supported &quot;
3150                                           &quot;by this VM.&quot;)
3151     (Constant NAMES_DONT_MATCH       =69  &quot;The class name defined in the new class file is &quot;
3152                                           &quot;different from the name in the old class object.&quot;)
3153     (Constant CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3154                                      =70  &quot;The new class version has different modifiers and &quot;
3155                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3156     (Constant METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED
3157                                      =71  &quot;A method in the new class version has &quot;
3158                                           &quot;different modifiers &quot;
3159                                           &quot;than its counterpart in the old class version and &quot;
3160                                           &quot;canUnrestrictedlyRedefineClasses is false.&quot;)
3161     (Constant CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED
3162                                      =72  &quot;The new class version has a different NestHost, &quot;
3163                                           &quot;NestMembers, PermittedSubclasses, or Record class attribute &quot;
3164                                           &quot;and canUnrestrictedlyRedefineClasses is false.&quot;)
3165     (Constant NOT_IMPLEMENTED        =99  &quot;The functionality is not implemented in &quot;
3166                                           &quot;this virtual machine.&quot;)
3167     (Constant NULL_POINTER           =100 &quot;Invalid pointer.&quot;)
3168     (Constant ABSENT_INFORMATION     =101 &quot;Desired information is not available.&quot;)
3169     (Constant INVALID_EVENT_TYPE     =102 &quot;The specified event type id is not recognized.&quot;)
3170     (Constant ILLEGAL_ARGUMENT       =103 &quot;Illegal argument.&quot;)
3171     (Constant OUT_OF_MEMORY          =110 &quot;The function needed to allocate memory and &quot;
3172                                           &quot;no more memory was available for allocation.&quot;)
3173     (Constant ACCESS_DENIED          =111 &quot;Debugging has not been enabled in this &quot;
3174                                           &quot;virtual machine. JVMTI cannot be used.&quot;)
3175     (Constant VM_DEAD                =112 &quot;The virtual machine is not running.&quot;)
3176     (Constant INTERNAL               =113 &quot;An unexpected internal error has occurred.&quot;)
3177     (Constant UNATTACHED_THREAD      =115 &quot;The thread being used to call this function &quot;
3178                                           &quot;is not attached to the virtual machine. &quot;
3179                                           &quot;Calls must be made from attached threads.&quot;)
3180     (Constant INVALID_TAG            =500 &quot;object type id or class tag.&quot;)
3181     (Constant ALREADY_INVOKING       =502 &quot;Previous invoke not complete.&quot;)
3182     (Constant INVALID_INDEX          =503 &quot;Index is invalid.&quot;)
3183     (Constant INVALID_LENGTH         =504 &quot;The length is invalid.&quot;)
3184     (Constant INVALID_STRING         =506 &quot;The string is invalid.&quot;)
3185     (Constant INVALID_CLASS_LOADER   =507 &quot;The class loader is invalid.&quot;)
3186     (Constant INVALID_ARRAY          =508 &quot;The array is invalid.&quot;)
3187     (Constant TRANSPORT_LOAD         =509 &quot;Unable to load the transport.&quot;)
3188     (Constant TRANSPORT_INIT         =510 &quot;Unable to initialize the transport.&quot;)
3189     (Constant NATIVE_METHOD          =511  )
3190     (Constant INVALID_COUNT          =512 &quot;The count is invalid.&quot;)
3191 )
3192 (ConstantSet EventKind
3193     (Constant SINGLE_STEP            =1   )
3194     (Constant BREAKPOINT             =2   )
3195     (Constant FRAME_POP              =3   )
3196     (Constant EXCEPTION              =4   )
3197     (Constant USER_DEFINED           =5   )
3198     (Constant THREAD_START           =6   )
3199     (Constant THREAD_DEATH           =7   )
3200     (Constant THREAD_END             =7   &quot;obsolete - was used in jvmdi&quot;)
3201     (Constant CLASS_PREPARE          =8   )
3202     (Constant CLASS_UNLOAD           =9   )
3203     (Constant CLASS_LOAD             =10  )
3204     (Constant FIELD_ACCESS           =20  )
3205     (Constant FIELD_MODIFICATION     =21  )
3206     (Constant EXCEPTION_CATCH        =30  )
3207     (Constant METHOD_ENTRY           =40  )
3208     (Constant METHOD_EXIT            =41  )
3209     (Constant METHOD_EXIT_WITH_RETURN_VALUE =42  )
3210     (Constant MONITOR_CONTENDED_ENTER          =43  )
3211     (Constant MONITOR_CONTENDED_ENTERED        =44 )
3212     (Constant MONITOR_WAIT           =45 )
3213     (Constant MONITOR_WAITED         =46 )
3214     (Constant VM_START               =90  )
3215     (Constant VM_INIT                =90  &quot;obsolete - was used in jvmdi&quot;)
3216     (Constant VM_DEATH               =99  )
3217     (Constant VM_DISCONNECTED        =100 &quot;Never sent across JDWP&quot;)
3218 )
3219 
3220 (ConstantSet ThreadStatus
3221     (Constant ZOMBIE                 =0  )
3222     (Constant RUNNING                =1  )
3223     (Constant SLEEPING               =2  )
3224     (Constant MONITOR                =3  )
3225     (Constant WAIT                   =4  )
3226 )
3227 
3228 (ConstantSet SuspendStatus
3229     (Constant SUSPEND_STATUS_SUSPENDED = 0x1 )
3230 )
3231 (ConstantSet ClassStatus
3232     (Constant VERIFIED               =1  )
3233     (Constant PREPARED               =2  )
3234     (Constant INITIALIZED            =4  )
3235     (Constant ERROR                  =8  )
3236 )
3237 (ConstantSet TypeTag
3238     (Constant CLASS=1 &quot;ReferenceType is a class. &quot;)
3239     (Constant INTERFACE=2 &quot;ReferenceType is an interface. &quot;)
3240     (Constant ARRAY=3 &quot;ReferenceType is an array. &quot;)
3241 )
3242 (ConstantSet Tag
3243     (Constant ARRAY = &#39;[&#39; &quot;&#39;[&#39; - an array object (objectID size). &quot;)
3244     (Constant BYTE = &#39;B&#39; &quot;&#39;B&#39; - a byte value (1 byte).&quot;)
3245     (Constant CHAR = &#39;C&#39; &quot;&#39;C&#39; - a character value (2 bytes).&quot;)
3246     (Constant OBJECT = &#39;L&#39; &quot;&#39;L&#39; - an object (objectID size).&quot;)
<a name="1" id="anc1"></a>
3247     (Constant FLOAT = &#39;F&#39; &quot;&#39;F&#39; - a float value (4 bytes).&quot;)
3248     (Constant DOUBLE = &#39;D&#39; &quot;&#39;D&#39; - a double value (8 bytes).&quot;)
3249     (Constant INT = &#39;I&#39; &quot;&#39;I&#39; - an int value (4 bytes).&quot;)
3250     (Constant LONG = &#39;J&#39; &quot;&#39;J&#39; - a long value (8 bytes).&quot;)
3251     (Constant SHORT = &#39;S&#39; &quot;&#39;S&#39; - a short value (2 bytes).&quot;)
3252     (Constant VOID = &#39;V&#39; &quot;&#39;V&#39; - a void value (no bytes).&quot;)
3253     (Constant BOOLEAN = &#39;Z&#39; &quot;&#39;Z&#39; - a boolean value (1 byte).&quot;)
3254     (Constant STRING = &#39;s&#39; &quot;&#39;s&#39; - a String object (objectID size). &quot;)
3255     (Constant THREAD = &#39;t&#39; &quot;&#39;t&#39; - a Thread object (objectID size). &quot;)
3256     (Constant THREAD_GROUP = &#39;g&#39;
3257         &quot;&#39;g&#39; - a ThreadGroup object (objectID size). &quot;)
3258     (Constant CLASS_LOADER = &#39;l&#39;
3259         &quot;&#39;l&#39; - a ClassLoader object (objectID size). &quot;)
3260     (Constant CLASS_OBJECT = &#39;c&#39;
3261         &quot;&#39;c&#39; - a class object object (objectID size). &quot;)
3262 )
3263 
3264 (ConstantSet StepDepth
3265     (Constant INTO = 0
3266         &quot;Step into any method calls that occur before the end of the step. &quot;)
3267     (Constant OVER = 1
3268         &quot;Step over any method calls that occur before the end of the step. &quot;)
3269     (Constant OUT = 2
3270         &quot;Step out of the current method. &quot;)
3271 )
3272 
3273 (ConstantSet StepSize
3274     (Constant MIN = 0
3275         &quot;Step by the minimum possible amount (often a bytecode instruction). &quot;)
3276     (Constant LINE = 1
3277         &quot;Step to the next source line unless there is no line number information in which case a MIN step is done instead.&quot;)
3278 )
3279 
3280 (ConstantSet SuspendPolicy
3281     (Constant NONE = 0
3282         &quot;Suspend no threads when this event is encountered. &quot;)
3283     (Constant EVENT_THREAD = 1
3284         &quot;Suspend the event thread when this event is encountered. &quot;)
3285     (Constant ALL = 2
3286         &quot;Suspend all threads when this event is encountered. &quot;)
3287 )
3288 
3289 (ConstantSet InvokeOptions
3290     &quot;The invoke options are a combination of zero or more of the following bit flags:&quot;
3291     (Constant INVOKE_SINGLE_THREADED = 0x01
3292         &quot;otherwise, all threads started. &quot;)
3293     (Constant INVOKE_NONVIRTUAL = 0x02
3294         &quot;otherwise, normal virtual invoke (instance methods only)&quot;)
3295 )
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
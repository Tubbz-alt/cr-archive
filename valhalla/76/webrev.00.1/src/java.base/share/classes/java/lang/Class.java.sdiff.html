<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
<span class="line-modified"> 200     private static final int ANNOTATION= 0x00002000;</span>
<span class="line-modified"> 201     private static final int ENUM      = 0x00004000;</span>
<span class="line-modified"> 202     private static final int SYNTHETIC = 0x00001000;</span>

 203 
 204     private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];
 205 
 206     private static native void registerNatives();
 207     static {
 208         registerNatives();
 209     }
 210 
 211     /*
 212      * Private constructor. Only the Java Virtual Machine creates Class objects.
 213      * This constructor is not used and prevents the default constructor being
 214      * generated.
 215      */
 216     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 217         // Initialize final field for classLoader.  The initialization value of non-null
 218         // prevents future JIT optimizations from assuming this final field is null.
 219         classLoader = loader;
 220         componentType = arrayComponentType;
 221     }
 222 
 223     /**
 224      * Converts the object to a string. The string representation is the
 225      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 226      * name of the class in the format returned by {@code getName}.
 227      * If this {@code Class} object represents a primitive type,
 228      * this method returns the name of the primitive type.  If
 229      * this {@code Class} object represents void this method returns
 230      * &quot;void&quot;. If this {@code Class} object represents an array type,
 231      * this method returns &quot;class &quot; followed by {@code getName}.
 232      *
 233      * @return a string representation of this {@code Class} object.
 234      */
 235     public String toString() {
<span class="line-modified"> 236         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-modified"> 237             + getName();</span>

 238     }
 239 
 240     /**
 241      * Returns a string describing this {@code Class}, including
 242      * information about modifiers and type parameters.
 243      *
 244      * The string is formatted as a list of type modifiers, if any,
 245      * followed by the kind of type (empty string for primitive types
 246      * and {@code class}, {@code enum}, {@code interface},
 247      * {@code @interface}, or {@code record} as appropriate), followed
 248      * by the type&#39;s name, followed by an angle-bracketed
 249      * comma-separated list of the type&#39;s type parameters, if any,
 250      * including informative bounds on the type parameters, if any.
 251      *
 252      * A space is used to separate modifiers from one another and to
 253      * separate any modifiers from the kind of type. The modifiers
 254      * occur in canonical order. If there are no type parameters, the
 255      * type parameter list is elided.
 256      *
 257      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 279             Class&lt;?&gt; component = this;
 280             int arrayDepth = 0;
 281 
 282             if (isArray()) {
 283                 do {
 284                     arrayDepth++;
 285                     component = component.getComponentType();
 286                 } while (component.isArray());
 287                 sb.append(component.getName());
 288             } else {
 289                 // Class modifiers are a superset of interface modifiers
 290                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 291                 if (modifiers != 0) {
 292                     sb.append(Modifier.toString(modifiers));
 293                     sb.append(&#39; &#39;);
 294                 }
 295 
 296                 if (isAnnotation()) {
 297                     sb.append(&#39;@&#39;);
 298                 }




 299                 if (isInterface()) { // Note: all annotation types are interfaces
 300                     sb.append(&quot;interface&quot;);
 301                 } else {
 302                     if (isEnum())
 303                         sb.append(&quot;enum&quot;);
 304                     else if (isRecord())
 305                         sb.append(&quot;record&quot;);
 306                     else
 307                         sb.append(&quot;class&quot;);
 308                 }
 309                 sb.append(&#39; &#39;);
 310                 sb.append(getName());
 311             }
 312 
 313             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 314             if (typeparms.length &gt; 0) {
 315                 sb.append(Arrays.stream(typeparms)
 316                           .map(Class::typeVarBounds)
 317                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 318             }
</pre>
<hr />
<pre>
 453     {
 454         Class&lt;?&gt; caller = null;
 455         SecurityManager sm = System.getSecurityManager();
 456         if (sm != null) {
 457             // Reflective call to get caller class is only needed if a security manager
 458             // is present.  Avoid the overhead of making this call otherwise.
 459             caller = Reflection.getCallerClass();
 460             if (loader == null) {
 461                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 462                 if (ccl != null) {
 463                     sm.checkPermission(
 464                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 465                 }
 466             }
 467         }
 468         return forName0(name, initialize, loader, caller);
 469     }
 470 
 471     /** Called after security check for system loader access checks have been made. */
 472     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 473                                             ClassLoader loader,</span>
<span class="line-modified"> 474                                             Class&lt;?&gt; caller)</span>
 475         throws ClassNotFoundException;
 476 
 477 
 478     /**
 479      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 480      * binary name&lt;/a&gt; in the given module.
 481      *
 482      * &lt;p&gt; This method attempts to locate and load the class or interface.
 483      * It does not link the class, and does not run the class initializer.
 484      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 485      *
 486      * &lt;p&gt; If the class loader of the given module defines other modules and
 487      * the given name is a class defined in a different module, this method
 488      * returns {@code null} after the class is loaded. &lt;/p&gt;
 489      *
 490      * &lt;p&gt; This method does not check whether the requested class is
 491      * accessible to its caller. &lt;/p&gt;
 492      *
 493      * @apiNote
 494      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 532         if (sm != null) {
 533             Class&lt;?&gt; caller = Reflection.getCallerClass();
 534             if (caller != null &amp;&amp; caller.getModule() != module) {
 535                 // if caller is null, Class.forName is the last java frame on the stack.
 536                 // java.base has all permissions
 537                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 538             }
 539             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 540             cl = AccessController.doPrivileged(pa);
 541         } else {
 542             cl = module.getClassLoader();
 543         }
 544 
 545         if (cl != null) {
 546             return cl.loadClass(module, name);
 547         } else {
 548             return BootLoader.loadClass(module, name);
 549         }
 550     }
 551 















































 552     /**
 553      * Creates a new instance of the class represented by this {@code Class}
 554      * object.  The class is instantiated as if by a {@code new}
 555      * expression with an empty argument list.  The class is initialized if it
 556      * has not already been initialized.
 557      *
 558      * @deprecated This method propagates any exception thrown by the
 559      * nullary constructor, including a checked exception.  Use of
 560      * this method effectively bypasses the compile-time exception
 561      * checking that would otherwise be performed by the compiler.
 562      * The {@link
 563      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 564      * Constructor.newInstance} method avoids this problem by wrapping
 565      * any exception thrown by the constructor in a (checked) {@link
 566      * java.lang.reflect.InvocationTargetException}.
 567      *
 568      * &lt;p&gt;The call
 569      *
 570      * &lt;pre&gt;{@code
 571      * clazz.newInstance()
</pre>
<hr />
<pre>
 811      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 812      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 813      * &lt;/ul&gt;
 814      *
 815      * &lt;p&gt; If this {@code Class} object represents an array class, then
 816      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 817      * representing the depth of the array nesting, followed by the element
 818      * type as encoded using the following table:
 819      *
 820      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 821      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 822      * &lt;thead&gt;
 823      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 824      * &lt;/thead&gt;
 825      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 826      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 827      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 828      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 829      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 830      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}


 831      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 832      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 833      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 834      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 835      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 836      * &lt;/tbody&gt;
 837      * &lt;/table&gt;&lt;/blockquote&gt;
 838      *
 839      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 840      * then the result is a string with the same spelling as the Java language
 841      * keyword which corresponds to the primitive type or {@code void}.
 842      *
 843      * &lt;p&gt; Examples:
 844      * &lt;blockquote&gt;&lt;pre&gt;
 845      * String.class.getName()
 846      *     returns &quot;java.lang.String&quot;
 847      * byte.class.getName()
 848      *     returns &quot;byte&quot;


 849      * (new Object[3]).getClass().getName()
 850      *     returns &quot;[Ljava.lang.Object;&quot;




 851      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 852      *     returns &quot;[[[[[[[I&quot;
 853      * &lt;/pre&gt;&lt;/blockquote&gt;
 854      *
 855      * @return  the name of the class, interface, or other entity
 856      *          represented by this {@code Class} object.
 857      * @jls 13.1 The Form of a Binary
 858      */
 859     public String getName() {
 860         String name = this.name;
 861         return name != null ? name : initClassName();
 862     }
 863 
 864     // Cache the name to reduce the number of calls into the VM.
 865     // This field would be set by VM itself during initClassName call.
 866     private transient String name;
 867     private native String initClassName();
 868 
 869     /**
 870      * Returns the class loader for the class.  Some implementations may use
</pre>
<hr />
<pre>
1261      * modifiers are the same as those of its component type.  If this
1262      * {@code Class} object represents a primitive type or void, its
1263      * {@code public} modifier is always {@code true}, and its
1264      * {@code protected} and {@code private} modifiers are always
1265      * {@code false}. If this {@code Class} object represents an array class, a
1266      * primitive type or void, then its {@code final} modifier is always
1267      * {@code true} and its interface modifier is always
1268      * {@code false}. The values of its other modifiers are not determined
1269      * by this specification.
1270      *
1271      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1272      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1273      *
1274      * @return the {@code int} representing the modifiers for this class
1275      * @see     java.lang.reflect.Modifier
1276      * @since 1.1
1277      */
1278     @HotSpotIntrinsicCandidate
1279     public native int getModifiers();
1280 
<span class="line-removed">1281 </span>
1282     /**
1283      * Gets the signers of this class.
1284      *
1285      * @return  the signers of this class, or null if there are no signers.  In
1286      *          particular, this method returns null if this {@code Class} object represents
1287      *          a primitive type or void.
1288      * @since   1.1
1289      */
1290     public native Object[] getSigners();
1291 
<span class="line-removed">1292 </span>
1293     /**
1294      * Set the signers of this class.
1295      */
1296     native void setSigners(Object[] signers);
1297 
1298 
1299     /**
1300      * If this {@code Class} object represents a local or anonymous
1301      * class within a method, returns a {@link
1302      * java.lang.reflect.Method Method} object representing the
1303      * immediately enclosing method of the underlying class. Returns
1304      * {@code null} otherwise.
1305      *
1306      * In particular, this method returns {@code null} if the underlying
1307      * class is a local or anonymous class immediately enclosed by a type
1308      * declaration, instance initializer or static initializer.
1309      *
1310      * @return the immediately enclosing method of the underlying class, if
1311      *     that class is a local or anonymous class; otherwise {@code null}.
1312      *
</pre>
<hr />
<pre>
1653             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1654         }
1655         return simpleName;
1656     }
1657 
1658     /**
1659      * Return an informative string for the name of this type.
1660      *
1661      * @return an informative string for the name of this type
1662      * @since 1.8
1663      */
1664     public String getTypeName() {
1665         if (isArray()) {
1666             try {
1667                 Class&lt;?&gt; cl = this;
1668                 int dimensions = 0;
1669                 do {
1670                     dimensions++;
1671                     cl = cl.getComponentType();
1672                 } while (cl.isArray());
<span class="line-modified">1673                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);</span>
1674             } catch (Throwable e) { /*FALLTHRU*/ }
1675         }
1676         return getName();
1677     }
1678 
1679     /**
1680      * Returns the canonical name of the underlying class as
1681      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1682      * Returns {@code null} if the underlying class does not have a canonical
1683      * name. Classes without canonical names include:
1684      * &lt;ul&gt;
1685      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1686      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1687      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1688      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1689      * &lt;/ul&gt;
1690      *
1691      * @return the canonical name of the underlying class if it exists, and
1692      * {@code null} otherwise.
1693      * @since 1.5
</pre>
<hr />
<pre>
3788                 throw new IllegalArgumentException(
3789                     getName() + &quot; is not an enum type&quot;);
3790             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3791             for (T constant : universe) {
3792                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3793             }
3794             enumConstantDirectory = directory;
3795         }
3796         return directory;
3797     }
3798     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3799 
3800     /**
3801      * Casts an object to the class or interface represented
3802      * by this {@code Class} object.
3803      *
3804      * @param obj the object to be cast
3805      * @return the object after casting, or null if obj is null
3806      *
3807      * @throws ClassCastException if the object is not
<span class="line-modified">3808      * null and is not assignable to the type T.</span>


3809      *
3810      * @since 1.5
3811      */
3812     @SuppressWarnings(&quot;unchecked&quot;)
3813     @HotSpotIntrinsicCandidate
3814     public T cast(Object obj) {



3815         if (obj != null &amp;&amp; !isInstance(obj))
3816             throw new ClassCastException(cannotCastMsg(obj));
3817         return (T) obj;
3818     }
3819 
3820     private String cannotCastMsg(Object obj) {
3821         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3822     }
3823 
3824     /**
3825      * Casts this {@code Class} object to represent a subclass of the class
3826      * represented by the specified class object.  Checks that the cast
3827      * is valid, and throws a {@code ClassCastException} if it is not.  If
3828      * this method succeeds, it always returns a reference to this {@code Class} object.
3829      *
3830      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3831      * a {@code Class} object to pass it to an API that restricts the
3832      * {@code Class} objects that it is willing to accept.  A cast would
3833      * generate a compile-time warning, as the correctness of the cast
3834      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4090      *
4091      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4092      * value is an array containing objects representing the uses of interface
4093      * types to specify interfaces directly extended by the interface. The
4094      * order of the objects in the array corresponds to the order of the
4095      * interface types used in the &#39;extends&#39; clause of the declaration of this
4096      * {@code Class} object.
4097      *
4098      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4099      * declaration does not explicitly indicate any annotated superinterfaces,
4100      * the return value is an array of length 0.
4101      *
4102      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4103      * class, an array type, a primitive type, or void, the return value is an
4104      * array of length 0.
4105      *
4106      * @return an array representing the superinterfaces
4107      * @since 1.8
4108      */
4109     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4110          return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4111     }
4112 
4113     private native Class&lt;?&gt; getNestHost0();
4114 
4115     /**
4116      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4117      * or interface represented by this {@code Class} object belongs.
4118      * Every class and interface belongs to exactly one nest.
4119      *
4120      * If the nest host of this class or interface has previously
4121      * been determined, then this method returns the nest host.
4122      * If the nest host of this class or interface has
4123      * not previously been determined, then this method determines the nest
4124      * host using the algorithm of JVMS 5.4.4, and returns it.
4125      *
4126      * Often, a class or interface belongs to a nest consisting only of itself,
4127      * in which case this method returns {@code this} to indicate that the class
4128      * or interface is the nest host.
4129      *
4130      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
</pre>
<hr />
<pre>
4303      * {@code void}, then the result is a field descriptor string which
4304      * is a one-letter code corresponding to a primitive type or {@code void}
4305      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4306      *
4307      * @apiNote
4308      * This is not a strict inverse of {@link #forName};
4309      * distinct classes which share a common name but have different class loaders
4310      * will have identical descriptor strings.
4311      *
4312      * @return the descriptor string for this {@code Class} object
4313      * @jvms 4.3.2 Field Descriptors
4314      * @since 12
4315      */
4316     @Override
4317     public String descriptorString() {
4318         if (isPrimitive())
4319             return Wrapper.forPrimitiveType(this).basicTypeString();
4320 
4321         if (isArray()) {
4322             return &quot;[&quot; + componentType.descriptorString();
<span class="line-modified">4323         } else if (isHidden()) {</span>


4324             String name = getName();
4325             int index = name.indexOf(&#39;/&#39;);
<span class="line-modified">4326             return &quot;L&quot; + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
4327                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4328         } else {
<span class="line-modified">4329             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4330         }
4331     }
4332 
4333     /**
4334      * Returns the component type of this {@code Class}, if it describes
4335      * an array type, or {@code null} otherwise.
4336      *
4337      * @implSpec
4338      * Equivalent to {@link Class#getComponentType()}.
4339      *
4340      * @return a {@code Class} describing the component type, or {@code null}
4341      * if this {@code Class} does not describe an array type
4342      * @since 12
4343      */
4344     @Override
4345     public Class&lt;?&gt; componentType() {
4346         return isArray() ? componentType : null;
4347     }
4348 
4349     /**
</pre>
</td>
<td>
<hr />
<pre>
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
<span class="line-modified"> 200     private static final int ANNOTATION = 0x00002000;</span>
<span class="line-modified"> 201     private static final int ENUM       = 0x00004000;</span>
<span class="line-modified"> 202     private static final int SYNTHETIC  = 0x00001000;</span>
<span class="line-added"> 203     private static final int INLINE     = 0x00000100;</span>
 204 
 205     private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];
 206 
 207     private static native void registerNatives();
 208     static {
 209         registerNatives();
 210     }
 211 
 212     /*
 213      * Private constructor. Only the Java Virtual Machine creates Class objects.
 214      * This constructor is not used and prevents the default constructor being
 215      * generated.
 216      */
 217     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 218         // Initialize final field for classLoader.  The initialization value of non-null
 219         // prevents future JIT optimizations from assuming this final field is null.
 220         classLoader = loader;
 221         componentType = arrayComponentType;
 222     }
 223 
 224     /**
 225      * Converts the object to a string. The string representation is the
 226      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 227      * name of the class in the format returned by {@code getName}.
 228      * If this {@code Class} object represents a primitive type,
 229      * this method returns the name of the primitive type.  If
 230      * this {@code Class} object represents void this method returns
 231      * &quot;void&quot;. If this {@code Class} object represents an array type,
 232      * this method returns &quot;class &quot; followed by {@code getName}.
 233      *
 234      * @return a string representation of this {@code Class} object.
 235      */
 236     public String toString() {
<span class="line-modified"> 237         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)</span>
<span class="line-modified"> 238                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-added"> 239                + getName();</span>
 240     }
 241 
 242     /**
 243      * Returns a string describing this {@code Class}, including
 244      * information about modifiers and type parameters.
 245      *
 246      * The string is formatted as a list of type modifiers, if any,
 247      * followed by the kind of type (empty string for primitive types
 248      * and {@code class}, {@code enum}, {@code interface},
 249      * {@code @interface}, or {@code record} as appropriate), followed
 250      * by the type&#39;s name, followed by an angle-bracketed
 251      * comma-separated list of the type&#39;s type parameters, if any,
 252      * including informative bounds on the type parameters, if any.
 253      *
 254      * A space is used to separate modifiers from one another and to
 255      * separate any modifiers from the kind of type. The modifiers
 256      * occur in canonical order. If there are no type parameters, the
 257      * type parameter list is elided.
 258      *
 259      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 281             Class&lt;?&gt; component = this;
 282             int arrayDepth = 0;
 283 
 284             if (isArray()) {
 285                 do {
 286                     arrayDepth++;
 287                     component = component.getComponentType();
 288                 } while (component.isArray());
 289                 sb.append(component.getName());
 290             } else {
 291                 // Class modifiers are a superset of interface modifiers
 292                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 293                 if (modifiers != 0) {
 294                     sb.append(Modifier.toString(modifiers));
 295                     sb.append(&#39; &#39;);
 296                 }
 297 
 298                 if (isAnnotation()) {
 299                     sb.append(&#39;@&#39;);
 300                 }
<span class="line-added"> 301                 if (isInlineClass()) {</span>
<span class="line-added"> 302                     sb.append(&quot;inline&quot;);</span>
<span class="line-added"> 303                     sb.append(&#39; &#39;);</span>
<span class="line-added"> 304                 }</span>
 305                 if (isInterface()) { // Note: all annotation types are interfaces
 306                     sb.append(&quot;interface&quot;);
 307                 } else {
 308                     if (isEnum())
 309                         sb.append(&quot;enum&quot;);
 310                     else if (isRecord())
 311                         sb.append(&quot;record&quot;);
 312                     else
 313                         sb.append(&quot;class&quot;);
 314                 }
 315                 sb.append(&#39; &#39;);
 316                 sb.append(getName());
 317             }
 318 
 319             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 320             if (typeparms.length &gt; 0) {
 321                 sb.append(Arrays.stream(typeparms)
 322                           .map(Class::typeVarBounds)
 323                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 324             }
</pre>
<hr />
<pre>
 459     {
 460         Class&lt;?&gt; caller = null;
 461         SecurityManager sm = System.getSecurityManager();
 462         if (sm != null) {
 463             // Reflective call to get caller class is only needed if a security manager
 464             // is present.  Avoid the overhead of making this call otherwise.
 465             caller = Reflection.getCallerClass();
 466             if (loader == null) {
 467                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 468                 if (ccl != null) {
 469                     sm.checkPermission(
 470                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 471                 }
 472             }
 473         }
 474         return forName0(name, initialize, loader, caller);
 475     }
 476 
 477     /** Called after security check for system loader access checks have been made. */
 478     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 479                                     ClassLoader loader,</span>
<span class="line-modified"> 480                                     Class&lt;?&gt; caller)</span>
 481         throws ClassNotFoundException;
 482 
 483 
 484     /**
 485      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 486      * binary name&lt;/a&gt; in the given module.
 487      *
 488      * &lt;p&gt; This method attempts to locate and load the class or interface.
 489      * It does not link the class, and does not run the class initializer.
 490      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 491      *
 492      * &lt;p&gt; If the class loader of the given module defines other modules and
 493      * the given name is a class defined in a different module, this method
 494      * returns {@code null} after the class is loaded. &lt;/p&gt;
 495      *
 496      * &lt;p&gt; This method does not check whether the requested class is
 497      * accessible to its caller. &lt;/p&gt;
 498      *
 499      * @apiNote
 500      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 538         if (sm != null) {
 539             Class&lt;?&gt; caller = Reflection.getCallerClass();
 540             if (caller != null &amp;&amp; caller.getModule() != module) {
 541                 // if caller is null, Class.forName is the last java frame on the stack.
 542                 // java.base has all permissions
 543                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 544             }
 545             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 546             cl = AccessController.doPrivileged(pa);
 547         } else {
 548             cl = module.getClassLoader();
 549         }
 550 
 551         if (cl != null) {
 552             return cl.loadClass(module, name);
 553         } else {
 554             return BootLoader.loadClass(module, name);
 555         }
 556     }
 557 
<span class="line-added"> 558     /**</span>
<span class="line-added"> 559      * Returns {@code true} if this class is an inline class.</span>
<span class="line-added"> 560      *</span>
<span class="line-added"> 561      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 562      * @since Valhalla</span>
<span class="line-added"> 563      */</span>
<span class="line-added"> 564     public boolean isInlineClass() {</span>
<span class="line-added"> 565         return (this.getModifiers() &amp; INLINE) != 0;</span>
<span class="line-added"> 566     }</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568     /**</span>
<span class="line-added"> 569      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-added"> 570      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-added"> 571      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-added"> 572      * {@link Optional} is returned.</span>
<span class="line-added"> 573      *</span>
<span class="line-added"> 574      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 575      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 576      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 577      * @since Valhalla</span>
<span class="line-added"> 578      */</span>
<span class="line-added"> 579     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-added"> 580         return Optional.ofNullable(valType);</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583     /**</span>
<span class="line-added"> 584      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-added"> 585      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 586      * with a reference projection.</span>
<span class="line-added"> 587      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 588      * without a reference projection or this class is not an inline class,</span>
<span class="line-added"> 589      * then this method returns an empty {@link Optional}.</span>
<span class="line-added"> 590      *</span>
<span class="line-added"> 591      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 592      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 593      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 594      * @since Valhalla</span>
<span class="line-added"> 595      */</span>
<span class="line-added"> 596     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-added"> 597         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>
<span class="line-added"> 598     }</span>
<span class="line-added"> 599 </span>
<span class="line-added"> 600     // set by VM if this class is an inline type</span>
<span class="line-added"> 601     // otherwise, these two fields are null</span>
<span class="line-added"> 602     private transient Class&lt;T&gt; valType;</span>
<span class="line-added"> 603     private transient Class&lt;T&gt; refType;</span>
<span class="line-added"> 604 </span>
 605     /**
 606      * Creates a new instance of the class represented by this {@code Class}
 607      * object.  The class is instantiated as if by a {@code new}
 608      * expression with an empty argument list.  The class is initialized if it
 609      * has not already been initialized.
 610      *
 611      * @deprecated This method propagates any exception thrown by the
 612      * nullary constructor, including a checked exception.  Use of
 613      * this method effectively bypasses the compile-time exception
 614      * checking that would otherwise be performed by the compiler.
 615      * The {@link
 616      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 617      * Constructor.newInstance} method avoids this problem by wrapping
 618      * any exception thrown by the constructor in a (checked) {@link
 619      * java.lang.reflect.InvocationTargetException}.
 620      *
 621      * &lt;p&gt;The call
 622      *
 623      * &lt;pre&gt;{@code
 624      * clazz.newInstance()
</pre>
<hr />
<pre>
 864      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 865      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 866      * &lt;/ul&gt;
 867      *
 868      * &lt;p&gt; If this {@code Class} object represents an array class, then
 869      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 870      * representing the depth of the array nesting, followed by the element
 871      * type as encoded using the following table:
 872      *
 873      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 874      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 875      * &lt;thead&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 877      * &lt;/thead&gt;
 878      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 883      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
<span class="line-added"> 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-added"> 885      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 888      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 889      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 890      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 891      * &lt;/tbody&gt;
 892      * &lt;/table&gt;&lt;/blockquote&gt;
 893      *
 894      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 895      * then the result is a string with the same spelling as the Java language
 896      * keyword which corresponds to the primitive type or {@code void}.
 897      *
 898      * &lt;p&gt; Examples:
 899      * &lt;blockquote&gt;&lt;pre&gt;
 900      * String.class.getName()
 901      *     returns &quot;java.lang.String&quot;
 902      * byte.class.getName()
 903      *     returns &quot;byte&quot;
<span class="line-added"> 904      * Point.class.getName()</span>
<span class="line-added"> 905      *     returns &quot;Point&quot;</span>
 906      * (new Object[3]).getClass().getName()
 907      *     returns &quot;[Ljava.lang.Object;&quot;
<span class="line-added"> 908      * (new Point[3]).getClass().getName()</span>
<span class="line-added"> 909      *     returns &quot;[QPoint;&quot;</span>
<span class="line-added"> 910      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-added"> 911      *     returns &quot;[[LPoint$ref;&quot;</span>
 912      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 913      *     returns &quot;[[[[[[[I&quot;
 914      * &lt;/pre&gt;&lt;/blockquote&gt;
 915      *
 916      * @return  the name of the class, interface, or other entity
 917      *          represented by this {@code Class} object.
 918      * @jls 13.1 The Form of a Binary
 919      */
 920     public String getName() {
 921         String name = this.name;
 922         return name != null ? name : initClassName();
 923     }
 924 
 925     // Cache the name to reduce the number of calls into the VM.
 926     // This field would be set by VM itself during initClassName call.
 927     private transient String name;
 928     private native String initClassName();
 929 
 930     /**
 931      * Returns the class loader for the class.  Some implementations may use
</pre>
<hr />
<pre>
1322      * modifiers are the same as those of its component type.  If this
1323      * {@code Class} object represents a primitive type or void, its
1324      * {@code public} modifier is always {@code true}, and its
1325      * {@code protected} and {@code private} modifiers are always
1326      * {@code false}. If this {@code Class} object represents an array class, a
1327      * primitive type or void, then its {@code final} modifier is always
1328      * {@code true} and its interface modifier is always
1329      * {@code false}. The values of its other modifiers are not determined
1330      * by this specification.
1331      *
1332      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1333      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1334      *
1335      * @return the {@code int} representing the modifiers for this class
1336      * @see     java.lang.reflect.Modifier
1337      * @since 1.1
1338      */
1339     @HotSpotIntrinsicCandidate
1340     public native int getModifiers();
1341 

1342     /**
1343      * Gets the signers of this class.
1344      *
1345      * @return  the signers of this class, or null if there are no signers.  In
1346      *          particular, this method returns null if this {@code Class} object represents
1347      *          a primitive type or void.
1348      * @since   1.1
1349      */
1350     public native Object[] getSigners();
1351 

1352     /**
1353      * Set the signers of this class.
1354      */
1355     native void setSigners(Object[] signers);
1356 
1357 
1358     /**
1359      * If this {@code Class} object represents a local or anonymous
1360      * class within a method, returns a {@link
1361      * java.lang.reflect.Method Method} object representing the
1362      * immediately enclosing method of the underlying class. Returns
1363      * {@code null} otherwise.
1364      *
1365      * In particular, this method returns {@code null} if the underlying
1366      * class is a local or anonymous class immediately enclosed by a type
1367      * declaration, instance initializer or static initializer.
1368      *
1369      * @return the immediately enclosing method of the underlying class, if
1370      *     that class is a local or anonymous class; otherwise {@code null}.
1371      *
</pre>
<hr />
<pre>
1712             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1713         }
1714         return simpleName;
1715     }
1716 
1717     /**
1718      * Return an informative string for the name of this type.
1719      *
1720      * @return an informative string for the name of this type
1721      * @since 1.8
1722      */
1723     public String getTypeName() {
1724         if (isArray()) {
1725             try {
1726                 Class&lt;?&gt; cl = this;
1727                 int dimensions = 0;
1728                 do {
1729                     dimensions++;
1730                     cl = cl.getComponentType();
1731                 } while (cl.isArray());
<span class="line-modified">1732                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);</span>
1733             } catch (Throwable e) { /*FALLTHRU*/ }
1734         }
1735         return getName();
1736     }
1737 
1738     /**
1739      * Returns the canonical name of the underlying class as
1740      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1741      * Returns {@code null} if the underlying class does not have a canonical
1742      * name. Classes without canonical names include:
1743      * &lt;ul&gt;
1744      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1745      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1746      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1747      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1748      * &lt;/ul&gt;
1749      *
1750      * @return the canonical name of the underlying class if it exists, and
1751      * {@code null} otherwise.
1752      * @since 1.5
</pre>
<hr />
<pre>
3847                 throw new IllegalArgumentException(
3848                     getName() + &quot; is not an enum type&quot;);
3849             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3850             for (T constant : universe) {
3851                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3852             }
3853             enumConstantDirectory = directory;
3854         }
3855         return directory;
3856     }
3857     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3858 
3859     /**
3860      * Casts an object to the class or interface represented
3861      * by this {@code Class} object.
3862      *
3863      * @param obj the object to be cast
3864      * @return the object after casting, or null if obj is null
3865      *
3866      * @throws ClassCastException if the object is not
<span class="line-modified">3867      * {@code null} and is not assignable to the type T.</span>
<span class="line-added">3868      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-added">3869      * inline type} and the object is {@code null}</span>
3870      *
3871      * @since 1.5
3872      */
3873     @SuppressWarnings(&quot;unchecked&quot;)
3874     @HotSpotIntrinsicCandidate
3875     public T cast(Object obj) {
<span class="line-added">3876         if (isInlineClass() &amp;&amp; obj == null)</span>
<span class="line-added">3877             throw new NullPointerException(getName() + &quot; is an inline class&quot;);</span>
<span class="line-added">3878 </span>
3879         if (obj != null &amp;&amp; !isInstance(obj))
3880             throw new ClassCastException(cannotCastMsg(obj));
3881         return (T) obj;
3882     }
3883 
3884     private String cannotCastMsg(Object obj) {
3885         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3886     }
3887 
3888     /**
3889      * Casts this {@code Class} object to represent a subclass of the class
3890      * represented by the specified class object.  Checks that the cast
3891      * is valid, and throws a {@code ClassCastException} if it is not.  If
3892      * this method succeeds, it always returns a reference to this {@code Class} object.
3893      *
3894      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3895      * a {@code Class} object to pass it to an API that restricts the
3896      * {@code Class} objects that it is willing to accept.  A cast would
3897      * generate a compile-time warning, as the correctness of the cast
3898      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4154      *
4155      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4156      * value is an array containing objects representing the uses of interface
4157      * types to specify interfaces directly extended by the interface. The
4158      * order of the objects in the array corresponds to the order of the
4159      * interface types used in the &#39;extends&#39; clause of the declaration of this
4160      * {@code Class} object.
4161      *
4162      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4163      * declaration does not explicitly indicate any annotated superinterfaces,
4164      * the return value is an array of length 0.
4165      *
4166      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4167      * class, an array type, a primitive type, or void, the return value is an
4168      * array of length 0.
4169      *
4170      * @return an array representing the superinterfaces
4171      * @since 1.8
4172      */
4173     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4174         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4175     }
4176 
4177     private native Class&lt;?&gt; getNestHost0();
4178 
4179     /**
4180      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4181      * or interface represented by this {@code Class} object belongs.
4182      * Every class and interface belongs to exactly one nest.
4183      *
4184      * If the nest host of this class or interface has previously
4185      * been determined, then this method returns the nest host.
4186      * If the nest host of this class or interface has
4187      * not previously been determined, then this method determines the nest
4188      * host using the algorithm of JVMS 5.4.4, and returns it.
4189      *
4190      * Often, a class or interface belongs to a nest consisting only of itself,
4191      * in which case this method returns {@code this} to indicate that the class
4192      * or interface is the nest host.
4193      *
4194      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
</pre>
<hr />
<pre>
4367      * {@code void}, then the result is a field descriptor string which
4368      * is a one-letter code corresponding to a primitive type or {@code void}
4369      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4370      *
4371      * @apiNote
4372      * This is not a strict inverse of {@link #forName};
4373      * distinct classes which share a common name but have different class loaders
4374      * will have identical descriptor strings.
4375      *
4376      * @return the descriptor string for this {@code Class} object
4377      * @jvms 4.3.2 Field Descriptors
4378      * @since 12
4379      */
4380     @Override
4381     public String descriptorString() {
4382         if (isPrimitive())
4383             return Wrapper.forPrimitiveType(this).basicTypeString();
4384 
4385         if (isArray()) {
4386             return &quot;[&quot; + componentType.descriptorString();
<span class="line-modified">4387         }</span>
<span class="line-added">4388         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-added">4389         if (isHidden()) {</span>
4390             String name = getName();
4391             int index = name.indexOf(&#39;/&#39;);
<span class="line-modified">4392             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
4393                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4394         } else {
<span class="line-modified">4395             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4396         }
4397     }
4398 
4399     /**
4400      * Returns the component type of this {@code Class}, if it describes
4401      * an array type, or {@code null} otherwise.
4402      *
4403      * @implSpec
4404      * Equivalent to {@link Class#getComponentType()}.
4405      *
4406      * @return a {@code Class} describing the component type, or {@code null}
4407      * if this {@code Class} does not describe an array type
4408      * @since 12
4409      */
4410     @Override
4411     public Class&lt;?&gt; componentType() {
4412         return isArray() ? componentType : null;
4413     }
4414 
4415     /**
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="invoke/InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
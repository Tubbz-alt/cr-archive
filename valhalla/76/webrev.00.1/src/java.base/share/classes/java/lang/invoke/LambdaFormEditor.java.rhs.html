<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import sun.invoke.util.Wrapper;
  29 
<a name="1" id="anc1"></a><span class="line-added">  30 import java.lang.invoke.MethodHandles.Lookup;</span>
  31 import java.lang.ref.SoftReference;
  32 import java.util.Arrays;
  33 import java.util.Collections;
  34 import java.util.Comparator;
  35 import java.util.TreeMap;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 
  38 import static java.lang.invoke.LambdaForm.*;
  39 import static java.lang.invoke.LambdaForm.BasicType.*;
  40 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  41 import static java.lang.invoke.MethodHandleImpl.NF_loop;
  42 
  43 /** Transforms on LFs.
  44  *  A lambda-form editor can derive new LFs from its base LF.
  45  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  46  *  To support this caching, a LF has an optional pointer to its editor.
  47  */
  48 class LambdaFormEditor {
  49     final LambdaForm lambdaForm;
  50 
  51     private LambdaFormEditor(LambdaForm lambdaForm) {
  52         this.lambdaForm = lambdaForm;
  53     }
  54 
  55     // Factory method.
  56     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  57         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  58         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  59 
  60         // Always use uncustomized version for editing.
  61         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  62         return new LambdaFormEditor(lambdaForm.uncustomize());
  63     }
  64 
  65     // Transform types
  66     // maybe add more for guard with test, catch exception, pointwise type conversions
  67     private static final byte
  68             BIND_ARG = 1,
  69             ADD_ARG = 2,
  70             DUP_ARG = 3,
  71             SPREAD_ARGS = 4,
  72             FILTER_ARG = 5,
  73             FILTER_RETURN = 6,
  74             FILTER_RETURN_TO_ZERO = 7,
  75             COLLECT_ARGS = 8,
  76             COLLECT_ARGS_TO_VOID = 9,
  77             COLLECT_ARGS_TO_ARRAY = 10,
  78             FOLD_ARGS = 11,
  79             FOLD_ARGS_TO_VOID = 12,
  80             PERMUTE_ARGS = 13,
  81             LOCAL_TYPES = 14,
  82             FOLD_SELECT_ARGS = 15,
  83             FOLD_SELECT_ARGS_TO_VOID = 16,
  84             FILTER_SELECT_ARGS = 17,
  85             REPEAT_FILTER_ARGS = 18;
  86 
  87     /**
  88      * A description of a cached transform, possibly associated with the result of the transform.
  89      * The logical content is a sequence of byte values, starting with a kind value.
  90      * The sequence is unterminated, ending with an indefinite number of zero bytes.
  91      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.
  92      *
  93      * Tightly coupled with the TransformKey class, which is used to lookup existing
  94      * Transforms.
  95      */
  96     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  97         final long packedBytes;
  98         final byte[] fullBytes;
  99 
 100         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {
 101             super(result);
 102             this.packedBytes = packedBytes;
 103             this.fullBytes = fullBytes;
 104         }
 105 
 106         @Override
 107         public boolean equals(Object obj) {
 108             if (obj instanceof TransformKey) {
 109                 return equals((TransformKey) obj);
 110             }
 111             return obj instanceof Transform &amp;&amp; equals((Transform)obj);
 112         }
 113 
 114         private boolean equals(TransformKey that) {
 115             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 116         }
 117 
 118         private boolean equals(Transform that) {
 119             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 120         }
 121 
 122         @Override
 123         public int hashCode() {
 124             if (packedBytes != 0) {
 125                 assert(fullBytes == null);
 126                 return Long.hashCode(packedBytes);
 127             }
 128             return Arrays.hashCode(fullBytes);
 129         }
 130 
 131         @Override
 132         public String toString() {
 133             StringBuilder buf = new StringBuilder();
 134             buf.append(new TransformKey(packedBytes, fullBytes).toString());
 135             LambdaForm result = get();
 136             if (result != null) {
 137                 buf.append(&quot; result=&quot;);
 138                 buf.append(result);
 139             }
 140             return buf.toString();
 141         }
 142     }
 143 
 144     /**
 145      * Used as a lookup key to find existing Transforms
 146      */
 147     private static final class TransformKey {
 148         final long packedBytes;
 149         final byte[] fullBytes;
 150 
 151         private TransformKey(long packedBytes) {
 152             this.packedBytes = packedBytes;
 153             this.fullBytes = null;
 154         }
 155 
 156         private TransformKey(byte[] fullBytes) {
 157             this.fullBytes = fullBytes;
 158             this.packedBytes = 0;
 159         }
 160 
 161         private TransformKey(long packedBytes, byte[] fullBytes) {
 162             this.fullBytes = fullBytes;
 163             this.packedBytes = packedBytes;
 164         }
 165 
 166         private static byte bval(int b) {
 167             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte
 168             return (byte)b;
 169         }
 170         static TransformKey of(byte k, int b1) {
 171             byte b0 = bval(k);
 172             if (inRange(b0 | b1))
 173                 return new TransformKey(packedBytes(b0, b1));
 174             else
 175                 return new TransformKey(fullBytes(b0, b1));
 176         }
 177         static TransformKey of(byte b0, int b1, int b2) {
 178             if (inRange(b0 | b1 | b2))
 179                 return new TransformKey(packedBytes(b0, b1, b2));
 180             else
 181                 return new TransformKey(fullBytes(b0, b1, b2));
 182         }
 183         static TransformKey of(byte b0, int b1, int b2, int b3) {
 184             if (inRange(b0 | b1 | b2 | b3))
 185                 return new TransformKey(packedBytes(b0, b1, b2, b3));
 186             else
 187                 return new TransformKey(fullBytes(b0, b1, b2, b3));
 188         }
 189         private static final byte[] NO_BYTES = {};
 190         static TransformKey of(byte kind, int... b123) {
 191             return ofBothArrays(kind, b123, NO_BYTES);
 192         }
 193 
 194         static TransformKey of(byte kind, int b1, int[] b23456) {
 195             byte[] fullBytes = new byte[b23456.length + 2];
 196             fullBytes[0] = kind;
 197             fullBytes[1] = bval(b1);
 198             for (int i = 0; i &lt; b23456.length; i++) {
 199                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);
 200             }
 201             long packedBytes = packedBytes(fullBytes);
 202             if (packedBytes != 0)
 203                 return new TransformKey(packedBytes);
 204             else
 205                 return new TransformKey(fullBytes);
 206         }
 207 
 208         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {
 209             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);
 210         }
 211         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {
 212             byte[] fullBytes = new byte[1 + b123.length + b456.length];
 213             int i = 0;
 214             fullBytes[i++] = bval(kind);
 215             for (int bv : b123) {
 216                 fullBytes[i++] = bval(bv);
 217             }
 218             for (byte bv : b456) {
 219                 fullBytes[i++] = bv;
 220             }
 221             long packedBytes = packedBytes(fullBytes);
 222             if (packedBytes != 0)
 223                 return new TransformKey(packedBytes);
 224             else
 225                 return new TransformKey(fullBytes);
 226         }
 227 
 228         private static final boolean STRESS_TEST = false; // turn on to disable most packing
 229         private static final int
 230                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
 231                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
 232                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 233 
 234         private static long packedBytes(byte[] bytes) {
 235             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)
 236                 return 0;
 237             long pb = 0;
 238             int bitset = 0;
 239             for (int i = 0; i &lt; bytes.length; i++) {
 240                 int b = bytes[i] &amp; 0xFF;
 241                 bitset |= b;
 242                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 243             }
 244             if (!inRange(bitset))
 245                 return 0;
 246             return pb;
 247         }
 248         private static long packedBytes(int b0, int b1) {
 249             assert(inRange(b0 | b1));
 250             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 251                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 252         }
 253         private static long packedBytes(int b0, int b1, int b2) {
 254             assert(inRange(b0 | b1 | b2));
 255             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 256                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 257                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE));
 258         }
 259         private static long packedBytes(int b0, int b1, int b2, int b3) {
 260             assert(inRange(b0 | b1 | b2 | b3));
 261             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 262                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 263                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 264                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 265         }
 266         private static boolean inRange(int bitset) {
 267             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 268             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 269         }
 270         private static byte[] fullBytes(int... byteValues) {
 271             byte[] bytes = new byte[byteValues.length];
 272             int i = 0;
 273             for (int bv : byteValues) {
 274                 bytes[i++] = bval(bv);
 275             }
 276             assert(packedBytes(bytes) == 0);
 277             return bytes;
 278         }
 279 
 280         Transform withResult(LambdaForm result) {
 281             return new Transform(this.packedBytes, this.fullBytes, result);
 282         }
 283 
 284         @Override
 285         public String toString() {
 286             StringBuilder buf = new StringBuilder();
 287             long bits = packedBytes;
 288             if (bits != 0) {
 289                 buf.append(&quot;(&quot;);
 290                 while (bits != 0) {
 291                     buf.append(bits &amp; PACKED_BYTE_MASK);
 292                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 293                     if (bits != 0)  buf.append(&quot;,&quot;);
 294                 }
 295                 buf.append(&quot;)&quot;);
 296             }
 297             if (fullBytes != null) {
 298                 buf.append(&quot;unpacked&quot;);
 299                 buf.append(Arrays.toString(fullBytes));
 300             }
 301             return buf.toString();
 302         }
 303 
 304         @Override
 305         public boolean equals(Object obj) {
 306             if (obj instanceof TransformKey) {
 307                 return equals((TransformKey) obj);
 308             }
 309             return obj instanceof Transform &amp;&amp; equals((Transform)obj);
 310         }
 311 
 312         private boolean equals(TransformKey that) {
 313             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 314         }
 315 
 316         private boolean equals(Transform that) {
 317             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 318         }
 319 
 320         @Override
 321         public int hashCode() {
 322             if (packedBytes != 0) {
 323                 assert(fullBytes == null);
 324                 return Long.hashCode(packedBytes);
 325             }
 326             return Arrays.hashCode(fullBytes);
 327         }
 328     }
 329 
 330     /** Find a previously cached transform equivalent to the given one, and return its result. */
 331     private LambdaForm getInCache(TransformKey key) {
 332         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 333         Object c = lambdaForm.transformCache;
 334         Transform k = null;
 335         if (c instanceof ConcurrentHashMap) {
 336             @SuppressWarnings(&quot;unchecked&quot;)
 337             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 338             k = m.get(key);
 339         } else if (c == null) {
 340             return null;
 341         } else if (c instanceof Transform) {
 342             // one-element cache avoids overhead of an array
 343             Transform t = (Transform)c;
 344             if (t.equals(key))  k = t;
 345         } else {
 346             Transform[] ta = (Transform[])c;
 347             for (int i = 0; i &lt; ta.length; i++) {
 348                 Transform t = ta[i];
 349                 if (t == null)  break;
 350                 if (t.equals(key)) { k = t; break; }
 351             }
 352         }
 353         assert(k == null || key.equals(k));
 354         return (k != null) ? k.get() : null;
 355     }
 356 
 357     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 358     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 359 
 360     /** Cache a transform with its result, and return that result.
 361      *  But if an equivalent transform has already been cached, return its result instead.
 362      */
 363     private LambdaForm putInCache(TransformKey key, LambdaForm form) {
 364         Transform transform = key.withResult(form);
 365         for (int pass = 0; ; pass++) {
 366             Object c = lambdaForm.transformCache;
 367             if (c instanceof ConcurrentHashMap) {
 368                 @SuppressWarnings(&quot;unchecked&quot;)
 369                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 370                 Transform k = m.putIfAbsent(transform, transform);
 371                 if (k == null) return form;
 372                 LambdaForm result = k.get();
 373                 if (result != null) {
 374                     return result;
 375                 } else {
 376                     if (m.replace(transform, k, transform)) {
 377                         return form;
 378                     } else {
 379                         continue;
 380                     }
 381                 }
 382             }
 383             assert(pass == 0);
 384             synchronized (lambdaForm) {
 385                 c = lambdaForm.transformCache;
 386                 if (c instanceof ConcurrentHashMap)
 387                     continue;
 388                 if (c == null) {
 389                     lambdaForm.transformCache = transform;
 390                     return form;
 391                 }
 392                 Transform[] ta;
 393                 if (c instanceof Transform) {
 394                     Transform k = (Transform)c;
 395                     if (k.equals(key)) {
 396                         LambdaForm result = k.get();
 397                         if (result == null) {
 398                             lambdaForm.transformCache = transform;
 399                             return form;
 400                         } else {
 401                             return result;
 402                         }
 403                     } else if (k.get() == null) { // overwrite stale entry
 404                         lambdaForm.transformCache = transform;
 405                         return form;
 406                     }
 407                     // expand one-element cache to small array
 408                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 409                     ta[0] = k;
 410                     lambdaForm.transformCache = ta;
 411                 } else {
 412                     // it is already expanded
 413                     ta = (Transform[])c;
 414                 }
 415                 int len = ta.length;
 416                 int stale = -1;
 417                 int i;
 418                 for (i = 0; i &lt; len; i++) {
 419                     Transform k = ta[i];
 420                     if (k == null) {
 421                         break;
 422                     }
 423                     if (k.equals(transform)) {
 424                         LambdaForm result = k.get();
 425                         if (result == null) {
 426                             ta[i] = transform;
 427                             return form;
 428                         } else {
 429                             return result;
 430                         }
 431                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 432                         stale = i; // remember 1st stale entry index
 433                     }
 434                 }
 435                 if (i &lt; len || stale &gt;= 0) {
 436                     // just fall through to cache update
 437                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 438                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 439                     ta = Arrays.copyOf(ta, len);
 440                     lambdaForm.transformCache = ta;
 441                 } else {
 442                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 443                     for (Transform k : ta) {
 444                         m.put(k, k);
 445                     }
 446                     lambdaForm.transformCache = m;
 447                     // The second iteration will update for this query, concurrently.
 448                     continue;
 449                 }
 450                 int idx = (stale &gt;= 0) ? stale : i;
 451                 ta[idx] = transform;
 452                 return form;
 453             }
 454         }
 455     }
 456 
 457     private LambdaFormBuffer buffer() {
 458         return new LambdaFormBuffer(lambdaForm);
 459     }
 460 
 461     /// Editing methods for method handles.  These need to have fast paths.
 462 
 463     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 464         return BoundMethodHandle.speciesDataFor(lambdaForm);
 465     }
 466 
 467     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 468         return oldSpeciesData().extendWith((byte) type.ordinal());
 469     }
 470 
 471     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
 472         assert(mh.speciesData() == oldSpeciesData());
 473         BasicType bt = L_TYPE;
 474         MethodType type2 = bindArgumentType(mh, pos, bt);
 475         LambdaForm form2 = bindArgumentForm(1+pos);
 476         return mh.copyWithExtendL(type2, form2, value);
 477     }
 478     BoundMethodHandle bindArgumentI(BoundMethodHandle mh, int pos, int value) {
 479         assert(mh.speciesData() == oldSpeciesData());
 480         BasicType bt = I_TYPE;
 481         MethodType type2 = bindArgumentType(mh, pos, bt);
 482         LambdaForm form2 = bindArgumentForm(1+pos);
 483         return mh.copyWithExtendI(type2, form2, value);
 484     }
 485 
 486     BoundMethodHandle bindArgumentJ(BoundMethodHandle mh, int pos, long value) {
 487         assert(mh.speciesData() == oldSpeciesData());
 488         BasicType bt = J_TYPE;
 489         MethodType type2 = bindArgumentType(mh, pos, bt);
 490         LambdaForm form2 = bindArgumentForm(1+pos);
 491         return mh.copyWithExtendJ(type2, form2, value);
 492     }
 493 
 494     BoundMethodHandle bindArgumentF(BoundMethodHandle mh, int pos, float value) {
 495         assert(mh.speciesData() == oldSpeciesData());
 496         BasicType bt = F_TYPE;
 497         MethodType type2 = bindArgumentType(mh, pos, bt);
 498         LambdaForm form2 = bindArgumentForm(1+pos);
 499         return mh.copyWithExtendF(type2, form2, value);
 500     }
 501 
 502     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 503         assert(mh.speciesData() == oldSpeciesData());
 504         BasicType bt = D_TYPE;
 505         MethodType type2 = bindArgumentType(mh, pos, bt);
 506         LambdaForm form2 = bindArgumentForm(1+pos);
 507         return mh.copyWithExtendD(type2, form2, value);
 508     }
 509 
 510     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 511         assert(mh.form.uncustomize() == lambdaForm);
 512         assert(mh.form.names[1+pos].type == bt);
 513         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 514         return mh.type().dropParameterTypes(pos, pos+1);
 515     }
 516 
 517     /// Editing methods for lambda forms.
 518     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 519 
 520     LambdaForm bindArgumentForm(int pos) {
 521         TransformKey key = TransformKey.of(BIND_ARG, pos);
 522         LambdaForm form = getInCache(key);
 523         if (form != null) {
 524             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 525             return form;
 526         }
 527         LambdaFormBuffer buf = buffer();
 528         buf.startEdit();
 529 
 530         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 531         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 532         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 533         Name newBaseAddress;
 534         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 535 
 536         if (pos != 0) {
 537             // The newly created LF will run with a different BMH.
 538             // Switch over any pre-existing BMH field references to the new BMH class.
 539             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 540             newBaseAddress = oldBaseAddress.withConstraint(newData);
 541             buf.renameParameter(0, newBaseAddress);
 542             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 543         } else {
 544             // cannot bind the MH arg itself, unless oldData is empty
 545             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 546             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 547             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 548             buf.insertParameter(0, newBaseAddress);
 549         }
 550 
 551         form = buf.endEdit();
 552         return putInCache(key, form);
 553     }
 554 
 555     LambdaForm addArgumentForm(int pos, BasicType type) {
 556         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());
 557         LambdaForm form = getInCache(key);
 558         if (form != null) {
 559             assert(form.arity == lambdaForm.arity+1);
 560             assert(form.parameterType(pos) == type);
 561             return form;
 562         }
 563         LambdaFormBuffer buf = buffer();
 564         buf.startEdit();
 565 
 566         buf.insertParameter(pos, new Name(type));
 567 
 568         form = buf.endEdit();
 569         return putInCache(key, form);
 570     }
 571 
 572     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
 573         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);
 574         LambdaForm form = getInCache(key);
 575         if (form != null) {
 576             assert(form.arity == lambdaForm.arity-1);
 577             return form;
 578         }
 579         LambdaFormBuffer buf = buffer();
 580         buf.startEdit();
 581 
 582         assert(lambdaForm.parameter(srcPos).constraint == null);
 583         assert(lambdaForm.parameter(dstPos).constraint == null);
 584         buf.replaceParameterByCopy(dstPos, srcPos);
 585 
 586         form = buf.endEdit();
 587         return putInCache(key, form);
 588     }
 589 
 590     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 591         Class&lt;?&gt; elementType = arrayType.getComponentType();
 592         Class&lt;?&gt; erasedArrayType = arrayType;
 593         if (!elementType.isPrimitive())
 594             erasedArrayType = Object[].class;
 595         BasicType bt = basicType(elementType);
 596         int elementTypeKey = bt.ordinal();
 597         if (bt.basicTypeClass() != elementType) {
 598             if (elementType.isPrimitive()) {
 599                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 600             }
 601         }
 602         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);
 603         LambdaForm form = getInCache(key);
 604         if (form != null) {
 605             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 606             return form;
 607         }
 608         LambdaFormBuffer buf = buffer();
 609         buf.startEdit();
 610 
 611         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 612         assert(pos + arrayLength &lt;= lambdaForm.arity);
 613         assert(pos &gt; 0);  // cannot spread the MH arg itself
 614 
 615         Name spreadParam = new Name(L_TYPE);
 616         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 617                 spreadParam, arrayLength);
 618 
 619         // insert the new expressions
 620         int exprPos = lambdaForm.arity();
 621         buf.insertExpression(exprPos++, checkSpread);
 622         // adjust the arguments
 623         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 624         for (int i = 0; i &lt; arrayLength; i++) {
 625             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 626             buf.insertExpression(exprPos + i, loadArgument);
 627             buf.replaceParameterByCopy(pos + i, exprPos + i);
 628         }
 629         buf.insertParameter(pos, spreadParam);
 630 
 631         form = buf.endEdit();
 632         return putInCache(key, form);
 633     }
 634 
 635     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 636         int collectorArity = collectorType.parameterCount();
 637         boolean dropResult = (collectorType.returnType() == void.class);
 638         if (collectorArity == 1 &amp;&amp; !dropResult) {
 639             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 640         }
 641         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());
 642         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);
 643         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
 644         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);
 645         LambdaForm form = getInCache(key);
 646         if (form != null) {
 647             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 648             return form;
 649         }
 650         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 651         return putInCache(key, form);
 652     }
 653 
 654     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 655         MethodType collectorType = arrayCollector.type();
 656         int collectorArity = collectorType.parameterCount();
 657         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 658         Class&lt;?&gt; arrayType = collectorType.returnType();
 659         Class&lt;?&gt; elementType = arrayType.getComponentType();
 660         BasicType argType = basicType(elementType);
 661         int argTypeKey = argType.ordinal();
 662         if (argType.basicTypeClass() != elementType) {
 663             // return null if it requires more metadata (like String[].class)
 664             if (!elementType.isPrimitive())
 665                 return null;
 666             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 667         }
 668         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
 669         byte kind = COLLECT_ARGS_TO_ARRAY;
 670         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);
 671         LambdaForm form = getInCache(key);
 672         if (form != null) {
 673             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 674             return form;
 675         }
 676         LambdaFormBuffer buf = buffer();
 677         buf.startEdit();
 678 
 679         assert(pos + 1 &lt;= lambdaForm.arity);
 680         assert(pos &gt; 0);  // cannot filter the MH arg itself
 681 
 682         Name[] newParams = new Name[collectorArity];
 683         for (int i = 0; i &lt; collectorArity; i++) {
 684             newParams[i] = new Name(pos + i, argType);
 685         }
 686         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 687                                         (Object[]) /*...*/ newParams);
 688 
 689         // insert the new expression
 690         int exprPos = lambdaForm.arity();
 691         buf.insertExpression(exprPos, callCombiner);
 692 
 693         // insert new arguments
 694         int argPos = pos + 1;  // skip result parameter
 695         for (Name newParam : newParams) {
 696             buf.insertParameter(argPos++, newParam);
 697         }
 698         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 699         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 700 
 701         form = buf.endEdit();
 702         return putInCache(key, form);
 703     }
 704 
 705     LambdaForm filterArgumentForm(int pos, BasicType newType) {
 706         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());
 707         LambdaForm form = getInCache(key);
 708         if (form != null) {
 709             assert(form.arity == lambdaForm.arity);
 710             assert(form.parameterType(pos) == newType);
 711             return form;
 712         }
 713 
 714         BasicType oldType = lambdaForm.parameterType(pos);
 715         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 716                 newType.basicTypeClass());
 717         form = makeArgumentCombinationForm(pos, filterType, false, false);
 718         return putInCache(key, form);
 719     }
 720 
 721     /**
 722      * This creates a LF that will repeatedly invoke some unary filter function
 723      * at each of the given positions. This allows fewer LFs and BMH species
 724      * classes to be generated in typical cases compared to building up the form
 725      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 726      * no worse in the worst case.
 727      */
 728     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 729         assert (argPositions.length &gt; 1);
 730         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);
 731         LambdaForm form = getInCache(key);
 732         if (form != null) {
 733             assert(form.arity == lambdaForm.arity &amp;&amp;
 734                     formParametersMatch(form, newType, argPositions));
 735             return form;
 736         }
 737         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 738         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 739                 newType.basicTypeClass());
 740         form = makeRepeatedFilterForm(filterType, argPositions);
 741         assert (formParametersMatch(form, newType, argPositions));
 742         return putInCache(key, form);
 743     }
 744 
 745     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 746         for (int i : argPositions) {
 747             if (form.parameterType(i) != newType) {
 748                 return false;
 749             }
 750         }
 751         return true;
 752     }
 753 
 754     private LambdaForm makeRepeatedFilterForm(MethodType combinerType, int... positions) {
 755         assert (combinerType.parameterCount() == 1 &amp;&amp;
 756                 combinerType == combinerType.basicType() &amp;&amp;
 757                 combinerType.returnType() != void.class);
 758         LambdaFormBuffer buf = buffer();
 759         buf.startEdit();
 760 
 761         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 762         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 763 
 764         // The newly created LF will run with a different BMH.
 765         // Switch over any pre-existing BMH field references to the new BMH class.
 766         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 767         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 768         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 769         buf.renameParameter(0, newBaseAddress);
 770 
 771         // Insert the new expressions at the end
 772         int exprPos = lambdaForm.arity();
 773         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 774         buf.insertExpression(exprPos++, getCombiner);
 775 
 776         // After inserting expressions, we insert parameters in order
 777         // from lowest to highest, simplifying the calculation of where parameters
 778         // and expressions are
 779         var newParameters = new TreeMap&lt;Name, Integer&gt;(new Comparator&lt;&gt;() {
 780             public int compare(Name n1, Name n2) {
 781                 return n1.index - n2.index;
 782             }
 783         });
 784 
 785         // Insert combiner expressions in reverse order so that the invocation of
 786         // the resulting form will invoke the combiners in left-to-right order
 787         for (int i = positions.length - 1; i &gt;= 0; --i) {
 788             int pos = positions[i];
 789             assert (pos &gt; 0 &amp;&amp; pos &lt;= MethodType.MAX_JVM_ARITY &amp;&amp; pos &lt; lambdaForm.arity);
 790 
 791             Name newParameter = new Name(pos, basicType(combinerType.parameterType(0)));
 792             Object[] combinerArgs = {getCombiner, newParameter};
 793 
 794             Name callCombiner = new Name(combinerType, combinerArgs);
 795             buf.insertExpression(exprPos++, callCombiner);
 796             newParameters.put(newParameter, exprPos);
 797         }
 798 
 799         // Mix in new parameters from left to right in the buffer (this doesn&#39;t change
 800         // execution order
 801         int offset = 0;
 802         for (var entry : newParameters.entrySet()) {
 803             Name newParameter = entry.getKey();
 804             int from = entry.getValue();
 805             buf.insertParameter(newParameter.index() + 1 + offset, newParameter);
 806             buf.replaceParameterByCopy(newParameter.index() + offset, from + offset);
 807             offset++;
 808         }
 809         return buf.endEdit();
 810     }
 811 
 812 
 813     private LambdaForm makeArgumentCombinationForm(int pos,
 814                                                    MethodType combinerType,
 815                                                    boolean keepArguments, boolean dropResult) {
 816         LambdaFormBuffer buf = buffer();
 817         buf.startEdit();
 818         int combinerArity = combinerType.parameterCount();
 819         int resultArity = (dropResult ? 0 : 1);
 820 
 821         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 822         assert(pos + resultArity + (keepArguments ? combinerArity : 0) &lt;= lambdaForm.arity);
 823         assert(pos &gt; 0);  // cannot filter the MH arg itself
 824         assert(combinerType == combinerType.basicType());
 825         assert(combinerType.returnType() != void.class || dropResult);
 826 
 827         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 828         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 829 
 830         // The newly created LF will run with a different BMH.
 831         // Switch over any pre-existing BMH field references to the new BMH class.
 832         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 833         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 834         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 835         buf.renameParameter(0, newBaseAddress);
 836 
 837         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 838         Object[] combinerArgs = new Object[1 + combinerArity];
 839         combinerArgs[0] = getCombiner;
 840         Name[] newParams;
 841         if (keepArguments) {
 842             newParams = new Name[0];
 843             System.arraycopy(lambdaForm.names, pos + resultArity,
 844                              combinerArgs, 1, combinerArity);
 845         } else {
 846             newParams = new Name[combinerArity];
 847             for (int i = 0; i &lt; newParams.length; i++) {
 848                 newParams[i] = new Name(pos + i, basicType(combinerType.parameterType(i)));
 849             }
 850             System.arraycopy(newParams, 0,
 851                              combinerArgs, 1, combinerArity);
 852         }
 853         Name callCombiner = new Name(combinerType, combinerArgs);
 854 
 855         // insert the two new expressions
 856         int exprPos = lambdaForm.arity();
 857         buf.insertExpression(exprPos+0, getCombiner);
 858         buf.insertExpression(exprPos+1, callCombiner);
 859 
 860         // insert new arguments, if needed
 861         int argPos = pos + resultArity;  // skip result parameter
 862         for (Name newParam : newParams) {
 863             buf.insertParameter(argPos++, newParam);
 864         }
 865         assert(buf.lastIndexOf(callCombiner) == exprPos+1+newParams.length);
 866         if (!dropResult) {
 867             buf.replaceParameterByCopy(pos, exprPos+1+newParams.length);
 868         }
 869 
 870         return buf.endEdit();
 871     }
 872 
 873     private LambdaForm makeArgumentCombinationForm(int pos,
 874                                                    MethodType combinerType,
 875                                                    int[] argPositions,
 876                                                    boolean keepArguments,
 877                                                    boolean dropResult) {
 878         LambdaFormBuffer buf = buffer();
 879         buf.startEdit();
 880         int combinerArity = combinerType.parameterCount();
 881         assert(combinerArity == argPositions.length);
 882 
 883         int resultArity = (dropResult ? 0 : 1);
 884 
 885         assert(pos &lt;= lambdaForm.arity);
 886         assert(pos &gt; 0);  // cannot filter the MH arg itself
 887         assert(combinerType == combinerType.basicType());
 888         assert(combinerType.returnType() != void.class || dropResult);
 889 
 890         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 891         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 892 
 893         // The newly created LF will run with a different BMH.
 894         // Switch over any pre-existing BMH field references to the new BMH class.
 895         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 896         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 897         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 898         buf.renameParameter(0, newBaseAddress);
 899 
 900         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 901         Object[] combinerArgs = new Object[1 + combinerArity];
 902         combinerArgs[0] = getCombiner;
 903         Name newParam = null;
 904         if (keepArguments) {
 905             for (int i = 0; i &lt; combinerArity; i++) {
 906                 combinerArgs[i + 1] = lambdaForm.parameter(1 + argPositions[i]);
 907                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 908             }
 909         } else {
 910             newParam = new Name(pos, BasicType.basicType(combinerType.returnType()));
 911             for (int i = 0; i &lt; combinerArity; i++) {
 912                 int argPos = 1 + argPositions[i];
 913                 if (argPos == pos) {
 914                     combinerArgs[i + 1] = newParam;
 915                 } else {
 916                     combinerArgs[i + 1] = lambdaForm.parameter(argPos);
 917                 }
 918                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 919             }
 920         }
 921         Name callCombiner = new Name(combinerType, combinerArgs);
 922 
 923         // insert the two new expressions
 924         int exprPos = lambdaForm.arity();
 925         buf.insertExpression(exprPos+0, getCombiner);
 926         buf.insertExpression(exprPos+1, callCombiner);
 927 
 928         // insert new arguments, if needed
 929         int argPos = pos + resultArity;  // skip result parameter
 930         if (newParam != null) {
 931             buf.insertParameter(argPos++, newParam);
 932             exprPos++;
 933         }
 934         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 935         if (!dropResult) {
 936             buf.replaceParameterByCopy(pos, exprPos+1);
 937         }
 938 
 939         return buf.endEdit();
 940     }
 941 
 942     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
 943         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);
 944         TransformKey key = TransformKey.of(kind, newType.ordinal());
 945         LambdaForm form = getInCache(key);
 946         if (form != null) {
 947             assert(form.arity == lambdaForm.arity);
 948             assert(form.returnType() == newType);
 949             return form;
 950         }
 951         LambdaFormBuffer buf = buffer();
 952         buf.startEdit();
 953 
 954         int insPos = lambdaForm.names.length;
 955         Name callFilter;
 956         if (constantZero) {
 957             // Synthesize a constant zero value for the given type.
 958             if (newType == V_TYPE)
 959                 callFilter = null;
 960             else
 961                 callFilter = new Name(constantZero(newType));
 962         } else {
 963             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 964             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 965 
 966             // The newly created LF will run with a different BMH.
 967             // Switch over any pre-existing BMH field references to the new BMH class.
 968             Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 969             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 970             Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 971             buf.renameParameter(0, newBaseAddress);
 972 
 973             Name getFilter = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 974             buf.insertExpression(insPos++, getFilter);
 975             BasicType oldType = lambdaForm.returnType();
 976             if (oldType == V_TYPE) {
 977                 MethodType filterType = MethodType.methodType(newType.basicTypeClass());
 978                 callFilter = new Name(filterType, getFilter);
 979             } else {
 980                 MethodType filterType = MethodType.methodType(newType.basicTypeClass(), oldType.basicTypeClass());
 981                 callFilter = new Name(filterType, getFilter, lambdaForm.names[lambdaForm.result]);
 982             }
 983         }
 984 
 985         if (callFilter != null)
 986             buf.insertExpression(insPos++, callFilter);
 987         buf.setResult(callFilter);
 988 
 989         form = buf.endEdit();
 990         return putInCache(key, form);
 991     }
 992 
 993     LambdaForm collectReturnValueForm(MethodType combinerType) {
 994         LambdaFormBuffer buf = buffer();
 995         buf.startEdit();
 996         int combinerArity = combinerType.parameterCount();
 997         int argPos = lambdaForm.arity();
 998         int exprPos = lambdaForm.names.length;
 999 
1000         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
1001         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
1002 
1003         // The newly created LF will run with a different BMH.
1004         // Switch over any pre-existing BMH field references to the new BMH class.
1005         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
1006         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
1007         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
1008         buf.renameParameter(0, newBaseAddress);
1009 
1010         // Now we set up the call to the filter
1011         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
1012 
1013         Object[] combinerArgs = new Object[combinerArity + 1];
1014         combinerArgs[0] = getCombiner; // first (synthetic) argument should be the MH that acts as a target of the invoke
1015 
1016         // set up additional adapter parameters (in case the combiner is not a unary function)
1017         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter
1018         for (int i = 0; i &lt; newParams.length; i++) {
1019             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));
1020         }
1021 
1022         // set up remaining filter parameters to point to the corresponding adapter parameters (see above)
1023         System.arraycopy(newParams, 0,
1024                 combinerArgs, 1, combinerArity - 1);
1025 
1026         // the last filter argument is set to point at the result of the target method handle
1027         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
1028         Name callCombiner = new Name(combinerType, combinerArgs);
1029 
1030         // insert the two new expressions
1031         buf.insertExpression(exprPos, getCombiner);
1032         buf.insertExpression(exprPos + 1, callCombiner);
1033 
1034         // insert additional arguments
1035         int insPos = argPos;
1036         for (Name newParam : newParams) {
1037             buf.insertParameter(insPos++, newParam);
1038         }
1039 
1040         buf.setResult(callCombiner);
1041         return buf.endEdit();
1042     }
1043 
1044     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
1045         int combinerArity = combinerType.parameterCount();
1046         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);
1047         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);
1048         LambdaForm form = getInCache(key);
1049         if (form != null) {
1050             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));
1051             return form;
1052         }
1053         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
1054         return putInCache(key, form);
1055     }
1056 
1057     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
1058         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);
1059         TransformKey key = TransformKey.of(kind, foldPos, argPositions);
1060         LambdaForm form = getInCache(key);
1061         if (form != null) {
1062             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));
1063             return form;
1064         }
1065         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
1066         return putInCache(key, form);
1067     }
1068 
1069     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
1070         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);
1071         LambdaForm form = getInCache(key);
1072         if (form != null) {
1073             assert(form.arity == lambdaForm.arity);
1074             return form;
1075         }
1076         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
1077         return putInCache(key, form);
1078     }
1079 
1080     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
1081         assert(skip == 1);  // skip only the leading MH argument, names[0]
1082         int length = lambdaForm.names.length;
1083         int outArgs = reorder.length;
1084         int inTypes = 0;
1085         boolean nullPerm = true;
1086         for (int i = 0; i &lt; reorder.length; i++) {
1087             int inArg = reorder[i];
1088             if (inArg != i)  nullPerm = false;
1089             inTypes = Math.max(inTypes, inArg+1);
1090         }
1091         assert(skip + reorder.length == lambdaForm.arity);
1092         if (nullPerm)  return lambdaForm;  // do not bother to cache
1093         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);
1094         LambdaForm form = getInCache(key);
1095         if (form != null) {
1096             assert(form.arity == skip+inTypes) : form;
1097             return form;
1098         }
1099 
1100         BasicType[] types = new BasicType[inTypes];
1101         for (int i = 0; i &lt; outArgs; i++) {
1102             int inArg = reorder[i];
1103             types[inArg] = lambdaForm.names[skip + i].type;
1104         }
1105         assert (skip + outArgs == lambdaForm.arity);
1106         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
1107         int pos = 0;
1108         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
1109             pos += 1;
1110         }
1111         Name[] names2 = new Name[length - outArgs + inTypes];
1112         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1113         int bodyLength = length - lambdaForm.arity;
1114         System.arraycopy(lambdaForm.names, skip + outArgs, names2, skip + inTypes, bodyLength);
1115         int arity2 = names2.length - bodyLength;
1116         int result2 = lambdaForm.result;
1117         if (result2 &gt;= skip) {
1118             if (result2 &lt; skip + outArgs) {
1119                 result2 = reorder[result2 - skip] + skip;
1120             } else {
1121                 result2 = result2 - outArgs + inTypes;
1122             }
1123         }
1124         for (int j = pos; j &lt; outArgs; j++) {
1125             Name n = lambdaForm.names[skip + j];
1126             int i = reorder[j];
1127             Name n2 = names2[skip + i];
1128             if (n2 == null) {
1129                 names2[skip + i] = n2 = new Name(types[i]);
1130             } else {
1131                 assert (n2.type == types[i]);
1132             }
1133             for (int k = arity2; k &lt; names2.length; k++) {
1134                 names2[k] = names2[k].replaceName(n, n2);
1135             }
1136         }
1137         for (int i = skip + pos; i &lt; arity2; i++) {
1138             if (names2[i] == null) {
1139                 names2[i] = argument(i, types[i - skip]);
1140             }
1141         }
1142         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1143             int i = j - lambdaForm.arity + arity2;
1144             Name n = lambdaForm.names[j];
1145             Name n2 = names2[i];
1146             if (n != n2) {
1147                 for (int k = i + 1; k &lt; names2.length; k++) {
1148                     names2[k] = names2[k].replaceName(n, n2);
1149                 }
1150             }
1151         }
1152 
1153         form = new LambdaForm(arity2, names2, result2);
1154         return putInCache(key, form);
1155     }
1156 
1157     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1158         assert(lambdaForm.isLoop(pos));
1159         int[] desc = BasicType.basicTypeOrds(localTypes);
1160         desc = Arrays.copyOf(desc, desc.length + 1);
1161         desc[desc.length - 1] = pos;
1162         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);
1163         LambdaForm form = getInCache(key);
1164         if (form != null) {
1165             return form;
1166         }
1167 
1168         // replace the null entry in the MHImpl.loop invocation with localTypes
1169         Name invokeLoop = lambdaForm.names[pos + 1];
1170         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1171         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1172         assert(args[0] == null);
1173         args[0] = localTypes;
1174 
1175         LambdaFormBuffer buf = buffer();
1176         buf.startEdit();
1177         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1178         form = buf.endEdit();
1179 
1180         return putInCache(key, form);
1181     }
1182 
1183     static boolean permutedTypesMatch(int[] reorder, BasicType[] types, Name[] names, int skip) {
1184         for (int i = 0; i &lt; reorder.length; i++) {
1185             assert (names[skip + i].isParam());
1186             assert (names[skip + i].type == types[reorder[i]]);
1187         }
1188         return true;
1189     }
1190 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
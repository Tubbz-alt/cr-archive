<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import sun.invoke.util.Wrapper;
  29 
<a name="1" id="anc1"></a>
  30 import java.lang.ref.SoftReference;
  31 import java.util.Arrays;
  32 import java.util.Collections;
  33 import java.util.Comparator;
  34 import java.util.TreeMap;
  35 import java.util.concurrent.ConcurrentHashMap;
  36 
  37 import static java.lang.invoke.LambdaForm.*;
  38 import static java.lang.invoke.LambdaForm.BasicType.*;
  39 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  40 import static java.lang.invoke.MethodHandleImpl.NF_loop;
  41 
  42 /** Transforms on LFs.
  43  *  A lambda-form editor can derive new LFs from its base LF.
  44  *  The editor can cache derived LFs, which simplifies the reuse of their underlying bytecodes.
  45  *  To support this caching, a LF has an optional pointer to its editor.
  46  */
  47 class LambdaFormEditor {
  48     final LambdaForm lambdaForm;
  49 
  50     private LambdaFormEditor(LambdaForm lambdaForm) {
  51         this.lambdaForm = lambdaForm;
  52     }
  53 
  54     // Factory method.
  55     static LambdaFormEditor lambdaFormEditor(LambdaForm lambdaForm) {
  56         // TO DO:  Consider placing intern logic here, to cut down on duplication.
  57         // lambdaForm = findPreexistingEquivalent(lambdaForm)
  58 
  59         // Always use uncustomized version for editing.
  60         // It helps caching and customized LambdaForms reuse transformCache field to keep a link to uncustomized version.
  61         return new LambdaFormEditor(lambdaForm.uncustomize());
  62     }
  63 
  64     // Transform types
  65     // maybe add more for guard with test, catch exception, pointwise type conversions
  66     private static final byte
  67             BIND_ARG = 1,
  68             ADD_ARG = 2,
  69             DUP_ARG = 3,
  70             SPREAD_ARGS = 4,
  71             FILTER_ARG = 5,
  72             FILTER_RETURN = 6,
  73             FILTER_RETURN_TO_ZERO = 7,
  74             COLLECT_ARGS = 8,
  75             COLLECT_ARGS_TO_VOID = 9,
  76             COLLECT_ARGS_TO_ARRAY = 10,
  77             FOLD_ARGS = 11,
  78             FOLD_ARGS_TO_VOID = 12,
  79             PERMUTE_ARGS = 13,
  80             LOCAL_TYPES = 14,
  81             FOLD_SELECT_ARGS = 15,
  82             FOLD_SELECT_ARGS_TO_VOID = 16,
  83             FILTER_SELECT_ARGS = 17,
  84             REPEAT_FILTER_ARGS = 18;
  85 
  86     /**
  87      * A description of a cached transform, possibly associated with the result of the transform.
  88      * The logical content is a sequence of byte values, starting with a kind value.
  89      * The sequence is unterminated, ending with an indefinite number of zero bytes.
  90      * Sequences that are simple (short enough and with small enough values) pack into a 64-bit long.
  91      *
  92      * Tightly coupled with the TransformKey class, which is used to lookup existing
  93      * Transforms.
  94      */
  95     private static final class Transform extends SoftReference&lt;LambdaForm&gt; {
  96         final long packedBytes;
  97         final byte[] fullBytes;
  98 
  99         private Transform(long packedBytes, byte[] fullBytes, LambdaForm result) {
 100             super(result);
 101             this.packedBytes = packedBytes;
 102             this.fullBytes = fullBytes;
 103         }
 104 
 105         @Override
 106         public boolean equals(Object obj) {
 107             if (obj instanceof TransformKey) {
 108                 return equals((TransformKey) obj);
 109             }
 110             return obj instanceof Transform &amp;&amp; equals((Transform)obj);
 111         }
 112 
 113         private boolean equals(TransformKey that) {
 114             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 115         }
 116 
 117         private boolean equals(Transform that) {
 118             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 119         }
 120 
 121         @Override
 122         public int hashCode() {
 123             if (packedBytes != 0) {
 124                 assert(fullBytes == null);
 125                 return Long.hashCode(packedBytes);
 126             }
 127             return Arrays.hashCode(fullBytes);
 128         }
 129 
 130         @Override
 131         public String toString() {
 132             StringBuilder buf = new StringBuilder();
 133             buf.append(new TransformKey(packedBytes, fullBytes).toString());
 134             LambdaForm result = get();
 135             if (result != null) {
 136                 buf.append(&quot; result=&quot;);
 137                 buf.append(result);
 138             }
 139             return buf.toString();
 140         }
 141     }
 142 
 143     /**
 144      * Used as a lookup key to find existing Transforms
 145      */
 146     private static final class TransformKey {
 147         final long packedBytes;
 148         final byte[] fullBytes;
 149 
 150         private TransformKey(long packedBytes) {
 151             this.packedBytes = packedBytes;
 152             this.fullBytes = null;
 153         }
 154 
 155         private TransformKey(byte[] fullBytes) {
 156             this.fullBytes = fullBytes;
 157             this.packedBytes = 0;
 158         }
 159 
 160         private TransformKey(long packedBytes, byte[] fullBytes) {
 161             this.fullBytes = fullBytes;
 162             this.packedBytes = packedBytes;
 163         }
 164 
 165         private static byte bval(int b) {
 166             assert((b &amp; 0xFF) == b);  // incoming value must fit in *unsigned* byte
 167             return (byte)b;
 168         }
 169         static TransformKey of(byte k, int b1) {
 170             byte b0 = bval(k);
 171             if (inRange(b0 | b1))
 172                 return new TransformKey(packedBytes(b0, b1));
 173             else
 174                 return new TransformKey(fullBytes(b0, b1));
 175         }
 176         static TransformKey of(byte b0, int b1, int b2) {
 177             if (inRange(b0 | b1 | b2))
 178                 return new TransformKey(packedBytes(b0, b1, b2));
 179             else
 180                 return new TransformKey(fullBytes(b0, b1, b2));
 181         }
 182         static TransformKey of(byte b0, int b1, int b2, int b3) {
 183             if (inRange(b0 | b1 | b2 | b3))
 184                 return new TransformKey(packedBytes(b0, b1, b2, b3));
 185             else
 186                 return new TransformKey(fullBytes(b0, b1, b2, b3));
 187         }
 188         private static final byte[] NO_BYTES = {};
 189         static TransformKey of(byte kind, int... b123) {
 190             return ofBothArrays(kind, b123, NO_BYTES);
 191         }
 192 
 193         static TransformKey of(byte kind, int b1, int[] b23456) {
 194             byte[] fullBytes = new byte[b23456.length + 2];
 195             fullBytes[0] = kind;
 196             fullBytes[1] = bval(b1);
 197             for (int i = 0; i &lt; b23456.length; i++) {
 198                 fullBytes[i + 2] = TransformKey.bval(b23456[i]);
 199             }
 200             long packedBytes = packedBytes(fullBytes);
 201             if (packedBytes != 0)
 202                 return new TransformKey(packedBytes);
 203             else
 204                 return new TransformKey(fullBytes);
 205         }
 206 
 207         static TransformKey of(byte kind, int b1, int b2, byte[] b345) {
 208             return ofBothArrays(kind, new int[]{ b1, b2 }, b345);
 209         }
 210         private static TransformKey ofBothArrays(byte kind, int[] b123, byte[] b456) {
 211             byte[] fullBytes = new byte[1 + b123.length + b456.length];
 212             int i = 0;
 213             fullBytes[i++] = bval(kind);
 214             for (int bv : b123) {
 215                 fullBytes[i++] = bval(bv);
 216             }
 217             for (byte bv : b456) {
 218                 fullBytes[i++] = bv;
 219             }
 220             long packedBytes = packedBytes(fullBytes);
 221             if (packedBytes != 0)
 222                 return new TransformKey(packedBytes);
 223             else
 224                 return new TransformKey(fullBytes);
 225         }
 226 
 227         private static final boolean STRESS_TEST = false; // turn on to disable most packing
 228         private static final int
 229                 PACKED_BYTE_SIZE = (STRESS_TEST ? 2 : 4),
 230                 PACKED_BYTE_MASK = (1 &lt;&lt; PACKED_BYTE_SIZE) - 1,
 231                 PACKED_BYTE_MAX_LENGTH = (STRESS_TEST ? 3 : 64 / PACKED_BYTE_SIZE);
 232 
 233         private static long packedBytes(byte[] bytes) {
 234             if (!inRange(bytes[0]) || bytes.length &gt; PACKED_BYTE_MAX_LENGTH)
 235                 return 0;
 236             long pb = 0;
 237             int bitset = 0;
 238             for (int i = 0; i &lt; bytes.length; i++) {
 239                 int b = bytes[i] &amp; 0xFF;
 240                 bitset |= b;
 241                 pb |= (long)b &lt;&lt; (i * PACKED_BYTE_SIZE);
 242             }
 243             if (!inRange(bitset))
 244                 return 0;
 245             return pb;
 246         }
 247         private static long packedBytes(int b0, int b1) {
 248             assert(inRange(b0 | b1));
 249             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 250                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE));
 251         }
 252         private static long packedBytes(int b0, int b1, int b2) {
 253             assert(inRange(b0 | b1 | b2));
 254             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 255                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 256                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE));
 257         }
 258         private static long packedBytes(int b0, int b1, int b2, int b3) {
 259             assert(inRange(b0 | b1 | b2 | b3));
 260             return (  (b0 &lt;&lt; 0*PACKED_BYTE_SIZE)
 261                     | (b1 &lt;&lt; 1*PACKED_BYTE_SIZE)
 262                     | (b2 &lt;&lt; 2*PACKED_BYTE_SIZE)
 263                     | (b3 &lt;&lt; 3*PACKED_BYTE_SIZE));
 264         }
 265         private static boolean inRange(int bitset) {
 266             assert((bitset &amp; 0xFF) == bitset);  // incoming values must fit in *unsigned* byte
 267             return ((bitset &amp; ~PACKED_BYTE_MASK) == 0);
 268         }
 269         private static byte[] fullBytes(int... byteValues) {
 270             byte[] bytes = new byte[byteValues.length];
 271             int i = 0;
 272             for (int bv : byteValues) {
 273                 bytes[i++] = bval(bv);
 274             }
 275             assert(packedBytes(bytes) == 0);
 276             return bytes;
 277         }
 278 
 279         Transform withResult(LambdaForm result) {
 280             return new Transform(this.packedBytes, this.fullBytes, result);
 281         }
 282 
 283         @Override
 284         public String toString() {
 285             StringBuilder buf = new StringBuilder();
 286             long bits = packedBytes;
 287             if (bits != 0) {
 288                 buf.append(&quot;(&quot;);
 289                 while (bits != 0) {
 290                     buf.append(bits &amp; PACKED_BYTE_MASK);
 291                     bits &gt;&gt;&gt;= PACKED_BYTE_SIZE;
 292                     if (bits != 0)  buf.append(&quot;,&quot;);
 293                 }
 294                 buf.append(&quot;)&quot;);
 295             }
 296             if (fullBytes != null) {
 297                 buf.append(&quot;unpacked&quot;);
 298                 buf.append(Arrays.toString(fullBytes));
 299             }
 300             return buf.toString();
 301         }
 302 
 303         @Override
 304         public boolean equals(Object obj) {
 305             if (obj instanceof TransformKey) {
 306                 return equals((TransformKey) obj);
 307             }
 308             return obj instanceof Transform &amp;&amp; equals((Transform)obj);
 309         }
 310 
 311         private boolean equals(TransformKey that) {
 312             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 313         }
 314 
 315         private boolean equals(Transform that) {
 316             return this.packedBytes == that.packedBytes &amp;&amp; Arrays.equals(this.fullBytes, that.fullBytes);
 317         }
 318 
 319         @Override
 320         public int hashCode() {
 321             if (packedBytes != 0) {
 322                 assert(fullBytes == null);
 323                 return Long.hashCode(packedBytes);
 324             }
 325             return Arrays.hashCode(fullBytes);
 326         }
 327     }
 328 
 329     /** Find a previously cached transform equivalent to the given one, and return its result. */
 330     private LambdaForm getInCache(TransformKey key) {
 331         // The transformCache is one of null, Transform, Transform[], or ConcurrentHashMap.
 332         Object c = lambdaForm.transformCache;
 333         Transform k = null;
 334         if (c instanceof ConcurrentHashMap) {
 335             @SuppressWarnings(&quot;unchecked&quot;)
 336             ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 337             k = m.get(key);
 338         } else if (c == null) {
 339             return null;
 340         } else if (c instanceof Transform) {
 341             // one-element cache avoids overhead of an array
 342             Transform t = (Transform)c;
 343             if (t.equals(key))  k = t;
 344         } else {
 345             Transform[] ta = (Transform[])c;
 346             for (int i = 0; i &lt; ta.length; i++) {
 347                 Transform t = ta[i];
 348                 if (t == null)  break;
 349                 if (t.equals(key)) { k = t; break; }
 350             }
 351         }
 352         assert(k == null || key.equals(k));
 353         return (k != null) ? k.get() : null;
 354     }
 355 
 356     /** Arbitrary but reasonable limits on Transform[] size for cache. */
 357     private static final int MIN_CACHE_ARRAY_SIZE = 4, MAX_CACHE_ARRAY_SIZE = 16;
 358 
 359     /** Cache a transform with its result, and return that result.
 360      *  But if an equivalent transform has already been cached, return its result instead.
 361      */
 362     private LambdaForm putInCache(TransformKey key, LambdaForm form) {
 363         Transform transform = key.withResult(form);
 364         for (int pass = 0; ; pass++) {
 365             Object c = lambdaForm.transformCache;
 366             if (c instanceof ConcurrentHashMap) {
 367                 @SuppressWarnings(&quot;unchecked&quot;)
 368                 ConcurrentHashMap&lt;Transform,Transform&gt; m = (ConcurrentHashMap&lt;Transform,Transform&gt;) c;
 369                 Transform k = m.putIfAbsent(transform, transform);
 370                 if (k == null) return form;
 371                 LambdaForm result = k.get();
 372                 if (result != null) {
 373                     return result;
 374                 } else {
 375                     if (m.replace(transform, k, transform)) {
 376                         return form;
 377                     } else {
 378                         continue;
 379                     }
 380                 }
 381             }
 382             assert(pass == 0);
 383             synchronized (lambdaForm) {
 384                 c = lambdaForm.transformCache;
 385                 if (c instanceof ConcurrentHashMap)
 386                     continue;
 387                 if (c == null) {
 388                     lambdaForm.transformCache = transform;
 389                     return form;
 390                 }
 391                 Transform[] ta;
 392                 if (c instanceof Transform) {
 393                     Transform k = (Transform)c;
 394                     if (k.equals(key)) {
 395                         LambdaForm result = k.get();
 396                         if (result == null) {
 397                             lambdaForm.transformCache = transform;
 398                             return form;
 399                         } else {
 400                             return result;
 401                         }
 402                     } else if (k.get() == null) { // overwrite stale entry
 403                         lambdaForm.transformCache = transform;
 404                         return form;
 405                     }
 406                     // expand one-element cache to small array
 407                     ta = new Transform[MIN_CACHE_ARRAY_SIZE];
 408                     ta[0] = k;
 409                     lambdaForm.transformCache = ta;
 410                 } else {
 411                     // it is already expanded
 412                     ta = (Transform[])c;
 413                 }
 414                 int len = ta.length;
 415                 int stale = -1;
 416                 int i;
 417                 for (i = 0; i &lt; len; i++) {
 418                     Transform k = ta[i];
 419                     if (k == null) {
 420                         break;
 421                     }
 422                     if (k.equals(transform)) {
 423                         LambdaForm result = k.get();
 424                         if (result == null) {
 425                             ta[i] = transform;
 426                             return form;
 427                         } else {
 428                             return result;
 429                         }
 430                     } else if (stale &lt; 0 &amp;&amp; k.get() == null) {
 431                         stale = i; // remember 1st stale entry index
 432                     }
 433                 }
 434                 if (i &lt; len || stale &gt;= 0) {
 435                     // just fall through to cache update
 436                 } else if (len &lt; MAX_CACHE_ARRAY_SIZE) {
 437                     len = Math.min(len * 2, MAX_CACHE_ARRAY_SIZE);
 438                     ta = Arrays.copyOf(ta, len);
 439                     lambdaForm.transformCache = ta;
 440                 } else {
 441                     ConcurrentHashMap&lt;Transform, Transform&gt; m = new ConcurrentHashMap&lt;&gt;(MAX_CACHE_ARRAY_SIZE * 2);
 442                     for (Transform k : ta) {
 443                         m.put(k, k);
 444                     }
 445                     lambdaForm.transformCache = m;
 446                     // The second iteration will update for this query, concurrently.
 447                     continue;
 448                 }
 449                 int idx = (stale &gt;= 0) ? stale : i;
 450                 ta[idx] = transform;
 451                 return form;
 452             }
 453         }
 454     }
 455 
 456     private LambdaFormBuffer buffer() {
 457         return new LambdaFormBuffer(lambdaForm);
 458     }
 459 
 460     /// Editing methods for method handles.  These need to have fast paths.
 461 
 462     private BoundMethodHandle.SpeciesData oldSpeciesData() {
 463         return BoundMethodHandle.speciesDataFor(lambdaForm);
 464     }
 465 
 466     private BoundMethodHandle.SpeciesData newSpeciesData(BasicType type) {
 467         return oldSpeciesData().extendWith((byte) type.ordinal());
 468     }
 469 
 470     BoundMethodHandle bindArgumentL(BoundMethodHandle mh, int pos, Object value) {
 471         assert(mh.speciesData() == oldSpeciesData());
 472         BasicType bt = L_TYPE;
 473         MethodType type2 = bindArgumentType(mh, pos, bt);
 474         LambdaForm form2 = bindArgumentForm(1+pos);
 475         return mh.copyWithExtendL(type2, form2, value);
 476     }
 477     BoundMethodHandle bindArgumentI(BoundMethodHandle mh, int pos, int value) {
 478         assert(mh.speciesData() == oldSpeciesData());
 479         BasicType bt = I_TYPE;
 480         MethodType type2 = bindArgumentType(mh, pos, bt);
 481         LambdaForm form2 = bindArgumentForm(1+pos);
 482         return mh.copyWithExtendI(type2, form2, value);
 483     }
 484 
 485     BoundMethodHandle bindArgumentJ(BoundMethodHandle mh, int pos, long value) {
 486         assert(mh.speciesData() == oldSpeciesData());
 487         BasicType bt = J_TYPE;
 488         MethodType type2 = bindArgumentType(mh, pos, bt);
 489         LambdaForm form2 = bindArgumentForm(1+pos);
 490         return mh.copyWithExtendJ(type2, form2, value);
 491     }
 492 
 493     BoundMethodHandle bindArgumentF(BoundMethodHandle mh, int pos, float value) {
 494         assert(mh.speciesData() == oldSpeciesData());
 495         BasicType bt = F_TYPE;
 496         MethodType type2 = bindArgumentType(mh, pos, bt);
 497         LambdaForm form2 = bindArgumentForm(1+pos);
 498         return mh.copyWithExtendF(type2, form2, value);
 499     }
 500 
 501     BoundMethodHandle bindArgumentD(BoundMethodHandle mh, int pos, double value) {
 502         assert(mh.speciesData() == oldSpeciesData());
 503         BasicType bt = D_TYPE;
 504         MethodType type2 = bindArgumentType(mh, pos, bt);
 505         LambdaForm form2 = bindArgumentForm(1+pos);
 506         return mh.copyWithExtendD(type2, form2, value);
 507     }
 508 
 509     private MethodType bindArgumentType(BoundMethodHandle mh, int pos, BasicType bt) {
 510         assert(mh.form.uncustomize() == lambdaForm);
 511         assert(mh.form.names[1+pos].type == bt);
 512         assert(BasicType.basicType(mh.type().parameterType(pos)) == bt);
 513         return mh.type().dropParameterTypes(pos, pos+1);
 514     }
 515 
 516     /// Editing methods for lambda forms.
 517     // Each editing method can (potentially) cache the edited LF so that it can be reused later.
 518 
 519     LambdaForm bindArgumentForm(int pos) {
 520         TransformKey key = TransformKey.of(BIND_ARG, pos);
 521         LambdaForm form = getInCache(key);
 522         if (form != null) {
 523             assert(form.parameterConstraint(0) == newSpeciesData(lambdaForm.parameterType(pos)));
 524             return form;
 525         }
 526         LambdaFormBuffer buf = buffer();
 527         buf.startEdit();
 528 
 529         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 530         BoundMethodHandle.SpeciesData newData = newSpeciesData(lambdaForm.parameterType(pos));
 531         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 532         Name newBaseAddress;
 533         NamedFunction getter = newData.getterFunction(oldData.fieldCount());
 534 
 535         if (pos != 0) {
 536             // The newly created LF will run with a different BMH.
 537             // Switch over any pre-existing BMH field references to the new BMH class.
 538             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 539             newBaseAddress = oldBaseAddress.withConstraint(newData);
 540             buf.renameParameter(0, newBaseAddress);
 541             buf.replaceParameterByNewExpression(pos, new Name(getter, newBaseAddress));
 542         } else {
 543             // cannot bind the MH arg itself, unless oldData is empty
 544             assert(oldData == BoundMethodHandle.SPECIALIZER.topSpecies());
 545             newBaseAddress = new Name(L_TYPE).withConstraint(newData);
 546             buf.replaceParameterByNewExpression(0, new Name(getter, newBaseAddress));
 547             buf.insertParameter(0, newBaseAddress);
 548         }
 549 
 550         form = buf.endEdit();
 551         return putInCache(key, form);
 552     }
 553 
 554     LambdaForm addArgumentForm(int pos, BasicType type) {
 555         TransformKey key = TransformKey.of(ADD_ARG, pos, type.ordinal());
 556         LambdaForm form = getInCache(key);
 557         if (form != null) {
 558             assert(form.arity == lambdaForm.arity+1);
 559             assert(form.parameterType(pos) == type);
 560             return form;
 561         }
 562         LambdaFormBuffer buf = buffer();
 563         buf.startEdit();
 564 
 565         buf.insertParameter(pos, new Name(type));
 566 
 567         form = buf.endEdit();
 568         return putInCache(key, form);
 569     }
 570 
 571     LambdaForm dupArgumentForm(int srcPos, int dstPos) {
 572         TransformKey key = TransformKey.of(DUP_ARG, srcPos, dstPos);
 573         LambdaForm form = getInCache(key);
 574         if (form != null) {
 575             assert(form.arity == lambdaForm.arity-1);
 576             return form;
 577         }
 578         LambdaFormBuffer buf = buffer();
 579         buf.startEdit();
 580 
 581         assert(lambdaForm.parameter(srcPos).constraint == null);
 582         assert(lambdaForm.parameter(dstPos).constraint == null);
 583         buf.replaceParameterByCopy(dstPos, srcPos);
 584 
 585         form = buf.endEdit();
 586         return putInCache(key, form);
 587     }
 588 
 589     LambdaForm spreadArgumentsForm(int pos, Class&lt;?&gt; arrayType, int arrayLength) {
 590         Class&lt;?&gt; elementType = arrayType.getComponentType();
 591         Class&lt;?&gt; erasedArrayType = arrayType;
 592         if (!elementType.isPrimitive())
 593             erasedArrayType = Object[].class;
 594         BasicType bt = basicType(elementType);
 595         int elementTypeKey = bt.ordinal();
 596         if (bt.basicTypeClass() != elementType) {
 597             if (elementType.isPrimitive()) {
 598                 elementTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 599             }
 600         }
 601         TransformKey key = TransformKey.of(SPREAD_ARGS, pos, elementTypeKey, arrayLength);
 602         LambdaForm form = getInCache(key);
 603         if (form != null) {
 604             assert(form.arity == lambdaForm.arity - arrayLength + 1);
 605             return form;
 606         }
 607         LambdaFormBuffer buf = buffer();
 608         buf.startEdit();
 609 
 610         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 611         assert(pos + arrayLength &lt;= lambdaForm.arity);
 612         assert(pos &gt; 0);  // cannot spread the MH arg itself
 613 
 614         Name spreadParam = new Name(L_TYPE);
 615         Name checkSpread = new Name(MethodHandleImpl.getFunction(MethodHandleImpl.NF_checkSpreadArgument),
 616                 spreadParam, arrayLength);
 617 
 618         // insert the new expressions
 619         int exprPos = lambdaForm.arity();
 620         buf.insertExpression(exprPos++, checkSpread);
 621         // adjust the arguments
 622         MethodHandle aload = MethodHandles.arrayElementGetter(erasedArrayType);
 623         for (int i = 0; i &lt; arrayLength; i++) {
 624             Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);
 625             buf.insertExpression(exprPos + i, loadArgument);
 626             buf.replaceParameterByCopy(pos + i, exprPos + i);
 627         }
 628         buf.insertParameter(pos, spreadParam);
 629 
 630         form = buf.endEdit();
 631         return putInCache(key, form);
 632     }
 633 
 634     LambdaForm collectArgumentsForm(int pos, MethodType collectorType) {
 635         int collectorArity = collectorType.parameterCount();
 636         boolean dropResult = (collectorType.returnType() == void.class);
 637         if (collectorArity == 1 &amp;&amp; !dropResult) {
 638             return filterArgumentForm(pos, basicType(collectorType.parameterType(0)));
 639         }
 640         byte[] newTypes = BasicType.basicTypesOrd(collectorType.ptypes());
 641         byte kind = (dropResult ? COLLECT_ARGS_TO_VOID : COLLECT_ARGS);
 642         if (dropResult &amp;&amp; collectorArity == 0)  pos = 1;  // pure side effect
 643         TransformKey key = TransformKey.of(kind, pos, collectorArity, newTypes);
 644         LambdaForm form = getInCache(key);
 645         if (form != null) {
 646             assert(form.arity == lambdaForm.arity - (dropResult ? 0 : 1) + collectorArity);
 647             return form;
 648         }
 649         form = makeArgumentCombinationForm(pos, collectorType, false, dropResult);
 650         return putInCache(key, form);
 651     }
 652 
 653     LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {
 654         MethodType collectorType = arrayCollector.type();
 655         int collectorArity = collectorType.parameterCount();
 656         assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);
 657         Class&lt;?&gt; arrayType = collectorType.returnType();
 658         Class&lt;?&gt; elementType = arrayType.getComponentType();
 659         BasicType argType = basicType(elementType);
 660         int argTypeKey = argType.ordinal();
 661         if (argType.basicTypeClass() != elementType) {
 662             // return null if it requires more metadata (like String[].class)
 663             if (!elementType.isPrimitive())
 664                 return null;
 665             argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();
 666         }
 667         assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));
 668         byte kind = COLLECT_ARGS_TO_ARRAY;
 669         TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);
 670         LambdaForm form = getInCache(key);
 671         if (form != null) {
 672             assert(form.arity == lambdaForm.arity - 1 + collectorArity);
 673             return form;
 674         }
 675         LambdaFormBuffer buf = buffer();
 676         buf.startEdit();
 677 
 678         assert(pos + 1 &lt;= lambdaForm.arity);
 679         assert(pos &gt; 0);  // cannot filter the MH arg itself
 680 
 681         Name[] newParams = new Name[collectorArity];
 682         for (int i = 0; i &lt; collectorArity; i++) {
 683             newParams[i] = new Name(pos + i, argType);
 684         }
 685         Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),
 686                                         (Object[]) /*...*/ newParams);
 687 
 688         // insert the new expression
 689         int exprPos = lambdaForm.arity();
 690         buf.insertExpression(exprPos, callCombiner);
 691 
 692         // insert new arguments
 693         int argPos = pos + 1;  // skip result parameter
 694         for (Name newParam : newParams) {
 695             buf.insertParameter(argPos++, newParam);
 696         }
 697         assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);
 698         buf.replaceParameterByCopy(pos, exprPos+newParams.length);
 699 
 700         form = buf.endEdit();
 701         return putInCache(key, form);
 702     }
 703 
 704     LambdaForm filterArgumentForm(int pos, BasicType newType) {
 705         TransformKey key = TransformKey.of(FILTER_ARG, pos, newType.ordinal());
 706         LambdaForm form = getInCache(key);
 707         if (form != null) {
 708             assert(form.arity == lambdaForm.arity);
 709             assert(form.parameterType(pos) == newType);
 710             return form;
 711         }
 712 
 713         BasicType oldType = lambdaForm.parameterType(pos);
 714         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 715                 newType.basicTypeClass());
 716         form = makeArgumentCombinationForm(pos, filterType, false, false);
 717         return putInCache(key, form);
 718     }
 719 
 720     /**
 721      * This creates a LF that will repeatedly invoke some unary filter function
 722      * at each of the given positions. This allows fewer LFs and BMH species
 723      * classes to be generated in typical cases compared to building up the form
 724      * by reapplying of {@code filterArgumentForm(int,BasicType)}, and should do
 725      * no worse in the worst case.
 726      */
 727     LambdaForm filterRepeatedArgumentForm(BasicType newType, int... argPositions) {
 728         assert (argPositions.length &gt; 1);
 729         TransformKey key = TransformKey.of(REPEAT_FILTER_ARGS, newType.ordinal(), argPositions);
 730         LambdaForm form = getInCache(key);
 731         if (form != null) {
 732             assert(form.arity == lambdaForm.arity &amp;&amp;
 733                     formParametersMatch(form, newType, argPositions));
 734             return form;
 735         }
 736         BasicType oldType = lambdaForm.parameterType(argPositions[0]);
 737         MethodType filterType = MethodType.methodType(oldType.basicTypeClass(),
 738                 newType.basicTypeClass());
 739         form = makeRepeatedFilterForm(filterType, argPositions);
 740         assert (formParametersMatch(form, newType, argPositions));
 741         return putInCache(key, form);
 742     }
 743 
 744     private boolean formParametersMatch(LambdaForm form, BasicType newType, int... argPositions) {
 745         for (int i : argPositions) {
 746             if (form.parameterType(i) != newType) {
 747                 return false;
 748             }
 749         }
 750         return true;
 751     }
 752 
 753     private LambdaForm makeRepeatedFilterForm(MethodType combinerType, int... positions) {
 754         assert (combinerType.parameterCount() == 1 &amp;&amp;
 755                 combinerType == combinerType.basicType() &amp;&amp;
 756                 combinerType.returnType() != void.class);
 757         LambdaFormBuffer buf = buffer();
 758         buf.startEdit();
 759 
 760         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 761         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 762 
 763         // The newly created LF will run with a different BMH.
 764         // Switch over any pre-existing BMH field references to the new BMH class.
 765         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 766         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 767         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 768         buf.renameParameter(0, newBaseAddress);
 769 
 770         // Insert the new expressions at the end
 771         int exprPos = lambdaForm.arity();
 772         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 773         buf.insertExpression(exprPos++, getCombiner);
 774 
 775         // After inserting expressions, we insert parameters in order
 776         // from lowest to highest, simplifying the calculation of where parameters
 777         // and expressions are
 778         var newParameters = new TreeMap&lt;Name, Integer&gt;(new Comparator&lt;&gt;() {
 779             public int compare(Name n1, Name n2) {
 780                 return n1.index - n2.index;
 781             }
 782         });
 783 
 784         // Insert combiner expressions in reverse order so that the invocation of
 785         // the resulting form will invoke the combiners in left-to-right order
 786         for (int i = positions.length - 1; i &gt;= 0; --i) {
 787             int pos = positions[i];
 788             assert (pos &gt; 0 &amp;&amp; pos &lt;= MethodType.MAX_JVM_ARITY &amp;&amp; pos &lt; lambdaForm.arity);
 789 
 790             Name newParameter = new Name(pos, basicType(combinerType.parameterType(0)));
 791             Object[] combinerArgs = {getCombiner, newParameter};
 792 
 793             Name callCombiner = new Name(combinerType, combinerArgs);
 794             buf.insertExpression(exprPos++, callCombiner);
 795             newParameters.put(newParameter, exprPos);
 796         }
 797 
 798         // Mix in new parameters from left to right in the buffer (this doesn&#39;t change
 799         // execution order
 800         int offset = 0;
 801         for (var entry : newParameters.entrySet()) {
 802             Name newParameter = entry.getKey();
 803             int from = entry.getValue();
 804             buf.insertParameter(newParameter.index() + 1 + offset, newParameter);
 805             buf.replaceParameterByCopy(newParameter.index() + offset, from + offset);
 806             offset++;
 807         }
 808         return buf.endEdit();
 809     }
 810 
 811 
 812     private LambdaForm makeArgumentCombinationForm(int pos,
 813                                                    MethodType combinerType,
 814                                                    boolean keepArguments, boolean dropResult) {
 815         LambdaFormBuffer buf = buffer();
 816         buf.startEdit();
 817         int combinerArity = combinerType.parameterCount();
 818         int resultArity = (dropResult ? 0 : 1);
 819 
 820         assert(pos &lt;= MethodType.MAX_JVM_ARITY);
 821         assert(pos + resultArity + (keepArguments ? combinerArity : 0) &lt;= lambdaForm.arity);
 822         assert(pos &gt; 0);  // cannot filter the MH arg itself
 823         assert(combinerType == combinerType.basicType());
 824         assert(combinerType.returnType() != void.class || dropResult);
 825 
 826         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 827         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 828 
 829         // The newly created LF will run with a different BMH.
 830         // Switch over any pre-existing BMH field references to the new BMH class.
 831         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 832         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 833         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 834         buf.renameParameter(0, newBaseAddress);
 835 
 836         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 837         Object[] combinerArgs = new Object[1 + combinerArity];
 838         combinerArgs[0] = getCombiner;
 839         Name[] newParams;
 840         if (keepArguments) {
 841             newParams = new Name[0];
 842             System.arraycopy(lambdaForm.names, pos + resultArity,
 843                              combinerArgs, 1, combinerArity);
 844         } else {
 845             newParams = new Name[combinerArity];
 846             for (int i = 0; i &lt; newParams.length; i++) {
 847                 newParams[i] = new Name(pos + i, basicType(combinerType.parameterType(i)));
 848             }
 849             System.arraycopy(newParams, 0,
 850                              combinerArgs, 1, combinerArity);
 851         }
 852         Name callCombiner = new Name(combinerType, combinerArgs);
 853 
 854         // insert the two new expressions
 855         int exprPos = lambdaForm.arity();
 856         buf.insertExpression(exprPos+0, getCombiner);
 857         buf.insertExpression(exprPos+1, callCombiner);
 858 
 859         // insert new arguments, if needed
 860         int argPos = pos + resultArity;  // skip result parameter
 861         for (Name newParam : newParams) {
 862             buf.insertParameter(argPos++, newParam);
 863         }
 864         assert(buf.lastIndexOf(callCombiner) == exprPos+1+newParams.length);
 865         if (!dropResult) {
 866             buf.replaceParameterByCopy(pos, exprPos+1+newParams.length);
 867         }
 868 
 869         return buf.endEdit();
 870     }
 871 
 872     private LambdaForm makeArgumentCombinationForm(int pos,
 873                                                    MethodType combinerType,
 874                                                    int[] argPositions,
 875                                                    boolean keepArguments,
 876                                                    boolean dropResult) {
 877         LambdaFormBuffer buf = buffer();
 878         buf.startEdit();
 879         int combinerArity = combinerType.parameterCount();
 880         assert(combinerArity == argPositions.length);
 881 
 882         int resultArity = (dropResult ? 0 : 1);
 883 
 884         assert(pos &lt;= lambdaForm.arity);
 885         assert(pos &gt; 0);  // cannot filter the MH arg itself
 886         assert(combinerType == combinerType.basicType());
 887         assert(combinerType.returnType() != void.class || dropResult);
 888 
 889         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 890         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 891 
 892         // The newly created LF will run with a different BMH.
 893         // Switch over any pre-existing BMH field references to the new BMH class.
 894         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 895         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 896         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 897         buf.renameParameter(0, newBaseAddress);
 898 
 899         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 900         Object[] combinerArgs = new Object[1 + combinerArity];
 901         combinerArgs[0] = getCombiner;
 902         Name newParam = null;
 903         if (keepArguments) {
 904             for (int i = 0; i &lt; combinerArity; i++) {
 905                 combinerArgs[i + 1] = lambdaForm.parameter(1 + argPositions[i]);
 906                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 907             }
 908         } else {
 909             newParam = new Name(pos, BasicType.basicType(combinerType.returnType()));
 910             for (int i = 0; i &lt; combinerArity; i++) {
 911                 int argPos = 1 + argPositions[i];
 912                 if (argPos == pos) {
 913                     combinerArgs[i + 1] = newParam;
 914                 } else {
 915                     combinerArgs[i + 1] = lambdaForm.parameter(argPos);
 916                 }
 917                 assert (basicType(combinerType.parameterType(i)) == lambdaForm.parameterType(1 + argPositions[i]));
 918             }
 919         }
 920         Name callCombiner = new Name(combinerType, combinerArgs);
 921 
 922         // insert the two new expressions
 923         int exprPos = lambdaForm.arity();
 924         buf.insertExpression(exprPos+0, getCombiner);
 925         buf.insertExpression(exprPos+1, callCombiner);
 926 
 927         // insert new arguments, if needed
 928         int argPos = pos + resultArity;  // skip result parameter
 929         if (newParam != null) {
 930             buf.insertParameter(argPos++, newParam);
 931             exprPos++;
 932         }
 933         assert(buf.lastIndexOf(callCombiner) == exprPos+1);
 934         if (!dropResult) {
 935             buf.replaceParameterByCopy(pos, exprPos+1);
 936         }
 937 
 938         return buf.endEdit();
 939     }
 940 
 941     LambdaForm filterReturnForm(BasicType newType, boolean constantZero) {
 942         byte kind = (constantZero ? FILTER_RETURN_TO_ZERO : FILTER_RETURN);
 943         TransformKey key = TransformKey.of(kind, newType.ordinal());
 944         LambdaForm form = getInCache(key);
 945         if (form != null) {
 946             assert(form.arity == lambdaForm.arity);
 947             assert(form.returnType() == newType);
 948             return form;
 949         }
 950         LambdaFormBuffer buf = buffer();
 951         buf.startEdit();
 952 
 953         int insPos = lambdaForm.names.length;
 954         Name callFilter;
 955         if (constantZero) {
 956             // Synthesize a constant zero value for the given type.
 957             if (newType == V_TYPE)
 958                 callFilter = null;
 959             else
 960                 callFilter = new Name(constantZero(newType));
 961         } else {
 962             BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 963             BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 964 
 965             // The newly created LF will run with a different BMH.
 966             // Switch over any pre-existing BMH field references to the new BMH class.
 967             Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 968             buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 969             Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 970             buf.renameParameter(0, newBaseAddress);
 971 
 972             Name getFilter = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
 973             buf.insertExpression(insPos++, getFilter);
 974             BasicType oldType = lambdaForm.returnType();
 975             if (oldType == V_TYPE) {
 976                 MethodType filterType = MethodType.methodType(newType.basicTypeClass());
 977                 callFilter = new Name(filterType, getFilter);
 978             } else {
 979                 MethodType filterType = MethodType.methodType(newType.basicTypeClass(), oldType.basicTypeClass());
 980                 callFilter = new Name(filterType, getFilter, lambdaForm.names[lambdaForm.result]);
 981             }
 982         }
 983 
 984         if (callFilter != null)
 985             buf.insertExpression(insPos++, callFilter);
 986         buf.setResult(callFilter);
 987 
 988         form = buf.endEdit();
 989         return putInCache(key, form);
 990     }
 991 
 992     LambdaForm collectReturnValueForm(MethodType combinerType) {
 993         LambdaFormBuffer buf = buffer();
 994         buf.startEdit();
 995         int combinerArity = combinerType.parameterCount();
 996         int argPos = lambdaForm.arity();
 997         int exprPos = lambdaForm.names.length;
 998 
 999         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
1000         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
1001 
1002         // The newly created LF will run with a different BMH.
1003         // Switch over any pre-existing BMH field references to the new BMH class.
1004         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
1005         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
1006         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
1007         buf.renameParameter(0, newBaseAddress);
1008 
1009         // Now we set up the call to the filter
1010         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
1011 
1012         Object[] combinerArgs = new Object[combinerArity + 1];
1013         combinerArgs[0] = getCombiner; // first (synthetic) argument should be the MH that acts as a target of the invoke
1014 
1015         // set up additional adapter parameters (in case the combiner is not a unary function)
1016         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter
1017         for (int i = 0; i &lt; newParams.length; i++) {
1018             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));
1019         }
1020 
1021         // set up remaining filter parameters to point to the corresponding adapter parameters (see above)
1022         System.arraycopy(newParams, 0,
1023                 combinerArgs, 1, combinerArity - 1);
1024 
1025         // the last filter argument is set to point at the result of the target method handle
1026         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
1027         Name callCombiner = new Name(combinerType, combinerArgs);
1028 
1029         // insert the two new expressions
1030         buf.insertExpression(exprPos, getCombiner);
1031         buf.insertExpression(exprPos + 1, callCombiner);
1032 
1033         // insert additional arguments
1034         int insPos = argPos;
1035         for (Name newParam : newParams) {
1036             buf.insertParameter(insPos++, newParam);
1037         }
1038 
1039         buf.setResult(callCombiner);
1040         return buf.endEdit();
1041     }
1042 
1043     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
1044         int combinerArity = combinerType.parameterCount();
1045         byte kind = (dropResult ? FOLD_ARGS_TO_VOID : FOLD_ARGS);
1046         TransformKey key = TransformKey.of(kind, foldPos, combinerArity);
1047         LambdaForm form = getInCache(key);
1048         if (form != null) {
1049             assert(form.arity == lambdaForm.arity - (kind == FOLD_ARGS ? 1 : 0));
1050             return form;
1051         }
1052         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
1053         return putInCache(key, form);
1054     }
1055 
1056     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType, int ... argPositions) {
1057         byte kind = (dropResult ? FOLD_SELECT_ARGS_TO_VOID : FOLD_SELECT_ARGS);
1058         TransformKey key = TransformKey.of(kind, foldPos, argPositions);
1059         LambdaForm form = getInCache(key);
1060         if (form != null) {
1061             assert(form.arity == lambdaForm.arity - (kind == FOLD_SELECT_ARGS ? 1 : 0));
1062             return form;
1063         }
1064         form = makeArgumentCombinationForm(foldPos, combinerType, argPositions, true, dropResult);
1065         return putInCache(key, form);
1066     }
1067 
1068     LambdaForm filterArgumentsForm(int filterPos, MethodType combinerType, int ... argPositions) {
1069         TransformKey key = TransformKey.of(FILTER_SELECT_ARGS, filterPos, argPositions);
1070         LambdaForm form = getInCache(key);
1071         if (form != null) {
1072             assert(form.arity == lambdaForm.arity);
1073             return form;
1074         }
1075         form = makeArgumentCombinationForm(filterPos, combinerType, argPositions, false, false);
1076         return putInCache(key, form);
1077     }
1078 
1079     LambdaForm permuteArgumentsForm(int skip, int[] reorder) {
1080         assert(skip == 1);  // skip only the leading MH argument, names[0]
1081         int length = lambdaForm.names.length;
1082         int outArgs = reorder.length;
1083         int inTypes = 0;
1084         boolean nullPerm = true;
1085         for (int i = 0; i &lt; reorder.length; i++) {
1086             int inArg = reorder[i];
1087             if (inArg != i)  nullPerm = false;
1088             inTypes = Math.max(inTypes, inArg+1);
1089         }
1090         assert(skip + reorder.length == lambdaForm.arity);
1091         if (nullPerm)  return lambdaForm;  // do not bother to cache
1092         TransformKey key = TransformKey.of(PERMUTE_ARGS, reorder);
1093         LambdaForm form = getInCache(key);
1094         if (form != null) {
1095             assert(form.arity == skip+inTypes) : form;
1096             return form;
1097         }
1098 
1099         BasicType[] types = new BasicType[inTypes];
1100         for (int i = 0; i &lt; outArgs; i++) {
1101             int inArg = reorder[i];
1102             types[inArg] = lambdaForm.names[skip + i].type;
1103         }
1104         assert (skip + outArgs == lambdaForm.arity);
1105         assert (permutedTypesMatch(reorder, types, lambdaForm.names, skip));
1106         int pos = 0;
1107         while (pos &lt; outArgs &amp;&amp; reorder[pos] == pos) {
1108             pos += 1;
1109         }
1110         Name[] names2 = new Name[length - outArgs + inTypes];
1111         System.arraycopy(lambdaForm.names, 0, names2, 0, skip + pos);
1112         int bodyLength = length - lambdaForm.arity;
1113         System.arraycopy(lambdaForm.names, skip + outArgs, names2, skip + inTypes, bodyLength);
1114         int arity2 = names2.length - bodyLength;
1115         int result2 = lambdaForm.result;
1116         if (result2 &gt;= skip) {
1117             if (result2 &lt; skip + outArgs) {
1118                 result2 = reorder[result2 - skip] + skip;
1119             } else {
1120                 result2 = result2 - outArgs + inTypes;
1121             }
1122         }
1123         for (int j = pos; j &lt; outArgs; j++) {
1124             Name n = lambdaForm.names[skip + j];
1125             int i = reorder[j];
1126             Name n2 = names2[skip + i];
1127             if (n2 == null) {
1128                 names2[skip + i] = n2 = new Name(types[i]);
1129             } else {
1130                 assert (n2.type == types[i]);
1131             }
1132             for (int k = arity2; k &lt; names2.length; k++) {
1133                 names2[k] = names2[k].replaceName(n, n2);
1134             }
1135         }
1136         for (int i = skip + pos; i &lt; arity2; i++) {
1137             if (names2[i] == null) {
1138                 names2[i] = argument(i, types[i - skip]);
1139             }
1140         }
1141         for (int j = lambdaForm.arity; j &lt; lambdaForm.names.length; j++) {
1142             int i = j - lambdaForm.arity + arity2;
1143             Name n = lambdaForm.names[j];
1144             Name n2 = names2[i];
1145             if (n != n2) {
1146                 for (int k = i + 1; k &lt; names2.length; k++) {
1147                     names2[k] = names2[k].replaceName(n, n2);
1148                 }
1149             }
1150         }
1151 
1152         form = new LambdaForm(arity2, names2, result2);
1153         return putInCache(key, form);
1154     }
1155 
1156     LambdaForm noteLoopLocalTypesForm(int pos, BasicType[] localTypes) {
1157         assert(lambdaForm.isLoop(pos));
1158         int[] desc = BasicType.basicTypeOrds(localTypes);
1159         desc = Arrays.copyOf(desc, desc.length + 1);
1160         desc[desc.length - 1] = pos;
1161         TransformKey key = TransformKey.of(LOCAL_TYPES, desc);
1162         LambdaForm form = getInCache(key);
1163         if (form != null) {
1164             return form;
1165         }
1166 
1167         // replace the null entry in the MHImpl.loop invocation with localTypes
1168         Name invokeLoop = lambdaForm.names[pos + 1];
1169         assert(invokeLoop.function.equals(MethodHandleImpl.getFunction(NF_loop)));
1170         Object[] args = Arrays.copyOf(invokeLoop.arguments, invokeLoop.arguments.length);
1171         assert(args[0] == null);
1172         args[0] = localTypes;
1173 
1174         LambdaFormBuffer buf = buffer();
1175         buf.startEdit();
1176         buf.changeName(pos + 1, new Name(MethodHandleImpl.getFunction(NF_loop), args));
1177         form = buf.endEdit();
1178 
1179         return putInCache(key, form);
1180     }
1181 
1182     static boolean permutedTypesMatch(int[] reorder, BasicType[] types, Name[] names, int skip) {
1183         for (int i = 0; i &lt; reorder.length; i++) {
1184             assert (names[skip + i].isParam());
1185             assert (names[skip + i].type == types[reorder[i]]);
1186         }
1187         return true;
1188     }
1189 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
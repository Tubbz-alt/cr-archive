<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaFormEditor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);






2399             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2400         }
2401 
2402         /**
2403          * Produces a method handle for a virtual method.
2404          * The type of the method handle will be that of the method,
2405          * with the receiver type (usually {@code refc}) prepended.
2406          * The method and all its argument types must be accessible to the lookup object.
2407          * &lt;p&gt;
2408          * When called, the handle will treat the first argument as a receiver
2409          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2410          * implementation to enter.
2411          * For private methods the named method in {@code refc} will be invoked on the receiver.
2412          * (The dispatching action is identical with that performed by an
2413          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2414          * &lt;p&gt;
2415          * The first argument will be of type {@code refc} if the lookup
2416          * class has full privileges to access the member.  Otherwise
2417          * the member must be {@code protected} and the first argument
2418          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2524          * If the returned method handle is invoked, the constructor&#39;s class will
2525          * be initialized, if it has not already been initialized.
2526          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2527          * &lt;blockquote&gt;&lt;pre&gt;{@code
2528 import static java.lang.invoke.MethodHandles.*;
2529 import static java.lang.invoke.MethodType.*;
2530 ...
2531 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2532   ArrayList.class, methodType(void.class, Collection.class));
2533 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2534 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2535 assert(orig != copy);
2536 assertEquals(orig, copy);
2537 // a variable-arity constructor:
2538 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2539   ProcessBuilder.class, methodType(void.class, String[].class));
2540 ProcessBuilder pb = (ProcessBuilder)
2541   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2542 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2543          * }&lt;/pre&gt;&lt;/blockquote&gt;







2544          * @param refc the class or interface from which the method is accessed
2545          * @param type the type of the method, with the receiver argument omitted, and a void return type
2546          * @return the desired method handle
2547          * @throws NoSuchMethodException if the constructor does not exist
2548          * @throws IllegalAccessException if access checking fails
2549          *                                or if the method&#39;s variable arity modifier bit
2550          *                                is set and {@code asVarargsCollector} fails
2551          * @throws    SecurityException if a security manager is present and it
2552          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2553          * @throws NullPointerException if any argument is null
2554          */
2555         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2556             if (refc.isArray()) {
2557                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2558             }



2559             String name = &quot;&lt;init&gt;&quot;;
2560             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2561             return getDirectConstructor(refc, ctor);
2562         }
2563 
2564         /**
2565          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2566          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2567          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2568          * and then determines whether the class is accessible to this lookup object.
2569          * &lt;p&gt;
2570          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2571          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2572          *
2573          * @param targetName the fully qualified name of the class to be looked up.
2574          * @return the requested class.
2575          * @throws SecurityException if a security manager is present and it
2576          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2577          * @throws LinkageError if the linkage fails
2578          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3156          * arguments passed to the method handle.
3157          * &lt;p&gt;
3158          * If the constructor&#39;s {@code accessible} flag is not set,
3159          * access checking is performed immediately on behalf of the lookup class.
3160          * &lt;p&gt;
3161          * The returned method handle will have
3162          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3163          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3164          * &lt;p&gt;
3165          * If the returned method handle is invoked, the constructor&#39;s class will
3166          * be initialized, if it has not already been initialized.
3167          * @param c the reflected constructor
3168          * @return a method handle which can invoke the reflected constructor
3169          * @throws IllegalAccessException if access checking fails
3170          *                                or if the method&#39;s variable arity modifier bit
3171          *                                is set and {@code asVarargsCollector} fails
3172          * @throws NullPointerException if the argument is null
3173          */
3174         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3175             MemberName ctor = new MemberName(c);
<span class="line-modified">3176             assert(ctor.isConstructor());</span>
3177             @SuppressWarnings(&quot;deprecation&quot;)
3178             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3179             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>








3180         }
3181 
3182         /**
3183          * Produces a method handle giving read access to a reflected field.
3184          * The type of the method handle will have a return type of the field&#39;s
3185          * value type.
3186          * If the field is {@code static}, the method handle will take no arguments.
3187          * Otherwise, its single argument will be the instance containing
3188          * the field.
3189          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3190          * access checking is performed immediately on behalf of the lookup class.
3191          * &lt;p&gt;
3192          * If the field is static, and
3193          * if the returned method handle is invoked, the field&#39;s class will
3194          * be initialized, if it has not already been initialized.
3195          * @param f the reflected field
3196          * @return a method handle which can load values from the reflected field
3197          * @throws IllegalAccessException if access checking fails
3198          * @throws NullPointerException if the argument is null
3199          */
</pre>
<hr />
<pre>
3412             }
3413             Objects.requireNonNull(member.getName());
3414             Objects.requireNonNull(member.getType());
3415             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3416         }
3417 
3418         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3419             if (!isClassAccessible(refc)) {
3420                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3421             }
3422         }
3423 
3424         boolean isClassAccessible(Class&lt;?&gt; refc) {
3425             Objects.requireNonNull(refc);
3426             Class&lt;?&gt; caller = lookupClassOrNull();
3427             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3428         }
3429 
3430         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3431         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3432             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)</span>
<span class="line-modified">3433                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);</span>



3434         }
3435 
<span class="line-removed">3436 </span>
3437         /**
3438          * Find my trustable caller class if m is a caller sensitive method.
3439          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3440          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3441          */
3442         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3443             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3444                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3445                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3446             }
3447             return this;
3448         }
3449 
3450         /**
3451          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3452          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3453          *
3454          * @deprecated This method was originally designed to test {@code PRIVATE} access
3455          * that implies full privilege access but {@code MODULE} access has since become
3456          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3501                 }
3502                 return;
3503             }
3504 
3505             // Step 2a:
3506             if (m.isPublic()) return;
3507             if (!fullPowerLookup) {
3508                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3509             }
3510 
3511             // Step 3:
3512             Class&lt;?&gt; defc = m.getDeclaringClass();
3513             if (!fullPowerLookup &amp;&amp; defc != refc) {
3514                 ReflectUtil.checkPackageAccess(defc);
3515             }
3516         }
3517 
3518         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3519             boolean wantStatic = (refKind == REF_invokeStatic);
3520             String message;
<span class="line-modified">3521             if (m.isConstructor())</span>
3522                 message = &quot;expected a method, not a constructor&quot;;
3523             else if (!m.isMethod())
3524                 message = &quot;expected a method&quot;;
3525             else if (wantStatic != m.isStatic())
3526                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3527             else
3528                 { checkAccess(refKind, refc, m); return; }
3529             throw m.makeAccessException(message, this);
3530         }
3531 
3532         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3533             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3534             String message;
3535             if (wantStatic != m.isStatic())
3536                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3537             else
3538                 { checkAccess(refKind, refc, m); return; }
3539             throw m.makeAccessException(message, this);
3540         }
3541 
</pre>
<hr />
<pre>
3800                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3801                 }
3802                 refc = lookupClass();
3803             }
3804             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3805                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3806         }
3807         /** Check access and get the requested constructor. */
3808         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3809             final boolean checkSecurity = true;
3810             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3811         }
3812         /** Check access and get the requested constructor, eliding security manager checks. */
3813         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3814             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3815             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3816         }
3817         /** Common code for all constructors; do not call directly except from immediately above. */
3818         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3819                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3820             assert(ctor.isConstructor());</span>
3821             checkAccess(REF_newInvokeSpecial, refc, ctor);
3822             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3823             if (checkSecurity)
3824                 checkSecurityManager(refc, ctor);
3825             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3826             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3827         }
3828 
3829         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3830          */
3831         /*non-public*/
3832         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3833                 throws ReflectiveOperationException {
3834             if (!(type instanceof Class || type instanceof MethodType))
3835                 throw new InternalError(&quot;unresolved MemberName&quot;);
3836             MemberName member = new MemberName(refKind, defc, name, type);
3837             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3838             if (mh != null) {
3839                 checkSymbolicClass(defc);
3840                 return mh;
</pre>
<hr />
<pre>
3990      * Produces a method handle giving write access to elements of an array,
3991      * as if by the {@code astore} bytecode.
3992      * The type of the method handle will have a void return type.
3993      * Its last argument will be the array&#39;s element type.
3994      * The first and second arguments will be the array type and int.
3995      *
3996      * &lt;p&gt; When the returned method handle is invoked,
3997      * the array reference and array index are checked.
3998      * A {@code NullPointerException} will be thrown if the array reference
3999      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4000      * thrown if the index is negative or if it is greater than or equal to
4001      * the length of the array.
4002      *
4003      * @param arrayClass the class of an array
4004      * @return a method handle which can store values into the array type
4005      * @throws NullPointerException if the argument is null
4006      * @throws IllegalArgumentException if arrayClass is not an array type
4007      * @jvms 6.5 {@code aastore} Instruction
4008      */
4009     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {



4010         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4011     }
4012 
4013     /**
4014      * Produces a VarHandle giving access to elements of an array of type
4015      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4016      * of {@code arrayClass} and the list of coordinate types is
4017      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4018      * corresponds to an argument that is an index into an array.
4019      * &lt;p&gt;
4020      * Certain access modes of the returned VarHandle are unsupported under
4021      * the following conditions:
4022      * &lt;ul&gt;
4023      * &lt;li&gt;if the component type is anything other than {@code byte},
4024      *     {@code short}, {@code char}, {@code int}, {@code long},
4025      *     {@code float}, or {@code double} then numeric atomic update access
4026      *     modes are unsupported.
4027      * &lt;li&gt;if the component type is anything other than {@code boolean},
4028      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4029      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4750     }
4751 
4752     /**
4753      * Produces a constant method handle of the requested return type which
4754      * returns the default value for that type every time it is invoked.
4755      * The resulting constant method handle will have no side effects.
4756      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4757      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4758      * since {@code explicitCastArguments} converts {@code null} to default values.
4759      * @param type the expected return type of the desired method handle
4760      * @return a constant method handle that takes no arguments
4761      *         and returns the default value of the given type (or void, if the type is void)
4762      * @throws NullPointerException if the argument is null
4763      * @see MethodHandles#constant
4764      * @see MethodHandles#empty
4765      * @see MethodHandles#explicitCastArguments
4766      * @since 9
4767      */
4768     public static MethodHandle zero(Class&lt;?&gt; type) {
4769         Objects.requireNonNull(type);
<span class="line-modified">4770         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);</span>






4771     }
4772 
4773     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4774         return type == void.class ? zero(type) : identity(type);
4775     }
4776 
4777     /**
4778      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4779      * and returns a suitable default depending on the return type.
4780      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4781      * &lt;p&gt;The returned method handle is equivalent to
4782      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4783      *
4784      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4785      * {@code guardWithTest(pred, target, empty(target.type())}.
4786      * @param type the type of the desired method handle
4787      * @return a constant method handle of the given type, which returns a default value of the given return type
4788      * @throws NullPointerException if the argument is null
4789      * @see MethodHandles#zero
4790      * @see MethodHandles#constant
4791      * @since 9
4792      */
4793     public static  MethodHandle empty(MethodType type) {
4794         Objects.requireNonNull(type);
4795         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4796     }
4797 
4798     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4799     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4800         MethodType mtype = methodType(ptype, ptype);</span>
4801         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4802         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4803     }
4804 
4805     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4806         int pos = btw.ordinal();
4807         MethodHandle zero = ZERO_MHS[pos];
4808         if (zero == null) {
4809             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4810         }
4811         if (zero.type().returnType() == rtype)
4812             return zero;
4813         assert(btw == Wrapper.OBJECT);
4814         return makeZero(rtype);
4815     }
4816     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4817     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4818         MethodType mtype = methodType(rtype);
4819         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4820         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
<td>
<hr />
<pre>
2379 ...
2380 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2381   &quot;asList&quot;, methodType(List.class, Object[].class));
2382 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2383          * }&lt;/pre&gt;&lt;/blockquote&gt;
2384          * @param refc the class from which the method is accessed
2385          * @param name the name of the method
2386          * @param type the type of the method
2387          * @return the desired method handle
2388          * @throws NoSuchMethodException if the method does not exist
2389          * @throws IllegalAccessException if access checking fails,
2390          *                                or if the method is not {@code static},
2391          *                                or if the method&#39;s variable arity modifier bit
2392          *                                is set and {@code asVarargsCollector} fails
2393          * @throws    SecurityException if a security manager is present and it
2394          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2395          * @throws NullPointerException if any argument is null
2396          */
2397         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2398             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-added">2399             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2400             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2401             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2402                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2403             }</span>
<span class="line-added">2404 </span>
2405             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2406         }
2407 
2408         /**
2409          * Produces a method handle for a virtual method.
2410          * The type of the method handle will be that of the method,
2411          * with the receiver type (usually {@code refc}) prepended.
2412          * The method and all its argument types must be accessible to the lookup object.
2413          * &lt;p&gt;
2414          * When called, the handle will treat the first argument as a receiver
2415          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2416          * implementation to enter.
2417          * For private methods the named method in {@code refc} will be invoked on the receiver.
2418          * (The dispatching action is identical with that performed by an
2419          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2420          * &lt;p&gt;
2421          * The first argument will be of type {@code refc} if the lookup
2422          * class has full privileges to access the member.  Otherwise
2423          * the member must be {@code protected} and the first argument
2424          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2530          * If the returned method handle is invoked, the constructor&#39;s class will
2531          * be initialized, if it has not already been initialized.
2532          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2533          * &lt;blockquote&gt;&lt;pre&gt;{@code
2534 import static java.lang.invoke.MethodHandles.*;
2535 import static java.lang.invoke.MethodType.*;
2536 ...
2537 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2538   ArrayList.class, methodType(void.class, Collection.class));
2539 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2540 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2541 assert(orig != copy);
2542 assertEquals(orig, copy);
2543 // a variable-arity constructor:
2544 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2545   ProcessBuilder.class, methodType(void.class, String[].class));
2546 ProcessBuilder pb = (ProcessBuilder)
2547   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2548 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2549          * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">2550          *</span>
<span class="line-added">2551          * @apiNote</span>
<span class="line-added">2552          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2553          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2554          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2555          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2556          *</span>
2557          * @param refc the class or interface from which the method is accessed
2558          * @param type the type of the method, with the receiver argument omitted, and a void return type
2559          * @return the desired method handle
2560          * @throws NoSuchMethodException if the constructor does not exist
2561          * @throws IllegalAccessException if access checking fails
2562          *                                or if the method&#39;s variable arity modifier bit
2563          *                                is set and {@code asVarargsCollector} fails
2564          * @throws    SecurityException if a security manager is present and it
2565          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2566          * @throws NullPointerException if any argument is null
2567          */
2568         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2569             if (refc.isArray()) {
2570                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2571             }
<span class="line-added">2572             if (type.returnType() != void.class) {</span>
<span class="line-added">2573                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2574             }</span>
2575             String name = &quot;&lt;init&gt;&quot;;
2576             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2577             return getDirectConstructor(refc, ctor);
2578         }
2579 
2580         /**
2581          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2582          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2583          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2584          * and then determines whether the class is accessible to this lookup object.
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3172          * arguments passed to the method handle.
3173          * &lt;p&gt;
3174          * If the constructor&#39;s {@code accessible} flag is not set,
3175          * access checking is performed immediately on behalf of the lookup class.
3176          * &lt;p&gt;
3177          * The returned method handle will have
3178          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3179          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3180          * &lt;p&gt;
3181          * If the returned method handle is invoked, the constructor&#39;s class will
3182          * be initialized, if it has not already been initialized.
3183          * @param c the reflected constructor
3184          * @return a method handle which can invoke the reflected constructor
3185          * @throws IllegalAccessException if access checking fails
3186          *                                or if the method&#39;s variable arity modifier bit
3187          *                                is set and {@code asVarargsCollector} fails
3188          * @throws NullPointerException if the argument is null
3189          */
3190         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3191             MemberName ctor = new MemberName(c);
<span class="line-modified">3192             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3193             @SuppressWarnings(&quot;deprecation&quot;)
3194             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3195             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3196                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3197                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3198             } else {</span>
<span class="line-added">3199                 // static init factory is a static method</span>
<span class="line-added">3200                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3201                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3202                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3203             }</span>
3204         }
3205 
3206         /**
3207          * Produces a method handle giving read access to a reflected field.
3208          * The type of the method handle will have a return type of the field&#39;s
3209          * value type.
3210          * If the field is {@code static}, the method handle will take no arguments.
3211          * Otherwise, its single argument will be the instance containing
3212          * the field.
3213          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3214          * access checking is performed immediately on behalf of the lookup class.
3215          * &lt;p&gt;
3216          * If the field is static, and
3217          * if the returned method handle is invoked, the field&#39;s class will
3218          * be initialized, if it has not already been initialized.
3219          * @param f the reflected field
3220          * @return a method handle which can load values from the reflected field
3221          * @throws IllegalAccessException if access checking fails
3222          * @throws NullPointerException if the argument is null
3223          */
</pre>
<hr />
<pre>
3436             }
3437             Objects.requireNonNull(member.getName());
3438             Objects.requireNonNull(member.getType());
3439             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3440         }
3441 
3442         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3443             if (!isClassAccessible(refc)) {
3444                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3445             }
3446         }
3447 
3448         boolean isClassAccessible(Class&lt;?&gt; refc) {
3449             Objects.requireNonNull(refc);
3450             Class&lt;?&gt; caller = lookupClassOrNull();
3451             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3452         }
3453 
3454         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3455         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3456             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3457             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3458                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3459                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3460             }</span>
3461         }
3462 

3463         /**
3464          * Find my trustable caller class if m is a caller sensitive method.
3465          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3466          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3467          */
3468         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3469             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3470                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3471                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3472             }
3473             return this;
3474         }
3475 
3476         /**
3477          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3478          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3479          *
3480          * @deprecated This method was originally designed to test {@code PRIVATE} access
3481          * that implies full privilege access but {@code MODULE} access has since become
3482          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3527                 }
3528                 return;
3529             }
3530 
3531             // Step 2a:
3532             if (m.isPublic()) return;
3533             if (!fullPowerLookup) {
3534                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3535             }
3536 
3537             // Step 3:
3538             Class&lt;?&gt; defc = m.getDeclaringClass();
3539             if (!fullPowerLookup &amp;&amp; defc != refc) {
3540                 ReflectUtil.checkPackageAccess(defc);
3541             }
3542         }
3543 
3544         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3545             boolean wantStatic = (refKind == REF_invokeStatic);
3546             String message;
<span class="line-modified">3547             if (m.isObjectConstructor())</span>
3548                 message = &quot;expected a method, not a constructor&quot;;
3549             else if (!m.isMethod())
3550                 message = &quot;expected a method&quot;;
3551             else if (wantStatic != m.isStatic())
3552                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3553             else
3554                 { checkAccess(refKind, refc, m); return; }
3555             throw m.makeAccessException(message, this);
3556         }
3557 
3558         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3559             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3560             String message;
3561             if (wantStatic != m.isStatic())
3562                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3563             else
3564                 { checkAccess(refKind, refc, m); return; }
3565             throw m.makeAccessException(message, this);
3566         }
3567 
</pre>
<hr />
<pre>
3826                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3827                 }
3828                 refc = lookupClass();
3829             }
3830             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3831                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3832         }
3833         /** Check access and get the requested constructor. */
3834         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3835             final boolean checkSecurity = true;
3836             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3837         }
3838         /** Check access and get the requested constructor, eliding security manager checks. */
3839         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3840             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3841             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3842         }
3843         /** Common code for all constructors; do not call directly except from immediately above. */
3844         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3845                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3846             assert(ctor.isObjectConstructor());</span>
3847             checkAccess(REF_newInvokeSpecial, refc, ctor);
3848             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3849             if (checkSecurity)
3850                 checkSecurityManager(refc, ctor);
3851             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3852             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3853         }
3854 
3855         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3856          */
3857         /*non-public*/
3858         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3859                 throws ReflectiveOperationException {
3860             if (!(type instanceof Class || type instanceof MethodType))
3861                 throw new InternalError(&quot;unresolved MemberName&quot;);
3862             MemberName member = new MemberName(refKind, defc, name, type);
3863             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3864             if (mh != null) {
3865                 checkSymbolicClass(defc);
3866                 return mh;
</pre>
<hr />
<pre>
4016      * Produces a method handle giving write access to elements of an array,
4017      * as if by the {@code astore} bytecode.
4018      * The type of the method handle will have a void return type.
4019      * Its last argument will be the array&#39;s element type.
4020      * The first and second arguments will be the array type and int.
4021      *
4022      * &lt;p&gt; When the returned method handle is invoked,
4023      * the array reference and array index are checked.
4024      * A {@code NullPointerException} will be thrown if the array reference
4025      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
4026      * thrown if the index is negative or if it is greater than or equal to
4027      * the length of the array.
4028      *
4029      * @param arrayClass the class of an array
4030      * @return a method handle which can store values into the array type
4031      * @throws NullPointerException if the argument is null
4032      * @throws IllegalArgumentException if arrayClass is not an array type
4033      * @jvms 6.5 {@code aastore} Instruction
4034      */
4035     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<span class="line-added">4036         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">4037             throw new UnsupportedOperationException();</span>
<span class="line-added">4038         }</span>
4039         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
4040     }
4041 
4042     /**
4043      * Produces a VarHandle giving access to elements of an array of type
4044      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
4045      * of {@code arrayClass} and the list of coordinate types is
4046      * {@code (arrayClass, int)}, where the {@code int} coordinate type
4047      * corresponds to an argument that is an index into an array.
4048      * &lt;p&gt;
4049      * Certain access modes of the returned VarHandle are unsupported under
4050      * the following conditions:
4051      * &lt;ul&gt;
4052      * &lt;li&gt;if the component type is anything other than {@code byte},
4053      *     {@code short}, {@code char}, {@code int}, {@code long},
4054      *     {@code float}, or {@code double} then numeric atomic update access
4055      *     modes are unsupported.
4056      * &lt;li&gt;if the component type is anything other than {@code boolean},
4057      *     {@code byte}, {@code short}, {@code char}, {@code int} or
4058      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4779     }
4780 
4781     /**
4782      * Produces a constant method handle of the requested return type which
4783      * returns the default value for that type every time it is invoked.
4784      * The resulting constant method handle will have no side effects.
4785      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4786      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4787      * since {@code explicitCastArguments} converts {@code null} to default values.
4788      * @param type the expected return type of the desired method handle
4789      * @return a constant method handle that takes no arguments
4790      *         and returns the default value of the given type (or void, if the type is void)
4791      * @throws NullPointerException if the argument is null
4792      * @see MethodHandles#constant
4793      * @see MethodHandles#empty
4794      * @see MethodHandles#explicitCastArguments
4795      * @since 9
4796      */
4797     public static MethodHandle zero(Class&lt;?&gt; type) {
4798         Objects.requireNonNull(type);
<span class="line-modified">4799         if (type.isPrimitive()) {</span>
<span class="line-added">4800             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4801         } else if (type.isInlineClass()) {</span>
<span class="line-added">4802             throw new UnsupportedOperationException();</span>
<span class="line-added">4803         } else {</span>
<span class="line-added">4804             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4805         }</span>
4806     }
4807 
4808     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4809         return type == void.class ? zero(type) : identity(type);
4810     }
4811 
4812     /**
4813      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4814      * and returns a suitable default depending on the return type.
4815      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4816      * &lt;p&gt;The returned method handle is equivalent to
4817      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4818      *
4819      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4820      * {@code guardWithTest(pred, target, empty(target.type())}.
4821      * @param type the type of the desired method handle
4822      * @return a constant method handle of the given type, which returns a default value of the given return type
4823      * @throws NullPointerException if the argument is null
4824      * @see MethodHandles#zero
4825      * @see MethodHandles#constant
4826      * @since 9
4827      */
4828     public static  MethodHandle empty(MethodType type) {
4829         Objects.requireNonNull(type);
4830         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4831     }
4832 
4833     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4834     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4835         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4836         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4837         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4838     }
4839 
4840     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4841         int pos = btw.ordinal();
4842         MethodHandle zero = ZERO_MHS[pos];
4843         if (zero == null) {
4844             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4845         }
4846         if (zero.type().returnType() == rtype)
4847             return zero;
4848         assert(btw == Wrapper.OBJECT);
4849         return makeZero(rtype);
4850     }
4851     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4852     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4853         MethodType mtype = methodType(rtype);
4854         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4855         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
</tr>
</table>
<center><a href="LambdaFormEditor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import java.util.function.IntFunction;
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;
  59 import com.sun.tools.javac.jvm.ClassFile.Version;
  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
  81 /** This class provides operations to read a classfile into an internal
  82  *  representation. The internal representation is anchored in a
  83  *  ClassSymbol which contains in its scope symbol representations
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 
 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
 108     /** Switch: allow sealed
 109      */
 110     boolean allowSealedTypes;
 111 
 112     /** Switch: allow records
 113      */
 114     boolean allowRecords;
 115 
 116    /** Lint option: warn about classfile issues
 117      */
 118     boolean lintClassfile;
 119 
 120     /** Switch: preserve parameter names from the variable table.
 121      */
 122     public boolean saveParameterNames;
 123 
 124     /**
 125      * The currently selected profile.
 126      */
 127     public final Profile profile;
 128 
 129     /** The log to use for verbose output
 130      */
 131     final Log log;
 132 
 133     /** The symbol table. */
 134     Symtab syms;
 135 
 136     Types types;
 137 
 138     /** The name table. */
 139     final Names names;
 140 
 141     /** Access to files
 142      */
 143     private final JavaFileManager fileManager;
 144 
 145     /** Factory for diagnostics
 146      */
 147     JCDiagnostic.Factory diagFactory;
 148 
 149     DeferredCompletionFailureHandler dcfh;
 150 
 151     /**
 152      * Support for preview language features.
 153      */
 154     Preview preview;
 155 
 156     /** The current scope where type variables are entered.
 157      */
 158     protected WriteableScope typevars;
 159 
 160     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 161     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 162 
 163     /** The path name of the class file currently being read.
 164      */
 165     protected JavaFileObject currentClassFile = null;
 166 
 167     /** The class or method currently being read.
 168      */
 169     protected Symbol currentOwner = null;
 170 
 171     /** The module containing the class currently being read.
 172      */
 173     protected ModuleSymbol currentModule = null;
 174 
 175     /** The buffer containing the currently read class file.
 176      */
 177     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);
 178 
 179     /** The current input pointer.
 180      */
 181     protected int bp;
 182 
 183     /** The pool reader.
 184      */
 185     PoolReader poolReader;
 186 
 187     /** The major version number of the class file being read. */
 188     int majorVersion;
 189     /** The minor version number of the class file being read. */
 190     int minorVersion;
 191 
 192     /** A table to hold the constant pool indices for method parameter
 193      * names, as given in LocalVariableTable attributes.
 194      */
 195     int[] parameterNameIndices;
 196 
 197     /**
 198      * A table to hold annotations for method parameters.
 199      */
 200     ParameterAnnotations[] parameterAnnotations;
 201 
 202     /**
 203      * A holder for parameter annotations.
 204      */
 205     static class ParameterAnnotations {
 206         List&lt;CompoundAnnotationProxy&gt; proxies;
 207 
 208         void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
 209             if (proxies == null) {
 210                 proxies = newAnnotations;
 211             } else {
 212                 proxies = proxies.prependList(newAnnotations);
 213             }
 214         }
 215     }
 216 
 217     /**
 218      * Whether or not any parameter names have been found.
 219      */
 220     boolean haveParameterNameIndices;
 221 
 222     /** Set this to false every time we start reading a method
 223      * and are saving parameter names.  Set it to true when we see
 224      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 225      * then we ignore the parameter names from the LVT.
 226      */
 227     boolean sawMethodParameters;
 228 
 229     /**
 230      * The set of attribute names for which warnings have been generated for the current class
 231      */
 232     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 233 
 234     /**
 235      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 236      * @Target
 237      */
 238     CompoundAnnotationProxy target;
 239 
 240     /**
 241      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with
 242      * @Repeatable
 243      */
 244     CompoundAnnotationProxy repeatable;
 245 
 246     /** Get the ClassReader instance for this invocation. */
 247     public static ClassReader instance(Context context) {
 248         ClassReader instance = context.get(classReaderKey);
 249         if (instance == null)
 250             instance = new ClassReader(context);
 251         return instance;
 252     }
 253 
 254     /** Construct a new class reader. */
 255     protected ClassReader(Context context) {
 256         context.put(classReaderKey, this);
 257         annotate = Annotate.instance(context);
 258         names = Names.instance(context);
 259         syms = Symtab.instance(context);
 260         types = Types.instance(context);
 261         fileManager = context.get(JavaFileManager.class);
 262         if (fileManager == null)
 263             throw new AssertionError(&quot;FileManager initialization error&quot;);
 264         diagFactory = JCDiagnostic.Factory.instance(context);
 265         dcfh = DeferredCompletionFailureHandler.instance(context);
 266 
 267         log = Log.instance(context);
 268 
 269         Options options = Options.instance(context);
 270         verbose         = options.isSet(Option.VERBOSE);
 271 
 272         Source source = Source.instance(context);
 273         preview = Preview.instance(context);
 274         allowModules     = Feature.MODULES.allowedInSource(source);
 275         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 276                 Feature.RECORDS.allowedInSource(source);
 277         allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &amp;&amp;
 278                 Feature.SEALED_CLASSES.allowedInSource(source);
 279 
 280         saveParameterNames = options.isSet(PARAMETERS);
 281 
 282         profile = Profile.instance(context);
 283 
 284         typevars = WriteableScope.create(syms.noSymbol);
 285 
 286         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 287 
 288         initAttributeReaders();
 289     }
 290 
 291     /** Add member to class unless it is synthetic.
 292      */
 293     private void enterMember(ClassSymbol c, Symbol sym) {
 294         // Synthetic members are not entered -- reason lost to history (optimization?).
 295         // Lambda methods must be entered because they may have inner classes (which reference them)
 296         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 297             c.members_field.enter(sym);
 298     }
 299 
 300 /************************************************************************
 301  * Error Diagnoses
 302  ***********************************************************************/
 303 
 304     public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
 305         return new ClassFinder.BadClassFile (
 306             currentOwner.enclClass(),
 307             currentClassFile,
 308             diagFactory.fragment(key, args),
 309             diagFactory,
 310             dcfh);
 311     }
 312 
 313     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 314         return new ClassFinder.BadEnclosingMethodAttr (
 315             currentOwner.enclClass(),
 316             currentClassFile,
 317             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 318             diagFactory,
 319             dcfh);
 320     }
 321 
 322 /************************************************************************
 323  * Buffer Access
 324  ***********************************************************************/
 325 
 326     /** Read a character.
 327      */
 328     char nextChar() {
 329         char res = buf.getChar(bp);
 330         bp += 2;
 331         return res;
 332     }
 333 
 334     /** Read a byte.
 335      */
 336     int nextByte() {
 337         return buf.getByte(bp++) &amp; 0xFF;
 338     }
 339 
 340     /** Read an integer.
 341      */
 342     int nextInt() {
 343         int res = buf.getInt(bp);
 344         bp += 4;
 345         return res;
 346     }
 347 
 348 /************************************************************************
 349  * Constant Pool Access
 350  ***********************************************************************/
 351 
 352     /** Read module_flags.
 353      */
 354     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 355         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 356         for (ModuleFlags f : ModuleFlags.values()) {
 357             if ((flags &amp; f.value) != 0)
 358                 set.add(f);
 359         }
 360         return set;
 361     }
 362 
 363     /** Read resolution_flags.
 364      */
 365     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 366         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 367         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 368             if ((flags &amp; f.value) != 0)
 369                 set.add(f);
 370         }
 371         return set;
 372     }
 373 
 374     /** Read exports_flags.
 375      */
 376     Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
 377         Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
 378         for (ExportsFlag f: ExportsFlag.values()) {
 379             if ((flags &amp; f.value) != 0)
 380                 set.add(f);
 381         }
 382         return set;
 383     }
 384 
 385     /** Read opens_flags.
 386      */
 387     Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
 388         Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);
 389         for (OpensFlag f: OpensFlag.values()) {
 390             if ((flags &amp; f.value) != 0)
 391                 set.add(f);
 392         }
 393         return set;
 394     }
 395 
 396     /** Read requires_flags.
 397      */
 398     Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {
 399         Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);
 400         for (RequiresFlag f: RequiresFlag.values()) {
 401             if ((flags &amp; f.value) != 0)
 402                 set.add(f);
 403         }
 404         return set;
 405     }
 406 
 407 /************************************************************************
 408  * Reading Types
 409  ***********************************************************************/
 410 
 411     /** The unread portion of the currently read type is
 412      *  signature[sigp..siglimit-1].
 413      */
 414     byte[] signature;
 415     int sigp;
 416     int siglimit;
 417     boolean sigEnterPhase = false;
 418 
 419     /** Convert signature to type, where signature is a byte array segment.
 420      */
 421     Type sigToType(byte[] sig, int offset, int len) {
 422         signature = sig;
 423         sigp = offset;
 424         siglimit = offset + len;
 425         return sigToType();
 426     }
 427 
 428     /** Convert signature to type, where signature is implicit.
 429      */
 430     Type sigToType() {
 431         switch ((char) signature[sigp]) {
 432         case &#39;T&#39;:
 433             sigp++;
 434             int start = sigp;
 435             while (signature[sigp] != &#39;;&#39;) sigp++;
 436             sigp++;
 437             return sigEnterPhase
 438                 ? Type.noType
 439                 : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));
 440         case &#39;+&#39;: {
 441             sigp++;
 442             Type t = sigToType();
 443             return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);
 444         }
 445         case &#39;*&#39;:
 446             sigp++;
 447             return new WildcardType(syms.objectType, BoundKind.UNBOUND,
 448                                     syms.boundClass);
 449         case &#39;-&#39;: {
 450             sigp++;
 451             Type t = sigToType();
 452             return new WildcardType(t, BoundKind.SUPER, syms.boundClass);
 453         }
 454         case &#39;B&#39;:
 455             sigp++;
 456             return syms.byteType;
 457         case &#39;C&#39;:
 458             sigp++;
 459             return syms.charType;
 460         case &#39;D&#39;:
 461             sigp++;
 462             return syms.doubleType;
 463         case &#39;F&#39;:
 464             sigp++;
 465             return syms.floatType;
 466         case &#39;I&#39;:
 467             sigp++;
 468             return syms.intType;
 469         case &#39;J&#39;:
 470             sigp++;
 471             return syms.longType;
 472         case &#39;L&#39;:
 473             {
 474                 // int oldsigp = sigp;
 475                 Type t = classSigToType();
 476                 if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
 477                     throw badClassFile(&quot;deprecated inner class signature syntax &quot; +
 478                                        &quot;(please recompile from source)&quot;);
 479                 /*
 480                 System.err.println(&quot; decoded &quot; +
 481                                    new String(signature, oldsigp, sigp-oldsigp) +
 482                                    &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());
 483                 */
 484                 return t;
 485             }
 486         case &#39;S&#39;:
 487             sigp++;
 488             return syms.shortType;
 489         case &#39;V&#39;:
 490             sigp++;
 491             return syms.voidType;
 492         case &#39;Z&#39;:
 493             sigp++;
 494             return syms.booleanType;
 495         case &#39;[&#39;:
 496             sigp++;
 497             return new ArrayType(sigToType(), syms.arrayClass);
 498         case &#39;(&#39;:
 499             sigp++;
 500             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 501             Type restype = sigToType();
 502             List&lt;Type&gt; thrown = List.nil();
 503             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {
 504                 sigp++;
 505                 thrown = thrown.prepend(sigToType());
 506             }
 507             // if there is a typevar in the throws clause we should state it.
 508             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 509                 if (l.head.hasTag(TYPEVAR)) {
 510                     l.head.tsym.flags_field |= THROWS;
 511                 }
 512             }
 513             return new MethodType(argtypes,
 514                                   restype,
 515                                   thrown.reverse(),
 516                                   syms.methodClass);
 517         case &#39;&lt;&#39;:
 518             typevars = typevars.dup(currentOwner);
 519             Type poly = new ForAll(sigToTypeParams(), sigToType());
 520             typevars = typevars.leave();
 521             return poly;
 522         default:
 523             throw badClassFile(&quot;bad.signature&quot;,
 524                                Convert.utf2string(signature, sigp, 10));
 525         }
 526     }
 527 
 528     byte[] signatureBuffer = new byte[0];
 529     int sbp = 0;
 530     /** Convert class signature to type, where signature is implicit.
 531      */
 532     Type classSigToType() {
 533         if (signature[sigp] != &#39;L&#39;)
 534             throw badClassFile(&quot;bad.class.signature&quot;,
 535                                Convert.utf2string(signature, sigp, 10));
 536         sigp++;
 537         Type outer = Type.noType;
 538         int startSbp = sbp;
 539 
 540         while (true) {
 541             final byte c = signature[sigp++];
 542             switch (c) {
 543 
 544             case &#39;;&#39;: {         // end
 545                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 546                                                          startSbp,
 547                                                          sbp - startSbp));
 548 
 549                 try {
 550                     return (outer == Type.noType) ?
 551                             t.erasure(types) :
 552                         new ClassType(outer, List.nil(), t);
 553                 } finally {
 554                     sbp = startSbp;
 555                 }
 556             }
 557 
 558             case &#39;&lt;&#39;:           // generic arguments
 559                 ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
 560                                                          startSbp,
 561                                                          sbp - startSbp));
 562                 outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {
 563                         boolean completed = false;
 564                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 565                         public Type getEnclosingType() {
 566                             if (!completed) {
 567                                 completed = true;
 568                                 tsym.complete();
 569                                 Type enclosingType = tsym.type.getEnclosingType();
 570                                 if (enclosingType != Type.noType) {
 571                                     List&lt;Type&gt; typeArgs =
 572                                         super.getEnclosingType().allparams();
 573                                     List&lt;Type&gt; typeParams =
 574                                         enclosingType.allparams();
 575                                     if (typeParams.length() != typeArgs.length()) {
 576                                         // no &quot;rare&quot; types
 577                                         super.setEnclosingType(types.erasure(enclosingType));
 578                                     } else {
 579                                         super.setEnclosingType(types.subst(enclosingType,
 580                                                                            typeParams,
 581                                                                            typeArgs));
 582                                     }
 583                                 } else {
 584                                     super.setEnclosingType(Type.noType);
 585                                 }
 586                             }
 587                             return super.getEnclosingType();
 588                         }
 589                         @Override
 590                         public void setEnclosingType(Type outer) {
 591                             throw new UnsupportedOperationException();
 592                         }
 593                     };
 594                 switch (signature[sigp++]) {
 595                 case &#39;;&#39;:
 596                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {
 597                         // support old-style GJC signatures
 598                         // The signature produced was
 599                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 600                         // rather than say
 601                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 602                         // so we skip past &quot;.Lfoo/Outer$&quot;
 603                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 604                             3;  // &quot;.L&quot; and &quot;$&quot;
 605                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 606                         break;
 607                     } else {
 608                         sbp = startSbp;
 609                         return outer;
 610                     }
 611                 case &#39;.&#39;:
 612                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 613                     break;
 614                 default:
 615                     throw new AssertionError(signature[sigp-1]);
 616                 }
 617                 continue;
 618 
 619             case &#39;.&#39;:
 620                 //we have seen an enclosing non-generic class
 621                 if (outer != Type.noType) {
 622                     t = enterClass(names.fromUtf(signatureBuffer,
 623                                                  startSbp,
 624                                                  sbp - startSbp));
 625                     outer = new ClassType(outer, List.nil(), t);
 626                 }
 627                 signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 628                 continue;
 629             case &#39;/&#39;:
 630                 signatureBuffer[sbp++] = (byte)&#39;.&#39;;
 631                 continue;
 632             default:
 633                 signatureBuffer[sbp++] = c;
 634                 continue;
 635             }
 636         }
 637     }
 638 
 639     /** Convert (implicit) signature to list of types
 640      *  until `terminator&#39; is encountered.
 641      */
 642     List&lt;Type&gt; sigToTypes(char terminator) {
 643         List&lt;Type&gt; head = List.of(null);
 644         List&lt;Type&gt; tail = head;
 645         while (signature[sigp] != terminator)
 646             tail = tail.setTail(List.of(sigToType()));
 647         sigp++;
 648         return head.tail;
 649     }
 650 
 651     /** Convert signature to type parameters, where signature is a byte
 652      *  array segment.
 653      */
 654     List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
 655         signature = sig;
 656         sigp = offset;
 657         siglimit = offset + len;
 658         return sigToTypeParams();
 659     }
 660 
 661     /** Convert signature to type parameters, where signature is implicit.
 662      */
 663     List&lt;Type&gt; sigToTypeParams() {
 664         List&lt;Type&gt; tvars = List.nil();
 665         if (signature[sigp] == &#39;&lt;&#39;) {
 666             sigp++;
 667             int start = sigp;
 668             sigEnterPhase = true;
 669             while (signature[sigp] != &#39;&gt;&#39;)
 670                 tvars = tvars.prepend(sigToTypeParam());
 671             sigEnterPhase = false;
 672             sigp = start;
 673             while (signature[sigp] != &#39;&gt;&#39;)
 674                 sigToTypeParam();
 675             sigp++;
 676         }
 677         return tvars.reverse();
 678     }
 679 
 680     /** Convert (implicit) signature to type parameter.
 681      */
 682     Type sigToTypeParam() {
 683         int start = sigp;
 684         while (signature[sigp] != &#39;:&#39;) sigp++;
 685         Name name = names.fromUtf(signature, start, sigp - start);
 686         TypeVar tvar;
 687         if (sigEnterPhase) {
 688             tvar = new TypeVar(name, currentOwner, syms.botType);
 689             typevars.enter(tvar.tsym);
 690         } else {
 691             tvar = (TypeVar)findTypeVar(name);
 692         }
 693         List&lt;Type&gt; bounds = List.nil();
 694         boolean allInterfaces = false;
 695         if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
 696             sigp++;
 697             allInterfaces = true;
 698         }
 699         while (signature[sigp] == &#39;:&#39;) {
 700             sigp++;
 701             bounds = bounds.prepend(sigToType());
 702         }
 703         if (!sigEnterPhase) {
 704             types.setBounds(tvar, bounds.reverse(), allInterfaces);
 705         }
 706         return tvar;
 707     }
 708 
 709     /** Find type variable with given name in `typevars&#39; scope.
 710      */
 711     Type findTypeVar(Name name) {
 712         Symbol s = typevars.findFirst(name);
 713         if (s != null) {
 714             return s.type;
 715         } else {
 716             if (readingClassAttr) {
 717                 // While reading the class attribute, the supertypes
 718                 // might refer to a type variable from an enclosing element
 719                 // (method or class).
 720                 // If the type variable is defined in the enclosing class,
 721                 // we can actually find it in
 722                 // currentOwner.owner.type.getTypeArguments()
 723                 // However, until we have read the enclosing method attribute
 724                 // we don&#39;t know for sure if this owner is correct.  It could
 725                 // be a method and there is no way to tell before reading the
 726                 // enclosing method attribute.
 727                 TypeVar t = new TypeVar(name, currentOwner, syms.botType);
 728                 missingTypeVariables = missingTypeVariables.prepend(t);
 729                 // System.err.println(&quot;Missing type var &quot; + name);
 730                 return t;
 731             }
 732             throw badClassFile(&quot;undecl.type.var&quot;, name);
 733         }
 734     }
 735 
 736 /************************************************************************
 737  * Reading Attributes
 738  ***********************************************************************/
 739 
 740     protected enum AttributeKind { CLASS, MEMBER }
 741 
 742     protected abstract class AttributeReader {
 743         protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
 744             this.name = name;
 745             this.version = version;
 746             this.kinds = kinds;
 747         }
 748 
 749         protected boolean accepts(AttributeKind kind) {
 750             if (kinds.contains(kind)) {
 751                 if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
 752                     return true;
 753 
 754                 if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {
 755                     JavaFileObject prev = log.useSource(currentClassFile);
 756                     try {
 757                         log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
 758                                     Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
 759                     } finally {
 760                         log.useSource(prev);
 761                     }
 762                     warnedAttrs.add(name);
 763                 }
 764             }
 765             return false;
 766         }
 767 
 768         protected abstract void read(Symbol sym, int attrLen);
 769 
 770         protected final Name name;
 771         protected final ClassFile.Version version;
 772         protected final Set&lt;AttributeKind&gt; kinds;
 773     }
 774 
 775     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 776             EnumSet.of(AttributeKind.CLASS);
 777     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 778             EnumSet.of(AttributeKind.MEMBER);
 779     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 780             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 781 
 782     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 783 
 784     private void initAttributeReaders() {
 785         AttributeReader[] readers = {
 786             // v45.3 attributes
 787 
 788             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 789                 protected void read(Symbol sym, int attrLen) {
 790                     if (saveParameterNames)
 791                         ((MethodSymbol)sym).code = readCode(sym);
 792                     else
 793                         bp = bp + attrLen;
 794                 }
 795             },
 796 
 797             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 798                 protected void read(Symbol sym, int attrLen) {
 799                     Object v = poolReader.getConstant(nextChar());
 800                     // Ignore ConstantValue attribute if field not final.
 801                     if ((sym.flags() &amp; FINAL) == 0) {
 802                         return;
 803                     }
 804                     VarSymbol var = (VarSymbol) sym;
 805                     switch (var.type.getTag()) {
 806                        case BOOLEAN:
 807                        case BYTE:
 808                        case CHAR:
 809                        case SHORT:
 810                        case INT:
 811                            checkType(var, Integer.class, v);
 812                            break;
 813                        case LONG:
 814                            checkType(var, Long.class, v);
 815                            break;
 816                        case FLOAT:
 817                            checkType(var, Float.class, v);
 818                            break;
 819                        case DOUBLE:
 820                            checkType(var, Double.class, v);
 821                            break;
 822                        case CLASS:
 823                            if (var.type.tsym == syms.stringType.tsym) {
 824                                checkType(var, String.class, v);
 825                            } else {
 826                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);
 827                            }
 828                            break;
 829                        default:
 830                            // ignore ConstantValue attribute if type is not primitive or String
 831                            return;
 832                     }
 833                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 834                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 835                     }
 836                     var.setData(v);
 837                 }
 838 
 839                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 840                     if (!clazz.isInstance(value)) {
 841                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 842                     }
 843                 }
 844             },
 845 
 846             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 847                 protected void read(Symbol sym, int attrLen) {
 848                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 849 
 850                     s.flags_field |= DEPRECATED;
 851                 }
 852             },
 853 
 854             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 855                 protected void read(Symbol sym, int attrLen) {
 856                     int nexceptions = nextChar();
 857                     List&lt;Type&gt; thrown = List.nil();
 858                     for (int j = 0; j &lt; nexceptions; j++)
 859                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);
 860                     if (sym.type.getThrownTypes().isEmpty())
 861                         sym.type.asMethodType().thrown = thrown.reverse();
 862                 }
 863             },
 864 
 865             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 866                 protected void read(Symbol sym, int attrLen) {
 867                     ClassSymbol c = (ClassSymbol) sym;
 868                     if (currentModule.module_info == c) {
 869                         //prevent entering the classes too soon:
 870                         skipInnerClasses();
 871                     } else {
 872                         readInnerClasses(c);
 873                     }
 874                 }
 875             },
 876 
 877             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 878                 protected void read(Symbol sym, int attrLen) {
 879                     int newbp = bp + attrLen;
 880                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 881                         // Pick up parameter names from the variable table.
 882                         // Parameter names are not explicitly identified as such,
 883                         // but all parameter name entries in the LocalVariableTable
 884                         // have a start_pc of 0.  Therefore, we record the name
 885                         // indices of all slots with a start_pc of zero in the
 886                         // parameterNameIndices array.
 887                         // Note that this implicitly honors the JVMS spec that
 888                         // there may be more than one LocalVariableTable, and that
 889                         // there is no specified ordering for the entries.
 890                         int numEntries = nextChar();
 891                         for (int i = 0; i &lt; numEntries; i++) {
 892                             int start_pc = nextChar();
 893                             int length = nextChar();
 894                             int nameIndex = nextChar();
 895                             int sigIndex = nextChar();
 896                             int register = nextChar();
 897                             if (start_pc == 0) {
 898                                 // ensure array large enough
 899                                 if (register &gt;= parameterNameIndices.length) {
 900                                     int newSize =
 901                                             Math.max(register + 1, parameterNameIndices.length + 8);
 902                                     parameterNameIndices =
 903                                             Arrays.copyOf(parameterNameIndices, newSize);
 904                                 }
 905                                 parameterNameIndices[register] = nameIndex;
 906                                 haveParameterNameIndices = true;
 907                             }
 908                         }
 909                     }
 910                     bp = newbp;
 911                 }
 912             },
 913 
 914             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 915                 protected void read(Symbol sym, int attrLen) {
 916                     ClassSymbol c = (ClassSymbol) sym;
 917                     Name n = poolReader.getName(nextChar());
 918                     c.sourcefile = new SourceFileObject(n);
 919                     // If the class is a toplevel class, originating from a Java source file,
 920                     // but the class name does not match the file name, then it is
 921                     // an auxiliary class.
 922                     String sn = n.toString();
 923                     if (c.owner.kind == PCK &amp;&amp;
 924                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 925                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 926                         c.flags_field |= AUXILIARY;
 927                     }
 928                 }
 929             },
 930 
 931             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 932                 protected void read(Symbol sym, int attrLen) {
 933                     sym.flags_field |= SYNTHETIC;
 934                 }
 935             },
 936 
 937             // standard v49 attributes
 938 
 939             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 940                 protected void read(Symbol sym, int attrLen) {
 941                     int newbp = bp + attrLen;
 942                     readEnclosingMethodAttr(sym);
 943                     bp = newbp;
 944                 }
 945             },
 946 
 947             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 948                 protected void read(Symbol sym, int attrLen) {
 949                     if (sym.kind == TYP) {
 950                         ClassSymbol c = (ClassSymbol) sym;
 951                         readingClassAttr = true;
 952                         try {
 953                             ClassType ct1 = (ClassType)c.type;
 954                             Assert.check(c == currentOwner);
 955                             ct1.typarams_field = poolReader.getName(nextChar())
 956                                     .map(ClassReader.this::sigToTypeParams);
 957                             ct1.supertype_field = sigToType();
 958                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 959                             while (sigp != siglimit) is.append(sigToType());
 960                             ct1.interfaces_field = is.toList();
 961                         } finally {
 962                             readingClassAttr = false;
 963                         }
 964                     } else {
 965                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
 966                         sym.type = poolReader.getType(nextChar());
 967                         //- System.err.println(&quot; # &quot; + sym.type);
 968                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 969                             sym.type.asMethodType().thrown = thrown;
 970 
 971                     }
 972                 }
 973             },
 974 
 975             // v49 annotation attributes
 976 
 977             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 978                 protected void read(Symbol sym, int attrLen) {
 979                     attachAnnotationDefault(sym);
 980                 }
 981             },
 982 
 983             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 984                 protected void read(Symbol sym, int attrLen) {
 985                     attachAnnotations(sym);
 986                 }
 987             },
 988 
 989             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 990                 protected void read(Symbol sym, int attrLen) {
 991                     readParameterAnnotations(sym);
 992                 }
 993             },
 994 
 995             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 996                 protected void read(Symbol sym, int attrLen) {
 997                     attachAnnotations(sym);
 998                 }
 999             },
1000 
1001             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1002                 protected void read(Symbol sym, int attrLen) {
1003                     readParameterAnnotations(sym);
1004                 }
1005             },
1006 
1007             // additional &quot;legacy&quot; v49 attributes, superseded by flags
1008 
1009             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1010                 protected void read(Symbol sym, int attrLen) {
1011                     sym.flags_field |= ANNOTATION;
1012                 }
1013             },
1014 
1015             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1016                 protected void read(Symbol sym, int attrLen) {
1017                     sym.flags_field |= BRIDGE;
1018                 }
1019             },
1020 
1021             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1022                 protected void read(Symbol sym, int attrLen) {
1023                     sym.flags_field |= ENUM;
1024                 }
1025             },
1026 
1027             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1028                 protected void read(Symbol sym, int attrLen) {
1029                     sym.flags_field |= VARARGS;
1030                 }
1031             },
1032 
1033             new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1034                 protected void read(Symbol sym, int attrLen) {
1035                     attachTypeAnnotations(sym);
1036                 }
1037             },
1038 
1039             new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
1040                 protected void read(Symbol sym, int attrLen) {
1041                     attachTypeAnnotations(sym);
1042                 }
1043             },
1044 
1045             // The following attributes for a Code attribute are not currently handled
1046             // StackMapTable
1047             // SourceDebugExtension
1048             // LineNumberTable
1049             // LocalVariableTypeTable
1050 
1051             // standard v52 attributes
1052 
1053             new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
1054                 protected void read(Symbol sym, int attrlen) {
1055                     int newbp = bp + attrlen;
1056                     if (saveParameterNames) {
1057                         sawMethodParameters = true;
1058                         int numEntries = nextByte();
1059                         parameterNameIndices = new int[numEntries];
1060                         haveParameterNameIndices = true;
1061                         int index = 0;
1062                         for (int i = 0; i &lt; numEntries; i++) {
1063                             int nameIndex = nextChar();
1064                             int flags = nextChar();
1065                             if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {
1066                                 continue;
1067                             }
1068                             parameterNameIndices[index++] = nameIndex;
1069                         }
1070                     }
1071                     bp = newbp;
1072                 }
1073             },
1074 
1075             // standard v53 attributes
1076 
1077             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1078                 @Override
1079                 protected boolean accepts(AttributeKind kind) {
1080                     return super.accepts(kind) &amp;&amp; allowModules;
1081                 }
1082                 protected void read(Symbol sym, int attrLen) {
1083                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1084                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1085                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1086 
1087                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);
1088                         if (currentModule.name != moduleName) {
1089                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1090                         }
1091 
1092                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1093                         msym.flags.addAll(moduleFlags);
1094                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);
1095 
1096                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1097                         int nrequires = nextChar();
1098                         for (int i = 0; i &lt; nrequires; i++) {
1099                             ModuleSymbol rsym = poolReader.getModule(nextChar());
1100                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1101                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1102                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1103                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1104                                 }
1105                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1106                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1107                                 }
1108                             }
1109                             nextChar(); // skip compiled version
1110                             requires.add(new RequiresDirective(rsym, flags));
1111                         }
1112                         msym.requires = requires.toList();
1113                         directives.addAll(msym.requires);
1114 
1115                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1116                         int nexports = nextChar();
1117                         for (int i = 0; i &lt; nexports; i++) {
1118                             PackageSymbol p = poolReader.getPackage(nextChar());
1119                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1120                             int nto = nextChar();
1121                             List&lt;ModuleSymbol&gt; to;
1122                             if (nto == 0) {
1123                                 to = null;
1124                             } else {
1125                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1126                                 for (int t = 0; t &lt; nto; t++)
1127                                     lb.append(poolReader.getModule(nextChar()));
1128                                 to = lb.toList();
1129                             }
1130                             exports.add(new ExportsDirective(p, to, flags));
1131                         }
1132                         msym.exports = exports.toList();
1133                         directives.addAll(msym.exports);
1134                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1135                         int nopens = nextChar();
1136                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1137                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1138                         }
1139                         for (int i = 0; i &lt; nopens; i++) {
1140                             PackageSymbol p = poolReader.getPackage(nextChar());
1141                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1142                             int nto = nextChar();
1143                             List&lt;ModuleSymbol&gt; to;
1144                             if (nto == 0) {
1145                                 to = null;
1146                             } else {
1147                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1148                                 for (int t = 0; t &lt; nto; t++)
1149                                     lb.append(poolReader.getModule(nextChar()));
1150                                 to = lb.toList();
1151                             }
1152                             opens.add(new OpensDirective(p, to, flags));
1153                         }
1154                         msym.opens = opens.toList();
1155                         directives.addAll(msym.opens);
1156 
1157                         msym.directives = directives.toList();
1158 
1159                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1160                         int nuses = nextChar();
1161                         for (int i = 0; i &lt; nuses; i++) {
1162                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1163                             uses.add(new InterimUsesDirective(srvc));
1164                         }
1165                         interimUses = uses.toList();
1166 
1167                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1168                         int nprovides = nextChar();
1169                         for (int p = 0; p &lt; nprovides; p++) {
1170                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);
1171                             int nimpls = nextChar();
1172                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1173                             for (int i = 0; i &lt; nimpls; i++) {
1174                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));
1175                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1176                             }
1177                         }
1178                         interimProvides = provides.toList();
1179                     }
1180                 }
1181 
1182                 private Name classNameMapper(byte[] arr, int offset, int length) {
1183                     return names.fromUtf(ClassFile.internalize(arr, offset, length));
1184                 }
1185             },
1186 
1187             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1188                 @Override
1189                 protected boolean accepts(AttributeKind kind) {
1190                     return super.accepts(kind) &amp;&amp; allowModules;
1191                 }
1192                 protected void read(Symbol sym, int attrLen) {
1193                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1194                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1195                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1196                     }
1197                 }
1198             },
1199 
1200             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {
1201                 @Override
1202                 protected boolean accepts(AttributeKind kind) {
1203                     return super.accepts(kind) &amp;&amp; allowRecords;
1204                 }
1205                 protected void read(Symbol sym, int attrLen) {
1206                     if (sym.kind == TYP) {
1207                         sym.flags_field |= RECORD;
1208                     }
1209                     bp = bp + attrLen;
1210                 }
1211             },
1212             new AttributeReader(names.PermittedSubclasses, V59, CLASS_ATTRIBUTE) {
1213                 @Override
1214                 protected boolean accepts(AttributeKind kind) {
1215                     return super.accepts(kind) &amp;&amp; allowSealedTypes;
1216                 }
1217                 protected void read(Symbol sym, int attrLen) {
1218                     if (sym.kind == TYP) {
1219                         ListBuffer&lt;Symbol&gt; subtypes = new ListBuffer&lt;&gt;();
1220                         int numberOfPermittedSubtypes = nextChar();
1221                         for (int i = 0; i &lt; numberOfPermittedSubtypes; i++) {
1222                             subtypes.add(poolReader.getClass(nextChar()));
1223                         }
1224                         ((ClassSymbol)sym).permitted = subtypes.toList();
1225                     }
1226                 }
1227             },
1228         };
1229 
1230         for (AttributeReader r: readers)
1231             attributeReaders.put(r.name, r);
1232     }
1233 
1234     protected void readEnclosingMethodAttr(Symbol sym) {
1235         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1236         // remove sym from it&#39;s current owners scope and place it in
1237         // the scope specified by the attribute
1238         sym.owner.members().remove(sym);
1239         ClassSymbol self = (ClassSymbol)sym;
1240         ClassSymbol c = poolReader.getClass(nextChar());
1241         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);
1242 
1243         if (c.members_field == null || c.kind != TYP)
1244             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1245 
1246         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1247         if (nt != null &amp;&amp; m == null)
1248             throw badEnclosingMethod(self);
1249 
1250         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1251         self.owner = m != null ? m : c;
1252         if (self.name.isEmpty())
1253             self.fullname = names.empty;
1254         else
1255             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1256 
1257         if (m != null) {
1258             ((ClassType)sym.type).setEnclosingType(m.type);
1259         } else if ((self.flags_field &amp; STATIC) == 0) {
1260             ((ClassType)sym.type).setEnclosingType(c.type);
1261         } else {
1262             ((ClassType)sym.type).setEnclosingType(Type.noType);
1263         }
1264         enterTypevars(self, self.type);
1265         if (!missingTypeVariables.isEmpty()) {
1266             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1267             for (Type typevar : missingTypeVariables) {
1268                 typeVars.append(findTypeVar(typevar.tsym.name));
1269             }
1270             foundTypeVariables = typeVars.toList();
1271         } else {
1272             foundTypeVariables = List.nil();
1273         }
1274     }
1275 
1276     // See java.lang.Class
1277     private Name simpleBinaryName(Name self, Name enclosing) {
1278         if (!self.startsWith(enclosing)) {
1279             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1280         }
1281 
1282         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1283         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1284             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1285         int index = 1;
1286         while (index &lt; simpleBinaryName.length() &amp;&amp;
1287                isAsciiDigit(simpleBinaryName.charAt(index)))
1288             index++;
1289         return names.fromString(simpleBinaryName.substring(index));
1290     }
1291 
1292     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1293         if (nt == null)
1294             return null;
1295 
1296         MethodType type = nt.type.asMethodType();
1297 
1298         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1299             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1300                 return (MethodSymbol)sym;
1301         }
1302 
1303         if (nt.name != names.init)
1304             // not a constructor
1305             return null;
1306         if ((flags &amp; INTERFACE) != 0)
1307             // no enclosing instance
1308             return null;
1309         if (nt.type.getParameterTypes().isEmpty())
1310             // no parameters
1311             return null;
1312 
1313         // A constructor of an inner class.
1314         // Remove the first argument (the enclosing instance)
1315         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,
1316                                  nt.type.getReturnType(),
1317                                  nt.type.getThrownTypes(),
1318                                  syms.methodClass));
1319         // Try searching again
1320         return findMethod(nt, scope, flags);
1321     }
1322 
1323     /** Similar to Types.isSameType but avoids completion */
1324     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1325         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1326             .prepend(types.erasure(mt1.getReturnType()));
1327         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1328         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1329             if (types1.head.tsym != types2.head.tsym)
1330                 return false;
1331             types1 = types1.tail;
1332             types2 = types2.tail;
1333         }
1334         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1335     }
1336 
1337     /**
1338      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1339      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1340      */
1341     private static boolean isAsciiDigit(char c) {
1342         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1343     }
1344 
1345     /** Read member attributes.
1346      */
1347     void readMemberAttrs(Symbol sym) {
1348         readAttrs(sym, AttributeKind.MEMBER);
1349     }
1350 
1351     void readAttrs(Symbol sym, AttributeKind kind) {
1352         char ac = nextChar();
1353         for (int i = 0; i &lt; ac; i++) {
1354             Name attrName = poolReader.getName(nextChar());
1355             int attrLen = nextInt();
1356             AttributeReader r = attributeReaders.get(attrName);
1357             if (r != null &amp;&amp; r.accepts(kind))
1358                 r.read(sym, attrLen);
1359             else  {
1360                 bp = bp + attrLen;
1361             }
1362         }
1363     }
1364 
1365     private boolean readingClassAttr = false;
1366     private List&lt;Type&gt; missingTypeVariables = List.nil();
1367     private List&lt;Type&gt; foundTypeVariables = List.nil();
1368 
1369     /** Read class attributes.
1370      */
1371     void readClassAttrs(ClassSymbol c) {
1372         readAttrs(c, AttributeKind.CLASS);
1373     }
1374 
1375     /** Read code block.
1376      */
1377     Code readCode(Symbol owner) {
1378         nextChar(); // max_stack
1379         nextChar(); // max_locals
1380         final int  code_length = nextInt();
1381         bp += code_length;
1382         final char exception_table_length = nextChar();
1383         bp += exception_table_length * 8;
1384         readMemberAttrs(owner);
1385         return null;
1386     }
1387 
1388 /************************************************************************
1389  * Reading Java-language annotations
1390  ***********************************************************************/
1391 
1392     /**
1393      * Save annotations.
1394      */
1395     List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
1396         int numAttributes = nextChar();
1397         ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();
1398         for (int i = 0; i &lt; numAttributes; i++) {
1399             annotations.append(readCompoundAnnotation());
1400         }
1401         return annotations.toList();
1402     }
1403 
1404     /** Attach annotations.
1405      */
1406     void attachAnnotations(final Symbol sym) {
1407         attachAnnotations(sym, readAnnotations());
1408     }
1409 
1410     /**
1411      * Attach annotations.
1412      */
1413     void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {
1414         if (annotations.isEmpty()) {
1415             return;
1416         }
1417         ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1418         for (CompoundAnnotationProxy proxy : annotations) {
1419             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1420                 sym.flags_field |= PROPRIETARY;
1421             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1422                 if (profile != Profile.DEFAULT) {
1423                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1424                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1425                             Attribute.Constant c = (Attribute.Constant)v.snd;
1426                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1427                                 sym.flags_field |= NOT_IN_PROFILE;
1428                             }
1429                         }
1430                     }
1431                 }
1432             } else {
1433                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1434                     target = proxy;
1435                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1436                     repeatable = proxy;
1437                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1438                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
1439                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);
1440                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {
1441                     sym.flags_field |= PREVIEW_API;
1442                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1443                 }
1444                 proxies.append(proxy);
1445             }
1446         }
1447         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1448     }
1449     //where:
1450         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {
1451             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1452                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {
1453                     Attribute.Constant c = (Attribute.Constant)v.snd;
1454                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
1455                         sym.flags_field |= flag;
1456                     }
1457                 }
1458             }
1459         }
1460 
1461     /** Read parameter annotations.
1462      */
1463     void readParameterAnnotations(Symbol meth) {
1464         int numParameters = buf.getByte(bp++) &amp; 0xFF;
1465         if (parameterAnnotations == null) {
1466             parameterAnnotations = new ParameterAnnotations[numParameters];
1467         } else if (parameterAnnotations.length != numParameters) {
1468             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1469         }
1470         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1471             if (parameterAnnotations[pnum] == null) {
1472                 parameterAnnotations[pnum] = new ParameterAnnotations();
1473             }
1474             parameterAnnotations[pnum].add(readAnnotations());
1475         }
1476     }
1477 
1478     void attachTypeAnnotations(final Symbol sym) {
1479         int numAttributes = nextChar();
1480         if (numAttributes != 0) {
1481             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1482             for (int i = 0; i &lt; numAttributes; i++)
1483                 proxies.append(readTypeAnnotation());
1484             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
1485         }
1486     }
1487 
1488     /** Attach the default value for an annotation element.
1489      */
1490     void attachAnnotationDefault(final Symbol sym) {
1491         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1492         final Attribute value = readAttributeValue();
1493 
1494         // The default value is set later during annotation. It might
1495         // be the case that the Symbol sym is annotated _after_ the
1496         // repeating instances that depend on this default value,
1497         // because of this we set an interim value that tells us this
1498         // element (most likely) has a default.
1499         //
1500         // Set interim value for now, reset just before we do this
1501         // properly at annotate time.
1502         meth.defaultValue = value;
1503         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1504     }
1505 
1506     Type readTypeOrClassSymbol(int i) {
1507         // support preliminary jsr175-format class files
1508         if (poolReader.hasTag(i, CONSTANT_Class))
1509             return poolReader.getClass(i).type;
1510         return readTypeToProxy(i);
1511     }
1512     Type readTypeToProxy(int i) {
1513         if (currentModule.module_info == currentOwner) {
1514             return new ProxyType(i);
1515         } else {
1516             return poolReader.getType(i);
1517         }
1518     }
1519 
1520     CompoundAnnotationProxy readCompoundAnnotation() {
1521         Type t;
1522         if (currentModule.module_info == currentOwner) {
1523             int cpIndex = nextChar();
1524             t = new ProxyType(cpIndex);
1525         } else {
1526             t = readTypeOrClassSymbol(nextChar());
1527         }
1528         int numFields = nextChar();
1529         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1530         for (int i=0; i&lt;numFields; i++) {
1531             Name name = poolReader.getName(nextChar());
1532             Attribute value = readAttributeValue();
1533             pairs.append(new Pair&lt;&gt;(name, value));
1534         }
1535         return new CompoundAnnotationProxy(t, pairs.toList());
1536     }
1537 
1538     TypeAnnotationProxy readTypeAnnotation() {
1539         TypeAnnotationPosition position = readPosition();
1540         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1541 
1542         return new TypeAnnotationProxy(proxy, position);
1543     }
1544 
1545     TypeAnnotationPosition readPosition() {
1546         int tag = nextByte(); // TargetType tag is a byte
1547 
1548         if (!TargetType.isValidTargetTypeValue(tag))
1549             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1550 
1551         TargetType type = TargetType.fromTargetTypeValue(tag);
1552 
1553         switch (type) {
1554         // instanceof
1555         case INSTANCEOF: {
1556             final int offset = nextChar();
1557             final TypeAnnotationPosition position =
1558                 TypeAnnotationPosition.instanceOf(readTypePath());
1559             position.offset = offset;
1560             return position;
1561         }
1562         // new expression
1563         case NEW: {
1564             final int offset = nextChar();
1565             final TypeAnnotationPosition position =
1566                 TypeAnnotationPosition.newObj(readTypePath());
1567             position.offset = offset;
1568             return position;
1569         }
1570         // constructor/method reference receiver
1571         case CONSTRUCTOR_REFERENCE: {
1572             final int offset = nextChar();
1573             final TypeAnnotationPosition position =
1574                 TypeAnnotationPosition.constructorRef(readTypePath());
1575             position.offset = offset;
1576             return position;
1577         }
1578         case METHOD_REFERENCE: {
1579             final int offset = nextChar();
1580             final TypeAnnotationPosition position =
1581                 TypeAnnotationPosition.methodRef(readTypePath());
1582             position.offset = offset;
1583             return position;
1584         }
1585         // local variable
1586         case LOCAL_VARIABLE: {
1587             final int table_length = nextChar();
1588             final int[] newLvarOffset = new int[table_length];
1589             final int[] newLvarLength = new int[table_length];
1590             final int[] newLvarIndex = new int[table_length];
1591 
1592             for (int i = 0; i &lt; table_length; ++i) {
1593                 newLvarOffset[i] = nextChar();
1594                 newLvarLength[i] = nextChar();
1595                 newLvarIndex[i] = nextChar();
1596             }
1597 
1598             final TypeAnnotationPosition position =
1599                     TypeAnnotationPosition.localVariable(readTypePath());
1600             position.lvarOffset = newLvarOffset;
1601             position.lvarLength = newLvarLength;
1602             position.lvarIndex = newLvarIndex;
1603             return position;
1604         }
1605         // resource variable
1606         case RESOURCE_VARIABLE: {
1607             final int table_length = nextChar();
1608             final int[] newLvarOffset = new int[table_length];
1609             final int[] newLvarLength = new int[table_length];
1610             final int[] newLvarIndex = new int[table_length];
1611 
1612             for (int i = 0; i &lt; table_length; ++i) {
1613                 newLvarOffset[i] = nextChar();
1614                 newLvarLength[i] = nextChar();
1615                 newLvarIndex[i] = nextChar();
1616             }
1617 
1618             final TypeAnnotationPosition position =
1619                     TypeAnnotationPosition.resourceVariable(readTypePath());
1620             position.lvarOffset = newLvarOffset;
1621             position.lvarLength = newLvarLength;
1622             position.lvarIndex = newLvarIndex;
1623             return position;
1624         }
1625         // exception parameter
1626         case EXCEPTION_PARAMETER: {
1627             final int exception_index = nextChar();
1628             final TypeAnnotationPosition position =
1629                 TypeAnnotationPosition.exceptionParameter(readTypePath());
1630             position.setExceptionIndex(exception_index);
1631             return position;
1632         }
1633         // method receiver
1634         case METHOD_RECEIVER:
1635             return TypeAnnotationPosition.methodReceiver(readTypePath());
1636         // type parameter
1637         case CLASS_TYPE_PARAMETER: {
1638             final int parameter_index = nextByte();
1639             return TypeAnnotationPosition
1640                 .typeParameter(readTypePath(), parameter_index);
1641         }
1642         case METHOD_TYPE_PARAMETER: {
1643             final int parameter_index = nextByte();
1644             return TypeAnnotationPosition
1645                 .methodTypeParameter(readTypePath(), parameter_index);
1646         }
1647         // type parameter bound
1648         case CLASS_TYPE_PARAMETER_BOUND: {
1649             final int parameter_index = nextByte();
1650             final int bound_index = nextByte();
1651             return TypeAnnotationPosition
1652                 .typeParameterBound(readTypePath(), parameter_index,
1653                                     bound_index);
1654         }
1655         case METHOD_TYPE_PARAMETER_BOUND: {
1656             final int parameter_index = nextByte();
1657             final int bound_index = nextByte();
1658             return TypeAnnotationPosition
1659                 .methodTypeParameterBound(readTypePath(), parameter_index,
1660                                           bound_index);
1661         }
1662         // class extends or implements clause
1663         case CLASS_EXTENDS: {
1664             final int type_index = nextChar();
1665             return TypeAnnotationPosition.classExtends(readTypePath(),
1666                                                        type_index);
1667         }
1668         // throws
1669         case THROWS: {
1670             final int type_index = nextChar();
1671             return TypeAnnotationPosition.methodThrows(readTypePath(),
1672                                                        type_index);
1673         }
1674         // method parameter
1675         case METHOD_FORMAL_PARAMETER: {
1676             final int parameter_index = nextByte();
1677             return TypeAnnotationPosition.methodParameter(readTypePath(),
1678                                                           parameter_index);
1679         }
1680         // type cast
1681         case CAST: {
1682             final int offset = nextChar();
1683             final int type_index = nextByte();
1684             final TypeAnnotationPosition position =
1685                 TypeAnnotationPosition.typeCast(readTypePath(), type_index);
1686             position.offset = offset;
1687             return position;
1688         }
1689         // method/constructor/reference type argument
1690         case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {
1691             final int offset = nextChar();
1692             final int type_index = nextByte();
1693             final TypeAnnotationPosition position = TypeAnnotationPosition
1694                 .constructorInvocationTypeArg(readTypePath(), type_index);
1695             position.offset = offset;
1696             return position;
1697         }
1698         case METHOD_INVOCATION_TYPE_ARGUMENT: {
1699             final int offset = nextChar();
1700             final int type_index = nextByte();
1701             final TypeAnnotationPosition position = TypeAnnotationPosition
1702                 .methodInvocationTypeArg(readTypePath(), type_index);
1703             position.offset = offset;
1704             return position;
1705         }
1706         case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {
1707             final int offset = nextChar();
1708             final int type_index = nextByte();
1709             final TypeAnnotationPosition position = TypeAnnotationPosition
1710                 .constructorRefTypeArg(readTypePath(), type_index);
1711             position.offset = offset;
1712             return position;
1713         }
1714         case METHOD_REFERENCE_TYPE_ARGUMENT: {
1715             final int offset = nextChar();
1716             final int type_index = nextByte();
1717             final TypeAnnotationPosition position = TypeAnnotationPosition
1718                 .methodRefTypeArg(readTypePath(), type_index);
1719             position.offset = offset;
1720             return position;
1721         }
1722         // We don&#39;t need to worry about these
1723         case METHOD_RETURN:
1724             return TypeAnnotationPosition.methodReturn(readTypePath());
1725         case FIELD:
1726             return TypeAnnotationPosition.field(readTypePath());
1727         case UNKNOWN:
1728             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1729         default:
1730             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1731         }
1732     }
1733 
1734     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1735         int len = nextByte();
1736         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1737         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1738             loc = loc.append(nextByte());
1739 
1740         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1741 
1742     }
1743 
1744     /**
1745      * Helper function to read an optional pool entry (with given function); this is used while parsing
1746      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,
1747      * as per JVMS.
1748      */
1749     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {
1750         return (index == 0) ?
1751                 defaultValue :
1752                 poolFunc.apply(index);
1753     }
1754 
1755     Attribute readAttributeValue() {
1756         char c = (char) buf.getByte(bp++);
1757         switch (c) {
1758         case &#39;B&#39;:
1759             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));
1760         case &#39;C&#39;:
1761             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));
1762         case &#39;D&#39;:
1763             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));
1764         case &#39;F&#39;:
1765             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));
1766         case &#39;I&#39;:
1767             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));
1768         case &#39;J&#39;:
1769             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));
1770         case &#39;S&#39;:
1771             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));
1772         case &#39;Z&#39;:
1773             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));
1774         case &#39;s&#39;:
1775             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());
1776         case &#39;e&#39;:
1777             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));
1778         case &#39;c&#39;:
1779             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1780         case &#39;[&#39;: {
1781             int n = nextChar();
1782             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1783             for (int i=0; i&lt;n; i++)
1784                 l.append(readAttributeValue());
1785             return new ArrayAttributeProxy(l.toList());
1786         }
1787         case &#39;@&#39;:
1788             return readCompoundAnnotation();
1789         default:
1790             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1791         }
1792     }
1793 
1794     interface ProxyVisitor extends Attribute.Visitor {
1795         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1796         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1797         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
1798         void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
1799     }
1800 
1801     static class EnumAttributeProxy extends Attribute {
1802         Type enumType;
1803         Name enumerator;
1804         public EnumAttributeProxy(Type enumType, Name enumerator) {
1805             super(null);
1806             this.enumType = enumType;
1807             this.enumerator = enumerator;
1808         }
1809         public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
1810         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1811         public String toString() {
1812             return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;
1813         }
1814     }
1815 
1816     static class ClassAttributeProxy extends Attribute {
1817         Type classType;
1818         public ClassAttributeProxy(Type classType) {
1819             super(null);
1820             this.classType = classType;
1821         }
1822         public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }
1823         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1824         public String toString() {
1825             return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;
1826         }
1827     }
1828 
1829     static class ArrayAttributeProxy extends Attribute {
1830         List&lt;Attribute&gt; values;
1831         ArrayAttributeProxy(List&lt;Attribute&gt; values) {
1832             super(null);
1833             this.values = values;
1834         }
1835         public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }
1836         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1837         public String toString() {
1838             return &quot;{&quot; + values + &quot;}&quot;;
1839         }
1840     }
1841 
1842     /** A temporary proxy representing a compound attribute.
1843      */
1844     static class CompoundAnnotationProxy extends Attribute {
1845         final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
1846         public CompoundAnnotationProxy(Type type,
1847                                       List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
1848             super(type);
1849             this.values = values;
1850         }
1851         public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
1852         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1853         public String toString() {
1854             StringBuilder buf = new StringBuilder();
1855             buf.append(&quot;@&quot;);
1856             buf.append(type.tsym.getQualifiedName());
1857             buf.append(&quot;/*proxy*/{&quot;);
1858             boolean first = true;
1859             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
1860                  v.nonEmpty(); v = v.tail) {
1861                 Pair&lt;Name,Attribute&gt; value = v.head;
1862                 if (!first) buf.append(&quot;,&quot;);
1863                 first = false;
1864                 buf.append(value.fst);
1865                 buf.append(&quot;=&quot;);
1866                 buf.append(value.snd);
1867             }
1868             buf.append(&quot;}&quot;);
1869             return buf.toString();
1870         }
1871     }
1872 
1873     /** A temporary proxy representing a type annotation.
1874      */
1875     static class TypeAnnotationProxy {
1876         final CompoundAnnotationProxy compound;
1877         final TypeAnnotationPosition position;
1878         public TypeAnnotationProxy(CompoundAnnotationProxy compound,
1879                 TypeAnnotationPosition position) {
1880             this.compound = compound;
1881             this.position = position;
1882         }
1883     }
1884 
1885     class AnnotationDeproxy implements ProxyVisitor {
1886         private ClassSymbol requestingOwner;
1887 
1888         AnnotationDeproxy(ClassSymbol owner) {
1889             this.requestingOwner = owner;
1890         }
1891 
1892         List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {
1893             // also must fill in types!!!!
1894             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
1895             for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
1896                 buf.append(deproxyCompound(l.head));
1897             }
1898             return buf.toList();
1899         }
1900 
1901         Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {
1902             Type annotationType = resolvePossibleProxyType(a.type);
1903             ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
1904             for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
1905                  l.nonEmpty();
1906                  l = l.tail) {
1907                 MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
1908                 buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
1909             }
1910             return new Attribute.Compound(annotationType, buf.toList());
1911         }
1912 
1913         MethodSymbol findAccessMethod(Type container, Name name) {
1914             CompletionFailure failure = null;
1915             try {
1916                 for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
1917                     if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
1918                         return (MethodSymbol) sym;
1919                 }
1920             } catch (CompletionFailure ex) {
1921                 failure = ex;
1922             }
1923             // The method wasn&#39;t found: emit a warning and recover
1924             JavaFileObject prevSource = log.useSource(requestingOwner.classfile);
1925             try {
1926                 if (lintClassfile) {
1927                     if (failure == null) {
1928                         log.warning(Warnings.AnnotationMethodNotFound(container, name));
1929                     } else {
1930                         log.warning(Warnings.AnnotationMethodNotFoundReason(container,
1931                                                                             name,
1932                                                                             failure.getDetailValue()));//diagnostic, if present
1933                     }
1934                 }
1935             } finally {
1936                 log.useSource(prevSource);
1937             }
1938             // Construct a new method type and symbol.  Use bottom
1939             // type (typeof null) as return type because this type is
1940             // a subtype of all reference types and can be converted
1941             // to primitive types by unboxing.
1942             MethodType mt = new MethodType(List.nil(),
1943                                            syms.botType,
1944                                            List.nil(),
1945                                            syms.methodClass);
1946             return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);
1947         }
1948 
1949         Attribute result;
1950         Type type;
1951         Attribute deproxy(Type t, Attribute a) {
1952             Type oldType = type;
1953             try {
1954                 type = t;
1955                 a.accept(this);
1956                 return result;
1957             } finally {
1958                 type = oldType;
1959             }
1960         }
1961 
1962         // implement Attribute.Visitor below
1963 
1964         public void visitConstant(Attribute.Constant value) {
1965             // assert value.type == type;
1966             result = value;
1967         }
1968 
1969         public void visitClass(Attribute.Class clazz) {
1970             result = clazz;
1971         }
1972 
1973         public void visitEnum(Attribute.Enum e) {
1974             throw new AssertionError(); // shouldn&#39;t happen
1975         }
1976 
1977         public void visitCompound(Attribute.Compound compound) {
1978             throw new AssertionError(); // shouldn&#39;t happen
1979         }
1980 
1981         public void visitArray(Attribute.Array array) {
1982             throw new AssertionError(); // shouldn&#39;t happen
1983         }
1984 
1985         public void visitError(Attribute.Error e) {
1986             throw new AssertionError(); // shouldn&#39;t happen
1987         }
1988 
1989         public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {
1990             // type.tsym.flatName() should == proxy.enumFlatName
1991             Type enumType = resolvePossibleProxyType(proxy.enumType);
1992             TypeSymbol enumTypeSym = enumType.tsym;
1993             VarSymbol enumerator = null;
1994             CompletionFailure failure = null;
1995             try {
1996                 for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
1997                     if (sym.kind == VAR) {
1998                         enumerator = (VarSymbol)sym;
1999                         break;
2000                     }
2001                 }
2002             }
2003             catch (CompletionFailure ex) {
2004                 failure = ex;
2005             }
2006             if (enumerator == null) {
2007                 if (failure != null) {
2008                     log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
2009                                                                    enumTypeSym,
2010                                                                    proxy.enumerator,
2011                                                                    failure.getDiagnostic()));
2012                 } else {
2013                     log.warning(Warnings.UnknownEnumConstant(currentClassFile,
2014                                                              enumTypeSym,
2015                                                              proxy.enumerator));
2016                 }
2017                 result = new Attribute.Enum(enumTypeSym.type,
2018                         new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));
2019             } else {
2020                 result = new Attribute.Enum(enumTypeSym.type, enumerator);
2021             }
2022         }
2023 
2024         @Override
2025         public void visitClassAttributeProxy(ClassAttributeProxy proxy) {
2026             Type classType = resolvePossibleProxyType(proxy.classType);
2027             result = new Attribute.Class(types, classType);
2028         }
2029 
2030         public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {
2031             int length = proxy.values.length();
2032             Attribute[] ats = new Attribute[length];
2033             Type elemtype = types.elemtype(type);
2034             int i = 0;
2035             for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {
2036                 ats[i++] = deproxy(elemtype, p.head);
2037             }
2038             result = new Attribute.Array(type, ats);
2039         }
2040 
2041         public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
2042             result = deproxyCompound(proxy);
2043         }
2044 
2045         Type resolvePossibleProxyType(Type t) {
2046             if (t instanceof ProxyType) {
2047                 Assert.check(requestingOwner.owner.kind == MDL);
2048                 ModuleSymbol prevCurrentModule = currentModule;
2049                 currentModule = (ModuleSymbol) requestingOwner.owner;
2050                 try {
2051                     return ((ProxyType) t).resolve();
2052                 } finally {
2053                     currentModule = prevCurrentModule;
2054                 }
2055             } else {
2056                 return t;
2057             }
2058         }
2059     }
2060 
2061     class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
2062         final MethodSymbol sym;
2063         final Attribute value;
2064         final JavaFileObject classFile = currentClassFile;
2065 
2066         AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
2067             super(currentOwner.kind == MTH
2068                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2069             this.sym = sym;
2070             this.value = value;
2071         }
2072 
2073         @Override
2074         public void run() {
2075             JavaFileObject previousClassFile = currentClassFile;
2076             try {
2077                 // Reset the interim value set earlier in
2078                 // attachAnnotationDefault().
2079                 sym.defaultValue = null;
2080                 currentClassFile = classFile;
2081                 sym.defaultValue = deproxy(sym.type.getReturnType(), value);
2082             } finally {
2083                 currentClassFile = previousClassFile;
2084             }
2085         }
2086 
2087         @Override
2088         public String toString() {
2089             return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;
2090         }
2091     }
2092 
2093     class AnnotationCompleter extends AnnotationDeproxy implements Runnable {
2094         final Symbol sym;
2095         final List&lt;CompoundAnnotationProxy&gt; l;
2096         final JavaFileObject classFile;
2097 
2098         AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {
2099             super(currentOwner.kind == MTH
2100                     ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
2101             if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
2102                 this.sym = sym.owner;
2103             } else {
2104                 this.sym = sym;
2105             }
2106             this.l = l;
2107             this.classFile = currentClassFile;
2108         }
2109 
2110         @Override
2111         public void run() {
2112             JavaFileObject previousClassFile = currentClassFile;
2113             try {
2114                 currentClassFile = classFile;
2115                 List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
2116                 for (Attribute.Compound attr : newList) {
2117                     if (attr.type.tsym == syms.deprecatedType.tsym) {
2118                         sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
2119                         Attribute forRemoval = attr.member(names.forRemoval);
2120                         if (forRemoval instanceof Attribute.Constant) {
2121                             Attribute.Constant c = (Attribute.Constant) forRemoval;
2122                             if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {
2123                                 sym.flags_field |= DEPRECATED_REMOVAL;
2124                             }
2125                         }
2126                     }
2127                 }
2128                 if (sym.annotationsPendingCompletion()) {
2129                     sym.setDeclarationAttributes(newList);
2130                 } else {
2131                     sym.appendAttributes(newList);
2132                 }
2133             } finally {
2134                 currentClassFile = previousClassFile;
2135             }
2136         }
2137 
2138         @Override
2139         public String toString() {
2140             return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;
2141         }
2142     }
2143 
2144     class TypeAnnotationCompleter extends AnnotationCompleter {
2145 
2146         List&lt;TypeAnnotationProxy&gt; proxies;
2147 
2148         TypeAnnotationCompleter(Symbol sym,
2149                 List&lt;TypeAnnotationProxy&gt; proxies) {
2150             super(sym, List.nil());
2151             this.proxies = proxies;
2152         }
2153 
2154         List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {
2155             ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();
2156             for (TypeAnnotationProxy proxy: proxies) {
2157                 Attribute.Compound compound = deproxyCompound(proxy.compound);
2158                 Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);
2159                 buf.add(typeCompound);
2160             }
2161             return buf.toList();
2162         }
2163 
2164         @Override
2165         public void run() {
2166             JavaFileObject previousClassFile = currentClassFile;
2167             try {
2168                 currentClassFile = classFile;
2169                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2170                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2171             } finally {
2172                 currentClassFile = previousClassFile;
2173             }
2174         }
2175     }
2176 
2177 
2178 /************************************************************************
2179  * Reading Symbols
2180  ***********************************************************************/
2181 
2182     /** Read a field.
2183      */
2184     VarSymbol readField() {
2185         long flags = adjustFieldFlags(nextChar());
2186         Name name = poolReader.getName(nextChar());
2187         Type type = poolReader.getType(nextChar());
2188         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2189         readMemberAttrs(v);
2190         return v;
2191     }
2192 
2193     /** Read a method.
2194      */
2195     MethodSymbol readMethod() {
2196         long flags = adjustMethodFlags(nextChar());
2197         Name name = poolReader.getName(nextChar());
2198         Type type = poolReader.getType(nextChar());
2199         if (currentOwner.isInterface() &amp;&amp;
2200                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2201             if (majorVersion &gt; Version.V52.major ||
2202                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2203                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2204                     currentOwner.flags_field |= DEFAULT;
2205                     flags |= DEFAULT | ABSTRACT;
2206                 }
2207             } else {
2208                 //protect against ill-formed classfiles
2209                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2210                                    Integer.toString(majorVersion),
2211                                    Integer.toString(minorVersion));
2212             }
2213         }
2214         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2215             // Sometimes anonymous classes don&#39;t have an outer
2216             // instance, however, there is no reliable way to tell so
2217             // we never strip this$n
2218             // ditto for local classes. Local classes that have an enclosing method set
2219             // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
2220             // enclosing method (i.e. from initializers) will pass that check.
2221             boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);
2222             if (!currentOwner.name.isEmpty() &amp;&amp; !local)
2223                 type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),
2224                                       type.getReturnType(),
2225                                       type.getThrownTypes(),
2226                                       syms.methodClass);
2227         }
2228         MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);
2229         if (types.isSignaturePolymorphic(m)) {
2230             m.flags_field |= SIGNATURE_POLYMORPHIC;
2231         }
2232         if (saveParameterNames)
2233             initParameterNames(m);
2234         Symbol prevOwner = currentOwner;
2235         currentOwner = m;
2236         try {
2237             readMemberAttrs(m);
2238         } finally {
2239             currentOwner = prevOwner;
2240         }
2241         setParameters(m, type);
2242 
2243         if ((flags &amp; VARARGS) != 0) {
2244             final Type last = type.getParameterTypes().last();
2245             if (last == null || !last.hasTag(ARRAY)) {
2246                 m.flags_field &amp;= ~VARARGS;
2247                 throw badClassFile(&quot;malformed.vararg.method&quot;, m);
2248             }
2249         }
2250 
2251         return m;
2252     }
2253 
2254     private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {
2255         if (args.isEmpty()) {
2256             return args;
2257         }
2258         boolean isVarargs = (flags &amp; VARARGS) != 0;
2259         if (isVarargs) {
2260             Type varargsElem = args.last();
2261             ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
2262             for (Type t : args) {
2263                 adjustedArgs.append(t != varargsElem ?
2264                     t :
2265                     ((ArrayType)t).makeVarargs());
2266             }
2267             args = adjustedArgs.toList();
2268         }
2269         return args.tail;
2270     }
2271 
2272     /**
2273      * Init the parameter names array.
2274      * Parameter names are currently inferred from the names in the
2275      * LocalVariableTable attributes of a Code attribute.
2276      * (Note: this means parameter names are currently not available for
2277      * methods without a Code attribute.)
2278      * This method initializes an array in which to store the name indexes
2279      * of parameter names found in LocalVariableTable attributes. It is
2280      * slightly supersized to allow for additional slots with a start_pc of 0.
2281      */
2282     void initParameterNames(MethodSymbol sym) {
2283         // make allowance for synthetic parameters.
2284         final int excessSlots = 4;
2285         int expectedParameterSlots =
2286                 Code.width(sym.type.getParameterTypes()) + excessSlots;
2287         if (parameterNameIndices == null
2288                 || parameterNameIndices.length &lt; expectedParameterSlots) {
2289             parameterNameIndices = new int[expectedParameterSlots];
2290         } else
2291             Arrays.fill(parameterNameIndices, 0);
2292         haveParameterNameIndices = false;
2293         sawMethodParameters = false;
2294     }
2295 
2296     /**
2297      * Set the parameters for a method symbol, including any names and
2298      * annotations that were read.
2299      *
2300      * &lt;p&gt;The type of the symbol may have changed while reading the
2301      * method attributes (see the Signature attribute). This may be
2302      * because of generic information or because anonymous synthetic
2303      * parameters were added.   The original type (as read from the
2304      * method descriptor) is used to help guess the existence of
2305      * anonymous synthetic parameters.
2306      */
2307     void setParameters(MethodSymbol sym, Type jvmType) {
2308         // If we get parameter names from MethodParameters, then we
2309         // don&#39;t need to skip.
2310         int firstParam = 0;
2311         if (!sawMethodParameters) {
2312             firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
2313             // the code in readMethod may have skipped the first
2314             // parameter when setting up the MethodType. If so, we
2315             // make a corresponding allowance here for the position of
2316             // the first parameter.  Note that this assumes the
2317             // skipped parameter has a width of 1 -- i.e. it is not
2318             // a double width type (long or double.)
2319             if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2320                 // Sometimes anonymous classes don&#39;t have an outer
2321                 // instance, however, there is no reliable way to tell so
2322                 // we never strip this$n
2323                 if (!currentOwner.name.isEmpty())
2324                     firstParam += 1;
2325             }
2326 
2327             if (sym.type != jvmType) {
2328                 // reading the method attributes has caused the
2329                 // symbol&#39;s type to be changed. (i.e. the Signature
2330                 // attribute.)  This may happen if there are hidden
2331                 // (synthetic) parameters in the descriptor, but not
2332                 // in the Signature.  The position of these hidden
2333                 // parameters is unspecified; for now, assume they are
2334                 // at the beginning, and so skip over them. The
2335                 // primary case for this is two hidden parameters
2336                 // passed into Enum constructors.
2337                 int skip = Code.width(jvmType.getParameterTypes())
2338                         - Code.width(sym.type.getParameterTypes());
2339                 firstParam += skip;
2340             }
2341         }
2342         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();
2343         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2344         int nameIndex = firstParam;
2345         int annotationIndex = 0;
2346         for (Type t: sym.type.getParameterTypes()) {
2347             VarSymbol param = parameter(nameIndex, t, sym, paramNames);
2348             params.append(param);
2349             if (parameterAnnotations != null) {
2350                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2351                 if (annotations != null &amp;&amp; annotations.proxies != null
2352                         &amp;&amp; !annotations.proxies.isEmpty()) {
2353                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2354                 }
2355             }
2356             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2357             annotationIndex++;
2358         }
2359         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2360             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2361         }
2362         Assert.checkNull(sym.params);
2363         sym.params = params.toList();
2364         parameterAnnotations = null;
2365         parameterNameIndices = null;
2366     }
2367 
2368 
2369     // Returns the name for the parameter at position &#39;index&#39;, either using
2370     // names read from the MethodParameters, or by synthesizing a name that
2371     // is not on the &#39;exclude&#39; list.
2372     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {
2373         long flags = PARAMETER;
2374         Name argName;
2375         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2376                 &amp;&amp; parameterNameIndices[index] != 0) {
2377             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);
2378             flags |= NAME_FILLED;
2379         } else {
2380             String prefix = &quot;arg&quot;;
2381             while (true) {
2382                 argName = names.fromString(prefix + exclude.size());
2383                 if (!exclude.contains(argName))
2384                     break;
2385                 prefix += &quot;$&quot;;
2386             }
2387         }
2388         exclude.add(argName);
2389         return new ParamSymbol(flags, argName, t, owner);
2390     }
2391 
2392     /**
2393      * skip n bytes
2394      */
2395     void skipBytes(int n) {
2396         bp = bp + n;
2397     }
2398 
2399     /** Skip a field or method
2400      */
2401     void skipMember() {
2402         bp = bp + 6;
2403         char ac = nextChar();
2404         for (int i = 0; i &lt; ac; i++) {
2405             bp = bp + 2;
2406             int attrLen = nextInt();
2407             bp = bp + attrLen;
2408         }
2409     }
2410 
2411     void skipInnerClasses() {
2412         int n = nextChar();
2413         for (int i = 0; i &lt; n; i++) {
2414             nextChar();
2415             nextChar();
2416             nextChar();
2417             nextChar();
2418         }
2419     }
2420 
2421     /** Enter type variables of this classtype and all enclosing ones in
2422      *  `typevars&#39;.
2423      */
2424     protected void enterTypevars(Symbol sym, Type t) {
2425         if (t.getEnclosingType() != null) {
2426             if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
2427                 enterTypevars(sym.owner, t.getEnclosingType());
2428             }
2429         } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
2430             enterTypevars(sym.owner, sym.owner.type);
2431         }
2432         for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
2433             typevars.enter(xs.head.tsym);
2434         }
2435     }
2436 
2437     protected ClassSymbol enterClass(Name name) {
2438         return syms.enterClass(currentModule, name);
2439     }
2440 
2441     protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
2442         return syms.enterClass(currentModule, name, owner);
2443     }
2444 
2445     /** Read contents of a given class symbol `c&#39;. Both external and internal
2446      *  versions of an inner class are read.
2447      */
2448     void readClass(ClassSymbol c) {
2449         ClassType ct = (ClassType)c.type;
2450 
2451         // allocate scope for members
2452         c.members_field = WriteableScope.create(c);
2453 
2454         // prepare type variable table
2455         typevars = typevars.dup(currentOwner);
2456         if (ct.getEnclosingType().hasTag(CLASS))
2457             enterTypevars(c.owner, ct.getEnclosingType());
2458 
2459         // read flags, or skip if this is an inner class
2460         long f = nextChar();
2461         long flags = adjustClassFlags(f);
2462         if ((flags &amp; MODULE) == 0) {
2463             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2464             // read own class name and check that it matches
2465             currentModule = c.packge().modle;
2466             ClassSymbol self = poolReader.getClass(nextChar());
2467             if (c != self) {
2468                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2469                                    self.flatname);
2470             }
2471         } else {
2472             if (majorVersion &lt; Version.V53.major) {
2473                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2474                         Integer.toString(majorVersion),
2475                         Integer.toString(minorVersion));
2476             }
2477             c.flags_field = flags;
2478             currentModule = (ModuleSymbol) c.owner;
2479             int this_class = nextChar();
2480             // temp, no check on this_class
2481         }
2482 
2483         // class attributes must be read before class
2484         // skip ahead to read class attributes
2485         int startbp = bp;
2486         nextChar();
2487         char interfaceCount = nextChar();
2488         bp += interfaceCount * 2;
2489         char fieldCount = nextChar();
2490         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2491         char methodCount = nextChar();
2492         for (int i = 0; i &lt; methodCount; i++) skipMember();
2493         readClassAttrs(c);
2494 
2495         if (c.permitted != null &amp;&amp; !c.permitted.isEmpty()) {
2496             c.flags_field |= SEALED;
2497         }
2498 
2499         // reset and read rest of classinfo
2500         bp = startbp;
2501         int n = nextChar();
2502         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2503             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2504         }
2505         if (ct.supertype_field == null)
2506             ct.supertype_field =
2507                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);
2508         n = nextChar();
2509         List&lt;Type&gt; is = List.nil();
2510         for (int i = 0; i &lt; n; i++) {
2511             Type _inter = poolReader.getClass(nextChar()).erasure(types);
2512             is = is.prepend(_inter);
2513         }
2514         if (ct.interfaces_field == null)
2515             ct.interfaces_field = is.reverse();
2516 
2517         Assert.check(fieldCount == nextChar());
2518         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2519         Assert.check(methodCount == nextChar());
2520         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2521 
2522         typevars = typevars.leave();
2523     }
2524 
2525     /** Read inner class info. For each inner/outer pair allocate a
2526      *  member class.
2527      */
2528     void readInnerClasses(ClassSymbol c) {
2529         int n = nextChar();
2530         for (int i = 0; i &lt; n; i++) {
2531             nextChar(); // skip inner class symbol
2532             int outerIdx = nextChar();
2533             int nameIdx = nextChar();
2534             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);
2535             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);
2536             if (name == null) name = names.empty;
2537             long flags = adjustClassFlags(nextChar());
2538             if (outer != null) { // we have a member class
2539                 if (name == names.empty)
2540                     name = names.one;
2541                 ClassSymbol member = enterClass(name, outer);
2542                 if ((flags &amp; STATIC) == 0) {
2543                     ((ClassType)member.type).setEnclosingType(outer.type);
2544                     if (member.erasure_field != null)
2545                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2546                 }
2547                 if (c == outer) {
2548                     member.flags_field = flags;
2549                     enterMember(c, member);
2550                 }
2551             }
2552         }
2553     }
2554 
2555     /** Read a class definition from the bytes in buf.
2556      */
2557     private void readClassBuffer(ClassSymbol c) throws IOException {
2558         int magic = nextInt();
2559         if (magic != JAVA_MAGIC)
2560             throw badClassFile(&quot;illegal.start.of.class.file&quot;);
2561 
2562         minorVersion = nextChar();
2563         majorVersion = nextChar();
2564         int maxMajor = Version.MAX().major;
2565         int maxMinor = Version.MAX().minor;
2566         if (majorVersion &gt; maxMajor ||
2567             majorVersion * 1000 + minorVersion &lt;
2568             Version.MIN().major * 1000 + Version.MIN().minor) {
2569             if (majorVersion == (maxMajor + 1))
2570                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2571                                                      majorVersion,
2572                                                      maxMajor));
2573             else
2574                 throw badClassFile(&quot;wrong.version&quot;,
2575                                    Integer.toString(majorVersion),
2576                                    Integer.toString(minorVersion),
2577                                    Integer.toString(maxMajor),
2578                                    Integer.toString(maxMinor));
2579         }
2580 
2581         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2582             if (!preview.isEnabled()) {
2583                 log.error(preview.disabledError(currentClassFile, majorVersion));
2584             } else {
2585                 preview.warnPreview(c.classfile, majorVersion);
2586             }
2587         }
2588 
2589         poolReader = new PoolReader(this, names, syms);
2590         bp = poolReader.readPool(buf, bp);
2591         if (signatureBuffer.length &lt; bp) {
2592             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2593             signatureBuffer = new byte[ns];
2594         }
2595         readClass(c);
2596     }
2597 
2598     public void readClassFile(ClassSymbol c) {
2599         currentOwner = c;
2600         currentClassFile = c.classfile;
2601         warnedAttrs.clear();
2602         filling = true;
2603         target = null;
2604         repeatable = null;
2605         try {
2606             bp = 0;
2607             buf.reset();
2608             buf.appendStream(c.classfile.openInputStream());
2609             readClassBuffer(c);
2610             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2611                 List&lt;Type&gt; missing = missingTypeVariables;
2612                 List&lt;Type&gt; found = foundTypeVariables;
2613                 missingTypeVariables = List.nil();
2614                 foundTypeVariables = List.nil();
2615                 interimUses = List.nil();
2616                 interimProvides = List.nil();
2617                 filling = false;
2618                 ClassType ct = (ClassType)currentOwner.type;
2619                 ct.supertype_field =
2620                     types.subst(ct.supertype_field, missing, found);
2621                 ct.interfaces_field =
2622                     types.subst(ct.interfaces_field, missing, found);
2623                 ct.typarams_field =
2624                     types.substBounds(ct.typarams_field, missing, found);
2625                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2626                     types.head.tsym.type = types.head;
2627                 }
2628             } else if (missingTypeVariables.isEmpty() !=
2629                        foundTypeVariables.isEmpty()) {
2630                 Name name = missingTypeVariables.head.tsym.name;
2631                 throw badClassFile(&quot;undecl.type.var&quot;, name);
2632             }
2633 
2634             if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
2635                 c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
2636             } else {
2637                 c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
2638             }
2639 
2640             if (c == currentModule.module_info) {
2641                 if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
2642                     Assert.check(currentModule.isCompleted());
2643                     currentModule.usesProvidesCompleter =
2644                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2645                 } else {
2646                     currentModule.uses = List.nil();
2647                     currentModule.provides = List.nil();
2648                 }
2649             }
2650         } catch (IOException | ClosedFileSystemException ex) {
2651             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2652         } catch (ArrayIndexOutOfBoundsException ex) {
2653             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2654         } finally {
2655             interimUses = List.nil();
2656             interimProvides = List.nil();
2657             missingTypeVariables = List.nil();
2658             foundTypeVariables = List.nil();
2659             filling = false;
2660         }
2661     }
2662 
2663     /** We can only read a single class file at a time; this
2664      *  flag keeps track of when we are currently reading a class
2665      *  file.
2666      */
2667     public boolean filling = false;
2668 
2669 /************************************************************************
2670  * Adjusting flags
2671  ***********************************************************************/
2672 
2673     long adjustFieldFlags(long flags) {
2674         return flags;
2675     }
2676 
2677     long adjustMethodFlags(long flags) {
2678         if ((flags &amp; ACC_BRIDGE) != 0) {
2679             flags &amp;= ~ACC_BRIDGE;
2680             flags |= BRIDGE;
2681         }
2682         if ((flags &amp; ACC_VARARGS) != 0) {
2683             flags &amp;= ~ACC_VARARGS;
2684             flags |= VARARGS;
2685         }
2686         return flags;
2687     }
2688 
2689     long adjustClassFlags(long flags) {
2690         if ((flags &amp; ACC_MODULE) != 0) {
2691             flags &amp;= ~ACC_MODULE;
2692             flags |= MODULE;
2693         }
2694         return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
2695     }
2696 
2697     /**
2698      * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
2699      * The attribute is only the last component of the original filename, so is unlikely
2700      * to be valid as is, so operations other than those to access the name throw
2701      * UnsupportedOperationException
2702      */
2703     private static class SourceFileObject implements JavaFileObject {
2704 
2705         /** The file&#39;s name.
2706          */
2707         private final Name name;
2708 
2709         public SourceFileObject(Name name) {
2710             this.name = name;
2711         }
2712 
2713         @Override @DefinedBy(Api.COMPILER)
2714         public URI toUri() {
2715             try {
2716                 return new URI(null, name.toString(), null);
2717             } catch (URISyntaxException e) {
2718                 throw new PathFileObject.CannotCreateUriError(name.toString(), e);
2719             }
2720         }
2721 
2722         @Override @DefinedBy(Api.COMPILER)
2723         public String getName() {
2724             return name.toString();
2725         }
2726 
2727         @Override @DefinedBy(Api.COMPILER)
2728         public JavaFileObject.Kind getKind() {
2729             return BaseFileManager.getKind(getName());
2730         }
2731 
2732         @Override @DefinedBy(Api.COMPILER)
2733         public InputStream openInputStream() {
2734             throw new UnsupportedOperationException();
2735         }
2736 
2737         @Override @DefinedBy(Api.COMPILER)
2738         public OutputStream openOutputStream() {
2739             throw new UnsupportedOperationException();
2740         }
2741 
2742         @Override @DefinedBy(Api.COMPILER)
2743         public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
2744             throw new UnsupportedOperationException();
2745         }
2746 
2747         @Override @DefinedBy(Api.COMPILER)
2748         public Reader openReader(boolean ignoreEncodingErrors) {
2749             throw new UnsupportedOperationException();
2750         }
2751 
2752         @Override @DefinedBy(Api.COMPILER)
2753         public Writer openWriter() {
2754             throw new UnsupportedOperationException();
2755         }
2756 
2757         @Override @DefinedBy(Api.COMPILER)
2758         public long getLastModified() {
2759             throw new UnsupportedOperationException();
2760         }
2761 
2762         @Override @DefinedBy(Api.COMPILER)
2763         public boolean delete() {
2764             throw new UnsupportedOperationException();
2765         }
2766 
2767         @Override @DefinedBy(Api.COMPILER)
2768         public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
2769             return true; // fail-safe mode
2770         }
2771 
2772         @Override @DefinedBy(Api.COMPILER)
2773         public NestingKind getNestingKind() {
2774             return null;
2775         }
2776 
2777         @Override @DefinedBy(Api.COMPILER)
2778         public Modifier getAccessLevel() {
2779             return null;
2780         }
2781 
2782         /**
2783          * Check if two file objects are equal.
2784          * SourceFileObjects are just placeholder objects for the value of a
2785          * SourceFile attribute, and do not directly represent specific files.
2786          * Two SourceFileObjects are equal if their names are equal.
2787          */
2788         @Override
2789         public boolean equals(Object other) {
2790             if (this == other)
2791                 return true;
2792 
2793             if (!(other instanceof SourceFileObject))
2794                 return false;
2795 
2796             SourceFileObject o = (SourceFileObject) other;
2797             return name.equals(o.name);
2798         }
2799 
2800         @Override
2801         public int hashCode() {
2802             return name.hashCode();
2803         }
2804     }
2805 
2806     private class CompleterDeproxy implements AnnotationTypeCompleter {
2807         ClassSymbol proxyOn;
2808         CompoundAnnotationProxy target;
2809         CompoundAnnotationProxy repeatable;
2810 
2811         public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
2812                 CompoundAnnotationProxy repeatable)
2813         {
2814             this.proxyOn = c;
2815             this.target = target;
2816             this.repeatable = repeatable;
2817         }
2818 
2819         @Override
2820         public void complete(ClassSymbol sym) {
2821             Assert.check(proxyOn == sym);
2822             Attribute.Compound theTarget = null, theRepeatable = null;
2823             AnnotationDeproxy deproxy;
2824 
2825             try {
2826                 if (target != null) {
2827                     deproxy = new AnnotationDeproxy(proxyOn);
2828                     theTarget = deproxy.deproxyCompound(target);
2829                 }
2830 
2831                 if (repeatable != null) {
2832                     deproxy = new AnnotationDeproxy(proxyOn);
2833                     theRepeatable = deproxy.deproxyCompound(repeatable);
2834                 }
2835             } catch (Exception e) {
2836                 throw new CompletionFailure(sym,
2837                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
2838                                             dcfh);
2839             }
2840 
2841             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2842             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2843         }
2844     }
2845 
2846     private class ProxyType extends Type {
2847 
2848         private final Name name;
2849 
2850         public ProxyType(int index) {
2851             super(syms.noSymbol, TypeMetadata.EMPTY);
2852             this.name = poolReader.getName(index);
2853         }
2854 
2855         @Override
2856         public TypeTag getTag() {
2857             return TypeTag.NONE;
2858         }
2859 
2860         @Override
2861         public Type cloneWithMetadata(TypeMetadata metadata) {
2862             throw new UnsupportedOperationException();
2863         }
2864 
2865         public Type resolve() {
2866             return name.map(ClassReader.this::sigToType);
2867         }
2868 
2869         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2870         public String toString() {
2871             return &quot;&lt;ProxyType&gt;&quot;;
2872         }
2873 
2874     }
2875 
2876     private static final class InterimUsesDirective {
2877         public final Name service;
2878 
2879         public InterimUsesDirective(Name service) {
2880             this.service = service;
2881         }
2882 
2883     }
2884 
2885     private static final class InterimProvidesDirective {
2886         public final Name service;
2887         public final List&lt;Name&gt; impls;
2888 
2889         public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
2890             this.service = service;
2891             this.impls = impls;
2892         }
2893 
2894     }
2895 
2896     private final class UsesProvidesCompleter implements Completer {
2897         private final ModuleSymbol currentModule;
2898         private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
2899         private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
2900 
2901         public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
2902             this.currentModule = currentModule;
2903             this.interimUsesCopy = interimUsesCopy;
2904             this.interimProvidesCopy = interimProvidesCopy;
2905         }
2906 
2907         @Override
2908         public void complete(Symbol sym) throws CompletionFailure {
2909             ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
2910             directives.addAll(currentModule.directives);
2911             ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
2912             for (InterimUsesDirective interim : interimUsesCopy) {
2913                 UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
2914                 uses.add(d);
2915                 directives.add(d);
2916             }
2917             currentModule.uses = uses.toList();
2918             ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
2919             for (InterimProvidesDirective interim : interimProvidesCopy) {
2920                 ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
2921                 for (Name impl : interim.impls) {
2922                     impls.append(syms.enterClass(currentModule, impl));
2923                 }
2924                 ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
2925                                                             impls.toList());
2926                 provides.add(d);
2927                 directives.add(d);
2928             }
2929             currentModule.provides = provides.toList();
2930             currentModule.directives = directives.toList();
2931         }
2932     }
2933 }
    </pre>
  </body>
</html>